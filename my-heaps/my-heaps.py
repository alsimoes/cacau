# Generated by Haxe 4.2.1
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import functools as python_lib_Functools
from threading import RLock as sys_thread__Mutex_NativeRLock
import threading
import timeit as python_lib_Timeit
import sys as python_lib_Sys
import builtins as python_lib_Builtins
import json as python_lib_Json
import os as python_lib_Os
import random as python_lib_Random
import re as python_lib_Re
import shutil as python_lib_Shutil
import subprocess as python_lib_Subprocess
import time as python_lib_Time
import traceback as python_lib_Traceback
from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
from io import StringIO as python_lib_io_StringIO
import urllib.parse as python_lib_urllib_Parse
from threading import Semaphore as Lock


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



_hx_classes = {}


class Enum:
    _hx_class_name = "Enum"
    _hx_is_interface = "False"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tag = None
        _hx_o.index = None
        _hx_o.params = None
Enum._hx_class = Enum
_hx_classes["Enum"] = Enum


class Class: pass


class Date:
    _hx_class_name = "Date"
    _hx_is_interface = "False"
    __slots__ = ("date", "dateUTC")
    _hx_fields = ["date", "dateUTC"]
    _hx_methods = ["toString"]
    _hx_statics = ["now", "fromTime", "makeLocal", "fromString"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        self.dateUTC = None
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = Date.makeLocal(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0))
        self.dateUTC = self.date.astimezone(python_lib_datetime_Timezone.utc)

    def toString(self):
        return self.date.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def now():
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.now())
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def fromTime(t):
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.fromtimestamp((t / 1000.0)))
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def makeLocal(date):
        try:
            return date.astimezone()
        except BaseException as _g:
            None
            tzinfo = python_lib_datetime_Datetime.now(python_lib_datetime_Timezone.utc).astimezone().tzinfo
            return date.replace(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'tzinfo': tzinfo})))

    @staticmethod
    def fromString(s):
        _g = len(s)
        if (_g == 8):
            k = s.split(":")
            return Date.fromTime((((Std.parseInt((k[0] if 0 < len(k) else None)) * 3600000.) + ((Std.parseInt((k[1] if 1 < len(k) else None)) * 60000.))) + ((Std.parseInt((k[2] if 2 < len(k) else None)) * 1000.))))
        elif (_g == 10):
            k = s.split("-")
            return Date(Std.parseInt((k[0] if 0 < len(k) else None)),(Std.parseInt((k[1] if 1 < len(k) else None)) - 1),Std.parseInt((k[2] if 2 < len(k) else None)),0,0,0)
        elif (_g == 19):
            k = s.split(" ")
            _this = (k[0] if 0 < len(k) else None)
            y = _this.split("-")
            _this = (k[1] if 1 < len(k) else None)
            t = _this.split(":")
            return Date(Std.parseInt((y[0] if 0 < len(y) else None)),(Std.parseInt((y[1] if 1 < len(y) else None)) - 1),Std.parseInt((y[2] if 2 < len(y) else None)),Std.parseInt((t[0] if 0 < len(t) else None)),Std.parseInt((t[1] if 1 < len(t) else None)),Std.parseInt((t[2] if 2 < len(t) else None)))
        else:
            raise haxe_Exception.thrown(("Invalid date format : " + ("null" if s is None else s)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.date = None
        _hx_o.dateUTC = None
Date._hx_class = Date
_hx_classes["Date"] = Date


class EReg:
    _hx_class_name = "EReg"
    _hx_is_interface = "False"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]
    _hx_methods = ["matchSub", "replace", "map"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def matchSub(self,s,pos,_hx_len = None):
        if (_hx_len is None):
            _hx_len = -1
        if (_hx_len != -1):
            self.matchObj = self.pattern.search(s,pos,(pos + _hx_len))
        else:
            self.matchObj = self.pattern.search(s,pos)
        return (self.matchObj is not None)

    def replace(self,s,by):
        _this = by.split("$$")
        by = "_hx_#repl#__".join([python_Boot.toString1(x1,'') for x1 in _this])
        def _hx_local_0(x):
            res = by
            g = x.groups()
            _g = 0
            _g1 = len(g)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                gs = g[i]
                if (gs is None):
                    continue
                delimiter = ("$" + HxOverrides.stringOrNull(str((i + 1))))
                _this = (list(res) if ((delimiter == "")) else res.split(delimiter))
                res = gs.join([python_Boot.toString1(x1,'') for x1 in _this])
            _this = res.split("_hx_#repl#__")
            res = "$".join([python_Boot.toString1(x1,'') for x1 in _this])
            return res
        replace = _hx_local_0
        return python_lib_Re.sub(self.pattern,replace,s,(0 if (self._hx_global) else 1))

    def map(self,s,f):
        buf_b = python_lib_io_StringIO()
        pos = 0
        right = s
        cur = self
        while (pos < len(s)):
            if (self.matchObj is None):
                self.matchObj = python_lib_Re.search(self.pattern,s)
            else:
                self.matchObj = self.matchObj.re.search(s,pos)
            if (self.matchObj is None):
                break
            pos1 = self.matchObj.end()
            curPos_pos = cur.matchObj.start()
            curPos_len = (cur.matchObj.end() - cur.matchObj.start())
            buf_b.write(Std.string(HxString.substr(HxString.substr(cur.matchObj.string,0,cur.matchObj.start()),pos,None)))
            buf_b.write(Std.string(f(cur)))
            right = HxString.substr(cur.matchObj.string,cur.matchObj.end(),None)
            if (not self._hx_global):
                buf_b.write(Std.string(right))
                return buf_b.getvalue()
            if (curPos_len == 0):
                buf_b.write(Std.string(("" if (((pos1 < 0) or ((pos1 >= len(s))))) else s[pos1])))
                right = HxString.substr(right,1,None)
                pos = (pos1 + 1)
            else:
                pos = pos1
        buf_b.write(Std.string(right))
        return buf_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o.matchObj = None
        _hx_o._hx_global = None
EReg._hx_class = EReg
_hx_classes["EReg"] = EReg


class h3d_IDrawable:
    _hx_class_name = "h3d.IDrawable"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["render"]
h3d_IDrawable._hx_class = h3d_IDrawable
_hx_classes["h3d.IDrawable"] = h3d_IDrawable


class hxd_App:
    _hx_class_name = "hxd.App"
    _hx_is_interface = "False"
    __slots__ = ("engine", "s3d", "s2d", "sevents", "isDisposed")
    _hx_fields = ["engine", "s3d", "s2d", "sevents", "isDisposed"]
    _hx_methods = ["onResize", "setScene", "setCurrent", "setScene2D", "setScene3D", "render", "setup", "dispose", "loadAssets", "init", "mainLoop", "update"]
    _hx_statics = ["staticHandler"]
    _hx_interfaces = [h3d_IDrawable]

    def __init__(self):
        self.isDisposed = None
        self.sevents = None
        self.s2d = None
        self.s3d = None
        self.engine = None
        _gthis = self
        engine = h3d_Engine.CURRENT
        if (engine is not None):
            self.engine = engine
            engine.onReady = self.setup
            haxe_Timer.delay(self.setup,0)
        else:
            def _hx_local_0():
                nonlocal engine
                engine = h3d_Engine()
                _gthis.engine = engine
                engine.onReady = _gthis.setup
                engine.init()
            hxd_System.start(_hx_local_0)

    def onResize(self):
        pass

    def setScene(self,scene,disposePrevious = None):
        if (disposePrevious is None):
            disposePrevious = True
        new2D = Std.downcast(scene,h2d_Scene)
        new3D = Std.downcast(scene,h3d_scene_Scene)
        if (new2D is not None):
            self.sevents.removeScene(self.s2d)
            self.sevents.addScene(scene,0)
        else:
            if (new3D is not None):
                self.sevents.removeScene(self.s3d)
            self.sevents.addScene(scene)
        if disposePrevious:
            if (new2D is not None):
                self.s2d.dispose()
            elif (new3D is not None):
                self.s3d.dispose()
            else:
                raise haxe_Exception.thrown("Can't dispose previous scene")
        if (new2D is not None):
            self.s2d = new2D
        if (new3D is not None):
            self.s3d = new3D

    def setCurrent(self):
        _gthis = self
        self.engine = h3d_Engine.CURRENT
        self.isDisposed = False
        self.engine.onReady = hxd_App.staticHandler
        def _hx_local_0():
            if (_gthis.s2d is None):
                return
            _gthis.s2d.checkResize()
            _gthis.onResize()
        self.engine.onResized = _hx_local_0
        hxd_System.setLoop(self.mainLoop)

    def setScene2D(self,s2d,disposePrevious = None):
        if (disposePrevious is None):
            disposePrevious = True
        self.sevents.removeScene(self.s2d)
        self.sevents.addScene(s2d,0)
        if disposePrevious:
            self.s2d.dispose()
        self.s2d = s2d

    def setScene3D(self,s3d,disposePrevious = None):
        if (disposePrevious is None):
            disposePrevious = True
        self.sevents.removeScene(self.s3d)
        self.sevents.addScene(s3d)
        if disposePrevious:
            self.s3d.dispose()
        self.s3d = s3d

    def render(self,e):
        self.s3d.render(e)
        self.s2d.render(e)

    def setup(self):
        _gthis = self
        initDone = False
        self.engine.onReady = hxd_App.staticHandler
        def _hx_local_0():
            if (_gthis.s2d is None):
                return
            _gthis.s2d.checkResize()
            if initDone:
                _gthis.onResize()
        self.engine.onResized = _hx_local_0
        self.s3d = h3d_scene_Scene()
        self.s2d = h2d_Scene()
        self.sevents = hxd_SceneEvents()
        self.sevents.addScene(self.s2d)
        self.sevents.addScene(self.s3d)
        def _hx_local_1():
            nonlocal initDone
            initDone = True
            _gthis.init()
            hxd_Timer.skip()
            _gthis.mainLoop()
            hxd_System.setLoop(_gthis.mainLoop)
            hxd_Key.initialize()
        self.loadAssets(_hx_local_1)

    def dispose(self):
        self.engine.onResized = hxd_App.staticHandler
        self.engine.onContextLost = hxd_App.staticHandler
        self.isDisposed = True
        if (self.s2d is not None):
            self.s2d.dispose()
        if (self.s3d is not None):
            self.s3d.dispose()
        if (self.sevents is not None):
            self.sevents.dispose()

    def loadAssets(self,onLoaded):
        onLoaded()

    def init(self):
        pass

    def mainLoop(self):
        hxd_Timer.update()
        self.sevents.checkEvents()
        if self.isDisposed:
            return
        self.update(hxd_Timer.dt)
        if self.isDisposed:
            return
        dt = hxd_Timer.dt
        if (self.s2d is not None):
            self.s2d.setElapsedTime(dt)
        if (self.s3d is not None):
            self.s3d.setElapsedTime(dt)
        self.engine.render(self)

    def update(self,dt):
        pass

    @staticmethod
    def staticHandler():
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.engine = None
        _hx_o.s3d = None
        _hx_o.s2d = None
        _hx_o.sevents = None
        _hx_o.isDisposed = None
hxd_App._hx_class = hxd_App
_hx_classes["hxd.App"] = hxd_App


class Game(hxd_App):
    _hx_class_name = "Game"
    _hx_is_interface = "False"
    __slots__ = ("screen",)
    _hx_fields = ["screen"]
    _hx_methods = ["init", "setScreen", "update"]
    _hx_statics = ["instance", "get_instance"]
    _hx_interfaces = []
    _hx_super = hxd_App


    def __init__(self):
        self.screen = None
        super().__init__()

    def init(self):
        haxe_Log.trace("Game init()",_hx_AnonObject({'fileName': "src/Game.hx", 'lineNumber': 19, 'className': "Game", 'methodName': "init"}))
        self.setScreen(screens_Menu())

    def setScreen(self,screen):
        self.setScene(screen)
        self.screen = screen
        screen.init()

    def update(self,dt):
        self.screen.update(dt)
    instance = None

    @staticmethod
    def get_instance():
        if (Game.instance is None):
            Game.instance = Game()
        return Game.instance

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.screen = None
Game._hx_class = Game
_hx_classes["Game"] = Game


class Lambda:
    _hx_class_name = "Lambda"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["array"]

    @staticmethod
    def array(it):
        a = list()
        i = HxOverrides.iterator(it)
        while i.hasNext():
            i1 = i.next()
            a.append(i1)
        return a
Lambda._hx_class = Lambda
_hx_classes["Lambda"] = Lambda


class Main(hxd_App):
    _hx_class_name = "Main"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["main"]
    _hx_interfaces = []
    _hx_super = hxd_App


    def __init__(self):
        super().__init__()

    @staticmethod
    def main():
        haxe_Log.trace("Main()",_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 3, 'className': "Main", 'methodName': "main"}))
        hxd_Res.set_loader(hxd_res_Loader(hxd_fs_LocalFileSystem("res",None)))
        Game.get_instance()
Main._hx_class = Main
_hx_classes["Main"] = Main


class Reflect:
    _hx_class_name = "Reflect"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["field", "setField", "callMethod", "isFunction", "compare", "compareMethods", "isObject", "isEnumValue", "deleteField"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def callMethod(o,func,args):
        if callable(func):
            return func(*args)
        else:
            return None

    @staticmethod
    def isFunction(f):
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return python_Boot.hasField(f,"func_code")
        else:
            return True

    @staticmethod
    def compare(a,b):
        if ((a is None) and ((b is None))):
            return 0
        if (a is None):
            return 1
        elif (b is None):
            return -1
        elif HxOverrides.eq(a,b):
            return 0
        elif (a > b):
            return 1
        else:
            return -1

    @staticmethod
    def compareMethods(f1,f2):
        if HxOverrides.eq(f1,f2):
            return True
        if (isinstance(f1,python_internal_MethodClosure) and isinstance(f2,python_internal_MethodClosure)):
            m1 = f1
            m2 = f2
            if HxOverrides.eq(m1.obj,m2.obj):
                return (m1.func == m2.func)
            else:
                return False
        if ((not Reflect.isFunction(f1)) or (not Reflect.isFunction(f2))):
            return False
        return False

    @staticmethod
    def isObject(v):
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 4):
            return True
        elif (tmp == 6):
            _g1 = _g.params[0]
            return True
        else:
            return False

    @staticmethod
    def isEnumValue(v):
        if not HxOverrides.eq(v,Enum):
            return isinstance(v,Enum)
        else:
            return False

    @staticmethod
    def deleteField(o,field):
        if (field in python_Boot.keywords):
            field = ("_hx_" + field)
        elif ((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95))):
            field = ("_hx_" + field)
        if (not python_Boot.hasField(o,field)):
            return False
        o.__delattr__(field)
        return True
Reflect._hx_class = Reflect
_hx_classes["Reflect"] = Reflect


class Std:
    _hx_class_name = "Std"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["downcast", "is", "isOfType", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def downcast(value,c):
        try:
            tmp = None
            if (not isinstance(value,c)):
                if c._hx_is_interface:
                    cls = c
                    loop = None
                    def _hx_local_1(intf):
                        f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                        if (f is not None):
                            _g = 0
                            while (_g < len(f)):
                                i = (f[_g] if _g >= 0 and _g < len(f) else None)
                                _g = (_g + 1)
                                if (i == cls):
                                    return True
                                else:
                                    l = loop(i)
                                    if l:
                                        return True
                            return False
                        else:
                            return False
                    loop = _hx_local_1
                    currentClass = value.__class__
                    result = False
                    while (currentClass is not None):
                        if loop(currentClass):
                            result = True
                            break
                        currentClass = python_Boot.getSuperClass(currentClass)
                    tmp = result
                else:
                    tmp = False
            else:
                tmp = True
            if tmp:
                return value
            else:
                return None
        except BaseException as _g:
            None
            return None

    @staticmethod
    def _hx_is(v,t):
        return Std.isOfType(v,t)

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except BaseException as _g:
            None
            base = 10
            _hx_len = len(x)
            foundCount = 0
            sign = 0
            firstDigitIndex = 0
            lastDigitIndex = -1
            previous = 0
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                c = (-1 if ((i >= len(x))) else ord(x[i]))
                if (((c > 8) and ((c < 14))) or ((c == 32))):
                    if (foundCount > 0):
                        return None
                    continue
                else:
                    c1 = c
                    if (c1 == 43):
                        if (foundCount == 0):
                            sign = 1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 45):
                        if (foundCount == 0):
                            sign = -1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 48):
                        if (not (((foundCount == 0) or (((foundCount == 1) and ((sign != 0))))))):
                            if (not (((48 <= c) and ((c <= 57))))):
                                if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                    break
                    elif ((c1 == 120) or ((c1 == 88))):
                        if ((previous == 48) and ((((foundCount == 1) and ((sign == 0))) or (((foundCount == 2) and ((sign != 0))))))):
                            base = 16
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (not (((48 <= c) and ((c <= 57))))):
                        if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                            break
                if (((foundCount == 0) and ((sign == 0))) or (((foundCount == 1) and ((sign != 0))))):
                    firstDigitIndex = i
                foundCount = (foundCount + 1)
                lastDigitIndex = i
                previous = c
            if (firstDigitIndex <= lastDigitIndex):
                digits = HxString.substring(x,firstDigitIndex,(lastDigitIndex + 1))
                try:
                    return (((-1 if ((sign == -1)) else 1)) * int(digits,base))
                except BaseException as _g:
                    return None
            return None

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except BaseException as _g:
            None
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN
Std._hx_class = Std
_hx_classes["Std"] = Std


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
StringBuf._hx_class = StringBuf
_hx_classes["StringBuf"] = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["htmlEscape", "isSpace", "ltrim", "rtrim", "trim", "lpad", "replace", "hex"]

    @staticmethod
    def htmlEscape(s,quotes = None):
        buf_b = python_lib_io_StringIO()
        _g_offset = 0
        _g_s = s
        while (_g_offset < len(_g_s)):
            index = _g_offset
            _g_offset = (_g_offset + 1)
            code = ord(_g_s[index])
            code1 = code
            if (code1 == 34):
                if quotes:
                    buf_b.write("&quot;")
                else:
                    buf_b.write("".join(map(chr,[code])))
            elif (code1 == 38):
                buf_b.write("&amp;")
            elif (code1 == 39):
                if quotes:
                    buf_b.write("&#039;")
                else:
                    buf_b.write("".join(map(chr,[code])))
            elif (code1 == 60):
                buf_b.write("&lt;")
            elif (code1 == 62):
                buf_b.write("&gt;")
            else:
                buf_b.write("".join(map(chr,[code])))
        return buf_b.getvalue()

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))

    @staticmethod
    def lpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        l = (l - len(s))
        while (buf.get_length() < l):
            s1 = Std.string(c)
            buf.b.write(s1)
        s1 = Std.string(s)
        buf.b.write(s1)
        return buf.b.getvalue()

    @staticmethod
    def replace(s,sub,by):
        _this = (list(s) if ((sub == "")) else s.split(sub))
        return by.join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def hex(n,digits = None):
        s = ""
        hexChars = "0123456789ABCDEF"
        while True:
            index = (n & 15)
            s = (HxOverrides.stringOrNull((("" if (((index < 0) or ((index >= len(hexChars))))) else hexChars[index]))) + ("null" if s is None else s))
            n = HxOverrides.rshift(n, 4)
            if (not ((n > 0))):
                break
        if ((digits is not None) and ((len(s) < digits))):
            diff = (digits - len(s))
            _g = 0
            _g1 = diff
            while (_g < _g1):
                _ = _g
                _g = (_g + 1)
                s = ("0" + ("null" if s is None else s))
        return s
StringTools._hx_class = StringTools
_hx_classes["StringTools"] = StringTools


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["exists", "stat", "rename", "fullPath", "isDirectory", "createDirectory", "deleteFile", "readDirectory"]

    @staticmethod
    def exists(path):
        return python_lib_os_Path.exists(path)

    @staticmethod
    def stat(path):
        s = python_lib_Os.stat(path)
        return _hx_AnonObject({'gid': s.st_gid, 'uid': s.st_uid, 'atime': Date.fromTime((1000 * s.st_atime)), 'mtime': Date.fromTime((1000 * s.st_mtime)), 'ctime': Date.fromTime((1000 * s.st_ctime)), 'size': s.st_size, 'dev': s.st_dev, 'ino': s.st_ino, 'nlink': s.st_nlink, 'rdev': getattr(s,"st_rdev",0), 'mode': s.st_mode})

    @staticmethod
    def rename(path,newPath):
        python_lib_Os.rename(path,newPath)

    @staticmethod
    def fullPath(relPath):
        return python_lib_os_Path.realpath(relPath)

    @staticmethod
    def isDirectory(path):
        return python_lib_os_Path.isdir(path)

    @staticmethod
    def createDirectory(path):
        python_lib_Os.makedirs(path,511,True)

    @staticmethod
    def deleteFile(path):
        python_lib_Os.remove(path)

    @staticmethod
    def readDirectory(path):
        return python_lib_Os.listdir(path)
sys_FileSystem._hx_class = sys_FileSystem
_hx_classes["sys.FileSystem"] = sys_FileSystem


class Sys:
    _hx_class_name = "Sys"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["environ", "get_environ", "getEnv", "systemName", "command", "_programPath", "programPath"]
    environ = None

    @staticmethod
    def get_environ():
        _g = Sys.environ
        if (_g is None):
            environ = haxe_ds_StringMap()
            env = python_lib_Os.environ
            key = python_HaxeIterator(iter(env.keys()))
            while key.hasNext():
                key1 = key.next()
                value = env.get(key1,None)
                environ.h[key1] = value
            def _hx_local_1():
                def _hx_local_0():
                    Sys.environ = environ
                    return Sys.environ
                return _hx_local_0()
            return _hx_local_1()
        else:
            env = _g
            return env

    @staticmethod
    def getEnv(s):
        return Sys.get_environ().h.get(s,None)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            else:
                raise haxe_Exception.thrown("not supported platform")

    @staticmethod
    def command(cmd,args = None):
        if (args is None):
            return python_lib_Subprocess.call(cmd,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'shell': True})))
        else:
            return python_lib_Subprocess.call(([cmd] + args))

    @staticmethod
    def programPath():
        return Sys._programPath
Sys._hx_class = Sys
_hx_classes["Sys"] = Sys

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"
    _hx_constructs = ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, (c,))

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, (e,))
ValueType.TNull = ValueType("TNull", 0, ())
ValueType.TInt = ValueType("TInt", 1, ())
ValueType.TFloat = ValueType("TFloat", 2, ())
ValueType.TBool = ValueType("TBool", 3, ())
ValueType.TObject = ValueType("TObject", 4, ())
ValueType.TFunction = ValueType("TFunction", 5, ())
ValueType.TUnknown = ValueType("TUnknown", 8, ())
ValueType._hx_class = ValueType
_hx_classes["ValueType"] = ValueType


class Type:
    _hx_class_name = "Type"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getClass", "getSuperClass", "getClassName", "getEnumName", "resolveClass", "resolveEnum", "createEmptyInstance", "createEnum", "createEnumIndex", "getEnumConstructs", "typeof", "enumEq", "allEnums"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        o1 = o
        if ((o1 is not None) and ((HxOverrides.eq(o1,str) or python_lib_Inspect.isclass(o1)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,"_hx_class"):
            return o._hx_class
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getSuperClass(c):
        return python_Boot.getSuperClass(c)

    @staticmethod
    def getClassName(c):
        if hasattr(c,"_hx_class_name"):
            return c._hx_class_name
        else:
            if (c == list):
                return "Array"
            if (c == Math):
                return "Math"
            if (c == str):
                return "String"
            try:
                return c.__name__
            except BaseException as _g:
                None
                return None

    @staticmethod
    def getEnumName(e):
        return e._hx_class_name

    @staticmethod
    def resolveClass(name):
        if (name == "Array"):
            return list
        if (name == "Math"):
            return Math
        if (name == "String"):
            return str
        cl = _hx_classes.get(name,None)
        tmp = None
        if (cl is not None):
            o = cl
            tmp = (not (((o is not None) and ((HxOverrides.eq(o,str) or python_lib_Inspect.isclass(o))))))
        else:
            tmp = True
        if tmp:
            return None
        return cl

    @staticmethod
    def resolveEnum(name):
        if (name == "Bool"):
            return Bool
        o = Type.resolveClass(name)
        if hasattr(o,"_hx_constructs"):
            return o
        else:
            return None

    @staticmethod
    def createEmptyInstance(cl):
        i = cl.__new__(cl)
        callInit = None
        def _hx_local_0(cl):
            sc = Type.getSuperClass(cl)
            if (sc is not None):
                callInit(sc)
            if hasattr(cl,"_hx_empty_init"):
                cl._hx_empty_init(i)
        callInit = _hx_local_0
        callInit(cl)
        return i

    @staticmethod
    def createEnum(e,constr,params = None):
        f = Reflect.field(e,constr)
        if (f is None):
            raise haxe_Exception.thrown(("No such constructor " + ("null" if constr is None else constr)))
        if Reflect.isFunction(f):
            if (params is None):
                raise haxe_Exception.thrown((("Constructor " + ("null" if constr is None else constr)) + " need parameters"))
            return Reflect.callMethod(e,f,params)
        if ((params is not None) and ((len(params) != 0))):
            raise haxe_Exception.thrown((("Constructor " + ("null" if constr is None else constr)) + " does not need parameters"))
        return f

    @staticmethod
    def createEnumIndex(e,index,params = None):
        c = python_internal_ArrayImpl._get(e._hx_constructs, index)
        if (c is None):
            raise haxe_Exception.thrown((Std.string(index) + " is not a valid enum constructor index"))
        return Type.createEnum(e,c,params)

    @staticmethod
    def getEnumConstructs(e):
        if hasattr(e,"_hx_constructs"):
            x = e._hx_constructs
            return list(x)
        else:
            return []

    @staticmethod
    def typeof(v):
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown

    @staticmethod
    def enumEq(a,b):
        if HxOverrides.eq(a,b):
            return True
        try:
            if ((b is None) and (not HxOverrides.eq(a,b))):
                return False
            if (a.tag != b.tag):
                return False
            p1 = a.params
            p2 = b.params
            if (len(p1) != len(p2)):
                return False
            _g = 0
            _g1 = len(p1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (not Type.enumEq(p1[i],p2[i])):
                    return False
            if (a._hx_class != b._hx_class):
                return False
        except BaseException as _g:
            None
            return False
        return True

    @staticmethod
    def allEnums(e):
        ctors = Type.getEnumConstructs(e)
        ret = []
        _g = 0
        while (_g < len(ctors)):
            ctor = (ctors[_g] if _g >= 0 and _g < len(ctors) else None)
            _g = (_g + 1)
            v = Reflect.field(e,ctor)
            if Std.isOfType(v,e):
                ret.append(v)
        return ret
Type._hx_class = Type
_hx_classes["Type"] = Type


class _Xml_XmlType_Impl_:
    _hx_class_name = "_Xml.XmlType_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(this1):
        _g = this1
        if (_g == 0):
            return "Element"
        elif (_g == 1):
            return "PCData"
        elif (_g == 2):
            return "CData"
        elif (_g == 3):
            return "Comment"
        elif (_g == 4):
            return "DocType"
        elif (_g == 5):
            return "ProcessingInstruction"
        elif (_g == 6):
            return "Document"
        else:
            pass
_Xml_XmlType_Impl_._hx_class = _Xml_XmlType_Impl_
_hx_classes["_Xml.XmlType_Impl_"] = _Xml_XmlType_Impl_


class Xml:
    _hx_class_name = "Xml"
    _hx_is_interface = "False"
    __slots__ = ("nodeType", "nodeName", "nodeValue", "parent", "children", "attributeMap")
    _hx_fields = ["nodeType", "nodeName", "nodeValue", "parent", "children", "attributeMap"]
    _hx_methods = ["get", "set", "exists", "attributes", "elements", "elementsNamed", "firstElement", "addChild", "removeChild", "toString"]
    _hx_statics = ["Element", "PCData", "CData", "Comment", "DocType", "ProcessingInstruction", "Document", "parse", "createElement", "createPCData", "createCData", "createComment", "createDocType", "createProcessingInstruction", "createDocument"]

    def __init__(self,nodeType):
        self.parent = None
        self.nodeValue = None
        self.nodeName = None
        self.nodeType = nodeType
        self.children = []
        self.attributeMap = haxe_ds_StringMap()

    def get(self,att):
        if (self.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        return self.attributeMap.h.get(att,None)

    def set(self,att,value):
        if (self.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        self.attributeMap.h[att] = value

    def exists(self,att):
        if (self.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        return (att in self.attributeMap.h)

    def attributes(self):
        if (self.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        return self.attributeMap.keys()

    def elements(self):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        _g = []
        _g1 = 0
        _g2 = self.children
        while (_g1 < len(_g2)):
            child = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            if (child.nodeType == Xml.Element):
                _g.append(child)
        ret = _g
        return haxe_iterators_ArrayIterator(ret)

    def elementsNamed(self,name):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        _g = []
        _g1 = 0
        _g2 = self.children
        while (_g1 < len(_g2)):
            child = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            tmp = None
            if (child.nodeType == Xml.Element):
                if (child.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((child.nodeType is None)) else _Xml_XmlType_Impl_.toString(child.nodeType))))))
                tmp = (child.nodeName == name)
            else:
                tmp = False
            if tmp:
                _g.append(child)
        ret = _g
        return haxe_iterators_ArrayIterator(ret)

    def firstElement(self):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            child = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (child.nodeType == Xml.Element):
                return child
        return None

    def addChild(self,x):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        if (x.parent is not None):
            x.parent.removeChild(x)
        _this = self.children
        _this.append(x)
        x.parent = self

    def removeChild(self,x):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        if python_internal_ArrayImpl.remove(self.children,x):
            x.parent = None
            return True
        return False

    def toString(self):
        return haxe_xml_Printer.print(self)

    @staticmethod
    def parse(_hx_str):
        return haxe_xml_Parser.parse(_hx_str)

    @staticmethod
    def createElement(name):
        xml = Xml(Xml.Element)
        if (xml.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeName = name
        return xml

    @staticmethod
    def createPCData(data):
        xml = Xml(Xml.PCData)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createCData(data):
        xml = Xml(Xml.CData)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createComment(data):
        xml = Xml(Xml.Comment)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createDocType(data):
        xml = Xml(Xml.DocType)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createProcessingInstruction(data):
        xml = Xml(Xml.ProcessingInstruction)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createDocument():
        return Xml(Xml.Document)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nodeType = None
        _hx_o.nodeName = None
        _hx_o.nodeValue = None
        _hx_o.parent = None
        _hx_o.children = None
        _hx_o.attributeMap = None
Xml._hx_class = Xml
_hx_classes["Xml"] = Xml

class format_gif_Block(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.Block"
    _hx_constructs = ["BFrame", "BExtension", "BEOF"]

    @staticmethod
    def BFrame(frame):
        return format_gif_Block("BFrame", 0, (frame,))

    @staticmethod
    def BExtension(extension):
        return format_gif_Block("BExtension", 1, (extension,))
format_gif_Block.BEOF = format_gif_Block("BEOF", 2, ())
format_gif_Block._hx_class = format_gif_Block
_hx_classes["format.gif.Block"] = format_gif_Block

class format_gif_Extension(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.Extension"
    _hx_constructs = ["EGraphicControl", "EComment", "EText", "EApplicationExtension", "EUnknown"]

    @staticmethod
    def EGraphicControl(gce):
        return format_gif_Extension("EGraphicControl", 0, (gce,))

    @staticmethod
    def EComment(text):
        return format_gif_Extension("EComment", 1, (text,))

    @staticmethod
    def EText(pte):
        return format_gif_Extension("EText", 2, (pte,))

    @staticmethod
    def EApplicationExtension(ext):
        return format_gif_Extension("EApplicationExtension", 3, (ext,))

    @staticmethod
    def EUnknown(id,data):
        return format_gif_Extension("EUnknown", 4, (id,data))
format_gif_Extension._hx_class = format_gif_Extension
_hx_classes["format.gif.Extension"] = format_gif_Extension

class format_gif_ApplicationExtension(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.ApplicationExtension"
    _hx_constructs = ["AENetscapeLooping", "AEUnknown"]

    @staticmethod
    def AENetscapeLooping(loops):
        return format_gif_ApplicationExtension("AENetscapeLooping", 0, (loops,))

    @staticmethod
    def AEUnknown(name,version,data):
        return format_gif_ApplicationExtension("AEUnknown", 1, (name,version,data))
format_gif_ApplicationExtension._hx_class = format_gif_ApplicationExtension
_hx_classes["format.gif.ApplicationExtension"] = format_gif_ApplicationExtension

class format_gif_Version(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.Version"
    _hx_constructs = ["GIF87a", "GIF89a", "Unknown"]

    @staticmethod
    def Unknown(version):
        return format_gif_Version("Unknown", 2, (version,))
format_gif_Version.GIF87a = format_gif_Version("GIF87a", 0, ())
format_gif_Version.GIF89a = format_gif_Version("GIF89a", 1, ())
format_gif_Version._hx_class = format_gif_Version
_hx_classes["format.gif.Version"] = format_gif_Version

class format_gif_DisposalMethod(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.DisposalMethod"
    _hx_constructs = ["UNSPECIFIED", "NO_ACTION", "FILL_BACKGROUND", "RENDER_PREVIOUS", "UNDEFINED"]

    @staticmethod
    def UNDEFINED(index):
        return format_gif_DisposalMethod("UNDEFINED", 4, (index,))
format_gif_DisposalMethod.UNSPECIFIED = format_gif_DisposalMethod("UNSPECIFIED", 0, ())
format_gif_DisposalMethod.NO_ACTION = format_gif_DisposalMethod("NO_ACTION", 1, ())
format_gif_DisposalMethod.FILL_BACKGROUND = format_gif_DisposalMethod("FILL_BACKGROUND", 2, ())
format_gif_DisposalMethod.RENDER_PREVIOUS = format_gif_DisposalMethod("RENDER_PREVIOUS", 3, ())
format_gif_DisposalMethod._hx_class = format_gif_DisposalMethod
_hx_classes["format.gif.DisposalMethod"] = format_gif_DisposalMethod


class format_gif_Reader:
    _hx_class_name = "format.gif.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i",)
    _hx_fields = ["i"]
    _hx_methods = ["read", "readBlock", "readImage", "readPixels", "deinterlace", "readExtension", "readApplicationExtension", "readBlocks", "readColorTable"]

    def __init__(self,i):
        self.i = i
        i.set_bigEndian(False)

    def read(self):
        b = 71
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 73
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 70
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        gifVer = self.i.readString(3)
        version = format_gif_Version.GIF89a
        gifVer1 = gifVer
        if (gifVer1 == "87a"):
            version = format_gif_Version.GIF87a
        elif (gifVer1 == "89a"):
            version = format_gif_Version.GIF89a
        else:
            version = format_gif_Version.Unknown(gifVer)
        width = self.i.readUInt16()
        height = self.i.readUInt16()
        packedField = self.i.readByte()
        bgIndex = self.i.readByte()
        pixelAspectRatio = self.i.readByte()
        if (pixelAspectRatio != 0):
            pixelAspectRatio = (((pixelAspectRatio + 15)) / 64)
        else:
            pixelAspectRatio = 1
        lsd = _hx_AnonObject({'width': width, 'height': height, 'hasGlobalColorTable': (((packedField & 128)) == 128), 'colorResolution': HxOverrides.rshift(((packedField & 112)), 4), 'sorted': (((packedField & 8)) == 8), 'globalColorTableSize': (2 << ((packedField & 7))), 'backgroundColorIndex': bgIndex, 'pixelAspectRatio': pixelAspectRatio})
        gct = None
        if lsd.hasGlobalColorTable:
            gct = self.readColorTable(lsd.globalColorTableSize)
        blocks = haxe_ds_List()
        while True:
            b = self.readBlock()
            blocks.add(b)
            if (b == format_gif_Block.BEOF):
                break
        return _hx_AnonObject({'version': version, 'logicalScreenDescriptor': lsd, 'globalColorTable': gct, 'blocks': blocks})

    def readBlock(self):
        blockID = self.i.readByte()
        blockID1 = blockID
        if (blockID1 == 33):
            return self.readExtension()
        elif (blockID1 == 44):
            return self.readImage()
        elif (blockID1 == 59):
            return format_gif_Block.BEOF
        else:
            pass
        return format_gif_Block.BEOF

    def readImage(self):
        x = self.i.readUInt16()
        y = self.i.readUInt16()
        width = self.i.readUInt16()
        height = self.i.readUInt16()
        packed = self.i.readByte()
        localColorTable = (((packed & 128)) == 128)
        interlaced = (((packed & 64)) == 64)
        sorted = (((packed & 32)) == 32)
        localColorTableSize = (2 << ((packed & 7)))
        lct = None
        if localColorTable:
            lct = self.readColorTable(localColorTableSize)
        return format_gif_Block.BFrame(_hx_AnonObject({'x': x, 'y': y, 'width': width, 'height': height, 'localColorTable': localColorTable, 'interlaced': interlaced, 'sorted': sorted, 'localColorTableSize': localColorTableSize, 'pixels': self.readPixels(width,height,interlaced), 'colorTable': lct}))

    def readPixels(self,width,height,interlaced):
        input = self.i
        pixelsCount = (width * height)
        pixels = haxe_io_Bytes.alloc(pixelsCount)
        minCodeSize = input.readByte()
        blockSize = (input.readByte() - 1)
        bits = input.readByte()
        bitsCount = 8
        clearCode = (1 << minCodeSize)
        eoiCode = (clearCode + 1)
        codeSize = (minCodeSize + 1)
        codeSizeLimit = (1 << codeSize)
        codeMask = (codeSizeLimit - 1)
        baseDict = list()
        _g = 0
        _g1 = clearCode
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(baseDict, i, [i])
        _hx_dict = list()
        dictLen = (clearCode + 2)
        newRecord = None
        i = 0
        code = 0
        last = None
        while (i < pixelsCount):
            last = code
            while (bitsCount < codeSize):
                if (blockSize == 0):
                    break
                bits = (bits | ((input.readByte() << bitsCount)))
                bitsCount = (bitsCount + 8)
                blockSize = (blockSize - 1)
                if (blockSize == 0):
                    blockSize = input.readByte()
            code = (bits & codeMask)
            bits = (bits >> codeSize)
            bitsCount = (bitsCount - codeSize)
            if (code == clearCode):
                _hx_dict = list(baseDict)
                dictLen = (clearCode + 2)
                codeSize = (minCodeSize + 1)
                codeSizeLimit = (1 << codeSize)
                codeMask = (codeSizeLimit - 1)
                continue
            if (code == eoiCode):
                break
            if (code < dictLen):
                if (last != clearCode):
                    newRecord = list((_hx_dict[last] if last >= 0 and last < len(_hx_dict) else None))
                    newRecord.append(python_internal_ArrayImpl._get((_hx_dict[code] if code >= 0 and code < len(_hx_dict) else None), 0))
                    tmp = dictLen
                    dictLen = (dictLen + 1)
                    python_internal_ArrayImpl._set(_hx_dict, tmp, newRecord)
            else:
                if (code != dictLen):
                    raise haxe_Exception.thrown(((("Invalid LZW code. Excepted: " + Std.string(dictLen)) + ", got: ") + Std.string(code)))
                newRecord = list((_hx_dict[last] if last >= 0 and last < len(_hx_dict) else None))
                newRecord.append((newRecord[0] if 0 < len(newRecord) else None))
                tmp1 = dictLen
                dictLen = (dictLen + 1)
                python_internal_ArrayImpl._set(_hx_dict, tmp1, newRecord)
            newRecord = (_hx_dict[code] if code >= 0 and code < len(_hx_dict) else None)
            _g = 0
            while (_g < len(newRecord)):
                item = (newRecord[_g] if _g >= 0 and _g < len(newRecord) else None)
                _g = (_g + 1)
                pos = i
                i = (i + 1)
                pixels.b[pos] = (item & 255)
            if ((dictLen == codeSizeLimit) and ((codeSize < 12))):
                codeSize = (codeSize + 1)
                codeSizeLimit = (1 << codeSize)
                codeMask = (codeSizeLimit - 1)
        while (blockSize > 0):
            input.readByte()
            blockSize = (blockSize - 1)
            if (blockSize == 0):
                blockSize = input.readByte()
        while (i < pixelsCount):
            pos = i
            i = (i + 1)
            pixels.b[pos] = 0
        if interlaced:
            buffer = haxe_io_Bytes.alloc(pixelsCount)
            offset = self.deinterlace(pixels,buffer,8,0,0,width,height)
            offset = self.deinterlace(pixels,buffer,8,4,offset,width,height)
            offset = self.deinterlace(pixels,buffer,4,2,offset,width,height)
            self.deinterlace(pixels,buffer,2,1,offset,width,height)
            pixels = buffer
        return pixels

    def deinterlace(self,input,output,step,y,offset,width,height):
        while (y < height):
            output.blit((y * width),input,offset,width)
            offset = (offset + width)
            y = (y + step)
        return offset

    def readExtension(self):
        subId = self.i.readByte()
        subId1 = subId
        if (subId1 == 1):
            if (self.i.readByte() != 12):
                raise haxe_Exception.thrown("Incorrect size of Plain Text Extension introducer block.")
            tmp = self.i.readUInt16()
            tmp1 = self.i.readUInt16()
            tmp2 = self.i.readUInt16()
            tmp3 = self.i.readUInt16()
            tmp4 = self.i.readByte()
            tmp5 = self.i.readByte()
            tmp6 = self.i.readByte()
            tmp7 = self.i.readByte()
            buffer = haxe_io_BytesOutput()
            _hx_bytes = haxe_io_Bytes.alloc(255)
            _hx_len = self.i.readByte()
            while (_hx_len != 0):
                self.i.readBytes(_hx_bytes,0,_hx_len)
                buffer.writeBytes(_hx_bytes,0,_hx_len)
                _hx_len = self.i.readByte()
            buffer.flush()
            _hx_bytes = buffer.getBytes()
            buffer.close()
            return format_gif_Block.BExtension(format_gif_Extension.EText(_hx_AnonObject({'textGridX': tmp, 'textGridY': tmp1, 'textGridWidth': tmp2, 'textGridHeight': tmp3, 'charCellWidth': tmp4, 'charCellHeight': tmp5, 'textForegroundColorIndex': tmp6, 'textBackgroundColorIndex': tmp7, 'text': _hx_bytes.toString()})))
        elif (subId1 == 249):
            if (self.i.readByte() != 4):
                raise haxe_Exception.thrown("Incorrect Graphic Control Extension block size!")
            packed = self.i.readByte()
            disposalMethod = None
            _g = (((packed & 28)) >> 2)
            if (_g == 0):
                disposalMethod = format_gif_DisposalMethod.UNSPECIFIED
            elif (_g == 1):
                disposalMethod = format_gif_DisposalMethod.NO_ACTION
            elif (_g == 2):
                disposalMethod = format_gif_DisposalMethod.FILL_BACKGROUND
            elif (_g == 3):
                disposalMethod = format_gif_DisposalMethod.RENDER_PREVIOUS
            else:
                disposalMethod = format_gif_DisposalMethod.UNDEFINED((((packed & 28)) >> 2))
            b = format_gif_Block.BExtension(format_gif_Extension.EGraphicControl(_hx_AnonObject({'disposalMethod': disposalMethod, 'userInput': (((packed & 2)) == 2), 'hasTransparentColor': (((packed & 1)) == 1), 'delay': self.i.readUInt16(), 'transparentIndex': self.i.readByte()})))
            self.i.readByte()
            return b
        elif (subId1 == 254):
            buffer = haxe_io_BytesOutput()
            _hx_bytes = haxe_io_Bytes.alloc(255)
            _hx_len = self.i.readByte()
            while (_hx_len != 0):
                self.i.readBytes(_hx_bytes,0,_hx_len)
                buffer.writeBytes(_hx_bytes,0,_hx_len)
                _hx_len = self.i.readByte()
            buffer.flush()
            _hx_bytes = buffer.getBytes()
            buffer.close()
            return format_gif_Block.BExtension(format_gif_Extension.EComment(_hx_bytes.toString()))
        elif (subId1 == 255):
            return self.readApplicationExtension()
        else:
            buffer = haxe_io_BytesOutput()
            _hx_bytes = haxe_io_Bytes.alloc(255)
            _hx_len = self.i.readByte()
            while (_hx_len != 0):
                self.i.readBytes(_hx_bytes,0,_hx_len)
                buffer.writeBytes(_hx_bytes,0,_hx_len)
                _hx_len = self.i.readByte()
            buffer.flush()
            _hx_bytes = buffer.getBytes()
            buffer.close()
            return format_gif_Block.BExtension(format_gif_Extension.EUnknown(subId,_hx_bytes))

    def readApplicationExtension(self):
        if (self.i.readByte() != 11):
            raise haxe_Exception.thrown("Incorrect size of Application Extension introducer block.")
        name = self.i.readString(8)
        version = self.i.readString(3)
        buffer = haxe_io_BytesOutput()
        _hx_bytes = haxe_io_Bytes.alloc(255)
        _hx_len = self.i.readByte()
        while (_hx_len != 0):
            self.i.readBytes(_hx_bytes,0,_hx_len)
            buffer.writeBytes(_hx_bytes,0,_hx_len)
            _hx_len = self.i.readByte()
        buffer.flush()
        _hx_bytes = buffer.getBytes()
        buffer.close()
        data = _hx_bytes
        if (((name == "NETSCAPE") and ((version == "2.0"))) and ((data.b[0] == 1))):
            return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AENetscapeLooping((data.b[1] | ((data.b[2] << 8))))))
        return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AEUnknown(name,version,data)))

    def readBlocks(self):
        buffer = haxe_io_BytesOutput()
        _hx_bytes = haxe_io_Bytes.alloc(255)
        _hx_len = self.i.readByte()
        while (_hx_len != 0):
            self.i.readBytes(_hx_bytes,0,_hx_len)
            buffer.writeBytes(_hx_bytes,0,_hx_len)
            _hx_len = self.i.readByte()
        buffer.flush()
        _hx_bytes = buffer.getBytes()
        buffer.close()
        return _hx_bytes

    def readColorTable(self,size):
        size = (size * 3)
        output = haxe_io_Bytes.alloc(size)
        c = 0
        while (c < size):
            v = self.i.readByte()
            output.b[c] = (v & 255)
            v1 = self.i.readByte()
            output.b[(c + 1)] = (v1 & 255)
            v2 = self.i.readByte()
            output.b[(c + 2)] = (v2 & 255)
            c = (c + 3)
        return output

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
format_gif_Reader._hx_class = format_gif_Reader
_hx_classes["format.gif.Reader"] = format_gif_Reader


class format_gif_Tools:
    _hx_class_name = "format.gif.Tools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["framesCount", "frame", "graphicControl", "extractBGRA", "extractRGBA", "extractFullBGRA", "extractFullRGBA", "loopCount", "LN2", "log2"]

    @staticmethod
    def framesCount(data):
        frames = 0
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            if (block.index == 0):
                _g = block.params[0]
                frames = (frames + 1)
        return frames

    @staticmethod
    def frame(data,frameIndex):
        counter = 0
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            if (block.index == 0):
                frame = block.params[0]
                if (counter == frameIndex):
                    return frame
                counter = (counter + 1)
        return None

    @staticmethod
    def graphicControl(data,frameIndex):
        counter = 0
        gce = None
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                if (counter == frameIndex):
                    return gce
                gce = None
                counter = (counter + 1)
            elif (tmp == 1):
                _g = block.params[0]
                if (_g.index == 0):
                    g = _g.params[0]
                    gce = g
            else:
                pass
        return None

    @staticmethod
    def extractBGRA(data,frameIndex):
        gce = None
        frameCaret = 0
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                if (frameCaret == frameIndex):
                    _hx_bytes = haxe_io_Bytes.alloc(((frame.width * frame.height) * 4))
                    ct = (frame.colorTable if (frame.localColorTable) else Reflect.field(data,"globalColorTable"))
                    if (ct is None):
                        raise haxe_Exception.thrown("Frame does not have a color table!")
                    transparentIndex = ((gce.transparentIndex * 3) if (((gce is not None) and gce.hasTransparentColor)) else -1)
                    writeCaret = 0
                    _g = 0
                    _g1 = frame.pixels.length
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        index = (frame.pixels.b[i] * 3)
                        v = ct.b[(index + 2)]
                        _hx_bytes.b[writeCaret] = (v & 255)
                        v1 = ct.b[(index + 1)]
                        _hx_bytes.b[(writeCaret + 1)] = (v1 & 255)
                        v2 = ct.b[index]
                        _hx_bytes.b[(writeCaret + 2)] = (v2 & 255)
                        if (transparentIndex == index):
                            _hx_bytes.b[(writeCaret + 3)] = 0
                        else:
                            _hx_bytes.b[(writeCaret + 3)] = 255
                        writeCaret = (writeCaret + 4)
                    return _hx_bytes
                frameCaret = (frameCaret + 1)
                gce = None
            elif (tmp == 1):
                ext = block.params[0]
                if (ext.index == 0):
                    g = ext.params[0]
                    gce = g
            else:
                pass
        return None

    @staticmethod
    def extractRGBA(data,frameIndex):
        gce = None
        frameCaret = 0
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                if (frameCaret == frameIndex):
                    _hx_bytes = haxe_io_Bytes.alloc(((frame.width * frame.height) * 4))
                    ct = (frame.colorTable if (frame.localColorTable) else Reflect.field(data,"globalColorTable"))
                    if (ct is None):
                        raise haxe_Exception.thrown("Frame does not have a color table!")
                    transparentIndex = ((gce.transparentIndex * 3) if (((gce is not None) and gce.hasTransparentColor)) else -1)
                    writeCaret = 0
                    _g = 0
                    _g1 = frame.pixels.length
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        index = (frame.pixels.b[i] * 3)
                        v = ct.b[index]
                        _hx_bytes.b[writeCaret] = (v & 255)
                        v1 = ct.b[(index + 1)]
                        _hx_bytes.b[(writeCaret + 1)] = (v1 & 255)
                        v2 = ct.b[(index + 2)]
                        _hx_bytes.b[(writeCaret + 2)] = (v2 & 255)
                        if (transparentIndex == index):
                            _hx_bytes.b[(writeCaret + 3)] = 0
                        else:
                            _hx_bytes.b[(writeCaret + 3)] = 255
                        writeCaret = (writeCaret + 4)
                    return _hx_bytes
                frameCaret = (frameCaret + 1)
                gce = None
            elif (tmp == 1):
                ext = block.params[0]
                if (ext.index == 0):
                    g = ext.params[0]
                    gce = g
            else:
                pass
        return None

    @staticmethod
    def extractFullBGRA(data,frameIndex):
        gce = None
        frameCaret = 0
        _hx_bytes = haxe_io_Bytes.alloc(((data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height) * 4))
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                ct = (frame.colorTable if (frame.localColorTable) else Reflect.field(data,"globalColorTable"))
                if (ct is None):
                    raise haxe_Exception.thrown("Frame does not have a color table!")
                transparentIndex = ((gce.transparentIndex * 3) if (((gce is not None) and gce.hasTransparentColor)) else -1)
                pixels = frame.pixels
                x = 0
                writeCaret = ((((frame.y * data.logicalScreenDescriptor.width) + frame.x)) * 4)
                lineSkip = ((((data.logicalScreenDescriptor.width - frame.width)) * 4) + 4)
                disposalMethod = (gce.disposalMethod if (((frameCaret != frameIndex) and ((gce is not None)))) else format_gif_DisposalMethod.NO_ACTION)
                tmp1 = disposalMethod.index
                if (tmp1 == 2):
                    _g = 0
                    _g1 = pixels.length
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        _hx_bytes.b[writeCaret] = 0
                        _hx_bytes.b[(writeCaret + 1)] = 0
                        _hx_bytes.b[(writeCaret + 2)] = 0
                        _hx_bytes.b[(writeCaret + 3)] = 0
                        x = (x + 1)
                        tmp2 = x
                        if (tmp2 == frame.width):
                            x = 0
                            writeCaret = (writeCaret + lineSkip)
                        else:
                            writeCaret = (writeCaret + 4)
                elif (tmp1 == 3):
                    pass
                else:
                    _g2 = 0
                    _g3 = pixels.length
                    while (_g2 < _g3):
                        i1 = _g2
                        _g2 = (_g2 + 1)
                        index = (pixels.b[i1] * 3)
                        if (transparentIndex != index):
                            v = ct.b[(index + 2)]
                            _hx_bytes.b[writeCaret] = (v & 255)
                            v1 = ct.b[(index + 1)]
                            _hx_bytes.b[(writeCaret + 1)] = (v1 & 255)
                            v2 = ct.b[index]
                            _hx_bytes.b[(writeCaret + 2)] = (v2 & 255)
                            _hx_bytes.b[(writeCaret + 3)] = 255
                        x = (x + 1)
                        tmp3 = x
                        if (tmp3 == frame.width):
                            x = 0
                            writeCaret = (writeCaret + lineSkip)
                        else:
                            writeCaret = (writeCaret + 4)
                if (frameCaret == frameIndex):
                    return _hx_bytes
                frameCaret = (frameCaret + 1)
                gce = None
            elif (tmp == 1):
                ext = block.params[0]
                if (ext.index == 0):
                    g = ext.params[0]
                    gce = g
            else:
                pass
        return _hx_bytes

    @staticmethod
    def extractFullRGBA(data,frameIndex):
        gce = None
        frameCaret = 0
        _hx_bytes = haxe_io_Bytes.alloc(((data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height) * 4))
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                ct = (frame.colorTable if (frame.localColorTable) else Reflect.field(data,"globalColorTable"))
                if (ct is None):
                    raise haxe_Exception.thrown("Frame does not have a color table!")
                transparentIndex = ((gce.transparentIndex * 3) if (((gce is not None) and gce.hasTransparentColor)) else -1)
                pixels = frame.pixels
                x = 0
                writeCaret = ((((frame.y * data.logicalScreenDescriptor.width) + frame.x)) * 4)
                lineSkip = ((((data.logicalScreenDescriptor.width - frame.width)) * 4) + 4)
                disposalMethod = (gce.disposalMethod if (((frameCaret != frameIndex) and ((gce is not None)))) else format_gif_DisposalMethod.NO_ACTION)
                tmp1 = disposalMethod.index
                if (tmp1 == 2):
                    _g = 0
                    _g1 = pixels.length
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        _hx_bytes.b[writeCaret] = 0
                        _hx_bytes.b[(writeCaret + 1)] = 0
                        _hx_bytes.b[(writeCaret + 2)] = 0
                        _hx_bytes.b[(writeCaret + 3)] = 0
                        x = (x + 1)
                        tmp2 = x
                        if (tmp2 == frame.width):
                            x = 0
                            writeCaret = (writeCaret + lineSkip)
                        else:
                            writeCaret = (writeCaret + 4)
                elif (tmp1 == 3):
                    pass
                else:
                    _g2 = 0
                    _g3 = pixels.length
                    while (_g2 < _g3):
                        i1 = _g2
                        _g2 = (_g2 + 1)
                        index = (pixels.b[i1] * 3)
                        if (transparentIndex != index):
                            v = ct.b[index]
                            _hx_bytes.b[writeCaret] = (v & 255)
                            v1 = ct.b[(index + 1)]
                            _hx_bytes.b[(writeCaret + 1)] = (v1 & 255)
                            v2 = ct.b[(index + 2)]
                            _hx_bytes.b[(writeCaret + 2)] = (v2 & 255)
                            _hx_bytes.b[(writeCaret + 3)] = 255
                        x = (x + 1)
                        tmp3 = x
                        if (tmp3 == frame.width):
                            x = 0
                            writeCaret = (writeCaret + lineSkip)
                        else:
                            writeCaret = (writeCaret + 4)
                if (frameCaret == frameIndex):
                    return _hx_bytes
                frameCaret = (frameCaret + 1)
                gce = None
            elif (tmp == 1):
                ext = block.params[0]
                if (ext.index == 0):
                    g = ext.params[0]
                    gce = g
            else:
                pass
        return _hx_bytes

    @staticmethod
    def loopCount(data):
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            if (block.index == 1):
                _g = block.params[0]
                if (_g.index == 3):
                    _g1 = _g.params[0]
                    if (_g1.index == 0):
                        loops = _g1.params[0]
                        return loops
        return 1

    @staticmethod
    def log2(val):
        return (((Math.NEGATIVE_INFINITY if ((val == 0.0)) else (Math.NaN if ((val < 0.0)) else python_lib_Math.log(val)))) / format_gif_Tools.LN2)
format_gif_Tools._hx_class = format_gif_Tools
_hx_classes["format.gif.Tools"] = format_gif_Tools

class format_mp3_SamplingRate(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.SamplingRate"
    _hx_constructs = ["SR_8000", "SR_11025", "SR_12000", "SR_22050", "SR_24000", "SR_32000", "SR_44100", "SR_48000", "SR_Bad"]
format_mp3_SamplingRate.SR_8000 = format_mp3_SamplingRate("SR_8000", 0, ())
format_mp3_SamplingRate.SR_11025 = format_mp3_SamplingRate("SR_11025", 1, ())
format_mp3_SamplingRate.SR_12000 = format_mp3_SamplingRate("SR_12000", 2, ())
format_mp3_SamplingRate.SR_22050 = format_mp3_SamplingRate("SR_22050", 3, ())
format_mp3_SamplingRate.SR_24000 = format_mp3_SamplingRate("SR_24000", 4, ())
format_mp3_SamplingRate.SR_32000 = format_mp3_SamplingRate("SR_32000", 5, ())
format_mp3_SamplingRate.SR_44100 = format_mp3_SamplingRate("SR_44100", 6, ())
format_mp3_SamplingRate.SR_48000 = format_mp3_SamplingRate("SR_48000", 7, ())
format_mp3_SamplingRate.SR_Bad = format_mp3_SamplingRate("SR_Bad", 8, ())
format_mp3_SamplingRate._hx_class = format_mp3_SamplingRate
_hx_classes["format.mp3.SamplingRate"] = format_mp3_SamplingRate

class format_mp3_Bitrate(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.Bitrate"
    _hx_constructs = ["BR_8", "BR_16", "BR_24", "BR_32", "BR_40", "BR_48", "BR_56", "BR_64", "BR_80", "BR_96", "BR_112", "BR_128", "BR_144", "BR_160", "BR_176", "BR_192", "BR_224", "BR_256", "BR_288", "BR_320", "BR_352", "BR_384", "BR_416", "BR_448", "BR_Free", "BR_Bad"]
format_mp3_Bitrate.BR_8 = format_mp3_Bitrate("BR_8", 0, ())
format_mp3_Bitrate.BR_16 = format_mp3_Bitrate("BR_16", 1, ())
format_mp3_Bitrate.BR_24 = format_mp3_Bitrate("BR_24", 2, ())
format_mp3_Bitrate.BR_32 = format_mp3_Bitrate("BR_32", 3, ())
format_mp3_Bitrate.BR_40 = format_mp3_Bitrate("BR_40", 4, ())
format_mp3_Bitrate.BR_48 = format_mp3_Bitrate("BR_48", 5, ())
format_mp3_Bitrate.BR_56 = format_mp3_Bitrate("BR_56", 6, ())
format_mp3_Bitrate.BR_64 = format_mp3_Bitrate("BR_64", 7, ())
format_mp3_Bitrate.BR_80 = format_mp3_Bitrate("BR_80", 8, ())
format_mp3_Bitrate.BR_96 = format_mp3_Bitrate("BR_96", 9, ())
format_mp3_Bitrate.BR_112 = format_mp3_Bitrate("BR_112", 10, ())
format_mp3_Bitrate.BR_128 = format_mp3_Bitrate("BR_128", 11, ())
format_mp3_Bitrate.BR_144 = format_mp3_Bitrate("BR_144", 12, ())
format_mp3_Bitrate.BR_160 = format_mp3_Bitrate("BR_160", 13, ())
format_mp3_Bitrate.BR_176 = format_mp3_Bitrate("BR_176", 14, ())
format_mp3_Bitrate.BR_192 = format_mp3_Bitrate("BR_192", 15, ())
format_mp3_Bitrate.BR_224 = format_mp3_Bitrate("BR_224", 16, ())
format_mp3_Bitrate.BR_256 = format_mp3_Bitrate("BR_256", 17, ())
format_mp3_Bitrate.BR_288 = format_mp3_Bitrate("BR_288", 18, ())
format_mp3_Bitrate.BR_320 = format_mp3_Bitrate("BR_320", 19, ())
format_mp3_Bitrate.BR_352 = format_mp3_Bitrate("BR_352", 20, ())
format_mp3_Bitrate.BR_384 = format_mp3_Bitrate("BR_384", 21, ())
format_mp3_Bitrate.BR_416 = format_mp3_Bitrate("BR_416", 22, ())
format_mp3_Bitrate.BR_448 = format_mp3_Bitrate("BR_448", 23, ())
format_mp3_Bitrate.BR_Free = format_mp3_Bitrate("BR_Free", 24, ())
format_mp3_Bitrate.BR_Bad = format_mp3_Bitrate("BR_Bad", 25, ())
format_mp3_Bitrate._hx_class = format_mp3_Bitrate
_hx_classes["format.mp3.Bitrate"] = format_mp3_Bitrate


class format_mp3_MPEG:
    _hx_class_name = "format.mp3.MPEG"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["V1", "V2", "V25", "Reserved", "enum2Num", "num2Enum", "V1_Bitrates", "V2_Bitrates", "SamplingRates", "srNum2Enum", "srEnum2Num", "getBitrateIdx", "getSamplingRateIdx", "bitrateEnum2Num", "bitrateNum2Enum"]

    @staticmethod
    def enum2Num(m):
        tmp = m.index
        if (tmp == 0):
            return 3
        elif (tmp == 1):
            return 2
        elif (tmp == 2):
            return 0
        elif (tmp == 3):
            return format_mp3_MPEG.Reserved
        else:
            pass

    @staticmethod
    def num2Enum(m):
        m1 = m
        if (m1 == 0):
            return format_mp3_MPEGVersion.MPEG_V25
        elif (m1 == 2):
            return format_mp3_MPEGVersion.MPEG_V2
        elif (m1 == 3):
            return format_mp3_MPEGVersion.MPEG_V1
        else:
            return format_mp3_MPEGVersion.MPEG_Reserved

    @staticmethod
    def srNum2Enum(sr):
        sr1 = sr
        if (sr1 == 8000):
            return format_mp3_SamplingRate.SR_8000
        elif (sr1 == 11025):
            return format_mp3_SamplingRate.SR_11025
        elif (sr1 == 12000):
            return format_mp3_SamplingRate.SR_12000
        elif (sr1 == 22050):
            return format_mp3_SamplingRate.SR_22050
        elif (sr1 == 24000):
            return format_mp3_SamplingRate.SR_24000
        elif (sr1 == 32000):
            return format_mp3_SamplingRate.SR_32000
        elif (sr1 == 44100):
            return format_mp3_SamplingRate.SR_44100
        elif (sr1 == 48000):
            return format_mp3_SamplingRate.SR_48000
        else:
            return format_mp3_SamplingRate.SR_Bad

    @staticmethod
    def srEnum2Num(sr):
        tmp = sr.index
        if (tmp == 0):
            return 8000
        elif (tmp == 1):
            return 11025
        elif (tmp == 2):
            return 12000
        elif (tmp == 3):
            return 22050
        elif (tmp == 4):
            return 24000
        elif (tmp == 5):
            return 32000
        elif (tmp == 6):
            return 44100
        elif (tmp == 7):
            return 48000
        elif (tmp == 8):
            return -1
        else:
            pass

    @staticmethod
    def getBitrateIdx(br,mpeg,layer):
        arr = python_internal_ArrayImpl._get(((format_mp3_MPEG.V1_Bitrates if ((mpeg == format_mp3_MPEGVersion.MPEG_V1)) else format_mp3_MPEG.V2_Bitrates)), format_mp3_CLayer.enum2Num(layer))
        if ((arr[0] if 0 < len(arr) else None) == br):
            return 0
        if ((arr[1] if 1 < len(arr) else None) == br):
            return 1
        if ((arr[2] if 2 < len(arr) else None) == br):
            return 2
        if ((arr[3] if 3 < len(arr) else None) == br):
            return 3
        if ((arr[4] if 4 < len(arr) else None) == br):
            return 4
        if ((arr[5] if 5 < len(arr) else None) == br):
            return 5
        if ((arr[6] if 6 < len(arr) else None) == br):
            return 6
        if ((arr[7] if 7 < len(arr) else None) == br):
            return 7
        if ((arr[8] if 8 < len(arr) else None) == br):
            return 8
        if ((arr[9] if 9 < len(arr) else None) == br):
            return 9
        if ((arr[10] if 10 < len(arr) else None) == br):
            return 10
        if ((arr[11] if 11 < len(arr) else None) == br):
            return 11
        if ((arr[12] if 12 < len(arr) else None) == br):
            return 12
        if ((arr[13] if 13 < len(arr) else None) == br):
            return 13
        if ((arr[14] if 14 < len(arr) else None) == br):
            return 14
        if ((arr[15] if 15 < len(arr) else None) == br):
            return 15
        raise haxe_Exception.thrown("Bitrate index not found")

    @staticmethod
    def getSamplingRateIdx(sr,mpeg):
        arr = python_internal_ArrayImpl._get(format_mp3_MPEG.SamplingRates, format_mp3_MPEG.enum2Num(mpeg))
        if ((arr[0] if 0 < len(arr) else None) == sr):
            return 0
        if ((arr[1] if 1 < len(arr) else None) == sr):
            return 1
        if ((arr[2] if 2 < len(arr) else None) == sr):
            return 2
        if ((arr[3] if 3 < len(arr) else None) == sr):
            return 3
        raise haxe_Exception.thrown("Sampling rate index not found")

    @staticmethod
    def bitrateEnum2Num(br):
        tmp = br.index
        if (tmp == 0):
            return 8
        elif (tmp == 1):
            return 16
        elif (tmp == 2):
            return 24
        elif (tmp == 3):
            return 32
        elif (tmp == 4):
            return 40
        elif (tmp == 5):
            return 48
        elif (tmp == 6):
            return 56
        elif (tmp == 7):
            return 64
        elif (tmp == 8):
            return 80
        elif (tmp == 9):
            return 96
        elif (tmp == 10):
            return 112
        elif (tmp == 11):
            return 128
        elif (tmp == 12):
            return 144
        elif (tmp == 13):
            return 160
        elif (tmp == 14):
            return 176
        elif (tmp == 15):
            return 192
        elif (tmp == 16):
            return 224
        elif (tmp == 17):
            return 256
        elif (tmp == 18):
            return 288
        elif (tmp == 19):
            return 320
        elif (tmp == 20):
            return 352
        elif (tmp == 21):
            return 384
        elif (tmp == 22):
            return 416
        elif (tmp == 23):
            return 448
        elif (tmp == 24):
            return 0
        elif (tmp == 25):
            return -1
        else:
            pass

    @staticmethod
    def bitrateNum2Enum(br):
        br1 = br
        if (br1 == 0):
            return format_mp3_Bitrate.BR_Free
        elif (br1 == 8):
            return format_mp3_Bitrate.BR_8
        elif (br1 == 16):
            return format_mp3_Bitrate.BR_16
        elif (br1 == 24):
            return format_mp3_Bitrate.BR_24
        elif (br1 == 32):
            return format_mp3_Bitrate.BR_32
        elif (br1 == 40):
            return format_mp3_Bitrate.BR_40
        elif (br1 == 48):
            return format_mp3_Bitrate.BR_48
        elif (br1 == 56):
            return format_mp3_Bitrate.BR_56
        elif (br1 == 64):
            return format_mp3_Bitrate.BR_64
        elif (br1 == 80):
            return format_mp3_Bitrate.BR_80
        elif (br1 == 96):
            return format_mp3_Bitrate.BR_96
        elif (br1 == 112):
            return format_mp3_Bitrate.BR_112
        elif (br1 == 128):
            return format_mp3_Bitrate.BR_128
        elif (br1 == 144):
            return format_mp3_Bitrate.BR_144
        elif (br1 == 160):
            return format_mp3_Bitrate.BR_160
        elif (br1 == 176):
            return format_mp3_Bitrate.BR_176
        elif (br1 == 192):
            return format_mp3_Bitrate.BR_192
        elif (br1 == 224):
            return format_mp3_Bitrate.BR_224
        elif (br1 == 256):
            return format_mp3_Bitrate.BR_256
        elif (br1 == 288):
            return format_mp3_Bitrate.BR_288
        elif (br1 == 320):
            return format_mp3_Bitrate.BR_320
        elif (br1 == 352):
            return format_mp3_Bitrate.BR_352
        elif (br1 == 384):
            return format_mp3_Bitrate.BR_384
        elif (br1 == 416):
            return format_mp3_Bitrate.BR_416
        elif (br1 == 448):
            return format_mp3_Bitrate.BR_448
        else:
            return format_mp3_Bitrate.BR_Bad
format_mp3_MPEG._hx_class = format_mp3_MPEG
_hx_classes["format.mp3.MPEG"] = format_mp3_MPEG


class format_mp3_CLayer:
    _hx_class_name = "format.mp3.CLayer"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["LReserved", "LLayer3", "LLayer2", "LLayer1", "enum2Num", "num2Enum"]

    @staticmethod
    def enum2Num(l):
        tmp = l.index
        if (tmp == 0):
            return format_mp3_CLayer.LReserved
        elif (tmp == 1):
            return format_mp3_CLayer.LLayer3
        elif (tmp == 2):
            return format_mp3_CLayer.LLayer2
        elif (tmp == 3):
            return format_mp3_CLayer.LLayer1
        else:
            pass

    @staticmethod
    def num2Enum(l):
        l1 = l
        if (l1 == 1):
            return format_mp3_Layer.Layer3
        elif (l1 == 2):
            return format_mp3_Layer.Layer2
        elif (l1 == 3):
            return format_mp3_Layer.Layer1
        else:
            return format_mp3_Layer.LayerReserved
format_mp3_CLayer._hx_class = format_mp3_CLayer
_hx_classes["format.mp3.CLayer"] = format_mp3_CLayer


class format_mp3_CChannelMode:
    _hx_class_name = "format.mp3.CChannelMode"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["CStereo", "CJointStereo", "CDualChannel", "CMono", "enum2Num", "num2Enum"]

    @staticmethod
    def enum2Num(c):
        tmp = c.index
        if (tmp == 0):
            return 0
        elif (tmp == 1):
            return 1
        elif (tmp == 2):
            return 2
        elif (tmp == 3):
            return 3
        else:
            pass

    @staticmethod
    def num2Enum(c):
        c1 = c
        if (c1 == 0):
            return format_mp3_ChannelMode.Stereo
        elif (c1 == 1):
            return format_mp3_ChannelMode.JointStereo
        elif (c1 == 2):
            return format_mp3_ChannelMode.DualChannel
        elif (c1 == 3):
            return format_mp3_ChannelMode.Mono
        else:
            raise haxe_Exception.thrown("assert")
format_mp3_CChannelMode._hx_class = format_mp3_CChannelMode
_hx_classes["format.mp3.CChannelMode"] = format_mp3_CChannelMode


class format_mp3_CEmphasis:
    _hx_class_name = "format.mp3.CEmphasis"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ENone", "EMs50_15", "EReserved", "ECCIT_J17", "enum2Num", "num2Enum"]

    @staticmethod
    def enum2Num(c):
        tmp = c.index
        if (tmp == 0):
            return 0
        elif (tmp == 1):
            return 1
        elif (tmp == 2):
            return 3
        elif (tmp == 3):
            return 2
        else:
            pass

    @staticmethod
    def num2Enum(c):
        c1 = c
        if (c1 == 0):
            return format_mp3_Emphasis.NoEmphasis
        elif (c1 == 1):
            return format_mp3_Emphasis.Ms50_15
        elif (c1 == 2):
            return format_mp3_Emphasis.InvalidEmphasis
        elif (c1 == 3):
            return format_mp3_Emphasis.CCIT_J17
        else:
            raise haxe_Exception.thrown("assert")
format_mp3_CEmphasis._hx_class = format_mp3_CEmphasis
_hx_classes["format.mp3.CEmphasis"] = format_mp3_CEmphasis

class format_mp3_MPEGVersion(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.MPEGVersion"
    _hx_constructs = ["MPEG_V1", "MPEG_V2", "MPEG_V25", "MPEG_Reserved"]
format_mp3_MPEGVersion.MPEG_V1 = format_mp3_MPEGVersion("MPEG_V1", 0, ())
format_mp3_MPEGVersion.MPEG_V2 = format_mp3_MPEGVersion("MPEG_V2", 1, ())
format_mp3_MPEGVersion.MPEG_V25 = format_mp3_MPEGVersion("MPEG_V25", 2, ())
format_mp3_MPEGVersion.MPEG_Reserved = format_mp3_MPEGVersion("MPEG_Reserved", 3, ())
format_mp3_MPEGVersion._hx_class = format_mp3_MPEGVersion
_hx_classes["format.mp3.MPEGVersion"] = format_mp3_MPEGVersion

class format_mp3_Layer(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.Layer"
    _hx_constructs = ["LayerReserved", "Layer3", "Layer2", "Layer1"]
format_mp3_Layer.LayerReserved = format_mp3_Layer("LayerReserved", 0, ())
format_mp3_Layer.Layer3 = format_mp3_Layer("Layer3", 1, ())
format_mp3_Layer.Layer2 = format_mp3_Layer("Layer2", 2, ())
format_mp3_Layer.Layer1 = format_mp3_Layer("Layer1", 3, ())
format_mp3_Layer._hx_class = format_mp3_Layer
_hx_classes["format.mp3.Layer"] = format_mp3_Layer

class format_mp3_ChannelMode(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.ChannelMode"
    _hx_constructs = ["Stereo", "JointStereo", "DualChannel", "Mono"]
format_mp3_ChannelMode.Stereo = format_mp3_ChannelMode("Stereo", 0, ())
format_mp3_ChannelMode.JointStereo = format_mp3_ChannelMode("JointStereo", 1, ())
format_mp3_ChannelMode.DualChannel = format_mp3_ChannelMode("DualChannel", 2, ())
format_mp3_ChannelMode.Mono = format_mp3_ChannelMode("Mono", 3, ())
format_mp3_ChannelMode._hx_class = format_mp3_ChannelMode
_hx_classes["format.mp3.ChannelMode"] = format_mp3_ChannelMode

class format_mp3_Emphasis(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.Emphasis"
    _hx_constructs = ["NoEmphasis", "Ms50_15", "CCIT_J17", "InvalidEmphasis"]
format_mp3_Emphasis.NoEmphasis = format_mp3_Emphasis("NoEmphasis", 0, ())
format_mp3_Emphasis.Ms50_15 = format_mp3_Emphasis("Ms50_15", 1, ())
format_mp3_Emphasis.CCIT_J17 = format_mp3_Emphasis("CCIT_J17", 2, ())
format_mp3_Emphasis.InvalidEmphasis = format_mp3_Emphasis("InvalidEmphasis", 3, ())
format_mp3_Emphasis._hx_class = format_mp3_Emphasis
_hx_classes["format.mp3.Emphasis"] = format_mp3_Emphasis

class format_mp3_FrameType(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.FrameType"
    _hx_constructs = ["FT_MP3", "FT_NONE"]
format_mp3_FrameType.FT_MP3 = format_mp3_FrameType("FT_MP3", 0, ())
format_mp3_FrameType.FT_NONE = format_mp3_FrameType("FT_NONE", 1, ())
format_mp3_FrameType._hx_class = format_mp3_FrameType
_hx_classes["format.mp3.FrameType"] = format_mp3_FrameType


class format_mp3_Reader:
    _hx_class_name = "format.mp3.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i", "bits", "version", "samples", "sampleSize", "any_read", "id3v2_data", "id3v2_version", "id3v2_flags")
    _hx_fields = ["i", "bits", "version", "samples", "sampleSize", "any_read", "id3v2_data", "id3v2_version", "id3v2_flags"]
    _hx_methods = ["skipID3v2", "seekFrame", "readFrames", "readFrameHeader", "readFrame", "read"]

    def __init__(self,i):
        self.id3v2_flags = None
        self.id3v2_version = None
        self.id3v2_data = None
        self.version = None
        self.i = i
        i.set_bigEndian(True)
        self.bits = format_tools_BitsInput(i)
        self.samples = 0
        self.sampleSize = 0
        self.any_read = False

    def skipID3v2(self):
        self.id3v2_version = self.i.readUInt16()
        self.id3v2_flags = self.i.readByte()
        size = (self.i.readByte() & 127)
        size = ((size << 7) | ((self.i.readByte() & 127)))
        size = ((size << 7) | ((self.i.readByte() & 127)))
        size = ((size << 7) | ((self.i.readByte() & 127)))
        self.id3v2_data = self.i.read(size)

    def seekFrame(self):
        found = False
        try:
            b = None
            while True:
                b = self.i.readByte()
                if (not self.any_read):
                    self.any_read = True
                    if (b == 73):
                        b = self.i.readByte()
                        if (b == 68):
                            b = self.i.readByte()
                            if (b == 51):
                                self.skipID3v2()
                if (b == 255):
                    self.bits.nbits = 0
                    b = self.bits.readBits(3)
                    if (b == 7):
                        return format_mp3_FrameType.FT_MP3
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof):
                return format_mp3_FrameType.FT_NONE
            else:
                raise _g

    def readFrames(self):
        frames = list()
        ft = None
        while True:
            ft = self.seekFrame()
            if (not ((ft != format_mp3_FrameType.FT_NONE))):
                break
            tmp = ft.index
            if (tmp == 0):
                f = self.readFrame()
                if (f is not None):
                    frames.append(f)
            elif (tmp == 1):
                pass
            else:
                pass
        return frames

    def readFrameHeader(self):
        version = self.bits.readBits(2)
        layer = self.bits.readBits(2)
        hasCrc = (not self.bits.readBit())
        if ((version == format_mp3_MPEG.Reserved) or ((layer == format_mp3_CLayer.LReserved))):
            return None
        bitrateIdx = self.bits.readBits(4)
        bitrate = format_mp3_Tools.getBitrate(version,layer,bitrateIdx)
        samplingRateIdx = self.bits.readBits(2)
        samplingRate = format_mp3_Tools.getSamplingRate(version,samplingRateIdx)
        isPadded = self.bits.readBit()
        privateBit = self.bits.readBit()
        if (((bitrate == format_mp3_Bitrate.BR_Bad) or ((bitrate == format_mp3_Bitrate.BR_Free))) or ((samplingRate == format_mp3_SamplingRate.SR_Bad))):
            return None
        channelMode = self.bits.readBits(2)
        isIntensityStereo = self.bits.readBit()
        isMSStereo = self.bits.readBit()
        isCopyrighted = self.bits.readBit()
        isOriginal = self.bits.readBit()
        emphasis = self.bits.readBits(2)
        crc16 = 0
        if hasCrc:
            crc16 = self.i.readUInt16()
        return _hx_AnonObject({'version': format_mp3_MPEG.num2Enum(version), 'layer': format_mp3_CLayer.num2Enum(layer), 'hasCrc': hasCrc, 'crc16': crc16, 'bitrate': bitrate, 'samplingRate': samplingRate, 'isPadded': isPadded, 'privateBit': privateBit, 'channelMode': format_mp3_CChannelMode.num2Enum(channelMode), 'isIntensityStereo': isIntensityStereo, 'isMSStereo': isMSStereo, 'isCopyrighted': isCopyrighted, 'isOriginal': isOriginal, 'emphasis': format_mp3_CEmphasis.num2Enum(emphasis)})

    def readFrame(self):
        header = self.readFrameHeader()
        if ((header is None) or format_mp3_Tools.isInvalidFrameHeader(header)):
            return None
        try:
            data = self.i.read(format_mp3_Tools.getSampleDataSizeHdr(header))
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.samples
            _hx_local_0.samples = (_hx_local_1 + format_mp3_Tools.getSampleCountHdr(header))
            _hx_local_0.samples
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.sampleSize
            _hx_local_2.sampleSize = (_hx_local_3 + data.length)
            _hx_local_2.sampleSize
            return _hx_AnonObject({'header': header, 'data': data})
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof):
                return None
            else:
                raise _g

    def read(self):
        fs = self.readFrames()
        return _hx_AnonObject({'frames': fs, 'sampleCount': self.samples, 'sampleSize': self.sampleSize, 'id3v2': (None if ((self.id3v2_data is None)) else _hx_AnonObject({'versionBytes': self.id3v2_version, 'flagByte': self.id3v2_flags, 'data': self.id3v2_data}))})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.bits = None
        _hx_o.version = None
        _hx_o.samples = None
        _hx_o.sampleSize = None
        _hx_o.any_read = None
        _hx_o.id3v2_data = None
        _hx_o.id3v2_version = None
        _hx_o.id3v2_flags = None
format_mp3_Reader._hx_class = format_mp3_Reader
_hx_classes["format.mp3.Reader"] = format_mp3_Reader


class format_mp3_Tools:
    _hx_class_name = "format.mp3.Tools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getBitrate", "getSamplingRate", "isInvalidFrameHeader", "getSampleDataSize", "getSampleDataSizeHdr", "getSampleCount", "getSampleCountHdr", "getFrameInfo"]

    @staticmethod
    def getBitrate(mpegVersion,layerIdx,bitrateIdx):
        if ((mpegVersion == format_mp3_MPEG.Reserved) or ((layerIdx == format_mp3_CLayer.LReserved))):
            return format_mp3_Bitrate.BR_Bad
        return python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(((format_mp3_MPEG.V1_Bitrates if ((mpegVersion == 3)) else format_mp3_MPEG.V2_Bitrates)), layerIdx), bitrateIdx)

    @staticmethod
    def getSamplingRate(mpegVersion,samplingRateIdx):
        return python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(format_mp3_MPEG.SamplingRates, mpegVersion), samplingRateIdx)

    @staticmethod
    def isInvalidFrameHeader(hdr):
        if (not (((((hdr.version == format_mp3_MPEGVersion.MPEG_Reserved) or ((hdr.layer == format_mp3_Layer.LayerReserved))) or ((hdr.bitrate == format_mp3_Bitrate.BR_Bad))) or ((hdr.bitrate == format_mp3_Bitrate.BR_Free))))):
            return (hdr.samplingRate == format_mp3_SamplingRate.SR_Bad)
        else:
            return True

    @staticmethod
    def getSampleDataSize(mpegVersion,bitrate,samplingRate,isPadded,hasCrc):
        tmp = None
        try:
            tmp = int((((((144 if ((mpegVersion == 3)) else 72)) * bitrate) * 1000) / samplingRate))
        except BaseException as _g:
            None
            tmp = None
        return (((tmp + ((1 if isPadded else 0))) - ((2 if hasCrc else 0))) - 4)

    @staticmethod
    def getSampleDataSizeHdr(hdr):
        return format_mp3_Tools.getSampleDataSize(format_mp3_MPEG.enum2Num(hdr.version),format_mp3_MPEG.bitrateEnum2Num(hdr.bitrate),format_mp3_MPEG.srEnum2Num(hdr.samplingRate),hdr.isPadded,hdr.hasCrc)

    @staticmethod
    def getSampleCount(mpegVersion):
        if (mpegVersion == 3):
            return 1152
        else:
            return 576

    @staticmethod
    def getSampleCountHdr(hdr):
        return format_mp3_Tools.getSampleCount(format_mp3_MPEG.enum2Num(hdr.version))

    @staticmethod
    def getFrameInfo(fr):
        return ((((((((((((((((((Std.string(fr.header.version) + ", ") + Std.string(fr.header.layer)) + ", ") + Std.string(fr.header.channelMode)) + ", ") + Std.string(fr.header.samplingRate)) + " Hz, ") + Std.string(fr.header.bitrate)) + " kbps ") + "Emphasis: ") + Std.string(fr.header.emphasis)) + ", ") + HxOverrides.stringOrNull((("(CRC) " if (fr.header.hasCrc) else "")))) + HxOverrides.stringOrNull((("(Padded) " if (fr.header.isPadded) else "")))) + HxOverrides.stringOrNull((("(Intensity Stereo) " if (fr.header.isIntensityStereo) else "")))) + HxOverrides.stringOrNull((("(MS Stereo) " if (fr.header.isMSStereo) else "")))) + HxOverrides.stringOrNull((("(Copyrighted) " if (fr.header.isCopyrighted) else "")))) + HxOverrides.stringOrNull((("(Original) " if (fr.header.isOriginal) else ""))))
format_mp3_Tools._hx_class = format_mp3_Tools
_hx_classes["format.mp3.Tools"] = format_mp3_Tools

class format_png_Color(Enum):
    __slots__ = ()
    _hx_class_name = "format.png.Color"
    _hx_constructs = ["ColGrey", "ColTrue", "ColIndexed"]

    @staticmethod
    def ColGrey(alpha):
        return format_png_Color("ColGrey", 0, (alpha,))

    @staticmethod
    def ColTrue(alpha):
        return format_png_Color("ColTrue", 1, (alpha,))
format_png_Color.ColIndexed = format_png_Color("ColIndexed", 2, ())
format_png_Color._hx_class = format_png_Color
_hx_classes["format.png.Color"] = format_png_Color

class format_png_Chunk(Enum):
    __slots__ = ()
    _hx_class_name = "format.png.Chunk"
    _hx_constructs = ["CEnd", "CHeader", "CData", "CPalette", "CUnknown"]

    @staticmethod
    def CHeader(h):
        return format_png_Chunk("CHeader", 1, (h,))

    @staticmethod
    def CData(b):
        return format_png_Chunk("CData", 2, (b,))

    @staticmethod
    def CPalette(b):
        return format_png_Chunk("CPalette", 3, (b,))

    @staticmethod
    def CUnknown(id,data):
        return format_png_Chunk("CUnknown", 4, (id,data))
format_png_Chunk.CEnd = format_png_Chunk("CEnd", 0, ())
format_png_Chunk._hx_class = format_png_Chunk
_hx_classes["format.png.Chunk"] = format_png_Chunk


class format_png_Reader:
    _hx_class_name = "format.png.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i", "checkCRC")
    _hx_fields = ["i", "checkCRC"]
    _hx_methods = ["read", "readHeader", "readChunk"]

    def __init__(self,i):
        self.i = i
        i.set_bigEndian(True)
        self.checkCRC = True

    def read(self):
        b = 137
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 80
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 78
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 71
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 13
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 10
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 26
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 10
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        l = haxe_ds_List()
        while True:
            c = self.readChunk()
            l.add(c)
            if (c == format_png_Chunk.CEnd):
                break
        return l

    def readHeader(self,i):
        i.set_bigEndian(True)
        width = i.readInt32()
        height = i.readInt32()
        colbits = i.readByte()
        color = i.readByte()
        color1 = None
        color2 = color
        if (color2 == 0):
            color1 = format_png_Color.ColGrey(False)
        elif (color2 == 2):
            color1 = format_png_Color.ColTrue(False)
        elif (color2 == 3):
            color1 = format_png_Color.ColIndexed
        elif (color2 == 4):
            color1 = format_png_Color.ColGrey(True)
        elif (color2 == 6):
            color1 = format_png_Color.ColTrue(True)
        else:
            raise haxe_Exception.thrown(((("Unknown color model " + Std.string(color)) + ":") + Std.string(colbits)))
        compress = i.readByte()
        _hx_filter = i.readByte()
        if ((compress != 0) or ((_hx_filter != 0))):
            raise haxe_Exception.thrown("Invalid header")
        interlace = i.readByte()
        if ((interlace != 0) and ((interlace != 1))):
            raise haxe_Exception.thrown("Invalid header")
        return _hx_AnonObject({'width': width, 'height': height, 'colbits': colbits, 'color': color1, 'interlaced': (interlace == 1)})

    def readChunk(self):
        dataLen = self.i.readInt32()
        id = self.i.readString(4)
        data = self.i.read(dataLen)
        crc = self.i.readInt32()
        if self.checkCRC:
            c_crc = -1
            tmp = (((c_crc ^ HxString.charCodeAt(id,0))) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            tmp = (((c_crc ^ HxString.charCodeAt(id,1))) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            tmp = (((c_crc ^ HxString.charCodeAt(id,2))) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            tmp = (((c_crc ^ HxString.charCodeAt(id,3))) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            b = data.b
            _g = 0
            _g1 = data.length
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                tmp = (((c_crc ^ b[i])) & 255)
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            if (((c_crc ^ -1)) != crc):
                raise haxe_Exception.thrown("CRC check failure")
        id1 = id
        if (id1 == "IDAT"):
            return format_png_Chunk.CData(data)
        elif (id1 == "IEND"):
            return format_png_Chunk.CEnd
        elif (id1 == "IHDR"):
            return format_png_Chunk.CHeader(self.readHeader(haxe_io_BytesInput(data)))
        elif (id1 == "PLTE"):
            return format_png_Chunk.CPalette(data)
        else:
            return format_png_Chunk.CUnknown(id,data)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.checkCRC = None
format_png_Reader._hx_class = format_png_Reader
_hx_classes["format.png.Reader"] = format_png_Reader


class format_png_Tools:
    _hx_class_name = "format.png.Tools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getHeader", "getPalette", "filter", "reverseBytes", "extractGrey", "extract32", "buildGrey", "buildIndexed", "buildRGB", "build32ARGB", "build32BGRA"]

    @staticmethod
    def getHeader(d):
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            if (c.index == 1):
                h = c.params[0]
                return h
        raise haxe_Exception.thrown("Header not found")

    @staticmethod
    def getPalette(d):
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            if (c.index == 3):
                b = c.params[0]
                return b
        return None

    @staticmethod
    def filter(data,x,y,stride,prev,p,numChannels = None):
        if (numChannels is None):
            numChannels = 4
        b = (0 if ((y == 0)) else data.b[(p - stride)])
        c = (0 if (((x == 0) or ((y == 0)))) else data.b[((p - stride) - numChannels)])
        k = ((prev + b) - c)
        pa = (k - prev)
        if (pa < 0):
            pa = -pa
        pb = (k - b)
        if (pb < 0):
            pb = -pb
        pc = (k - c)
        if (pc < 0):
            pc = -pc
        if ((pa <= pb) and ((pa <= pc))):
            return prev
        elif (pb <= pc):
            return b
        else:
            return c

    @staticmethod
    def reverseBytes(b):
        p = 0
        _g = 0
        _g1 = (b.length >> 2)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            b1 = b.b[p]
            g = b.b[(p + 1)]
            r = b.b[(p + 2)]
            a = b.b[(p + 3)]
            p1 = p
            p = (p + 1)
            b.b[p1] = (a & 255)
            p2 = p
            p = (p + 1)
            b.b[p2] = (r & 255)
            p3 = p
            p = (p + 1)
            b.b[p3] = (g & 255)
            p4 = p
            p = (p + 1)
            b.b[p4] = (b1 & 255)

    @staticmethod
    def extractGrey(d):
        h = format_png_Tools.getHeader(d)
        grey = haxe_io_Bytes.alloc((h.width * h.height))
        data = None
        fullData = None
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            if (c.index == 2):
                b = c.params[0]
                if (fullData is not None):
                    fullData.b.extend(b.b)
                elif (data is None):
                    data = b
                else:
                    fullData = haxe_io_BytesBuffer()
                    fullData.b.extend(data.b)
                    fullData.b.extend(b.b)
                    data = None
        if (fullData is not None):
            data = fullData.getBytes()
        if (data is None):
            raise haxe_Exception.thrown("Data not found")
        data = format_tools_Inflate.run(data)
        r = 0
        w = 0
        _g = h.color
        if (_g.index == 0):
            alpha = _g.params[0]
            if (h.colbits != 8):
                raise haxe_Exception.thrown("Unsupported color mode")
            width = h.width
            stride = ((((2 if alpha else 1)) * width) + 1)
            if (data.length < ((h.height * stride))):
                raise haxe_Exception.thrown("Not enough data")
            rinc = (2 if alpha else 1)
            _g = 0
            _g1 = h.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                f1 = f
                if (f1 == 0):
                    _g2 = 0
                    _g3 = width
                    while (_g2 < _g3):
                        x = _g2
                        _g2 = (_g2 + 1)
                        v = data.b[r]
                        r = (r + rinc)
                        pos1 = w
                        w = (w + 1)
                        grey.b[pos1] = (v & 255)
                elif (f1 == 1):
                    cv = 0
                    _g4 = 0
                    _g5 = width
                    while (_g4 < _g5):
                        x1 = _g4
                        _g4 = (_g4 + 1)
                        cv = (cv + data.b[r])
                        r = (r + rinc)
                        pos2 = w
                        w = (w + 1)
                        grey.b[pos2] = (cv & 255)
                elif (f1 == 2):
                    stride = (0 if ((y == 0)) else width)
                    _g6 = 0
                    _g7 = width
                    while (_g6 < _g7):
                        x2 = _g6
                        _g6 = (_g6 + 1)
                        v1 = (data.b[r] + grey.b[(w - stride)])
                        r = (r + rinc)
                        pos3 = w
                        w = (w + 1)
                        grey.b[pos3] = (v1 & 255)
                elif (f1 == 3):
                    cv1 = 0
                    stride1 = (0 if ((y == 0)) else width)
                    _g8 = 0
                    _g9 = width
                    while (_g8 < _g9):
                        x3 = _g8
                        _g8 = (_g8 + 1)
                        cv1 = ((data.b[r] + (((cv1 + grey.b[(w - stride1)]) >> 1))) & 255)
                        r = (r + rinc)
                        pos4 = w
                        w = (w + 1)
                        grey.b[pos4] = (cv1 & 255)
                elif (f1 == 4):
                    stride2 = width
                    cv2 = 0
                    _g10 = 0
                    _g11 = width
                    while (_g10 < _g11):
                        x4 = _g10
                        _g10 = (_g10 + 1)
                        numChannels = 1
                        if (numChannels is None):
                            numChannels = 4
                        b = (0 if ((y == 0)) else grey.b[(w - stride2)])
                        c = (0 if (((x4 == 0) or ((y == 0)))) else grey.b[((w - stride2) - numChannels)])
                        k = ((cv2 + b) - c)
                        pa = (k - cv2)
                        if (pa < 0):
                            pa = -pa
                        pb = (k - b)
                        if (pb < 0):
                            pb = -pb
                        pc = (k - c)
                        if (pc < 0):
                            pc = -pc
                        cv2 = ((((cv2 if (((pa <= pb) and ((pa <= pc)))) else (b if ((pb <= pc)) else c))) + data.b[r]) & 255)
                        r = (r + rinc)
                        pos5 = w
                        w = (w + 1)
                        grey.b[pos5] = (cv2 & 255)
                else:
                    raise haxe_Exception.thrown(("Invalid filter " + Std.string(f)))
        else:
            raise haxe_Exception.thrown("Unsupported color mode")
        return grey

    @staticmethod
    def extract32(d,_hx_bytes = None,flipY = None):
        h = format_png_Tools.getHeader(d)
        bgra = (haxe_io_Bytes.alloc(((h.width * h.height) * 4)) if ((_hx_bytes is None)) else _hx_bytes)
        data = None
        fullData = None
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            if (c.index == 2):
                b = c.params[0]
                if (fullData is not None):
                    fullData.b.extend(b.b)
                elif (data is None):
                    data = b
                else:
                    fullData = haxe_io_BytesBuffer()
                    fullData.b.extend(data.b)
                    fullData.b.extend(b.b)
                    data = None
        if (fullData is not None):
            data = fullData.getBytes()
        if (data is None):
            raise haxe_Exception.thrown("Data not found")
        data = format_tools_Inflate.run(data)
        r = 0
        w = 0
        lineDelta = 0
        if flipY:
            lineDelta = (-h.width * 8)
            w = (((h.height - 1)) * ((h.width * 4)))
        flipY1 = (-1 if flipY else 1)
        _g = h.color
        tmp = _g.index
        if (tmp == 0):
            alpha = _g.params[0]
            if (h.colbits != 8):
                raise haxe_Exception.thrown("Unsupported color mode")
            width = h.width
            stride = ((((2 if alpha else 1)) * width) + 1)
            if (data.length < ((h.height * stride))):
                raise haxe_Exception.thrown("Not enough data")
            alphvaIdx = -1
            if (not alpha):
                _g1_head = d.h
                while (_g1_head is not None):
                    val = _g1_head.item
                    _g1_head = _g1_head.next
                    t = val
                    if (t.index == 4):
                        if (t.params[0] == "tRNS"):
                            data1 = t.params[1]
                            if (data1.length >= 2):
                                alphvaIdx = data1.b[1]
                            break
            _g1 = 0
            _g2 = h.height
            while (_g1 < _g2):
                y = _g1
                _g1 = (_g1 + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                f1 = f
                if (f1 == 0):
                    if alpha:
                        _g3 = 0
                        _g4 = width
                        while (_g3 < _g4):
                            x = _g3
                            _g3 = (_g3 + 1)
                            pos1 = r
                            r = (r + 1)
                            v = data.b[pos1]
                            pos2 = w
                            w = (w + 1)
                            bgra.b[pos2] = (v & 255)
                            pos3 = w
                            w = (w + 1)
                            bgra.b[pos3] = (v & 255)
                            pos4 = w
                            w = (w + 1)
                            bgra.b[pos4] = (v & 255)
                            pos5 = w
                            w = (w + 1)
                            pos6 = r
                            r = (r + 1)
                            v1 = data.b[pos6]
                            bgra.b[pos5] = (v1 & 255)
                    else:
                        _g5 = 0
                        _g6 = width
                        while (_g5 < _g6):
                            x1 = _g5
                            _g5 = (_g5 + 1)
                            pos7 = r
                            r = (r + 1)
                            v2 = data.b[pos7]
                            pos8 = w
                            w = (w + 1)
                            bgra.b[pos8] = (v2 & 255)
                            pos9 = w
                            w = (w + 1)
                            bgra.b[pos9] = (v2 & 255)
                            pos10 = w
                            w = (w + 1)
                            bgra.b[pos10] = (v2 & 255)
                            pos11 = w
                            w = (w + 1)
                            bgra.b[pos11] = (((0 if ((v2 == alphvaIdx)) else 255)) & 255)
                elif (f1 == 1):
                    cv = 0
                    ca = 0
                    if alpha:
                        _g7 = 0
                        _g8 = width
                        while (_g7 < _g8):
                            x2 = _g7
                            _g7 = (_g7 + 1)
                            pos12 = r
                            r = (r + 1)
                            cv = (cv + data.b[pos12])
                            pos13 = w
                            w = (w + 1)
                            bgra.b[pos13] = (cv & 255)
                            pos14 = w
                            w = (w + 1)
                            bgra.b[pos14] = (cv & 255)
                            pos15 = w
                            w = (w + 1)
                            bgra.b[pos15] = (cv & 255)
                            pos16 = r
                            r = (r + 1)
                            ca = (ca + data.b[pos16])
                            pos17 = w
                            w = (w + 1)
                            bgra.b[pos17] = (ca & 255)
                    else:
                        _g9 = 0
                        _g10 = width
                        while (_g9 < _g10):
                            x3 = _g9
                            _g9 = (_g9 + 1)
                            pos18 = r
                            r = (r + 1)
                            cv = (cv + data.b[pos18])
                            pos19 = w
                            w = (w + 1)
                            bgra.b[pos19] = (cv & 255)
                            pos20 = w
                            w = (w + 1)
                            bgra.b[pos20] = (cv & 255)
                            pos21 = w
                            w = (w + 1)
                            bgra.b[pos21] = (cv & 255)
                            pos22 = w
                            w = (w + 1)
                            bgra.b[pos22] = (((0 if ((cv == alphvaIdx)) else 255)) & 255)
                elif (f1 == 2):
                    stride = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if alpha:
                        _g11 = 0
                        _g12 = width
                        while (_g11 < _g12):
                            x4 = _g11
                            _g11 = (_g11 + 1)
                            pos23 = r
                            r = (r + 1)
                            v3 = (data.b[pos23] + bgra.b[(w - stride)])
                            pos24 = w
                            w = (w + 1)
                            bgra.b[pos24] = (v3 & 255)
                            pos25 = w
                            w = (w + 1)
                            bgra.b[pos25] = (v3 & 255)
                            pos26 = w
                            w = (w + 1)
                            bgra.b[pos26] = (v3 & 255)
                            pos27 = w
                            w = (w + 1)
                            pos28 = r
                            r = (r + 1)
                            v4 = (data.b[pos28] + bgra.b[(w - stride)])
                            bgra.b[pos27] = (v4 & 255)
                    else:
                        _g13 = 0
                        _g14 = width
                        while (_g13 < _g14):
                            x5 = _g13
                            _g13 = (_g13 + 1)
                            pos29 = r
                            r = (r + 1)
                            v5 = (data.b[pos29] + bgra.b[(w - stride)])
                            pos30 = w
                            w = (w + 1)
                            bgra.b[pos30] = (v5 & 255)
                            pos31 = w
                            w = (w + 1)
                            bgra.b[pos31] = (v5 & 255)
                            pos32 = w
                            w = (w + 1)
                            bgra.b[pos32] = (v5 & 255)
                            pos33 = w
                            w = (w + 1)
                            bgra.b[pos33] = (((0 if ((v5 == alphvaIdx)) else 255)) & 255)
                elif (f1 == 3):
                    cv1 = 0
                    ca1 = 0
                    stride1 = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if alpha:
                        _g15 = 0
                        _g16 = width
                        while (_g15 < _g16):
                            x6 = _g15
                            _g15 = (_g15 + 1)
                            pos34 = r
                            r = (r + 1)
                            cv1 = ((data.b[pos34] + (((cv1 + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos35 = w
                            w = (w + 1)
                            bgra.b[pos35] = (cv1 & 255)
                            pos36 = w
                            w = (w + 1)
                            bgra.b[pos36] = (cv1 & 255)
                            pos37 = w
                            w = (w + 1)
                            bgra.b[pos37] = (cv1 & 255)
                            pos38 = r
                            r = (r + 1)
                            ca1 = ((data.b[pos38] + (((ca1 + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos39 = w
                            w = (w + 1)
                            bgra.b[pos39] = (ca1 & 255)
                    else:
                        _g17 = 0
                        _g18 = width
                        while (_g17 < _g18):
                            x7 = _g17
                            _g17 = (_g17 + 1)
                            pos40 = r
                            r = (r + 1)
                            cv1 = ((data.b[pos40] + (((cv1 + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos41 = w
                            w = (w + 1)
                            bgra.b[pos41] = (cv1 & 255)
                            pos42 = w
                            w = (w + 1)
                            bgra.b[pos42] = (cv1 & 255)
                            pos43 = w
                            w = (w + 1)
                            bgra.b[pos43] = (cv1 & 255)
                            pos44 = w
                            w = (w + 1)
                            bgra.b[pos44] = (((0 if ((cv1 == alphvaIdx)) else 255)) & 255)
                elif (f1 == 4):
                    stride2 = ((width * 4) * flipY1)
                    cv2 = 0
                    ca2 = 0
                    if alpha:
                        _g19 = 0
                        _g20 = width
                        while (_g19 < _g20):
                            x8 = _g19
                            _g19 = (_g19 + 1)
                            b = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k = ((cv2 + b) - c)
                            pa = (k - cv2)
                            if (pa < 0):
                                pa = -pa
                            pb = (k - b)
                            if (pb < 0):
                                pb = -pb
                            pc = (k - c)
                            if (pc < 0):
                                pc = -pc
                            pos45 = r
                            r = (r + 1)
                            cv2 = ((((cv2 if (((pa <= pb) and ((pa <= pc)))) else (b if ((pb <= pc)) else c))) + data.b[pos45]) & 255)
                            pos46 = w
                            w = (w + 1)
                            bgra.b[pos46] = (cv2 & 255)
                            pos47 = w
                            w = (w + 1)
                            bgra.b[pos47] = (cv2 & 255)
                            pos48 = w
                            w = (w + 1)
                            bgra.b[pos48] = (cv2 & 255)
                            b1 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c1 = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k1 = ((ca2 + b1) - c1)
                            pa1 = (k1 - ca2)
                            if (pa1 < 0):
                                pa1 = -pa1
                            pb1 = (k1 - b1)
                            if (pb1 < 0):
                                pb1 = -pb1
                            pc1 = (k1 - c1)
                            if (pc1 < 0):
                                pc1 = -pc1
                            pos49 = r
                            r = (r + 1)
                            ca2 = ((((ca2 if (((pa1 <= pb1) and ((pa1 <= pc1)))) else (b1 if ((pb1 <= pc1)) else c1))) + data.b[pos49]) & 255)
                            pos50 = w
                            w = (w + 1)
                            bgra.b[pos50] = (ca2 & 255)
                    else:
                        _g21 = 0
                        _g22 = width
                        while (_g21 < _g22):
                            x9 = _g21
                            _g21 = (_g21 + 1)
                            b2 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c2 = (0 if (((x9 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k2 = ((cv2 + b2) - c2)
                            pa2 = (k2 - cv2)
                            if (pa2 < 0):
                                pa2 = -pa2
                            pb2 = (k2 - b2)
                            if (pb2 < 0):
                                pb2 = -pb2
                            pc2 = (k2 - c2)
                            if (pc2 < 0):
                                pc2 = -pc2
                            pos51 = r
                            r = (r + 1)
                            cv2 = ((((cv2 if (((pa2 <= pb2) and ((pa2 <= pc2)))) else (b2 if ((pb2 <= pc2)) else c2))) + data.b[pos51]) & 255)
                            pos52 = w
                            w = (w + 1)
                            bgra.b[pos52] = (cv2 & 255)
                            pos53 = w
                            w = (w + 1)
                            bgra.b[pos53] = (cv2 & 255)
                            pos54 = w
                            w = (w + 1)
                            bgra.b[pos54] = (cv2 & 255)
                            pos55 = w
                            w = (w + 1)
                            bgra.b[pos55] = (((0 if ((cv2 == alphvaIdx)) else 255)) & 255)
                else:
                    raise haxe_Exception.thrown(("Invalid filter " + Std.string(f)))
                w = (w + lineDelta)
        elif (tmp == 1):
            alpha = _g.params[0]
            if (h.colbits != 8):
                raise haxe_Exception.thrown("Unsupported color mode")
            width = h.width
            stride = ((((4 if alpha else 3)) * width) + 1)
            if (data.length < ((h.height * stride))):
                raise haxe_Exception.thrown("Not enough data")
            alphaRed = -1
            alphaGreen = -1
            alphaBlue = -1
            if (not alpha):
                _g1_head = d.h
                while (_g1_head is not None):
                    val = _g1_head.item
                    _g1_head = _g1_head.next
                    t = val
                    if (t.index == 4):
                        if (t.params[0] == "tRNS"):
                            data1 = t.params[1]
                            if (data1.length >= 6):
                                alphaRed = data1.b[1]
                                alphaGreen = data1.b[3]
                                alphaBlue = data1.b[5]
                            break
            cr = 0
            cg = 0
            cb = 0
            ca = 0
            _g = 0
            _g1 = h.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                f1 = f
                if (f1 == 0):
                    if alpha:
                        _g2 = 0
                        _g3 = width
                        while (_g2 < _g3):
                            x = _g2
                            _g2 = (_g2 + 1)
                            pos1 = w
                            w = (w + 1)
                            v = data.b[(r + 2)]
                            bgra.b[pos1] = (v & 255)
                            pos2 = w
                            w = (w + 1)
                            v1 = data.b[(r + 1)]
                            bgra.b[pos2] = (v1 & 255)
                            pos3 = w
                            w = (w + 1)
                            v2 = data.b[r]
                            bgra.b[pos3] = (v2 & 255)
                            pos4 = w
                            w = (w + 1)
                            v3 = data.b[(r + 3)]
                            bgra.b[pos4] = (v3 & 255)
                            r = (r + 4)
                    else:
                        _g4 = 0
                        _g5 = width
                        while (_g4 < _g5):
                            x1 = _g4
                            _g4 = (_g4 + 1)
                            pos5 = w
                            w = (w + 1)
                            cb = data.b[(r + 2)]
                            bgra.b[pos5] = (cb & 255)
                            pos6 = w
                            w = (w + 1)
                            cg = data.b[(r + 1)]
                            bgra.b[pos6] = (cg & 255)
                            pos7 = w
                            w = (w + 1)
                            cr = data.b[r]
                            bgra.b[pos7] = (cr & 255)
                            pos8 = w
                            w = (w + 1)
                            bgra.b[pos8] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f1 == 1):
                    ca = 0
                    cb = ca
                    cg = cb
                    cr = cg
                    if alpha:
                        _g6 = 0
                        _g7 = width
                        while (_g6 < _g7):
                            x2 = _g6
                            _g6 = (_g6 + 1)
                            cb = (cb + data.b[(r + 2)])
                            pos9 = w
                            w = (w + 1)
                            bgra.b[pos9] = (cb & 255)
                            cg = (cg + data.b[(r + 1)])
                            pos10 = w
                            w = (w + 1)
                            bgra.b[pos10] = (cg & 255)
                            cr = (cr + data.b[r])
                            pos11 = w
                            w = (w + 1)
                            bgra.b[pos11] = (cr & 255)
                            ca = (ca + data.b[(r + 3)])
                            pos12 = w
                            w = (w + 1)
                            bgra.b[pos12] = (ca & 255)
                            r = (r + 4)
                    else:
                        _g8 = 0
                        _g9 = width
                        while (_g8 < _g9):
                            x3 = _g8
                            _g8 = (_g8 + 1)
                            cb = (cb + data.b[(r + 2)])
                            pos13 = w
                            w = (w + 1)
                            bgra.b[pos13] = (cb & 255)
                            cg = (cg + data.b[(r + 1)])
                            pos14 = w
                            w = (w + 1)
                            bgra.b[pos14] = (cg & 255)
                            cr = (cr + data.b[r])
                            pos15 = w
                            w = (w + 1)
                            bgra.b[pos15] = (cr & 255)
                            pos16 = w
                            w = (w + 1)
                            bgra.b[pos16] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f1 == 2):
                    stride = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if alpha:
                        _g10 = 0
                        _g11 = width
                        while (_g10 < _g11):
                            x4 = _g10
                            _g10 = (_g10 + 1)
                            v4 = (data.b[(r + 2)] + bgra.b[(w - stride)])
                            bgra.b[w] = (v4 & 255)
                            w = (w + 1)
                            v5 = (data.b[(r + 1)] + bgra.b[(w - stride)])
                            bgra.b[w] = (v5 & 255)
                            w = (w + 1)
                            v6 = (data.b[r] + bgra.b[(w - stride)])
                            bgra.b[w] = (v6 & 255)
                            w = (w + 1)
                            v7 = (data.b[(r + 3)] + bgra.b[(w - stride)])
                            bgra.b[w] = (v7 & 255)
                            w = (w + 1)
                            r = (r + 4)
                    else:
                        _g12 = 0
                        _g13 = width
                        while (_g12 < _g13):
                            x5 = _g12
                            _g12 = (_g12 + 1)
                            cb = (data.b[(r + 2)] + bgra.b[(w - stride)])
                            bgra.b[w] = (cb & 255)
                            w = (w + 1)
                            cg = (data.b[(r + 1)] + bgra.b[(w - stride)])
                            bgra.b[w] = (cg & 255)
                            w = (w + 1)
                            cr = (data.b[r] + bgra.b[(w - stride)])
                            bgra.b[w] = (cr & 255)
                            w = (w + 1)
                            pos17 = w
                            w = (w + 1)
                            bgra.b[pos17] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f1 == 3):
                    ca = 0
                    cb = ca
                    cg = cb
                    cr = cg
                    stride1 = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if alpha:
                        _g14 = 0
                        _g15 = width
                        while (_g14 < _g15):
                            x6 = _g14
                            _g14 = (_g14 + 1)
                            cb = ((data.b[(r + 2)] + (((cb + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos18 = w
                            w = (w + 1)
                            bgra.b[pos18] = (cb & 255)
                            cg = ((data.b[(r + 1)] + (((cg + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos19 = w
                            w = (w + 1)
                            bgra.b[pos19] = (cg & 255)
                            cr = ((data.b[r] + (((cr + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos20 = w
                            w = (w + 1)
                            bgra.b[pos20] = (cr & 255)
                            ca = ((data.b[(r + 3)] + (((ca + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos21 = w
                            w = (w + 1)
                            bgra.b[pos21] = (ca & 255)
                            r = (r + 4)
                    else:
                        _g16 = 0
                        _g17 = width
                        while (_g16 < _g17):
                            x7 = _g16
                            _g16 = (_g16 + 1)
                            cb = ((data.b[(r + 2)] + (((cb + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos22 = w
                            w = (w + 1)
                            bgra.b[pos22] = (cb & 255)
                            cg = ((data.b[(r + 1)] + (((cg + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos23 = w
                            w = (w + 1)
                            bgra.b[pos23] = (cg & 255)
                            cr = ((data.b[r] + (((cr + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos24 = w
                            w = (w + 1)
                            bgra.b[pos24] = (cr & 255)
                            pos25 = w
                            w = (w + 1)
                            bgra.b[pos25] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f1 == 4):
                    stride2 = ((width * 4) * flipY1)
                    ca = 0
                    cb = ca
                    cg = cb
                    cr = cg
                    if alpha:
                        _g18 = 0
                        _g19 = width
                        while (_g18 < _g19):
                            x8 = _g18
                            _g18 = (_g18 + 1)
                            b = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k = ((cb + b) - c)
                            pa = (k - cb)
                            if (pa < 0):
                                pa = -pa
                            pb = (k - b)
                            if (pb < 0):
                                pb = -pb
                            pc = (k - c)
                            if (pc < 0):
                                pc = -pc
                            cb = ((((cb if (((pa <= pb) and ((pa <= pc)))) else (b if ((pb <= pc)) else c))) + data.b[(r + 2)]) & 255)
                            pos26 = w
                            w = (w + 1)
                            bgra.b[pos26] = (cb & 255)
                            b1 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c1 = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k1 = ((cg + b1) - c1)
                            pa1 = (k1 - cg)
                            if (pa1 < 0):
                                pa1 = -pa1
                            pb1 = (k1 - b1)
                            if (pb1 < 0):
                                pb1 = -pb1
                            pc1 = (k1 - c1)
                            if (pc1 < 0):
                                pc1 = -pc1
                            cg = ((((cg if (((pa1 <= pb1) and ((pa1 <= pc1)))) else (b1 if ((pb1 <= pc1)) else c1))) + data.b[(r + 1)]) & 255)
                            pos27 = w
                            w = (w + 1)
                            bgra.b[pos27] = (cg & 255)
                            b2 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c2 = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k2 = ((cr + b2) - c2)
                            pa2 = (k2 - cr)
                            if (pa2 < 0):
                                pa2 = -pa2
                            pb2 = (k2 - b2)
                            if (pb2 < 0):
                                pb2 = -pb2
                            pc2 = (k2 - c2)
                            if (pc2 < 0):
                                pc2 = -pc2
                            cr = ((((cr if (((pa2 <= pb2) and ((pa2 <= pc2)))) else (b2 if ((pb2 <= pc2)) else c2))) + data.b[r]) & 255)
                            pos28 = w
                            w = (w + 1)
                            bgra.b[pos28] = (cr & 255)
                            b3 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c3 = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k3 = ((ca + b3) - c3)
                            pa3 = (k3 - ca)
                            if (pa3 < 0):
                                pa3 = -pa3
                            pb3 = (k3 - b3)
                            if (pb3 < 0):
                                pb3 = -pb3
                            pc3 = (k3 - c3)
                            if (pc3 < 0):
                                pc3 = -pc3
                            ca = ((((ca if (((pa3 <= pb3) and ((pa3 <= pc3)))) else (b3 if ((pb3 <= pc3)) else c3))) + data.b[(r + 3)]) & 255)
                            pos29 = w
                            w = (w + 1)
                            bgra.b[pos29] = (ca & 255)
                            r = (r + 4)
                    else:
                        _g20 = 0
                        _g21 = width
                        while (_g20 < _g21):
                            x9 = _g20
                            _g20 = (_g20 + 1)
                            b4 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c4 = (0 if (((x9 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k4 = ((cb + b4) - c4)
                            pa4 = (k4 - cb)
                            if (pa4 < 0):
                                pa4 = -pa4
                            pb4 = (k4 - b4)
                            if (pb4 < 0):
                                pb4 = -pb4
                            pc4 = (k4 - c4)
                            if (pc4 < 0):
                                pc4 = -pc4
                            cb = ((((cb if (((pa4 <= pb4) and ((pa4 <= pc4)))) else (b4 if ((pb4 <= pc4)) else c4))) + data.b[(r + 2)]) & 255)
                            pos30 = w
                            w = (w + 1)
                            bgra.b[pos30] = (cb & 255)
                            b5 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c5 = (0 if (((x9 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k5 = ((cg + b5) - c5)
                            pa5 = (k5 - cg)
                            if (pa5 < 0):
                                pa5 = -pa5
                            pb5 = (k5 - b5)
                            if (pb5 < 0):
                                pb5 = -pb5
                            pc5 = (k5 - c5)
                            if (pc5 < 0):
                                pc5 = -pc5
                            cg = ((((cg if (((pa5 <= pb5) and ((pa5 <= pc5)))) else (b5 if ((pb5 <= pc5)) else c5))) + data.b[(r + 1)]) & 255)
                            pos31 = w
                            w = (w + 1)
                            bgra.b[pos31] = (cg & 255)
                            b6 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c6 = (0 if (((x9 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k6 = ((cr + b6) - c6)
                            pa6 = (k6 - cr)
                            if (pa6 < 0):
                                pa6 = -pa6
                            pb6 = (k6 - b6)
                            if (pb6 < 0):
                                pb6 = -pb6
                            pc6 = (k6 - c6)
                            if (pc6 < 0):
                                pc6 = -pc6
                            cr = ((((cr if (((pa6 <= pb6) and ((pa6 <= pc6)))) else (b6 if ((pb6 <= pc6)) else c6))) + data.b[r]) & 255)
                            pos32 = w
                            w = (w + 1)
                            bgra.b[pos32] = (cr & 255)
                            pos33 = w
                            w = (w + 1)
                            bgra.b[pos33] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                else:
                    raise haxe_Exception.thrown(("Invalid filter " + Std.string(f)))
                w = (w + lineDelta)
        elif (tmp == 2):
            pal = format_png_Tools.getPalette(d)
            if (pal is None):
                raise haxe_Exception.thrown("PNG Palette is missing")
            alpha = None
            _g1_head = d.h
            while (_g1_head is not None):
                val = _g1_head.item
                _g1_head = _g1_head.next
                t = val
                if (t.index == 4):
                    if (t.params[0] == "tRNS"):
                        data1 = t.params[1]
                        alpha = data1
                        break
            if ((alpha is not None) and ((alpha.length < ((1 << h.colbits))))):
                alpha2 = haxe_io_Bytes.alloc((1 << h.colbits))
                alpha2.blit(0,alpha,0,alpha.length)
                alpha2.fill(alpha.length,(alpha2.length - alpha.length),255)
                alpha = alpha2
            width = h.width
            stride = (Math.ceil(((width * h.colbits) / 8)) + 1)
            if (data.length < ((h.height * stride))):
                raise haxe_Exception.thrown("Not enough data")
            tmp = (h.width * h.colbits)
            rline = (tmp >> 3)
            _g = 0
            _g1 = h.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                if (f == 0):
                    r = (r + rline)
                    continue
                f1 = f
                if (f1 == 1):
                    c = 0
                    _g2 = 0
                    _g3 = width
                    while (_g2 < _g3):
                        x = _g2
                        _g2 = (_g2 + 1)
                        v = data.b[r]
                        c = (c + v)
                        pos1 = r
                        r = (r + 1)
                        data.b[pos1] = ((c & 255) & 255)
                elif (f1 == 2):
                    stride = (0 if ((y == 0)) else (rline + 1))
                    _g4 = 0
                    _g5 = width
                    while (_g4 < _g5):
                        x1 = _g4
                        _g4 = (_g4 + 1)
                        v1 = data.b[r]
                        v2 = (v1 + data.b[(r - stride)])
                        data.b[r] = (v2 & 255)
                        r = (r + 1)
                elif (f1 == 3):
                    c1 = 0
                    stride1 = (0 if ((y == 0)) else (rline + 1))
                    _g6 = 0
                    _g7 = width
                    while (_g6 < _g7):
                        x2 = _g6
                        _g6 = (_g6 + 1)
                        v3 = data.b[r]
                        c1 = ((v3 + (((c1 + data.b[(r - stride1)]) >> 1))) & 255)
                        pos2 = r
                        r = (r + 1)
                        data.b[pos2] = (c1 & 255)
                elif (f1 == 4):
                    stride2 = (rline + 1)
                    c2 = 0
                    _g8 = 0
                    _g9 = width
                    while (_g8 < _g9):
                        x3 = _g8
                        _g8 = (_g8 + 1)
                        v4 = data.b[r]
                        numChannels = 1
                        if (numChannels is None):
                            numChannels = 4
                        b = (0 if ((y == 0)) else data.b[(r - stride2)])
                        c3 = (0 if (((x3 == 0) or ((y == 0)))) else data.b[((r - stride2) - numChannels)])
                        k = ((c2 + b) - c3)
                        pa = (k - c2)
                        if (pa < 0):
                            pa = -pa
                        pb = (k - b)
                        if (pb < 0):
                            pb = -pb
                        pc = (k - c3)
                        if (pc < 0):
                            pc = -pc
                        c2 = ((((c2 if (((pa <= pb) and ((pa <= pc)))) else (b if ((pb <= pc)) else c3))) + v4) & 255)
                        pos3 = r
                        r = (r + 1)
                        data.b[pos3] = (c2 & 255)
                else:
                    raise haxe_Exception.thrown(("Invalid filter " + Std.string(f)))
            r = 0
            if (h.colbits == 8):
                _g = 0
                _g1 = h.height
                while (_g < _g1):
                    y = _g
                    _g = (_g + 1)
                    r = (r + 1)
                    _g2 = 0
                    _g3 = h.width
                    while (_g2 < _g3):
                        x = _g2
                        _g2 = (_g2 + 1)
                        pos = r
                        r = (r + 1)
                        c = data.b[pos]
                        pos1 = w
                        w = (w + 1)
                        v = pal.b[((c * 3) + 2)]
                        bgra.b[pos1] = (v & 255)
                        pos2 = w
                        w = (w + 1)
                        v1 = pal.b[((c * 3) + 1)]
                        bgra.b[pos2] = (v1 & 255)
                        pos3 = w
                        w = (w + 1)
                        v2 = pal.b[(c * 3)]
                        bgra.b[pos3] = (v2 & 255)
                        pos4 = w
                        w = (w + 1)
                        v3 = (alpha.b[c] if ((alpha is not None)) else 255)
                        bgra.b[pos4] = (v3 & 255)
                    w = (w + lineDelta)
            elif (h.colbits < 8):
                req = h.colbits
                mask = (((1 << req)) - 1)
                _g = 0
                _g1 = h.height
                while (_g < _g1):
                    y = _g
                    _g = (_g + 1)
                    r = (r + 1)
                    bits = 0
                    nbits = 0
                    _g2 = 0
                    _g3 = h.width
                    while (_g2 < _g3):
                        x = _g2
                        _g2 = (_g2 + 1)
                        if (nbits < req):
                            pos = r
                            r = (r + 1)
                            bits = ((bits << 8) | data.b[pos])
                            nbits = (nbits + 8)
                        c = (HxOverrides.rshift(bits, ((nbits - req))) & mask)
                        nbits = (nbits - req)
                        pos1 = w
                        w = (w + 1)
                        v = pal.b[((c * 3) + 2)]
                        bgra.b[pos1] = (v & 255)
                        pos2 = w
                        w = (w + 1)
                        v1 = pal.b[((c * 3) + 1)]
                        bgra.b[pos2] = (v1 & 255)
                        pos3 = w
                        w = (w + 1)
                        v2 = pal.b[(c * 3)]
                        bgra.b[pos3] = (v2 & 255)
                        pos4 = w
                        w = (w + 1)
                        v3 = (alpha.b[c] if ((alpha is not None)) else 255)
                        bgra.b[pos4] = (v3 & 255)
                    w = (w + lineDelta)
            else:
                raise haxe_Exception.thrown((Std.string(h.colbits) + " indexed bits per pixel not supported"))
        else:
            pass
        return bgra

    @staticmethod
    def buildGrey(width,height,data,level = None):
        if (level is None):
            level = 9
        rgb = haxe_io_Bytes.alloc(((width * height) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgb.b[pos] = 0
            _g2 = 0
            _g3 = width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                pos2 = r
                r = (r + 1)
                v = data.b[pos2]
                rgb.b[pos1] = (v & 255)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColGrey(False), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def buildIndexed(width,height,data,palette,level = None):
        if (level is None):
            level = 9
        rgb = haxe_io_Bytes.alloc(((width * height) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgb.b[pos] = 0
            _g2 = 0
            _g3 = width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                pos2 = r
                r = (r + 1)
                v = data.b[pos2]
                rgb.b[pos1] = (v & 255)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColIndexed, 'interlaced': False})))
        l.add(format_png_Chunk.CPalette(palette))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def buildRGB(width,height,data,level = None):
        if (level is None):
            level = 9
        rgb = haxe_io_Bytes.alloc((((width * height) * 3) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgb.b[pos] = 0
            _g2 = 0
            _g3 = width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                v = data.b[(r + 2)]
                rgb.b[pos1] = (v & 255)
                pos2 = w
                w = (w + 1)
                v1 = data.b[(r + 1)]
                rgb.b[pos2] = (v1 & 255)
                pos3 = w
                w = (w + 1)
                v2 = data.b[r]
                rgb.b[pos3] = (v2 & 255)
                r = (r + 3)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColTrue(False), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def build32ARGB(width,height,data,level = None):
        if (level is None):
            level = 9
        rgba = haxe_io_Bytes.alloc((((width * height) * 4) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgba.b[pos] = 0
            _g2 = 0
            _g3 = width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                v = data.b[(r + 1)]
                rgba.b[pos1] = (v & 255)
                pos2 = w
                w = (w + 1)
                v1 = data.b[(r + 2)]
                rgba.b[pos2] = (v1 & 255)
                pos3 = w
                w = (w + 1)
                v2 = data.b[(r + 3)]
                rgba.b[pos3] = (v2 & 255)
                pos4 = w
                w = (w + 1)
                v3 = data.b[r]
                rgba.b[pos4] = (v3 & 255)
                r = (r + 4)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColTrue(True), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def build32BGRA(width,height,data,level = None):
        if (level is None):
            level = 9
        rgba = haxe_io_Bytes.alloc((((width * height) * 4) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgba.b[pos] = 0
            _g2 = 0
            _g3 = width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                v = data.b[(r + 2)]
                rgba.b[pos1] = (v & 255)
                pos2 = w
                w = (w + 1)
                v1 = data.b[(r + 1)]
                rgba.b[pos2] = (v1 & 255)
                pos3 = w
                w = (w + 1)
                v2 = data.b[r]
                rgba.b[pos3] = (v2 & 255)
                pos4 = w
                w = (w + 1)
                v3 = data.b[(r + 3)]
                rgba.b[pos4] = (v3 & 255)
                r = (r + 4)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColTrue(True), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)))
        l.add(format_png_Chunk.CEnd)
        return l
format_png_Tools._hx_class = format_png_Tools
_hx_classes["format.png.Tools"] = format_png_Tools


class format_png_Writer:
    _hx_class_name = "format.png.Writer"
    _hx_is_interface = "False"
    __slots__ = ("o",)
    _hx_fields = ["o"]
    _hx_methods = ["write", "writeChunk"]

    def __init__(self,o):
        self.o = o
        o.set_bigEndian(True)

    def write(self,png):
        b = 137
        self.o.writeByte(b)
        b = 80
        self.o.writeByte(b)
        b = 78
        self.o.writeByte(b)
        b = 71
        self.o.writeByte(b)
        b = 13
        self.o.writeByte(b)
        b = 10
        self.o.writeByte(b)
        b = 26
        self.o.writeByte(b)
        b = 10
        self.o.writeByte(b)
        _g_head = png.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            tmp = c.index
            if (tmp == 0):
                self.writeChunk("IEND",haxe_io_Bytes.alloc(0))
            elif (tmp == 1):
                h = c.params[0]
                b = haxe_io_BytesOutput()
                b.set_bigEndian(True)
                b.writeInt32(h.width)
                b.writeInt32(h.height)
                b.writeByte(h.colbits)
                _g = h.color
                tmp1 = None
                tmp2 = _g.index
                if (tmp2 == 0):
                    alpha = _g.params[0]
                    tmp1 = (4 if alpha else 0)
                elif (tmp2 == 1):
                    alpha1 = _g.params[0]
                    tmp1 = (6 if alpha1 else 2)
                elif (tmp2 == 2):
                    tmp1 = 3
                else:
                    pass
                b.writeByte(tmp1)
                b.writeByte(0)
                b.writeByte(0)
                b.writeByte((1 if (h.interlaced) else 0))
                self.writeChunk("IHDR",b.getBytes())
            elif (tmp == 2):
                d = c.params[0]
                self.writeChunk("IDAT",d)
            elif (tmp == 3):
                b1 = c.params[0]
                self.writeChunk("PLTE",b1)
            elif (tmp == 4):
                id = c.params[0]
                data = c.params[1]
                self.writeChunk(id,data)
            else:
                pass

    def writeChunk(self,id,data):
        self.o.writeInt32(data.length)
        self.o.writeString(id)
        self.o.write(data)
        crc_crc = -1
        tmp = (((crc_crc ^ HxString.charCodeAt(id,0))) & 255)
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        tmp = (((crc_crc ^ HxString.charCodeAt(id,1))) & 255)
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        tmp = (((crc_crc ^ HxString.charCodeAt(id,2))) & 255)
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        tmp = (((crc_crc ^ HxString.charCodeAt(id,3))) & 255)
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        b = data.b
        _g = 0
        _g1 = data.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            tmp = (((crc_crc ^ b[i])) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        self.o.writeInt32((crc_crc ^ -1))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.o = None
format_png_Writer._hx_class = format_png_Writer
_hx_classes["format.png.Writer"] = format_png_Writer

class format_tga_ImageOrigin(Enum):
    __slots__ = ()
    _hx_class_name = "format.tga.ImageOrigin"
    _hx_constructs = ["BottomLeft", "BottomRight", "TopLeft", "TopRight"]
format_tga_ImageOrigin.BottomLeft = format_tga_ImageOrigin("BottomLeft", 0, ())
format_tga_ImageOrigin.BottomRight = format_tga_ImageOrigin("BottomRight", 1, ())
format_tga_ImageOrigin.TopLeft = format_tga_ImageOrigin("TopLeft", 2, ())
format_tga_ImageOrigin.TopRight = format_tga_ImageOrigin("TopRight", 3, ())
format_tga_ImageOrigin._hx_class = format_tga_ImageOrigin
_hx_classes["format.tga.ImageOrigin"] = format_tga_ImageOrigin

class format_tga_ImageType(Enum):
    __slots__ = ()
    _hx_class_name = "format.tga.ImageType"
    _hx_constructs = ["NoImage", "UncompressedColorMapped", "UncompressedTrueColor", "UncompressedBlackAndWhite", "RunLengthColorMapped", "RunLengthTrueColor", "RunLengthBlackAndWhite", "Unknown"]

    @staticmethod
    def Unknown(type):
        return format_tga_ImageType("Unknown", 7, (type,))
format_tga_ImageType.NoImage = format_tga_ImageType("NoImage", 0, ())
format_tga_ImageType.UncompressedColorMapped = format_tga_ImageType("UncompressedColorMapped", 1, ())
format_tga_ImageType.UncompressedTrueColor = format_tga_ImageType("UncompressedTrueColor", 2, ())
format_tga_ImageType.UncompressedBlackAndWhite = format_tga_ImageType("UncompressedBlackAndWhite", 3, ())
format_tga_ImageType.RunLengthColorMapped = format_tga_ImageType("RunLengthColorMapped", 4, ())
format_tga_ImageType.RunLengthTrueColor = format_tga_ImageType("RunLengthTrueColor", 5, ())
format_tga_ImageType.RunLengthBlackAndWhite = format_tga_ImageType("RunLengthBlackAndWhite", 6, ())
format_tga_ImageType._hx_class = format_tga_ImageType
_hx_classes["format.tga.ImageType"] = format_tga_ImageType


class format_tga_Reader:
    _hx_class_name = "format.tga.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i",)
    _hx_fields = ["i"]
    _hx_methods = ["read", "readHeader", "readColorMapData", "readImageData", "readPixels", "readMono", "readIndexes", "parsePixel1", "parsePixelGreyAlpha", "parsePixel2", "parsePixel3", "parsePixel4"]

    def __init__(self,i):
        self.i = i
        i.set_bigEndian(False)

    def read(self):
        idLength = self.i.readByte()
        header = self.readHeader()
        id = ("" if ((idLength == 0)) else self.i.readString(idLength))
        colorMap = self.readColorMapData(header)
        return _hx_AnonObject({'header': header, 'imageId': id, 'colorMapData': colorMap, 'imageData': self.readImageData(header,colorMap), 'developerData': None})

    def readHeader(self):
        colorMapType = self.i.readByte()
        dataType = None
        dataId = self.i.readByte()
        dataId1 = dataId
        if (dataId1 == 0):
            dataType = format_tga_ImageType.NoImage
        elif (dataId1 == 1):
            dataType = format_tga_ImageType.UncompressedColorMapped
        elif (dataId1 == 2):
            dataType = format_tga_ImageType.UncompressedTrueColor
        elif (dataId1 == 3):
            dataType = format_tga_ImageType.UncompressedBlackAndWhite
        elif (dataId1 == 9):
            dataType = format_tga_ImageType.RunLengthColorMapped
        elif (dataId1 == 10):
            dataType = format_tga_ImageType.RunLengthTrueColor
        elif (dataId1 == 11):
            dataType = format_tga_ImageType.RunLengthBlackAndWhite
        else:
            dataType = format_tga_ImageType.Unknown(dataId)
        colorMapOrigin = self.i.readInt16()
        colorMapLength = self.i.readInt16()
        colorMapDepth = self.i.readByte()
        xOrigin = self.i.readInt16()
        yOrigin = self.i.readInt16()
        width = self.i.readInt16()
        height = self.i.readInt16()
        depth = self.i.readByte()
        descriptor = self.i.readByte()
        origin = None
        _g = (descriptor & 48)
        if (_g == 16):
            origin = format_tga_ImageOrigin.BottomRight
        elif (_g == 32):
            origin = format_tga_ImageOrigin.TopLeft
        elif (_g == 48):
            origin = format_tga_ImageOrigin.TopRight
        else:
            origin = format_tga_ImageOrigin.BottomLeft
        return _hx_AnonObject({'colorMapType': colorMapType, 'imageType': dataType, 'colorMapFirstIndex': colorMapOrigin, 'colorMapLength': colorMapLength, 'colorMapEntrySize': colorMapDepth, 'xOrigin': xOrigin, 'yOrigin': yOrigin, 'width': width, 'height': height, 'bitsPerPixel': depth, 'alphaChannelBits': (descriptor & 15), 'imageOrigin': origin})

    def readColorMapData(self,header):
        if (header.colorMapType == 0):
            return None
        return self.readPixels(header.colorMapEntrySize,header.colorMapLength,header.alphaChannelBits,False)

    def readImageData(self,header,colorMap):
        tmp = header.imageType.index
        if (tmp == 0):
            return None
        elif (tmp == 1):
            return self.readIndexes(header.bitsPerPixel,(header.width * header.height),colorMap,header.colorMapFirstIndex,False)
        elif (tmp == 2):
            return self.readPixels(header.bitsPerPixel,(header.width * header.height),header.alphaChannelBits,False)
        elif (tmp == 3):
            return self.readMono(header.bitsPerPixel,(header.width * header.height),header.alphaChannelBits,False)
        elif (tmp == 4):
            return self.readIndexes(header.bitsPerPixel,(header.width * header.height),colorMap,header.colorMapFirstIndex,True)
        elif (tmp == 5):
            return self.readPixels(header.bitsPerPixel,(header.width * header.height),header.alphaChannelBits,True)
        elif (tmp == 6):
            return self.readMono(header.bitsPerPixel,(header.width * header.height),header.alphaChannelBits,True)
        else:
            raise haxe_Exception.thrown("Unsupported image data type!")

    def readPixels(self,bitsPerPixel,amount,alphaChannelBits,rle):
        this1 = [None]*amount
        _hx_list = this1
        alpha = (alphaChannelBits != 0)
        bitFieldSize = None
        try:
            bitFieldSize = int((bitsPerPixel / 3))
        except BaseException as _g:
            None
            bitFieldSize = None
        bitFieldSize1 = bitFieldSize
        if (bitFieldSize1 > 8):
            bitFieldSize1 = 8
        parsePixel = None
        readEntry = None
        bitsPerPixel1 = bitsPerPixel
        if (bitsPerPixel1 == 8):
            readEntry = self.i.readByte
            parsePixel = self.parsePixel1
        elif (bitsPerPixel1 == 16):
            readEntry = self.i.readUInt16
            parsePixel = self.parsePixel2
        elif (bitsPerPixel1 == 24):
            readEntry = self.i.readUInt24
            parsePixel = self.parsePixel3
        elif (bitsPerPixel1 == 32):
            readEntry = self.i.readInt32
            parsePixel = self.parsePixel4
        else:
            raise haxe_Exception.thrown("Unsupported bits per pixels amount!")
        if rle:
            rleChunk = None
            i = 0
            while (i < amount):
                rleChunk = self.i.readByte()
                if (((rleChunk & 128)) != 0):
                    rleChunk = (rleChunk & 127)
                    pixel = parsePixel(readEntry(),alpha)
                    while (rleChunk >= 0):
                        index = i
                        i = (i + 1)
                        _hx_list[index] = pixel
                        rleChunk = (rleChunk - 1)
                else:
                    rleChunk = (rleChunk & 127)
                    while (rleChunk >= 0):
                        index1 = i
                        i = (i + 1)
                        val = parsePixel(readEntry(),alpha)
                        _hx_list[index1] = val
                        rleChunk = (rleChunk - 1)
        else:
            _g = 0
            _g1 = amount
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                val = parsePixel(readEntry(),alpha)
                _hx_list[i] = val
        return _hx_list

    def readMono(self,bitsPerPixel,amount,alphaChannelBits,rle):
        this1 = [None]*amount
        _hx_list = this1
        alpha = (alphaChannelBits != 0)
        parsePixel = None
        readEntry = None
        bitsPerPixel1 = bitsPerPixel
        if (bitsPerPixel1 == 8):
            readEntry = self.i.readByte
            parsePixel = self.parsePixel1
        elif (bitsPerPixel1 == 16):
            readEntry = self.i.readUInt16
            parsePixel = self.parsePixelGreyAlpha
        else:
            raise haxe_Exception.thrown("Unsupported bits per pixels amount!")
        if rle:
            rleChunk = None
            i = 0
            while (i < amount):
                rleChunk = self.i.readByte()
                if (((rleChunk & 128)) != 0):
                    rleChunk = (rleChunk & 127)
                    pixel = parsePixel(readEntry(),alpha)
                    while (rleChunk >= 0):
                        index = i
                        i = (i + 1)
                        _hx_list[index] = pixel
                        rleChunk = (rleChunk - 1)
                else:
                    rleChunk = (rleChunk & 127)
                    while (rleChunk >= 0):
                        index1 = i
                        i = (i + 1)
                        val = parsePixel(readEntry(),alpha)
                        _hx_list[index1] = val
                        rleChunk = (rleChunk - 1)
        else:
            _g = 0
            _g1 = amount
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                val = parsePixel(readEntry(),alpha)
                _hx_list[i] = val
        return _hx_list

    def readIndexes(self,bitsPerPixel,amount,colorMap,offset,rle):
        this1 = [None]*amount
        _hx_list = this1
        readEntry = None
        bitsPerPixel1 = bitsPerPixel
        if (bitsPerPixel1 == 8):
            readEntry = self.i.readByte
        elif (bitsPerPixel1 == 16):
            readEntry = self.i.readUInt16
        elif (bitsPerPixel1 == 24):
            readEntry = self.i.readUInt24
        elif (bitsPerPixel1 == 32):
            readEntry = self.i.readInt32
        else:
            raise haxe_Exception.thrown("Unsupported bits per pixels amount!")
        if rle:
            i = 0
            rleChunk = None
            while (i < amount):
                rleChunk = self.i.readByte()
                if (((rleChunk & 128)) != 0):
                    rleChunk = (rleChunk & 127)
                    pixel = colorMap[(offset + readEntry())]
                    while (rleChunk >= 0):
                        index = i
                        i = (i + 1)
                        _hx_list[index] = pixel
                        rleChunk = (rleChunk - 1)
                else:
                    rleChunk = (rleChunk & 127)
                    while (rleChunk >= 0):
                        index1 = i
                        i = (i + 1)
                        val = colorMap[(offset + readEntry())]
                        _hx_list[index1] = val
                        rleChunk = (rleChunk - 1)
        else:
            _g = 0
            _g1 = amount
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                val = colorMap[(offset + readEntry())]
                _hx_list[i] = val
        return _hx_list

    def parsePixel1(self,value,alpha):
        return (((value << 16) | ((value << 8))) | value)

    def parsePixelGreyAlpha(self,value,alpha):
        return ((((((value & 65280)) << 16) if alpha else 0)) | self.parsePixel1((value & 255),False))

    def parsePixel2(self,value,alpha):
        tmp = ((-16777216 if ((((value & 32768)) == 1)) else 0) if alpha else 0)
        tmp1 = None
        try:
            tmp1 = int(((((((value & 31744)) >> 10)) / 31) * 255))
        except BaseException as _g:
            None
            tmp1 = None
        tmp2 = (tmp | ((tmp1 << 16)))
        tmp = None
        try:
            tmp = int(((((((value & 992)) >> 5)) / 31) * 255))
        except BaseException as _g:
            None
            tmp = None
        tmp1 = (tmp2 | ((tmp << 8)))
        tmp = None
        try:
            tmp = int(((((value & 31)) / 31) * 255))
        except BaseException as _g:
            None
            tmp = None
        return (tmp1 | tmp)

    def parsePixel3(self,value,alpha):
        return value

    def parsePixel4(self,value,alpha):
        return value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
format_tga_Reader._hx_class = format_tga_Reader
_hx_classes["format.tga.Reader"] = format_tga_Reader


class format_tools_BitsInput:
    _hx_class_name = "format.tools.BitsInput"
    _hx_is_interface = "False"
    __slots__ = ("i", "nbits", "bits")
    _hx_fields = ["i", "nbits", "bits"]
    _hx_methods = ["readBits", "readBit", "reset"]

    def __init__(self,i):
        self.i = i
        self.nbits = 0
        self.bits = 0

    def readBits(self,n):
        if (self.nbits >= n):
            c = (self.nbits - n)
            k = (HxOverrides.rshift(self.bits, c) & ((((1 << n)) - 1)))
            self.nbits = c
            return k
        k = self.i.readByte()
        if (self.nbits >= 24):
            if (n > 31):
                raise haxe_Exception.thrown("Bits error")
            c = ((8 + self.nbits) - n)
            d = (self.bits & ((((1 << self.nbits)) - 1)))
            d = ((d << ((8 - c))) | ((k << c)))
            self.bits = k
            self.nbits = c
            return d
        self.bits = ((self.bits << 8) | k)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nbits
        _hx_local_0.nbits = (_hx_local_1 + 8)
        _hx_local_0.nbits
        return self.readBits(n)

    def readBit(self):
        if (self.nbits == 0):
            self.bits = self.i.readByte()
            self.nbits = 8
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nbits
        _hx_local_0.nbits = (_hx_local_1 - 1)
        _hx_local_1
        return (((HxOverrides.rshift(self.bits, self.nbits) & 1)) == 1)

    def reset(self):
        self.nbits = 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.nbits = None
        _hx_o.bits = None
format_tools_BitsInput._hx_class = format_tools_BitsInput
_hx_classes["format.tools.BitsInput"] = format_tools_BitsInput


class format_tools_Deflate:
    _hx_class_name = "format.tools.Deflate"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(b,level = None):
        if (level is None):
            level = 9
        return haxe_zip_Compress.run(b,level)
format_tools_Deflate._hx_class = format_tools_Deflate
_hx_classes["format.tools.Deflate"] = format_tools_Deflate


class format_tools_Inflate:
    _hx_class_name = "format.tools.Inflate"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(_hx_bytes):
        return haxe_zip_Uncompress.run(_hx_bytes)
format_tools_Inflate._hx_class = format_tools_Inflate
_hx_classes["format.tools.Inflate"] = format_tools_Inflate

class format_wav_WAVEFormat(Enum):
    __slots__ = ()
    _hx_class_name = "format.wav.WAVEFormat"
    _hx_constructs = ["WF_PCM"]
format_wav_WAVEFormat.WF_PCM = format_wav_WAVEFormat("WF_PCM", 0, ())
format_wav_WAVEFormat._hx_class = format_wav_WAVEFormat
_hx_classes["format.wav.WAVEFormat"] = format_wav_WAVEFormat


class format_wav_Reader:
    _hx_class_name = "format.wav.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i", "version")
    _hx_fields = ["i", "version"]
    _hx_methods = ["readInt", "read"]

    def __init__(self,i):
        self.version = None
        self.i = i
        i.set_bigEndian(False)

    def readInt(self):
        return self.i.readInt32()

    def read(self):
        if (self.i.readString(4) != "RIFF"):
            raise haxe_Exception.thrown("RIFF header expected")
        _hx_len = self.i.readInt32()
        if (self.i.readString(4) != "WAVE"):
            raise haxe_Exception.thrown("WAVE signature not found")
        fmt = self.i.readString(4)
        while (fmt != "fmt "):
            fmt1 = fmt
            if (fmt1 == "JUNK"):
                junkLen = self.i.readInt32()
                self.i.read(junkLen)
                fmt = self.i.readString(4)
            elif (fmt1 == "bext"):
                bextLen = self.i.readInt32()
                self.i.read(bextLen)
                fmt = self.i.readString(4)
            else:
                break
        if (fmt != "fmt "):
            raise haxe_Exception.thrown(("unsupported wave chunk " + ("null" if fmt is None else fmt)))
        fmtlen = self.i.readInt32()
        format = None
        _g = self.i.readUInt16()
        if ((_g == 3) or ((_g == 1))):
            format = format_wav_WAVEFormat.WF_PCM
        else:
            raise haxe_Exception.thrown("only PCM (uncompressed) WAV files are supported")
        channels = self.i.readUInt16()
        samplingRate = self.i.readInt32()
        byteRate = self.i.readInt32()
        blockAlign = self.i.readUInt16()
        bitsPerSample = self.i.readUInt16()
        if (fmtlen > 16):
            self.i.read((fmtlen - 16))
        nextChunk = self.i.readString(4)
        while (nextChunk != "data"):
            self.i.read(self.i.readInt32())
            nextChunk = self.i.readString(4)
        if (nextChunk != "data"):
            raise haxe_Exception.thrown("expected data subchunk")
        datalen = self.i.readInt32()
        data = None
        try:
            data = self.i.read(datalen)
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof):
                raise haxe_Exception.thrown("Invalid chunk data length")
            else:
                raise _g
        cuePoints = list()
        try:
            while True:
                nextChunk = self.i.readString(4)
                if (nextChunk == "cue "):
                    self.i.readInt32()
                    nbCuePoints = self.i.readInt32()
                    _g = 0
                    _g1 = nbCuePoints
                    while (_g < _g1):
                        _ = _g
                        _g = (_g + 1)
                        cueId = self.i.readInt32()
                        self.i.readInt32()
                        self.i.readString(4)
                        self.i.readInt32()
                        self.i.readInt32()
                        cueSampleOffset = self.i.readInt32()
                        cuePoints.append(_hx_AnonObject({'id': cueId, 'sampleOffset': cueSampleOffset}))
                else:
                    self.i.read(self.i.readInt32())
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return _hx_AnonObject({'header': _hx_AnonObject({'format': format, 'channels': channels, 'samplingRate': samplingRate, 'byteRate': byteRate, 'blockAlign': blockAlign, 'bitsPerSample': bitsPerSample}), 'data': data, 'cuePoints': cuePoints})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.version = None
format_wav_Reader._hx_class = format_wav_Reader
_hx_classes["format.wav.Reader"] = format_wav_Reader


class h2d_Object:
    _hx_class_name = "h2d.Object"
    _hx_is_interface = "False"
    __slots__ = ("children", "parentContainer", "parent", "name", "x", "y", "scaleX", "scaleY", "rotation", "visible", "alpha", "filter", "blendMode", "matA", "matB", "matC", "matD", "absX", "absY", "posChanged", "allocated", "lastFrame")
    _hx_fields = ["children", "parentContainer", "parent", "name", "x", "y", "scaleX", "scaleY", "rotation", "visible", "alpha", "filter", "blendMode", "matA", "matB", "matC", "matD", "absX", "absY", "posChanged", "allocated", "lastFrame"]
    _hx_methods = ["getBounds", "getSize", "getAbsPos", "contains", "find", "findAll", "set_filter", "getBoundsRec", "addBounds", "getObjectsCount", "localToGlobal", "globalToLocal", "getScene", "set_visible", "addChild", "addChildAt", "onContentChanged", "onHierarchyMoved", "onAdd", "onRemove", "getMatrix", "removeChild", "setParentContainer", "removeChildren", "remove", "drawTo", "drawToTextures", "draw", "sync", "syncPos", "calcAbsPos", "emitTile", "clipBounds", "drawFilters", "drawFiltered", "drawRec", "drawContent", "set_x", "set_y", "set_scaleX", "set_scaleY", "set_rotation", "move", "setPosition", "rotate", "scale", "setScale", "getChildAt", "getChildIndex", "getObjectByName", "get_numChildren", "iterator", "toString", "contentChanged", "constraintSize"]
    _hx_statics = ["nullDrawable"]

    def __init__(self,parent = None):
        self.lastFrame = None
        self.allocated = None
        self.filter = None
        self.name = None
        self.parent = None
        self.parentContainer = None
        self.blendMode = h2d_BlendMode.Alpha
        self.alpha = 1.
        self.visible = True
        self.rotation = 0
        self.scaleY = 1
        self.scaleX = 1
        self.y = 0
        self.x = 0
        self.matA = 1
        self.matB = 0
        self.matC = 0
        self.matD = 1
        self.absX = 0
        self.absY = 0
        self.posChanged = (parent is not None)
        self.children = []
        if (parent is not None):
            parent.addChild(self)

    def getBounds(self,relativeTo = None,out = None):
        if (out is None):
            out = h2d_col_Bounds()
        else:
            out.xMin = 1e20
            out.yMin = 1e20
            out.xMax = -1e20
            out.yMax = -1e20
        if (relativeTo is not None):
            relativeTo.syncPos()
        if (relativeTo != self):
            self.syncPos()
        self.getBoundsRec(relativeTo,out,False)
        if ((out.xMax <= out.xMin) or ((out.yMax <= out.yMin))):
            self.addBounds(relativeTo,out,-1,-1,2,2)
            def _hx_local_0():
                out.xMin = (((out.xMax + out.xMin)) * 0.5)
                return out.xMin
            out.xMax = _hx_local_0()
            def _hx_local_1():
                out.yMin = (((out.yMax + out.yMin)) * 0.5)
                return out.yMin
            out.yMax = _hx_local_1()
        return out

    def getSize(self,out = None):
        if (out is None):
            out = h2d_col_Bounds()
        else:
            out.xMin = 1e20
            out.yMin = 1e20
            out.xMax = -1e20
            out.yMax = -1e20
        self.syncPos()
        self.getBoundsRec(self.parent,out,True)
        if ((out.xMax <= out.xMin) or ((out.yMax <= out.yMin))):
            self.addBounds(self.parent,out,-1,-1,2,2)
            def _hx_local_0():
                out.xMin = (((out.xMax + out.xMin)) * 0.5)
                return out.xMin
            out.xMax = _hx_local_0()
            def _hx_local_1():
                out.yMin = (((out.yMax + out.yMin)) * 0.5)
                return out.yMin
            out.yMax = _hx_local_1()
        dx = -self.x
        dy = -self.y
        out.xMin = (out.xMin + dx)
        out.xMax = (out.xMax + dx)
        out.yMin = (out.yMin + dy)
        out.yMax = (out.yMax + dy)
        return out

    def getAbsPos(self):
        self.syncPos()
        m = h2d_col_Matrix()
        m.a = self.matA
        m.b = self.matB
        m.c = self.matC
        m.d = self.matD
        m.x = self.absX
        m.y = self.absY
        return m

    def contains(self,o):
        while (o is not None):
            o = o.parent
            if (o == self):
                return True
        return False

    def find(self,f):
        v = f(self)
        if (v is not None):
            return v
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            v = o.find(f)
            if (v is not None):
                return v
        return None

    def findAll(self,f,arr = None):
        if (arr is None):
            arr = []
        v = f(self)
        if (v is not None):
            arr.append(v)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o.findAll(f,arr)
        return arr

    def set_filter(self,f):
        if ((self.filter is not None) and self.allocated):
            self.filter.unbind(self)
        self.filter = f
        if ((f is not None) and self.allocated):
            f.bind(self)
        return f

    def getBoundsRec(self,relativeTo,out,forSize):
        if self.posChanged:
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.posChanged = True
            self.posChanged = False
        n = len(self.children)
        if (n == 0):
            out.xMin = 1e20
            out.yMin = 1e20
            out.xMax = -1e20
            out.yMax = -1e20
            return
        if (n == 1):
            c = (self.children[0] if 0 < len(self.children) else None)
            if c.visible:
                c.getBoundsRec(relativeTo,out,forSize)
            else:
                out.xMin = 1e20
                out.yMin = 1e20
                out.xMax = -1e20
                out.yMax = -1e20
            return
        xmin = Math.POSITIVE_INFINITY
        ymin = Math.POSITIVE_INFINITY
        xmax = Math.NEGATIVE_INFINITY
        ymax = Math.NEGATIVE_INFINITY
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (not c.visible):
                continue
            c.getBoundsRec(relativeTo,out,forSize)
            if (out.xMin < xmin):
                xmin = out.xMin
            if (out.yMin < ymin):
                ymin = out.yMin
            if (out.xMax > xmax):
                xmax = out.xMax
            if (out.yMax > ymax):
                ymax = out.yMax
        out.xMin = xmin
        out.yMin = ymin
        out.xMax = xmax
        out.yMax = ymax

    def addBounds(self,relativeTo,out,dx,dy,width,height):
        if ((width <= 0) or ((height <= 0))):
            return
        if (relativeTo is None):
            x = None
            y = None
            x = (((dx * self.matA) + ((dy * self.matC))) + self.absX)
            y = (((dx * self.matB) + ((dy * self.matD))) + self.absY)
            if (x < out.xMin):
                out.xMin = x
            if (x > out.xMax):
                out.xMax = x
            if (y < out.yMin):
                out.yMin = y
            if (y > out.yMax):
                out.yMax = y
            x = (((((dx + width)) * self.matA) + ((dy * self.matC))) + self.absX)
            y = (((((dx + width)) * self.matB) + ((dy * self.matD))) + self.absY)
            if (x < out.xMin):
                out.xMin = x
            if (x > out.xMax):
                out.xMax = x
            if (y < out.yMin):
                out.yMin = y
            if (y > out.yMax):
                out.yMax = y
            x = (((dx * self.matA) + ((((dy + height)) * self.matC))) + self.absX)
            y = (((dx * self.matB) + ((((dy + height)) * self.matD))) + self.absY)
            if (x < out.xMin):
                out.xMin = x
            if (x > out.xMax):
                out.xMax = x
            if (y < out.yMin):
                out.yMin = y
            if (y > out.yMax):
                out.yMax = y
            x = (((((dx + width)) * self.matA) + ((((dy + height)) * self.matC))) + self.absX)
            y = (((((dx + width)) * self.matB) + ((((dy + height)) * self.matD))) + self.absY)
            if (x < out.xMin):
                out.xMin = x
            if (x > out.xMax):
                out.xMax = x
            if (y < out.yMin):
                out.yMin = y
            if (y > out.yMax):
                out.yMax = y
            return
        if (relativeTo == self):
            if (out.xMin > dx):
                out.xMin = dx
            if (out.yMin > dy):
                out.yMin = dy
            if (out.xMax < ((dx + width))):
                out.xMax = (dx + width)
            if (out.yMax < ((dy + height))):
                out.yMax = (dy + height)
            return
        r = ((relativeTo.matA * relativeTo.matD) - ((relativeTo.matB * relativeTo.matC)))
        if (r == 0):
            return
        det = (1 / r)
        rA = (relativeTo.matD * det)
        rB = (-relativeTo.matB * det)
        rC = (-relativeTo.matC * det)
        rD = (relativeTo.matA * det)
        rX = (self.absX - relativeTo.absX)
        rY = (self.absY - relativeTo.absY)
        x = (((dx * self.matA) + ((dy * self.matC))) + rX)
        y = (((dx * self.matB) + ((dy * self.matD))) + rY)
        x1 = ((x * rA) + ((y * rC)))
        y1 = ((x * rB) + ((y * rD)))
        if (x1 < out.xMin):
            out.xMin = x1
        if (x1 > out.xMax):
            out.xMax = x1
        if (y1 < out.yMin):
            out.yMin = y1
        if (y1 > out.yMax):
            out.yMax = y1
        x = (((((dx + width)) * self.matA) + ((dy * self.matC))) + rX)
        y = (((((dx + width)) * self.matB) + ((dy * self.matD))) + rY)
        x1 = ((x * rA) + ((y * rC)))
        y1 = ((x * rB) + ((y * rD)))
        if (x1 < out.xMin):
            out.xMin = x1
        if (x1 > out.xMax):
            out.xMax = x1
        if (y1 < out.yMin):
            out.yMin = y1
        if (y1 > out.yMax):
            out.yMax = y1
        x = (((dx * self.matA) + ((((dy + height)) * self.matC))) + rX)
        y = (((dx * self.matB) + ((((dy + height)) * self.matD))) + rY)
        x1 = ((x * rA) + ((y * rC)))
        y1 = ((x * rB) + ((y * rD)))
        if (x1 < out.xMin):
            out.xMin = x1
        if (x1 > out.xMax):
            out.xMax = x1
        if (y1 < out.yMin):
            out.yMin = y1
        if (y1 > out.yMax):
            out.yMax = y1
        x = (((((dx + width)) * self.matA) + ((((dy + height)) * self.matC))) + rX)
        y = (((((dx + width)) * self.matB) + ((((dy + height)) * self.matD))) + rY)
        x1 = ((x * rA) + ((y * rC)))
        y1 = ((x * rB) + ((y * rD)))
        if (x1 < out.xMin):
            out.xMin = x1
        if (x1 > out.xMax):
            out.xMax = x1
        if (y1 < out.yMin):
            out.yMin = y1
        if (y1 > out.yMax):
            out.yMax = y1

    def getObjectsCount(self):
        k = 0
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            k = (k + ((c.getObjectsCount() + 1)))
        return k

    def localToGlobal(self,pt = None):
        self.syncPos()
        if (pt is None):
            pt = h2d_col_Point()
        px = (((pt.x * self.matA) + ((pt.y * self.matC))) + self.absX)
        py = (((pt.x * self.matB) + ((pt.y * self.matD))) + self.absY)
        pt.x = px
        pt.y = py
        return pt

    def globalToLocal(self,pt):
        self.syncPos()
        pt.x = (pt.x - self.absX)
        pt.y = (pt.y - self.absY)
        invDet = (1 / (((self.matA * self.matD) - ((self.matB * self.matC)))))
        px = ((((pt.x * self.matD) - ((pt.y * self.matC)))) * invDet)
        py = ((((-pt.x * self.matB) + ((pt.y * self.matA)))) * invDet)
        pt.x = px
        pt.y = py
        return pt

    def getScene(self):
        p = self
        while (p.parent is not None):
            p = p.parent
        return Std.downcast(p,h2d_Scene)

    def set_visible(self,b):
        if (self.visible == b):
            return b
        self.visible = b
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return b

    def addChild(self,s):
        self.addChildAt(s,len(self.children))

    def addChildAt(self,s,pos):
        if (pos < 0):
            pos = 0
        if (pos > len(self.children)):
            pos = len(self.children)
        p = self
        while (p is not None):
            if (p == s):
                raise haxe_Exception.thrown("Recursive addChild")
            p = p.parent
        if (s.parent is not None):
            old = s.allocated
            s.allocated = False
            s.parent.removeChild(s)
            s.allocated = old
        self.children.insert(pos, s)
        if ((not self.allocated) and s.allocated):
            s.onRemove()
        s.parent = self
        s.parentContainer = self.parentContainer
        s.posChanged = True
        if self.allocated:
            if (not s.allocated):
                s.onAdd()
            else:
                s.onHierarchyMoved(True)
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)

    def onContentChanged(self):
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)

    def onHierarchyMoved(self,parentChanged):
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onHierarchyMoved(parentChanged)

    def onAdd(self):
        self.allocated = True
        if (self.filter is not None):
            self.filter.bind(self)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onAdd()

    def onRemove(self):
        self.allocated = False
        if (self.filter is not None):
            self.filter.unbind(self)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onRemove()

    def getMatrix(self,m):
        m.a = self.matA
        m.b = self.matB
        m.c = self.matC
        m.d = self.matD
        m.x = self.absX
        m.y = self.absY

    def removeChild(self,s):
        if python_internal_ArrayImpl.remove(self.children,s):
            if s.allocated:
                s.onRemove()
            s.parent = None
            if (s.parentContainer is not None):
                s.setParentContainer(None)
            s.posChanged = True
            if (self.parentContainer is not None):
                self.parentContainer.contentChanged(self)

    def setParentContainer(self,c):
        self.parentContainer = c
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            s.setParentContainer(c)

    def removeChildren(self):
        while (len(self.children) > 0):
            self.removeChild((self.children[0] if 0 < len(self.children) else None))

    def remove(self):
        if (self.parent is not None):
            self.parent.removeChild(self)

    def drawTo(self,t):
        s = self.getScene()
        needDispose = (s is None)
        if (s is None):
            s = h2d_Scene()
        s.drawImplTo(self,[t])
        if needDispose:
            s.dispose()
            self.onRemove()

    def drawToTextures(self,texs,outputs):
        s = self.getScene()
        needDispose = (s is None)
        if (s is None):
            s = h2d_Scene()
        s.drawImplTo(self,texs,outputs)
        if needDispose:
            s.dispose()
            self.onRemove()

    def draw(self,ctx):
        pass

    def sync(self,ctx):
        changed = self.posChanged
        if changed:
            self.calcAbsPos()
            self.posChanged = False
        self.lastFrame = ctx.frame
        p = 0
        _hx_len = len(self.children)
        while (p < _hx_len):
            c = (self.children[p] if p >= 0 and p < len(self.children) else None)
            if (c is None):
                break
            if (c.lastFrame != ctx.frame):
                if changed:
                    c.posChanged = True
                c.sync(ctx)
            if ((self.children[p] if p >= 0 and p < len(self.children) else None) != c):
                p = 0
                _hx_len = len(self.children)
            else:
                p = (p + 1)

    def syncPos(self):
        if (self.parent is not None):
            self.parent.syncPos()
        if self.posChanged:
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.posChanged = True
            self.posChanged = False

    def calcAbsPos(self):
        if (self.parent is None):
            cr = None
            sr = None
            if (self.rotation == 0):
                cr = 1.
                sr = 0.
                self.matA = self.scaleX
                self.matB = 0
                self.matC = 0
                self.matD = self.scaleY
            else:
                f = self.rotation
                cr = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
                f = self.rotation
                sr = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
                self.matA = (self.scaleX * cr)
                self.matB = (self.scaleX * sr)
                self.matC = (self.scaleY * -sr)
                self.matD = (self.scaleY * cr)
            self.absX = self.x
            self.absY = self.y
        else:
            if (self.rotation == 0):
                self.matA = (self.scaleX * self.parent.matA)
                self.matB = (self.scaleX * self.parent.matB)
                self.matC = (self.scaleY * self.parent.matC)
                self.matD = (self.scaleY * self.parent.matD)
            else:
                f = self.rotation
                cr = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
                f = self.rotation
                sr = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
                tmpA = (self.scaleX * cr)
                tmpB = (self.scaleX * sr)
                tmpC = (self.scaleY * -sr)
                tmpD = (self.scaleY * cr)
                self.matA = ((tmpA * self.parent.matA) + ((tmpB * self.parent.matC)))
                self.matB = ((tmpA * self.parent.matB) + ((tmpB * self.parent.matD)))
                self.matC = ((tmpC * self.parent.matA) + ((tmpD * self.parent.matC)))
                self.matD = ((tmpC * self.parent.matB) + ((tmpD * self.parent.matD)))
            self.absX = (((self.x * self.parent.matA) + ((self.y * self.parent.matC))) + self.parent.absX)
            self.absY = (((self.x * self.parent.matB) + ((self.y * self.parent.matD))) + self.parent.absY)

    def emitTile(self,ctx,tile):
        if (h2d_Object.nullDrawable is None):
            h2d_Object.nullDrawable = h2d_Drawable(None)
        h2d_Object.nullDrawable.absX = self.absX
        h2d_Object.nullDrawable.absY = self.absY
        h2d_Object.nullDrawable.matA = self.matA
        h2d_Object.nullDrawable.matB = self.matB
        h2d_Object.nullDrawable.matC = self.matC
        h2d_Object.nullDrawable.matD = self.matD
        ctx.drawTile(h2d_Object.nullDrawable,tile)

    def clipBounds(self,ctx,bounds):
        view = ctx.tmpBounds
        matA = None
        matB = None
        matC = None
        matD = None
        absX = None
        absY = None
        if (ctx.inFilter is not None):
            f1 = ctx.baseShader.filterMatrixA__
            f2 = ctx.baseShader.filterMatrixB__
            tmpA = ((self.matA * f1.x) + ((self.matB * f1.y)))
            tmpB = ((self.matA * f2.x) + ((self.matB * f2.y)))
            tmpC = ((self.matC * f1.x) + ((self.matD * f1.y)))
            tmpD = ((self.matC * f2.x) + ((self.matD * f2.y)))
            tmpX = (((self.absX * f1.x) + ((self.absY * f1.y))) + f1.z)
            tmpY = (((self.absX * f2.x) + ((self.absY * f2.y))) + f2.z)
            matA = ((tmpA * ctx.viewA) + ((tmpB * ctx.viewC)))
            matB = ((tmpA * ctx.viewB) + ((tmpB * ctx.viewD)))
            matC = ((tmpC * ctx.viewA) + ((tmpD * ctx.viewC)))
            matD = ((tmpC * ctx.viewB) + ((tmpD * ctx.viewD)))
            absX = (((tmpX * ctx.viewA) + ((tmpY * ctx.viewC))) + ctx.viewX)
            absY = (((tmpX * ctx.viewB) + ((tmpY * ctx.viewD))) + ctx.viewY)
        else:
            matA = ((self.matA * ctx.viewA) + ((self.matB * ctx.viewC)))
            matB = ((self.matA * ctx.viewB) + ((self.matB * ctx.viewD)))
            matC = ((self.matC * ctx.viewA) + ((self.matD * ctx.viewC)))
            matD = ((self.matC * ctx.viewB) + ((self.matD * ctx.viewD)))
            absX = (((self.absX * ctx.viewA) + ((self.absY * ctx.viewC))) + ctx.viewX)
            absY = (((self.absX * ctx.viewB) + ((self.absY * ctx.viewD))) + ctx.viewY)
        view.xMin = 1e20
        view.yMin = 1e20
        view.xMax = -1e20
        view.yMax = -1e20
        x = bounds.xMin
        y = bounds.yMin
        x1 = (((x * matA) + ((y * matC))) + absX)
        y1 = (((x * matB) + ((y * matD))) + absY)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        x = bounds.xMax
        y = bounds.yMin
        x1 = (((x * matA) + ((y * matC))) + absX)
        y1 = (((x * matB) + ((y * matD))) + absY)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        x = bounds.xMin
        y = bounds.yMax
        x1 = (((x * matA) + ((y * matC))) + absX)
        y1 = (((x * matB) + ((y * matD))) + absY)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        x = bounds.xMax
        y = bounds.yMax
        x1 = (((x * matA) + ((y * matC))) + absX)
        y1 = (((x * matB) + ((y * matD))) + absY)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        if (view.xMin < -1):
            view.xMin = -1
        if (view.yMin < -1):
            view.yMin = -1
        if (view.xMax > 1):
            view.xMax = 1
        if (view.yMax > 1):
            view.yMax = 1
        invDet = (1 / (((matA * matD) - ((matB * matC)))))
        sxMin = view.xMin
        syMin = view.yMin
        sxMax = view.xMax
        syMax = view.yMax
        view.xMin = 1e20
        view.yMin = 1e20
        view.xMax = -1e20
        view.yMax = -1e20
        x = sxMin
        y = syMin
        x = (x - absX)
        y = (y - absY)
        x1 = ((((x * matD) - ((y * matC)))) * invDet)
        y1 = ((((-x * matB) + ((y * matA)))) * invDet)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        x = sxMax
        y = syMin
        x = (x - absX)
        y = (y - absY)
        x1 = ((((x * matD) - ((y * matC)))) * invDet)
        y1 = ((((-x * matB) + ((y * matA)))) * invDet)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        x = sxMin
        y = syMax
        x = (x - absX)
        y = (y - absY)
        x1 = ((((x * matD) - ((y * matC)))) * invDet)
        y1 = ((((-x * matB) + ((y * matA)))) * invDet)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        x = sxMax
        y = syMax
        x = (x - absX)
        y = (y - absY)
        x1 = ((((x * matD) - ((y * matC)))) * invDet)
        y1 = ((((-x * matB) + ((y * matA)))) * invDet)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        a = bounds.xMin
        b = view.xMin
        bounds.xMin = (b if ((a < b)) else a)
        a = bounds.yMin
        b = view.yMin
        bounds.yMin = (b if ((a < b)) else a)
        a = bounds.xMax
        b = view.xMax
        bounds.xMax = (b if ((a > b)) else a)
        a = bounds.yMax
        b = view.yMax
        bounds.yMax = (b if ((a > b)) else a)

    def drawFilters(self,ctx):
        if (not ctx.pushFilter(self)):
            return
        bounds = ctx.tmpBounds
        total = h2d_col_Bounds()
        maxExtent = -1.
        self.filter.sync(ctx,self)
        if self.filter.autoBounds:
            maxExtent = self.filter.boundsExtend
        else:
            self.filter.getBounds(self,bounds)
            if (bounds.xMin < total.xMin):
                total.xMin = bounds.xMin
            if (bounds.xMax > total.xMax):
                total.xMax = bounds.xMax
            if (bounds.yMin < total.yMin):
                total.yMin = bounds.yMin
            if (bounds.yMax > total.yMax):
                total.yMax = bounds.yMax
        if (maxExtent >= 0):
            self.getBounds(self,bounds)
            bounds.xMin = (bounds.xMin - maxExtent)
            bounds.yMin = (bounds.yMin - maxExtent)
            bounds.xMax = (bounds.xMax + maxExtent)
            bounds.yMax = (bounds.yMax + maxExtent)
            if (bounds.xMin < total.xMin):
                total.xMin = bounds.xMin
            if (bounds.xMax > total.xMax):
                total.xMax = bounds.xMax
            if (bounds.yMin < total.yMin):
                total.yMin = bounds.yMin
            if (bounds.yMax > total.yMax):
                total.yMax = bounds.yMax
        self.clipBounds(ctx,total)
        xMin = Math.floor((total.xMin + 1e-10))
        yMin = Math.floor((total.yMin + 1e-10))
        width = Math.ceil(((total.xMax - xMin) - 1e-10))
        height = Math.ceil(((total.yMax - yMin) - 1e-10))
        if (((width <= 0) or ((height <= 0))) or ((total.xMax < total.xMin))):
            ctx.popFilter()
            return
        t = ctx.textures.allocTarget("filterTemp",width,height,False)
        ctx.pushTarget(t,xMin,yMin,width,height)
        ctx.engine.clear(0)
        oldAlpha = ctx.globalAlpha
        shader = ctx.baseShader
        _this = shader.filterMatrixA__
        x = _this.x
        y = _this.y
        z = _this.z
        w = _this.w
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        oldA_x = x
        oldA_y = y
        oldA_z = z
        oldA_w = w
        _this = shader.filterMatrixB__
        x = _this.x
        y = _this.y
        z = _this.z
        w = _this.w
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        oldB_x = x
        oldB_y = y
        oldB_z = z
        oldB_w = w
        invDet = (1 / (((self.matA * self.matD) - ((self.matB * self.matC)))))
        invA = (self.matD * invDet)
        invB = (-self.matB * invDet)
        invC = (-self.matC * invDet)
        invD = (self.matA * invDet)
        invX = -(((self.absX * invA) + ((self.absY * invC))))
        invY = -(((self.absX * invB) + ((self.absY * invD))))
        _this = shader.filterMatrixA__
        x = invA
        y = invC
        z = invX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = shader.filterMatrixB__
        x = invB
        y = invD
        z = invY
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        ctx.globalAlpha = 1
        self.drawContent(ctx)
        finalTile = h2d_Tile.fromTexture(t)
        finalTile.dx = xMin
        finalTile.dy = yMin
        prev = finalTile
        finalTile = self.filter.draw(ctx,finalTile)
        if ((finalTile != prev) and ((finalTile is not None))):
            finalTile.dx = (finalTile.dx + xMin)
            finalTile.dy = (finalTile.dy + yMin)
        _this = shader.filterMatrixA__
        _this.x = oldA_x
        _this.y = oldA_y
        _this.z = oldA_z
        _this.w = oldA_w
        _this = shader.filterMatrixB__
        _this.x = oldB_x
        _this.y = oldB_y
        _this.z = oldB_z
        _this.w = oldB_w
        ctx.popTarget()
        ctx.popFilter()
        ctx.globalAlpha = oldAlpha
        if (finalTile is None):
            return
        self.drawFiltered(ctx,finalTile)

    def drawFiltered(self,ctx,tile):
        oldAlpha = ctx.globalAlpha
        ctx.currentBlend = None
        ctx.inFilterBlend = self.blendMode
        ctx.globalAlpha = (ctx.globalAlpha * self.alpha)
        self.emitTile(ctx,tile)
        ctx.globalAlpha = oldAlpha
        ctx.inFilterBlend = None
        ctx.currentBlend = None

    def drawRec(self,ctx):
        if (not self.visible):
            return
        if self.posChanged:
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.posChanged = True
            self.posChanged = False
        if ((self.filter is not None) and self.filter.get_enable()):
            self.drawFilters(ctx)
        else:
            old = ctx.globalAlpha
            ctx.globalAlpha = (ctx.globalAlpha * self.alpha)
            self.drawContent(ctx)
            ctx.globalAlpha = old

    def drawContent(self,ctx):
        if ctx.front2back:
            i = len(self.children)
            while True:
                tmp = i
                i = (i - 1)
                if (not ((tmp > 0))):
                    break
                (self.children[i] if i >= 0 and i < len(self.children) else None).drawRec(ctx)
            self.draw(ctx)
        else:
            self.draw(ctx)
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.drawRec(ctx)

    def set_x(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.x = v
                return self.x
            return _hx_local_0()
        return _hx_local_1()

    def set_y(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.y = v
                return self.y
            return _hx_local_0()
        return _hx_local_1()

    def set_scaleX(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scaleX = v
                return self.scaleX
            return _hx_local_0()
        return _hx_local_1()

    def set_scaleY(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scaleY = v
                return self.scaleY
            return _hx_local_0()
        return _hx_local_1()

    def set_rotation(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.rotation = v
                return self.rotation
            return _hx_local_0()
        return _hx_local_1()

    def move(self,dx,dy):
        v = self.x
        f = self.rotation
        v1 = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        self.posChanged = True
        self.x = (v + ((dx * v1)))
        v = self.y
        f = self.rotation
        v1 = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        self.posChanged = True
        self.y = (v + ((dy * v1)))

    def setPosition(self,x,y):
        self.posChanged = True
        self.x = x
        self.posChanged = True
        self.y = y

    def rotate(self,v):
        self.posChanged = True
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.rotation
        _hx_local_0.rotation = (_hx_local_1 + v)
        _hx_local_0.rotation

    def scale(self,v):
        self.posChanged = True
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.scaleX
        _hx_local_0.scaleX = (_hx_local_1 * v)
        _hx_local_0.scaleX
        self.posChanged = True
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.scaleY
        _hx_local_2.scaleY = (_hx_local_3 * v)
        _hx_local_2.scaleY

    def setScale(self,v):
        self.posChanged = True
        self.scaleX = v
        self.posChanged = True
        self.scaleY = v

    def getChildAt(self,n):
        return (self.children[n] if n >= 0 and n < len(self.children) else None)

    def getChildIndex(self,o):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == o):
                return i
        return -1

    def getObjectByName(self,name):
        if (self.name == name):
            return self
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o = c.getObjectByName(name)
            if (o is not None):
                return o
        return None

    def get_numChildren(self):
        return len(self.children)

    def iterator(self):
        return hxd_impl_ArrayIterator_h2d_Object(self.children)

    def toString(self):
        c = Type.getClassName(Type.getClass(self))
        if (self.name is None):
            return c
        else:
            return (((HxOverrides.stringOrNull(self.name) + "(") + ("null" if c is None else c)) + ")")

    def contentChanged(self,s):
        pass

    def constraintSize(self,maxWidth,maxHeight):
        pass
    nullDrawable = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.children = None
        _hx_o.parentContainer = None
        _hx_o.parent = None
        _hx_o.name = None
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.scaleX = None
        _hx_o.scaleY = None
        _hx_o.rotation = None
        _hx_o.visible = None
        _hx_o.alpha = None
        _hx_o.filter = None
        _hx_o.blendMode = None
        _hx_o.matA = None
        _hx_o.matB = None
        _hx_o.matC = None
        _hx_o.matD = None
        _hx_o.absX = None
        _hx_o.absY = None
        _hx_o.posChanged = None
        _hx_o.allocated = None
        _hx_o.lastFrame = None
h2d_Object._hx_class = h2d_Object
_hx_classes["h2d.Object"] = h2d_Object


class h2d_Drawable(h2d_Object):
    _hx_class_name = "h2d.Drawable"
    _hx_is_interface = "False"
    __slots__ = ("color", "smooth", "tileWrap", "colorKey", "shaders")
    _hx_fields = ["color", "smooth", "tileWrap", "colorKey", "shaders"]
    _hx_methods = ["set_tileWrap", "get_colorAdd", "set_colorAdd", "drawFiltered", "set_colorKey", "adjustColor", "get_colorMatrix", "set_colorMatrix", "getDebugShaderCode", "getShader", "getShaders", "addShader", "removeShader", "emitTile"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Object


    def __init__(self,parent):
        self.shaders = None
        self.colorKey = None
        self.tileWrap = None
        self.smooth = None
        self.color = None
        super().__init__(parent)
        self.color = h3d_Vector(1,1,1,1)

    def set_tileWrap(self,b):
        def _hx_local_1():
            def _hx_local_0():
                self.tileWrap = b
                return self.tileWrap
            return _hx_local_0()
        return _hx_local_1()

    def get_colorAdd(self):
        s = self.getShader(h3d_shader_ColorAdd)
        if (s is None):
            return None
        else:
            return s.color__

    def set_colorAdd(self,c):
        s = self.getShader(h3d_shader_ColorAdd)
        if (s is None):
            if (c is not None):
                s = self.addShader(h3d_shader_ColorAdd())
                s.color__ = c
        elif (c is None):
            self.removeShader(s)
        else:
            s.color__ = c
        return c

    def drawFiltered(self,ctx,tile):
        old = self.shaders
        self.shaders = None
        super().drawFiltered(ctx,tile)
        self.shaders = old

    def set_colorKey(self,v):
        s = self.getShader(h3d_shader_ColorKey)
        if (s is None):
            if (v is not None):
                s = self.addShader(h3d_shader_ColorKey((-16777216 | v)))
        elif (v is None):
            self.removeShader(s)
        else:
            _this = s.colorKey__
            c = (-16777216 | v)
            _this.x = ((((c >> 16) & 255)) / 255)
            _this.y = ((((c >> 8) & 255)) / 255)
            _this.z = (((c & 255)) / 255)
            _this.w = ((HxOverrides.rshift(c, 24)) / 255)
        def _hx_local_1():
            def _hx_local_0():
                self.colorKey = v
                return self.colorKey
            return _hx_local_0()
        return _hx_local_1()

    def adjustColor(self,col = None):
        if (col is None):
            self.set_colorMatrix(None)
        else:
            m = self.get_colorMatrix()
            if (m is None):
                m = h3d_Matrix()
                self.set_colorMatrix(m)
            m.identity()
            m.adjustColor(col)

    def get_colorMatrix(self):
        s = self.getShader(h3d_shader_ColorMatrix)
        if (s is None):
            return None
        else:
            return s.matrix__

    def set_colorMatrix(self,m):
        s = self.getShader(h3d_shader_ColorMatrix)
        if (s is None):
            if (m is not None):
                s = self.addShader(h3d_shader_ColorMatrix())
                s.matrix__ = m
        elif (m is None):
            self.removeShader(s)
        else:
            s.matrix__ = m
        return m

    def getDebugShaderCode(self,toHxsl = None):
        if (toHxsl is None):
            toHxsl = True
        ctx = self.getScene().ctx
        shader = ctx.manager.compileShaders(hxsl_ShaderList(ctx.baseShader,self.shaders))
        if toHxsl:
            varId = True
            def _hx_local_0(s):
                return hxsl_Printer.shaderToString(s,varId)
            toString = _hx_local_0
            return ((("// vertex:\n" + HxOverrides.stringOrNull(toString(shader.vertex.data))) + "\n\nfragment:\n") + HxOverrides.stringOrNull(toString(shader.fragment.data)))
        else:
            return h3d_Engine.CURRENT.driver.getNativeShaderCode(shader)

    def getShader(self,stype):
        if (self.shaders is not None):
            _g_l = self.shaders
            _g_last = None
            while (_g_l != _g_last):
                s = _g_l.s
                _g_l = _g_l.next
                s1 = s
                s2 = Std.downcast(s1,stype)
                if (s2 is not None):
                    return s2
        return None

    def getShaders(self):
        return hxsl__ShaderList_ShaderIterator(self.shaders,None)

    def addShader(self,s):
        if (s is None):
            raise haxe_Exception.thrown("Can't add null shader")
        self.shaders = hxsl_ShaderList.addSort(s,self.shaders)
        return s

    def removeShader(self,s):
        prev = None
        cur = self.shaders
        while (cur is not None):
            if (cur.s == s):
                if (prev is None):
                    self.shaders = cur.next
                else:
                    prev.next = cur.next
                return True
            prev = cur
            cur = cur.next
        return False

    def emitTile(self,ctx,tile):
        if (tile is None):
            tile = h2d_Tile(None,0,0,5,5)
        if (not ctx.drawTile(self,tile)):
            return

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color = None
        _hx_o.smooth = None
        _hx_o.tileWrap = None
        _hx_o.colorKey = None
        _hx_o.shaders = None
h2d_Drawable._hx_class = h2d_Drawable
_hx_classes["h2d.Drawable"] = h2d_Drawable


class h2d_Bitmap(h2d_Drawable):
    _hx_class_name = "h2d.Bitmap"
    _hx_is_interface = "False"
    __slots__ = ("tile", "width", "height")
    _hx_fields = ["tile", "width", "height"]
    _hx_methods = ["getBoundsRec", "set_width", "set_height", "set_tile", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Drawable


    def __init__(self,tile = None,parent = None):
        self.height = None
        self.width = None
        self.tile = None
        super().__init__(parent)
        self.set_tile(tile)

    def getBoundsRec(self,relativeTo,out,forSize):
        super().getBoundsRec(relativeTo,out,forSize)
        if (self.tile is not None):
            if ((self.width is None) and ((self.height is None))):
                self.addBounds(relativeTo,out,self.tile.dx,self.tile.dy,self.tile.width,self.tile.height)
            else:
                self.addBounds(relativeTo,out,self.tile.dx,self.tile.dy,(self.width if ((self.width is not None)) else ((self.tile.width * self.height) / self.tile.height)),(self.height if ((self.height is not None)) else ((self.tile.height * self.width) / self.tile.width)))

    def set_width(self,w):
        if (self.width == w):
            return w
        self.width = w
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return w

    def set_height(self,h):
        if (self.height == h):
            return h
        self.height = h
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return h

    def set_tile(self,t):
        if (self.tile == t):
            return t
        self.tile = t
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return t

    def draw(self,ctx):
        if ((self.width is None) and ((self.height is None))):
            self.emitTile(ctx,self.tile)
            return
        if (self.tile is None):
            self.set_tile(h2d_Tile.fromColor(16711935))
        ow = self.tile.width
        oh = self.tile.height
        self.tile.width = (self.width if ((self.width is not None)) else ((ow * self.height) / oh))
        self.tile.height = (self.height if ((self.height is not None)) else ((oh * self.width) / ow))
        self.emitTile(ctx,self.tile)
        self.tile.width = ow
        self.tile.height = oh

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tile = None
        _hx_o.width = None
        _hx_o.height = None
h2d_Bitmap._hx_class = h2d_Bitmap
_hx_classes["h2d.Bitmap"] = h2d_Bitmap

class h2d_BlendMode(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.BlendMode"
    _hx_constructs = ["None", "Alpha", "Add", "AlphaAdd", "SoftAdd", "Multiply", "AlphaMultiply", "Erase", "Screen", "Sub", "Max", "Min"]
h2d_BlendMode._hx_None = h2d_BlendMode("None", 0, ())
h2d_BlendMode.Alpha = h2d_BlendMode("Alpha", 1, ())
h2d_BlendMode.Add = h2d_BlendMode("Add", 2, ())
h2d_BlendMode.AlphaAdd = h2d_BlendMode("AlphaAdd", 3, ())
h2d_BlendMode.SoftAdd = h2d_BlendMode("SoftAdd", 4, ())
h2d_BlendMode.Multiply = h2d_BlendMode("Multiply", 5, ())
h2d_BlendMode.AlphaMultiply = h2d_BlendMode("AlphaMultiply", 6, ())
h2d_BlendMode.Erase = h2d_BlendMode("Erase", 7, ())
h2d_BlendMode.Screen = h2d_BlendMode("Screen", 8, ())
h2d_BlendMode.Sub = h2d_BlendMode("Sub", 9, ())
h2d_BlendMode.Max = h2d_BlendMode("Max", 10, ())
h2d_BlendMode.Min = h2d_BlendMode("Min", 11, ())
h2d_BlendMode._hx_class = h2d_BlendMode
_hx_classes["h2d.BlendMode"] = h2d_BlendMode


class h2d_Camera:
    _hx_class_name = "h2d.Camera"
    _hx_is_interface = "False"
    _hx_fields = ["x", "y", "scaleX", "scaleY", "rotation", "clipViewport", "anchorX", "anchorY", "visible", "follow", "followRotation", "posChanged", "viewX", "viewY", "viewW", "viewH", "matA", "matB", "matC", "matD", "absX", "absY", "invDet", "scene"]
    _hx_methods = ["remove", "layerVisible", "enter", "exit", "sync", "setScale", "scale", "setPosition", "move", "rotate", "setAnchor", "setViewport", "setRawViewport", "screenXToCamera", "screenYToCamera", "cameraXToScreen", "cameraYToScreen", "sceneXToCamera", "sceneYToCamera", "cameraXToScene", "cameraYToScene", "eventToCamera", "screenToCamera", "cameraToScreen", "sceneToCamera", "cameraToScene", "checkScene", "set_x", "set_y", "set_scaleX", "set_scaleY", "set_rotation", "get_viewportX", "set_viewportX", "get_viewportY", "set_viewportY", "get_viewportWidth", "set_viewportWidth", "get_viewportHeight", "set_viewportHeight", "set_anchorX", "set_anchorY"]

    def __init__(self,scene = None):
        self.scene = None
        self.invDet = None
        self.absY = None
        self.absX = None
        self.matD = None
        self.matC = None
        self.matB = None
        self.matA = None
        self.follow = None
        self.clipViewport = None
        self.followRotation = False
        self.posChanged = True
        self.x = 0
        self.posChanged = True
        self.y = 0
        self.posChanged = True
        self.scaleX = 1
        self.posChanged = True
        self.scaleY = 1
        self.posChanged = True
        self.rotation = 0
        self.posChanged = True
        self.anchorX = 0
        self.posChanged = True
        self.anchorY = 0
        self.viewX = 0
        self.viewY = 0
        self.viewW = 1
        self.viewH = 1
        self.visible = True
        if (scene is not None):
            scene.addCamera(self)

    def remove(self):
        if (self.scene is not None):
            self.scene.removeCamera(self)

    def layerVisible(self,layer):
        return True

    def enter(self,ctx):
        ctx.pushCamera(self)
        if self.clipViewport:
            old = ctx.inFilter
            ctx.inFilter = None
            ctx.pushRenderZone((self.viewX * self.scene.width),(self.viewY * self.scene.height),(self.viewW * self.scene.width),(self.viewH * self.scene.height))
            ctx.inFilter = old

    def exit(self,ctx):
        if self.clipViewport:
            old = ctx.inFilter
            ctx.inFilter = None
            ctx.popRenderZone()
            ctx.inFilter = old
        ctx.popCamera()

    def sync(self,ctx,force = None):
        if (force is None):
            force = False
        if (self.scene is None):
            return
        if (self.follow is not None):
            self.posChanged = True
            self.x = self.follow.absX
            self.posChanged = True
            self.y = self.follow.absY
            if self.followRotation:
                self.posChanged = True
                self.rotation = -self.follow.rotation
        if (self.posChanged or force):
            if (self.rotation == 0):
                self.matA = self.scaleX
                self.matB = 0
                self.matC = 0
                self.matD = self.scaleY
            else:
                v = self.rotation
                cr = (Math.NaN if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(v))
                v = self.rotation
                sr = (Math.NaN if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(v))
                self.matA = (self.scaleX * cr)
                self.matB = (self.scaleX * sr)
                self.matC = (self.scaleY * -sr)
                self.matD = (self.scaleY * cr)
            self.absX = Math.floor((((-(((self.x * self.matA) + ((self.y * self.matC)))) + (((self.scene.width * self.anchorX) * self.viewW))) + ((self.scene.width * self.viewX))) + 0.5))
            self.absY = Math.floor((((-(((self.x * self.matB) + ((self.y * self.matD)))) + (((self.scene.height * self.anchorY) * self.viewH))) + ((self.scene.height * self.viewY))) + 0.5))
            self.invDet = (1 / (((self.matA * self.matD) - ((self.matB * self.matC)))))
            self.posChanged = False

    def setScale(self,x,y):
        self.posChanged = True
        self.scaleX = x
        self.posChanged = True
        self.scaleY = y

    def scale(self,x,y):
        self.posChanged = True
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.scaleX
        _hx_local_0.scaleX = (_hx_local_1 * x)
        _hx_local_0.scaleX
        self.posChanged = True
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.scaleY
        _hx_local_2.scaleY = (_hx_local_3 * y)
        _hx_local_2.scaleY

    def setPosition(self,x,y):
        self.posChanged = True
        self.x = x
        self.posChanged = True
        self.y = y

    def move(self,dx,dy):
        self.posChanged = True
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + dx)
        _hx_local_0.x
        self.posChanged = True
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + dy)
        _hx_local_2.y

    def rotate(self,angle):
        self.posChanged = True
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.rotation
        _hx_local_0.rotation = (_hx_local_1 + angle)
        _hx_local_0.rotation

    def setAnchor(self,x,y):
        self.posChanged = True
        self.anchorX = x
        self.posChanged = True
        self.anchorY = y

    def setViewport(self,x = None,y = None,w = None,h = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        if (w is None):
            w = 0
        if (h is None):
            h = 0
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewX = (Math.floor(x) / self.scene.width)
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewY = (Math.floor(y) / self.scene.height)
        v = (self.scene.width if ((w == 0)) else w)
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewW = (Math.ceil(v) / self.scene.width)
        v = (self.scene.height if ((h == 0)) else h)
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewH = (Math.ceil(v) / self.scene.height)

    def setRawViewport(self,x = None,y = None,w = None,h = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        if (w is None):
            w = 1
        if (h is None):
            h = 1
        self.viewX = x
        self.viewY = y
        self.viewW = w
        self.viewH = h
        self.posChanged = True

    def screenXToCamera(self,mx,my):
        return (((((((((mx - self.scene.offsetX)) / self.scene.viewportScaleX) - self.absX)) * self.matD) - (((((((my - self.scene.offsetY)) / self.scene.viewportScaleY) - self.absY)) * self.matC)))) * self.invDet)

    def screenYToCamera(self,mx,my):
        return ((((-(((((mx - self.scene.offsetX)) / self.scene.viewportScaleX) - self.absX)) * self.matB) + (((((((my - self.scene.offsetY)) / self.scene.viewportScaleY) - self.absY)) * self.matA)))) * self.invDet)

    def cameraXToScreen(self,mx,my):
        return ((((((mx * self.matA) + ((my * self.matC))) + self.absX)) * self.scene.viewportScaleX) + self.scene.offsetX)

    def cameraYToScreen(self,mx,my):
        return ((((((mx * self.matB) + ((my * self.matD))) + self.absY)) * self.scene.viewportScaleY) + self.scene.offsetY)

    def sceneXToCamera(self,mx,my):
        return ((((((mx - self.absX)) * self.matD) - ((((my - self.absY)) * self.matC)))) * self.invDet)

    def sceneYToCamera(self,mx,my):
        return ((((-((mx - self.absX)) * self.matB) + ((((my - self.absY)) * self.matA)))) * self.invDet)

    def cameraXToScene(self,mx,my):
        return (((mx * self.matA) + ((my * self.matC))) + self.absX)

    def cameraYToScene(self,mx,my):
        return (((mx * self.matB) + ((my * self.matD))) + self.absY)

    def eventToCamera(self,e):
        x = ((((e.relX - self.scene.offsetX)) / self.scene.viewportScaleX) - self.absX)
        y = ((((e.relY - self.scene.offsetY)) / self.scene.viewportScaleY) - self.absY)
        e.relX = ((((x * self.matD) - ((y * self.matC)))) * self.invDet)
        e.relY = ((((-x * self.matB) + ((y * self.matA)))) * self.invDet)

    def screenToCamera(self,pt):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        x = ((((pt.x - self.scene.offsetX)) / self.scene.viewportScaleX) - self.absX)
        y = ((((pt.y - self.scene.offsetY)) / self.scene.viewportScaleY) - self.absY)
        pt.x = ((((x * self.matD) - ((y * self.matC)))) * self.invDet)
        pt.y = ((((-x * self.matB) + ((y * self.matA)))) * self.invDet)

    def cameraToScreen(self,pt):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        x = pt.x
        y = pt.y
        pt.x = ((((((x * self.matA) + ((y * self.matC))) + self.absX)) * self.scene.viewportScaleX) + self.scene.offsetX)
        pt.y = ((((((x * self.matB) + ((y * self.matD))) + self.absY)) * self.scene.viewportScaleY) + self.scene.offsetY)

    def sceneToCamera(self,pt):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        x = (pt.x - self.absX)
        y = (pt.y - self.absY)
        pt.x = ((((x * self.matD) - ((y * self.matC)))) * self.invDet)
        pt.y = ((((-x * self.matB) + ((y * self.matA)))) * self.invDet)

    def cameraToScene(self,pt):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        x = pt.x
        y = pt.y
        pt.x = (((x * self.matA) + ((y * self.matC))) + self.absX)
        pt.y = (((x * self.matB) + ((y * self.matD))) + self.absY)

    def checkScene(self):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")

    def set_x(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.x = v
                return self.x
            return _hx_local_0()
        return _hx_local_1()

    def set_y(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.y = v
                return self.y
            return _hx_local_0()
        return _hx_local_1()

    def set_scaleX(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scaleX = v
                return self.scaleX
            return _hx_local_0()
        return _hx_local_1()

    def set_scaleY(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scaleY = v
                return self.scaleY
            return _hx_local_0()
        return _hx_local_1()

    def set_rotation(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.rotation = v
                return self.rotation
            return _hx_local_0()
        return _hx_local_1()

    def get_viewportX(self):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        return (self.viewX * self.scene.width)

    def set_viewportX(self,v):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewX = (Math.floor(v) / self.scene.width)
        return v

    def get_viewportY(self):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        return (self.viewY * self.scene.height)

    def set_viewportY(self,v):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewY = (Math.floor(v) / self.scene.height)
        return v

    def get_viewportWidth(self):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        return (self.viewW * self.scene.width)

    def set_viewportWidth(self,v):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewW = (Math.ceil(v) / self.scene.width)
        return v

    def get_viewportHeight(self):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        return (self.viewH * self.scene.height)

    def set_viewportHeight(self,v):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewH = (Math.ceil(v) / self.scene.height)
        return v

    def set_anchorX(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.anchorX = v
                return self.anchorX
            return _hx_local_0()
        return _hx_local_1()

    def set_anchorY(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.anchorY = v
                return self.anchorY
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.scaleX = None
        _hx_o.scaleY = None
        _hx_o.rotation = None
        _hx_o.clipViewport = None
        _hx_o.anchorX = None
        _hx_o.anchorY = None
        _hx_o.visible = None
        _hx_o.follow = None
        _hx_o.followRotation = None
        _hx_o.posChanged = None
        _hx_o.viewX = None
        _hx_o.viewY = None
        _hx_o.viewW = None
        _hx_o.viewH = None
        _hx_o.matA = None
        _hx_o.matB = None
        _hx_o.matC = None
        _hx_o.matD = None
        _hx_o.absX = None
        _hx_o.absY = None
        _hx_o.invDet = None
        _hx_o.scene = None
h2d_Camera._hx_class = h2d_Camera
_hx_classes["h2d.Camera"] = h2d_Camera


class h2d_Kerning:
    _hx_class_name = "h2d.Kerning"
    _hx_is_interface = "False"
    __slots__ = ("prevChar", "offset", "next")
    _hx_fields = ["prevChar", "offset", "next"]

    def __init__(self,c,o):
        self.next = None
        self.prevChar = c
        self.offset = o

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.prevChar = None
        _hx_o.offset = None
        _hx_o.next = None
h2d_Kerning._hx_class = h2d_Kerning
_hx_classes["h2d.Kerning"] = h2d_Kerning


class h2d_FontChar:
    _hx_class_name = "h2d.FontChar"
    _hx_is_interface = "False"
    __slots__ = ("t", "width", "kerning")
    _hx_fields = ["t", "width", "kerning"]
    _hx_methods = ["addKerning", "getKerningOffset", "clone"]

    def __init__(self,t,w):
        self.kerning = None
        self.t = t
        self.width = w

    def addKerning(self,prevChar,offset):
        k = h2d_Kerning(prevChar,offset)
        k.next = self.kerning
        self.kerning = k

    def getKerningOffset(self,prevChar):
        k = self.kerning
        while (k is not None):
            if (k.prevChar == prevChar):
                return k.offset
            k = k.next
        return 0

    def clone(self):
        c = h2d_FontChar(self.t.clone(),self.width)
        k = self.kerning
        if (k is not None):
            kc = h2d_Kerning(k.prevChar,k.offset)
            c.kerning = kc
            k = k.next
            while (k is not None):
                kn = h2d_Kerning(k.prevChar,k.offset)
                def _hx_local_0():
                    kc.next = kn
                    return kc.next
                kc = _hx_local_0()
                k = k.next
        return c

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.t = None
        _hx_o.width = None
        _hx_o.kerning = None
h2d_FontChar._hx_class = h2d_FontChar
_hx_classes["h2d.FontChar"] = h2d_FontChar

class h2d_FontType(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.FontType"
    _hx_constructs = ["BitmapFont", "SignedDistanceField"]

    @staticmethod
    def SignedDistanceField(channel,alphaCutoff,smoothing):
        return h2d_FontType("SignedDistanceField", 1, (channel,alphaCutoff,smoothing))
h2d_FontType.BitmapFont = h2d_FontType("BitmapFont", 0, ())
h2d_FontType._hx_class = h2d_FontType
_hx_classes["h2d.FontType"] = h2d_FontType


class h2d_Font:
    _hx_class_name = "h2d.Font"
    _hx_is_interface = "False"
    __slots__ = ("name", "size", "baseLine", "lineHeight", "tile", "tilePath", "type", "charset", "glyphs", "nullChar", "defaultChar", "initSize", "offsetX", "offsetY")
    _hx_fields = ["name", "size", "baseLine", "lineHeight", "tile", "tilePath", "type", "charset", "glyphs", "nullChar", "defaultChar", "initSize", "offsetX", "offsetY"]
    _hx_methods = ["getChar", "setOffset", "clone", "resizeTo", "hasChar", "dispose"]

    def __init__(self,name,size,_hx_type = None):
        self.type = None
        self.tilePath = None
        self.tile = None
        self.lineHeight = None
        self.baseLine = None
        self.offsetY = 0
        self.offsetX = 0
        self.name = name
        self.size = size
        self.initSize = size
        self.glyphs = haxe_ds_IntMap()
        def _hx_local_0():
            self.nullChar = h2d_FontChar(h2d_Tile(None,0,0,0,0),0)
            return self.nullChar
        self.defaultChar = _hx_local_0()
        self.charset = hxd_Charset.getDefault()
        if (name is not None):
            self.tilePath = haxe_io_Path.withExtension(name,"png")
        if (_hx_type is None):
            self.type = h2d_FontType.BitmapFont
        else:
            self.type = _hx_type

    def getChar(self,code):
        c = self.glyphs.h.get(code,None)
        if (c is None):
            c = self.charset.resolveChar(code,self.glyphs)
            if (c is None):
                c = (self.nullChar if (((code == 13) or ((code == 10)))) else self.defaultChar)
        return c

    def setOffset(self,x,y):
        dx = (x - self.offsetX)
        dy = (y - self.offsetY)
        if ((dx == 0) and ((dy == 0))):
            return
        g = self.glyphs.iterator()
        while g.hasNext():
            g1 = g.next()
            _hx_local_0 = g1.t
            _hx_local_1 = _hx_local_0.dx
            _hx_local_0.dx = (_hx_local_1 + dx)
            _hx_local_0.dx
            _hx_local_2 = g1.t
            _hx_local_3 = _hx_local_2.dy
            _hx_local_2.dy = (_hx_local_3 + dy)
            _hx_local_2.dy
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.offsetX
        _hx_local_4.offsetX = (_hx_local_5 + dx)
        _hx_local_4.offsetX
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.offsetY
        _hx_local_6.offsetY = (_hx_local_7 + dy)
        _hx_local_6.offsetY

    def clone(self):
        f = h2d_Font(self.name,self.size)
        f.baseLine = self.baseLine
        f.lineHeight = self.lineHeight
        f.tile = self.tile.clone()
        f.charset = self.charset
        f.defaultChar = self.defaultChar.clone()
        f.type = self.type
        g = self.glyphs.keys()
        while g.hasNext():
            g1 = g.next()
            c = self.glyphs.h.get(g1,None)
            c2 = c.clone()
            if (c == self.defaultChar):
                f.defaultChar = c2
            f.glyphs.set(g1,c2)
        return f

    def resizeTo(self,size):
        ratio = (size / self.initSize)
        c = self.glyphs.iterator()
        while c.hasNext():
            c1 = c.next()
            c1.width = (c1.width * ratio)
            c1.t.scaleToSize((c1.t.width * ratio),(c1.t.height * ratio))
            _hx_local_1 = c1.t
            _hx_local_2 = _hx_local_1.dx
            _hx_local_1.dx = (_hx_local_2 * ratio)
            _hx_local_1.dx
            _hx_local_3 = c1.t
            _hx_local_4 = _hx_local_3.dy
            _hx_local_3.dy = (_hx_local_4 * ratio)
            _hx_local_3.dy
            k = c1.kerning
            while (k is not None):
                k.offset = (k.offset * ratio)
                k = k.next
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.lineHeight
        _hx_local_6.lineHeight = (_hx_local_7 * ratio)
        _hx_local_6.lineHeight
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.baseLine
        _hx_local_8.baseLine = (_hx_local_9 * ratio)
        _hx_local_8.baseLine
        self.size = size

    def hasChar(self,code):
        return (self.glyphs.h.get(code,None) is not None)

    def dispose(self):
        self.tile.dispose()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.size = None
        _hx_o.baseLine = None
        _hx_o.lineHeight = None
        _hx_o.tile = None
        _hx_o.tilePath = None
        _hx_o.type = None
        _hx_o.charset = None
        _hx_o.glyphs = None
        _hx_o.nullChar = None
        _hx_o.defaultChar = None
        _hx_o.initSize = None
        _hx_o.offsetX = None
        _hx_o.offsetY = None
h2d_Font._hx_class = h2d_Font
_hx_classes["h2d.Font"] = h2d_Font


class hxd_Interactive:
    _hx_class_name = "hxd.Interactive"
    _hx_is_interface = "True"
    __slots__ = ("propagateEvents", "cursor")
    _hx_fields = ["propagateEvents", "cursor"]
    _hx_methods = ["set_cursor", "handleEvent", "getInteractiveScene"]
hxd_Interactive._hx_class = hxd_Interactive
_hx_classes["hxd.Interactive"] = hxd_Interactive


class h2d_Interactive(h2d_Drawable):
    _hx_class_name = "h2d.Interactive"
    _hx_is_interface = "False"
    _hx_fields = ["width", "height", "cursor", "isEllipse", "cancelEvents", "propagateEvents", "backgroundColor", "enableRightButton", "scene", "mouseDownButton", "parentMask", "invDet", "shape", "shapeX", "shapeY"]
    _hx_methods = ["onAdd", "draw", "getBoundsRec", "onHierarchyMoved", "updateMask", "onRemove", "checkBounds", "preventClick", "getInteractiveScene", "handleEvent", "calcAbsPos", "set_cursor", "eventToLocal", "startCapture", "stopCapture", "startDrag", "stopDrag", "focus", "blur", "isOver", "hasFocus", "onOver", "onOut", "onPush", "onRelease", "onReleaseOutside", "onClick", "onMove", "onWheel", "onFocus", "onFocusLost", "onKeyUp", "onKeyDown", "onCheck", "onTextInput"]
    _hx_statics = []
    _hx_interfaces = [hxd_Interactive]
    _hx_super = h2d_Drawable


    def __init__(self,width,height,parent = None,shape = None):
        self.shape = None
        self.invDet = None
        self.parentMask = None
        self.scene = None
        self.backgroundColor = None
        self.isEllipse = None
        self.height = None
        self.width = None
        self.shapeY = 0
        self.shapeX = 0
        self.mouseDownButton = -1
        self.enableRightButton = False
        self.propagateEvents = False
        self.cancelEvents = False
        self.cursor = hxd_Cursor.Button
        super().__init__(parent)
        self.width = width
        self.height = height
        self.shape = shape

    def onAdd(self):
        self.scene = self.getScene()
        if (self.scene is not None):
            self.scene.addEventTarget(self)
        self.updateMask()
        super().onAdd()

    def draw(self,ctx):
        if (self.backgroundColor is not None):
            tmp = self.backgroundColor
            x = self.width
            tmp1 = None
            try:
                tmp1 = int(x)
            except BaseException as _g:
                None
                tmp1 = None
            x = self.height
            tmp2 = None
            try:
                tmp2 = int(x)
            except BaseException as _g:
                None
                tmp2 = None
            self.emitTile(ctx,h2d_Tile.fromColor(tmp,tmp1,tmp2,((HxOverrides.rshift(self.backgroundColor, 24)) / 255)))

    def getBoundsRec(self,relativeTo,out,forSize):
        super().getBoundsRec(relativeTo,out,forSize)
        if ((self.backgroundColor is not None) or forSize):
            x = self.width
            tmp = None
            try:
                tmp = int(x)
            except BaseException as _g:
                None
                tmp = None
            x = self.height
            tmp1 = None
            try:
                tmp1 = int(x)
            except BaseException as _g:
                None
                tmp1 = None
            self.addBounds(relativeTo,out,0,0,tmp,tmp1)

    def onHierarchyMoved(self,parentChanged):
        super().onHierarchyMoved(parentChanged)
        if (self.scene is not None):
            self.scene.removeEventTarget(self)
            self.scene = self.getScene()
            if (self.scene is not None):
                self.scene.addEventTarget(self)
        if parentChanged:
            self.updateMask()

    def updateMask(self):
        self.parentMask = None
        p = self.parent
        while (p is not None):
            m = Std.downcast(p,h2d_Mask)
            if (m is not None):
                self.parentMask = m
                break
            p = p.parent

    def onRemove(self):
        if (self.scene is not None):
            self.scene.removeEventTarget(self,True)
            self.scene = None
        super().onRemove()

    def checkBounds(self,e):
        tmp = e.kind.index
        if ((((tmp == 10) or ((tmp == 7))) or ((tmp == 6))) or ((tmp == 4))):
            return False
        else:
            return True

    def preventClick(self):
        self.mouseDownButton = -1

    def getInteractiveScene(self):
        return self.scene

    def handleEvent(self,e):
        if ((self.parentMask is not None) and self.checkBounds(e)):
            p = self.parentMask
            pt = h2d_col_Point(e.relX,e.relY)
            self.localToGlobal(pt)
            saveX = pt.x
            saveY = pt.y
            while (p is not None):
                pt.x = saveX
                pt.y = saveY
                pt1 = p.globalToLocal(pt)
                if ((((pt1.x < 0) or ((pt1.y < 0))) or ((pt1.x > p.width))) or ((pt1.y > p.height))):
                    e.cancel = True
                    return
                p = p.parentMask
        if (((self.shape is None) and self.isEllipse) and self.checkBounds(e)):
            cx = (self.width * 0.5)
            cy = (self.height * 0.5)
            dx = (((e.relX - cx)) / cx)
            dy = (((e.relY - cy)) / cy)
            if (((dx * dx) + ((dy * dy))) > 1):
                e.cancel = True
                return
        if self.propagateEvents:
            e.propagate = True
        if self.cancelEvents:
            e.cancel = True
        tmp = e.kind.index
        if (tmp == 0):
            if (self.enableRightButton or ((e.button == 0))):
                self.mouseDownButton = e.button
                self.onPush(e)
                if e.cancel:
                    self.mouseDownButton = -1
        elif (tmp == 1):
            if (self.enableRightButton or ((e.button == 0))):
                self.onRelease(e)
                if (self.mouseDownButton == e.button):
                    self.onClick(e)
            self.mouseDownButton = -1
        elif (tmp == 2):
            self.onMove(e)
        elif (tmp == 3):
            self.onOver(e)
        elif (tmp == 4):
            self.onOut(e)
        elif (tmp == 5):
            self.onWheel(e)
        elif (tmp == 6):
            self.onFocus(e)
        elif (tmp == 7):
            self.onFocusLost(e)
        elif (tmp == 8):
            self.onKeyDown(e)
        elif (tmp == 9):
            self.onKeyUp(e)
        elif (tmp == 10):
            if (self.enableRightButton or ((e.button == 0))):
                self.onRelease(e)
                if (self.mouseDownButton == e.button):
                    self.onReleaseOutside(e)
            self.mouseDownButton = -1
        elif (tmp == 11):
            self.onTextInput(e)
        elif (tmp == 12):
            self.onCheck(e)
        else:
            pass

    def calcAbsPos(self):
        super().calcAbsPos()
        self.invDet = (1 / (((self.matA * self.matD) - ((self.matB * self.matC)))))

    def set_cursor(self,c):
        self.cursor = c
        if ((self.scene is not None) and ((self.scene.events is not None))):
            self.scene.events.updateCursor(self)
        return c

    def eventToLocal(self,e):
        i = self
        dx = (e.relX - i.absX)
        dy = (e.relY - i.absY)
        e.relX = ((((dx * i.matD) - ((dy * i.matC)))) * i.invDet)
        e.relY = ((((-dx * i.matB) + ((dy * i.matA)))) * i.invDet)

    def startCapture(self,callb,onCancel = None,touchId = None):
        _gthis = self
        def _hx_local_0(event):
            x = event.relX
            y = event.relY
            _gthis.eventToLocal(event)
            callb(event)
            event.relX = x
            event.relY = y
        self.scene.startCapture(_hx_local_0,onCancel,touchId)

    def stopCapture(self):
        self.scene.stopCapture()

    def startDrag(self,callb,onCancel = None):
        self.startCapture(callb,onCancel)

    def stopDrag(self):
        self.stopCapture()

    def focus(self):
        if ((self.scene is None) or ((self.scene.events is None))):
            return
        self.scene.events.focus(self)

    def blur(self):
        if self.hasFocus():
            self.scene.events.blur()

    def isOver(self):
        if ((self.scene is not None) and ((self.scene.events is not None))):
            return (python_internal_ArrayImpl.indexOf(self.scene.events.overList,self,None) != -1)
        else:
            return False

    def hasFocus(self):
        if ((self.scene is not None) and ((self.scene.events is not None))):
            return (self.scene.events.currentFocus == self)
        else:
            return False

    def onOver(self,e):
        pass

    def onOut(self,e):
        pass

    def onPush(self,e):
        pass

    def onRelease(self,e):
        pass

    def onReleaseOutside(self,e):
        pass

    def onClick(self,e):
        pass

    def onMove(self,e):
        pass

    def onWheel(self,e):
        pass

    def onFocus(self,e):
        pass

    def onFocusLost(self,e):
        pass

    def onKeyUp(self,e):
        pass

    def onKeyDown(self,e):
        pass

    def onCheck(self,e):
        pass

    def onTextInput(self,e):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.cursor = None
        _hx_o.isEllipse = None
        _hx_o.cancelEvents = None
        _hx_o.propagateEvents = None
        _hx_o.backgroundColor = None
        _hx_o.enableRightButton = None
        _hx_o.scene = None
        _hx_o.mouseDownButton = None
        _hx_o.parentMask = None
        _hx_o.invDet = None
        _hx_o.shape = None
        _hx_o.shapeX = None
        _hx_o.shapeY = None
h2d_Interactive._hx_class = h2d_Interactive
_hx_classes["h2d.Interactive"] = h2d_Interactive


class h2d_Layers(h2d_Object):
    _hx_class_name = "h2d.Layers"
    _hx_is_interface = "False"
    __slots__ = ("layersIndexes", "layerCount")
    _hx_fields = ["layersIndexes", "layerCount"]
    _hx_methods = ["addChild", "add", "addChildAt", "removeChild", "under", "over", "getLayer", "getChildLayer", "drawLayer", "ysort"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Object


    def __init__(self,parent = None):
        self.layerCount = None
        self.layersIndexes = None
        super().__init__(parent)
        self.layersIndexes = []
        self.layerCount = 0

    def addChild(self,s):
        self.addChildAt(s,0)

    def add(self,s,layer):
        self.addChildAt(s,layer)

    def addChildAt(self,s,layer):
        if (s.parent == self):
            old = s.allocated
            s.allocated = False
            self.removeChild(s)
            s.allocated = old
        while (layer >= self.layerCount):
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.layerCount
                _hx_local_0.layerCount = (_hx_local_1 + 1)
                return _hx_local_1
            python_internal_ArrayImpl._set(self.layersIndexes, _hx_local_2(), len(self.children))
        super().addChildAt(s,(self.layersIndexes[layer] if layer >= 0 and layer < len(self.layersIndexes) else None))
        _g = layer
        _g1 = self.layerCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _hx_local_3 = self.layersIndexes
            _hx_local_4 = i
            _hx_local_5 = (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
            python_internal_ArrayImpl._set(_hx_local_3, _hx_local_4, (_hx_local_5 + 1))
            _hx_local_5

    def removeChild(self,s):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == s):
                _this = self.children
                pos = i
                if (pos < 0):
                    pos = (len(_this) + pos)
                if (pos < 0):
                    pos = 0
                res = _this[pos:(pos + 1)]
                del _this[pos:(pos + 1)]
                if s.allocated:
                    s.onRemove()
                s.parent = None
                s.posChanged = True
                if (s.parentContainer is not None):
                    s.setParentContainer(None)
                k = (self.layerCount - 1)
                while ((k >= 0) and (((self.layersIndexes[k] if k >= 0 and k < len(self.layersIndexes) else None) > i))):
                    _hx_local_0 = self.layersIndexes
                    _hx_local_1 = k
                    _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
                    python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 - 1))
                    _hx_local_2
                    k = (k - 1)
                if (self.parentContainer is not None):
                    self.parentContainer.contentChanged(self)
                break

    def under(self,s):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == s):
                pos = 0
                _g2 = 0
                _g3 = self.layersIndexes
                while (_g2 < len(_g3)):
                    l = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if (l > i):
                        break
                    else:
                        pos = l
                p = i
                while (p > pos):
                    python_internal_ArrayImpl._set(self.children, p, python_internal_ArrayImpl._get(self.children, (p - 1)))
                    p = (p - 1)
                python_internal_ArrayImpl._set(self.children, pos, s)
                if s.allocated:
                    s.onHierarchyMoved(False)
                return

    def over(self,s):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == s):
                _g2 = 0
                _g3 = self.layersIndexes
                while (_g2 < len(_g3)):
                    l = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if (l > i):
                        _g4 = i
                        _g5 = (l - 1)
                        while (_g4 < _g5):
                            p = _g4
                            _g4 = (_g4 + 1)
                            python_internal_ArrayImpl._set(self.children, p, python_internal_ArrayImpl._get(self.children, (p + 1)))
                        python_internal_ArrayImpl._set(self.children, (l - 1), s)
                        if s.allocated:
                            s.onHierarchyMoved(False)
                        return
                return

    def getLayer(self,layer):
        a = None
        if (layer >= self.layerCount):
            a = []
        else:
            start = (0 if ((layer == 0)) else python_internal_ArrayImpl._get(self.layersIndexes, (layer - 1)))
            _hx_max = (self.layersIndexes[layer] if layer >= 0 and layer < len(self.layersIndexes) else None)
            a = self.children[start:_hx_max]
        return hxd_impl_ArrayIterator_h2d_Object(a)

    def getChildLayer(self,s):
        if (s.parent != self):
            return -1
        index = python_internal_ArrayImpl.indexOf(self.children,s,None)
        _g = 0
        _g1 = self.layerCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.layersIndexes[i] if i >= 0 and i < len(self.layersIndexes) else None) > index):
                return i
        return -1

    def drawLayer(self,ctx,layer):
        if (layer >= self.layerCount):
            return
        old = ctx.globalAlpha
        ctx.globalAlpha = (ctx.globalAlpha * self.alpha)
        start = (0 if ((layer == 0)) else python_internal_ArrayImpl._get(self.layersIndexes, (layer - 1)))
        _hx_max = (self.layersIndexes[layer] if layer >= 0 and layer < len(self.layersIndexes) else None)
        if ctx.front2back:
            _g = start
            _g1 = _hx_max
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                python_internal_ArrayImpl._get(self.children, ((_hx_max - 1) - i)).drawRec(ctx)
        else:
            _g = start
            _g1 = _hx_max
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                (self.children[i] if i >= 0 and i < len(self.children) else None).drawRec(ctx)
        ctx.globalAlpha = old

    def ysort(self,layer):
        if (layer >= self.layerCount):
            return
        start = (0 if ((layer == 0)) else python_internal_ArrayImpl._get(self.layersIndexes, (layer - 1)))
        _hx_max = (self.layersIndexes[layer] if layer >= 0 and layer < len(self.layersIndexes) else None)
        if (start == _hx_max):
            return
        pos = start
        ymax = pos
        pos = (pos + 1)
        ymax1 = (self.children[ymax] if ymax >= 0 and ymax < len(self.children) else None).y
        while (pos < _hx_max):
            c = (self.children[pos] if pos >= 0 and pos < len(self.children) else None)
            if (c.y < ymax1):
                p = (pos - 1)
                while (p >= start):
                    c2 = (self.children[p] if p >= 0 and p < len(self.children) else None)
                    if (c.y >= c2.y):
                        break
                    python_internal_ArrayImpl._set(self.children, (p + 1), c2)
                    p = (p - 1)
                python_internal_ArrayImpl._set(self.children, (p + 1), c)
                if c.allocated:
                    c.onHierarchyMoved(False)
            else:
                ymax1 = c.y
            pos = (pos + 1)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.layersIndexes = None
        _hx_o.layerCount = None
h2d_Layers._hx_class = h2d_Layers
_hx_classes["h2d.Layers"] = h2d_Layers


class h2d_Mask(h2d_Object):
    _hx_class_name = "h2d.Mask"
    _hx_is_interface = "False"
    __slots__ = ("width", "height", "parentMask", "scrollX", "scrollY", "scrollBounds")
    _hx_fields = ["width", "height", "parentMask", "scrollX", "scrollY", "scrollBounds"]
    _hx_methods = ["scrollTo", "scrollBy", "onHierarchyMoved", "onAdd", "updateMask", "set_scrollX", "set_scrollY", "calcAbsPos", "getBoundsRec", "drawRec"]
    _hx_statics = ["maskWith", "unmask"]
    _hx_interfaces = []
    _hx_super = h2d_Object


    def __init__(self,width,height,parent = None):
        self.scrollBounds = None
        self.parentMask = None
        self.height = None
        self.width = None
        self.scrollY = 0
        self.scrollX = 0
        super().__init__(parent)
        self.width = width
        self.height = height

    def scrollTo(self,x,y):
        self.set_scrollX(x)
        self.set_scrollY(y)

    def scrollBy(self,x,y):
        self.set_scrollX((self.scrollX + x))
        self.set_scrollY((self.scrollY + y))

    def onHierarchyMoved(self,parentChanged):
        super().onHierarchyMoved(parentChanged)
        if parentChanged:
            self.updateMask()

    def onAdd(self):
        super().onAdd()
        self.updateMask()

    def updateMask(self):
        self.parentMask = None
        p = self.parent
        while (p is not None):
            m = Std.downcast(p,h2d_Mask)
            if (m is not None):
                self.parentMask = m
                break
            p = p.parent

    def set_scrollX(self,v):
        if (self.scrollBounds is not None):
            _hx_min = self.scrollBounds.xMin
            _hx_max = (self.scrollBounds.xMax - self.width)
            if (_hx_max is None):
                _hx_max = 1.
            if (_hx_min is None):
                _hx_min = 0.
            if (v < _hx_min):
                v = _hx_min
            elif (v > _hx_max):
                v = _hx_max
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scrollX = v
                return self.scrollX
            return _hx_local_0()
        return _hx_local_1()

    def set_scrollY(self,v):
        if (self.scrollBounds is not None):
            _hx_min = self.scrollBounds.yMin
            _hx_max = (self.scrollBounds.yMax - self.height)
            if (_hx_max is None):
                _hx_max = 1.
            if (_hx_min is None):
                _hx_min = 0.
            if (v < _hx_min):
                v = _hx_min
            elif (v > _hx_max):
                v = _hx_max
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scrollY = v
                return self.scrollY
            return _hx_local_0()
        return _hx_local_1()

    def calcAbsPos(self):
        super().calcAbsPos()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.absX
        _hx_local_0.absX = (_hx_local_1 - self.scrollX)
        _hx_local_0.absX
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.absY
        _hx_local_2.absY = (_hx_local_3 - self.scrollY)
        _hx_local_2.absY

    def getBoundsRec(self,relativeTo,out,forSize):
        xMin = out.xMin
        yMin = out.yMin
        xMax = out.xMax
        yMax = out.yMax
        out.xMin = 1e20
        out.yMin = 1e20
        out.xMax = -1e20
        out.yMax = -1e20
        if self.posChanged:
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.posChanged = True
            self.posChanged = False
        self.addBounds(relativeTo,out,self.scrollX,self.scrollY,self.width,self.height)
        bxMin = out.xMin
        byMin = out.yMin
        bxMax = out.xMax
        byMax = out.yMax
        out.xMin = xMin
        out.xMax = xMax
        out.yMin = yMin
        out.yMax = yMax
        super().getBoundsRec(relativeTo,out,forSize)
        if (out.xMin < bxMin):
            out.xMin = (bxMin if ((xMin > bxMin)) else xMin)
        if (out.yMin < byMin):
            out.yMin = (byMin if ((yMin > byMin)) else yMin)
        if (out.xMax > bxMax):
            out.xMax = (bxMax if ((xMax < bxMax)) else xMax)
        if (out.yMax > byMax):
            out.yMax = (byMax if ((yMax < byMax)) else yMax)

    def drawRec(self,ctx):
        h2d_Mask.maskWith(ctx,self,self.width,self.height,self.scrollX,self.scrollY)
        super().drawRec(ctx)
        h2d_Mask.unmask(ctx)

    @staticmethod
    def maskWith(ctx,object,width,height,scrollX = None,scrollY = None):
        if (scrollX is None):
            scrollX = 0
        if (scrollY is None):
            scrollY = 0
        x1 = (object.absX + scrollX)
        y1 = (object.absY + scrollY)
        x2 = (((width * object.matA) + ((height * object.matC))) + x1)
        y2 = (((width * object.matB) + ((height * object.matD))) + y1)
        tmp = None
        if (x1 > x2):
            tmp = x1
            x1 = x2
            x2 = tmp
        if (y1 > y2):
            tmp = y1
            y1 = y2
            y2 = tmp
        ctx.pushRenderZone(x1,y1,(x2 - x1),(y2 - y1))

    @staticmethod
    def unmask(ctx):
        ctx.popRenderZone()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.parentMask = None
        _hx_o.scrollX = None
        _hx_o.scrollY = None
        _hx_o.scrollBounds = None
h2d_Mask._hx_class = h2d_Mask
_hx_classes["h2d.Mask"] = h2d_Mask


class h3d_impl_RenderContext:
    _hx_class_name = "h3d.impl.RenderContext"
    _hx_is_interface = "False"
    __slots__ = ("engine", "time", "elapsedTime", "frame", "textures")
    _hx_fields = ["engine", "time", "elapsedTime", "frame", "textures"]
    _hx_methods = ["dispose"]

    def __init__(self):
        self.textures = None
        self.engine = h3d_Engine.CURRENT
        self.frame = 0
        self.time = 0.
        self.elapsedTime = (1. / hxd_System.getDefaultFrameRate())
        self.textures = h3d_impl_TextureCache(self)

    def dispose(self):
        self.textures.dispose()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.engine = None
        _hx_o.time = None
        _hx_o.elapsedTime = None
        _hx_o.frame = None
        _hx_o.textures = None
h3d_impl_RenderContext._hx_class = h3d_impl_RenderContext
_hx_classes["h3d.impl.RenderContext"] = h3d_impl_RenderContext


class h2d_RenderContext(h3d_impl_RenderContext):
    _hx_class_name = "h2d.RenderContext"
    _hx_is_interface = "False"
    __slots__ = ("globalAlpha", "buffer", "bufPos", "scene", "defaultSmooth", "killAlpha", "front2back", "onBeginDraw", "onEnterFilter", "onLeaveFilter", "tmpBounds", "texture", "baseShader", "manager", "compiledShader", "buffers", "fixedBuffer", "_hx_pass", "currentShaders", "baseShaderList", "currentObj", "stride", "targetsStack", "targetsStackIndex", "cameraStack", "cameraStackIndex", "curTarget", "renderZoneStack", "renderZoneIndex", "hasUVPos", "filterStack", "inFilter", "inFilterBlend", "viewA", "viewB", "viewC", "viewD", "viewX", "viewY", "hasRenderZone", "renderX", "renderY", "renderW", "renderH", "currentBlend", "baseFlipY", "targetFlipY")
    _hx_fields = ["globalAlpha", "buffer", "bufPos", "scene", "defaultSmooth", "killAlpha", "front2back", "onBeginDraw", "onEnterFilter", "onLeaveFilter", "tmpBounds", "texture", "baseShader", "manager", "compiledShader", "buffers", "fixedBuffer", "pass", "currentShaders", "baseShaderList", "currentObj", "stride", "targetsStack", "targetsStackIndex", "cameraStack", "cameraStackIndex", "curTarget", "renderZoneStack", "renderZoneIndex", "hasUVPos", "filterStack", "inFilter", "inFilterBlend", "viewA", "viewB", "viewC", "viewD", "viewX", "viewY", "hasRenderZone", "renderX", "renderY", "renderW", "renderH", "currentBlend", "baseFlipY", "targetFlipY"]
    _hx_methods = ["dispose", "hasBuffering", "begin", "allocTarget", "clear", "initShaders", "end", "pushCamera", "popCamera", "pushFilter", "popFilter", "pushTarget", "pushTargets", "popTarget", "pushRenderZone", "popRenderZone", "clipRenderZone", "setRZ", "clearRZ", "setRenderZone", "clearRenderZone", "drawLayer", "drawScene", "flush", "_flush", "beforeDraw", "setupColor", "beginDrawBatchState", "swapTexture", "beginDrawObject", "beginDrawBatch", "drawTile", "beginDraw"]
    _hx_statics = ["BUFFERING"]
    _hx_interfaces = []
    _hx_super = h3d_impl_RenderContext


    def __init__(self,scene):
        self.targetFlipY = None
        self.baseFlipY = None
        self.currentBlend = None
        self.renderH = None
        self.renderW = None
        self.renderY = None
        self.renderX = None
        self.hasRenderZone = None
        self.viewY = None
        self.viewX = None
        self.viewD = None
        self.viewC = None
        self.viewB = None
        self.viewA = None
        self.inFilterBlend = None
        self.inFilter = None
        self.filterStack = None
        self.hasUVPos = None
        self.curTarget = None
        self.cameraStackIndex = None
        self.cameraStack = None
        self.targetsStackIndex = None
        self.targetsStack = None
        self.stride = None
        self.currentObj = None
        self.baseShaderList = None
        self.currentShaders = None
        self._hx_pass = None
        self.fixedBuffer = None
        self.buffers = None
        self.compiledShader = None
        self.manager = None
        self.baseShader = None
        self.texture = None
        self.onLeaveFilter = None
        self.onEnterFilter = None
        self.onBeginDraw = None
        self.front2back = None
        self.killAlpha = None
        self.scene = None
        self.bufPos = None
        self.buffer = None
        self.renderZoneIndex = 0
        self.renderZoneStack = []
        self.tmpBounds = h2d_col_Bounds()
        self.defaultSmooth = False
        self.globalAlpha = 1.
        super().__init__()
        self.scene = scene
        self.bufPos = 0
        self.manager = h3d_pass_ShaderManager()
        self._hx_pass = h3d_mat_Pass("",None)
        self._hx_pass.depth(True,h3d_mat_Compare.Always)
        self._hx_pass.set_culling(h3d_mat_Face._hx_None)
        self.baseShader = h3d_shader_Base2d()
        self.baseShader.setPriority(100)
        self.baseShader.zValue__ = 0.
        self.baseShaderList = hxsl_ShaderList(self.baseShader)
        self.targetsStack = []
        self.targetsStackIndex = 0
        self.cameraStack = []
        self.cameraStackIndex = 0
        self.filterStack = []

    def dispose(self):
        super().dispose()
        if (self.fixedBuffer is not None):
            self.fixedBuffer.dispose()

    def hasBuffering(self):
        return False

    def begin(self):
        self.texture = None
        self.currentObj = None
        self.bufPos = 0
        self.stride = 0
        self.viewA = self.scene.viewportA
        self.viewB = 0
        self.viewC = 0
        self.viewD = self.scene.viewportD
        self.viewX = self.scene.viewportX
        self.viewY = self.scene.viewportY
        self.targetFlipY = (-1 if (self.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords)) else 1)
        self.baseFlipY = (self.targetFlipY if ((self.engine.getCurrentTarget() is not None)) else 1)
        self.inFilter = None
        self.manager.globals.set("time",self.time)
        self.manager.globals.set("global.time",self.time)
        _this = self.baseShader
        _this.constModified = True
        _this.pixelAlign__ = False
        _this = self.baseShader.halfPixelInverse__
        x = (0.5 / self.engine.width)
        y = (0.5 / self.engine.height)
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        _this = self.baseShader.viewportA__
        x = self.scene.viewportA
        y = 0
        z = self.scene.viewportX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.viewportB__
        x = 0
        y = (self.scene.viewportD * -self.baseFlipY)
        z = (self.scene.viewportY * -self.baseFlipY)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.filterMatrixA__
        x = 1
        y = 0
        z = 0
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.filterMatrixB__
        x = 0
        y = 1
        z = 0
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        self.baseShaderList.next = None
        self.initShaders(self.baseShaderList)
        self.engine.selectMaterial(self._hx_pass)
        self.textures.begin()

    def allocTarget(self,name,_hx_filter = None):
        if (_hx_filter is None):
            _hx_filter = False
        t = self.textures.allocTarget(name,self.scene.width,self.scene.height,False)
        t.set_filter((h3d_mat_Filter.Linear if _hx_filter else h3d_mat_Filter.Nearest))
        return t

    def clear(self,color):
        self.engine.clear(color)

    def initShaders(self,shaders):
        self.currentShaders = shaders
        self.compiledShader = self.manager.compileShaders(shaders)
        if (self.buffers is None):
            self.buffers = h3d_shader_Buffers(self.compiledShader)
        else:
            _this = self.buffers
            s = self.compiledShader
            _this.vertex.grow(s.vertex)
            _this.fragment.grow(s.fragment)
        self.manager.fillGlobals(self.buffers,self.compiledShader)
        self.engine.selectShader(self.compiledShader)
        self.engine.uploadShaderBuffers(self.buffers,0)

    def end(self):
        self.texture = None
        self.currentObj = None
        self.baseShaderList.next = None
        if (self.targetsStackIndex != 0):
            raise haxe_Exception.thrown("Missing popTarget()")
        if (self.cameraStackIndex != 0):
            raise haxe_Exception.thrown("Missing popCamera()")

    def pushCamera(self,cam):
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.cameraStackIndex
            _hx_local_0.cameraStackIndex = (_hx_local_1 + 1)
            return _hx_local_1
        entry = python_internal_ArrayImpl._get(self.cameraStack, _hx_local_2())
        if (entry is None):
            entry = _hx_AnonObject({'va': 0, 'vb': 0, 'vc': 0, 'vd': 0, 'vx': 0, 'vy': 0})
            _this = self.cameraStack
            _this.append(entry)
        tmpA = self.viewA
        tmpB = self.viewB
        tmpC = self.viewC
        tmpD = self.viewD
        entry.va = tmpA
        entry.vb = tmpB
        entry.vc = tmpC
        entry.vd = tmpD
        entry.vx = self.viewX
        entry.vy = self.viewY
        self.viewA = ((cam.matA * tmpA) + ((cam.matB * tmpC)))
        self.viewB = ((cam.matA * tmpB) + ((cam.matB * tmpD)))
        self.viewC = ((cam.matC * tmpA) + ((cam.matD * tmpC)))
        self.viewD = ((cam.matC * tmpB) + ((cam.matD * tmpD)))
        self.viewX = (((cam.absX * tmpA) + ((cam.absY * tmpC))) + self.viewX)
        self.viewY = (((cam.absX * tmpB) + ((cam.absY * tmpD))) + self.viewY)
        flipY = (-self.targetFlipY if ((self.curTarget is not None)) else -self.baseFlipY)
        _this = self.baseShader.viewportA__
        x = self.viewA
        y = self.viewC
        z = self.viewX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.viewportB__
        x = (self.viewB * flipY)
        y = (self.viewD * flipY)
        z = (self.viewY * flipY)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.

    def popCamera(self):
        if (self.cameraStackIndex == 0):
            raise haxe_Exception.thrown("Too many popCamera()")
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.cameraStackIndex
            _hx_local_0.cameraStackIndex = (_hx_local_1 - 1)
            return _hx_local_0.cameraStackIndex
        inf = python_internal_ArrayImpl._get(self.cameraStack, _hx_local_2())
        self.viewA = inf.va
        self.viewB = inf.vb
        self.viewC = inf.vc
        self.viewD = inf.vd
        self.viewX = inf.vx
        self.viewY = inf.vy
        flipY = (-self.targetFlipY if ((self.curTarget is not None)) else -self.baseFlipY)
        _this = self.baseShader.viewportA__
        x = self.viewA
        y = self.viewC
        z = self.viewX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.viewportB__
        x = (self.viewB * flipY)
        y = (self.viewD * flipY)
        z = (self.viewY * flipY)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.

    def pushFilter(self,spr):
        if ((len(self.filterStack) == 0) and ((self.onEnterFilter is not None))):
            if (not self.onEnterFilter(spr)):
                return False
        _this = self.filterStack
        _this.append(spr)
        self.inFilter = spr
        return True

    def popFilter(self):
        _this = self.filterStack
        spr = (None if ((len(_this) == 0)) else _this.pop())
        if (len(self.filterStack) > 0):
            self.inFilter = python_internal_ArrayImpl._get(self.filterStack, (len(self.filterStack) - 1))
        else:
            self.inFilter = None
            if (self.onLeaveFilter is not None):
                self.onLeaveFilter(spr)

    def pushTarget(self,t,startX = None,startY = None,width = None,height = None):
        if (startX is None):
            startX = 0
        if (startY is None):
            startY = 0
        if (width is None):
            width = -1
        if (height is None):
            height = -1
        self.engine.pushTarget(t)
        self.initShaders(self.baseShaderList)
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.targetsStackIndex
            _hx_local_0.targetsStackIndex = (_hx_local_1 + 1)
            return _hx_local_1
        entry = python_internal_ArrayImpl._get(self.targetsStack, _hx_local_2())
        if (entry is None):
            entry = _hx_AnonObject({'t': None, 'va': 0, 'vb': 0, 'vc': 0, 'vd': 0, 'vx': 0, 'vy': 0, 'hasRZ': False, 'rzX': 0, 'rzY': 0, 'rzW': 0, 'rzH': 0})
            _this = self.targetsStack
            _this.append(entry)
        entry.t = self.curTarget
        entry.va = self.viewA
        entry.vb = self.viewB
        entry.vc = self.viewC
        entry.vd = self.viewD
        entry.vx = self.viewX
        entry.vy = self.viewY
        entry.hasRZ = self.hasRenderZone
        entry.rzX = self.renderX
        entry.rzY = self.renderY
        entry.rzW = self.renderW
        entry.rzH = self.renderH
        if (width < 0):
            width = (self.scene.width if ((t is None)) else t.width)
        if (height < 0):
            height = (self.scene.height if ((t is None)) else t.height)
        self.viewA = (2 / width)
        self.viewB = 0
        self.viewC = 0
        self.viewD = (2 / height)
        self.viewX = (-1 - ((startX * self.viewA)))
        self.viewY = (-1 - ((startY * self.viewD)))
        _this = self.baseShader.halfPixelInverse__
        x = (0.5 / ((self.engine.width if ((t is None)) else t.width)))
        y = (0.5 / ((self.engine.height if ((t is None)) else t.height)))
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        _this = self.baseShader.viewportA__
        x = self.viewA
        y = self.viewC
        z = self.viewX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.viewportB__
        x = (self.viewB * -self.targetFlipY)
        y = (self.viewD * -self.targetFlipY)
        z = (self.viewY * -self.targetFlipY)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        self.curTarget = t
        self.currentBlend = None
        if self.hasRenderZone:
            self.hasRenderZone = False
            self.engine.setRenderZone()

    def pushTargets(self,texs):
        self.pushTarget((texs[0] if 0 < len(texs) else None))
        if (len(texs) > 1):
            self.engine.popTarget()
            self.engine.pushTargets(texs)

    def popTarget(self):
        if (self.targetsStackIndex <= 0):
            raise haxe_Exception.thrown("Too many popTarget()")
        self.engine.popTarget()
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.targetsStackIndex
            _hx_local_0.targetsStackIndex = (_hx_local_1 - 1)
            return _hx_local_0.targetsStackIndex
        tinf = python_internal_ArrayImpl._get(self.targetsStack, _hx_local_2())
        def _hx_local_3():
            self.curTarget = tinf.t
            return self.curTarget
        t = _hx_local_3()
        self.viewA = tinf.va
        self.viewB = tinf.vb
        self.viewC = tinf.vc
        self.viewD = tinf.vd
        self.viewX = tinf.vx
        self.viewY = tinf.vy
        flipY = (-self.baseFlipY if ((t is None)) else -self.targetFlipY)
        self.initShaders(self.baseShaderList)
        _this = self.baseShader.halfPixelInverse__
        x = (0.5 / ((self.engine.width if ((t is None)) else t.width)))
        y = (0.5 / ((self.engine.height if ((t is None)) else t.height)))
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        _this = self.baseShader.viewportA__
        x = self.viewA
        y = self.viewC
        z = self.viewX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.viewportB__
        x = (self.viewB * flipY)
        y = (self.viewD * flipY)
        z = (self.viewY * flipY)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        if tinf.hasRZ:
            self.setRZ(tinf.rzX,tinf.rzY,tinf.rzW,tinf.rzH)

    def pushRenderZone(self,x,y,w,h):
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.renderZoneIndex
            _hx_local_0.renderZoneIndex = (_hx_local_1 + 1)
            return _hx_local_1
        inf = python_internal_ArrayImpl._get(self.renderZoneStack, _hx_local_2())
        if (inf is None):
            inf = _hx_AnonObject({'hasRZ': self.hasRenderZone, 'x': self.renderX, 'y': self.renderY, 'w': self.renderW, 'h': self.renderH})
            python_internal_ArrayImpl._set(self.renderZoneStack, (self.renderZoneIndex - 1), inf)
        elif self.hasRenderZone:
            inf.hasRZ = True
            inf.x = self.renderX
            inf.y = self.renderY
            inf.w = self.renderW
            inf.h = self.renderH
        else:
            inf.hasRZ = False
        self.setRZ(x,y,w,h)

    def popRenderZone(self):
        if (self.renderZoneIndex == 0):
            raise haxe_Exception.thrown("Too many popRenderZone()")
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.renderZoneIndex
            _hx_local_0.renderZoneIndex = (_hx_local_1 - 1)
            return _hx_local_0.renderZoneIndex
        inf = python_internal_ArrayImpl._get(self.renderZoneStack, _hx_local_2())
        if inf.hasRZ:
            self.setRZ(inf.x,inf.y,inf.w,inf.h)
        else:
            self.hasRenderZone = False
            self.engine.setRenderZone()

    def clipRenderZone(self,x,y,w,h):
        if (not self.hasRenderZone):
            self.pushRenderZone(x,y,w,h)
            return
        b = self.renderX
        if (not python_lib_Math.isnan(x)):
            x = (b if (python_lib_Math.isnan(b)) else max(x,b))
        b = self.renderY
        if (not python_lib_Math.isnan(y)):
            y = (b if (python_lib_Math.isnan(b)) else max(y,b))
        a = (x + w)
        b = (self.renderX + self.renderW)
        x2 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        a = (y + h)
        b = (self.renderY + self.renderH)
        y2 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        if (x2 < x):
            x2 = x
        if (y2 < y):
            y2 = y
        self.pushRenderZone(x,y,(x2 - x),(y2 - y))

    def setRZ(self,x,y,w,h):
        self.hasRenderZone = True
        self.renderX = x
        self.renderY = y
        self.renderW = w
        self.renderH = h
        scaleX = ((self.scene.viewportA * self.engine.width) / 2)
        scaleY = ((self.scene.viewportD * self.engine.height) / 2)
        if (self.inFilter is not None):
            fa = self.baseShader.filterMatrixA__
            fb = self.baseShader.filterMatrixB__
            x2 = (x + w)
            y2 = (y + h)
            rx1 = (((x * fa.x) + ((y * fa.y))) + fa.z)
            ry1 = (((x * fb.x) + ((y * fb.y))) + fb.z)
            rx2 = (((x2 * fa.x) + ((y2 * fa.y))) + fa.z)
            ry2 = (((x2 * fb.x) + ((y2 * fb.y))) + fb.z)
            x = rx1
            y = ry1
            w = (rx2 - rx1)
            h = (ry2 - ry1)
        tmp = self.engine
        x1 = (((x * scaleX) + ((((self.scene.viewportX + 1)) * ((self.engine.width / 2))))) + 1e-10)
        tmp1 = None
        try:
            tmp1 = int(x1)
        except BaseException as _g:
            None
            tmp1 = None
        x = (((y * scaleY) + ((((self.scene.viewportY + 1)) * ((self.engine.height / 2))))) + 1e-10)
        tmp2 = None
        try:
            tmp2 = int(x)
        except BaseException as _g:
            None
            tmp2 = None
        tmp3 = None
        try:
            tmp3 = int(((w * scaleX) + 1e-10))
        except BaseException as _g:
            None
            tmp3 = None
        tmp4 = tmp3
        tmp3 = None
        try:
            tmp3 = int(((h * scaleY) + 1e-10))
        except BaseException as _g:
            None
            tmp3 = None
        tmp.setRenderZone(tmp1,tmp2,tmp4,tmp3)

    def clearRZ(self):
        self.hasRenderZone = False
        self.engine.setRenderZone()

    def setRenderZone(self,x,y,w,h):
        self.pushRenderZone(x,y,w,h)

    def clearRenderZone(self):
        self.popRenderZone()

    def drawLayer(self,layer):
        self.scene.drawLayer(self,layer)

    def drawScene(self):
        self.scene.drawRec(self)

    def flush(self):
        pass

    def _flush(self):
        if (self.bufPos == 0):
            return
        self.beforeDraw()
        x = (self.bufPos / self.stride)
        nverts = None
        try:
            nverts = int(x)
        except BaseException as _g:
            None
            nverts = None
        tmp = h3d_Buffer(nverts,self.stride,[h3d_BufferFlag.Quads, h3d_BufferFlag.Dynamic, h3d_BufferFlag.RawFormat])
        tmp.uploadVector(self.buffer,0,nverts)
        _this = self.engine
        _this.renderBuffer(tmp,_this.mem.quadIndexes,2,0,-1)
        tmp.dispose()
        self.bufPos = 0
        self.texture = None

    def beforeDraw(self):
        if (self.texture is None):
            self.texture = h3d_mat_Texture.fromColor(16711935)
        self.baseShader.texture__ = self.texture
        self.texture.set_filter((h3d_mat_Filter.Linear if ((self.defaultSmooth if ((self.currentObj.smooth is None)) else self.currentObj.smooth)) else h3d_mat_Filter.Nearest))
        self.texture.set_wrap((h3d_mat_Wrap.Repeat if ((self.currentObj.tileWrap and (((self.currentObj.filter is None) or ((self.inFilter is not None)))))) else h3d_mat_Wrap.Clamp))
        blend = self.currentObj.blendMode
        if ((self.inFilter == self.currentObj) and ((blend == h2d_BlendMode.Erase))):
            blend = h2d_BlendMode.Add
        if (self.inFilterBlend is not None):
            blend = self.inFilterBlend
        if (blend != self.currentBlend):
            self.currentBlend = blend
            self._hx_pass.setBlendMode(blend)
            if ((blend == h2d_BlendMode.Alpha) or ((blend == h2d_BlendMode.Add))):
                self._hx_pass.set_blendAlphaSrc(h3d_mat_Blend.One)
                if (self.inFilterBlend is not None):
                    self._hx_pass.set_blendSrc(h3d_mat_Blend.One)
        self.manager.fillParams(self.buffers,self.compiledShader,self.currentShaders)
        self.engine.selectMaterial(self._hx_pass)
        self.engine.uploadShaderBuffers(self.buffers,1)
        self.engine.uploadShaderBuffers(self.buffers,2)
        self.engine.uploadShaderBuffers(self.buffers,3)

    def setupColor(self,obj):
        if (self.inFilter == obj):
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = obj.color.w
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        elif (self.inFilterBlend is not None):
            _this = self.baseShader.color__
            x = self.globalAlpha
            y = self.globalAlpha
            z = self.globalAlpha
            w = self.globalAlpha
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        else:
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = (obj.color.w * self.globalAlpha)
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w

    def beginDrawBatchState(self,obj):
        if (not self.beginDraw(obj,None,True)):
            return False
        if (self.inFilter == obj):
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = obj.color.w
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        elif (self.inFilterBlend is not None):
            _this = self.baseShader.color__
            x = self.globalAlpha
            y = self.globalAlpha
            z = self.globalAlpha
            w = self.globalAlpha
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        else:
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = (obj.color.w * self.globalAlpha)
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        _this = self.baseShader.absoluteMatrixA__
        x = obj.matA
        y = obj.matC
        z = obj.absX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.absoluteMatrixB__
        x = obj.matB
        y = obj.matD
        z = obj.absY
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        return True

    def swapTexture(self,texture):
        self.texture = texture
        self.beforeDraw()

    def beginDrawObject(self,obj,texture):
        if (not self.beginDraw(obj,texture,True)):
            return False
        if (self.inFilter == obj):
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = obj.color.w
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        elif (self.inFilterBlend is not None):
            _this = self.baseShader.color__
            x = self.globalAlpha
            y = self.globalAlpha
            z = self.globalAlpha
            w = self.globalAlpha
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        else:
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = (obj.color.w * self.globalAlpha)
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        _this = self.baseShader.absoluteMatrixA__
        x = obj.matA
        y = obj.matC
        z = obj.absX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.absoluteMatrixB__
        x = obj.matB
        y = obj.matD
        z = obj.absY
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        self.beforeDraw()
        return True

    def beginDrawBatch(self,obj,texture):
        return self.beginDraw(obj,texture,False)

    def drawTile(self,obj,tile):
        matA = None
        matB = None
        matC = None
        matD = None
        absX = None
        absY = None
        if (self.inFilter is not None):
            f1 = self.baseShader.filterMatrixA__
            f2 = self.baseShader.filterMatrixB__
            tmpA = ((obj.matA * f1.x) + ((obj.matB * f1.y)))
            tmpB = ((obj.matA * f2.x) + ((obj.matB * f2.y)))
            tmpC = ((obj.matC * f1.x) + ((obj.matD * f1.y)))
            tmpD = ((obj.matC * f2.x) + ((obj.matD * f2.y)))
            tmpX = (((obj.absX * f1.x) + ((obj.absY * f1.y))) + f1.z)
            tmpY = (((obj.absX * f2.x) + ((obj.absY * f2.y))) + f2.z)
            matA = ((tmpA * self.viewA) + ((tmpB * self.viewC)))
            matB = ((tmpA * self.viewB) + ((tmpB * self.viewD)))
            matC = ((tmpC * self.viewA) + ((tmpD * self.viewC)))
            matD = ((tmpC * self.viewB) + ((tmpD * self.viewD)))
            absX = (((tmpX * self.viewA) + ((tmpY * self.viewC))) + self.viewX)
            absY = (((tmpX * self.viewB) + ((tmpY * self.viewD))) + self.viewY)
        else:
            matA = ((obj.matA * self.viewA) + ((obj.matB * self.viewC)))
            matB = ((obj.matA * self.viewB) + ((obj.matB * self.viewD)))
            matC = ((obj.matC * self.viewA) + ((obj.matD * self.viewC)))
            matD = ((obj.matC * self.viewB) + ((obj.matD * self.viewD)))
            absX = (((obj.absX * self.viewA) + ((obj.absY * self.viewC))) + self.viewX)
            absY = (((obj.absX * self.viewB) + ((obj.absY * self.viewD))) + self.viewY)
        if ((matB == 0) and ((matC == 0))):
            tx = (tile.dx + ((tile.width * 0.5)))
            ty = (tile.dy + ((tile.height * 0.5)))
            a = (-matA if ((matA < 0)) else matA)
            b = (-matD if ((matD < 0)) else matD)
            tr = ((((tile.width if ((tile.width > tile.height)) else tile.height)) * 1.5) * ((b if ((a < b)) else a)))
            cx = (absX + ((tx * matA)))
            cy = (absY + ((ty * matD)))
            if (((((cx + tr) < -1) or (((cx - tr) > 1))) or (((cy + tr) < -1))) or (((cy - tr) > 1))):
                return False
        else:
            xMin = 1e20
            yMin = 1e20
            xMax = -1e20
            yMax = -1e20
            hw = (tile.width * 0.5)
            hh = (tile.height * 0.5)
            px = ((tile.dx * matA) + ((tile.dy * matC)))
            py = ((tile.dx * matB) + ((tile.dy * matD)))
            if (px < xMin):
                xMin = px
            if (px > xMax):
                xMax = px
            if (py < yMin):
                yMin = py
            if (py > yMax):
                yMax = py
            x = tile.width
            px = ((((x + tile.dx)) * matA) + ((tile.dy * matC)))
            py = ((((x + tile.dx)) * matB) + ((tile.dy * matD)))
            if (px < xMin):
                xMin = px
            if (px > xMax):
                xMax = px
            if (py < yMin):
                yMin = py
            if (py > yMax):
                yMax = py
            y = tile.height
            px = ((tile.dx * matA) + ((((y + tile.dy)) * matC)))
            py = ((tile.dx * matB) + ((((y + tile.dy)) * matD)))
            if (px < xMin):
                xMin = px
            if (px > xMax):
                xMax = px
            if (py < yMin):
                yMin = py
            if (py > yMax):
                yMax = py
            x = tile.width
            y = tile.height
            px = ((((x + tile.dx)) * matA) + ((((y + tile.dy)) * matC)))
            py = ((((x + tile.dx)) * matB) + ((((y + tile.dy)) * matD)))
            if (px < xMin):
                xMin = px
            if (px > xMax):
                xMax = px
            if (py < yMin):
                yMin = py
            if (py > yMax):
                yMax = py
            if (((((absX + xMax) < -1) or (((absY + yMax) < -1))) or (((absX + xMin) > 1))) or (((absY + yMin) > 1))):
                return False
        if (not self.beginDraw(obj,tile.innerTex,True,True)):
            return False
        if (self.inFilter == obj):
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = obj.color.w
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        elif (self.inFilterBlend is not None):
            _this = self.baseShader.color__
            x = self.globalAlpha
            y = self.globalAlpha
            z = self.globalAlpha
            w = self.globalAlpha
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        else:
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = (obj.color.w * self.globalAlpha)
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        _this = self.baseShader.absoluteMatrixA__
        x = (tile.width * obj.matA)
        y = (tile.height * obj.matC)
        z = ((obj.absX + ((tile.dx * obj.matA))) + ((tile.dy * obj.matC)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.absoluteMatrixB__
        x = (tile.width * obj.matB)
        y = (tile.height * obj.matD)
        z = ((obj.absY + ((tile.dx * obj.matB))) + ((tile.dy * obj.matD)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.uvPos__
        x = tile.u
        y = tile.v
        z = (tile.u2 - tile.u)
        w = (tile.v2 - tile.v)
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = w
        self.beforeDraw()
        tmp = None
        if (self.fixedBuffer is not None):
            _this = self.fixedBuffer
            tmp = ((_this.buffer is None) or ((_this.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            self.fixedBuffer = h3d_Buffer(4,8,[h3d_BufferFlag.Quads, h3d_BufferFlag.RawFormat])
            this1 = list()
            k = this1
            v = 0
            k.append(v)
            v = 0
            k.append(v)
            v = 0
            k.append(v)
            v = 0
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 0
            k.append(v)
            v = 1
            k.append(v)
            v = 0
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 0
            k.append(v)
            v = 1
            k.append(v)
            v = 0
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            self.fixedBuffer.uploadVector(k,0,4)
        _this = self.engine
        _this.renderBuffer(self.fixedBuffer,_this.mem.quadIndexes,2,0,-1)
        return True

    def beginDraw(self,obj,texture,isRelative,hasUVPos = None):
        if (hasUVPos is None):
            hasUVPos = False
        if ((self.onBeginDraw is not None) and (not self.onBeginDraw(obj))):
            return False
        stride = 8
        shaderChanged = False
        paramsChanged = False
        objShaders = obj.shaders
        curShaders = self.currentShaders.next
        while ((objShaders is not None) and ((curShaders is not None))):
            s = objShaders.s
            t = curShaders.s
            objShaders = objShaders.next
            curShaders = curShaders.next
            prevInst = t.instance
            if (s != t):
                paramsChanged = True
            s.updateConstants(self.manager.globals)
            if (s.instance != prevInst):
                shaderChanged = True
        if (((((objShaders is not None) or ((curShaders is not None))) or ((self.baseShader.isRelative__ != isRelative))) or ((self.baseShader.hasUVPos__ != hasUVPos))) or ((self.baseShader.killAlpha__ != self.killAlpha))):
            shaderChanged = True
        if shaderChanged:
            _this = self.baseShader
            _this.constModified = True
            _this.hasUVPos__ = hasUVPos
            _this = self.baseShader
            _this.constModified = True
            _this.isRelative__ = isRelative
            _this = self.baseShader
            _this.constModified = True
            _this.killAlpha__ = self.killAlpha
            self.baseShader.updateConstants(self.manager.globals)
            self.baseShaderList.next = obj.shaders
            self.initShaders(self.baseShaderList)
        elif paramsChanged:
            if (self.currentShaders != self.baseShaderList):
                raise haxe_Exception.thrown("!")
            self.currentShaders.next = obj.shaders
        self.texture = texture
        self.stride = stride
        self.currentObj = obj
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.globalAlpha = None
        _hx_o.buffer = None
        _hx_o.bufPos = None
        _hx_o.scene = None
        _hx_o.defaultSmooth = None
        _hx_o.killAlpha = None
        _hx_o.front2back = None
        _hx_o.onBeginDraw = None
        _hx_o.onEnterFilter = None
        _hx_o.onLeaveFilter = None
        _hx_o.tmpBounds = None
        _hx_o.texture = None
        _hx_o.baseShader = None
        _hx_o.manager = None
        _hx_o.compiledShader = None
        _hx_o.buffers = None
        _hx_o.fixedBuffer = None
        _hx_o._hx_pass = None
        _hx_o.currentShaders = None
        _hx_o.baseShaderList = None
        _hx_o.currentObj = None
        _hx_o.stride = None
        _hx_o.targetsStack = None
        _hx_o.targetsStackIndex = None
        _hx_o.cameraStack = None
        _hx_o.cameraStackIndex = None
        _hx_o.curTarget = None
        _hx_o.renderZoneStack = None
        _hx_o.renderZoneIndex = None
        _hx_o.hasUVPos = None
        _hx_o.filterStack = None
        _hx_o.inFilter = None
        _hx_o.inFilterBlend = None
        _hx_o.viewA = None
        _hx_o.viewB = None
        _hx_o.viewC = None
        _hx_o.viewD = None
        _hx_o.viewX = None
        _hx_o.viewY = None
        _hx_o.hasRenderZone = None
        _hx_o.renderX = None
        _hx_o.renderY = None
        _hx_o.renderW = None
        _hx_o.renderH = None
        _hx_o.currentBlend = None
        _hx_o.baseFlipY = None
        _hx_o.targetFlipY = None
h2d_RenderContext._hx_class = h2d_RenderContext
_hx_classes["h2d.RenderContext"] = h2d_RenderContext

class h2d_ScaleModeAlign(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.ScaleModeAlign"
    _hx_constructs = ["Left", "Right", "Center", "Top", "Bottom"]
h2d_ScaleModeAlign.Left = h2d_ScaleModeAlign("Left", 0, ())
h2d_ScaleModeAlign.Right = h2d_ScaleModeAlign("Right", 1, ())
h2d_ScaleModeAlign.Center = h2d_ScaleModeAlign("Center", 2, ())
h2d_ScaleModeAlign.Top = h2d_ScaleModeAlign("Top", 3, ())
h2d_ScaleModeAlign.Bottom = h2d_ScaleModeAlign("Bottom", 4, ())
h2d_ScaleModeAlign._hx_class = h2d_ScaleModeAlign
_hx_classes["h2d.ScaleModeAlign"] = h2d_ScaleModeAlign

class h2d_ScaleMode(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.ScaleMode"
    _hx_constructs = ["Resize", "Stretch", "LetterBox", "Fixed", "Zoom", "AutoZoom"]

    @staticmethod
    def Stretch(width,height):
        return h2d_ScaleMode("Stretch", 1, (width,height))

    @staticmethod
    def LetterBox(width,height,integerScale = None,horizontalAlign= None,verticalAlign= None):
        return h2d_ScaleMode("LetterBox", 2, (width,height,integerScale,horizontalAlign,verticalAlign))

    @staticmethod
    def Fixed(width,height,zoom,horizontalAlign = None,verticalAlign= None):
        return h2d_ScaleMode("Fixed", 3, (width,height,zoom,horizontalAlign,verticalAlign))

    @staticmethod
    def Zoom(level):
        return h2d_ScaleMode("Zoom", 4, (level,))

    @staticmethod
    def AutoZoom(minWidth,minHeight,integerScaling = None):
        return h2d_ScaleMode("AutoZoom", 5, (minWidth,minHeight,integerScaling))
h2d_ScaleMode.Resize = h2d_ScaleMode("Resize", 0, ())
h2d_ScaleMode._hx_class = h2d_ScaleMode
_hx_classes["h2d.ScaleMode"] = h2d_ScaleMode


class hxd_InteractiveScene:
    _hx_class_name = "hxd.InteractiveScene"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["setEvents", "handleEvent", "dispatchEvent", "dispatchListeners", "isInteractiveVisible"]
hxd_InteractiveScene._hx_class = hxd_InteractiveScene
_hx_classes["hxd.InteractiveScene"] = hxd_InteractiveScene


class h2d_Scene(h2d_Layers):
    _hx_class_name = "h2d.Scene"
    _hx_is_interface = "False"
    __slots__ = ("width", "height", "viewportA", "viewportD", "viewportX", "viewportY", "offsetX", "offsetY", "viewportScaleX", "viewportScaleY", "mouseX", "mouseY", "scaleMode", "_cameras", "interactiveCamera", "interactive", "eventListeners", "ctx", "window", "events", "shapePoint")
    _hx_fields = ["width", "height", "viewportA", "viewportD", "viewportX", "viewportY", "offsetX", "offsetY", "viewportScaleX", "viewportScaleY", "scaleMode", "_cameras", "interactiveCamera", "interactive", "eventListeners", "ctx", "window", "events", "shapePoint"]
    _hx_methods = ["get_defaultSmooth", "set_defaultSmooth", "setEvents", "get_zoom", "set_zoom", "set_scaleMode", "get_renderer", "set_renderer", "get_camera", "get_cameras", "set_interactiveCamera", "addCamera", "removeCamera", "setFixedSize", "checkResize", "screenXToViewport", "screenYToViewport", "get_mouseX", "get_mouseY", "dispatchListeners", "isInteractiveVisible", "getInteractive", "screenToViewport", "dispatchEvent", "handleEvent", "addEventListener", "removeEventListener", "startCapture", "stopCapture", "startDrag", "stopDrag", "getFocus", "addEventTarget", "removeEventTarget", "dispose", "setElapsedTime", "drawImplTo", "syncOnly", "render", "sync", "clipBounds", "drawContent", "onAdd", "onRemove", "captureBitmap"]
    _hx_statics = []
    _hx_interfaces = [hxd_InteractiveScene, h3d_IDrawable]
    _hx_super = h2d_Layers


    def __init__(self):
        self.shapePoint = None
        self.events = None
        self.window = None
        self.ctx = None
        self.eventListeners = None
        self.interactive = None
        self.interactiveCamera = None
        self._cameras = None
        self.mouseY = None
        self.mouseX = None
        self.viewportScaleY = None
        self.viewportScaleX = None
        self.offsetY = None
        self.offsetX = None
        self.viewportY = None
        self.viewportX = None
        self.viewportD = None
        self.viewportA = None
        self.height = None
        self.width = None
        self.scaleMode = h2d_ScaleMode.Resize
        super().__init__(None)
        e = h3d_Engine.CURRENT
        self.ctx = h2d_RenderContext(self)
        self._cameras = []
        h2d_Camera(self)
        self.set_interactiveCamera((self._cameras[0] if 0 < len(self._cameras) else None))
        self.width = e.width
        self.height = e.height
        self.viewportA = (2 / e.width)
        self.viewportD = (2 / e.height)
        self.viewportX = -1
        self.viewportY = -1
        self.viewportScaleX = 1
        self.viewportScaleY = 1
        self.offsetX = 0
        self.offsetY = 0
        self.interactive = list()
        self.eventListeners = list()
        self.shapePoint = h2d_col_Point()
        self.window = hxd_Window.getInstance()
        self.posChanged = True

    def get_defaultSmooth(self):
        return self.ctx.defaultSmooth

    def set_defaultSmooth(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.ctx.defaultSmooth = v
                return self.ctx.defaultSmooth
            return _hx_local_0()
        return _hx_local_1()

    def setEvents(self,events):
        self.events = events

    def get_zoom(self):
        _g = self.scaleMode
        if (_g.index == 4):
            level = _g.params[0]
            tmp = None
            try:
                tmp = int(level)
            except BaseException as _g:
                None
                tmp = None
            return tmp
        else:
            return 0

    def set_zoom(self,v):
        self.set_scaleMode(h2d_ScaleMode.Zoom(v))
        return v

    def set_scaleMode(self,v):
        self.scaleMode = v
        self.checkResize()
        return v

    def get_renderer(self):
        return self.ctx

    def set_renderer(self,v):
        self.ctx = v
        return v

    def get_camera(self):
        return (self._cameras[0] if 0 < len(self._cameras) else None)

    def get_cameras(self):
        return self._cameras

    def set_interactiveCamera(self,cam):
        if (cam is None):
            raise haxe_Exception.thrown("Interactive cammera cannot be null!")
        if (cam.scene != self):
            self.addCamera(cam)
        def _hx_local_1():
            def _hx_local_0():
                self.interactiveCamera = cam
                return self.interactiveCamera
            return _hx_local_0()
        return _hx_local_1()

    def addCamera(self,cam,pos = None):
        if (cam.scene is not None):
            cam.scene.removeCamera(cam)
        cam.scene = self
        cam.posChanged = True
        if (pos is not None):
            self._cameras.insert(pos, cam)
        else:
            _this = self._cameras
            _this.append(cam)

    def removeCamera(self,cam):
        if (cam == self.interactiveCamera):
            raise haxe_Exception.thrown("Current interactive Camera cannot be removed from camera list!")
        cam.scene = None
        python_internal_ArrayImpl.remove(self._cameras,cam)

    def setFixedSize(self,w,h):
        self.set_scaleMode(h2d_ScaleMode.Stretch(w,h))

    def checkResize(self):
        _gthis = self
        engine = h3d_Engine.CURRENT
        _g = self.scaleMode
        tmp = _g.index
        if (tmp == 0):
            w = engine.width
            h = engine.height
            if ((w != _gthis.width) or ((h != _gthis.height))):
                _gthis.width = w
                _gthis.height = h
                _gthis.posChanged = True
            _gthis.viewportScaleX = 1
            _gthis.viewportScaleY = 1
            _gthis.viewportA = (2 / _gthis.width)
            _gthis.viewportD = (2 / _gthis.height)
            _gthis.viewportX = -1
            _gthis.viewportY = -1
        elif (tmp == 1):
            _width = _g.params[0]
            _height = _g.params[1]
            if ((_width != _gthis.width) or ((_height != _gthis.height))):
                _gthis.width = _width
                _gthis.height = _height
                _gthis.posChanged = True
            _gthis.viewportScaleX = (engine.width / _width)
            _gthis.viewportScaleY = (engine.height / _height)
            _gthis.viewportA = (2 / _gthis.width)
            _gthis.viewportD = (2 / _gthis.height)
            _gthis.viewportX = -1
            _gthis.viewportY = -1
        elif (tmp == 2):
            _width = _g.params[0]
            _height = _g.params[1]
            integerScale = _g.params[2]
            horizontalAlign = _g.params[3]
            verticalAlign = _g.params[4]
            if ((_width != _gthis.width) or ((_height != _gthis.height))):
                _gthis.width = _width
                _gthis.height = _height
                _gthis.posChanged = True
            a = (engine.width / _width)
            b = (engine.height / _height)
            zoom = (b if ((a > b)) else a)
            if integerScale:
                zoom1 = None
                try:
                    zoom1 = int(zoom)
                except BaseException as _g1:
                    None
                    zoom1 = None
                zoom = zoom1
                if (zoom == 0):
                    zoom = 1
            horizontal = horizontalAlign
            vertical = verticalAlign
            _gthis.viewportA = ((zoom * 2) / engine.width)
            _gthis.viewportD = ((zoom * 2) / engine.height)
            _gthis.viewportScaleX = zoom
            _gthis.viewportScaleY = zoom
            if (horizontal is None):
                horizontal = h2d_ScaleModeAlign.Center
            tmp = horizontal.index
            if (tmp == 0):
                _gthis.viewportX = -1
                _gthis.offsetX = 0
            elif (tmp == 1):
                _gthis.viewportX = (1 - ((_gthis.width * _gthis.viewportA)))
                _gthis.offsetX = (engine.width - ((_gthis.width * zoom)))
            else:
                _gthis.viewportX = ((Math.floor((((engine.width - ((_gthis.width * zoom)))) / ((zoom * 2)))) * _gthis.viewportA) - 1.)
                _gthis.offsetX = Math.floor((((engine.width - ((_gthis.width * zoom)))) / 2))
            if (vertical is None):
                vertical = h2d_ScaleModeAlign.Center
            tmp = vertical.index
            if (tmp == 3):
                _gthis.viewportY = -1
                _gthis.offsetY = 0
            elif (tmp == 4):
                _gthis.viewportY = (1 - ((_gthis.height * _gthis.viewportD)))
                _gthis.offsetY = (engine.height - ((_gthis.height * zoom)))
            else:
                _gthis.viewportY = ((Math.floor((((engine.height - ((_gthis.height * zoom)))) / ((zoom * 2)))) * _gthis.viewportD) - 1.)
                _gthis.offsetY = Math.floor((((engine.height - ((_gthis.height * zoom)))) / 2))
        elif (tmp == 3):
            _width = _g.params[0]
            _height = _g.params[1]
            zoom = _g.params[2]
            horizontalAlign = _g.params[3]
            verticalAlign = _g.params[4]
            if ((_width != _gthis.width) or ((_height != _gthis.height))):
                _gthis.width = _width
                _gthis.height = _height
                _gthis.posChanged = True
            horizontal = horizontalAlign
            vertical = verticalAlign
            _gthis.viewportA = ((zoom * 2) / engine.width)
            _gthis.viewportD = ((zoom * 2) / engine.height)
            _gthis.viewportScaleX = zoom
            _gthis.viewportScaleY = zoom
            if (horizontal is None):
                horizontal = h2d_ScaleModeAlign.Center
            tmp = horizontal.index
            if (tmp == 0):
                _gthis.viewportX = -1
                _gthis.offsetX = 0
            elif (tmp == 1):
                _gthis.viewportX = (1 - ((_gthis.width * _gthis.viewportA)))
                _gthis.offsetX = (engine.width - ((_gthis.width * zoom)))
            else:
                _gthis.viewportX = ((Math.floor((((engine.width - ((_gthis.width * zoom)))) / ((zoom * 2)))) * _gthis.viewportA) - 1.)
                _gthis.offsetX = Math.floor((((engine.width - ((_gthis.width * zoom)))) / 2))
            if (vertical is None):
                vertical = h2d_ScaleModeAlign.Center
            tmp = vertical.index
            if (tmp == 3):
                _gthis.viewportY = -1
                _gthis.offsetY = 0
            elif (tmp == 4):
                _gthis.viewportY = (1 - ((_gthis.height * _gthis.viewportD)))
                _gthis.offsetY = (engine.height - ((_gthis.height * zoom)))
            else:
                _gthis.viewportY = ((Math.floor((((engine.height - ((_gthis.height * zoom)))) / ((zoom * 2)))) * _gthis.viewportD) - 1.)
                _gthis.offsetY = Math.floor((((engine.height - ((_gthis.height * zoom)))) / 2))
        elif (tmp == 4):
            level = _g.params[0]
            w = Math.ceil((engine.width / level))
            h = Math.ceil((engine.height / level))
            if ((w != _gthis.width) or ((h != _gthis.height))):
                _gthis.width = w
                _gthis.height = h
                _gthis.posChanged = True
            _gthis.viewportScaleX = level
            _gthis.viewportScaleY = level
            _gthis.viewportA = (2 / _gthis.width)
            _gthis.viewportD = (2 / _gthis.height)
            _gthis.viewportX = -1
            _gthis.viewportY = -1
        elif (tmp == 5):
            minWidth = _g.params[0]
            minHeight = _g.params[1]
            integerScaling = _g.params[2]
            a = (engine.width / minWidth)
            b = (engine.height / minHeight)
            zoom = (b if ((a > b)) else a)
            if integerScaling:
                zoom1 = None
                try:
                    zoom1 = int(zoom)
                except BaseException as _g:
                    None
                    zoom1 = None
                zoom = zoom1
                if (zoom == 0):
                    zoom = 1
            w = Math.ceil((engine.width / zoom))
            h = Math.ceil((engine.height / zoom))
            if ((w != _gthis.width) or ((h != _gthis.height))):
                _gthis.width = w
                _gthis.height = h
                _gthis.posChanged = True
            _gthis.viewportScaleX = zoom
            _gthis.viewportScaleY = zoom
            _gthis.viewportA = (2 / _gthis.width)
            _gthis.viewportD = (2 / _gthis.height)
            _gthis.viewportX = -1
            _gthis.viewportY = -1
        else:
            pass

    def screenXToViewport(self,mx):
        _this = self.interactiveCamera
        mx = self.window.get_mouseX()
        my = self.window.get_mouseY()
        return (((((((((mx - _this.scene.offsetX)) / _this.scene.viewportScaleX) - _this.absX)) * _this.matD) - (((((((my - _this.scene.offsetY)) / _this.scene.viewportScaleY) - _this.absY)) * _this.matC)))) * _this.invDet)

    def screenYToViewport(self,my):
        _this = self.interactiveCamera
        mx = self.window.get_mouseX()
        my = self.window.get_mouseY()
        return ((((-(((((mx - _this.scene.offsetX)) / _this.scene.viewportScaleX) - _this.absX)) * _this.matB) + (((((((my - _this.scene.offsetY)) / _this.scene.viewportScaleY) - _this.absY)) * _this.matA)))) * _this.invDet)

    def get_mouseX(self):
        self.syncPos()
        mx = self.window.get_mouseX()
        _this = self.interactiveCamera
        mx = self.window.get_mouseX()
        my = self.window.get_mouseY()
        dx = ((((((((((mx - _this.scene.offsetX)) / _this.scene.viewportScaleX) - _this.absX)) * _this.matD) - (((((((my - _this.scene.offsetY)) / _this.scene.viewportScaleY) - _this.absY)) * _this.matC)))) * _this.invDet) - self.absX)
        if (self.matC == 0):
            return (dx / self.matA)
        my = self.window.get_mouseY()
        _this = self.interactiveCamera
        mx = self.window.get_mouseX()
        my = self.window.get_mouseY()
        dy = (((((-(((((mx - _this.scene.offsetX)) / _this.scene.viewportScaleX) - _this.absX)) * _this.matB) + (((((((my - _this.scene.offsetY)) / _this.scene.viewportScaleY) - _this.absY)) * _this.matA)))) * _this.invDet) - self.absY)
        return ((((dx * self.matD) - ((dy * self.matC)))) / (((self.matA * self.matD) - ((self.matB * self.matC)))))

    def get_mouseY(self):
        self.syncPos()
        my = self.window.get_mouseY()
        _this = self.interactiveCamera
        mx = self.window.get_mouseX()
        my = self.window.get_mouseY()
        dy = (((((-(((((mx - _this.scene.offsetX)) / _this.scene.viewportScaleX) - _this.absX)) * _this.matB) + (((((((my - _this.scene.offsetY)) / _this.scene.viewportScaleY) - _this.absY)) * _this.matA)))) * _this.invDet) - self.absY)
        if (self.matB == 0):
            return (dy / self.matD)
        mx = self.window.get_mouseX()
        _this = self.interactiveCamera
        mx = self.window.get_mouseX()
        my = self.window.get_mouseY()
        dx = ((((((((((mx - _this.scene.offsetX)) / _this.scene.viewportScaleX) - _this.absX)) * _this.matD) - (((((((my - _this.scene.offsetY)) / _this.scene.viewportScaleY) - _this.absY)) * _this.matC)))) * _this.invDet) - self.absX)
        return ((((dy * self.matA) - ((dx * self.matB)))) / (((self.matA * self.matD) - ((self.matB * self.matC)))))

    def dispatchListeners(self,event):
        self.screenToViewport(event)
        _g = 0
        _g1 = self.eventListeners
        while (_g < len(_g1)):
            l = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            l(event)
            if (not event.propagate):
                break

    def isInteractiveVisible(self,i):
        s = i
        while (s != self):
            if ((s is None) or (not s.visible)):
                return False
            s = s.parent
        return True

    def getInteractive(self,x,y):
        pt = self.shapePoint
        _g = 0
        _g1 = self.interactive
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if i.posChanged:
                i.syncPos()
            dx = (x - i.absX)
            dy = (y - i.absY)
            rx = ((((dx * i.matD) - ((dy * i.matC)))) * i.invDet)
            ry = ((((dy * i.matA) - ((dx * i.matB)))) * i.invDet)
            if (i.shape is not None):
                x1 = (rx + i.shapeX)
                y1 = (ry + i.shapeY)
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                pt.x = x1
                pt.y = y1
                if (not i.shape.contains(pt)):
                    continue
            elif ((((ry < 0) or ((rx < 0))) or ((rx >= i.width))) or ((ry >= i.height))):
                continue
            visible = True
            p = i
            while (p is not None):
                if (not p.visible):
                    visible = False
                    break
                p = p.parent
            if (not visible):
                continue
            return i
        return None

    def screenToViewport(self,e):
        self.interactiveCamera.eventToCamera(e)

    def dispatchEvent(self,event,to):
        i = to
        self.screenToViewport(event)
        dx = (event.relX - i.absX)
        dy = (event.relY - i.absY)
        rx = ((((dx * i.matD) - ((dy * i.matC)))) * i.invDet)
        ry = ((((dy * i.matA) - ((dx * i.matB)))) * i.invDet)
        event.relX = rx
        event.relY = ry
        i.handleEvent(event)

    def handleEvent(self,event,last):
        self.screenToViewport(event)
        ex = event.relX
        ey = event.relY
        index = (0 if ((last is None)) else (python_internal_ArrayImpl.indexOf(self.interactive,last,None) + 1))
        pt = self.shapePoint
        _g = index
        _g1 = len(self.interactive)
        while (_g < _g1):
            idx = _g
            _g = (_g + 1)
            i = (self.interactive[idx] if idx >= 0 and idx < len(self.interactive) else None)
            if (i is None):
                break
            if (i.invDet == 0):
                continue
            dx = (ex - i.absX)
            dy = (ey - i.absY)
            rx = ((((dx * i.matD) - ((dy * i.matC)))) * i.invDet)
            ry = ((((dy * i.matA) - ((dx * i.matB)))) * i.invDet)
            if (i.shape is not None):
                x = (rx + i.shapeX)
                y = (ry + i.shapeY)
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                pt.x = x
                pt.y = y
                if (not i.shape.contains(pt)):
                    continue
            elif ((((ry < 0) or ((rx < 0))) or ((rx >= i.width))) or ((ry >= i.height))):
                continue
            visible = True
            p = i
            while (p is not None):
                if (not p.visible):
                    visible = False
                    break
                p = p.parent
            if (not visible):
                continue
            event.relX = rx
            event.relY = ry
            i.handleEvent(event)
            if event.cancel:
                event.cancel = False
                event.propagate = False
                continue
            return i
        return None

    def addEventListener(self,f):
        _this = self.eventListeners
        _this.append(f)

    def removeEventListener(self,f):
        _g = 0
        _g1 = self.eventListeners
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if Reflect.compareMethods(e,f):
                python_internal_ArrayImpl.remove(self.eventListeners,e)
                return True
        return False

    def startCapture(self,onEvent,onCancel = None,touchId = None):
        _gthis = self
        def _hx_local_0(e):
            _gthis.screenToViewport(e)
            onEvent(e)
        self.events.startCapture(_hx_local_0,onCancel,touchId)

    def stopCapture(self):
        self.events.stopCapture()

    def startDrag(self,onEvent,onCancel = None,refEvent = None):
        self.startCapture(onEvent,onCancel,(refEvent.touchId if ((refEvent is not None)) else None))

    def stopDrag(self):
        self.stopCapture()

    def getFocus(self):
        if (self.events is None):
            return None
        f = self.events.getFocus()
        if (f is None):
            return None
        i = Std.downcast(f,h2d_Interactive)
        if (i is None):
            return None
        return python_internal_ArrayImpl._get(self.interactive, python_internal_ArrayImpl.indexOf(self.interactive,i,None))

    def addEventTarget(self,i):
        i1 = i
        lv = 0
        while (i1 is not None):
            i1 = i1.parent
            lv = (lv + 1)
        level = lv
        _g = 0
        _g1 = len(self.interactive)
        while (_g < _g1):
            index = _g
            _g = (_g + 1)
            i1 = i
            i2 = (self.interactive[index] if index >= 0 and index < len(self.interactive) else None)
            lv1 = level
            i3 = i2
            lv = 0
            while (i3 is not None):
                i3 = i3.parent
                lv = (lv + 1)
            lv2 = lv
            p1 = i1
            p2 = i2
            while (lv1 > lv2):
                i1 = p1
                p1 = p1.parent
                lv1 = (lv1 - 1)
            while (lv2 > lv1):
                i2 = p2
                p2 = p2.parent
                lv2 = (lv2 - 1)
            while (p1 != p2):
                i1 = p1
                p1 = p1.parent
                i2 = p2
                p2 = p2.parent
            id = -1
            _g2 = 0
            _g3 = len(p1.children)
            while (_g2 < _g3):
                k = _g2
                _g2 = (_g2 + 1)
                if ((p1.children[k] if k >= 0 and k < len(p1.children) else None) == i1):
                    id = k
                    break
            tmp = id
            id1 = -1
            _g4 = 0
            _g5 = len(p2.children)
            while (_g4 < _g5):
                k1 = _g4
                _g4 = (_g4 + 1)
                if ((p2.children[k1] if k1 >= 0 and k1 < len(p2.children) else None) == i2):
                    id1 = k1
                    break
            if (tmp > id1):
                self.interactive.insert(index, i)
                return
        _this = self.interactive
        _this.append(i)

    def removeEventTarget(self,i,notify = None):
        if (notify is None):
            notify = False
        python_internal_ArrayImpl.remove(self.interactive,i)
        if (notify and ((self.events is not None))):
            self.events.onRemove(i)

    def dispose(self):
        if self.allocated:
            self.onRemove()
        self.ctx.dispose()

    def setElapsedTime(self,v):
        self.ctx.elapsedTime = v

    def drawImplTo(self,s,texs,outputs = None):
        _g = 0
        while (_g < len(texs)):
            t = (texs[_g] if _g >= 0 and _g < len(texs) else None)
            _g = (_g + 1)
            if (((t.flags & ((1 << h3d_mat_TextureFlags.Target.index)))) == 0):
                raise haxe_Exception.thrown("Can only draw to texture created with Target flag")
        self.ctx.engine = h3d_Engine.CURRENT
        oldBG = self.ctx.engine.backgroundColor
        self.ctx.engine.backgroundColor = None
        if (not self.ctx.engine.inRender):
            self.ctx.begin()
        self.ctx.globalAlpha = self.alpha
        self.ctx.begin()
        self.ctx.pushTargets(texs)
        if (outputs is not None):
            self.ctx.manager.setOutput(outputs)
        s.drawRec(self.ctx)
        if (outputs is not None):
            self.ctx.manager.setOutput()
        self.ctx.popTarget()
        self.ctx.engine.backgroundColor = oldBG

    def syncOnly(self,et):
        engine = h3d_Engine.CURRENT
        self.setElapsedTime(et)
        self.ctx.engine = engine
        _hx_local_0 = self.ctx
        _hx_local_1 = _hx_local_0.frame
        _hx_local_0.frame = (_hx_local_1 + 1)
        _hx_local_1
        _hx_local_2 = self.ctx
        _hx_local_3 = _hx_local_2.time
        _hx_local_2.time = (_hx_local_3 + self.ctx.elapsedTime)
        _hx_local_2.time
        self.ctx.globalAlpha = self.alpha
        self.sync(self.ctx)

    def render(self,engine):
        self.ctx.engine = engine
        _hx_local_0 = self.ctx
        _hx_local_1 = _hx_local_0.frame
        _hx_local_0.frame = (_hx_local_1 + 1)
        _hx_local_1
        _hx_local_2 = self.ctx
        _hx_local_3 = _hx_local_2.time
        _hx_local_2.time = (_hx_local_3 + self.ctx.elapsedTime)
        _hx_local_2.time
        self.ctx.globalAlpha = self.alpha
        self.sync(self.ctx)
        if (len(self.children) == 0):
            return
        self.ctx.begin()
        self.ctx.drawScene()
        self.ctx.end()

    def sync(self,ctx):
        forceCamSync = self.posChanged
        if (not self.allocated):
            self.onAdd()
        super().sync(ctx)
        _g = 0
        _g1 = self._cameras
        while (_g < len(_g1)):
            cam = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            cam.sync(ctx,forceCamSync)

    def clipBounds(self,ctx,bounds):
        _gthis = self
        if (self.rotation == 0):
            x = -self.absX
            y = -self.absY
            if (x < bounds.xMin):
                bounds.xMin = x
            if (x > bounds.xMax):
                bounds.xMax = x
            if (y < bounds.yMin):
                bounds.yMin = y
            if (y > bounds.yMax):
                bounds.yMax = y
            x = ((self.window.get_width() / self.matA) - self.absX)
            y = ((self.window.get_height() / self.matD) - self.absY)
            if (x < bounds.xMin):
                bounds.xMin = x
            if (x > bounds.xMax):
                bounds.xMax = x
            if (y < bounds.yMin):
                bounds.yMin = y
            if (y > bounds.yMax):
                bounds.yMax = y
        else:
            ww = ((self.window.get_width() / self.matA) - self.absX)
            wh = ((self.window.get_height() / self.matD) - self.absY)
            x = -self.absX
            y = -self.absY
            x1 = ((x * _gthis.matA) + ((y * _gthis.matC)))
            y1 = ((x * _gthis.matB) + ((y * _gthis.matD)))
            if (x1 < bounds.xMin):
                bounds.xMin = x1
            if (x1 > bounds.xMax):
                bounds.xMax = x1
            if (y1 < bounds.yMin):
                bounds.yMin = y1
            if (y1 > bounds.yMax):
                bounds.yMax = y1
            x = (ww - self.absX)
            y = -self.absY
            x1 = ((x * _gthis.matA) + ((y * _gthis.matC)))
            y1 = ((x * _gthis.matB) + ((y * _gthis.matD)))
            if (x1 < bounds.xMin):
                bounds.xMin = x1
            if (x1 > bounds.xMax):
                bounds.xMax = x1
            if (y1 < bounds.yMin):
                bounds.yMin = y1
            if (y1 > bounds.yMax):
                bounds.yMax = y1
            x = -self.absX
            y = (wh - self.absY)
            x1 = ((x * _gthis.matA) + ((y * _gthis.matC)))
            y1 = ((x * _gthis.matB) + ((y * _gthis.matD)))
            if (x1 < bounds.xMin):
                bounds.xMin = x1
            if (x1 > bounds.xMax):
                bounds.xMax = x1
            if (y1 < bounds.yMin):
                bounds.yMin = y1
            if (y1 > bounds.yMax):
                bounds.yMax = y1
            x = (ww - self.absX)
            y = (wh - self.absY)
            x1 = ((x * _gthis.matA) + ((y * _gthis.matC)))
            y1 = ((x * _gthis.matB) + ((y * _gthis.matD)))
            if (x1 < bounds.xMin):
                bounds.xMin = x1
            if (x1 > bounds.xMax):
                bounds.xMax = x1
            if (y1 < bounds.yMin):
                bounds.yMin = y1
            if (y1 > bounds.yMax):
                bounds.yMax = y1
        super().clipBounds(ctx,bounds)

    def drawContent(self,ctx):
        if ctx.front2back:
            _g = 0
            _g1 = self._cameras
            while (_g < len(_g1)):
                cam = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (not cam.visible):
                    continue
                i = len(self.children)
                l = self.layerCount
                cam.enter(ctx)
                while True:
                    tmp = l
                    l = (l - 1)
                    if (not ((tmp > 0))):
                        break
                    top = (0 if ((l == 0)) else python_internal_ArrayImpl._get(self.layersIndexes, (l - 1)))
                    if cam.layerVisible(l):
                        while (i >= top):
                            tmp1 = i
                            i = (i - 1)
                            (self.children[tmp1] if tmp1 >= 0 and tmp1 < len(self.children) else None).drawRec(ctx)
                    else:
                        i = (top - 1)
                cam.exit(ctx)
            self.draw(ctx)
        else:
            self.draw(ctx)
            _g = 0
            _g1 = self._cameras
            while (_g < len(_g1)):
                cam = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (not cam.visible):
                    continue
                i = 0
                l = 0
                cam.enter(ctx)
                while (l < self.layerCount):
                    top = l
                    l = (l + 1)
                    top1 = (self.layersIndexes[top] if top >= 0 and top < len(self.layersIndexes) else None)
                    if cam.layerVisible((l - 1)):
                        while (i < top1):
                            tmp = i
                            i = (i + 1)
                            (self.children[tmp] if tmp >= 0 and tmp < len(self.children) else None).drawRec(ctx)
                    else:
                        i = top1
                cam.exit(ctx)

    def onAdd(self):
        self.checkResize()
        super().onAdd()
        self.window.addResizeEvent(self.checkResize)

    def onRemove(self):
        super().onRemove()
        self.window.removeResizeEvent(self.checkResize)

    def captureBitmap(self,target = None):
        engine = h3d_Engine.CURRENT
        if (target is None):
            tex = h3d_mat_Texture(self.width,self.height,[h3d_mat_TextureFlags.Target])
            target = h2d_Tile(tex,0,0,self.width,self.height)
        engine.begin()
        x = target.x
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        x = target.y
        tmp1 = None
        try:
            tmp1 = int(x)
        except BaseException as _g:
            None
            tmp1 = None
        engine.setRenderZone(tmp,tmp1,Math.ceil(target.width),Math.ceil(target.height))
        tex = target.innerTex
        engine.pushTarget(tex)
        ow = self.width
        oh = self.height
        ova = self.viewportA
        ovd = self.viewportD
        ovx = self.viewportX
        ovy = self.viewportY
        self.width = tex.width
        self.height = tex.height
        self.viewportA = (2 / self.width)
        self.viewportD = (2 / self.height)
        self.viewportX = -1
        self.viewportY = -1
        self.posChanged = True
        self.render(engine)
        engine.popTarget()
        self.width = ow
        self.height = oh
        self.viewportA = ova
        self.viewportD = ovd
        self.viewportX = ovx
        self.viewportY = ovy
        self.posChanged = True
        engine.setRenderZone()
        engine.end()
        return h2d_Bitmap(target)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.viewportA = None
        _hx_o.viewportD = None
        _hx_o.viewportX = None
        _hx_o.viewportY = None
        _hx_o.offsetX = None
        _hx_o.offsetY = None
        _hx_o.viewportScaleX = None
        _hx_o.viewportScaleY = None
        _hx_o.scaleMode = None
        _hx_o._cameras = None
        _hx_o.interactiveCamera = None
        _hx_o.interactive = None
        _hx_o.eventListeners = None
        _hx_o.ctx = None
        _hx_o.window = None
        _hx_o.events = None
        _hx_o.shapePoint = None
h2d_Scene._hx_class = h2d_Scene
_hx_classes["h2d.Scene"] = h2d_Scene

class h2d_Align(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.Align"
    _hx_constructs = ["Left", "Right", "Center", "MultilineRight", "MultilineCenter"]
h2d_Align.Left = h2d_Align("Left", 0, ())
h2d_Align.Right = h2d_Align("Right", 1, ())
h2d_Align.Center = h2d_Align("Center", 2, ())
h2d_Align.MultilineRight = h2d_Align("MultilineRight", 3, ())
h2d_Align.MultilineCenter = h2d_Align("MultilineCenter", 4, ())
h2d_Align._hx_class = h2d_Align
_hx_classes["h2d.Align"] = h2d_Align


class h2d_Text(h2d_Drawable):
    _hx_class_name = "h2d.Text"
    _hx_is_interface = "False"
    __slots__ = ("font", "text", "textColor", "maxWidth", "dropShadow", "textWidth", "textHeight", "textAlign", "letterSpacing", "lineSpacing", "glyphs", "needsRebuild", "currentText", "textChanged", "calcDone", "calcXMin", "calcYMin", "calcWidth", "calcHeight", "calcSizeHeight", "constraintWidth", "realMaxWidth", "sdfShader")
    _hx_fields = ["font", "text", "textColor", "maxWidth", "dropShadow", "textAlign", "letterSpacing", "lineSpacing", "glyphs", "needsRebuild", "currentText", "textChanged", "calcDone", "calcXMin", "calcYMin", "calcWidth", "calcHeight", "calcSizeHeight", "constraintWidth", "realMaxWidth", "sdfShader"]
    _hx_methods = ["set_font", "set_textAlign", "set_letterSpacing", "set_lineSpacing", "constraintSize", "onAdd", "checkText", "sync", "draw", "set_text", "validateText", "rebuild", "calcTextWidth", "splitText", "splitRawText", "getTextProgress", "initGlyphs", "updateSize", "get_textHeight", "get_textWidth", "set_maxWidth", "updateConstraint", "set_textColor", "getBoundsRec"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Drawable


    def __init__(self,font,parent = None):
        self.sdfShader = None
        self.calcSizeHeight = None
        self.calcHeight = None
        self.calcWidth = None
        self.calcYMin = None
        self.calcXMin = None
        self.calcDone = None
        self.textChanged = None
        self.currentText = None
        self.needsRebuild = None
        self.glyphs = None
        self.textAlign = None
        self.textHeight = None
        self.textWidth = None
        self.dropShadow = None
        self.maxWidth = None
        self.textColor = None
        self.text = None
        self.font = None
        self.realMaxWidth = -1
        self.constraintWidth = -1
        self.lineSpacing = 0
        self.letterSpacing = 0
        super().__init__(parent)
        self.set_font(font)
        self.set_textAlign(h2d_Align.Left)
        self.set_text("")
        self.currentText = ""
        self.set_textColor(16777215)

    def set_font(self,font):
        if (self.font == font):
            return font
        self.font = font
        if (font is not None):
            _g = font.type
            tmp = _g.index
            if (tmp == 0):
                if (self.sdfShader is not None):
                    self.removeShader(self.sdfShader)
                    self.sdfShader = None
            elif (tmp == 1):
                channel = _g.params[0]
                alphaCutoff = _g.params[1]
                smoothing = _g.params[2]
                if (self.sdfShader is None):
                    self.sdfShader = h3d_shader_SignedDistanceField()
                    self.addShader(self.sdfShader)
                self.sdfShader.alphaCutoff__ = alphaCutoff
                self.sdfShader.smoothing__ = smoothing
                _this = self.sdfShader
                _this.constModified = True
                _this.channel__ = channel
            else:
                pass
        if (self.glyphs is not None):
            _this = self.glyphs
            if ((_this is not None) and ((_this.parent is not None))):
                _this.parent.removeChild(_this)
        self.glyphs = h2d_TileGroup((None if ((font is None)) else font.tile),self)
        self.glyphs.set_visible(False)
        self.rebuild()
        return font

    def set_textAlign(self,a):
        if (self.textAlign == a):
            return a
        self.textAlign = a
        self.rebuild()
        return a

    def set_letterSpacing(self,s):
        if (self.letterSpacing == s):
            return s
        self.letterSpacing = s
        self.rebuild()
        return s

    def set_lineSpacing(self,s):
        if (self.lineSpacing == s):
            return s
        self.lineSpacing = s
        self.rebuild()
        return s

    def constraintSize(self,width,height):
        self.constraintWidth = width
        self.updateConstraint()

    def onAdd(self):
        super().onAdd()
        self.rebuild()

    def checkText(self):
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True

    def sync(self,ctx):
        super().sync(ctx)
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True
        if self.needsRebuild:
            self.initGlyphs(self.currentText)

    def draw(self,ctx):
        if (self.glyphs is None):
            self.emitTile(ctx,h2d_Tile.fromColor(16711935,16,16))
            return
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True
        if self.needsRebuild:
            self.initGlyphs(self.currentText)
        if (self.dropShadow is not None):
            oldX = self.absX
            oldY = self.absY
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.absX
            _hx_local_0.absX = (_hx_local_1 + (((self.dropShadow.dx * self.matA) + ((self.dropShadow.dy * self.matC)))))
            _hx_local_0.absX
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.absY
            _hx_local_2.absY = (_hx_local_3 + (((self.dropShadow.dx * self.matB) + ((self.dropShadow.dy * self.matD)))))
            _hx_local_2.absY
            oldR = self.color.x
            oldG = self.color.y
            oldB = self.color.z
            oldA = self.color.w
            _this = self.color
            c = self.dropShadow.color
            _this.x = ((((c >> 16) & 255)) / 255)
            _this.y = ((((c >> 8) & 255)) / 255)
            _this.z = (((c & 255)) / 255)
            _this.w = ((HxOverrides.rshift(c, 24)) / 255)
            self.color.w = (self.dropShadow.alpha * oldA)
            self.glyphs.drawWith(ctx,self)
            self.absX = oldX
            self.absY = oldY
            _this = self.color
            x = oldR
            y = oldG
            z = oldB
            w = oldA
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        self.glyphs.drawWith(ctx,self)

    def set_text(self,t):
        t1 = ("null" if ((t is None)) else t)
        if (t1 == self.text):
            return t1
        self.text = t1
        self.textChanged = True
        self.validateText()
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return t1

    def validateText(self):
        pass

    def rebuild(self):
        self.calcDone = False
        self.needsRebuild = True
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)

    def calcTextWidth(self,text):
        if self.calcDone:
            ow = self.calcWidth
            oh = self.calcHeight
            osh = self.calcSizeHeight
            ox = self.calcXMin
            oy = self.calcYMin
            self.initGlyphs(text,False)
            w = self.calcWidth
            self.calcWidth = ow
            self.calcHeight = oh
            self.calcSizeHeight = osh
            self.calcXMin = ox
            self.calcYMin = oy
            return w
        else:
            self.initGlyphs(text,False)
            self.calcDone = False
            return self.calcWidth

    def splitText(self,text):
        return self.splitRawText(text,0,0)

    def splitRawText(self,text,leftMargin = None,afterData = None,font = None,sizes = None,prevChar = None):
        if (leftMargin is None):
            leftMargin = 0.
        if (afterData is None):
            afterData = 0.
        if (prevChar is None):
            prevChar = -1
        maxWidth = self.realMaxWidth
        if (maxWidth < 0):
            if (sizes is None):
                return text
            else:
                maxWidth = Math.POSITIVE_INFINITY
        if (font is None):
            font = self.font
        lines = []
        restPos = 0
        x = leftMargin
        _g = 0
        _g1 = len(text)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            cc = HxString.charCodeAt(text,i)
            c = font.glyphs.h.get(cc,None)
            if (c is None):
                c = font.charset.resolveChar(cc,font.glyphs)
                if (c is None):
                    c = (font.nullChar if (((cc == 13) or ((cc == 10)))) else font.defaultChar)
            e = c
            newline = (cc == 10)
            esize = (e.width + e.getKerningOffset(prevChar))
            nc = HxString.charCodeAt(text,(i + 1))
            if (font.charset.isBreakChar(cc) and (((nc is None) or (not font.charset.isComplementChar(nc))))):
                if (((len(lines) == 0) and ((leftMargin > 0))) and ((x > maxWidth))):
                    lines.append("")
                    if (sizes is not None):
                        sizes.append(leftMargin)
                    x = (x - leftMargin)
                size = ((x + esize) + self.letterSpacing)
                k = (i + 1)
                _hx_max = len(text)
                prevChar1 = prevChar
                breakFound = False
                while ((size <= maxWidth) and ((k < _hx_max))):
                    index = k
                    k = (k + 1)
                    cc1 = HxString.charCodeAt(text,index)
                    if (font.charset.isSpace(cc1) or ((cc1 == 10))):
                        breakFound = True
                        break
                    c1 = font.glyphs.h.get(cc1,None)
                    if (c1 is None):
                        c1 = font.charset.resolveChar(cc1,font.glyphs)
                        if (c1 is None):
                            c1 = (font.nullChar if (((cc1 == 13) or ((cc1 == 10)))) else font.defaultChar)
                    e1 = c1
                    size = (size + (((e1.width + self.letterSpacing) + e1.getKerningOffset(prevChar1))))
                    prevChar1 = cc1
                    nc1 = HxString.charCodeAt(text,(k + 1))
                    if (font.charset.isBreakChar(cc1) and (((nc1 is None) or (not font.charset.isComplementChar(nc1))))):
                        break
                if ((size > maxWidth) or (((not breakFound) and (((size + afterData) > maxWidth))))):
                    newline = True
                    if font.charset.isSpace(cc):
                        x1 = HxString.substr(text,restPos,(i - restPos))
                        lines.append(x1)
                        e = None
                    else:
                        x2 = HxString.substr(text,restPos,((i + 1) - restPos))
                        lines.append(x2)
                    restPos = (i + 1)
            if ((e is not None) and ((cc != 10))):
                x = (x + ((esize + self.letterSpacing)))
            if newline:
                if (sizes is not None):
                    sizes.append(x)
                x = 0
                prevChar = -1
            else:
                prevChar = cc
        if (restPos < len(text)):
            if (((len(lines) == 0) and ((leftMargin > 0))) and ((((x + afterData) - self.letterSpacing) > maxWidth))):
                lines.append("")
                if (sizes is not None):
                    sizes.append(leftMargin)
                x = (x - leftMargin)
            x1 = HxString.substr(text,restPos,(len(text) - restPos))
            lines.append(x1)
            if (sizes is not None):
                sizes.append(x)
        return "\n".join([python_Boot.toString1(x1,'') for x1 in lines])

    def getTextProgress(self,text,progress):
        if (progress >= len(text)):
            return text
        _hx_len = None
        try:
            _hx_len = int(progress)
        except BaseException as _g:
            None
            _hx_len = None
        return HxString.substr(text,0,_hx_len)

    def initGlyphs(self,text,rebuild = None):
        if (rebuild is None):
            rebuild = True
        if rebuild:
            self.glyphs.clear()
        x = 0.
        y = 0.
        xMax = 0.
        xMin = 0.
        yMin = 0.
        prevChar = -1
        linei = 0
        align = self.textAlign
        lines = list()
        dl = (self.font.lineHeight + self.lineSpacing)
        t = self.splitRawText(text,0,0,None,lines)
        _g = 0
        while (_g < len(lines)):
            lw = (lines[_g] if _g >= 0 and _g < len(lines) else None)
            _g = (_g + 1)
            if (lw > x):
                x = lw
        self.calcWidth = x
        tmp = align.index
        if (tmp == 0):
            x = 0
        elif ((((tmp == 4) or ((tmp == 3))) or ((tmp == 2))) or ((tmp == 1))):
            _hx_max = (Math.ceil(self.calcWidth) if (((align == h2d_Align.MultilineCenter) or ((align == h2d_Align.MultilineRight)))) else (0 if ((self.realMaxWidth < 0)) else Math.ceil(self.realMaxWidth)))
            k = (0.5 if (((align == h2d_Align.Center) or ((align == h2d_Align.MultilineCenter)))) else 1)
            _g = 0
            _g1 = len(lines)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                v = (((_hx_max - (lines[i] if i >= 0 and i < len(lines) else None))) * k)
                python_internal_ArrayImpl._set(lines, i, (v if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v)) else Math.floor(v))))
            x = (lines[0] if 0 < len(lines) else None)
            xMin = x
        else:
            pass
        _g = 0
        _g1 = len(t)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            cc = HxString.charCodeAt(t,i)
            _this = self.font
            c = _this.glyphs.h.get(cc,None)
            if (c is None):
                c = _this.charset.resolveChar(cc,_this.glyphs)
                if (c is None):
                    c = (_this.nullChar if (((cc == 13) or ((cc == 10)))) else _this.defaultChar)
            e = c
            offs = e.getKerningOffset(prevChar)
            esize = (e.width + offs)
            if (cc == 10):
                if (x > xMax):
                    xMax = x
                tmp = align.index
                if (tmp == 0):
                    x = 0
                elif ((((tmp == 4) or ((tmp == 3))) or ((tmp == 2))) or ((tmp == 1))):
                    linei = (linei + 1)
                    x1 = linei
                    x = (lines[x1] if x1 >= 0 and x1 < len(lines) else None)
                    if (x < xMin):
                        xMin = x
                else:
                    pass
                y = (y + dl)
                prevChar = -1
            else:
                if (e is not None):
                    if rebuild:
                        _this1 = self.glyphs
                        _this1.content.add((x + offs),y,_this1.curColor.x,_this1.curColor.y,_this1.curColor.z,_this1.curColor.w,e.t)
                    if ((y == 0) and ((e.t.dy < yMin))):
                        yMin = e.t.dy
                    x = (x + ((esize + self.letterSpacing)))
                prevChar = cc
        if (x > xMax):
            xMax = x
        self.calcXMin = xMin
        self.calcYMin = yMin
        self.calcWidth = (xMax - xMin)
        self.calcHeight = (y + self.font.lineHeight)
        self.calcSizeHeight = (y + ((self.font.baseLine if ((self.font.baseLine > 0)) else self.font.lineHeight)))
        self.calcDone = True
        if rebuild:
            self.needsRebuild = False

    def updateSize(self):
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True
        if (not self.calcDone):
            self.initGlyphs(self.text,self.needsRebuild)

    def get_textHeight(self):
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True
        if (not self.calcDone):
            self.initGlyphs(self.text,self.needsRebuild)
        return self.calcHeight

    def get_textWidth(self):
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True
        if (not self.calcDone):
            self.initGlyphs(self.text,self.needsRebuild)
        return self.calcWidth

    def set_maxWidth(self,w):
        if (self.maxWidth == w):
            return w
        self.maxWidth = w
        self.updateConstraint()
        return w

    def updateConstraint(self):
        old = self.realMaxWidth
        if (self.maxWidth is None):
            self.realMaxWidth = self.constraintWidth
        elif (self.constraintWidth < 0):
            self.realMaxWidth = self.maxWidth
        else:
            a = self.maxWidth
            b = self.constraintWidth
            self.realMaxWidth = (b if ((a > b)) else a)
        if (self.realMaxWidth != old):
            self.rebuild()

    def set_textColor(self,c):
        if (self.textColor == c):
            return c
        self.textColor = c
        a = self.color.w
        _this = self.color
        _this.x = ((((c >> 16) & 255)) / 255)
        _this.y = ((((c >> 8) & 255)) / 255)
        _this.z = (((c & 255)) / 255)
        _this.w = ((HxOverrides.rshift(c, 24)) / 255)
        self.color.w = a
        return c

    def getBoundsRec(self,relativeTo,out,forSize):
        super().getBoundsRec(relativeTo,out,forSize)
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True
        if (not self.calcDone):
            self.initGlyphs(self.text,self.needsRebuild)
        x = None
        y = None
        w = None
        h = None
        if forSize:
            x = self.calcXMin
            y = 0.
            w = self.calcWidth
            h = self.calcSizeHeight
        else:
            x = self.calcXMin
            y = self.calcYMin
            w = self.calcWidth
            h = (self.calcHeight - self.calcYMin)
        self.addBounds(relativeTo,out,x,y,w,h)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.font = None
        _hx_o.text = None
        _hx_o.textColor = None
        _hx_o.maxWidth = None
        _hx_o.dropShadow = None
        _hx_o.textAlign = None
        _hx_o.letterSpacing = None
        _hx_o.lineSpacing = None
        _hx_o.glyphs = None
        _hx_o.needsRebuild = None
        _hx_o.currentText = None
        _hx_o.textChanged = None
        _hx_o.calcDone = None
        _hx_o.calcXMin = None
        _hx_o.calcYMin = None
        _hx_o.calcWidth = None
        _hx_o.calcHeight = None
        _hx_o.calcSizeHeight = None
        _hx_o.constraintWidth = None
        _hx_o.realMaxWidth = None
        _hx_o.sdfShader = None
h2d_Text._hx_class = h2d_Text
_hx_classes["h2d.Text"] = h2d_Text


class h2d_Tile:
    _hx_class_name = "h2d.Tile"
    _hx_is_interface = "False"
    __slots__ = ("innerTex", "u", "v", "u2", "v2", "dx", "dy", "x", "y", "width", "height")
    _hx_fields = ["innerTex", "u", "v", "u2", "v2", "dx", "dy", "x", "y", "width", "height"]
    _hx_methods = ["get_ix", "get_iy", "get_iwidth", "get_iheight", "getTexture", "isDisposed", "setTexture", "switchTexture", "sub", "center", "setCenterRatio", "flipX", "flipY", "setPosition", "setSize", "scaleToSize", "scrollDiscrete", "dispose", "clone", "get_xFlip", "get_yFlip", "set_xFlip", "set_yFlip", "split", "gridFlatten", "grid", "toString", "upload"]
    _hx_statics = ["fromColor", "fromBitmap", "autoCut", "fromTexture", "fromPixels", "isEmpty"]

    def __init__(self,tex,x,y,w,h,dx = None,dy = None):
        if (dx is None):
            dx = 0
        if (dy is None):
            dy = 0
        self.v2 = None
        self.u2 = None
        self.v = None
        self.u = None
        self.innerTex = tex
        self.x = x
        self.y = y
        self.width = w
        self.height = h
        self.dx = dx
        self.dy = dy
        if (tex is not None):
            self.setTexture(tex)

    def get_ix(self):
        return Math.floor(self.x)

    def get_iy(self):
        return Math.floor(self.y)

    def get_iwidth(self):
        return (Math.ceil((self.width + self.x)) - Math.floor(self.x))

    def get_iheight(self):
        return (Math.ceil((self.height + self.y)) - Math.floor(self.y))

    def getTexture(self):
        return self.innerTex

    def isDisposed(self):
        if (self.innerTex is not None):
            _this = self.innerTex
            if (_this.t is None):
                return (_this.realloc is None)
            else:
                return False
        else:
            return True

    def setTexture(self,tex):
        self.innerTex = tex
        if (tex is not None):
            self.u = (self.x / tex.width)
            self.v = (self.y / tex.height)
            self.u2 = (((self.x + self.width)) / tex.width)
            self.v2 = (((self.y + self.height)) / tex.height)

    def switchTexture(self,t):
        self.setTexture(t.innerTex)

    def sub(self,x,y,w,h,dx = None,dy = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        return h2d_Tile(self.innerTex,(self.x + x),(self.y + y),w,h,dx,dy)

    def center(self):
        return self.sub(0,0,self.width,self.height,-((self.width * .5)),-((self.height * .5)))

    def setCenterRatio(self,px = None,py = None):
        if (px is None):
            px = 0.5
        if (py is None):
            py = 0.5
        self.dx = -((px * self.width))
        self.dy = -((py * self.height))

    def flipX(self):
        tmp = self.u
        self.u = self.u2
        self.u2 = tmp
        self.dx = (-self.dx - self.width)

    def flipY(self):
        tmp = self.v
        self.v = self.v2
        self.v2 = tmp
        self.dy = (-self.dy - self.height)

    def setPosition(self,x,y):
        self.x = x
        self.y = y
        tex = self.innerTex
        if (tex is not None):
            self.u = (x / tex.width)
            self.v = (y / tex.height)
            self.u2 = (((x + self.width)) / tex.width)
            self.v2 = (((y + self.height)) / tex.height)

    def setSize(self,w,h):
        self.width = w
        self.height = h
        tex = self.innerTex
        if (tex is not None):
            self.u2 = (((self.x + w)) / tex.width)
            self.v2 = (((self.y + h)) / tex.height)

    def scaleToSize(self,w,h):
        self.width = w
        self.height = h

    def scrollDiscrete(self,dx,dy):
        tex = self.innerTex
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.u
        _hx_local_0.u = (_hx_local_1 + ((dx / tex.width)))
        _hx_local_0.u
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.v
        _hx_local_2.v = (_hx_local_3 - ((dy / tex.height)))
        _hx_local_2.v
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.u2
        _hx_local_4.u2 = (_hx_local_5 + ((dx / tex.width)))
        _hx_local_4.u2
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.v2
        _hx_local_6.v2 = (_hx_local_7 - ((dy / tex.height)))
        _hx_local_6.v2
        self.x = (self.u * tex.width)
        self.y = (self.v * tex.height)

    def dispose(self):
        if (self.innerTex is not None):
            self.innerTex.dispose()
        self.innerTex = None

    def clone(self):
        t = h2d_Tile(None,self.x,self.y,self.width,self.height,self.dx,self.dy)
        t.innerTex = self.innerTex
        t.u = self.u
        t.u2 = self.u2
        t.v = self.v
        t.v2 = self.v2
        return t

    def get_xFlip(self):
        return (self.u2 < self.u)

    def get_yFlip(self):
        return (self.v2 < self.v)

    def set_xFlip(self,v):
        if (v != self.get_xFlip()):
            self.flipX()
        return v

    def set_yFlip(self,v):
        if (v != self.get_yFlip()):
            self.flipY()
        return v

    def split(self,frames = None,vertical = None,subpixel = None):
        if (frames is None):
            frames = 0
        if (vertical is None):
            vertical = False
        if (subpixel is None):
            subpixel = False
        tl = []
        if vertical:
            if (frames == 0):
                x = (self.height / self.width)
                try:
                    frames = int(x)
                except BaseException as _g:
                    None
                    frames = None
            stride = None
            if subpixel:
                stride = (self.height / frames)
            else:
                x = (self.height / frames)
                try:
                    stride = int(x)
                except BaseException as _g:
                    None
                    stride = None
            _g = 0
            _g1 = frames
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                x = self.sub(0,(i * stride),self.width,stride)
                tl.append(x)
        else:
            if (frames == 0):
                x = (self.width / self.height)
                try:
                    frames = int(x)
                except BaseException as _g:
                    None
                    frames = None
            stride = None
            if subpixel:
                stride = (self.width / frames)
            else:
                x = (self.width / frames)
                try:
                    stride = int(x)
                except BaseException as _g:
                    None
                    stride = None
            _g = 0
            _g1 = frames
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                x = self.sub((i * stride),0,stride,self.height)
                tl.append(x)
        return tl

    def gridFlatten(self,size,dx = None,dy = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        _g = []
        _g1 = 0
        x = (self.height / size)
        _g2 = None
        try:
            _g2 = int(x)
        except BaseException as _g3:
            None
            _g2 = None
        while (_g1 < _g2):
            y = _g1
            _g1 = (_g1 + 1)
            _g3 = 0
            x = (self.width / size)
            _g4 = None
            try:
                _g4 = int(x)
            except BaseException as _g5:
                None
                _g4 = None
            while (_g3 < _g4):
                x1 = _g3
                _g3 = (_g3 + 1)
                x2 = self.sub((x1 * size),(y * size),size,size,dx,dy)
                _g.append(x2)
        return _g

    def grid(self,size,dx = None,dy = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        _g = []
        _g1 = 0
        x = (self.width / size)
        _g2 = None
        try:
            _g2 = int(x)
        except BaseException as _g3:
            None
            _g2 = None
        while (_g1 < _g2):
            x = _g1
            _g1 = (_g1 + 1)
            _g3 = []
            _g4 = 0
            x1 = (self.height / size)
            _g5 = None
            try:
                _g5 = int(x1)
            except BaseException as _g6:
                None
                _g5 = None
            while (_g4 < _g5):
                y = _g4
                _g4 = (_g4 + 1)
                x2 = self.sub((x * size),(y * size),size,size,dx,dy)
                _g3.append(x2)
            _g.append(_g3)
        return _g

    def toString(self):
        return ((((((((("Tile(" + Std.string(self.x)) + ",") + Std.string(self.y)) + ",") + Std.string(self.width)) + "x") + Std.string(self.height)) + HxOverrides.stringOrNull(((((("," + Std.string(self.dx)) + ":") + Std.string(self.dy)) if (((self.dx != 0) or ((self.dy != 0)))) else "")))) + ")")

    def upload(self,bmp):
        w = self.innerTex.width
        h = self.innerTex.height
        self.innerTex.uploadBitmap(bmp)

    @staticmethod
    def fromColor(color,width = None,height = None,alpha = None):
        if (width is None):
            width = 1
        if (height is None):
            height = 1
        if (alpha is None):
            alpha = 1.
        t = h2d_Tile(h3d_mat_Texture.fromColor(color,alpha),0,0,1,1)
        t.width = width
        t.height = height
        return t

    @staticmethod
    def fromBitmap(bmp):
        tex = h3d_mat_Texture.fromBitmap(bmp)
        return h2d_Tile(tex,0,0,bmp.data.width,bmp.data.height)

    @staticmethod
    def autoCut(bmp,width,height = None):
        if (height is None):
            height = width
        colorBG = bmp.getPixel((bmp.data.width - 1),(bmp.data.height - 1))
        tl = list()
        w = 1
        h = 1
        while (w < bmp.data.width):
            w = (w << 1)
        while (h < bmp.data.height):
            h = (h << 1)
        tex = h3d_mat_Texture(w,h)
        _g = 0
        x = (bmp.data.height / height)
        _g1 = None
        try:
            _g1 = int(x)
        except BaseException as _g2:
            None
            _g1 = None
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            a = []
            python_internal_ArrayImpl._set(tl, y, a)
            _g2 = 0
            x = (bmp.data.width / width)
            _g3 = None
            try:
                _g3 = int(x)
            except BaseException as _g4:
                None
                _g3 = None
            while (_g2 < _g3):
                x1 = _g2
                _g2 = (_g2 + 1)
                sz = h2d_Tile.isEmpty(bmp,(x1 * width),(y * height),width,height,colorBG)
                if (sz is None):
                    break
                x2 = h2d_Tile(tex,((x1 * width) + sz.dx),((y * height) + sz.dy),sz.w,sz.h,sz.dx,sz.dy)
                a.append(x2)
        main = h2d_Tile(tex,0,0,bmp.data.width,bmp.data.height)
        main.upload(bmp)
        return _hx_AnonObject({'main': main, 'tiles': tl})

    @staticmethod
    def fromTexture(t):
        return h2d_Tile(t,0,0,t.width,t.height)

    @staticmethod
    def fromPixels(pixels):
        pix2 = pixels.makeSquare(True)
        t = h3d_mat_Texture.fromPixels(pix2)
        if (pix2 != pixels):
            pix2.dispose()
        return h2d_Tile(t,0,0,pixels.width,pixels.height)

    @staticmethod
    def isEmpty(b,px,py,width,height,bg):
        empty = True
        xmin = width
        ymin = height
        xmax = 0
        ymax = 0
        _g = 0
        _g1 = width
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = height
            while (_g2 < _g3):
                y = _g2
                _g2 = (_g2 + 1)
                color = b.getPixel((x + px),(y + py))
                if (((color & -16777216)) == 0):
                    if (color != 0):
                        b.setPixel((x + px),(y + py),0)
                    continue
                if (color != bg):
                    empty = False
                    if (x < xmin):
                        xmin = x
                    if (y < ymin):
                        ymin = y
                    if (x > xmax):
                        xmax = x
                    if (y > ymax):
                        ymax = y
                if ((color == bg) and ((color != 0))):
                    b.setPixel((x + px),(y + py),0)
        if empty:
            return None
        else:
            return _hx_AnonObject({'dx': xmin, 'dy': ymin, 'w': ((xmax - xmin) + 1), 'h': ((ymax - ymin) + 1)})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.innerTex = None
        _hx_o.u = None
        _hx_o.v = None
        _hx_o.u2 = None
        _hx_o.v2 = None
        _hx_o.dx = None
        _hx_o.dy = None
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.width = None
        _hx_o.height = None
h2d_Tile._hx_class = h2d_Tile
_hx_classes["h2d.Tile"] = h2d_Tile


class hxd_impl__Serializable_NoSerializeSupport:
    _hx_class_name = "hxd.impl._Serializable.NoSerializeSupport"
    _hx_is_interface = "True"
    __slots__ = ()
hxd_impl__Serializable_NoSerializeSupport._hx_class = hxd_impl__Serializable_NoSerializeSupport
_hx_classes["hxd.impl._Serializable.NoSerializeSupport"] = hxd_impl__Serializable_NoSerializeSupport


class h3d_prim_Primitive:
    _hx_class_name = "h3d.prim.Primitive"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "indexes", "refCount")
    _hx_fields = ["buffer", "indexes", "refCount"]
    _hx_methods = ["triCount", "vertexCount", "getCollider", "getBounds", "incref", "decref", "alloc", "selectMaterial", "buildNormalsDisplay", "render", "dispose", "toString"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self):
        self.indexes = None
        self.buffer = None
        self.refCount = 0

    def triCount(self):
        if (self.indexes is not None):
            x = (self.indexes.count / 3)
            try:
                return int(x)
            except BaseException as _g:
                None
                return None
        elif (self.buffer is None):
            return 0
        else:
            x = (self.buffer.totalVertices() / 3)
            try:
                return int(x)
            except BaseException as _g:
                None
                return None

    def vertexCount(self):
        return 0

    def getCollider(self):
        raise haxe_Exception.thrown(("not implemented for " + Std.string(self)))

    def getBounds(self):
        raise haxe_Exception.thrown(("not implemented for " + Std.string(self)))

    def incref(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.refCount
        _hx_local_0.refCount = (_hx_local_1 + 1)
        _hx_local_1

    def decref(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.refCount
        _hx_local_0.refCount = (_hx_local_1 - 1)
        _hx_local_1
        if (self.refCount <= 0):
            self.refCount = 0
            self.dispose()

    def alloc(self,engine):
        raise haxe_Exception.thrown("not implemented")

    def selectMaterial(self,material):
        pass

    def buildNormalsDisplay(self):
        raise haxe_Exception.thrown(("not implemented for " + Std.string(self)))

    def render(self,engine):
        tmp = None
        if (self.buffer is not None):
            _this = self.buffer
            tmp = ((_this.buffer is None) or ((_this.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            self.alloc(engine)
        if (self.indexes is None):
            if (((self.buffer.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0):
                engine.renderBuffer(self.buffer,engine.mem.quadIndexes,2,0,-1)
            else:
                engine.renderBuffer(self.buffer,engine.mem.triIndexes,3,0,-1)
        else:
            engine.renderIndexed(self.buffer,self.indexes)

    def dispose(self):
        if (self.buffer is not None):
            self.buffer.dispose()
            self.buffer = None
        if (self.indexes is not None):
            self.indexes.dispose()
            self.indexes = None

    def toString(self):
        _this = Type.getClassName(Type.getClass(self))
        _this1 = _this.split(".")
        return (None if ((len(_this1) == 0)) else _this1.pop())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.indexes = None
        _hx_o.refCount = None
h3d_prim_Primitive._hx_class = h3d_prim_Primitive
_hx_classes["h3d.prim.Primitive"] = h3d_prim_Primitive


class h2d_TileLayerContent(h3d_prim_Primitive):
    _hx_class_name = "h2d.TileLayerContent"
    _hx_is_interface = "False"
    __slots__ = ("tmp", "xMin", "yMin", "xMax", "yMax", "useAllocator", "state")
    _hx_fields = ["tmp", "xMin", "yMin", "xMax", "yMax", "useAllocator", "state"]
    _hx_methods = ["clear", "isEmpty", "triCount", "addColor", "add", "addTransform", "addPoint", "insertColor", "rectColor", "rectGradient", "fillArc", "fillCircle", "circle", "arc", "alloc", "dispose", "flush", "doRender"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self):
        self.state = None
        self.yMax = None
        self.xMax = None
        self.yMin = None
        self.xMin = None
        self.tmp = None
        self.useAllocator = False
        super().__init__()
        self.state = h2d_impl_BatchDrawState()
        self.clear()

    def clear(self):
        this1 = list()
        self.tmp = this1
        if (self.buffer is not None):
            if self.useAllocator:
                hxd_impl_Allocator.get().disposeBuffer(self.buffer)
            else:
                self.buffer.dispose()
        self.buffer = None
        self.xMin = Math.POSITIVE_INFINITY
        self.yMin = Math.POSITIVE_INFINITY
        self.xMax = Math.NEGATIVE_INFINITY
        self.yMax = Math.NEGATIVE_INFINITY
        self.state.clear()

    def isEmpty(self):
        return (self.triCount() == 0)

    def triCount(self):
        if (self.buffer is None):
            return (len(self.tmp) >> 4)
        else:
            return (self.buffer.totalVertices() >> 1)

    def addColor(self,x,y,color,t):
        self.add(x,y,color.x,color.y,color.z,color.w,t)

    def add(self,x,y,r,g,b,a,t):
        sx = (x + t.dx)
        sy = (y + t.dy)
        this1 = self.tmp
        this1.append(sx)
        this1 = self.tmp
        this1.append(sy)
        this1 = self.tmp
        v = t.u
        this1.append(v)
        this1 = self.tmp
        v = t.v
        this1.append(v)
        this1 = self.tmp
        this1.append(r)
        this1 = self.tmp
        this1.append(g)
        this1 = self.tmp
        this1.append(b)
        this1 = self.tmp
        this1.append(a)
        this1 = self.tmp
        v = (sx + t.width)
        this1.append(v)
        this1 = self.tmp
        this1.append(sy)
        this1 = self.tmp
        v = t.u2
        this1.append(v)
        this1 = self.tmp
        v = t.v
        this1.append(v)
        this1 = self.tmp
        this1.append(r)
        this1 = self.tmp
        this1.append(g)
        this1 = self.tmp
        this1.append(b)
        this1 = self.tmp
        this1.append(a)
        this1 = self.tmp
        this1.append(sx)
        this1 = self.tmp
        v = (sy + t.height)
        this1.append(v)
        this1 = self.tmp
        v = t.u
        this1.append(v)
        this1 = self.tmp
        v = t.v2
        this1.append(v)
        this1 = self.tmp
        this1.append(r)
        this1 = self.tmp
        this1.append(g)
        this1 = self.tmp
        this1.append(b)
        this1 = self.tmp
        this1.append(a)
        this1 = self.tmp
        v = (sx + t.width)
        this1.append(v)
        this1 = self.tmp
        v = (sy + t.height)
        this1.append(v)
        this1 = self.tmp
        v = t.u2
        this1.append(v)
        this1 = self.tmp
        v = t.v2
        this1.append(v)
        this1 = self.tmp
        this1.append(r)
        this1 = self.tmp
        this1.append(g)
        this1 = self.tmp
        this1.append(b)
        this1 = self.tmp
        this1.append(a)
        x1 = (x + t.dx)
        y1 = (y + t.dy)
        if (x1 < self.xMin):
            self.xMin = x1
        if (y1 < self.yMin):
            self.yMin = y1
        x1 = (x1 + t.width)
        y1 = (y1 + t.height)
        if (x1 > self.xMax):
            self.xMax = x1
        if (y1 > self.yMax):
            self.yMax = y1
        if (t is not None):
            self.state.setTexture(t.innerTex)
        _this = self.state
        _hx_local_2 = _this.tail
        _hx_local_3 = _hx_local_2.count
        _hx_local_2.count = (_hx_local_3 + 4)
        _hx_local_2.count
        _this.totalCount = (_this.totalCount + 4)

    def addTransform(self,x,y,sx,sy,r,c,t):
        _gthis = self
        ca = (Math.NaN if (((r == Math.POSITIVE_INFINITY) or ((r == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(r))
        sa = (Math.NaN if (((r == Math.POSITIVE_INFINITY) or ((r == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(r))
        hx = t.width
        hy = t.height
        dx = (t.dx * sx)
        dy = (t.dy * sy)
        px = (((dx * ca) - ((dy * sa))) + x)
        py = (((dy * ca) + ((dx * sa))) + y)
        this1 = self.tmp
        this1.append(px)
        this1 = self.tmp
        this1.append(py)
        this1 = self.tmp
        v = t.u
        this1.append(v)
        this1 = self.tmp
        v = t.v
        this1.append(v)
        this1 = self.tmp
        v = c.x
        this1.append(v)
        this1 = self.tmp
        v = c.y
        this1.append(v)
        this1 = self.tmp
        v = c.z
        this1.append(v)
        this1 = self.tmp
        v = c.w
        this1.append(v)
        if (px < _gthis.xMin):
            _gthis.xMin = px
        if (py < _gthis.yMin):
            _gthis.yMin = py
        if (px > _gthis.xMax):
            _gthis.xMax = px
        if (py > _gthis.yMax):
            _gthis.yMax = py
        dx = (((t.dx + hx)) * sx)
        dy = (t.dy * sy)
        px = (((dx * ca) - ((dy * sa))) + x)
        py = (((dy * ca) + ((dx * sa))) + y)
        this1 = self.tmp
        this1.append(px)
        this1 = self.tmp
        this1.append(py)
        this1 = self.tmp
        v = t.u2
        this1.append(v)
        this1 = self.tmp
        v = t.v
        this1.append(v)
        this1 = self.tmp
        v = c.x
        this1.append(v)
        this1 = self.tmp
        v = c.y
        this1.append(v)
        this1 = self.tmp
        v = c.z
        this1.append(v)
        this1 = self.tmp
        v = c.w
        this1.append(v)
        if (px < _gthis.xMin):
            _gthis.xMin = px
        if (py < _gthis.yMin):
            _gthis.yMin = py
        if (px > _gthis.xMax):
            _gthis.xMax = px
        if (py > _gthis.yMax):
            _gthis.yMax = py
        dx = (t.dx * sx)
        dy = (((t.dy + hy)) * sy)
        px = (((dx * ca) - ((dy * sa))) + x)
        py = (((dy * ca) + ((dx * sa))) + y)
        this1 = self.tmp
        this1.append(px)
        this1 = self.tmp
        this1.append(py)
        this1 = self.tmp
        v = t.u
        this1.append(v)
        this1 = self.tmp
        v = t.v2
        this1.append(v)
        this1 = self.tmp
        v = c.x
        this1.append(v)
        this1 = self.tmp
        v = c.y
        this1.append(v)
        this1 = self.tmp
        v = c.z
        this1.append(v)
        this1 = self.tmp
        v = c.w
        this1.append(v)
        if (px < _gthis.xMin):
            _gthis.xMin = px
        if (py < _gthis.yMin):
            _gthis.yMin = py
        if (px > _gthis.xMax):
            _gthis.xMax = px
        if (py > _gthis.yMax):
            _gthis.yMax = py
        dx = (((t.dx + hx)) * sx)
        dy = (((t.dy + hy)) * sy)
        px = (((dx * ca) - ((dy * sa))) + x)
        py = (((dy * ca) + ((dx * sa))) + y)
        this1 = self.tmp
        this1.append(px)
        this1 = self.tmp
        this1.append(py)
        this1 = self.tmp
        v = t.u2
        this1.append(v)
        this1 = self.tmp
        v = t.v2
        this1.append(v)
        this1 = self.tmp
        v = c.x
        this1.append(v)
        this1 = self.tmp
        v = c.y
        this1.append(v)
        this1 = self.tmp
        v = c.z
        this1.append(v)
        this1 = self.tmp
        v = c.w
        this1.append(v)
        if (px < _gthis.xMin):
            _gthis.xMin = px
        if (py < _gthis.yMin):
            _gthis.yMin = py
        if (px > _gthis.xMax):
            _gthis.xMax = px
        if (py > _gthis.yMax):
            _gthis.yMax = py
        if (t is not None):
            self.state.setTexture(t.innerTex)
        _this = self.state
        _hx_local_0 = _this.tail
        _hx_local_1 = _hx_local_0.count
        _hx_local_0.count = (_hx_local_1 + 4)
        _hx_local_0.count
        _this.totalCount = (_this.totalCount + 4)

    def addPoint(self,x,y,color):
        this1 = self.tmp
        this1.append(x)
        this1 = self.tmp
        this1.append(y)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(((((color >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((color >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((color & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(color, 24)) / 255.))
        if (x < self.xMin):
            self.xMin = x
        if (y < self.yMin):
            self.yMin = y
        if (x > self.xMax):
            self.xMax = x
        if (y > self.yMax):
            self.yMax = y

    def insertColor(self,c):
        this1 = self.tmp
        this1.append(((((c >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((c >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((c & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(c, 24)) / 255.))

    def rectColor(self,x,y,w,h,color):
        this1 = self.tmp
        this1.append(x)
        this1 = self.tmp
        this1.append(y)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(((((color >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((color >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((color & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(color, 24)) / 255.))
        this1 = self.tmp
        this1.append((x + w))
        this1 = self.tmp
        this1.append(y)
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(((((color >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((color >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((color & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(color, 24)) / 255.))
        this1 = self.tmp
        this1.append(x)
        this1 = self.tmp
        this1.append((y + h))
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(((((color >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((color >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((color & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(color, 24)) / 255.))
        this1 = self.tmp
        this1.append((x + w))
        this1 = self.tmp
        this1.append((y + h))
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(((((color >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((color >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((color & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(color, 24)) / 255.))
        if (x < self.xMin):
            self.xMin = x
        if (y < self.yMin):
            self.yMin = y
        x = (x + w)
        y = (y + h)
        if (x > self.xMax):
            self.xMax = x
        if (y > self.yMax):
            self.yMax = y
        _this = self.state
        _hx_local_2 = _this.tail
        _hx_local_3 = _hx_local_2.count
        _hx_local_2.count = (_hx_local_3 + 4)
        _hx_local_2.count
        _this.totalCount = (_this.totalCount + 4)

    def rectGradient(self,x,y,w,h,ctl,ctr,cbl,cbr):
        this1 = self.tmp
        this1.append(x)
        this1 = self.tmp
        this1.append(y)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(((((ctl >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((ctl >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((ctl & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(ctl, 24)) / 255.))
        this1 = self.tmp
        this1.append((x + w))
        this1 = self.tmp
        this1.append(y)
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(((((ctr >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((ctr >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((ctr & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(ctr, 24)) / 255.))
        this1 = self.tmp
        this1.append(x)
        this1 = self.tmp
        this1.append((y + h))
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(((((cbl >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((cbl >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((cbl & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(cbl, 24)) / 255.))
        this1 = self.tmp
        this1.append((x + w))
        this1 = self.tmp
        this1.append((y + h))
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(((((cbr >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((cbr >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((cbr & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(cbr, 24)) / 255.))
        if (x < self.xMin):
            self.xMin = x
        if (y < self.yMin):
            self.yMin = y
        x = (x + w)
        y = (y + h)
        if (x > self.xMax):
            self.xMax = x
        if (y > self.yMax):
            self.yMax = y
        _this = self.state
        _hx_local_2 = _this.tail
        _hx_local_3 = _hx_local_2.count
        _hx_local_2.count = (_hx_local_3 + 4)
        _hx_local_2.count
        _this.totalCount = (_this.totalCount + 4)

    def fillArc(self,x,y,ray,c,start,end):
        if (end <= start):
            return
        arcLength = (end - start)
        nsegments = Math.ceil((((ray * 3.14) * 2) / 4))
        if (nsegments < 4):
            nsegments = 4
        angle = (arcLength / nsegments)
        prevX = Math.NEGATIVE_INFINITY
        prevY = Math.NEGATIVE_INFINITY
        _x = 0.
        _y = 0.
        i = 0
        count = 0
        while (i < nsegments):
            a = (start + ((i * angle)))
            _x = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray)))
            _y = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray)))
            if (prevX != Math.NEGATIVE_INFINITY):
                self.addPoint(x,y,c)
                self.addPoint(_x,_y,c)
                self.addPoint(prevX,prevY,c)
                self.addPoint(prevX,prevY,c)
                count = (count + 4)
            prevX = _x
            prevY = _y
            i = (i + 1)
        a = end
        _x = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray)))
        _y = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray)))
        self.addPoint(x,y,c)
        self.addPoint(_x,_y,c)
        self.addPoint(prevX,prevY,c)
        self.addPoint(prevX,prevY,c)
        _this = self.state
        count1 = (count + 4)
        _hx_local_2 = _this.tail
        _hx_local_3 = _hx_local_2.count
        _hx_local_2.count = (_hx_local_3 + count1)
        _hx_local_2.count
        _this.totalCount = (_this.totalCount + count1)

    def fillCircle(self,x,y,radius,c):
        nsegments = Math.ceil((((radius * 3.14) * 2) / 2))
        if (nsegments < 3):
            nsegments = 3
        angle = ((Math.PI * 2) / nsegments)
        prevX = Math.NEGATIVE_INFINITY
        prevY = Math.NEGATIVE_INFINITY
        firstX = Math.NEGATIVE_INFINITY
        firstY = Math.NEGATIVE_INFINITY
        curX = 0.
        curY = 0.
        count = 0
        _g = 0
        _g1 = nsegments
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            a = (i * angle)
            curX = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * radius)))
            curY = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * radius)))
            if (prevX != Math.NEGATIVE_INFINITY):
                self.addPoint(x,y,c)
                self.addPoint(curX,curY,c)
                self.addPoint(prevX,prevY,c)
                self.addPoint(x,y,c)
                count = (count + 4)
            if (firstX == Math.NEGATIVE_INFINITY):
                firstX = curX
                firstY = curY
            prevX = curX
            prevY = curY
        self.addPoint(x,y,c)
        self.addPoint(curX,curY,c)
        self.addPoint(firstX,firstY,c)
        self.addPoint(x,y,c)
        _this = self.state
        count1 = (count + 4)
        _hx_local_1 = _this.tail
        _hx_local_2 = _hx_local_1.count
        _hx_local_1.count = (_hx_local_2 + count1)
        _hx_local_1.count
        _this.totalCount = (_this.totalCount + count1)

    def circle(self,x,y,ray,size,c):
        if (size > ray):
            return
        nsegments = Math.ceil((((ray * 3.14) * 2) / 2))
        if (nsegments < 3):
            nsegments = 3
        ray1 = (ray - size)
        angle = ((Math.PI * 2) / nsegments)
        prevX = Math.NEGATIVE_INFINITY
        prevY = Math.NEGATIVE_INFINITY
        prevX1 = Math.NEGATIVE_INFINITY
        prevY1 = Math.NEGATIVE_INFINITY
        count = 0
        _g = 0
        _g1 = nsegments
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            a = (i * angle)
            _x = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray)))
            _y = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray)))
            _x1 = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray1)))
            _y1 = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray1)))
            if (prevX != Math.NEGATIVE_INFINITY):
                self.addPoint(_x,_y,c)
                self.addPoint(prevX,prevY,c)
                self.addPoint(_x1,_y1,c)
                self.addPoint(prevX1,prevY1,c)
                count = (count + 4)
            prevX = _x
            prevY = _y
            prevX1 = _x1
            prevY1 = _y1
        _this = self.state
        _hx_local_1 = _this.tail
        _hx_local_2 = _hx_local_1.count
        _hx_local_1.count = (_hx_local_2 + count)
        _hx_local_1.count
        _this.totalCount = (_this.totalCount + count)

    def arc(self,x,y,ray,size,start,end,c):
        if (size > ray):
            return
        if (end <= start):
            return
        arcLength = (end - start)
        nsegments = Math.ceil((((ray * 3.14) * 2) / 4))
        if (nsegments < 3):
            nsegments = 3
        ray1 = (ray - size)
        angle = (arcLength / nsegments)
        prevX = Math.NEGATIVE_INFINITY
        prevY = Math.NEGATIVE_INFINITY
        prevX1 = Math.NEGATIVE_INFINITY
        prevY1 = Math.NEGATIVE_INFINITY
        _x = 0.
        _y = 0.
        _x1 = 0.
        _y1 = 0.
        count = 0
        _g = 0
        _g1 = nsegments
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            a = (start + ((i * angle)))
            _x = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray)))
            _y = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray)))
            _x1 = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray1)))
            _y1 = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray1)))
            if (prevX != Math.NEGATIVE_INFINITY):
                self.addPoint(_x,_y,c)
                self.addPoint(prevX,prevY,c)
                self.addPoint(_x1,_y1,c)
                self.addPoint(prevX1,prevY1,c)
                count = (count + 4)
            prevX = _x
            prevY = _y
            prevX1 = _x1
            prevY1 = _y1
        a = end
        _x = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray)))
        _y = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray)))
        _x1 = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray1)))
        _y1 = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray1)))
        self.addPoint(_x,_y,c)
        self.addPoint(prevX,prevY,c)
        self.addPoint(_x1,_y1,c)
        self.addPoint(prevX1,prevY1,c)
        _this = self.state
        count1 = (count + 4)
        _hx_local_1 = _this.tail
        _hx_local_2 = _hx_local_1.count
        _hx_local_1.count = (_hx_local_2 + count1)
        _hx_local_1.count
        _this.totalCount = (_this.totalCount + count1)

    def alloc(self,engine):
        if (self.tmp is None):
            self.clear()
        if (len(self.tmp) > 0):
            self.buffer = (hxd_impl_Allocator.get().ofFloats(self.tmp,8,3) if (self.useAllocator) else h3d_Buffer.ofFloats(self.tmp,8,[h3d_BufferFlag.Quads, h3d_BufferFlag.RawFormat]))

    def dispose(self):
        if (self.buffer is not None):
            if self.useAllocator:
                hxd_impl_Allocator.get().disposeBuffer(self.buffer)
            else:
                self.buffer.dispose()
            self.buffer = None
        super().dispose()

    def flush(self):
        tmp = None
        if (self.buffer is not None):
            _this = self.buffer
            tmp = ((_this.buffer is None) or ((_this.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            self.alloc(h3d_Engine.CURRENT)

    def doRender(self,ctx,_hx_min,_hx_len):
        tmp = None
        if (self.buffer is not None):
            _this = self.buffer
            tmp = ((_this.buffer is None) or ((_this.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            self.alloc(h3d_Engine.CURRENT)
        self.state.drawQuads(ctx,self.buffer,_hx_min,_hx_len)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tmp = None
        _hx_o.xMin = None
        _hx_o.yMin = None
        _hx_o.xMax = None
        _hx_o.yMax = None
        _hx_o.useAllocator = None
        _hx_o.state = None
h2d_TileLayerContent._hx_class = h2d_TileLayerContent
_hx_classes["h2d.TileLayerContent"] = h2d_TileLayerContent


class h2d_TileGroup(h2d_Drawable):
    _hx_class_name = "h2d.TileGroup"
    _hx_is_interface = "False"
    __slots__ = ("content", "curColor", "tile", "rangeMin", "rangeMax")
    _hx_fields = ["content", "curColor", "tile", "rangeMin", "rangeMax"]
    _hx_methods = ["getBoundsRec", "clear", "invalidate", "count", "onRemove", "setDefaultColor", "add", "addColor", "addAlpha", "addTransform", "draw", "sync", "drawWith"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Drawable


    def __init__(self,t = None,parent = None):
        self.rangeMax = None
        self.rangeMin = None
        self.tile = None
        self.curColor = None
        self.content = None
        super().__init__(parent)
        self.tile = t
        def _hx_local_0():
            self.rangeMax = -1
            return self.rangeMax
        self.rangeMin = _hx_local_0()
        self.curColor = h3d_Vector(1,1,1,1)
        self.content = h2d_TileLayerContent()

    def getBoundsRec(self,relativeTo,out,forSize):
        super().getBoundsRec(relativeTo,out,forSize)
        self.addBounds(relativeTo,out,self.content.xMin,self.content.yMin,(self.content.xMax - self.content.xMin),(self.content.yMax - self.content.yMin))

    def clear(self):
        self.content.clear()

    def invalidate(self):
        self.content.dispose()

    def count(self):
        return (self.content.triCount() >> 1)

    def onRemove(self):
        self.content.dispose()
        super().onRemove()

    def setDefaultColor(self,rgb,alpha = None):
        if (alpha is None):
            alpha = 1.0
        self.curColor.x = ((((rgb >> 16) & 255)) / 255)
        self.curColor.y = ((((rgb >> 8) & 255)) / 255)
        self.curColor.z = (((rgb & 255)) / 255)
        self.curColor.w = alpha

    def add(self,x,y,t):
        self.content.add(x,y,self.curColor.x,self.curColor.y,self.curColor.z,self.curColor.w,t)

    def addColor(self,x,y,r,g,b,a,t):
        self.content.add(x,y,r,g,b,a,t)

    def addAlpha(self,x,y,a,t):
        self.content.add(x,y,self.curColor.x,self.curColor.y,self.curColor.z,a,t)

    def addTransform(self,x,y,sx,sy,r,t):
        self.content.addTransform(x,y,sx,sy,r,self.curColor,t)

    def draw(self,ctx):
        self.drawWith(ctx,self)

    def sync(self,ctx):
        super().sync(ctx)
        if self.visible:
            _this = self.content
            tmp = None
            if (_this.buffer is not None):
                _this1 = _this.buffer
                tmp = ((_this1.buffer is None) or ((_this1.buffer.vbuf is None)))
            else:
                tmp = True
            if tmp:
                _this.alloc(h3d_Engine.CURRENT)

    def drawWith(self,ctx,obj):
        _hx_max = self.content.triCount()
        if (_hx_max == 0):
            return
        if (not ctx.beginDrawBatchState(obj)):
            return
        _hx_min = (0 if ((self.rangeMin < 0)) else (self.rangeMin * 2))
        if ((self.rangeMax > 0) and ((self.rangeMax < ((_hx_max * 2))))):
            _hx_max = (self.rangeMax * 2)
        _this = self.content
        tmp = None
        if (_this.buffer is not None):
            _this1 = _this.buffer
            tmp = ((_this1.buffer is None) or ((_this1.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            _this.alloc(h3d_Engine.CURRENT)
        _this.state.drawQuads(ctx,_this.buffer,_hx_min,(_hx_max - _hx_min))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.content = None
        _hx_o.curColor = None
        _hx_o.tile = None
        _hx_o.rangeMin = None
        _hx_o.rangeMax = None
h2d_TileGroup._hx_class = h2d_TileGroup
_hx_classes["h2d.TileGroup"] = h2d_TileGroup


class h2d_col_Bounds:
    _hx_class_name = "h2d.col.Bounds"
    _hx_is_interface = "False"
    __slots__ = ("xMin", "yMin", "xMax", "yMax")
    _hx_fields = ["xMin", "yMin", "xMax", "yMax"]
    _hx_methods = ["toIBounds", "intersects", "contains", "distanceSq", "distance", "addBounds", "addPoint", "addPos", "set", "setMin", "setMax", "doIntersect", "doUnion", "intersection", "union", "load", "scalePivot", "scaleCenter", "rotate", "offset", "getMin", "getCenter", "getSize", "getMax", "isEmpty", "empty", "all", "clone", "get_x", "get_y", "set_x", "set_y", "get_width", "get_height", "set_width", "set_height", "toString", "toCircle"]
    _hx_statics = ["fromValues", "fromPoints"]

    def __init__(self):
        self.xMin = 1e20
        self.yMin = 1e20
        self.xMax = -1e20
        self.yMax = -1e20

    def toIBounds(self,scale = None):
        if (scale is None):
            scale = 1.
        ix = Math.floor((self.xMin * scale))
        iy = Math.floor((self.yMin * scale))
        width = (Math.ceil((self.xMax * scale)) - ix)
        height = (Math.ceil((self.yMax * scale)) - iy)
        b = h2d_col_IBounds()
        b.xMin = ix
        b.yMin = iy
        b.xMax = (ix + width)
        b.yMax = (iy + height)
        return b

    def intersects(self,b):
        return (not (((((self.xMin > b.xMax) or ((self.yMin > b.yMax))) or ((self.xMax < b.xMin))) or ((self.yMax < b.yMin)))))

    def contains(self,p):
        if (((p.x >= self.xMin) and ((p.x < self.xMax))) and ((p.y >= self.yMin))):
            return (p.y < self.yMax)
        else:
            return False

    def distanceSq(self,p):
        dx = ((self.xMin - p.x) if ((p.x < self.xMin)) else ((p.x - self.xMax) if ((p.x > self.xMax)) else 0.))
        dy = ((self.yMin - p.y) if ((p.y < self.yMin)) else ((p.y - self.yMax) if ((p.y > self.yMax)) else 0.))
        return ((dx * dx) + ((dy * dy)))

    def distance(self,p):
        dx = ((self.xMin - p.x) if ((p.x < self.xMin)) else ((p.x - self.xMax) if ((p.x > self.xMax)) else 0.))
        dy = ((self.yMin - p.y) if ((p.y < self.yMin)) else ((p.y - self.yMax) if ((p.y > self.yMax)) else 0.))
        f = ((dx * dx) + ((dy * dy)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def addBounds(self,b):
        if (b.xMin < self.xMin):
            self.xMin = b.xMin
        if (b.xMax > self.xMax):
            self.xMax = b.xMax
        if (b.yMin < self.yMin):
            self.yMin = b.yMin
        if (b.yMax > self.yMax):
            self.yMax = b.yMax

    def addPoint(self,p):
        if (p.x < self.xMin):
            self.xMin = p.x
        if (p.x > self.xMax):
            self.xMax = p.x
        if (p.y < self.yMin):
            self.yMin = p.y
        if (p.y > self.yMax):
            self.yMax = p.y

    def addPos(self,x,y):
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y

    def set(self,x,y,width,height):
        self.xMin = x
        self.yMin = y
        self.xMax = (x + width)
        self.yMax = (y + height)

    def setMin(self,p):
        self.xMin = p.x
        self.yMin = p.y

    def setMax(self,p):
        self.xMax = p.x
        self.yMax = p.y

    def doIntersect(self,b):
        a = self.xMin
        b1 = b.xMin
        self.xMin = (b1 if ((a < b1)) else a)
        a = self.yMin
        b1 = b.yMin
        self.yMin = (b1 if ((a < b1)) else a)
        a = self.xMax
        b1 = b.xMax
        self.xMax = (b1 if ((a > b1)) else a)
        a = self.yMax
        b1 = b.yMax
        self.yMax = (b1 if ((a > b1)) else a)

    def doUnion(self,b):
        a = self.xMin
        b1 = b.xMin
        self.xMin = (b1 if ((a > b1)) else a)
        a = self.yMin
        b1 = b.yMin
        self.yMin = (b1 if ((a > b1)) else a)
        a = self.xMax
        b1 = b.xMax
        self.xMax = (b1 if ((a < b1)) else a)
        a = self.yMax
        b1 = b.yMax
        self.yMax = (b1 if ((a < b1)) else a)

    def intersection(self,b):
        i = h2d_col_Bounds()
        a = self.xMin
        b1 = b.xMin
        i.xMin = (b1 if ((a < b1)) else a)
        a = self.yMin
        b1 = b.yMin
        i.yMin = (b1 if ((a < b1)) else a)
        a = self.xMax
        b1 = b.xMax
        i.xMax = (b1 if ((a > b1)) else a)
        a = self.yMax
        b1 = b.yMax
        i.yMax = (b1 if ((a > b1)) else a)
        if (i.xMax < i.xMin):
            i.xMax = i.xMin
        if (i.yMax < i.yMin):
            i.yMax = i.yMin
        return i

    def union(self,b):
        i = h2d_col_Bounds()
        a = self.xMin
        b1 = b.xMin
        i.xMin = (b1 if ((a > b1)) else a)
        a = self.yMin
        b1 = b.yMin
        i.yMin = (b1 if ((a > b1)) else a)
        a = self.xMax
        b1 = b.xMax
        i.xMax = (b1 if ((a < b1)) else a)
        a = self.yMax
        b1 = b.yMax
        i.yMax = (b1 if ((a < b1)) else a)
        return i

    def load(self,b):
        self.xMin = b.xMin
        self.yMin = b.yMin
        self.xMax = b.xMax
        self.yMax = b.yMax

    def scalePivot(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 * v)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.yMin
        _hx_local_2.yMin = (_hx_local_3 * v)
        _hx_local_2.yMin
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.xMax
        _hx_local_4.xMax = (_hx_local_5 * v)
        _hx_local_4.xMax
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.yMax
        _hx_local_6.yMax = (_hx_local_7 * v)
        _hx_local_6.yMax

    def scaleCenter(self,v):
        dx = ((((self.xMax - self.xMin)) * 0.5) * v)
        dy = ((((self.yMax - self.yMin)) * 0.5) * v)
        mx = (((self.xMax + self.xMin)) * 0.5)
        my = (((self.yMax + self.yMin)) * 0.5)
        self.xMin = (mx - dx)
        self.yMin = (my - dy)
        self.xMax = (mx + dx)
        self.yMax = (my + dy)

    def rotate(self,angle):
        cos = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sin = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        x0 = self.xMin
        y0 = self.yMin
        x1 = self.xMax
        y1 = self.yMax
        self.xMin = 1e20
        self.yMin = 1e20
        self.xMax = -1e20
        self.yMax = -1e20
        x = ((x0 * cos) - ((y0 * sin)))
        y = ((x0 * sin) + ((y0 * cos)))
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y
        x = ((x1 * cos) - ((y0 * sin)))
        y = ((x1 * sin) + ((y0 * cos)))
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y
        x = ((x0 * cos) - ((y1 * sin)))
        y = ((x0 * sin) + ((y1 * cos)))
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y
        x = ((x1 * cos) - ((y1 * sin)))
        y = ((x1 * sin) + ((y1 * cos)))
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y

    def offset(self,dx,dy):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 + dx)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.xMax
        _hx_local_2.xMax = (_hx_local_3 + dx)
        _hx_local_2.xMax
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.yMin
        _hx_local_4.yMin = (_hx_local_5 + dy)
        _hx_local_4.yMin
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.yMax
        _hx_local_6.yMax = (_hx_local_7 + dy)
        _hx_local_6.yMax

    def getMin(self):
        return h2d_col_Point(self.xMin,self.yMin)

    def getCenter(self):
        return h2d_col_Point((((self.xMin + self.xMax)) * 0.5),(((self.yMin + self.yMax)) * 0.5))

    def getSize(self):
        return h2d_col_Point((self.xMax - self.xMin),(self.yMax - self.yMin))

    def getMax(self):
        return h2d_col_Point(self.xMax,self.yMax)

    def isEmpty(self):
        if (not ((self.xMax <= self.xMin))):
            return (self.yMax <= self.yMin)
        else:
            return True

    def empty(self):
        self.xMin = 1e20
        self.yMin = 1e20
        self.xMax = -1e20
        self.yMax = -1e20

    def all(self):
        self.xMin = -1e20
        self.yMin = -1e20
        self.xMax = 1e20
        self.yMax = 1e20

    def clone(self):
        b = h2d_col_Bounds()
        b.xMin = self.xMin
        b.yMin = self.yMin
        b.xMax = self.xMax
        b.yMax = self.yMax
        return b

    def get_x(self):
        return self.xMin

    def get_y(self):
        return self.yMin

    def set_x(self,x):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMax
        _hx_local_0.xMax = (_hx_local_1 + ((x - self.xMin)))
        _hx_local_0.xMax
        def _hx_local_3():
            def _hx_local_2():
                self.xMin = x
                return self.xMin
            return _hx_local_2()
        return _hx_local_3()

    def set_y(self,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.yMax
        _hx_local_0.yMax = (_hx_local_1 + ((y - self.yMin)))
        _hx_local_0.yMax
        def _hx_local_3():
            def _hx_local_2():
                self.yMin = y
                return self.yMin
            return _hx_local_2()
        return _hx_local_3()

    def get_width(self):
        return (self.xMax - self.xMin)

    def get_height(self):
        return (self.yMax - self.yMin)

    def set_width(self,w):
        self.xMax = (self.xMin + w)
        return w

    def set_height(self,h):
        self.yMax = (self.yMin + h)
        return h

    def toString(self):
        return (((("{" + Std.string(h2d_col_Point(self.xMin,self.yMin))) + ",") + Std.string(h2d_col_Point((self.xMax - self.xMin),(self.yMax - self.yMin)))) + "}")

    def toCircle(self):
        dx = (self.xMax - self.xMin)
        dy = (self.yMax - self.yMin)
        f = ((dx * dx) + ((dy * dy)))
        return h2d_col_Circle((((self.xMin + self.xMax)) * 0.5),(((self.yMin + self.yMax)) * 0.5),(((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 0.5))

    @staticmethod
    def fromValues(x0,y0,width,height):
        b = h2d_col_Bounds()
        b.xMin = x0
        b.yMin = y0
        b.xMax = (x0 + width)
        b.yMax = (y0 + height)
        return b

    @staticmethod
    def fromPoints(_hx_min,_hx_max):
        b = h2d_col_Bounds()
        b.xMin = _hx_min.x
        b.yMin = _hx_min.y
        b.xMax = _hx_max.x
        b.yMax = _hx_max.y
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.xMin = None
        _hx_o.yMin = None
        _hx_o.xMax = None
        _hx_o.yMax = None
h2d_col_Bounds._hx_class = h2d_col_Bounds
_hx_classes["h2d.col.Bounds"] = h2d_col_Bounds


class h2d_col_Collider:
    _hx_class_name = "h2d.col.Collider"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["contains"]
h2d_col_Collider._hx_class = h2d_col_Collider
_hx_classes["h2d.col.Collider"] = h2d_col_Collider


class h2d_col_Circle:
    _hx_class_name = "h2d.col.Circle"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "ray")
    _hx_fields = ["x", "y", "ray"]
    _hx_methods = ["distanceSq", "side", "collideCircle", "collideBounds", "lineIntersect", "toString", "contains"]
    _hx_interfaces = [h2d_col_Collider]

    def __init__(self,x,y,ray):
        self.x = x
        self.y = y
        self.ray = ray

    def distanceSq(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        d = (((dx * dx) + ((dy * dy))) - ((self.ray * self.ray)))
        if (d < 0):
            return 0
        else:
            return d

    def side(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        return ((self.ray * self.ray) - (((dx * dx) + ((dy * dy)))))

    def collideCircle(self,c):
        dx = (self.x - c.x)
        dy = (self.y - c.y)
        return (((dx * dx) + ((dy * dy))) < ((((self.ray + c.ray)) * ((self.ray + c.ray)))))

    def collideBounds(self,b):
        if (self.x < ((b.xMin - self.ray))):
            return False
        if (self.x > ((b.xMax + self.ray))):
            return False
        if (self.y < ((b.yMin - self.ray))):
            return False
        if (self.y > ((b.yMax + self.ray))):
            return False
        tmp = None
        if ((self.x < b.xMin) and ((self.y < b.yMin))):
            dx = (self.x - b.xMin)
            dy = (self.y - b.yMin)
            tmp = (((dx * dx) + ((dy * dy))) > ((self.ray * self.ray)))
        else:
            tmp = False
        if tmp:
            return False
        tmp = None
        if ((self.x > b.xMax) and ((self.y < b.yMin))):
            dx = (self.x - b.xMax)
            dy = (self.y - b.yMin)
            tmp = (((dx * dx) + ((dy * dy))) > ((self.ray * self.ray)))
        else:
            tmp = False
        if tmp:
            return False
        tmp = None
        if ((self.x < b.xMin) and ((self.y > b.yMax))):
            dx = (self.x - b.xMin)
            dy = (self.y - b.yMax)
            tmp = (((dx * dx) + ((dy * dy))) > ((self.ray * self.ray)))
        else:
            tmp = False
        if tmp:
            return False
        tmp = None
        if ((self.x > b.xMax) and ((self.y > b.yMax))):
            dx = (self.x - b.xMax)
            dy = (self.y - b.yMax)
            tmp = (((dx * dx) + ((dy * dy))) > ((self.ray * self.ray)))
        else:
            tmp = False
        if tmp:
            return False
        return True

    def lineIntersect(self,p1,p2):
        dx = (p2.x - p1.x)
        dy = (p2.y - p1.y)
        a = ((dx * dx) + ((dy * dy)))
        if (a < 1e-8):
            return None
        b = (2 * (((dx * ((p1.x - self.x))) + ((dy * ((p1.y - self.y)))))))
        dx1 = (p1.x - self.x)
        dy1 = (p1.y - self.y)
        c = (((dx1 * dx1) + ((dy1 * dy1))) - ((self.ray * self.ray)))
        d = ((b * b) - (((4 * a) * c)))
        if (d < 0):
            return None
        if (d == 0):
            t = (-b / ((2 * a)))
            return [h2d_col_Point((p1.x + ((t * dx))),(p1.y + ((t * dy))))]
        t1 = (((-b - ((Math.NaN if ((d < 0)) else python_lib_Math.sqrt(d))))) / ((2 * a)))
        t2 = (((-b + ((Math.NaN if ((d < 0)) else python_lib_Math.sqrt(d))))) / ((2 * a)))
        return [h2d_col_Point((p1.x + ((t1 * dx))),(p1.y + ((t1 * dy)))), h2d_col_Point((p1.x + ((t2 * dx))),(p1.y + ((t2 * dy))))]

    def toString(self):
        return (((((("{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.ray))) + "}")

    def contains(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        d = (((dx * dx) + ((dy * dy))) - ((self.ray * self.ray)))
        return (((0 if ((d < 0)) else d)) == 0)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.ray = None
h2d_col_Circle._hx_class = h2d_col_Circle
_hx_classes["h2d.col.Circle"] = h2d_col_Circle


class h2d_col_IBounds:
    _hx_class_name = "h2d.col.IBounds"
    _hx_is_interface = "False"
    __slots__ = ("xMin", "yMin", "xMax", "yMax")
    _hx_fields = ["xMin", "yMin", "xMax", "yMax"]
    _hx_methods = ["toBounds", "intersects", "contains", "addBounds", "addPoint", "addPos", "set", "setMin", "setMax", "doIntersect", "doUnion", "intersection", "union", "load", "offset", "getMin", "getCenter", "getSize", "getMax", "isEmpty", "empty", "all", "clone", "get_x", "get_y", "set_x", "set_y", "get_width", "get_height", "set_width", "set_height", "toString"]
    _hx_statics = ["fromValues", "fromPoints"]

    def __init__(self):
        self.xMin = 2147483647
        self.yMin = 2147483647
        self.xMax = -2147483648
        self.yMax = -2147483648

    def toBounds(self,scale = None):
        if (scale is None):
            scale = 1.
        x0 = (self.xMin * scale)
        y0 = (self.yMin * scale)
        width = (((self.xMax - self.xMin)) * scale)
        height = (((self.yMax - self.yMin)) * scale)
        b = h2d_col_Bounds()
        b.xMin = x0
        b.yMin = y0
        b.xMax = (x0 + width)
        b.yMax = (y0 + height)
        return b

    def intersects(self,b):
        return (not (((((self.xMin > b.xMax) or ((self.yMin > b.yMax))) or ((self.xMax < b.xMin))) or ((self.yMax < b.yMin)))))

    def contains(self,p):
        if (((p.x >= self.xMin) and ((p.x < self.xMax))) and ((p.y >= self.yMin))):
            return (p.y < self.yMax)
        else:
            return False

    def addBounds(self,b):
        if (b.xMin < self.xMin):
            self.xMin = b.xMin
        if (b.xMax > self.xMax):
            self.xMax = b.xMax
        if (b.yMin < self.yMin):
            self.yMin = b.yMin
        if (b.yMax > self.yMax):
            self.yMax = b.yMax

    def addPoint(self,p):
        if (p.x < self.xMin):
            self.xMin = p.x
        if (p.x > self.xMax):
            self.xMax = p.x
        if (p.y < self.yMin):
            self.yMin = p.y
        if (p.y > self.yMax):
            self.yMax = p.y

    def addPos(self,x,y):
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y

    def set(self,x,y,width,height):
        self.xMin = x
        self.yMin = y
        self.xMax = (x + width)
        self.yMax = (y + height)

    def setMin(self,p):
        self.xMin = p.x
        self.yMin = p.y

    def setMax(self,p):
        self.xMax = p.x
        self.yMax = p.y

    def doIntersect(self,b):
        a = self.xMin
        b1 = b.xMin
        self.xMin = (b1 if ((a < b1)) else a)
        a = self.yMin
        b1 = b.yMin
        self.yMin = (b1 if ((a < b1)) else a)
        a = self.xMax
        b1 = b.xMax
        self.xMax = (b1 if ((a > b1)) else a)
        a = self.yMax
        b1 = b.yMax
        self.yMax = (b1 if ((a > b1)) else a)

    def doUnion(self,b):
        a = self.xMin
        b1 = b.xMin
        self.xMin = (b1 if ((a > b1)) else a)
        a = self.yMin
        b1 = b.yMin
        self.yMin = (b1 if ((a > b1)) else a)
        a = self.xMax
        b1 = b.xMax
        self.xMax = (b1 if ((a < b1)) else a)
        a = self.yMax
        b1 = b.yMax
        self.yMax = (b1 if ((a < b1)) else a)

    def intersection(self,b):
        i = h2d_col_IBounds()
        a = self.xMin
        b1 = b.xMin
        i.xMin = (b1 if ((a < b1)) else a)
        a = self.yMin
        b1 = b.yMin
        i.yMin = (b1 if ((a < b1)) else a)
        a = self.xMax
        b1 = b.xMax
        i.xMax = (b1 if ((a > b1)) else a)
        a = self.yMax
        b1 = b.yMax
        i.yMax = (b1 if ((a > b1)) else a)
        if (i.xMax < i.xMin):
            i.xMax = i.xMin
        if (i.yMax < i.yMin):
            i.yMax = i.yMin
        return i

    def union(self,b):
        i = h2d_col_IBounds()
        a = self.xMin
        b1 = b.xMin
        i.xMin = (b1 if ((a > b1)) else a)
        a = self.yMin
        b1 = b.yMin
        i.yMin = (b1 if ((a > b1)) else a)
        a = self.xMax
        b1 = b.xMax
        i.xMax = (b1 if ((a < b1)) else a)
        a = self.yMax
        b1 = b.yMax
        i.yMax = (b1 if ((a < b1)) else a)
        return i

    def load(self,b):
        self.xMin = b.xMin
        self.yMin = b.yMin
        self.xMax = b.xMax
        self.yMax = b.yMax

    def offset(self,dx,dy):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 + dx)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.xMax
        _hx_local_2.xMax = (_hx_local_3 + dx)
        _hx_local_2.xMax
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.yMin
        _hx_local_4.yMin = (_hx_local_5 + dy)
        _hx_local_4.yMin
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.yMax
        _hx_local_6.yMax = (_hx_local_7 + dy)
        _hx_local_6.yMax

    def getMin(self):
        return h2d_col_IPoint(self.xMin,self.yMin)

    def getCenter(self):
        return h2d_col_IPoint(((self.xMin + self.xMax) >> 1),((self.yMin + self.yMax) >> 1))

    def getSize(self):
        return h2d_col_IPoint((self.xMax - self.xMin),(self.yMax - self.yMin))

    def getMax(self):
        return h2d_col_IPoint(self.xMax,self.yMax)

    def isEmpty(self):
        if (self.xMax > self.xMin):
            return (self.yMax <= self.yMin)
        else:
            return True

    def empty(self):
        self.xMin = 2147483647
        self.yMin = 2147483647
        self.xMax = -2147483648
        self.yMax = -2147483648

    def all(self):
        self.xMin = -2147483648
        self.yMin = -2147483648
        self.xMax = 2147483647
        self.yMax = 2147483647

    def clone(self):
        b = h2d_col_IBounds()
        b.xMin = self.xMin
        b.yMin = self.yMin
        b.xMax = self.xMax
        b.yMax = self.yMax
        return b

    def get_x(self):
        return self.xMin

    def get_y(self):
        return self.yMin

    def set_x(self,x):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMax
        _hx_local_0.xMax = (_hx_local_1 + ((x - self.xMin)))
        _hx_local_0.xMax
        def _hx_local_3():
            def _hx_local_2():
                self.xMin = x
                return self.xMin
            return _hx_local_2()
        return _hx_local_3()

    def set_y(self,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.yMax
        _hx_local_0.yMax = (_hx_local_1 + ((y - self.yMin)))
        _hx_local_0.yMax
        def _hx_local_3():
            def _hx_local_2():
                self.yMin = y
                return self.yMin
            return _hx_local_2()
        return _hx_local_3()

    def get_width(self):
        return (self.xMax - self.xMin)

    def get_height(self):
        return (self.yMax - self.yMin)

    def set_width(self,w):
        self.xMax = (self.xMin + w)
        return w

    def set_height(self,h):
        self.yMax = (self.yMin + h)
        return h

    def toString(self):
        return (((("{" + Std.string(h2d_col_IPoint(self.xMin,self.yMin))) + ",") + Std.string(h2d_col_IPoint((self.xMax - self.xMin),(self.yMax - self.yMin)))) + "}")

    @staticmethod
    def fromValues(x0,y0,width,height):
        b = h2d_col_IBounds()
        b.xMin = x0
        b.yMin = y0
        b.xMax = (x0 + width)
        b.yMax = (y0 + height)
        return b

    @staticmethod
    def fromPoints(_hx_min,_hx_max):
        b = h2d_col_IBounds()
        b.xMin = _hx_min.x
        b.yMin = _hx_min.y
        b.xMax = _hx_max.x
        b.yMax = _hx_max.y
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.xMin = None
        _hx_o.yMin = None
        _hx_o.xMax = None
        _hx_o.yMax = None
h2d_col_IBounds._hx_class = h2d_col_IBounds
_hx_classes["h2d.col.IBounds"] = h2d_col_IBounds


class h2d_col_IPoint:
    _hx_class_name = "h2d.col.IPoint"
    _hx_is_interface = "False"
    __slots__ = ("x", "y")
    _hx_fields = ["x", "y"]
    _hx_methods = ["load", "scale", "multiply", "distanceSq", "distance", "toString", "sub", "add", "equals", "dot", "lengthSq", "length", "set", "clone", "cross", "toPoint"]

    def __init__(self,x = None,y = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        self.x = x
        self.y = y

    def load(self,p):
        self.x = p.x
        self.y = p.y

    def scale(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * v)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * v)
        _hx_local_2.y

    def multiply(self,v):
        return h2d_col_IPoint((self.x * v),(self.y * v))

    def distanceSq(self,p):
        dx = (self.x - p.x)
        dy = (self.y - p.y)
        return ((dx * dx) + ((dy * dy)))

    def distance(self,p):
        dx = (self.x - p.x)
        dy = (self.y - p.y)
        f = ((dx * dx) + ((dy * dy)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def toString(self):
        return (((("{" + Std.string(self.x)) + ",") + Std.string(self.y)) + "}")

    def sub(self,p):
        return h2d_col_IPoint((self.x - p.x),(self.y - p.y))

    def add(self,p):
        return h2d_col_IPoint((self.x + p.x),(self.y + p.y))

    def equals(self,other):
        if (self.x == other.x):
            return (self.y == other.y)
        else:
            return False

    def dot(self,p):
        return ((self.x * p.x) + ((self.y * p.y)))

    def lengthSq(self):
        return ((self.x * self.x) + ((self.y * self.y)))

    def length(self):
        f = ((self.x * self.x) + ((self.y * self.y)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def set(self,x = None,y = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        self.x = x
        self.y = y

    def clone(self):
        return h2d_col_IPoint(self.x,self.y)

    def cross(self,p):
        return ((self.x * p.y) - ((self.y * p.x)))

    def toPoint(self,scale = None):
        if (scale is None):
            scale = 1.
        return h2d_col_Point((self.x * scale),(self.y * scale))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
h2d_col_IPoint._hx_class = h2d_col_IPoint
_hx_classes["h2d.col.IPoint"] = h2d_col_IPoint

class h2d_col_OffsetKind(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.col.OffsetKind"
    _hx_constructs = ["Square", "Miter", "Round"]

    @staticmethod
    def Round(arc):
        return h2d_col_OffsetKind("Round", 2, (arc,))
h2d_col_OffsetKind.Square = h2d_col_OffsetKind("Square", 0, ())
h2d_col_OffsetKind.Miter = h2d_col_OffsetKind("Miter", 1, ())
h2d_col_OffsetKind._hx_class = h2d_col_OffsetKind
_hx_classes["h2d.col.OffsetKind"] = h2d_col_OffsetKind


class h2d_col__IPolygon_IPolygon_Impl_:
    _hx_class_name = "h2d.col._IPolygon.IPolygon_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_length", "get_points", "_new", "iterator", "toPolygon", "getBounds", "union", "intersection", "subtraction", "offset", "clipperOp", "convexHull", "isClockwise", "area", "side", "isConvex", "reverse", "contains", "optimize", "optimizeRec"]
    points = None
    length = None

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def get_points(this1):
        return this1

    @staticmethod
    def _new(points = None):
        this1 = ([] if ((points is None)) else points)
        return this1

    @staticmethod
    def iterator(this1):
        return hxd_impl_ArrayIterator_h2d_col_IPoint(this1)

    @staticmethod
    def toPolygon(this1,scale = None):
        if (scale is None):
            scale = 1.
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            p = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            scale1 = scale
            if (scale1 is None):
                scale1 = 1.
            x = h2d_col_Point((p.x * scale1),(p.y * scale1))
            _g.append(x)
        return _g

    @staticmethod
    def getBounds(this1,b = None):
        if (b is None):
            b = h2d_col_IBounds()
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (p.x < b.xMin):
                b.xMin = p.x
            if (p.x > b.xMax):
                b.xMax = p.x
            if (p.y < b.yMin):
                b.yMin = p.y
            if (p.y > b.yMax):
                b.yMax = p.y
        return b

    @staticmethod
    def union(this1,p,withHoles = None):
        if (withHoles is None):
            withHoles = True
        c = hxd_clipper_Clipper()
        if (not withHoles):
            c.resultKind = hxd_clipper_ResultKind.NoHoles
        c.addPolygon(this1,hxd_clipper_PolyType.Clip)
        c.addPolygon(p,hxd_clipper_PolyType.Clip)
        return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    @staticmethod
    def intersection(this1,p,withHoles = None):
        if (withHoles is None):
            withHoles = True
        return h2d_col__IPolygon_IPolygon_Impl_.clipperOp(this1,p,hxd_clipper_ClipType.Intersection,withHoles)

    @staticmethod
    def subtraction(this1,p,withHoles = None):
        if (withHoles is None):
            withHoles = True
        return h2d_col__IPolygon_IPolygon_Impl_.clipperOp(this1,p,hxd_clipper_ClipType.Difference,withHoles)

    @staticmethod
    def offset(this1,delta,kind,withHoles = None):
        if (withHoles is None):
            withHoles = True
        c = hxd_clipper_ClipperOffset()
        tmp = kind.index
        if (tmp == 0):
            c.addPolygon(this1,hxd_clipper_JoinType.Square,hxd_clipper_EndType.ClosedPol)
        elif (tmp == 1):
            c.addPolygon(this1,hxd_clipper_JoinType.Miter,hxd_clipper_EndType.ClosedPol)
        elif (tmp == 2):
            arc = kind.params[0]
            c.ArcTolerance = arc
            c.addPolygon(this1,hxd_clipper_JoinType.Round,hxd_clipper_EndType.ClosedPol)
        else:
            pass
        if (not withHoles):
            c.resultKind = hxd_clipper_ResultKind.NoHoles
        return c.execute(delta)

    @staticmethod
    def clipperOp(this1,p,op,withHoles):
        c = hxd_clipper_Clipper()
        if (not withHoles):
            c.resultKind = hxd_clipper_ResultKind.NoHoles
        c.addPolygon(this1,hxd_clipper_PolyType.Subject)
        c.addPolygon(p,hxd_clipper_PolyType.Clip)
        return c.execute(op,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    @staticmethod
    def convexHull(this1):
        _hx_len = len(this1)
        if (_hx_len < 3):
            raise haxe_Exception.thrown("convexHull() needs at least 3 points")
        first = 0
        firstX = python_internal_ArrayImpl._get(this1, first).x
        _g = 1
        _g1 = len(this1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            px = python_internal_ArrayImpl._get(this1, i).x
            if (px < firstX):
                first = i
                firstX = px
        hull = []
        curr = first
        next = 0
        while True:
            hull.append(python_internal_ArrayImpl._get(this1, curr))
            next = HxOverrides.mod(((curr + 1)), _hx_len)
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p1 = python_internal_ArrayImpl._get(this1, i)
                p2 = python_internal_ArrayImpl._get(this1, curr)
                t = python_internal_ArrayImpl._get(this1, next)
                if (((((p2.x - p1.x)) * ((t.y - p1.y))) - ((((p2.y - p1.y)) * ((t.x - p1.x))))) < 0):
                    next = i
            curr = next
            if (not ((curr != first))):
                break
        return hull

    @staticmethod
    def isClockwise(this1):
        sum = 0.
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            sum = (sum + ((((p2.x - p1.x)) * ((p2.y + p1.y)))))
            p1 = p2
        return (sum < 0)

    @staticmethod
    def area(this1):
        sum = 0.
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            sum = (sum + (((p1.x * p2.y) - ((p2.x * p1.y)))))
            p1 = p2
        return (((-sum if ((sum < 0)) else sum)) * 0.5)

    @staticmethod
    def side(this1,p1,p2,t):
        return ((((p2.x - p1.x)) * ((t.y - p1.y))) - ((((p2.y - p1.y)) * ((t.x - p1.x)))))

    @staticmethod
    def isConvex(this1):
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 2))
        p2 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        p3 = python_internal_ArrayImpl._get(this1, 0)
        s = (((((p2.x - p1.x)) * ((p3.y - p1.y))) - ((((p2.y - p1.y)) * ((p3.x - p1.x))))) > 0)
        _g = 1
        _g1 = len(this1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p1 = p2
            p2 = p3
            p3 = python_internal_ArrayImpl._get(this1, i)
            if ((((((p2.x - p1.x)) * ((p3.y - p1.y))) - ((((p2.y - p1.y)) * ((p3.x - p1.x))))) > 0) != s):
                return False
        return True

    @staticmethod
    def reverse(this1):
        this1.reverse()

    @staticmethod
    def contains(this1,p,isConvex = None):
        if (isConvex is None):
            isConvex = False
        if isConvex:
            p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
            _g = 0
            _g1 = this1
            while (_g < len(_g1)):
                p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (((((p2.x - p1.x)) * ((p.y - p1.y))) - ((((p2.y - p1.y)) * ((p.x - p1.x))))) < 0):
                    return False
                p1 = p2
            return True
        else:
            w = 0
            p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
            _g = 0
            _g1 = this1
            while (_g < len(_g1)):
                p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (p2.y <= p.y):
                    if ((p1.y > p.y) and ((((((p1.x - p2.x)) * ((p.y - p2.y))) - ((((p1.y - p2.y)) * ((p.x - p2.x))))) > 0))):
                        w = (w + 1)
                elif ((p1.y <= p.y) and ((((((p1.x - p2.x)) * ((p.y - p2.y))) - ((((p1.y - p2.y)) * ((p.x - p2.x))))) < 0))):
                    w = (w - 1)
                p1 = p2
            return (w != 0)

    @staticmethod
    def optimize(this1,epsilon):
        out = []
        h2d_col__IPolygon_IPolygon_Impl_.optimizeRec(this1,0,len(this1),out,epsilon)
        return out

    @staticmethod
    def optimizeRec(points,index,_hx_len,out,epsilon):
        dmax = 0.
        pfirst = (points[index] if index >= 0 and index < len(points) else None)
        plast = python_internal_ArrayImpl._get(points, (_hx_len - 1))
        _g = (index + 1)
        _g1 = (_hx_len - 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p0 = (points[i] if i >= 0 and i < len(points) else None)
            A = (p0.x - pfirst.x)
            B = (p0.y - pfirst.y)
            C = (plast.x - pfirst.x)
            D = (plast.y - pfirst.y)
            dot = ((A * C) + ((B * D)))
            dist = ((C * C) + ((D * D)))
            param = -1.
            if (dist != 0):
                param = (dot / dist)
            xx = None
            yy = None
            if (param < 0):
                xx = pfirst.x
                yy = pfirst.y
            elif (param > 1):
                xx = plast.x
                yy = plast.y
            else:
                xx = (pfirst.x + ((param * C)))
                yy = (pfirst.y + ((param * D)))
            dx = (p0.x - xx)
            dy = (p0.y - yy)
            d = ((dx * dx) + ((dy * dy)))
            if (d > dmax):
                index = i
                dmax = d
        if (dmax >= epsilon):
            h2d_col__IPolygon_IPolygon_Impl_.optimizeRec(points,0,index,out,epsilon)
            if (len(out) != 0):
                out.pop()
            h2d_col__IPolygon_IPolygon_Impl_.optimizeRec(points,index,_hx_len,out,epsilon)
        else:
            out.append((points[index] if index >= 0 and index < len(points) else None))
            out.append(python_internal_ArrayImpl._get(points, (_hx_len - 1)))
h2d_col__IPolygon_IPolygon_Impl_._hx_class = h2d_col__IPolygon_IPolygon_Impl_
_hx_classes["h2d.col._IPolygon.IPolygon_Impl_"] = h2d_col__IPolygon_IPolygon_Impl_


class h2d_col__IPolygons_IPolygons_Impl_:
    _hx_class_name = "h2d.col._IPolygons.IPolygons_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_length", "get_polygons", "_new", "iterator", "toPolygons", "getBounds", "union", "intersection", "subtraction", "offset", "clipperOp", "contains", "optimize"]
    polygons = None
    length = None

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def get_polygons(this1):
        return this1

    @staticmethod
    def _new(polygons = None):
        this1 = ([] if ((polygons is None)) else polygons)
        return this1

    @staticmethod
    def iterator(this1):
        return hxd_impl_ArrayIterator_h2d_col_IPolygon(this1)

    @staticmethod
    def toPolygons(this1,scale = None):
        if (scale is None):
            scale = 1.
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            p = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = h2d_col__IPolygon_IPolygon_Impl_.toPolygon(p,scale)
            _g.append(x)
        return _g

    @staticmethod
    def getBounds(this1,b = None):
        if (b is None):
            b = h2d_col_IBounds()
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            h2d_col__IPolygon_IPolygon_Impl_.getBounds(p,b)
        return b

    @staticmethod
    def union(this1,p = None,withHoles = None):
        if (withHoles is None):
            withHoles = True
        c = hxd_clipper_Clipper()
        if (not withHoles):
            c.resultKind = hxd_clipper_ResultKind.NoHoles
        c.addPolygons(this1,hxd_clipper_PolyType.Clip)
        if (p is not None):
            c.addPolygons(p,hxd_clipper_PolyType.Clip)
        return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    @staticmethod
    def intersection(this1,p,withHoles = None):
        if (withHoles is None):
            withHoles = True
        return h2d_col__IPolygons_IPolygons_Impl_.clipperOp(this1,p,hxd_clipper_ClipType.Intersection,withHoles)

    @staticmethod
    def subtraction(this1,p,withHoles = None):
        if (withHoles is None):
            withHoles = True
        return h2d_col__IPolygons_IPolygons_Impl_.clipperOp(this1,p,hxd_clipper_ClipType.Difference,withHoles)

    @staticmethod
    def offset(this1,delta,kind,withHoles = None):
        if (withHoles is None):
            withHoles = True
        if (len(this1) == 0):
            polygons = None
            this2 = ([] if ((polygons is None)) else polygons)
            return this2
        c = hxd_clipper_ClipperOffset()
        tmp = kind.index
        if (tmp == 0):
            c.addPolygons(this1,hxd_clipper_JoinType.Square,hxd_clipper_EndType.ClosedPol)
        elif (tmp == 1):
            c.addPolygons(this1,hxd_clipper_JoinType.Miter,hxd_clipper_EndType.ClosedPol)
        elif (tmp == 2):
            arc = kind.params[0]
            c.ArcTolerance = arc
            c.addPolygons(this1,hxd_clipper_JoinType.Round,hxd_clipper_EndType.ClosedPol)
        else:
            pass
        if (not withHoles):
            c.resultKind = hxd_clipper_ResultKind.NoHoles
        return c.execute(delta)

    @staticmethod
    def clipperOp(this1,p,op,withHoles):
        c = hxd_clipper_Clipper()
        if (not withHoles):
            c.resultKind = hxd_clipper_ResultKind.NoHoles
        c.addPolygons(this1,hxd_clipper_PolyType.Subject)
        c.addPolygons(p,hxd_clipper_PolyType.Clip)
        return c.execute(op,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    @staticmethod
    def contains(this1,p,isConvex = None):
        if (isConvex is None):
            isConvex = False
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            pl = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if h2d_col__IPolygon_IPolygon_Impl_.contains(pl,p,isConvex):
                return True
        return False

    @staticmethod
    def optimize(this1,epsilon):
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            p = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = h2d_col__IPolygon_IPolygon_Impl_.optimize(p,epsilon)
            _g.append(x)
        return _g
h2d_col__IPolygons_IPolygons_Impl_._hx_class = h2d_col__IPolygons_IPolygons_Impl_
_hx_classes["h2d.col._IPolygons.IPolygons_Impl_"] = h2d_col__IPolygons_IPolygons_Impl_


class h2d_col_Matrix:
    _hx_class_name = "h2d.col.Matrix"
    _hx_is_interface = "False"
    __slots__ = ("a", "b", "c", "d", "x", "y")
    _hx_fields = ["a", "b", "c", "d", "x", "y"]
    _hx_methods = ["identity", "initTranslate", "initScale", "initRotate", "initSkew", "invert", "getDeterminant", "inverse", "transform", "translate", "translateX", "translateY", "prependTranslate", "prependTranslateX", "prependTranslateY", "multiply", "getScale", "scale", "scaleX", "scaleY", "rotate", "skew", "skewX", "skewY", "clone", "getPosition", "toString"]
    _hx_statics = ["tmp"]

    def __init__(self):
        self.a = 1
        self.b = 0
        self.c = 0
        self.d = 1
        self.x = 0
        self.y = 0

    def identity(self):
        self.a = 1
        self.b = 0
        self.c = 0
        self.d = 1
        self.x = 0
        self.y = 0

    def initTranslate(self,x,y):
        self.a = 1
        self.b = 0
        self.c = 0
        self.d = 1
        self.x = x
        self.y = y

    def initScale(self,sx,sy):
        self.a = sx
        self.b = 0
        self.c = 0
        self.d = sy
        self.x = 0
        self.y = 0

    def initRotate(self,angle):
        cos = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sin = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        self.a = cos
        self.b = sin
        self.c = -sin
        self.d = cos
        self.x = 0
        self.y = 0

    def initSkew(self,sx,sy):
        tanX = Math.tan(sx)
        tanY = Math.tan(sy)
        self.a = 1
        self.b = tanY
        self.c = tanX
        self.d = 1
        self.x = 0
        self.y = 0

    def invert(self):
        self.inverse(self)

    def getDeterminant(self):
        return ((self.a * self.d) - ((self.b * self.c)))

    def inverse(self,m):
        a = m.a
        b = m.b
        c = m.c
        d = m.d
        x = m.x
        y = m.y
        invDet = (1 / (((self.a * self.d) - ((self.b * self.c)))))
        self.a = (d * invDet)
        self.b = (-b * invDet)
        self.c = (-c * invDet)
        self.d = (a * invDet)
        self.x = ((((-x * d) + ((c * y)))) * invDet)
        self.y = ((((x * b) - ((a * y)))) * invDet)

    def transform(self,pt):
        return h2d_col_Point((((pt.x * self.a) + ((pt.y * self.c))) + self.x),(((pt.x * self.b) + ((pt.y * self.d))) + self.y))

    def translate(self,x,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + x)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + y)
        _hx_local_2.y

    def translateX(self,x):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + x)
        _hx_local_0.x

    def translateY(self,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.y
        _hx_local_0.y = (_hx_local_1 + y)
        _hx_local_0.y

    def prependTranslate(self,x,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + (((self.a * x) + ((self.c * y)))))
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + (((self.b * x) + ((self.d * y)))))
        _hx_local_2.y

    def prependTranslateX(self,x):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + ((self.a * x)))
        _hx_local_0.x

    def prependTranslateY(self,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.y
        _hx_local_0.y = (_hx_local_1 + ((self.d * y)))
        _hx_local_0.y

    def multiply(self,a,b):
        aa = a.a
        ab = a.b
        ac = a.c
        ad = a.d
        ax = a.x
        ay = a.y
        ba = b.a
        bb = b.b
        bc = b.c
        bd = b.d
        bx = b.x
        by = b.y
        self.a = ((aa * ba) + ((ab * bc)))
        self.b = ((aa * bb) + ((ab * bd)))
        self.c = ((ac * ba) + ((ad * bc)))
        self.d = ((ac * bb) + ((ad * bd)))
        self.x = (((ax * ba) + ((ay * bc))) + bx)
        self.y = (((ax * bb) + ((ay * bd))) + by)

    def getScale(self,p = None):
        if (p is None):
            p = h2d_col_Point()
        f = ((self.a * self.a) + ((self.b * self.b)))
        p.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = ((self.c * self.c) + ((self.d * self.d)))
        p.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if (((self.a * self.d) - ((self.b * self.c))) < 0):
            p.x = (p.x * -1)
            p.y = (p.y * -1)
        return p

    def scale(self,sx,sy):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.a
        _hx_local_0.a = (_hx_local_1 * sx)
        _hx_local_0.a
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.c
        _hx_local_2.c = (_hx_local_3 * sx)
        _hx_local_2.c
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.x
        _hx_local_4.x = (_hx_local_5 * sx)
        _hx_local_4.x
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.b
        _hx_local_6.b = (_hx_local_7 * sy)
        _hx_local_6.b
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.d
        _hx_local_8.d = (_hx_local_9 * sy)
        _hx_local_8.d
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.y
        _hx_local_10.y = (_hx_local_11 * sy)
        _hx_local_10.y

    def scaleX(self,sx):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.a
        _hx_local_0.a = (_hx_local_1 * sx)
        _hx_local_0.a
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.c
        _hx_local_2.c = (_hx_local_3 * sx)
        _hx_local_2.c
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.x
        _hx_local_4.x = (_hx_local_5 * sx)
        _hx_local_4.x

    def scaleY(self,sy):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.b
        _hx_local_0.b = (_hx_local_1 * sy)
        _hx_local_0.b
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.d
        _hx_local_2.d = (_hx_local_3 * sy)
        _hx_local_2.d
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.y
        _hx_local_4.y = (_hx_local_5 * sy)
        _hx_local_4.y

    def rotate(self,angle):
        _this = h2d_col_Matrix.tmp
        cos = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sin = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        _this.a = cos
        _this.b = sin
        _this.c = -sin
        _this.d = cos
        _this.x = 0
        _this.y = 0
        self.multiply(self,h2d_col_Matrix.tmp)

    def skew(self,sx,sy):
        aa = self.a
        ab = self.b
        ac = self.c
        ad = self.d
        ax = self.x
        ay = self.y
        bb = Math.tan(sy)
        bc = Math.tan(sx)
        self.a = (aa + ((ab * bc)))
        self.b = ((aa * bb) + ab)
        self.c = (ac + ((ad * bc)))
        self.d = ((ac * bb) + ad)
        self.x = (ax + ((ay * bc)))
        self.y = ((ax * bb) + ay)

    def skewX(self,sx):
        bc = Math.tan(sx)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.a
        _hx_local_0.a = (_hx_local_1 + ((self.b * bc)))
        _hx_local_0.a
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.c
        _hx_local_2.c = (_hx_local_3 + ((self.d * bc)))
        _hx_local_2.c
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.x
        _hx_local_4.x = (_hx_local_5 + ((self.y * bc)))
        _hx_local_4.x

    def skewY(self,sy):
        bb = Math.tan(sy)
        self.b = ((self.a * bb) + self.b)
        self.d = ((self.c * bb) + self.d)
        self.y = ((self.x * bb) + self.y)

    def clone(self):
        m = h2d_col_Matrix()
        m.a = self.a
        m.b = self.b
        m.c = self.c
        m.d = self.d
        m.x = self.x
        m.y = self.y
        return m

    def getPosition(self,p = None):
        if (p is None):
            p = h2d_col_Point()
        x = self.x
        y = self.y
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p.x = x
        p.y = y
        return p

    def toString(self):
        return (((((((((((((((("MAT=[\n" + "  [ ") + Std.string(hxd_Math.fmt(self.a))) + ", ") + Std.string(hxd_Math.fmt(self.b))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self.c))) + ", ") + Std.string(hxd_Math.fmt(self.d))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self.x))) + ", ") + Std.string(hxd_Math.fmt(self.y))) + " ]\n") + "]")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a = None
        _hx_o.b = None
        _hx_o.c = None
        _hx_o.d = None
        _hx_o.x = None
        _hx_o.y = None
h2d_col_Matrix._hx_class = h2d_col_Matrix
_hx_classes["h2d.col.Matrix"] = h2d_col_Matrix


class h2d_col_Point:
    _hx_class_name = "h2d.col.Point"
    _hx_is_interface = "False"
    __slots__ = ("x", "y")
    _hx_fields = ["x", "y"]
    _hx_methods = ["distanceSq", "distance", "toString", "sub", "add", "multiply", "equals", "dot", "lengthSq", "length", "normalize", "normalized", "set", "load", "scale", "clone", "cross", "lerp", "transform", "transformed", "transform2x2", "transformed2x2", "toIPoint", "rotate"]

    def __init__(self,x = None,y = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        self.x = x
        self.y = y

    def distanceSq(self,p):
        dx = (self.x - p.x)
        dy = (self.y - p.y)
        return ((dx * dx) + ((dy * dy)))

    def distance(self,p):
        dx = (self.x - p.x)
        dy = (self.y - p.y)
        f = ((dx * dx) + ((dy * dy)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def toString(self):
        return (((("{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + "}")

    def sub(self,p):
        return h2d_col_Point((self.x - p.x),(self.y - p.y))

    def add(self,p):
        return h2d_col_Point((self.x + p.x),(self.y + p.y))

    def multiply(self,v):
        return h2d_col_Point((self.x * v),(self.y * v))

    def equals(self,other):
        if (self.x == other.x):
            return (self.y == other.y)
        else:
            return False

    def dot(self,p):
        return ((self.x * p.x) + ((self.y * p.y)))

    def lengthSq(self):
        return ((self.x * self.x) + ((self.y * self.y)))

    def length(self):
        f = ((self.x * self.x) + ((self.y * self.y)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def normalize(self):
        k = ((self.x * self.x) + ((self.y * self.y)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y

    def normalized(self):
        k = ((self.x * self.x) + ((self.y * self.y)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        return h2d_col_Point((self.x * k),(self.y * k))

    def set(self,x = None,y = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        self.x = x
        self.y = y

    def load(self,p):
        self.x = p.x
        self.y = p.y

    def scale(self,f):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * f)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * f)
        _hx_local_2.y

    def clone(self):
        return h2d_col_Point(self.x,self.y)

    def cross(self,p):
        return ((self.x * p.y) - ((self.y * p.x)))

    def lerp(self,a,b,k):
        a1 = a.x
        self.x = (a1 + ((k * ((b.x - a1)))))
        a1 = a.y
        self.y = (a1 + ((k * ((a.y - a1)))))

    def transform(self,m):
        mx = (((m.a * self.x) + ((m.c * self.y))) + m.x)
        my = (((m.b * self.x) + ((m.d * self.y))) + m.y)
        self.x = mx
        self.y = my

    def transformed(self,m):
        mx = (((m.a * self.x) + ((m.c * self.y))) + m.x)
        my = (((m.b * self.x) + ((m.d * self.y))) + m.y)
        return h2d_col_Point(mx,my)

    def transform2x2(self,m):
        mx = ((m.a * self.x) + ((m.c * self.y)))
        my = ((m.b * self.x) + ((m.d * self.y)))
        self.x = mx
        self.y = my

    def transformed2x2(self,m):
        mx = ((m.a * self.x) + ((m.c * self.y)))
        my = ((m.b * self.x) + ((m.d * self.y)))
        return h2d_col_Point(mx,my)

    def toIPoint(self,scale = None):
        if (scale is None):
            scale = 1.
        return h2d_col_IPoint(Math.floor(((self.x * scale) + 0.5)),Math.floor(((self.y * scale) + 0.5)))

    def rotate(self,angle):
        c = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        s = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        x2 = ((self.x * c) - ((self.y * s)))
        y2 = ((self.x * s) + ((self.y * c)))
        self.x = x2
        self.y = y2

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
h2d_col_Point._hx_class = h2d_col_Point
_hx_classes["h2d.col.Point"] = h2d_col_Point


class h2d_col__Polygon_Polygon_Impl_:
    _hx_class_name = "h2d.col._Polygon.Polygon_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_length", "get_points", "_new", "iterator", "fastTriangulate", "toSegments", "toIPolygon", "getBounds", "getCollider", "xSort", "convexHull", "isClockwise", "area", "centroid", "side", "isConvex", "reverse", "transform", "contains", "findClosestPoint", "projectPoint", "distance", "distanceSq", "rayIntersection", "orientation", "onSegment", "intersect", "selfIntersecting", "optimize", "optimizeRec", "makeCircle"]
    points = None
    length = None

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def get_points(this1):
        return this1

    @staticmethod
    def _new(points = None):
        this1 = ([] if ((points is None)) else points)
        return this1

    @staticmethod
    def iterator(this1):
        return hxd_impl_ArrayIterator_h2d_col_Point(this1)

    @staticmethod
    def fastTriangulate(this1):
        return hxd_earcut_Earcut().triangulate_h2d_col_Point(this1)

    @staticmethod
    def toSegments(this1):
        segments = []
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            s = h2d_col_Segment(p1,p2)
            segments.append(s)
            p1 = p2
        return segments

    @staticmethod
    def toIPolygon(this1,scale = None):
        if (scale is None):
            scale = 1.
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            p = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            scale1 = scale
            if (scale1 is None):
                scale1 = 1.
            x = h2d_col_IPoint(Math.floor(((p.x * scale1) + 0.5)),Math.floor(((p.y * scale1) + 0.5)))
            _g.append(x)
        return _g

    @staticmethod
    def getBounds(this1,b = None):
        if (b is None):
            b = h2d_col_Bounds()
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (p.x < b.xMin):
                b.xMin = p.x
            if (p.x > b.xMax):
                b.xMax = p.x
            if (p.y < b.yMin):
                b.yMin = p.y
            if (p.y > b.yMax):
                b.yMax = p.y
        return b

    @staticmethod
    def getCollider(this1,isConvex = None):
        if (isConvex is None):
            isConvex = False
        return h2d_col_PolygonCollider([this1],isConvex)

    @staticmethod
    def xSort(this1,a,b):
        if (a.x == b.x):
            if (a.y < b.y):
                return -1
            else:
                return 1
        if (a.x < b.x):
            return -1
        else:
            return 1

    @staticmethod
    def convexHull(this1):
        _hx_len = len(this1)
        if (len(this1) < 3):
            return this1
        def _hx_local_0(a,b):
            if (a.x == b.x):
                if (a.y < b.y):
                    return -1
                else:
                    return 1
            elif (a.x < b.x):
                return -1
            else:
                return 1
        this1.sort(key= python_lib_Functools.cmp_to_key(_hx_local_0))
        hull = []
        k = 0
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            while True:
                tmp = None
                if (k >= 2):
                    p1 = python_internal_ArrayImpl._get(hull, (k - 2))
                    p2 = python_internal_ArrayImpl._get(hull, (k - 1))
                    tmp = (((((p2.x - p1.x)) * ((p.y - p1.y))) - ((((p2.y - p1.y)) * ((p.x - p1.x))))) <= 0)
                else:
                    tmp = False
                if (not tmp):
                    break
                k = (k - 1)
            tmp1 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(hull, tmp1, p)
        i = (len(this1) - 2)
        _hx_len = (k + 1)
        while (i >= 0):
            p = python_internal_ArrayImpl._get(this1, i)
            while True:
                tmp = None
                if (k >= _hx_len):
                    p1 = python_internal_ArrayImpl._get(hull, (k - 2))
                    p2 = python_internal_ArrayImpl._get(hull, (k - 1))
                    tmp = (((((p2.x - p1.x)) * ((p.y - p1.y))) - ((((p2.y - p1.y)) * ((p.x - p1.x))))) <= 0)
                else:
                    tmp = False
                if (not tmp):
                    break
                k = (k - 1)
            tmp1 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(hull, tmp1, p)
            i = (i - 1)
        while (len(hull) >= k):
            if (len(hull) != 0):
                hull.pop()
        return hull

    @staticmethod
    def isClockwise(this1):
        sum = 0.
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            sum = (sum + ((((p2.x - p1.x)) * ((p2.y + p1.y)))))
            p1 = p2
        return (sum < 0)

    @staticmethod
    def area(this1):
        sum = 0.
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            sum = (sum + (((p2.x * p1.y) - ((p1.x * p2.y)))))
            p1 = p2
        return (((-sum if ((sum < 0)) else sum)) * 0.5)

    @staticmethod
    def centroid(this1):
        A = 0.
        cx = 0.
        cy = 0.
        p0 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            a = ((p0.x * p.y) - ((p.x * p0.y)))
            cx = (cx + ((((p0.x + p.x)) * a)))
            cy = (cy + ((((p0.y + p.y)) * a)))
            A = (A + a)
            p0 = p
        A = (A * 0.5)
        cx = (cx * ((1 / ((6 * A)))))
        cy = (cy * ((1 / ((6 * A)))))
        return h2d_col_Point(cx,cy)

    @staticmethod
    def side(this1,p1,p2,t):
        return ((((p2.x - p1.x)) * ((t.y - p1.y))) - ((((p2.y - p1.y)) * ((t.x - p1.x)))))

    @staticmethod
    def isConvex(this1):
        if (len(this1) < 4):
            return True
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 2))
        p2 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        p3 = python_internal_ArrayImpl._get(this1, 0)
        s = (((((p2.x - p1.x)) * ((p3.y - p1.y))) - ((((p2.y - p1.y)) * ((p3.x - p1.x))))) > 0)
        _g = 1
        _g1 = len(this1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p1 = p2
            p2 = p3
            p3 = python_internal_ArrayImpl._get(this1, i)
            if ((((((p2.x - p1.x)) * ((p3.y - p1.y))) - ((((p2.y - p1.y)) * ((p3.x - p1.x))))) > 0) != s):
                return False
        return True

    @staticmethod
    def reverse(this1):
        this1.reverse()

    @staticmethod
    def transform(this1,mat):
        _g = 0
        _g1 = len(this1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pt = python_internal_ArrayImpl._get(this1, i)
            python_internal_ArrayImpl._set(this1, i, h2d_col_Point((((pt.x * mat.a) + ((pt.y * mat.c))) + mat.x),(((pt.x * mat.b) + ((pt.y * mat.d))) + mat.y)))

    @staticmethod
    def contains(this1,p,isConvex = None):
        if (isConvex is None):
            isConvex = False
        if isConvex:
            p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
            _g = 0
            _g1 = this1
            while (_g < len(_g1)):
                p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (((((p2.x - p1.x)) * ((p.y - p1.y))) - ((((p2.y - p1.y)) * ((p.x - p1.x))))) < 0):
                    return False
                p1 = p2
            return True
        else:
            w = 0
            p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
            _g = 0
            _g1 = this1
            while (_g < len(_g1)):
                p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (p2.y <= p.y):
                    if ((p1.y > p.y) and ((((((p1.x - p2.x)) * ((p.y - p2.y))) - ((((p1.y - p2.y)) * ((p.x - p2.x))))) > 0))):
                        w = (w + 1)
                elif ((p1.y <= p.y) and ((((((p1.x - p2.x)) * ((p.y - p2.y))) - ((((p1.y - p2.y)) * ((p.x - p2.x))))) < 0))):
                    w = (w - 1)
                p1 = p2
            return (w != 0)

    @staticmethod
    def findClosestPoint(this1,pt,maxDist):
        closest = None
        minDist = (maxDist * maxDist)
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            cp = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            dx = (cp.x - pt.x)
            dy = (cp.y - pt.y)
            sqDist = ((dx * dx) + ((dy * dy)))
            if (sqDist < minDist):
                closest = cp
                minDist = sqDist
        return closest

    @staticmethod
    def projectPoint(this1,pt):
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        closestProj = None
        minDistSq = 1e10
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p11 = p1
            p21 = p2
            _this_x = p11.x
            _this_y = p11.y
            _this_dx = (p21.x - _this_x)
            _this_dy = (p21.y - _this_y)
            _this_lenSq = ((_this_dx * _this_dx) + ((_this_dy * _this_dy)))
            _this_invLenSq = (1 / _this_lenSq)
            px = (pt.x - _this_x)
            py = (pt.y - _this_y)
            t = ((px * _this_dx) + ((py * _this_dy)))
            proj = None
            if (t < 0):
                proj = h2d_col_Point(_this_x,_this_y)
            elif (t > _this_lenSq):
                proj = h2d_col_Point((_this_x + _this_dx),(_this_y + _this_dy))
            else:
                tl2 = (t * _this_invLenSq)
                proj = h2d_col_Point((_this_x + ((tl2 * _this_dx))),(_this_y + ((tl2 * _this_dy))))
            dx = (proj.x - pt.x)
            dy = (proj.y - pt.y)
            distSq = ((dx * dx) + ((dy * dy)))
            if (distSq < minDistSq):
                closestProj = proj
                minDistSq = distSq
            p1 = p2
        return closestProj

    @staticmethod
    def distance(this1,pt,outside = None):
        f = h2d_col__Polygon_Polygon_Impl_.distanceSq(this1,pt,outside)
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    @staticmethod
    def distanceSq(this1,pt,outside = None):
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        minDistSq = 1e10
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p11 = p1
            p21 = p2
            s_x = p11.x
            s_y = p11.y
            s_dx = (p21.x - s_x)
            s_dy = (p21.y - s_y)
            s_lenSq = ((s_dx * s_dx) + ((s_dy * s_dy)))
            s_invLenSq = (1 / s_lenSq)
            if ((outside is None) or (((((s_dx * ((pt.y - s_y))) - ((s_dy * ((pt.x - s_x))))) < 0) == outside))):
                px = (pt.x - s_x)
                py = (pt.y - s_y)
                t = ((px * s_dx) + ((py * s_dy)))
                dist = None
                if (t < 0):
                    dist = ((px * px) + ((py * py)))
                elif (t > s_lenSq):
                    kx = (pt.x - ((s_x + s_dx)))
                    ky = (pt.y - ((s_y + s_dy)))
                    dist = ((kx * kx) + ((ky * ky)))
                else:
                    tl2 = (t * s_invLenSq)
                    pdx = ((s_x + ((tl2 * s_dx))) - pt.x)
                    pdy = ((s_y + ((tl2 * s_dy))) - pt.y)
                    dist = ((pdx * pdx) + ((pdy * pdy)))
                if (dist < minDistSq):
                    minDistSq = dist
            p1 = p2
        if (minDistSq == 1e10):
            return 0.
        else:
            return minDistSq

    @staticmethod
    def rayIntersection(this1,r,bestMatch):
        dmin = -1.
        p0 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((((r.lx * ((p0.y - r.py))) - ((r.ly * ((p0.x - r.px)))))) * (((r.lx * ((p.y - r.py))) - ((r.ly * ((p.x - r.px))))))) > 0):
                p0 = p
                continue
            u = ((((r.lx * ((p0.y - r.py))) - ((r.ly * ((p0.x - r.px)))))) / (((r.ly * ((p.x - p0.x))) - ((r.lx * ((p.y - p0.y)))))))
            x = (p0.x + ((u * ((p.x - p0.x)))))
            y = (p0.y + ((u * ((p.y - p0.y)))))
            dx = (x - r.px)
            dy = (y - r.py)
            d = ((dx * dx) + ((dy * dy)))
            if ((d < dmin) or ((dmin < 0))):
                if (not bestMatch):
                    if (d < 0):
                        return Math.NaN
                    else:
                        return python_lib_Math.sqrt(d)
                dmin = d
            p0 = p
        if (dmin < 0):
            return dmin
        elif (dmin < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(dmin)

    @staticmethod
    def orientation(this1,p,q,r):
        v = ((((q.x - p.x)) * ((r.y - p.y))) - ((((q.y - p.y)) * ((r.x - p.x)))))
        if (v == 0):
            return 0
        if (v > 0):
            return 1
        else:
            return -1

    @staticmethod
    def onSegment(this1,p,q,r):
        a = p.x
        b = q.x
        if (r.x > ((b if ((a < b)) else a))):
            return False
        a = p.x
        b = q.x
        if (r.x < ((b if ((a > b)) else a))):
            return False
        a = p.y
        b = q.y
        if (r.y > ((b if ((a < b)) else a))):
            return False
        a = p.y
        b = q.y
        if (r.y < ((b if ((a > b)) else a))):
            return False
        return True

    @staticmethod
    def intersect(this1,p1,q1,p2,q2):
        v = ((((q1.x - p1.x)) * ((p2.y - p1.y))) - ((((q1.y - p1.y)) * ((p2.x - p1.x)))))
        s1 = (0 if ((v == 0)) else (1 if ((v > 0)) else -1))
        v = ((((q1.x - p1.x)) * ((q2.y - p1.y))) - ((((q1.y - p1.y)) * ((q2.x - p1.x)))))
        s2 = (0 if ((v == 0)) else (1 if ((v > 0)) else -1))
        v = ((((q2.x - p2.x)) * ((p1.y - p2.y))) - ((((q2.y - p2.y)) * ((p1.x - p2.x)))))
        s3 = (0 if ((v == 0)) else (1 if ((v > 0)) else -1))
        v = ((((q2.x - p2.x)) * ((q1.y - p2.y))) - ((((q2.y - p2.y)) * ((q1.x - p2.x)))))
        s4 = (0 if ((v == 0)) else (1 if ((v > 0)) else -1))
        if ((s1 != s2) and ((s3 != s4))):
            return True
        tmp = None
        tmp1 = None
        tmp2 = None
        tmp3 = None
        if (s1 == 0):
            a = p1.x
            b = q1.x
            if (p2.x > ((b if ((a < b)) else a))):
                tmp3 = False
            else:
                a = p1.x
                b = q1.x
                if (p2.x < ((b if ((a > b)) else a))):
                    tmp3 = False
                else:
                    a = p1.y
                    b = q1.y
                    if (p2.y > ((b if ((a < b)) else a))):
                        tmp3 = False
                    else:
                        a = p1.y
                        b = q1.y
                        tmp3 = (False if ((p2.y < ((b if ((a > b)) else a)))) else True)
        else:
            tmp3 = False
        if (not tmp3):
            if (s2 == 0):
                a = p1.x
                b = q1.x
                if (q2.x > ((b if ((a < b)) else a))):
                    tmp2 = False
                else:
                    a = p1.x
                    b = q1.x
                    if (q2.x < ((b if ((a > b)) else a))):
                        tmp2 = False
                    else:
                        a = p1.y
                        b = q1.y
                        if (q2.y > ((b if ((a < b)) else a))):
                            tmp2 = False
                        else:
                            a = p1.y
                            b = q1.y
                            tmp2 = (False if ((q2.y < ((b if ((a > b)) else a)))) else True)
            else:
                tmp2 = False
        else:
            tmp2 = True
        if (not tmp2):
            if (s3 == 0):
                a = p2.x
                b = q2.x
                if (p1.x > ((b if ((a < b)) else a))):
                    tmp1 = False
                else:
                    a = p2.x
                    b = q2.x
                    if (p1.x < ((b if ((a > b)) else a))):
                        tmp1 = False
                    else:
                        a = p2.y
                        b = q2.y
                        if (p1.y > ((b if ((a < b)) else a))):
                            tmp1 = False
                        else:
                            a = p2.y
                            b = q2.y
                            tmp1 = (False if ((p1.y < ((b if ((a > b)) else a)))) else True)
            else:
                tmp1 = False
        else:
            tmp1 = True
        if (not tmp1):
            if (s4 == 0):
                a = p2.x
                b = q2.x
                if (q1.x > ((b if ((a < b)) else a))):
                    tmp = False
                else:
                    a = p2.x
                    b = q2.x
                    if (q1.x < ((b if ((a > b)) else a))):
                        tmp = False
                    else:
                        a = p2.y
                        b = q2.y
                        if (q1.y > ((b if ((a < b)) else a))):
                            tmp = False
                        else:
                            a = p2.y
                            b = q2.y
                            tmp = (False if ((q1.y < ((b if ((a > b)) else a)))) else True)
            else:
                tmp = False
        else:
            tmp = True
        if tmp:
            return True
        return False

    @staticmethod
    def selfIntersecting(this1):
        if (len(this1) < 4):
            return False
        _g = 0
        _g1 = (len(this1) - 2)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p1 = python_internal_ArrayImpl._get(this1, i)
            q1 = python_internal_ArrayImpl._get(this1, (i + 1))
            _g2 = (i + 2)
            _g3 = len(this1)
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                p2 = python_internal_ArrayImpl._get(this1, j)
                q2 = python_internal_ArrayImpl._get(this1, HxOverrides.mod(((j + 1)), len(this1)))
                if ((q2 != p1) and h2d_col__Polygon_Polygon_Impl_.intersect(this1,p1,q1,p2,q2)):
                    return True
        return False

    @staticmethod
    def optimize(this1,epsilon):
        out = []
        h2d_col__Polygon_Polygon_Impl_.optimizeRec(this1,0,(len(this1) - 1),out,epsilon)
        return out

    @staticmethod
    def optimizeRec(points,start,end,out,epsilon):
        dmax = 0.
        pfirst = (points[start] if start >= 0 and start < len(points) else None)
        plast = (points[end] if end >= 0 and end < len(points) else None)
        index = 0
        _g = (start + 1)
        _g1 = end
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p0 = (points[i] if i >= 0 and i < len(points) else None)
            A = (p0.x - pfirst.x)
            B = (p0.y - pfirst.y)
            C = (plast.x - pfirst.x)
            D = (plast.y - pfirst.y)
            dot = ((A * C) + ((B * D)))
            dist = ((C * C) + ((D * D)))
            param = -1.
            if (dist != 0):
                param = (dot / dist)
            xx = None
            yy = None
            if (param < 0):
                xx = pfirst.x
                yy = pfirst.y
            elif (param > 1):
                xx = plast.x
                yy = plast.y
            else:
                xx = (pfirst.x + ((param * C)))
                yy = (pfirst.y + ((param * D)))
            dx = (p0.x - xx)
            dy = (p0.y - yy)
            d = ((dx * dx) + ((dy * dy)))
            if (d > dmax):
                index = i
                dmax = d
        if (dmax >= ((epsilon * epsilon))):
            h2d_col__Polygon_Polygon_Impl_.optimizeRec(points,start,index,out,epsilon)
            if (len(out) != 0):
                out.pop()
            h2d_col__Polygon_Polygon_Impl_.optimizeRec(points,index,end,out,epsilon)
        else:
            out.append((points[start] if start >= 0 and start < len(points) else None))
            out.append((points[end] if end >= 0 and end < len(points) else None))

    @staticmethod
    def makeCircle(x,y,radius,npoints = None):
        if (npoints is None):
            npoints = 0
        if (npoints == 0):
            f = (((radius * 3.14) * 2) / 4)
            npoints = Math.ceil((-f if ((f < 0)) else f))
        if (npoints < 3):
            npoints = 3
        angle = (6.28318530717958623 / npoints)
        points = []
        _g = 0
        _g1 = npoints
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            a = (i * angle)
            x1 = h2d_col_Point(((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * radius) + x),((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * radius) + y))
            points.append(x1)
        this1 = ([] if ((points is None)) else points)
        return this1
h2d_col__Polygon_Polygon_Impl_._hx_class = h2d_col__Polygon_Polygon_Impl_
_hx_classes["h2d.col._Polygon.Polygon_Impl_"] = h2d_col__Polygon_Polygon_Impl_


class h2d_col_PolygonCollider:
    _hx_class_name = "h2d.col.PolygonCollider"
    _hx_is_interface = "False"
    __slots__ = ("polygons", "isConvex")
    _hx_fields = ["polygons", "isConvex"]
    _hx_methods = ["contains"]
    _hx_interfaces = [h2d_col_Collider]

    def __init__(self,polygons,isConvex = None):
        if (isConvex is None):
            isConvex = False
        self.polygons = polygons
        self.isConvex = isConvex

    def contains(self,p):
        if (self.polygons is None):
            return False
        return h2d_col__Polygons_Polygons_Impl_.contains(self.polygons,p,self.isConvex)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.polygons = None
        _hx_o.isConvex = None
h2d_col_PolygonCollider._hx_class = h2d_col_PolygonCollider
_hx_classes["h2d.col.PolygonCollider"] = h2d_col_PolygonCollider


class h2d_col__Polygons_Polygons_Impl_:
    _hx_class_name = "h2d.col._Polygons.Polygons_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_length", "get_polygons", "_new", "iterator", "toIPolygons", "getBounds", "getCollider", "contains", "optimize"]
    polygons = None
    length = None

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def get_polygons(this1):
        return this1

    @staticmethod
    def _new(polygons = None):
        this1 = ([] if ((polygons is None)) else polygons)
        return this1

    @staticmethod
    def iterator(this1):
        return hxd_impl_ArrayIterator_h2d_col_Polygon(this1)

    @staticmethod
    def toIPolygons(this1,scale = None):
        if (scale is None):
            scale = 1.
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            p = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = h2d_col__Polygon_Polygon_Impl_.toIPolygon(p,scale)
            _g.append(x)
        return _g

    @staticmethod
    def getBounds(this1,b = None):
        if (b is None):
            b = h2d_col_Bounds()
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            h2d_col__Polygon_Polygon_Impl_.getBounds(p,b)
        return b

    @staticmethod
    def getCollider(this1,isConvex = None):
        if (isConvex is None):
            isConvex = False
        return h2d_col_PolygonCollider(this1,isConvex)

    @staticmethod
    def contains(this1,p,isConvex = None):
        if (isConvex is None):
            isConvex = False
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            pl = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if h2d_col__Polygon_Polygon_Impl_.contains(pl,p,isConvex):
                return True
        return False

    @staticmethod
    def optimize(this1,epsilon):
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            p = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = h2d_col__Polygon_Polygon_Impl_.optimize(p,epsilon)
            _g.append(x)
        return _g
h2d_col__Polygons_Polygons_Impl_._hx_class = h2d_col__Polygons_Polygons_Impl_
_hx_classes["h2d.col._Polygons.Polygons_Impl_"] = h2d_col__Polygons_Polygons_Impl_


class h2d_col_Ray:
    _hx_class_name = "h2d.col.Ray"
    _hx_is_interface = "False"
    __slots__ = ("px", "py", "lx", "ly")
    _hx_fields = ["px", "py", "lx", "ly"]
    _hx_methods = ["side", "getPoint", "getPos", "getDir", "normalize"]
    _hx_statics = ["fromPoints", "fromValues"]

    def __init__(self):
        self.ly = None
        self.lx = None
        self.py = None
        self.px = None

    def side(self,p):
        return ((self.lx * ((p.y - self.py))) - ((self.ly * ((p.x - self.px)))))

    def getPoint(self,distance):
        return h2d_col_Point((self.px + ((distance * self.lx))),(self.py + ((distance * self.ly))))

    def getPos(self):
        return h2d_col_Point(self.px,self.py)

    def getDir(self):
        return h2d_col_Point(self.lx,self.ly)

    def normalize(self):
        l = ((self.lx * self.lx) + ((self.ly * self.ly)))
        if (l == 1.):
            return
        if (l < 1e-10):
            l = 0
        else:
            l = (1. / ((Math.NaN if ((l < 0)) else python_lib_Math.sqrt(l))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.lx
        _hx_local_0.lx = (_hx_local_1 * l)
        _hx_local_0.lx
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.ly
        _hx_local_2.ly = (_hx_local_3 * l)
        _hx_local_2.ly

    @staticmethod
    def fromPoints(p1,p2):
        r = h2d_col_Ray()
        r.px = p1.x
        r.py = p1.y
        r.lx = (p2.x - p1.x)
        r.ly = (p2.y - p1.y)
        r.normalize()
        return r

    @staticmethod
    def fromValues(x,y,dx,dy):
        r = h2d_col_Ray()
        r.px = x
        r.py = y
        r.lx = dx
        r.ly = dy
        r.normalize()
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.px = None
        _hx_o.py = None
        _hx_o.lx = None
        _hx_o.ly = None
h2d_col_Ray._hx_class = h2d_col_Ray
_hx_classes["h2d.col.Ray"] = h2d_col_Ray


class h2d_col_Segment:
    _hx_class_name = "h2d.col.Segment"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "dx", "dy", "lenSq", "invLenSq")
    _hx_fields = ["x", "y", "dx", "dy", "lenSq", "invLenSq"]
    _hx_methods = ["setPoints", "side", "distanceSq", "distance", "project", "lineIntersection"]

    def __init__(self,p1,p2):
        self.invLenSq = None
        self.lenSq = None
        self.dy = None
        self.dx = None
        self.x = p1.x
        self.y = p1.y
        self.dx = (p2.x - self.x)
        self.dy = (p2.y - self.y)
        self.lenSq = ((self.dx * self.dx) + ((self.dy * self.dy)))
        self.invLenSq = (1 / self.lenSq)

    def setPoints(self,p1,p2):
        self.x = p1.x
        self.y = p1.y
        self.dx = (p2.x - self.x)
        self.dy = (p2.y - self.y)
        self.lenSq = ((self.dx * self.dx) + ((self.dy * self.dy)))
        self.invLenSq = (1 / self.lenSq)

    def side(self,p):
        return ((self.dx * ((p.y - self.y))) - ((self.dy * ((p.x - self.x)))))

    def distanceSq(self,p):
        px = (p.x - self.x)
        py = (p.y - self.y)
        t = ((px * self.dx) + ((py * self.dy)))
        if (t < 0):
            return ((px * px) + ((py * py)))
        elif (t > self.lenSq):
            kx = (p.x - ((self.x + self.dx)))
            ky = (p.y - ((self.y + self.dy)))
            return ((kx * kx) + ((ky * ky)))
        else:
            tl2 = (t * self.invLenSq)
            pdx = ((self.x + ((tl2 * self.dx))) - p.x)
            pdy = ((self.y + ((tl2 * self.dy))) - p.y)
            return ((pdx * pdx) + ((pdy * pdy)))

    def distance(self,p):
        px = (p.x - self.x)
        py = (p.y - self.y)
        t = ((px * self.dx) + ((py * self.dy)))
        f = None
        if (t < 0):
            f = ((px * px) + ((py * py)))
        elif (t > self.lenSq):
            kx = (p.x - ((self.x + self.dx)))
            ky = (p.y - ((self.y + self.dy)))
            f = ((kx * kx) + ((ky * ky)))
        else:
            tl2 = (t * self.invLenSq)
            pdx = ((self.x + ((tl2 * self.dx))) - p.x)
            pdy = ((self.y + ((tl2 * self.dy))) - p.y)
            f = ((pdx * pdx) + ((pdy * pdy)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def project(self,p):
        px = (p.x - self.x)
        py = (p.y - self.y)
        t = ((px * self.dx) + ((py * self.dy)))
        if (t < 0):
            return h2d_col_Point(self.x,self.y)
        elif (t > self.lenSq):
            return h2d_col_Point((self.x + self.dx),(self.y + self.dy))
        else:
            tl2 = (t * self.invLenSq)
            return h2d_col_Point((self.x + ((tl2 * self.dx))),(self.y + ((tl2 * self.dy))))

    def lineIntersection(self,r,pt = None):
        x = self.x
        y = self.y
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        x = (self.x + self.dx)
        y = (self.y + self.dy)
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x1 = x
        p_y1 = y
        if (((((r.lx * ((p_y - r.py))) - ((r.ly * ((p_x - r.px)))))) * (((r.lx * ((p_y1 - r.py))) - ((r.ly * ((p_x1 - r.px))))))) > 0):
            return None
        u = ((((r.lx * ((self.y - r.py))) - ((r.ly * ((self.x - r.px)))))) / (((r.ly * self.dx) - ((r.lx * self.dy)))))
        if ((u < 0) or ((u > 1))):
            return None
        if (pt is None):
            pt = h2d_col_Point()
        pt.x = (self.x + ((u * self.dx)))
        pt.y = (self.y + ((u * self.dy)))
        return pt

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.dx = None
        _hx_o.dy = None
        _hx_o.lenSq = None
        _hx_o.invLenSq = None
h2d_col_Segment._hx_class = h2d_col_Segment
_hx_classes["h2d.col.Segment"] = h2d_col_Segment


class h2d_col__Segments_Segments_Impl_:
    _hx_class_name = "h2d.col._Segments.Segments_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_segments", "get_length", "iterator", "containsPoint", "toPolygon", "project", "distanceSq", "distance"]
    segments = None
    length = None

    @staticmethod
    def get_segments(this1):
        return this1

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def iterator(this1):
        return hxd_impl_ArrayIterator_h2d_col_Segment(this1)

    @staticmethod
    def containsPoint(this1,p,isConvex):
        if isConvex:
            _g = 0
            _g1 = this1
            while (_g < len(_g1)):
                s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (((s.dx * ((p.y - s.y))) - ((s.dy * ((p.x - s.x))))) < 0):
                    return False
        else:
            raise haxe_Exception.thrown("TODO")
        return True

    @staticmethod
    def toPolygon(this1):
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            s = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = h2d_col_Point(s.x,s.y)
            _g.append(x)
        return _g

    @staticmethod
    def project(this1,p):
        dmin = 1e20
        smin = None
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            px = (p.x - s.x)
            py = (p.y - s.y)
            t = ((px * s.dx) + ((py * s.dy)))
            d = None
            if (t < 0):
                d = ((px * px) + ((py * py)))
            elif (t > s.lenSq):
                kx = (p.x - ((s.x + s.dx)))
                ky = (p.y - ((s.y + s.dy)))
                d = ((kx * kx) + ((ky * ky)))
            else:
                tl2 = (t * s.invLenSq)
                pdx = ((s.x + ((tl2 * s.dx))) - p.x)
                pdy = ((s.y + ((tl2 * s.dy))) - p.y)
                d = ((pdx * pdx) + ((pdy * pdy)))
            if (d < dmin):
                dmin = d
                smin = s
        px = (p.x - smin.x)
        py = (p.y - smin.y)
        t = ((px * smin.dx) + ((py * smin.dy)))
        if (t < 0):
            return h2d_col_Point(smin.x,smin.y)
        elif (t > smin.lenSq):
            return h2d_col_Point((smin.x + smin.dx),(smin.y + smin.dy))
        else:
            tl2 = (t * smin.invLenSq)
            return h2d_col_Point((smin.x + ((tl2 * smin.dx))),(smin.y + ((tl2 * smin.dy))))

    @staticmethod
    def distanceSq(this1,p):
        dmin = 1e20
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            px = (p.x - s.x)
            py = (p.y - s.y)
            t = ((px * s.dx) + ((py * s.dy)))
            d = None
            if (t < 0):
                d = ((px * px) + ((py * py)))
            elif (t > s.lenSq):
                kx = (p.x - ((s.x + s.dx)))
                ky = (p.y - ((s.y + s.dy)))
                d = ((kx * kx) + ((ky * ky)))
            else:
                tl2 = (t * s.invLenSq)
                pdx = ((s.x + ((tl2 * s.dx))) - p.x)
                pdy = ((s.y + ((tl2 * s.dy))) - p.y)
                d = ((pdx * pdx) + ((pdy * pdy)))
            if (d < dmin):
                dmin = d
        return dmin

    @staticmethod
    def distance(this1,p):
        f = h2d_col__Segments_Segments_Impl_.distanceSq(this1,p)
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)
h2d_col__Segments_Segments_Impl_._hx_class = h2d_col__Segments_Segments_Impl_
_hx_classes["h2d.col._Segments.Segments_Impl_"] = h2d_col__Segments_Segments_Impl_


class h2d_filter_Filter:
    _hx_class_name = "h2d.filter.Filter"
    _hx_is_interface = "False"
    __slots__ = ("autoBounds", "boundsExtend", "smooth", "enable")
    _hx_fields = ["autoBounds", "boundsExtend", "smooth", "enable"]
    _hx_methods = ["get_enable", "set_enable", "sync", "bind", "unbind", "getBounds", "draw"]

    def __init__(self):
        self.enable = True
        self.smooth = False
        self.boundsExtend = 0.
        self.autoBounds = True

    def get_enable(self):
        return self.enable

    def set_enable(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.enable = v
                return self.enable
            return _hx_local_0()
        return _hx_local_1()

    def sync(self,ctx,s):
        pass

    def bind(self,s):
        pass

    def unbind(self,s):
        pass

    def getBounds(self,s,bounds):
        s.getBounds(s,bounds)
        bounds.xMin = (bounds.xMin - self.boundsExtend)
        bounds.yMin = (bounds.yMin - self.boundsExtend)
        bounds.xMax = (bounds.xMax + self.boundsExtend)
        bounds.yMax = (bounds.yMax + self.boundsExtend)

    def draw(self,ctx,input):
        return input

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.autoBounds = None
        _hx_o.boundsExtend = None
        _hx_o.smooth = None
h2d_filter_Filter._hx_class = h2d_filter_Filter
_hx_classes["h2d.filter.Filter"] = h2d_filter_Filter


class h2d_impl_BatchDrawState:
    _hx_class_name = "h2d.impl.BatchDrawState"
    _hx_is_interface = "False"
    __slots__ = ("totalCount", "head", "tail")
    _hx_fields = ["totalCount", "head", "tail"]
    _hx_methods = ["setTile", "setTexture", "add", "clear", "drawQuads", "drawIndexed", "get_currentTexture"]

    def __init__(self):
        def _hx_local_0():
            self.tail = h2d_impl__BatchDrawState_StateEntry(None)
            return self.tail
        self.head = _hx_local_0()
        self.totalCount = 0

    def setTile(self,tile):
        if (tile is not None):
            self.setTexture(tile.innerTex)

    def setTexture(self,texture):
        if (texture is not None):
            if (self.tail.texture is None):
                self.tail.texture = texture
            elif (self.tail.texture != texture):
                cur = self.tail
                if (cur.next is None):
                    def _hx_local_0():
                        self.tail = h2d_impl__BatchDrawState_StateEntry(texture)
                        return self.tail
                    cur.next = _hx_local_0()
                else:
                    self.tail = cur.next.set(texture)

    def add(self,count):
        _hx_local_0 = self.tail
        _hx_local_1 = _hx_local_0.count
        _hx_local_0.count = (_hx_local_1 + count)
        _hx_local_0.count
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.totalCount
        _hx_local_2.totalCount = (_hx_local_3 + count)
        _hx_local_2.totalCount

    def clear(self):
        state = self.head
        while True:
            state.texture = None
            state = state.next
            if (not ((state is not None))):
                break
        self.tail = self.head
        self.tail.count = 0
        self.totalCount = 0

    def drawQuads(self,ctx,buffer,offset = None,length = None):
        if (offset is None):
            offset = 0
        if (length is None):
            length = -1
        state = self.head
        last = self.tail.next
        engine = ctx.engine
        stateLen = None
        if ((offset == 0) and ((length == -1))):
            while True:
                ctx.texture = state.texture
                ctx.beforeDraw()
                stateLen = (state.count >> 1)
                start = offset
                _hx_max = stateLen
                if (_hx_max is None):
                    _hx_max = -1
                if (start is None):
                    start = 0
                engine.renderBuffer(buffer,engine.mem.quadIndexes,2,start,_hx_max)
                offset = (offset + stateLen)
                state = state.next
                if (not ((state != last))):
                    break
        else:
            if (length == -1):
                length = (((self.totalCount >> 1)) - offset)
            caret = 0
            while True:
                stateLen = (state.count >> 1)
                if ((caret + stateLen) >= offset):
                    stateMin = (offset if ((offset >= caret)) else caret)
                    stateLen1 = (stateLen if ((length > stateLen)) else length)
                    ctx.texture = state.texture
                    ctx.beforeDraw()
                    start = stateMin
                    _hx_max = stateLen1
                    if (_hx_max is None):
                        _hx_max = -1
                    if (start is None):
                        start = 0
                    engine.renderBuffer(buffer,engine.mem.quadIndexes,2,start,_hx_max)
                    length = (length - stateLen1)
                    if (length == 0):
                        break
                caret = (caret + stateLen)
                state = state.next
                if (not ((state != last))):
                    break

    def drawIndexed(self,ctx,buffer,indices,offset = None,length = None):
        if (offset is None):
            offset = 0
        if (length is None):
            length = -1
        state = self.head
        last = self.tail.next
        engine = ctx.engine
        stateLen = None
        if ((offset == 0) and ((length == -1))):
            while True:
                ctx.texture = state.texture
                ctx.beforeDraw()
                count = state.count
                stateLen1 = None
                try:
                    stateLen1 = int((count / 3))
                except BaseException as _g:
                    None
                    stateLen1 = None
                stateLen = stateLen1
                engine.renderIndexed(buffer,indices,offset,stateLen)
                offset = (offset + stateLen)
                state = state.next
                if (not ((state != last))):
                    break
        else:
            if (length == -1):
                count = self.totalCount
                length1 = None
                try:
                    length1 = int((count / 3))
                except BaseException as _g:
                    None
                    length1 = None
                length = length1
            caret = 0
            while True:
                count = state.count
                stateLen1 = None
                try:
                    stateLen1 = int((count / 3))
                except BaseException as _g:
                    None
                    stateLen1 = None
                stateLen = stateLen1
                if ((caret + stateLen) >= offset):
                    stateMin = (offset if ((offset >= caret)) else caret)
                    stateLen2 = (stateLen if ((length > stateLen)) else length)
                    ctx.texture = state.texture
                    ctx.beforeDraw()
                    engine.renderIndexed(buffer,indices,stateMin,stateLen2)
                    length = (length - stateLen2)
                    if (length == 0):
                        break
                caret = (caret + stateLen)
                state = state.next
                if (not ((state != last))):
                    break

    def get_currentTexture(self):
        return self.tail.texture

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.totalCount = None
        _hx_o.head = None
        _hx_o.tail = None
h2d_impl_BatchDrawState._hx_class = h2d_impl_BatchDrawState
_hx_classes["h2d.impl.BatchDrawState"] = h2d_impl_BatchDrawState


class h2d_impl__BatchDrawState_StateEntry:
    _hx_class_name = "h2d.impl._BatchDrawState.StateEntry"
    _hx_is_interface = "False"
    __slots__ = ("texture", "count", "next")
    _hx_fields = ["texture", "count", "next"]
    _hx_methods = ["set"]

    def __init__(self,texture):
        self.next = None
        self.texture = texture
        self.count = 0

    def set(self,texture):
        self.texture = texture
        self.count = 0
        return self

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture = None
        _hx_o.count = None
        _hx_o.next = None
h2d_impl__BatchDrawState_StateEntry._hx_class = h2d_impl__BatchDrawState_StateEntry
_hx_classes["h2d.impl._BatchDrawState.StateEntry"] = h2d_impl__BatchDrawState_StateEntry

class h3d_BufferFlag(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.BufferFlag"
    _hx_constructs = ["Dynamic", "Triangles", "Quads", "Managed", "RawFormat", "NoAlloc", "UniformBuffer", "LargeBuffer"]
h3d_BufferFlag.Dynamic = h3d_BufferFlag("Dynamic", 0, ())
h3d_BufferFlag.Triangles = h3d_BufferFlag("Triangles", 1, ())
h3d_BufferFlag.Quads = h3d_BufferFlag("Quads", 2, ())
h3d_BufferFlag.Managed = h3d_BufferFlag("Managed", 3, ())
h3d_BufferFlag.RawFormat = h3d_BufferFlag("RawFormat", 4, ())
h3d_BufferFlag.NoAlloc = h3d_BufferFlag("NoAlloc", 5, ())
h3d_BufferFlag.UniformBuffer = h3d_BufferFlag("UniformBuffer", 6, ())
h3d_BufferFlag.LargeBuffer = h3d_BufferFlag("LargeBuffer", 7, ())
h3d_BufferFlag._hx_class = h3d_BufferFlag
_hx_classes["h3d.BufferFlag"] = h3d_BufferFlag


class h3d_Buffer:
    _hx_class_name = "h3d.Buffer"
    _hx_is_interface = "False"
    __slots__ = ("id", "buffer", "position", "vertices", "next", "flags")
    _hx_fields = ["id", "buffer", "position", "vertices", "next", "flags"]
    _hx_methods = ["isDisposed", "dispose", "totalVertices", "uploadVector", "uploadBytes", "readBytes"]
    _hx_statics = ["GUID", "ofFloats", "ofSubFloats"]

    def __init__(self,vertices,stride,flags = None):
        self.next = None
        self.position = None
        self.buffer = None
        def _hx_local_2():
            _hx_local_0 = h3d_Buffer
            _hx_local_1 = _hx_local_0.GUID
            _hx_local_0.GUID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()
        self.vertices = vertices
        this1 = 0
        self.flags = this1
        if (flags is not None):
            _g = 0
            while (_g < len(flags)):
                f = (flags[_g] if _g >= 0 and _g < len(flags) else None)
                _g = (_g + 1)
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.flags
                _hx_local_4.flags = (_hx_local_5 | ((1 << f.index)))
                _hx_local_4.flags
        if (((self.flags & ((1 << h3d_BufferFlag.NoAlloc.index)))) == 0):
            h3d_Engine.CURRENT.mem.allocBuffer(self,stride)

    def isDisposed(self):
        if (self.buffer is not None):
            return (self.buffer.vbuf is None)
        else:
            return True

    def dispose(self):
        if (self.buffer is not None):
            self.buffer.freeBuffer(self)
            self.buffer = None
            if (self.next is not None):
                self.next.dispose()

    def totalVertices(self):
        count = 0
        b = self
        while (b is not None):
            count = (count + b.vertices)
            b = b.next
        return count

    def uploadVector(self,buf,bufPos,vertices,startVertice = None):
        if (startVertice is None):
            startVertice = 0
        cur = self
        while ((cur is not None) and ((startVertice >= cur.vertices))):
            startVertice = (startVertice - cur.vertices)
            cur = cur.next
        while (vertices > 0):
            if (cur is None):
                raise haxe_Exception.thrown("Too many vertices")
            count = ((cur.vertices - startVertice) if (((vertices + startVertice) > cur.vertices)) else vertices)
            cur.buffer.uploadVertexBuffer((cur.position + startVertice),count,buf,bufPos)
            startVertice = 0
            bufPos = (bufPos + ((count * self.buffer.stride)))
            vertices = (vertices - count)
            cur = cur.next

    def uploadBytes(self,data,dataPos,vertices):
        cur = self
        while (vertices > 0):
            if (cur is None):
                raise haxe_Exception.thrown("Too many vertices")
            count = (cur.vertices if ((vertices > cur.vertices)) else vertices)
            cur.buffer.uploadVertexBytes(cur.position,count,data,dataPos)
            dataPos = (dataPos + (((count * self.buffer.stride) * 4)))
            vertices = (vertices - count)
            cur = cur.next

    def readBytes(self,_hx_bytes,bytesPosition,vertices,startVertice = None):
        if (startVertice is None):
            startVertice = 0
        cur = self
        while ((cur is not None) and ((startVertice >= cur.vertices))):
            startVertice = (startVertice - cur.vertices)
            cur = cur.next
        while (vertices > 0):
            if (cur is None):
                raise haxe_Exception.thrown("Too many vertices")
            count = ((cur.vertices - startVertice) if (((vertices + startVertice) > cur.vertices)) else vertices)
            cur.buffer.readVertexBytes((cur.position + startVertice),count,_hx_bytes,bytesPosition)
            startVertice = 0
            bytesPosition = (bytesPosition + (((count * self.buffer.stride) * 4)))
            vertices = (vertices - count)
            cur = cur.next

    @staticmethod
    def ofFloats(v,stride,flags = None):
        x = (len(v) / stride)
        nvert = None
        try:
            nvert = int(x)
        except BaseException as _g:
            None
            nvert = None
        b = h3d_Buffer(nvert,stride,flags)
        b.uploadVector(v,0,nvert)
        return b

    @staticmethod
    def ofSubFloats(v,stride,vertices,flags = None):
        b = h3d_Buffer(vertices,stride,flags)
        b.uploadVector(v,0,vertices)
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.buffer = None
        _hx_o.position = None
        _hx_o.vertices = None
        _hx_o.next = None
        _hx_o.flags = None
h3d_Buffer._hx_class = h3d_Buffer
_hx_classes["h3d.Buffer"] = h3d_Buffer


class h3d_BufferOffset:
    _hx_class_name = "h3d.BufferOffset"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "offset", "next")
    _hx_fields = ["buffer", "offset", "next"]
    _hx_methods = ["clone", "dispose"]

    def __init__(self,buffer,offset):
        self.next = None
        self.buffer = buffer
        self.offset = offset

    def clone(self):
        b = h3d_BufferOffset(self.buffer,self.offset)
        return b

    def dispose(self):
        if (self.buffer is not None):
            self.buffer.dispose()
            self.buffer = None
        self.next = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.offset = None
        _hx_o.next = None
h3d_BufferOffset._hx_class = h3d_BufferOffset
_hx_classes["h3d.BufferOffset"] = h3d_BufferOffset


class h3d_Camera:
    _hx_class_name = "h3d.Camera"
    _hx_is_interface = "False"
    __slots__ = ("zoom", "screenRatio", "fovY", "zNear", "zFar", "orthoBounds", "rightHanded", "mproj", "mcam", "m", "pos", "up", "target", "viewX", "viewY", "follow", "frustum", "minv", "mcamInv", "mprojInv", "needInv")
    _hx_fields = ["zoom", "screenRatio", "fovY", "zNear", "zFar", "orthoBounds", "rightHanded", "mproj", "mcam", "m", "pos", "up", "target", "viewX", "viewY", "follow", "frustum", "minv", "mcamInv", "mprojInv", "needInv"]
    _hx_methods = ["setFovX", "getFovX", "clone", "getInverseViewProj", "getInverseProj", "getInverseView", "setCubeMap", "unproject", "rayFromScreen", "update", "getFrustumCorners", "lostUp", "getViewDirection", "movePosAxis", "moveTargetAxis", "forward", "backward", "makeCameraMatrix", "setTransform", "makeFrustumMatrix", "project", "load"]

    def __init__(self,fovY = None,zoom = None,screenRatio = None,zNear = None,zFar = None,rightHanded = None):
        if (fovY is None):
            fovY = 25.
        if (zoom is None):
            zoom = 1.
        if (screenRatio is None):
            screenRatio = 1.333333
        if (zNear is None):
            zNear = 0.02
        if (zFar is None):
            zFar = 4000.
        if (rightHanded is None):
            rightHanded = False
        self.needInv = None
        self.mprojInv = None
        self.mcamInv = None
        self.minv = None
        self.follow = None
        self.orthoBounds = None
        self.viewY = 0.
        self.viewX = 0.
        self.fovY = fovY
        self.zoom = zoom
        self.screenRatio = screenRatio
        self.zNear = zNear
        self.zFar = zFar
        self.rightHanded = rightHanded
        self.pos = h3d_Vector(2,3,4)
        self.up = h3d_Vector(0,0,1)
        self.target = h3d_Vector(0,0,0)
        self.m = h3d_Matrix()
        self.mcam = h3d_Matrix()
        self.mproj = h3d_Matrix()
        self.frustum = h3d_col_Frustum()
        self.update()

    def setFovX(self,fovX,withRatio):
        degToRad = (Math.PI / 180)
        self.fovY = ((2 * Math.atan((Math.tan(((fovX * 0.5) * degToRad)) / withRatio))) / degToRad)

    def getFovX(self):
        degToRad = (Math.PI / 180)
        halfFovX = Math.atan((Math.tan(((self.fovY * 0.5) * degToRad)) * self.screenRatio))
        fovX = ((halfFovX * 2) / degToRad)
        return fovX

    def clone(self):
        c = h3d_Camera(self.fovY,self.zoom,self.screenRatio,self.zNear,self.zFar,self.rightHanded)
        _this = self.pos
        c.pos = h3d_Vector(_this.x,_this.y,_this.z,_this.w)
        _this = self.up
        c.up = h3d_Vector(_this.x,_this.y,_this.z,_this.w)
        _this = self.target
        c.target = h3d_Vector(_this.x,_this.y,_this.z,_this.w)
        c.update()
        return c

    def getInverseViewProj(self):
        if (self.minv is None):
            self.minv = h3d_Matrix()
        if self.needInv:
            self.minv.initInverse(self.m)
            self.needInv = False
        return self.minv

    def getInverseProj(self):
        if (self.mprojInv is None):
            self.mprojInv = h3d_Matrix()
            self.mprojInv._44 = 0
        if (self.mprojInv._44 == 0):
            self.mprojInv.initInverse(self.mproj)
        return self.mprojInv

    def getInverseView(self):
        if (self.mcamInv is None):
            self.mcamInv = h3d_Matrix()
            self.mcamInv._44 = 0
        if (self.mcamInv._44 == 0):
            self.mcamInv.initInverse(self.mcam)
        return self.mcamInv

    def setCubeMap(self,face,position = None):
        dx = 0
        dy = 0
        dz = 0
        face1 = face
        if (face1 == 0):
            dx = 1
            _this = self.up
            x = 0
            y = 1
            z = 0
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
        elif (face1 == 1):
            dx = -1
            _this = self.up
            x = 0
            y = 1
            z = 0
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
        elif (face1 == 2):
            dy = 1
            _this = self.up
            x = 0
            y = 0
            z = -1
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
        elif (face1 == 3):
            dy = -1
            _this = self.up
            x = 0
            y = 0
            z = 1
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
        elif (face1 == 4):
            dz = 1
            _this = self.up
            x = 0
            y = 1
            z = 0
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
        elif (face1 == 5):
            dz = -1
            _this = self.up
            x = 0
            y = 1
            z = 0
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
        else:
            pass
        if (position is not None):
            _this = self.pos
            _this.x = position.x
            _this.y = position.y
            _this.z = position.z
            _this.w = position.w
        _this = self.target
        x = (self.pos.x + dx)
        y = (self.pos.y + dy)
        z = (self.pos.z + dz)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.

    def unproject(self,screenX,screenY,camZ):
        p = h3d_Vector(screenX,screenY,camZ)
        m = self.getInverseViewProj()
        px = ((((p.x * m._11) + ((p.y * m._21))) + ((p.z * m._31))) + ((p.w * m._41)))
        py = ((((p.x * m._12) + ((p.y * m._22))) + ((p.z * m._32))) + ((p.w * m._42)))
        pz = ((((p.x * m._13) + ((p.y * m._23))) + ((p.z * m._33))) + ((p.w * m._43)))
        iw = (1 / (((((p.x * m._14) + ((p.y * m._24))) + ((p.z * m._34))) + ((p.w * m._44)))))
        p.x = (px * iw)
        p.y = (py * iw)
        p.z = (pz * iw)
        p.w = 1
        return p

    def rayFromScreen(self,pixelX,pixelY,sceneWidth = None,sceneHeight = None):
        if (sceneWidth is None):
            sceneWidth = -1
        if (sceneHeight is None):
            sceneHeight = -1
        engine = h3d_Engine.CURRENT
        if (sceneWidth < 0):
            sceneWidth = engine.width
        if (sceneHeight < 0):
            sceneHeight = engine.height
        rx = ((((pixelX / sceneWidth) - 0.5)) * 2)
        ry = (((0.5 - ((pixelY / sceneHeight)))) * 2)
        _this = self.unproject(rx,ry,0)
        x = _this.x
        y = _this.y
        z = _this.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p1_x = x
        p1_y = y
        p1_z = z
        _this = self.unproject(rx,ry,1)
        x = _this.x
        y = _this.y
        z = _this.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p2_x = x
        p2_y = y
        p2_z = z
        r = h3d_col_Ray()
        r.px = p1_x
        r.py = p1_y
        r.pz = p1_z
        r.lx = (p2_x - p1_x)
        r.ly = (p2_y - p1_y)
        r.lz = (p2_z - p1_z)
        r.normalize()
        return r

    def update(self):
        if (self.follow is not None):
            fpos = self.follow.pos.localToGlobal()
            ftarget = self.follow.target.localToGlobal()
            _this = self.pos
            x = fpos.x
            y = fpos.y
            z = fpos.z
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
            _this = self.target
            x = ftarget.x
            y = ftarget.y
            z = ftarget.z
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
            if (self.follow.pos.name is not None):
                p = self.follow.pos
                while (p is not None):
                    if (p.currentAnimation is not None):
                        v = p.currentAnimation.getPropValue(self.follow.pos.name,"FOVY")
                        if (v is not None):
                            self.fovY = v
                            break
                    p = p.parent
        self.makeCameraMatrix(self.mcam)
        self.makeFrustumMatrix(self.mproj)
        self.m.multiply(self.mcam,self.mproj)
        self.needInv = True
        if (self.mcamInv is not None):
            self.mcamInv._44 = 0
        if (self.mprojInv is not None):
            self.mprojInv._44 = 0
        self.frustum.loadMatrix(self.m)

    def getFrustumCorners(self,zMax = None,zMin = None):
        if (zMax is None):
            zMax = 1.
        if (zMin is None):
            zMin = 0.
        return [self.unproject(-1,1,zMin), self.unproject(1,1,zMin), self.unproject(1,-1,zMin), self.unproject(-1,-1,zMin), self.unproject(-1,1,zMax), self.unproject(1,1,zMax), self.unproject(1,-1,zMax), self.unproject(-1,-1,zMax)]

    def lostUp(self):
        _this = self.pos
        x = _this.x
        y = _this.y
        z = _this.z
        w = _this.w
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p2_x = x
        p2_y = y
        p2_z = z
        p2_w = w
        k = (((p2_x * p2_x) + ((p2_y * p2_y))) + ((p2_z * p2_z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        p2_x = (p2_x * k)
        p2_y = (p2_y * k)
        p2_z = (p2_z * k)
        v = self.up
        return (Reflect.field(Math,"fabs")((((p2_x * v.x) + ((p2_y * v.y))) + ((p2_z * v.z)))) > 0.999)

    def getViewDirection(self,dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        a = h3d_col_Point(dx,dy,dz)
        m = self.mcam
        px = (((a.x * m._11) + ((a.y * m._21))) + ((a.z * m._31)))
        py = (((a.x * m._12) + ((a.y * m._22))) + ((a.z * m._32)))
        pz = (((a.x * m._13) + ((a.y * m._23))) + ((a.z * m._33)))
        a.x = px
        a.y = py
        a.z = pz
        k = (((a.x * a.x) + ((a.y * a.y))) + ((a.z * a.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        a.x = (a.x * k)
        a.y = (a.y * k)
        a.z = (a.z * k)
        return a

    def movePosAxis(self,dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        x = dx
        y = dy
        z = dz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        m = self.mcam
        px = (((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31)))
        py = (((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32)))
        pz = (((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33)))
        p_x = px
        p_y = py
        p_z = pz
        _hx_local_0 = self.pos
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + p_x)
        _hx_local_0.x
        _hx_local_2 = self.pos
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + p_y)
        _hx_local_2.y
        _hx_local_4 = self.pos
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 + p_z)
        _hx_local_4.z

    def moveTargetAxis(self,dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        x = dx
        y = dy
        z = dz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        m = self.mcam
        px = (((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31)))
        py = (((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32)))
        pz = (((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33)))
        p_x = px
        p_y = py
        p_z = pz
        _hx_local_0 = self.target
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + p_x)
        _hx_local_0.x
        _hx_local_2 = self.target
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + p_y)
        _hx_local_2.y
        _hx_local_4 = self.target
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 + p_z)
        _hx_local_4.z

    def forward(self,speed = None):
        if (speed is None):
            speed = 1.
        c = (1 - ((0.025 * speed)))
        _this = self.pos
        x = (self.target.x + ((((self.pos.x - self.target.x)) * c)))
        y = (self.target.y + ((((self.pos.y - self.target.y)) * c)))
        z = (self.target.z + ((((self.pos.z - self.target.z)) * c)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.

    def backward(self,speed = None):
        if (speed is None):
            speed = 1.
        c = (1 + ((0.025 * speed)))
        _this = self.pos
        x = (self.target.x + ((((self.pos.x - self.target.x)) * c)))
        y = (self.target.y + ((((self.pos.y - self.target.y)) * c)))
        z = (self.target.z + ((((self.pos.z - self.target.z)) * c)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.

    def makeCameraMatrix(self,m):
        _this = self.target
        v = self.pos
        x = (_this.x - v.x)
        y = (_this.y - v.y)
        z = (_this.z - v.z)
        w = (_this.w - v.w)
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        az_x = x
        az_y = y
        az_z = z
        az_w = w
        if self.rightHanded:
            az_x = (az_x * -1)
            az_y = (az_y * -1)
            az_z = (az_z * -1)
        k = (((az_x * az_x) + ((az_y * az_y))) + ((az_z * az_z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        az_x = (az_x * k)
        az_y = (az_y * k)
        az_z = (az_z * k)
        _this = self.up
        x = ((_this.y * az_z) - ((_this.z * az_y)))
        y = ((_this.z * az_x) - ((_this.x * az_z)))
        z = ((_this.x * az_y) - ((_this.y * az_x)))
        w = 1
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ax_x = x
        ax_y = y
        ax_z = z
        ax_w = w
        k = (((ax_x * ax_x) + ((ax_y * ax_y))) + ((ax_z * ax_z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        ax_x = (ax_x * k)
        ax_y = (ax_y * k)
        ax_z = (ax_z * k)
        f = (((ax_x * ax_x) + ((ax_y * ax_y))) + ((ax_z * ax_z)))
        if (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) == 0):
            ax_x = az_y
            ax_y = az_z
            ax_z = az_x
        x = ((az_y * ax_z) - ((az_z * ax_y)))
        y = ((az_z * ax_x) - ((az_x * ax_z)))
        z = ((az_x * ax_y) - ((az_y * ax_x)))
        w = 1
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ay_x = x
        ay_y = y
        ay_z = z
        ay_w = w
        m._11 = ax_x
        m._12 = ay_x
        m._13 = az_x
        m._14 = 0
        m._21 = ax_y
        m._22 = ay_y
        m._23 = az_y
        m._24 = 0
        m._31 = ax_z
        m._32 = ay_z
        m._33 = az_z
        m._34 = 0
        v = self.pos
        m._41 = -((((ax_x * v.x) + ((ax_y * v.y))) + ((ax_z * v.z))))
        v = self.pos
        m._42 = -((((ay_x * v.x) + ((ay_y * v.y))) + ((ay_z * v.z))))
        v = self.pos
        m._43 = -((((az_x * v.x) + ((az_y * v.y))) + ((az_z * v.z))))
        m._44 = 1

    def setTransform(self,m):
        _this = self.pos
        x = m._41
        y = m._42
        z = m._43
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.target
        _this1 = self.pos
        v = m.getDirection()
        x = (_this1.x + v.x)
        y = (_this1.y + v.y)
        z = (_this1.z + v.z)
        w = (_this1.w + v.w)
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        _this.x = v_x
        _this.y = v_y
        _this.z = v_z
        _this.w = v_w

    def makeFrustumMatrix(self,m):
        m.zero()
        bounds = self.orthoBounds
        if (bounds is not None):
            w = (1 / ((bounds.xMax - bounds.xMin)))
            h = (1 / ((bounds.yMax - bounds.yMin)))
            d = (1 / ((bounds.zMax - bounds.zMin)))
            m._11 = (2 * w)
            m._22 = (2 * h)
            m._33 = d
            m._41 = (-((bounds.xMin + bounds.xMax)) * w)
            m._42 = (-((bounds.yMin + bounds.yMax)) * h)
            m._43 = (-bounds.zMin * d)
            m._44 = 1
        else:
            degToRad = (Math.PI / 180)
            halfFovX = Math.atan((Math.tan(((self.fovY * 0.5) * degToRad)) * self.screenRatio))
            scale = (self.zoom / Math.tan(halfFovX))
            m._11 = scale
            m._22 = (scale * self.screenRatio)
            m._33 = (self.zFar / ((self.zFar - self.zNear)))
            m._34 = 1
            m._43 = (-((self.zNear * self.zFar)) / ((self.zFar - self.zNear)))
        m._11 = (m._11 + ((self.viewX * m._14)))
        m._21 = (m._21 + ((self.viewX * m._24)))
        m._31 = (m._31 + ((self.viewX * m._34)))
        m._41 = (m._41 + ((self.viewX * m._44)))
        m._12 = (m._12 + ((self.viewY * m._14)))
        m._22 = (m._22 + ((self.viewY * m._24)))
        m._32 = (m._32 + ((self.viewY * m._34)))
        m._42 = (m._42 + ((self.viewY * m._44)))
        if self.rightHanded:
            m._33 = (m._33 * -1)
            m._34 = (m._34 * -1)

    def project(self,x,y,z,screenWidth,screenHeight,snapToPixel = None,p = None):
        if (snapToPixel is None):
            snapToPixel = True
        if (p is None):
            p = h3d_Vector()
        x1 = x
        y1 = y
        z1 = z
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        p.x = x1
        p.y = y1
        p.z = z1
        p.w = 1.
        m = self.m
        px = ((((p.x * m._11) + ((p.y * m._21))) + ((p.z * m._31))) + ((p.w * m._41)))
        py = ((((p.x * m._12) + ((p.y * m._22))) + ((p.z * m._32))) + ((p.w * m._42)))
        pz = ((((p.x * m._13) + ((p.y * m._23))) + ((p.z * m._33))) + ((p.w * m._43)))
        iw = (1 / (((((p.x * m._14) + ((p.y * m._24))) + ((p.z * m._34))) + ((p.w * m._44)))))
        p.x = (px * iw)
        p.y = (py * iw)
        p.z = (pz * iw)
        p.w = 1
        p.x = ((((p.x + 1)) * 0.5) * screenWidth)
        p.y = ((((-p.y + 1)) * 0.5) * screenHeight)
        if snapToPixel:
            p.x = Math.floor((p.x + 0.5))
            p.y = Math.floor((p.y + 0.5))
        return p

    def load(self,cam):
        _this = self.pos
        v = cam.pos
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        _this = self.target
        v = cam.target
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        _this = self.up
        v = cam.up
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        if (cam.orthoBounds is not None):
            self.orthoBounds = h3d_col_Bounds()
            self.orthoBounds.load(cam.orthoBounds)
        else:
            self.orthoBounds = None
        self.fovY = cam.fovY
        self.screenRatio = cam.screenRatio
        self.zoom = cam.zoom
        self.zNear = cam.zNear
        self.zFar = cam.zFar
        if (cam.follow is not None):
            self.follow = _hx_AnonObject({'pos': cam.follow.pos, 'target': cam.follow.target})
        else:
            self.follow = None
        self.viewX = cam.viewX
        self.viewY = cam.viewY
        self.update()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.zoom = None
        _hx_o.screenRatio = None
        _hx_o.fovY = None
        _hx_o.zNear = None
        _hx_o.zFar = None
        _hx_o.orthoBounds = None
        _hx_o.rightHanded = None
        _hx_o.mproj = None
        _hx_o.mcam = None
        _hx_o.m = None
        _hx_o.pos = None
        _hx_o.up = None
        _hx_o.target = None
        _hx_o.viewX = None
        _hx_o.viewY = None
        _hx_o.follow = None
        _hx_o.frustum = None
        _hx_o.minv = None
        _hx_o.mcamInv = None
        _hx_o.mprojInv = None
        _hx_o.needInv = None
h3d_Camera._hx_class = h3d_Camera
_hx_classes["h3d.Camera"] = h3d_Camera


class h3d__Engine_TargetTmp:
    _hx_class_name = "h3d._Engine.TargetTmp"
    _hx_is_interface = "False"
    __slots__ = ("t", "textures", "next", "layer", "mipLevel")
    _hx_fields = ["t", "textures", "next", "layer", "mipLevel"]

    def __init__(self,t,n,l,m):
        self.textures = None
        self.t = t
        self.next = n
        self.layer = l
        self.mipLevel = m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.t = None
        _hx_o.textures = None
        _hx_o.next = None
        _hx_o.layer = None
        _hx_o.mipLevel = None
h3d__Engine_TargetTmp._hx_class = h3d__Engine_TargetTmp
_hx_classes["h3d._Engine.TargetTmp"] = h3d__Engine_TargetTmp


class h3d_Engine:
    _hx_class_name = "h3d.Engine"
    _hx_is_interface = "False"
    _hx_fields = ["driver", "mem", "hardware", "width", "height", "debug", "drawTriangles", "drawCalls", "shaderSwitches", "backgroundColor", "autoResize", "fullScreen", "realFps", "lastTime", "antiAlias", "tmpVector", "window", "targetTmp", "targetStack", "currentTargetTex", "currentTargetLayer", "currentTargetMip", "needFlushTarget", "nullTexture", "textureColorCache", "inRender", "ready", "resCache"]
    _hx_methods = ["setDriver", "setCurrent", "init", "driverName", "selectShader", "selectMaterial", "uploadShaderBuffers", "selectBuffer", "renderTriBuffer", "renderQuadBuffer", "renderBuffer", "renderIndexed", "renderMultiBuffers", "renderInstanced", "set_debug", "onCreate", "onContextLost", "onReady", "onWindowResize", "set_fullScreen", "onResized", "resize", "begin", "hasFeature", "end", "getCurrentTarget", "pushTarget", "updateNeedFlush", "pushTargets", "popTarget", "flushTarget", "doFlushTarget", "clearF", "clear", "setRenderZone", "render", "dispose", "get_fps"]
    _hx_statics = ["SOFTWARE_DRIVER", "ANTIALIASING", "CURRENT", "getCurrent"]

    def __init__(self):
        self.nullTexture = None
        self.needFlushTarget = None
        self.currentTargetMip = None
        self.currentTargetLayer = None
        self.currentTargetTex = None
        self.targetStack = None
        self.targetTmp = None
        self.window = None
        self.lastTime = None
        self.realFps = None
        self.fullScreen = None
        self.shaderSwitches = None
        self.drawCalls = None
        self.drawTriangles = None
        self.debug = None
        self.height = None
        self.width = None
        self.mem = None
        self.driver = None
        self.resCache = haxe_ds_ObjectMap()
        self.ready = False
        self.inRender = False
        self.textureColorCache = haxe_ds_IntMap()
        self.tmpVector = h3d_Vector()
        self.backgroundColor = -16777216
        self.hardware = (not h3d_Engine.SOFTWARE_DRIVER)
        self.antiAlias = h3d_Engine.ANTIALIASING
        self.autoResize = True
        self.set_fullScreen((not hxd_System.getValue(hxd_SystemValue.IsWindowed)))
        self.window = hxd_Window.getInstance()
        self.realFps = hxd_System.getDefaultFrameRate()
        self.lastTime = python_lib_Timeit.default_timer()
        self.window.addResizeEvent(self.onWindowResize)
        _hx_str = "No output driver available."
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        self.driver = h3d_impl_LogDriver(h3d_impl_NullDriver())
        self.driver.logEnable = True
        h3d_Engine.CURRENT = self

    def setDriver(self,d):
        self.driver = d
        if (self.mem is not None):
            self.mem.driver = d

    def setCurrent(self):
        h3d_Engine.CURRENT = self

    def init(self):
        self.driver.init(self.onCreate,(not self.hardware))

    def driverName(self,details = None):
        if (details is None):
            details = False
        return self.driver.getDriverName(details)

    def selectShader(self,shader):
        if self.needFlushTarget:
            self.doFlushTarget()
        if self.driver.selectShader(shader):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.shaderSwitches
            _hx_local_0.shaderSwitches = (_hx_local_1 + 1)
            _hx_local_1

    def selectMaterial(self,_hx_pass):
        self.driver.selectMaterial(_hx_pass)

    def uploadShaderBuffers(self,buffers,which):
        self.driver.uploadShaderBuffers(buffers,which)

    def selectBuffer(self,buf):
        if ((buf.buffer is None) or ((buf.buffer.vbuf is None))):
            return False
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.selectBuffer(buf)
        return True

    def renderTriBuffer(self,b,start = None,_hx_max = None):
        if (start is None):
            start = 0
        if (_hx_max is None):
            _hx_max = -1
        self.renderBuffer(b,self.mem.triIndexes,3,start,_hx_max)

    def renderQuadBuffer(self,b,start = None,_hx_max = None):
        if (start is None):
            start = 0
        if (_hx_max is None):
            _hx_max = -1
        self.renderBuffer(b,self.mem.quadIndexes,2,start,_hx_max)

    def renderBuffer(self,b,indexes,vertPerTri,startTri = None,drawTri = None):
        if (startTri is None):
            startTri = 0
        if (drawTri is None):
            drawTri = -1
        if indexes.isDisposed():
            return
        while True:
            x = (b.vertices / vertPerTri)
            ntri = None
            try:
                ntri = int(x)
            except BaseException as _g:
                None
                ntri = None
            x1 = (b.position / vertPerTri)
            pos = None
            try:
                pos = int(x1)
            except BaseException as _g1:
                None
                pos = None
            if (startTri > 0):
                if (startTri >= ntri):
                    startTri = (startTri - ntri)
                    b = b.next
                    if (not ((b is not None))):
                        break
                    else:
                        continue
                pos = (pos + startTri)
                ntri = (ntri - startTri)
                startTri = 0
            if (drawTri >= 0):
                if (drawTri == 0):
                    return
                drawTri = (drawTri - ntri)
                if (drawTri < 0):
                    ntri = (ntri + drawTri)
                    drawTri = 0
            if ((ntri > 0) and self.selectBuffer(b)):
                self.driver.draw(indexes.ibuf,(pos * 3),ntri)
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.drawTriangles
                _hx_local_5.drawTriangles = (_hx_local_6 + ntri)
                _hx_local_5.drawTriangles
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.drawCalls
                _hx_local_7.drawCalls = (_hx_local_8 + 1)
                _hx_local_8
            b = b.next
            if (not ((b is not None))):
                break

    def renderIndexed(self,b,indexes,startTri = None,drawTri = None):
        if (startTri is None):
            startTri = 0
        if (drawTri is None):
            drawTri = -1
        if (b.next is not None):
            raise haxe_Exception.thrown("Buffer is split")
        if indexes.isDisposed():
            return
        x = (indexes.count / 3)
        maxTri = None
        try:
            maxTri = int(x)
        except BaseException as _g:
            None
            maxTri = None
        if (drawTri < 0):
            drawTri = (maxTri - startTri)
        if ((drawTri > 0) and self.selectBuffer(b)):
            self.driver.draw(indexes.ibuf,(startTri * 3),drawTri)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.drawTriangles
            _hx_local_0.drawTriangles = (_hx_local_1 + drawTri)
            _hx_local_0.drawTriangles
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.drawCalls
            _hx_local_2.drawCalls = (_hx_local_3 + 1)
            _hx_local_3

    def renderMultiBuffers(self,buffers,indexes,startTri = None,drawTri = None):
        if (startTri is None):
            startTri = 0
        if (drawTri is None):
            drawTri = -1
        x = (indexes.count / 3)
        maxTri = None
        try:
            maxTri = int(x)
        except BaseException as _g:
            None
            maxTri = None
        if (maxTri <= 0):
            return
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.selectMultiBuffers(buffers)
        if indexes.isDisposed():
            return
        if (drawTri < 0):
            drawTri = (maxTri - startTri)
        if (drawTri > 0):
            self.driver.draw(indexes.ibuf,(startTri * 3),drawTri)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.drawTriangles
            _hx_local_0.drawTriangles = (_hx_local_1 + drawTri)
            _hx_local_0.drawTriangles
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.drawCalls
            _hx_local_2.drawCalls = (_hx_local_3 + 1)
            _hx_local_3

    def renderInstanced(self,buffers,indexes,commands):
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.selectMultiBuffers(buffers)
        if indexes.isDisposed():
            return
        if (commands.commandCount > 0):
            self.driver.drawInstanced(indexes.ibuf,commands)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.drawTriangles
            _hx_local_0.drawTriangles = (_hx_local_1 + commands.triCount)
            _hx_local_0.drawTriangles
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.drawCalls
            _hx_local_2.drawCalls = (_hx_local_3 + 1)
            _hx_local_3

    def set_debug(self,d):
        self.debug = d
        self.driver.setDebug(self.debug)
        return d

    def onCreate(self,disposed):
        h3d_Engine.CURRENT = self
        if self.autoResize:
            self.width = self.window.get_width()
            self.height = self.window.get_height()
        if disposed:
            hxd_impl_Allocator.get().onContextLost()
            self.mem.onContextLost()
        else:
            self.mem = h3d_impl_MemoryManager(self.driver)
            self.mem.init()
            self.nullTexture = h3d_mat_Texture(0,0,[h3d_mat_TextureFlags.NoAlloc])
        self.hardware = self.driver.hasFeature(h3d_impl_Feature.HardwareAccelerated)
        self.set_debug(self.debug)
        self.set_fullScreen(self.fullScreen)
        self.resize(self.width,self.height)
        if disposed:
            self.onContextLost()
        else:
            self.onReady()
        self.ready = True

    def onContextLost(self):
        pass

    def onReady(self):
        pass

    def onWindowResize(self):
        if (self.autoResize and (not self.driver.isDisposed())):
            w = self.window.get_width()
            h = self.window.get_height()
            if ((w != self.width) or ((h != self.height))):
                self.resize(w,h)
            self.onResized()

    def set_fullScreen(self,v):
        self.fullScreen = v
        if ((self.mem is not None) and hxd_System.getValue(hxd_SystemValue.IsWindowed)):
            self.window.set_displayMode((hxd_DisplayMode.Borderless if v else hxd_DisplayMode.Windowed))
        return v

    def onResized(self):
        pass

    def resize(self,width,height):
        if (width < 32):
            width = 32
        if (height < 32):
            height = 32
        self.width = width
        self.height = height
        if (not self.driver.isDisposed()):
            self.driver.resize(width,height)

    def begin(self):
        if self.driver.isDisposed():
            return False
        self.inRender = True
        self.drawTriangles = 0
        self.shaderSwitches = 0
        self.drawCalls = 0
        self.targetStack = None
        self.needFlushTarget = (self.currentTargetTex is not None)
        self.driver.begin(hxd_Timer.frameCount)
        if (self.backgroundColor is not None):
            self.clear(self.backgroundColor,1,0)
        return True

    def hasFeature(self,f):
        return self.driver.hasFeature(f)

    def end(self):
        self.inRender = False
        self.driver.end()

    def getCurrentTarget(self):
        if (self.targetStack is None):
            return None
        elif (self.targetStack.t == self.nullTexture):
            return python_internal_ArrayImpl._get(self.targetStack.textures, 0)
        else:
            return self.targetStack.t

    def pushTarget(self,tex,layer = None,mipLevel = None):
        if (layer is None):
            layer = 0
        if (mipLevel is None):
            mipLevel = 0
        c = self.targetTmp
        if (c is None):
            c = h3d__Engine_TargetTmp(tex,self.targetStack,layer,mipLevel)
        else:
            self.targetTmp = c.next
            c.t = tex
            c.next = self.targetStack
            c.mipLevel = mipLevel
            c.layer = layer
        self.targetStack = c
        self.updateNeedFlush()

    def updateNeedFlush(self):
        t = self.targetStack
        if (t is None):
            self.needFlushTarget = (self.currentTargetTex is not None)
        else:
            self.needFlushTarget = ((((self.currentTargetTex != t.t) or ((self.currentTargetLayer != t.layer))) or ((self.currentTargetMip != t.mipLevel))) or ((t.textures is not None)))

    def pushTargets(self,textures):
        self.pushTarget(self.nullTexture)
        self.targetStack.textures = textures
        self.needFlushTarget = True

    def popTarget(self):
        c = self.targetStack
        if (c is None):
            raise haxe_Exception.thrown("popTarget() with no matching pushTarget()")
        self.targetStack = c.next
        self.updateNeedFlush()
        c.t = None
        c.textures = None
        c.next = self.targetTmp
        self.targetTmp = c

    def flushTarget(self):
        if self.needFlushTarget:
            self.doFlushTarget()

    def doFlushTarget(self):
        t = self.targetStack
        if (t is None):
            self.driver.setRenderTarget(None)
            self.currentTargetTex = None
        else:
            if (t.textures is not None):
                self.driver.setRenderTargets(t.textures)
            else:
                self.driver.setRenderTarget(t.t,t.layer,t.mipLevel)
            self.currentTargetTex = t.t
            self.currentTargetLayer = t.layer
            self.currentTargetMip = t.mipLevel
        self.needFlushTarget = False

    def clearF(self,color,depth = None,stencil = None):
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.clear(color,depth,stencil)

    def clear(self,color = None,depth = None,stencil = None):
        if (color is not None):
            _this = self.tmpVector
            _this.x = ((((color >> 16) & 255)) / 255)
            _this.y = ((((color >> 8) & 255)) / 255)
            _this.z = (((color & 255)) / 255)
            _this.w = ((HxOverrides.rshift(color, 24)) / 255)
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.clear((None if ((color is None)) else self.tmpVector),depth,stencil)

    def setRenderZone(self,x = None,y = None,width = None,height = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        if (width is None):
            width = -1
        if (height is None):
            height = -1
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.setRenderZone(x,y,width,height)

    def render(self,obj):
        if (not self.begin()):
            return False
        obj.render(self)
        self.end()
        delta = (python_lib_Timeit.default_timer() - self.lastTime)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.lastTime
        _hx_local_0.lastTime = (_hx_local_1 + delta)
        _hx_local_0.lastTime
        if (delta > 0):
            curFps = (1. / delta)
            if (curFps > ((self.realFps * 2))):
                curFps = (self.realFps * 2)
            elif (curFps < ((self.realFps * 0.5))):
                curFps = (self.realFps * 0.5)
            f = (delta / .5)
            if (f > 0.3):
                f = 0.3
            self.realFps = ((self.realFps * ((1 - f))) + ((curFps * f)))
        return True

    def dispose(self):
        self.driver.dispose()
        self.window.removeResizeEvent(self.onWindowResize)

    def get_fps(self):
        return (Math.ceil((self.realFps * 100)) / 100)

    @staticmethod
    def getCurrent():
        return h3d_Engine.CURRENT

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.driver = None
        _hx_o.mem = None
        _hx_o.hardware = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.debug = None
        _hx_o.drawTriangles = None
        _hx_o.drawCalls = None
        _hx_o.shaderSwitches = None
        _hx_o.backgroundColor = None
        _hx_o.autoResize = None
        _hx_o.fullScreen = None
        _hx_o.realFps = None
        _hx_o.lastTime = None
        _hx_o.antiAlias = None
        _hx_o.tmpVector = None
        _hx_o.window = None
        _hx_o.targetTmp = None
        _hx_o.targetStack = None
        _hx_o.currentTargetTex = None
        _hx_o.currentTargetLayer = None
        _hx_o.currentTargetMip = None
        _hx_o.needFlushTarget = None
        _hx_o.nullTexture = None
        _hx_o.textureColorCache = None
        _hx_o.inRender = None
        _hx_o.ready = None
        _hx_o.resCache = None
h3d_Engine._hx_class = h3d_Engine
_hx_classes["h3d.Engine"] = h3d_Engine


class h3d_Indexes:
    _hx_class_name = "h3d.Indexes"
    _hx_is_interface = "False"
    __slots__ = ("mem", "ibuf", "is32", "count")
    _hx_fields = ["mem", "ibuf", "is32", "count"]
    _hx_methods = ["isDisposed", "upload", "uploadBytes", "readBytes", "dispose"]
    _hx_statics = ["alloc"]

    def __init__(self,count,is32 = None):
        if (is32 is None):
            is32 = False
        self.ibuf = None
        self.mem = h3d_Engine.CURRENT.mem
        self.count = count
        self.is32 = is32
        self.mem.allocIndexes(self)

    def isDisposed(self):
        return (self.ibuf is None)

    def upload(self,indexes,pos,count,bufferPos = None):
        if (bufferPos is None):
            bufferPos = 0
        self.mem.driver.uploadIndexBuffer(self.ibuf,pos,count,indexes,bufferPos)

    def uploadBytes(self,_hx_bytes,dataPos,indices):
        self.mem.driver.uploadIndexBytes(self.ibuf,0,indices,_hx_bytes,dataPos)

    def readBytes(self,_hx_bytes,bytesPosition,indices,startIndice = None):
        if (startIndice is None):
            startIndice = 0
        self.mem.driver.readIndexBytes(self.ibuf,startIndice,indices,_hx_bytes,bytesPosition)

    def dispose(self):
        if (self.ibuf is not None):
            self.mem.deleteIndexes(self)

    @staticmethod
    def alloc(i,startPos = None,length = None):
        if (startPos is None):
            startPos = 0
        if (length is None):
            length = -1
        if (length < 0):
            length = len(i)
        idx = h3d_Indexes(length)
        idx.upload(i,0,length)
        return idx

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mem = None
        _hx_o.ibuf = None
        _hx_o.is32 = None
        _hx_o.count = None
h3d_Indexes._hx_class = h3d_Indexes
_hx_classes["h3d.Indexes"] = h3d_Indexes


class h3d_Matrix:
    _hx_class_name = "h3d.Matrix"
    _hx_is_interface = "False"
    __slots__ = ("_11", "_12", "_13", "_14", "_21", "_22", "_23", "_24", "_31", "_32", "_33", "_34", "_41", "_42", "_43", "_44")
    _hx_fields = ["_11", "_12", "_13", "_14", "_21", "_22", "_23", "_24", "_31", "_32", "_33", "_34", "_41", "_42", "_43", "_44"]
    _hx_methods = ["get_tx", "get_ty", "get_tz", "set_tx", "set_ty", "set_tz", "equal", "zero", "identity", "isIdentity", "isIdentityEpsilon", "initRotationX", "initRotationY", "initRotationZ", "initTranslation", "initScale", "initRotationAxis", "initRotation", "translate", "scale", "rotate", "rotateAxis", "getPosition", "setPosition", "prependTranslation", "getScale", "prependRotation", "prependRotationAxis", "prependScale", "multiply3x4", "multiply3x4inline", "multiply", "multiplyValue", "invert", "getInverse", "getDeterminant", "inverse3x4", "initInverse", "initInverse3x3", "front", "right", "up", "transpose", "clone", "load", "loadValues", "getFloats", "getDirection", "getEulerAngles", "toString", "colorHue", "colorSaturate", "colorContrast", "colorLightness", "colorGain", "colorBits", "colorAdd", "colorSet", "adjustColor", "toMatrix2D"]
    _hx_statics = ["tmp", "lumR", "lumG", "lumB", "SQ13", "I", "L", "T", "R", "S", "lookAtX"]

    def __init__(self):
        self._44 = None
        self._43 = None
        self._42 = None
        self._41 = None
        self._34 = None
        self._33 = None
        self._32 = None
        self._31 = None
        self._24 = None
        self._23 = None
        self._22 = None
        self._21 = None
        self._14 = None
        self._13 = None
        self._12 = None
        self._11 = None

    def get_tx(self):
        return self._41

    def get_ty(self):
        return self._42

    def get_tz(self):
        return self._43

    def set_tx(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self._41 = v
                return self._41
            return _hx_local_0()
        return _hx_local_1()

    def set_ty(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self._42 = v
                return self._42
            return _hx_local_0()
        return _hx_local_1()

    def set_tz(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self._43 = v
                return self._43
            return _hx_local_0()
        return _hx_local_1()

    def equal(self,other):
        if (((((((((((((((self._11 == other._11) and ((self._12 == other._12))) and ((self._13 == other._13))) and ((self._14 == other._14))) and ((self._21 == other._21))) and ((self._22 == other._22))) and ((self._23 == other._23))) and ((self._24 == other._24))) and ((self._31 == other._31))) and ((self._32 == other._32))) and ((self._33 == other._33))) and ((self._34 == other._34))) and ((self._41 == other._41))) and ((self._42 == other._42))) and ((self._43 == other._43))):
            return (self._44 == other._44)
        else:
            return False

    def zero(self):
        self._11 = 0.0
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = 0.0
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = 0.0
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 0.0

    def identity(self):
        self._11 = 1.0
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = 1.0
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = 1.0
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def isIdentity(self):
        if (((self._41 != 0) or ((self._42 != 0))) or ((self._43 != 0))):
            return False
        if (((self._11 != 1) or ((self._22 != 1))) or ((self._33 != 1))):
            return False
        if (((self._12 != 0) or ((self._13 != 0))) or ((self._14 != 0))):
            return False
        if (((self._21 != 0) or ((self._23 != 0))) or ((self._24 != 0))):
            return False
        if (((self._31 != 0) or ((self._32 != 0))) or ((self._34 != 0))):
            return False
        return (self._44 == 1)

    def isIdentityEpsilon(self,e):
        tmp = None
        tmp1 = None
        f = self._41
        if (not ((((-f if ((f < 0)) else f)) > e))):
            f = self._42
            tmp1 = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp1 = True
        if (not tmp1):
            f = self._43
            tmp = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp = True
        if tmp:
            return False
        tmp = None
        tmp1 = None
        f = (self._11 - 1)
        if (not ((((-f if ((f < 0)) else f)) > e))):
            f = (self._22 - 1)
            tmp1 = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp1 = True
        if (not tmp1):
            f = (self._33 - 1)
            tmp = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp = True
        if tmp:
            return False
        tmp = None
        tmp1 = None
        f = self._12
        if (not ((((-f if ((f < 0)) else f)) > e))):
            f = self._13
            tmp1 = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp1 = True
        if (not tmp1):
            f = self._14
            tmp = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp = True
        if tmp:
            return False
        tmp = None
        tmp1 = None
        f = self._21
        if (not ((((-f if ((f < 0)) else f)) > e))):
            f = self._23
            tmp1 = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp1 = True
        if (not tmp1):
            f = self._24
            tmp = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp = True
        if tmp:
            return False
        tmp = None
        tmp1 = None
        f = self._31
        if (not ((((-f if ((f < 0)) else f)) > e))):
            f = self._32
            tmp1 = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp1 = True
        if (not tmp1):
            f = self._34
            tmp = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp = True
        if tmp:
            return False
        f = (self._44 - 1)
        return (((-f if ((f < 0)) else f)) <= e)

    def initRotationX(self,a):
        cos = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))
        sin = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))
        self._11 = 1.0
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = cos
        self._23 = sin
        self._24 = 0.0
        self._31 = 0.0
        self._32 = -sin
        self._33 = cos
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initRotationY(self,a):
        cos = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))
        sin = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))
        self._11 = cos
        self._12 = 0.0
        self._13 = -sin
        self._14 = 0.0
        self._21 = 0.0
        self._22 = 1.0
        self._23 = 0.0
        self._24 = 0.0
        self._31 = sin
        self._32 = 0.0
        self._33 = cos
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initRotationZ(self,a):
        cos = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))
        sin = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))
        self._11 = cos
        self._12 = sin
        self._13 = 0.0
        self._14 = 0.0
        self._21 = -sin
        self._22 = cos
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = 1.0
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initTranslation(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        self._11 = 1.0
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = 1.0
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = 1.0
        self._34 = 0.0
        self._41 = x
        self._42 = y
        self._43 = z
        self._44 = 1.0

    def initScale(self,x = None,y = None,z = None):
        if (x is None):
            x = 1.
        if (y is None):
            y = 1.
        if (z is None):
            z = 1.
        self._11 = x
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = y
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = z
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initRotationAxis(self,axis,angle):
        cos = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sin = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        cos1 = (1 - cos)
        x = -axis.x
        y = -axis.y
        z = -axis.z
        xx = (x * x)
        yy = (y * y)
        zz = (z * z)
        f = ((xx + yy) + zz)
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        x = (x * _hx_len)
        y = (y * _hx_len)
        z = (z * _hx_len)
        xcos1 = (x * cos1)
        zcos1 = (z * cos1)
        self._11 = (cos + ((x * xcos1)))
        self._12 = ((y * xcos1) - ((z * sin)))
        self._13 = ((x * zcos1) + ((y * sin)))
        self._14 = 0.
        self._21 = ((y * xcos1) + ((z * sin)))
        self._22 = (cos + (((y * y) * cos1)))
        self._23 = ((y * zcos1) - ((x * sin)))
        self._24 = 0.
        self._31 = ((x * zcos1) - ((y * sin)))
        self._32 = ((y * zcos1) + ((x * sin)))
        self._33 = (cos + ((z * zcos1)))
        self._34 = 0.
        self._41 = 0.
        self._42 = 0.
        self._43 = 0.
        self._44 = 1.

    def initRotation(self,x,y,z):
        cx = (Math.NaN if (((x == Math.POSITIVE_INFINITY) or ((x == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(x))
        sx = (Math.NaN if (((x == Math.POSITIVE_INFINITY) or ((x == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(x))
        cy = (Math.NaN if (((y == Math.POSITIVE_INFINITY) or ((y == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(y))
        sy = (Math.NaN if (((y == Math.POSITIVE_INFINITY) or ((y == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(y))
        cz = (Math.NaN if (((z == Math.POSITIVE_INFINITY) or ((z == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(z))
        sz = (Math.NaN if (((z == Math.POSITIVE_INFINITY) or ((z == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(z))
        cxsy = (cx * sy)
        sxsy = (sx * sy)
        self._11 = (cy * cz)
        self._12 = (cy * sz)
        self._13 = -sy
        self._14 = 0
        self._21 = ((sxsy * cz) - ((cx * sz)))
        self._22 = ((sxsy * sz) + ((cx * cz)))
        self._23 = (sx * cy)
        self._24 = 0
        self._31 = ((cxsy * cz) + ((sx * sz)))
        self._32 = ((cxsy * sz) - ((sx * cz)))
        self._33 = (cx * cy)
        self._34 = 0
        self._41 = 0
        self._42 = 0
        self._43 = 0
        self._44 = 1

    def translate(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 + ((x * self._14)))
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 + ((y * self._14)))
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 + ((z * self._14)))
        _hx_local_4._13
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._21
        _hx_local_6._21 = (_hx_local_7 + ((x * self._24)))
        _hx_local_6._21
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._22
        _hx_local_8._22 = (_hx_local_9 + ((y * self._24)))
        _hx_local_8._22
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._23
        _hx_local_10._23 = (_hx_local_11 + ((z * self._24)))
        _hx_local_10._23
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._31
        _hx_local_12._31 = (_hx_local_13 + ((x * self._34)))
        _hx_local_12._31
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._32
        _hx_local_14._32 = (_hx_local_15 + ((y * self._34)))
        _hx_local_14._32
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._33
        _hx_local_16._33 = (_hx_local_17 + ((z * self._34)))
        _hx_local_16._33
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._41
        _hx_local_18._41 = (_hx_local_19 + ((x * self._44)))
        _hx_local_18._41
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._42
        _hx_local_20._42 = (_hx_local_21 + ((y * self._44)))
        _hx_local_20._42
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._43
        _hx_local_22._43 = (_hx_local_23 + ((z * self._44)))
        _hx_local_22._43

    def scale(self,x = None,y = None,z = None):
        if (x is None):
            x = 1.
        if (y is None):
            y = 1.
        if (z is None):
            z = 1.
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * x)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._21
        _hx_local_2._21 = (_hx_local_3 * x)
        _hx_local_2._21
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._31
        _hx_local_4._31 = (_hx_local_5 * x)
        _hx_local_4._31
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._41
        _hx_local_6._41 = (_hx_local_7 * x)
        _hx_local_6._41
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._12
        _hx_local_8._12 = (_hx_local_9 * y)
        _hx_local_8._12
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._22
        _hx_local_10._22 = (_hx_local_11 * y)
        _hx_local_10._22
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._32
        _hx_local_12._32 = (_hx_local_13 * y)
        _hx_local_12._32
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._42
        _hx_local_14._42 = (_hx_local_15 * y)
        _hx_local_14._42
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._13
        _hx_local_16._13 = (_hx_local_17 * z)
        _hx_local_16._13
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._23
        _hx_local_18._23 = (_hx_local_19 * z)
        _hx_local_18._23
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._33
        _hx_local_20._33 = (_hx_local_21 * z)
        _hx_local_20._33
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._43
        _hx_local_22._43 = (_hx_local_23 * z)
        _hx_local_22._43

    def rotate(self,x,y,z):
        tmp = h3d_Matrix.tmp
        tmp.initRotation(x,y,z)
        self.multiply(self,tmp)

    def rotateAxis(self,axis,angle):
        tmp = h3d_Matrix.tmp
        tmp.initRotationAxis(axis,angle)
        self.multiply(self,tmp)

    def getPosition(self,v = None):
        if (v is None):
            v = h3d_Vector()
        x = self._41
        y = self._42
        z = self._43
        w = self._44
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v.x = x
        v.y = y
        v.z = z
        v.w = w
        return v

    def setPosition(self,v):
        self._41 = v.x
        self._42 = v.y
        self._43 = v.z
        self._44 = v.w

    def prependTranslation(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        vx = ((((self._11 * x) + ((self._21 * y))) + ((self._31 * z))) + self._41)
        vy = ((((self._12 * x) + ((self._22 * y))) + ((self._32 * z))) + self._42)
        vz = ((((self._13 * x) + ((self._23 * y))) + ((self._33 * z))) + self._43)
        vw = ((((self._14 * x) + ((self._24 * y))) + ((self._34 * z))) + self._44)
        self._41 = vx
        self._42 = vy
        self._43 = vz
        self._44 = vw

    def getScale(self,v = None):
        if (v is None):
            v = h3d_Vector()
        f = (((self._11 * self._11) + ((self._12 * self._12))) + ((self._13 * self._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((self._21 * self._21) + ((self._22 * self._22))) + ((self._23 * self._23)))
        v.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((self._31 * self._31) + ((self._32 * self._32))) + ((self._33 * self._33)))
        v.z = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if ((((self._11 * (((self._22 * self._33) - ((self._23 * self._32))))) + ((self._12 * (((self._23 * self._31) - ((self._21 * self._33))))))) + ((self._13 * (((self._21 * self._32) - ((self._22 * self._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        return v

    def prependRotation(self,x,y,z):
        tmp = h3d_Matrix.tmp
        tmp.initRotation(x,y,z)
        self.multiply(tmp,self)

    def prependRotationAxis(self,axis,angle):
        tmp = h3d_Matrix.tmp
        tmp.initRotationAxis(axis,angle)
        self.multiply(tmp,self)

    def prependScale(self,sx = None,sy = None,sz = None):
        if (sx is None):
            sx = 1.
        if (sy is None):
            sy = 1.
        if (sz is None):
            sz = 1.
        tmp = h3d_Matrix.tmp
        tmp.initScale(sx,sy,sz)
        self.multiply(tmp,self)

    def multiply3x4(self,a,b):
        m11 = a._11
        m12 = a._12
        m13 = a._13
        m21 = a._21
        m22 = a._22
        m23 = a._23
        a31 = a._31
        a32 = a._32
        a33 = a._33
        a41 = a._41
        a42 = a._42
        a43 = a._43
        b11 = b._11
        b12 = b._12
        b13 = b._13
        b21 = b._21
        b22 = b._22
        b23 = b._23
        b31 = b._31
        b32 = b._32
        b33 = b._33
        b41 = b._41
        b42 = b._42
        b43 = b._43
        self._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
        self._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
        self._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
        self._14 = 0
        self._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
        self._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
        self._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
        self._24 = 0
        self._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
        self._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
        self._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
        self._34 = 0
        self._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
        self._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
        self._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
        self._44 = 1

    def multiply3x4inline(self,a,b):
        m11 = a._11
        m12 = a._12
        m13 = a._13
        m21 = a._21
        m22 = a._22
        m23 = a._23
        a31 = a._31
        a32 = a._32
        a33 = a._33
        a41 = a._41
        a42 = a._42
        a43 = a._43
        b11 = b._11
        b12 = b._12
        b13 = b._13
        b21 = b._21
        b22 = b._22
        b23 = b._23
        b31 = b._31
        b32 = b._32
        b33 = b._33
        b41 = b._41
        b42 = b._42
        b43 = b._43
        self._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
        self._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
        self._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
        self._14 = 0
        self._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
        self._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
        self._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
        self._24 = 0
        self._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
        self._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
        self._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
        self._34 = 0
        self._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
        self._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
        self._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
        self._44 = 1

    def multiply(self,a,b):
        a11 = a._11
        a12 = a._12
        a13 = a._13
        a14 = a._14
        a21 = a._21
        a22 = a._22
        a23 = a._23
        a24 = a._24
        a31 = a._31
        a32 = a._32
        a33 = a._33
        a34 = a._34
        a41 = a._41
        a42 = a._42
        a43 = a._43
        a44 = a._44
        b11 = b._11
        b12 = b._12
        b13 = b._13
        b14 = b._14
        b21 = b._21
        b22 = b._22
        b23 = b._23
        b24 = b._24
        b31 = b._31
        b32 = b._32
        b33 = b._33
        b34 = b._34
        b41 = b._41
        b42 = b._42
        b43 = b._43
        b44 = b._44
        self._11 = ((((a11 * b11) + ((a12 * b21))) + ((a13 * b31))) + ((a14 * b41)))
        self._12 = ((((a11 * b12) + ((a12 * b22))) + ((a13 * b32))) + ((a14 * b42)))
        self._13 = ((((a11 * b13) + ((a12 * b23))) + ((a13 * b33))) + ((a14 * b43)))
        self._14 = ((((a11 * b14) + ((a12 * b24))) + ((a13 * b34))) + ((a14 * b44)))
        self._21 = ((((a21 * b11) + ((a22 * b21))) + ((a23 * b31))) + ((a24 * b41)))
        self._22 = ((((a21 * b12) + ((a22 * b22))) + ((a23 * b32))) + ((a24 * b42)))
        self._23 = ((((a21 * b13) + ((a22 * b23))) + ((a23 * b33))) + ((a24 * b43)))
        self._24 = ((((a21 * b14) + ((a22 * b24))) + ((a23 * b34))) + ((a24 * b44)))
        self._31 = ((((a31 * b11) + ((a32 * b21))) + ((a33 * b31))) + ((a34 * b41)))
        self._32 = ((((a31 * b12) + ((a32 * b22))) + ((a33 * b32))) + ((a34 * b42)))
        self._33 = ((((a31 * b13) + ((a32 * b23))) + ((a33 * b33))) + ((a34 * b43)))
        self._34 = ((((a31 * b14) + ((a32 * b24))) + ((a33 * b34))) + ((a34 * b44)))
        self._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + ((a44 * b41)))
        self._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + ((a44 * b42)))
        self._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + ((a44 * b43)))
        self._44 = ((((a41 * b14) + ((a42 * b24))) + ((a43 * b34))) + ((a44 * b44)))

    def multiplyValue(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * v)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * v)
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * v)
        _hx_local_4._13
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._14
        _hx_local_6._14 = (_hx_local_7 * v)
        _hx_local_6._14
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._21
        _hx_local_8._21 = (_hx_local_9 * v)
        _hx_local_8._21
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._22
        _hx_local_10._22 = (_hx_local_11 * v)
        _hx_local_10._22
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._23
        _hx_local_12._23 = (_hx_local_13 * v)
        _hx_local_12._23
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._24
        _hx_local_14._24 = (_hx_local_15 * v)
        _hx_local_14._24
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._31
        _hx_local_16._31 = (_hx_local_17 * v)
        _hx_local_16._31
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._32
        _hx_local_18._32 = (_hx_local_19 * v)
        _hx_local_18._32
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._33
        _hx_local_20._33 = (_hx_local_21 * v)
        _hx_local_20._33
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._34
        _hx_local_22._34 = (_hx_local_23 * v)
        _hx_local_22._34
        _hx_local_24 = self
        _hx_local_25 = _hx_local_24._41
        _hx_local_24._41 = (_hx_local_25 * v)
        _hx_local_24._41
        _hx_local_26 = self
        _hx_local_27 = _hx_local_26._42
        _hx_local_26._42 = (_hx_local_27 * v)
        _hx_local_26._42
        _hx_local_28 = self
        _hx_local_29 = _hx_local_28._43
        _hx_local_28._43 = (_hx_local_29 * v)
        _hx_local_28._43
        _hx_local_30 = self
        _hx_local_31 = _hx_local_30._44
        _hx_local_30._44 = (_hx_local_31 * v)
        _hx_local_30._44

    def invert(self):
        self.initInverse(self)

    def getInverse(self,m = None):
        if (m is None):
            m = h3d_Matrix()
        m.initInverse(self)
        return m

    def getDeterminant(self):
        return (((self._11 * (((self._22 * self._33) - ((self._23 * self._32))))) + ((self._12 * (((self._23 * self._31) - ((self._21 * self._33))))))) + ((self._13 * (((self._21 * self._32) - ((self._22 * self._31)))))))

    def inverse3x4(self,m):
        m11 = m._11
        m12 = m._12
        m13 = m._13
        m21 = m._21
        m22 = m._22
        m23 = m._23
        m31 = m._31
        m32 = m._32
        m33 = m._33
        m41 = m._41
        m42 = m._42
        m43 = m._43
        self._11 = ((m22 * m33) - ((m23 * m32)))
        self._12 = ((m13 * m32) - ((m12 * m33)))
        self._13 = ((m12 * m23) - ((m13 * m22)))
        self._14 = 0
        self._21 = ((m23 * m31) - ((m21 * m33)))
        self._22 = ((m11 * m33) - ((m13 * m31)))
        self._23 = ((m13 * m21) - ((m11 * m23)))
        self._24 = 0
        self._31 = ((m21 * m32) - ((m22 * m31)))
        self._32 = ((m12 * m31) - ((m11 * m32)))
        self._33 = ((m11 * m22) - ((m12 * m21)))
        self._34 = 0
        self._41 = (((((((-m21 * m32) * m43) + (((m21 * m33) * m42))) + (((m31 * m22) * m43))) - (((m31 * m23) * m42))) - (((m41 * m22) * m33))) + (((m41 * m23) * m32)))
        self._42 = (((((((m11 * m32) * m43) - (((m11 * m33) * m42))) - (((m31 * m12) * m43))) + (((m31 * m13) * m42))) + (((m41 * m12) * m33))) - (((m41 * m13) * m32)))
        self._43 = (((((((-m11 * m22) * m43) + (((m11 * m23) * m42))) + (((m21 * m12) * m43))) - (((m21 * m13) * m42))) - (((m41 * m12) * m23))) + (((m41 * m13) * m22)))
        self._44 = (((((((m11 * m22) * m33) - (((m11 * m23) * m32))) - (((m21 * m12) * m33))) + (((m21 * m13) * m32))) + (((m31 * m12) * m23))) - (((m31 * m13) * m22)))
        self._44 = 1
        det = (((m11 * self._11) + ((m12 * self._21))) + ((m13 * self._31)))
        if (((-det if ((det < 0)) else det)) < 1e-10):
            self.zero()
            return
        invDet = (1.0 / det)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * invDet)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * invDet)
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * invDet)
        _hx_local_4._13
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._21
        _hx_local_6._21 = (_hx_local_7 * invDet)
        _hx_local_6._21
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._22
        _hx_local_8._22 = (_hx_local_9 * invDet)
        _hx_local_8._22
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._23
        _hx_local_10._23 = (_hx_local_11 * invDet)
        _hx_local_10._23
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._31
        _hx_local_12._31 = (_hx_local_13 * invDet)
        _hx_local_12._31
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._32
        _hx_local_14._32 = (_hx_local_15 * invDet)
        _hx_local_14._32
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._33
        _hx_local_16._33 = (_hx_local_17 * invDet)
        _hx_local_16._33
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._41
        _hx_local_18._41 = (_hx_local_19 * invDet)
        _hx_local_18._41
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._42
        _hx_local_20._42 = (_hx_local_21 * invDet)
        _hx_local_20._42
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._43
        _hx_local_22._43 = (_hx_local_23 * invDet)
        _hx_local_22._43

    def initInverse(self,m):
        m11 = m._11
        m12 = m._12
        m13 = m._13
        m14 = m._14
        m21 = m._21
        m22 = m._22
        m23 = m._23
        m24 = m._24
        m31 = m._31
        m32 = m._32
        m33 = m._33
        m34 = m._34
        m41 = m._41
        m42 = m._42
        m43 = m._43
        m44 = m._44
        self._11 = (((((((m22 * m33) * m44) - (((m22 * m34) * m43))) - (((m32 * m23) * m44))) + (((m32 * m24) * m43))) + (((m42 * m23) * m34))) - (((m42 * m24) * m33)))
        self._12 = (((((((-m12 * m33) * m44) + (((m12 * m34) * m43))) + (((m32 * m13) * m44))) - (((m32 * m14) * m43))) - (((m42 * m13) * m34))) + (((m42 * m14) * m33)))
        self._13 = (((((((m12 * m23) * m44) - (((m12 * m24) * m43))) - (((m22 * m13) * m44))) + (((m22 * m14) * m43))) + (((m42 * m13) * m24))) - (((m42 * m14) * m23)))
        self._14 = (((((((-m12 * m23) * m34) + (((m12 * m24) * m33))) + (((m22 * m13) * m34))) - (((m22 * m14) * m33))) - (((m32 * m13) * m24))) + (((m32 * m14) * m23)))
        self._21 = (((((((-m21 * m33) * m44) + (((m21 * m34) * m43))) + (((m31 * m23) * m44))) - (((m31 * m24) * m43))) - (((m41 * m23) * m34))) + (((m41 * m24) * m33)))
        self._22 = (((((((m11 * m33) * m44) - (((m11 * m34) * m43))) - (((m31 * m13) * m44))) + (((m31 * m14) * m43))) + (((m41 * m13) * m34))) - (((m41 * m14) * m33)))
        self._23 = (((((((-m11 * m23) * m44) + (((m11 * m24) * m43))) + (((m21 * m13) * m44))) - (((m21 * m14) * m43))) - (((m41 * m13) * m24))) + (((m41 * m14) * m23)))
        self._24 = (((((((m11 * m23) * m34) - (((m11 * m24) * m33))) - (((m21 * m13) * m34))) + (((m21 * m14) * m33))) + (((m31 * m13) * m24))) - (((m31 * m14) * m23)))
        self._31 = (((((((m21 * m32) * m44) - (((m21 * m34) * m42))) - (((m31 * m22) * m44))) + (((m31 * m24) * m42))) + (((m41 * m22) * m34))) - (((m41 * m24) * m32)))
        self._32 = (((((((-m11 * m32) * m44) + (((m11 * m34) * m42))) + (((m31 * m12) * m44))) - (((m31 * m14) * m42))) - (((m41 * m12) * m34))) + (((m41 * m14) * m32)))
        self._33 = (((((((m11 * m22) * m44) - (((m11 * m24) * m42))) - (((m21 * m12) * m44))) + (((m21 * m14) * m42))) + (((m41 * m12) * m24))) - (((m41 * m14) * m22)))
        self._34 = (((((((-m11 * m22) * m34) + (((m11 * m24) * m32))) + (((m21 * m12) * m34))) - (((m21 * m14) * m32))) - (((m31 * m12) * m24))) + (((m31 * m14) * m22)))
        self._41 = (((((((-m21 * m32) * m43) + (((m21 * m33) * m42))) + (((m31 * m22) * m43))) - (((m31 * m23) * m42))) - (((m41 * m22) * m33))) + (((m41 * m23) * m32)))
        self._42 = (((((((m11 * m32) * m43) - (((m11 * m33) * m42))) - (((m31 * m12) * m43))) + (((m31 * m13) * m42))) + (((m41 * m12) * m33))) - (((m41 * m13) * m32)))
        self._43 = (((((((-m11 * m22) * m43) + (((m11 * m23) * m42))) + (((m21 * m12) * m43))) - (((m21 * m13) * m42))) - (((m41 * m12) * m23))) + (((m41 * m13) * m22)))
        self._44 = (((((((m11 * m22) * m33) - (((m11 * m23) * m32))) - (((m21 * m12) * m33))) + (((m21 * m13) * m32))) + (((m31 * m12) * m23))) - (((m31 * m13) * m22)))
        det = ((((m11 * self._11) + ((m12 * self._21))) + ((m13 * self._31))) + ((m14 * self._41)))
        if (((-det if ((det < 0)) else det)) < 1e-10):
            self.zero()
            return
        det = (1.0 / det)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * det)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * det)
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * det)
        _hx_local_4._13
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._14
        _hx_local_6._14 = (_hx_local_7 * det)
        _hx_local_6._14
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._21
        _hx_local_8._21 = (_hx_local_9 * det)
        _hx_local_8._21
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._22
        _hx_local_10._22 = (_hx_local_11 * det)
        _hx_local_10._22
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._23
        _hx_local_12._23 = (_hx_local_13 * det)
        _hx_local_12._23
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._24
        _hx_local_14._24 = (_hx_local_15 * det)
        _hx_local_14._24
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._31
        _hx_local_16._31 = (_hx_local_17 * det)
        _hx_local_16._31
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._32
        _hx_local_18._32 = (_hx_local_19 * det)
        _hx_local_18._32
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._33
        _hx_local_20._33 = (_hx_local_21 * det)
        _hx_local_20._33
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._34
        _hx_local_22._34 = (_hx_local_23 * det)
        _hx_local_22._34
        _hx_local_24 = self
        _hx_local_25 = _hx_local_24._41
        _hx_local_24._41 = (_hx_local_25 * det)
        _hx_local_24._41
        _hx_local_26 = self
        _hx_local_27 = _hx_local_26._42
        _hx_local_26._42 = (_hx_local_27 * det)
        _hx_local_26._42
        _hx_local_28 = self
        _hx_local_29 = _hx_local_28._43
        _hx_local_28._43 = (_hx_local_29 * det)
        _hx_local_28._43
        _hx_local_30 = self
        _hx_local_31 = _hx_local_30._44
        _hx_local_30._44 = (_hx_local_31 * det)
        _hx_local_30._44

    def initInverse3x3(self,m):
        m11 = m._11
        m12 = m._12
        m13 = m._13
        m21 = m._21
        m22 = m._22
        m23 = m._23
        m31 = m._31
        m32 = m._32
        m33 = m._33
        self._11 = ((m22 * m33) - ((m32 * m23)))
        self._12 = ((-m12 * m33) + ((m32 * m13)))
        self._13 = ((m12 * m23) - ((m22 * m13)))
        self._21 = ((-m21 * m33) + ((m31 * m23)))
        self._22 = ((m11 * m33) - ((m31 * m13)))
        self._23 = ((-m11 * m23) + ((m21 * m13)))
        self._31 = ((m21 * m32) - ((m31 * m22)))
        self._32 = ((-m11 * m32) + ((m31 * m12)))
        self._33 = ((m11 * m22) - ((m21 * m12)))
        det = (((m11 * self._11) + ((m12 * self._21))) + ((m13 * self._31)))
        if (((-det if ((det < 0)) else det)) < 1e-10):
            self.zero()
            return
        det = (1.0 / det)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * det)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * det)
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * det)
        _hx_local_4._13
        self._14 = 0
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._21
        _hx_local_6._21 = (_hx_local_7 * det)
        _hx_local_6._21
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._22
        _hx_local_8._22 = (_hx_local_9 * det)
        _hx_local_8._22
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._23
        _hx_local_10._23 = (_hx_local_11 * det)
        _hx_local_10._23
        self._24 = 0
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._31
        _hx_local_12._31 = (_hx_local_13 * det)
        _hx_local_12._31
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._32
        _hx_local_14._32 = (_hx_local_15 * det)
        _hx_local_14._32
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._33
        _hx_local_16._33 = (_hx_local_17 * det)
        _hx_local_16._33
        self._34 = 0
        self._41 = 0
        self._42 = 0
        self._43 = 0
        self._44 = 1

    def front(self):
        v = h3d_Vector(self._11,self._12,self._13)
        k = (((v.x * v.x) + ((v.y * v.y))) + ((v.z * v.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        v.x = (v.x * k)
        v.y = (v.y * k)
        v.z = (v.z * k)
        return v

    def right(self):
        v = h3d_Vector(self._21,self._22,self._23)
        k = (((v.x * v.x) + ((v.y * v.y))) + ((v.z * v.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        v.x = (v.x * k)
        v.y = (v.y * k)
        v.z = (v.z * k)
        return v

    def up(self):
        v = h3d_Vector(self._31,self._32,self._33)
        k = (((v.x * v.x) + ((v.y * v.y))) + ((v.z * v.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        v.x = (v.x * k)
        v.y = (v.y * k)
        v.z = (v.z * k)
        return v

    def transpose(self):
        tmp = self._12
        self._12 = self._21
        self._21 = tmp
        tmp = self._13
        self._13 = self._31
        self._31 = tmp
        tmp = self._14
        self._14 = self._41
        self._41 = tmp
        tmp = self._23
        self._23 = self._32
        self._32 = tmp
        tmp = self._24
        self._24 = self._42
        self._42 = tmp
        tmp = self._34
        self._34 = self._43
        self._43 = tmp

    def clone(self):
        m = h3d_Matrix()
        m._11 = self._11
        m._12 = self._12
        m._13 = self._13
        m._14 = self._14
        m._21 = self._21
        m._22 = self._22
        m._23 = self._23
        m._24 = self._24
        m._31 = self._31
        m._32 = self._32
        m._33 = self._33
        m._34 = self._34
        m._41 = self._41
        m._42 = self._42
        m._43 = self._43
        m._44 = self._44
        return m

    def load(self,m):
        self._11 = m._11
        self._12 = m._12
        self._13 = m._13
        self._14 = m._14
        self._21 = m._21
        self._22 = m._22
        self._23 = m._23
        self._24 = m._24
        self._31 = m._31
        self._32 = m._32
        self._33 = m._33
        self._34 = m._34
        self._41 = m._41
        self._42 = m._42
        self._43 = m._43
        self._44 = m._44

    def loadValues(self,a):
        self._11 = (a[0] if 0 < len(a) else None)
        self._12 = (a[1] if 1 < len(a) else None)
        self._13 = (a[2] if 2 < len(a) else None)
        self._14 = (a[3] if 3 < len(a) else None)
        self._21 = (a[4] if 4 < len(a) else None)
        self._22 = (a[5] if 5 < len(a) else None)
        self._23 = (a[6] if 6 < len(a) else None)
        self._24 = (a[7] if 7 < len(a) else None)
        self._31 = (a[8] if 8 < len(a) else None)
        self._32 = (a[9] if 9 < len(a) else None)
        self._33 = (a[10] if 10 < len(a) else None)
        self._34 = (a[11] if 11 < len(a) else None)
        self._41 = (a[12] if 12 < len(a) else None)
        self._42 = (a[13] if 13 < len(a) else None)
        self._43 = (a[14] if 14 < len(a) else None)
        self._44 = (a[15] if 15 < len(a) else None)

    def getFloats(self):
        return [self._11, self._12, self._13, self._14, self._21, self._22, self._23, self._24, self._31, self._32, self._33, self._34, self._41, self._42, self._43, self._44]

    def getDirection(self):
        q = h3d_Quat()
        q.initRotateMatrix(self)
        q.normalize()
        return h3d_Vector((1 - ((2 * (((q.y * q.y) + ((q.z * q.z))))))),(2 * (((q.x * q.y) + ((q.z * q.w))))),(2 * (((q.x * q.z) - ((q.y * q.w))))))

    def getEulerAngles(self):
        m = self.clone()
        v = None
        if (v is None):
            v = h3d_Vector()
        f = (((self._11 * self._11) + ((self._12 * self._12))) + ((self._13 * self._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((self._21 * self._21) + ((self._22 * self._22))) + ((self._23 * self._23)))
        v.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((self._31 * self._31) + ((self._32 * self._32))) + ((self._33 * self._33)))
        v.z = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if ((((self._11 * (((self._22 * self._33) - ((self._23 * self._32))))) + ((self._12 * (((self._23 * self._31) - ((self._21 * self._33))))))) + ((self._13 * (((self._21 * self._32) - ((self._22 * self._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        s = v
        m.prependScale((1.0 / s.x),(1.0 / s.y),(1.0 / s.z))
        f = ((m._11 * m._11) + ((m._12 * m._12)))
        cy = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if (cy > 0.01):
            v1 = h3d_Vector(Math.atan2(m._23,m._33),Math.atan2(-m._13,cy),Math.atan2(m._12,m._11))
            v2 = h3d_Vector(Math.atan2(-m._23,-m._33),Math.atan2(-m._13,-cy),Math.atan2(-m._12,-m._11))
            if ((((v1.x * v1.x) + ((v1.y * v1.y))) + ((v1.z * v1.z))) < ((((v2.x * v2.x) + ((v2.y * v2.y))) + ((v2.z * v2.z))))):
                return v1
            else:
                return v2
        else:
            return h3d_Vector(Math.atan2(-m._32,m._22),Math.atan2(-m._13,cy),0.0)

    def toString(self):
        return ((((((((((((((((((((((((((((((((((((("MAT=[\n" + "  [ ") + Std.string(hxd_Math.fmt(self._11))) + ", ") + Std.string(hxd_Math.fmt(self._12))) + ", ") + Std.string(hxd_Math.fmt(self._13))) + ", ") + Std.string(hxd_Math.fmt(self._14))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self._21))) + ", ") + Std.string(hxd_Math.fmt(self._22))) + ", ") + Std.string(hxd_Math.fmt(self._23))) + ", ") + Std.string(hxd_Math.fmt(self._24))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self._31))) + ", ") + Std.string(hxd_Math.fmt(self._32))) + ", ") + Std.string(hxd_Math.fmt(self._33))) + ", ") + Std.string(hxd_Math.fmt(self._34))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self._41))) + ", ") + Std.string(hxd_Math.fmt(self._42))) + ", ") + Std.string(hxd_Math.fmt(self._43))) + ", ") + Std.string(hxd_Math.fmt(self._44))) + " ]\n") + "]")

    def colorHue(self,hue):
        if (hue == 0.):
            return
        f = -hue
        cosA = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        f = -hue
        sinA = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        ch = (((1 - cosA)) / 3)
        tmp = h3d_Matrix.tmp
        tmp._11 = (cosA + ch)
        tmp._12 = (ch - ((0.57735026918962576450914878050196 * sinA)))
        tmp._13 = (ch + ((0.57735026918962576450914878050196 * sinA)))
        tmp._21 = (ch + ((0.57735026918962576450914878050196 * sinA)))
        tmp._22 = (cosA + ch)
        tmp._23 = (ch - ((0.57735026918962576450914878050196 * sinA)))
        tmp._31 = (ch - ((0.57735026918962576450914878050196 * sinA)))
        tmp._32 = (ch + ((0.57735026918962576450914878050196 * sinA)))
        tmp._33 = (cosA + ch)
        tmp._34 = 0
        tmp._41 = 0
        tmp._42 = 0
        tmp._43 = 0
        self.multiply3x4(self,tmp)

    def colorSaturate(self,sat):
        sat = (sat + 1)
        ins = (1 - sat)
        r = (ins * 0.212671)
        g = (ins * 0.71516)
        b = (ins * 0.072169)
        tmp = h3d_Matrix.tmp
        tmp._11 = (r + sat)
        tmp._12 = r
        tmp._13 = r
        tmp._21 = g
        tmp._22 = (g + sat)
        tmp._23 = g
        tmp._31 = b
        tmp._32 = b
        tmp._33 = (b + sat)
        tmp._41 = 0
        tmp._42 = 0
        tmp._43 = 0
        self.multiply3x4(self,tmp)

    def colorContrast(self,contrast):
        tmp = h3d_Matrix.tmp
        v = (contrast + 1)
        tmp._11 = v
        tmp._12 = 0
        tmp._13 = 0
        tmp._21 = 0
        tmp._22 = v
        tmp._23 = 0
        tmp._31 = 0
        tmp._32 = 0
        tmp._33 = v
        tmp._41 = (-contrast * 0.5)
        tmp._42 = (-contrast * 0.5)
        tmp._43 = (-contrast * 0.5)
        self.multiply3x4(self,tmp)

    def colorLightness(self,lightness):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._41
        _hx_local_0._41 = (_hx_local_1 + lightness)
        _hx_local_0._41
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._42
        _hx_local_2._42 = (_hx_local_3 + lightness)
        _hx_local_2._42
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._43
        _hx_local_4._43 = (_hx_local_5 + lightness)
        _hx_local_4._43

    def colorGain(self,color,alpha):
        tmp = h3d_Matrix.tmp
        tmp._11 = (1 - alpha)
        tmp._12 = 0
        tmp._13 = 0
        tmp._21 = 0
        tmp._22 = (1 - alpha)
        tmp._23 = 0
        tmp._31 = 0
        tmp._32 = 0
        tmp._33 = (1 - alpha)
        tmp._41 = (((((color >> 16) & 255)) / 255) * alpha)
        tmp._42 = (((((color >> 8) & 255)) / 255) * alpha)
        tmp._43 = ((((color & 255)) / 255) * alpha)
        self.multiply3x4(self,tmp)

    def colorBits(self,bits,blend):
        t11 = 0.
        t12 = 0.
        t13 = 0.
        t21 = 0.
        t22 = 0.
        t23 = 0.
        t31 = 0.
        t32 = 0.
        t33 = 0.
        c = bits
        if (((c & 1)) == 1):
            t11 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t12 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t13 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t21 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t22 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t23 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t31 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t32 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t33 = 1
        c = (c >> 1)
        r = ((t11 + t21) + t31)
        g = ((t12 + t22) + t32)
        b = ((t13 + t23) + t33)
        if (r > 1):
            t11 = (t11 / r)
            t21 = (t21 / r)
            t31 = (t31 / r)
        if (g > 1):
            t12 = (t12 / g)
            t22 = (t22 / g)
            t32 = (t32 / g)
        if (b > 1):
            t13 = (t13 / b)
            t23 = (t23 / b)
            t33 = (t33 / b)
        b11 = (((self._11 * t11) + ((self._12 * t21))) + ((self._13 * t31)))
        b12 = (((self._11 * t12) + ((self._12 * t22))) + ((self._13 * t32)))
        b13 = (((self._11 * t13) + ((self._12 * t23))) + ((self._13 * t33)))
        b21 = (((self._21 * t11) + ((self._22 * t21))) + ((self._23 * t31)))
        b22 = (((self._21 * t12) + ((self._22 * t22))) + ((self._23 * t32)))
        b23 = (((self._21 * t13) + ((self._22 * t23))) + ((self._23 * t33)))
        b31 = (((self._31 * t11) + ((self._32 * t21))) + ((self._33 * t31)))
        b32 = (((self._31 * t12) + ((self._32 * t22))) + ((self._33 * t32)))
        b33 = (((self._31 * t13) + ((self._32 * t23))) + ((self._33 * t33)))
        ik = blend
        k = (1 - ik)
        self._11 = ((self._11 * k) + ((b11 * ik)))
        self._12 = ((self._12 * k) + ((b12 * ik)))
        self._13 = ((self._13 * k) + ((b13 * ik)))
        self._21 = ((self._21 * k) + ((b21 * ik)))
        self._22 = ((self._22 * k) + ((b22 * ik)))
        self._23 = ((self._23 * k) + ((b23 * ik)))
        self._31 = ((self._31 * k) + ((b31 * ik)))
        self._32 = ((self._32 * k) + ((b32 * ik)))
        self._33 = ((self._33 * k) + ((b33 * ik)))

    def colorAdd(self,c):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._41
        _hx_local_0._41 = (_hx_local_1 + (((((c >> 16) & 255)) / 255)))
        _hx_local_0._41
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._42
        _hx_local_2._42 = (_hx_local_3 + (((((c >> 8) & 255)) / 255)))
        _hx_local_2._42
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._43
        _hx_local_4._43 = (_hx_local_5 + ((((c & 255)) / 255)))
        _hx_local_4._43

    def colorSet(self,c,alpha = None):
        if (alpha is None):
            alpha = 1.
        self.zero()
        self._44 = alpha
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._41
        _hx_local_0._41 = (_hx_local_1 + (((((c >> 16) & 255)) / 255)))
        _hx_local_0._41
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._42
        _hx_local_2._42 = (_hx_local_3 + (((((c >> 8) & 255)) / 255)))
        _hx_local_2._42
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._43
        _hx_local_4._43 = (_hx_local_5 + ((((c & 255)) / 255)))
        _hx_local_4._43

    def adjustColor(self,col):
        if (Reflect.field(col,"hue") is not None):
            self.colorHue(Reflect.field(col,"hue"))
        if (Reflect.field(col,"saturation") is not None):
            self.colorSaturate(Reflect.field(col,"saturation"))
        if (Reflect.field(col,"contrast") is not None):
            self.colorContrast(Reflect.field(col,"contrast"))
        if (Reflect.field(col,"lightness") is not None):
            self.colorLightness(Reflect.field(col,"lightness"))
        if (Reflect.field(col,"gain") is not None):
            self.colorGain(Reflect.field(col,"gain").color,Reflect.field(col,"gain").alpha)

    def toMatrix2D(self,m = None):
        if (m is None):
            m = h2d_col_Matrix()
        m.a = self._11
        m.b = self._12
        m.c = self._21
        m.d = self._22
        m.x = self._41
        m.y = self._42
        return m

    @staticmethod
    def I():
        m = h3d_Matrix()
        m.identity()
        return m

    @staticmethod
    def L(a):
        m = h3d_Matrix()
        m.loadValues(a)
        return m

    @staticmethod
    def T(x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        m = h3d_Matrix()
        m.initTranslation(x,y,z)
        return m

    @staticmethod
    def R(x,y,z):
        m = h3d_Matrix()
        m.initRotation(x,y,z)
        return m

    @staticmethod
    def S(x = None,y = None,z = None):
        if (x is None):
            x = 1.
        if (y is None):
            y = 1.
        if (z is None):
            z = 1.0
        m = h3d_Matrix()
        m.initScale(x,y,z)
        return m

    @staticmethod
    def lookAtX(dir,up = None,m = None):
        if (up is None):
            up = h3d_Vector(0,0,1)
        if (m is None):
            m = h3d_Matrix()
        k = (((dir.x * dir.x) + ((dir.y * dir.y))) + ((dir.z * dir.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        x = (dir.x * k)
        y = (dir.y * k)
        z = (dir.z * k)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ax_x = x
        ax_y = y
        ax_z = z
        ax_w = 1.
        x = ((up.y * ax_z) - ((up.z * ax_y)))
        y = ((up.z * ax_x) - ((up.x * ax_z)))
        z = ((up.x * ax_y) - ((up.y * ax_x)))
        w = 1
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this_x = x
        _this_y = y
        _this_z = z
        _this_w = w
        k = (((_this_x * _this_x) + ((_this_y * _this_y))) + ((_this_z * _this_z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        x = (_this_x * k)
        y = (_this_y * k)
        z = (_this_z * k)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ay_x = x
        ay_y = y
        ay_z = z
        ay_w = 1.
        if ((((ay_x * ay_x) + ((ay_y * ay_y))) + ((ay_z * ay_z))) < 1e-10):
            ay_x = ax_y
            ay_y = ax_z
            ay_z = ax_x
        x = ((ax_y * ay_z) - ((ax_z * ay_y)))
        y = ((ax_z * ay_x) - ((ax_x * ay_z)))
        z = ((ax_x * ay_y) - ((ax_y * ay_x)))
        w = 1
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        az_x = x
        az_y = y
        az_z = z
        az_w = w
        m._11 = ax_x
        m._12 = ax_y
        m._13 = ax_z
        m._14 = 0
        m._21 = ay_x
        m._22 = ay_y
        m._23 = ay_z
        m._24 = 0
        m._31 = az_x
        m._32 = az_y
        m._33 = az_z
        m._34 = 0
        m._41 = 0
        m._42 = 0
        m._43 = 0
        m._44 = 1
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._11 = None
        _hx_o._12 = None
        _hx_o._13 = None
        _hx_o._14 = None
        _hx_o._21 = None
        _hx_o._22 = None
        _hx_o._23 = None
        _hx_o._24 = None
        _hx_o._31 = None
        _hx_o._32 = None
        _hx_o._33 = None
        _hx_o._34 = None
        _hx_o._41 = None
        _hx_o._42 = None
        _hx_o._43 = None
        _hx_o._44 = None
h3d_Matrix._hx_class = h3d_Matrix
_hx_classes["h3d.Matrix"] = h3d_Matrix


class h3d_Quat:
    _hx_class_name = "h3d.Quat"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "w")
    _hx_fields = ["x", "y", "z", "w"]
    _hx_methods = ["set", "identity", "lengthSq", "length", "load", "clone", "initMoveTo", "initNormal", "initDirection", "initRotateAxis", "initRotateMatrix", "normalize", "initRotation", "multiply", "toEuler", "lerp", "slerp", "conjugate", "negate", "dot", "getDirection", "toMatrix", "toString"]

    def __init__(self,x = None,y = None,z = None,w = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (w is None):
            w = 1.
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def set(self,x,y,z,w):
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def identity(self):
        def _hx_local_1():
            def _hx_local_0():
                self.z = 0
                return self.z
            self.y = _hx_local_0()
            return self.y
        self.x = _hx_local_1()
        self.w = 1

    def lengthSq(self):
        return ((((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z))) + ((self.w * self.w)))

    def length(self):
        f = ((((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z))) + ((self.w * self.w)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def load(self,q):
        self.x = q.x
        self.y = q.y
        self.z = q.z
        self.w = q.w

    def clone(self):
        return h3d_Quat(self.x,self.y,self.z,self.w)

    def initMoveTo(self,_hx_from,to):
        hx = (_hx_from.x + to.x)
        hy = (_hx_from.y + to.y)
        hz = (_hx_from.z + to.z)
        f = (((hx * hx) + ((hy * hy))) + ((hz * hz)))
        h = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        self.x = ((_hx_from.y * hz) - ((_hx_from.z * hy)))
        self.y = ((_hx_from.z * hx) - ((_hx_from.x * hz)))
        self.z = ((_hx_from.x * hy) - ((_hx_from.y * hx)))
        self.w = (((_hx_from.x * hx) + ((_hx_from.y * hy))) + ((_hx_from.z * hz)))
        self.normalize()

    def initNormal(self,dir):
        k = (((dir.x * dir.x) + ((dir.y * dir.y))) + ((dir.z * dir.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        x = (dir.x * k)
        y = (dir.y * k)
        z = (dir.z * k)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        dir_x = x
        dir_y = y
        dir_z = z
        if (((dir_x * dir_x) + ((dir_y * dir_y))) < 1e-10):
            self.initDirection(h3d_Vector(1,0,0))
        else:
            x = dir_x
            y = dir_y
            z = 0
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this_x = x
            _this_y = y
            _this_z = z
            k = (((_this_x * _this_x) + ((_this_y * _this_y))) + ((_this_z * _this_z)))
            if (k < 1e-10):
                k = 0
            else:
                k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
            x = (_this_x * k)
            y = (_this_y * k)
            z = (_this_z * k)
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            ay_x = x
            ay_y = y
            ay_z = z
            x = ((dir_y * ay_z) - ((dir_z * ay_y)))
            y = ((dir_z * ay_x) - ((dir_x * ay_z)))
            z = ((dir_x * ay_y) - ((dir_y * ay_x)))
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            az_x = x
            az_y = y
            az_z = z
            x = ((dir_y * az_z) - ((dir_z * az_y)))
            y = ((dir_z * az_x) - ((dir_x * az_z)))
            z = ((dir_x * az_y) - ((dir_y * az_x)))
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this_x = x
            _this_y = y
            _this_z = z
            self.initDirection(h3d_Vector(_this_x,_this_y,_this_z))

    def initDirection(self,dir):
        x = dir.x
        y = dir.y
        z = dir.z
        w = dir.w
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this_x = x
        _this_y = y
        _this_z = z
        _this_w = w
        k = (((_this_x * _this_x) + ((_this_y * _this_y))) + ((_this_z * _this_z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        x = (_this_x * k)
        y = (_this_y * k)
        z = (_this_z * k)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ax_x = x
        ax_y = y
        ax_z = z
        ax_w = 1.
        x = -ax_y
        y = ax_x
        z = 0
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this_x = x
        _this_y = y
        _this_z = z
        _this_w = 1.
        k = (((_this_x * _this_x) + ((_this_y * _this_y))) + ((_this_z * _this_z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        x = (_this_x * k)
        y = (_this_y * k)
        z = (_this_z * k)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ay_x = x
        ay_y = y
        ay_z = z
        ay_w = 1.
        if ((((ay_x * ay_x) + ((ay_y * ay_y))) + ((ay_z * ay_z))) < 1e-10):
            ay_x = ax_y
            ay_y = ax_z
            ay_z = ax_x
        x = ((ax_y * ay_z) - ((ax_z * ay_y)))
        y = ((ax_z * ay_x) - ((ax_x * ay_z)))
        z = ((ax_x * ay_y) - ((ax_y * ay_x)))
        w = 1
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        az_x = x
        az_y = y
        az_z = z
        az_w = w
        tr = ((ax_x + ay_y) + az_z)
        if (tr > 0):
            f = (tr + 1.0)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (((ay_z - az_y)) * ins)
            self.y = (((az_x - ax_z)) * ins)
            self.z = (((ax_y - ay_x)) * ins)
            self.w = (0.25 * s)
        elif ((ax_x > ay_y) and ((ax_x > az_z))):
            f = (((1.0 + ax_x) - ay_y) - az_z)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (0.25 * s)
            self.y = (((ay_x + ax_y)) * ins)
            self.z = (((az_x + ax_z)) * ins)
            self.w = (((ay_z - az_y)) * ins)
        elif (ay_y > az_z):
            f = (((1.0 + ay_y) - ax_x) - az_z)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (((ay_x + ax_y)) * ins)
            self.y = (0.25 * s)
            self.z = (((az_y + ay_z)) * ins)
            self.w = (((az_x - ax_z)) * ins)
        else:
            f = (((1.0 + az_z) - ax_x) - ay_y)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (((az_x + ax_z)) * ins)
            self.y = (((az_y + ay_z)) * ins)
            self.z = (0.25 * s)
            self.w = (((ax_y - ay_x)) * ins)

    def initRotateAxis(self,x,y,z,a):
        f = (a / 2)
        sin = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        f = (a / 2)
        cos = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        self.x = (x * sin)
        self.y = (y * sin)
        self.z = (z * sin)
        f = (((x * x) + ((y * y))) + ((z * z)))
        self.w = (cos * ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        self.normalize()

    def initRotateMatrix(self,m):
        tr = ((m._11 + m._22) + m._33)
        if (tr > 0):
            f = (tr + 1.0)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (((m._23 - m._32)) * ins)
            self.y = (((m._31 - m._13)) * ins)
            self.z = (((m._12 - m._21)) * ins)
            self.w = (0.25 * s)
        elif ((m._11 > m._22) and ((m._11 > m._33))):
            f = (((1.0 + m._11) - m._22) - m._33)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (0.25 * s)
            self.y = (((m._21 + m._12)) * ins)
            self.z = (((m._31 + m._13)) * ins)
            self.w = (((m._23 - m._32)) * ins)
        elif (m._22 > m._33):
            f = (((1.0 + m._22) - m._11) - m._33)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (((m._21 + m._12)) * ins)
            self.y = (0.25 * s)
            self.z = (((m._32 + m._23)) * ins)
            self.w = (((m._31 - m._13)) * ins)
        else:
            f = (((1.0 + m._33) - m._11) - m._22)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (((m._31 + m._13)) * ins)
            self.y = (((m._32 + m._23)) * ins)
            self.z = (0.25 * s)
            self.w = (((m._12 - m._21)) * ins)

    def normalize(self):
        _hx_len = ((((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z))) + ((self.w * self.w)))
        if (_hx_len < 1e-10):
            def _hx_local_1():
                def _hx_local_0():
                    self.z = 0
                    return self.z
                self.y = _hx_local_0()
                return self.y
            self.x = _hx_local_1()
            self.w = 1
        else:
            m = (1. / ((Math.NaN if ((_hx_len < 0)) else python_lib_Math.sqrt(_hx_len))))
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.x
            _hx_local_2.x = (_hx_local_3 * m)
            _hx_local_2.x
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.y
            _hx_local_4.y = (_hx_local_5 * m)
            _hx_local_4.y
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.z
            _hx_local_6.z = (_hx_local_7 * m)
            _hx_local_6.z
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.w
            _hx_local_8.w = (_hx_local_9 * m)
            _hx_local_8.w

    def initRotation(self,ax,ay,az):
        f = (ax * 0.5)
        sinX = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        f = (ax * 0.5)
        cosX = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        f = (ay * 0.5)
        sinY = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        f = (ay * 0.5)
        cosY = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        f = (az * 0.5)
        sinZ = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        f = (az * 0.5)
        cosZ = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        cosYZ = (cosY * cosZ)
        sinYZ = (sinY * sinZ)
        self.x = ((sinX * cosYZ) - ((cosX * sinYZ)))
        self.y = (((cosX * sinY) * cosZ) + (((sinX * cosY) * sinZ)))
        self.z = (((cosX * cosY) * sinZ) - (((sinX * sinY) * cosZ)))
        self.w = ((cosX * cosYZ) + ((sinX * sinYZ)))

    def multiply(self,q1,q2):
        x2 = ((((q1.x * q2.w) + ((q1.w * q2.x))) + ((q1.y * q2.z))) - ((q1.z * q2.y)))
        y2 = ((((q1.w * q2.y) - ((q1.x * q2.z))) + ((q1.y * q2.w))) + ((q1.z * q2.x)))
        z2 = ((((q1.w * q2.z) + ((q1.x * q2.y))) - ((q1.y * q2.x))) + ((q1.z * q2.w)))
        w2 = ((((q1.w * q2.w) - ((q1.x * q2.x))) - ((q1.y * q2.y))) - ((q1.z * q2.z)))
        self.x = x2
        self.y = y2
        self.z = z2
        self.w = w2

    def toEuler(self):
        return self.toMatrix().getEulerAngles()

    def lerp(self,q1,q2,v,nearest = None):
        if (nearest is None):
            nearest = False
        v2 = (1 - v)
        if (nearest and ((((((q1.x * q2.x) + ((q1.y * q2.y))) + ((q1.z * q2.z))) + ((q1.w * q2.w))) < 0))):
            v = -v
        x = ((q1.x * v2) + ((q2.x * v)))
        y = ((q1.y * v2) + ((q2.y * v)))
        z = ((q1.z * v2) + ((q2.z * v)))
        w = ((q1.w * v2) + ((q2.w * v)))
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def slerp(self,q1,q2,v):
        cosHalfTheta = ((((q1.x * q2.x) + ((q1.y * q2.y))) + ((q1.z * q2.z))) + ((q1.w * q2.w)))
        if (((-cosHalfTheta if ((cosHalfTheta < 0)) else cosHalfTheta)) >= 1):
            self.x = q1.x
            self.y = q1.y
            self.z = q1.z
            self.w = q1.w
            return
        halfTheta = Math.acos(cosHalfTheta)
        f = (1 - ((cosHalfTheta * cosHalfTheta)))
        invSinHalfTheta = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        if (((-invSinHalfTheta if ((invSinHalfTheta < 0)) else invSinHalfTheta)) > 1e3):
            v1 = 0.5
            nearest = True
            if (nearest is None):
                nearest = False
            v2 = (1 - v1)
            if (nearest and ((((((q1.x * q2.x) + ((q1.y * q2.y))) + ((q1.z * q2.z))) + ((q1.w * q2.w))) < 0))):
                v1 = -v1
            x = ((q1.x * v2) + ((q2.x * v1)))
            y = ((q1.y * v2) + ((q2.y * v1)))
            z = ((q1.z * v2) + ((q2.z * v1)))
            w = ((q1.w * v2) + ((q2.w * v1)))
            self.x = x
            self.y = y
            self.z = z
            self.w = w
            return
        f = (((1 - v)) * halfTheta)
        a = (((Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))) * invSinHalfTheta)
        f = (v * halfTheta)
        b = ((((Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))) * invSinHalfTheta) * ((-1 if ((cosHalfTheta < 0)) else 1)))
        self.x = ((q1.x * a) + ((q2.x * b)))
        self.y = ((q1.y * a) + ((q2.y * b)))
        self.z = ((q1.z * a) + ((q2.z * b)))
        self.w = ((q1.w * a) + ((q2.w * b)))

    def conjugate(self):
        self.x = -self.x
        self.y = -self.y
        self.z = -self.z

    def negate(self):
        self.x = -self.x
        self.y = -self.y
        self.z = -self.z
        self.w = -self.w

    def dot(self,q):
        return ((((self.x * q.x) + ((self.y * q.y))) + ((self.z * q.z))) + ((self.w * q.w)))

    def getDirection(self):
        return h3d_Vector((1 - ((2 * (((self.y * self.y) + ((self.z * self.z))))))),(2 * (((self.x * self.y) + ((self.z * self.w))))),(2 * (((self.x * self.z) - ((self.y * self.w))))))

    def toMatrix(self,m = None):
        if (m is None):
            m = h3d_Matrix()
        xx = (self.x * self.x)
        xy = (self.x * self.y)
        xz = (self.x * self.z)
        xw = (self.x * self.w)
        yy = (self.y * self.y)
        yz = (self.y * self.z)
        yw = (self.y * self.w)
        zz = (self.z * self.z)
        zw = (self.z * self.w)
        m._11 = (1 - ((2 * ((yy + zz)))))
        m._12 = (2 * ((xy + zw)))
        m._13 = (2 * ((xz - yw)))
        m._14 = 0
        m._21 = (2 * ((xy - zw)))
        m._22 = (1 - ((2 * ((xx + zz)))))
        m._23 = (2 * ((yz + xw)))
        m._24 = 0
        m._31 = (2 * ((xz + yw)))
        m._32 = (2 * ((yz - xw)))
        m._33 = (1 - ((2 * ((xx + yy)))))
        m._34 = 0
        m._41 = 0
        m._42 = 0
        m._43 = 0
        m._44 = 1
        return m

    def toString(self):
        return (((((((("{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.z))) + ",") + Std.string(hxd_Math.fmt(self.w))) + "}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.w = None
h3d_Quat._hx_class = h3d_Quat
_hx_classes["h3d.Quat"] = h3d_Quat


class h3d_Vector:
    _hx_class_name = "h3d.Vector"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "w")
    _hx_fields = ["x", "y", "z", "w"]
    _hx_methods = ["distance", "distanceSq", "sub", "add", "multiply", "equals", "cross", "dot", "lengthSq", "length", "normalize", "normalized", "set", "load", "scale", "lerp", "transform", "transformed", "transform3x4", "transformed3x4", "transform3x3", "transformed3x3", "clone", "toPoint", "toString", "reflect", "dot4", "project", "get_r", "get_g", "get_b", "get_a", "set_r", "set_g", "set_b", "set_a", "setColor", "makeColor", "toColor", "toColorHSL", "scale3", "dot3", "normalizeFast"]
    _hx_statics = ["fromColor", "fromArray"]

    def __init__(self,x = None,y = None,z = None,w = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (w is None):
            w = 1.
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def distance(self,v):
        dx = (v.x - self.x)
        dy = (v.y - self.y)
        dz = (v.z - self.z)
        f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def distanceSq(self,v):
        dx = (v.x - self.x)
        dy = (v.y - self.y)
        dz = (v.z - self.z)
        return (((dx * dx) + ((dy * dy))) + ((dz * dz)))

    def sub(self,v):
        return h3d_Vector((self.x - v.x),(self.y - v.y),(self.z - v.z),(self.w - v.w))

    def add(self,v):
        return h3d_Vector((self.x + v.x),(self.y + v.y),(self.z + v.z),(self.w + v.w))

    def multiply(self,v):
        return h3d_Vector((self.x * v),(self.y * v),(self.z * v),self.w)

    def equals(self,v):
        if (((self.x == v.x) and ((self.y == v.y))) and ((self.z == v.z))):
            return (self.w == v.w)
        else:
            return False

    def cross(self,v):
        return h3d_Vector(((self.y * v.z) - ((self.z * v.y))),((self.z * v.x) - ((self.x * v.z))),((self.x * v.y) - ((self.y * v.x))),1)

    def dot(self,v):
        return (((self.x * v.x) + ((self.y * v.y))) + ((self.z * v.z)))

    def lengthSq(self):
        return (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))

    def length(self):
        f = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def normalize(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * k)
        _hx_local_4.z

    def normalized(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        return h3d_Vector((self.x * k),(self.y * k),(self.z * k))

    def set(self,x = None,y = None,z = None,w = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (w is None):
            w = 1.
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def load(self,v):
        self.x = v.x
        self.y = v.y
        self.z = v.z
        self.w = v.w

    def scale(self,f):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * f)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * f)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * f)
        _hx_local_4.z

    def lerp(self,v1,v2,k):
        a = v1.x
        self.x = (a + ((k * ((v2.x - a)))))
        a = v1.y
        self.y = (a + ((k * ((v2.y - a)))))
        a = v1.z
        self.z = (a + ((k * ((v2.z - a)))))
        a = v1.w
        self.w = (a + ((k * ((v2.w - a)))))

    def transform(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + ((self.w * m._41)))
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + ((self.w * m._42)))
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + ((self.w * m._43)))
        pw = ((((self.x * m._14) + ((self.y * m._24))) + ((self.z * m._34))) + ((self.w * m._44)))
        self.x = px
        self.y = py
        self.z = pz
        self.w = pw

    def transformed(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + ((self.w * m._41)))
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + ((self.w * m._42)))
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + ((self.w * m._43)))
        pw = ((((self.x * m._14) + ((self.y * m._24))) + ((self.z * m._34))) + ((self.w * m._44)))
        return h3d_Vector(px,py,pz,pw)

    def transform3x4(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + ((self.w * m._41)))
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + ((self.w * m._42)))
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + ((self.w * m._43)))
        self.x = px
        self.y = py
        self.z = pz

    def transformed3x4(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + ((self.w * m._41)))
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + ((self.w * m._42)))
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + ((self.w * m._43)))
        return h3d_Vector(px,py,pz)

    def transform3x3(self,m):
        px = (((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31)))
        py = (((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32)))
        pz = (((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33)))
        self.x = px
        self.y = py
        self.z = pz

    def transformed3x3(self,m):
        px = (((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31)))
        py = (((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32)))
        pz = (((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33)))
        return h3d_Vector(px,py,pz)

    def clone(self):
        return h3d_Vector(self.x,self.y,self.z,self.w)

    def toPoint(self):
        return h3d_col_Point(self.x,self.y,self.z)

    def toString(self):
        return (((((((("{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.z))) + ",") + Std.string(hxd_Math.fmt(self.w))) + "}")

    def reflect(self,n):
        k = (2 * ((((self.x * n.x) + ((self.y * n.y))) + ((self.z * n.z)))))
        return h3d_Vector((self.x - ((k * n.x))),(self.y - ((k * n.y))),(self.z - ((k * n.z))),1)

    def dot4(self,v):
        return ((((self.x * v.x) + ((self.y * v.y))) + ((self.z * v.z))) + ((self.w * v.w)))

    def project(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + ((self.w * m._41)))
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + ((self.w * m._42)))
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + ((self.w * m._43)))
        iw = (1 / (((((self.x * m._14) + ((self.y * m._24))) + ((self.z * m._34))) + ((self.w * m._44)))))
        self.x = (px * iw)
        self.y = (py * iw)
        self.z = (pz * iw)
        self.w = 1

    def get_r(self):
        return self.x

    def get_g(self):
        return self.y

    def get_b(self):
        return self.z

    def get_a(self):
        return self.w

    def set_r(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.x = v
                return self.x
            return _hx_local_0()
        return _hx_local_1()

    def set_g(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.y = v
                return self.y
            return _hx_local_0()
        return _hx_local_1()

    def set_b(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.z = v
                return self.z
            return _hx_local_0()
        return _hx_local_1()

    def set_a(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.w = v
                return self.w
            return _hx_local_0()
        return _hx_local_1()

    def setColor(self,c):
        self.x = ((((c >> 16) & 255)) / 255)
        self.y = ((((c >> 8) & 255)) / 255)
        self.z = (((c & 255)) / 255)
        self.w = ((HxOverrides.rshift(c, 24)) / 255)

    def makeColor(self,hue,saturation = None,brightness = None):
        if (saturation is None):
            saturation = 1.
        if (brightness is None):
            brightness = 0.5
        r = HxOverrides.modf(hue, 6.28318530717958623)
        hue = (r if ((r >= 0)) else (r + 6.28318530717958623))
        f = ((2 * brightness) - 1)
        c = (((1 - ((-f if ((f < 0)) else f)))) * saturation)
        f = (HxOverrides.modf(((hue * 3) / 3.14159265358979323), 2.) - 1)
        x = (c * ((1 - ((-f if ((f < 0)) else f)))))
        m = (brightness - ((c / 2)))
        if (hue < 1.04719755119659763):
            self.x = c
            self.y = x
            self.z = 0
        elif (hue < 2.09439510239319526):
            self.x = x
            self.y = c
            self.z = 0
        elif (hue < 3.14159265358979323):
            self.x = 0
            self.y = c
            self.z = x
        elif (hue < 4.18879020478639053):
            self.x = 0
            self.y = x
            self.z = c
        elif (hue < 5.23598775598298882):
            self.x = x
            self.y = 0
            self.z = c
        else:
            self.x = c
            self.y = 0
            self.z = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + m)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + m)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 + m)
        _hx_local_4.z
        self.w = 1

    def toColor(self):
        f = self.w
        x = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        tmp1 = (tmp << 24)
        f = self.x
        x = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        tmp2 = (tmp1 | ((tmp << 16)))
        f = self.y
        x = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        tmp1 = (tmp2 | ((tmp << 8)))
        f = self.z
        x = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        return (tmp1 | tmp)

    def toColorHSL(self):
        a = self.x
        b = self.y
        a1 = (b if ((a < b)) else a)
        b = self.z
        _hx_max = (b if ((a1 < b)) else a1)
        a = self.x
        b = self.y
        a1 = (b if ((a > b)) else a)
        b = self.z
        _hx_min = (b if ((a1 > b)) else a1)
        h = None
        s = None
        l = (((_hx_max + _hx_min)) / 2.0)
        if (_hx_max == _hx_min):
            s = 0.0
            h = s
        else:
            d = (_hx_max - _hx_min)
            s = ((d / (((2 - _hx_max) - _hx_min))) if ((l > 0.5)) else (d / ((_hx_max + _hx_min))))
            if (_hx_max == self.x):
                h = ((((self.y - self.z)) / d) + ((6.0 if ((self.y < self.z)) else 0.0)))
            elif (_hx_max == self.y):
                h = ((((self.z - self.x)) / d) + 2.0)
            else:
                h = ((((self.x - self.y)) / d) + 4.0)
            h = (h * 1.04719755119659763)
        return h3d_Vector(h,s,l,self.w)

    def scale3(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * v)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * v)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * v)
        _hx_local_4.z

    def dot3(self,v):
        return (((self.x * v.x) + ((self.y * v.y))) + ((self.z * v.z)))

    def normalizeFast(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * k)
        _hx_local_4.z

    @staticmethod
    def fromColor(c,scale = None):
        if (scale is None):
            scale = 1.0
        s = (scale / 255)
        return h3d_Vector(((((c >> 16) & 255)) * s),((((c >> 8) & 255)) * s),(((c & 255)) * s),((HxOverrides.rshift(c, 24)) * s))

    @staticmethod
    def fromArray(a):
        r = h3d_Vector()
        if (len(a) > 0):
            r.x = (a[0] if 0 < len(a) else None)
        if (len(a) > 1):
            r.y = (a[1] if 1 < len(a) else None)
        if (len(a) > 2):
            r.z = (a[2] if 2 < len(a) else None)
        if (len(a) > 3):
            r.w = (a[3] if 3 < len(a) else None)
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.w = None
h3d_Vector._hx_class = h3d_Vector
_hx_classes["h3d.Vector"] = h3d_Vector


class h3d_anim_AnimatedObject:
    _hx_class_name = "h3d.anim.AnimatedObject"
    _hx_is_interface = "False"
    __slots__ = ("objectName", "targetObject", "targetSkin", "targetJoint")
    _hx_fields = ["objectName", "targetObject", "targetSkin", "targetJoint"]
    _hx_methods = ["clone"]

    def __init__(self,name):
        self.targetJoint = None
        self.targetSkin = None
        self.targetObject = None
        self.objectName = name

    def clone(self):
        return h3d_anim_AnimatedObject(self.objectName)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.objectName = None
        _hx_o.targetObject = None
        _hx_o.targetSkin = None
        _hx_o.targetJoint = None
h3d_anim_AnimatedObject._hx_class = h3d_anim_AnimatedObject
_hx_classes["h3d.anim.AnimatedObject"] = h3d_anim_AnimatedObject


class h3d_anim_Animation:
    _hx_class_name = "h3d.anim.Animation"
    _hx_is_interface = "False"
    __slots__ = ("name", "resourcePath", "frameCount", "sampling", "frame", "speed", "onAnimEnd", "onEvent", "pause", "loop", "events", "isInstance", "objects", "isSync", "lastEvent")
    _hx_fields = ["name", "resourcePath", "frameCount", "sampling", "frame", "speed", "onAnimEnd", "onEvent", "pause", "loop", "events", "isInstance", "objects", "isSync", "lastEvent"]
    _hx_methods = ["getDuration", "frameToTime", "getIFrame", "unbind", "setEvents", "addEvent", "getEvents", "getObjects", "getEventTime", "setFrame", "clone", "initInstance", "createInstance", "bind", "getPropValue", "sync", "isPlaying", "endFrame", "update", "initAndBind", "toString"]
    _hx_statics = ["EPSILON"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,name,frameCount,sampling):
        self.isSync = None
        self.isInstance = None
        self.events = None
        self.onEvent = None
        self.onAnimEnd = None
        self.resourcePath = None
        self.name = name
        self.frameCount = frameCount
        self.sampling = sampling
        self.objects = []
        self.lastEvent = -1
        self.frame = 0.
        self.speed = 1.
        self.loop = True
        self.pause = False

    def getDuration(self):
        return (self.frameCount / ((self.sampling * self.speed)))

    def frameToTime(self,f):
        return (f / ((self.sampling * self.speed)))

    def getIFrame(self):
        x = self.frame
        f = None
        try:
            f = int(x)
        except BaseException as _g:
            None
            f = None
        _hx_max = self.endFrame()
        if (f == _hx_max):
            f = (f - 1)
        return f

    def unbind(self,objectName):
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (o.objectName == objectName):
                self.isSync = False
                o.targetObject = None
                o.targetSkin = None
                return

    def setEvents(self,el):
        _g = []
        _g1 = 0
        _g2 = self.frameCount
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append(None)
        self.events = _g
        e = HxOverrides.iterator(el)
        while e.hasNext():
            e1 = e.next()
            if (python_internal_ArrayImpl._get(self.events, e1.frame) is None):
                python_internal_ArrayImpl._set(self.events, e1.frame, [])
            _this = python_internal_ArrayImpl._get(self.events, e1.frame)
            x = e1.data
            _this.append(x)

    def addEvent(self,frame,data):
        if (self.events is None):
            self.events = []
        if ((self.events[frame] if frame >= 0 and frame < len(self.events) else None) is None):
            python_internal_ArrayImpl._set(self.events, frame, [data])
        else:
            _this = (self.events[frame] if frame >= 0 and frame < len(self.events) else None)
            _this.append(data)

    def getEvents(self):
        return self.events

    def getObjects(self):
        return self.objects

    def getEventTime(self,id):
        if (self.events is None):
            return None
        _g = 0
        _g1 = len(self.events)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            ev = (self.events[i] if i >= 0 and i < len(self.events) else None)
            if ((ev is not None) and ((python_internal_ArrayImpl.indexOf(ev,id,None) >= 0))):
                return (i / ((self.sampling * self.speed)))
        return None

    def setFrame(self,f):
        self.frame = f
        self.lastEvent = -1
        while (self.frame < 0):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.frame
            _hx_local_0.frame = (_hx_local_1 + self.frameCount)
            _hx_local_0.frame
        while (self.frame > self.frameCount):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.frame
            _hx_local_2.frame = (_hx_local_3 - self.frameCount)
            _hx_local_2.frame

    def clone(self,a = None):
        if (a is None):
            a = h3d_anim_Animation(self.name,self.frameCount,self.sampling)
        a.objects = self.objects
        a.speed = self.speed
        a.loop = self.loop
        a.pause = self.pause
        a.events = self.events
        a.resourcePath = self.resourcePath
        return a

    def initInstance(self):
        self.isInstance = True

    def createInstance(self,base):
        _g = []
        _g1 = 0
        _g2 = self.objects
        while (_g1 < len(_g2)):
            a = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = a.clone()
            _g.append(x)
        objects = _g
        a = self.clone()
        a.objects = objects
        a.bind(base)
        a.initInstance()
        return a

    def bind(self,base):
        currentSkin = None
        _g = 0
        _g1 = list(self.objects)
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (currentSkin is not None):
                j = currentSkin.skinData.namedJoints.h.get(a.objectName,None)
                if (j is not None):
                    a.targetSkin = currentSkin
                    a.targetJoint = j.index
                    continue
            obj = base.getObjectByName(a.objectName)
            if (obj is None):
                python_internal_ArrayImpl.remove(self.objects,a)
                continue
            joint = Std.downcast(obj,h3d_scene_Joint)
            if (joint is not None):
                currentSkin = joint.parent
                a.targetSkin = currentSkin
                a.targetJoint = joint.index
            else:
                a.targetObject = obj
        self.isSync = False

    def getPropValue(self,objectName,propName):
        return None

    def sync(self,decompose = None):
        if (decompose is None):
            decompose = False
        raise haxe_Exception.thrown("assert")

    def isPlaying(self):
        if (not self.pause):
            return (((-self.speed if ((self.speed < 0)) else self.speed)) > 0.000001)
        else:
            return False

    def endFrame(self):
        return self.frameCount

    def update(self,dt):
        if (not self.isInstance):
            raise haxe_Exception.thrown("You must instanciate this animation first")
        if (not self.isPlaying()):
            return 0
        if ((self.events is not None) and ((self.onEvent is not None))):
            x = self.frame
            f0 = None
            try:
                f0 = int(x)
            except BaseException as _g:
                None
                f0 = None
            x = (self.frame + (((dt * self.speed) * self.sampling)))
            f1 = None
            try:
                f1 = int(x)
            except BaseException as _g:
                None
                f1 = None
            if (f1 >= self.frameCount):
                f1 = (self.frameCount - 1)
            _g = f0
            _g1 = (f1 + 1)
            while (_g < _g1):
                f = _g
                _g = (_g + 1)
                if (f == self.lastEvent):
                    continue
                self.lastEvent = f
                if ((self.events[f] if f >= 0 and f < len(self.events) else None) is not None):
                    oldF = self.frame
                    oldDT = dt
                    dt = (dt - ((((f - self.frame)) / ((self.speed * self.sampling)))))
                    self.frame = f
                    _g2 = 0
                    _g3 = (self.events[f] if f >= 0 and f < len(self.events) else None)
                    while (_g2 < len(_g3)):
                        e = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                        _g2 = (_g2 + 1)
                        self.onEvent(e)
                    if ((self.frame == f) and ((f == ((self.frameCount - 1))))):
                        self.frame = oldF
                        dt = oldDT
                        break
                    else:
                        return dt
        if (self.onAnimEnd is not None):
            end = self.endFrame()
            et = (0 if ((self.speed == 0)) else (((end - self.frame)) / ((self.speed * self.sampling))))
            if ((et <= dt) and ((et > 0))):
                self.frame = end
                dt = (dt - et)
                self.onAnimEnd()
                if ((self.frame == end) and self.isPlaying()):
                    if self.loop:
                        self.frame = 0
                    else:
                        dt = 0
                return dt
        _hx_local_3 = self
        _hx_local_4 = _hx_local_3.frame
        _hx_local_3.frame = (_hx_local_4 + (((dt * self.speed) * self.sampling)))
        _hx_local_3.frame
        if (self.frame >= self.frameCount):
            if self.loop:
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.frame
                _hx_local_5.frame = HxOverrides.modf(_hx_local_6, self.frameCount)
                _hx_local_5.frame
            else:
                self.frame = self.frameCount
        return 0

    def initAndBind(self,obj):
        self.bind(obj)
        self.initInstance()
        self.pause = True

    def toString(self):
        return self.name

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.resourcePath = None
        _hx_o.frameCount = None
        _hx_o.sampling = None
        _hx_o.frame = None
        _hx_o.speed = None
        _hx_o.onAnimEnd = None
        _hx_o.onEvent = None
        _hx_o.pause = None
        _hx_o.loop = None
        _hx_o.events = None
        _hx_o.isInstance = None
        _hx_o.objects = None
        _hx_o.isSync = None
        _hx_o.lastEvent = None
h3d_anim_Animation._hx_class = h3d_anim_Animation
_hx_classes["h3d.anim.Animation"] = h3d_anim_Animation

class h3d_anim_DataLayout(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.anim.DataLayout"
    _hx_constructs = ["Position", "Rotation", "Scale", "UV", "Alpha", "Property", "SingleFrame"]
h3d_anim_DataLayout.Position = h3d_anim_DataLayout("Position", 0, ())
h3d_anim_DataLayout.Rotation = h3d_anim_DataLayout("Rotation", 1, ())
h3d_anim_DataLayout.Scale = h3d_anim_DataLayout("Scale", 2, ())
h3d_anim_DataLayout.UV = h3d_anim_DataLayout("UV", 3, ())
h3d_anim_DataLayout.Alpha = h3d_anim_DataLayout("Alpha", 4, ())
h3d_anim_DataLayout.Property = h3d_anim_DataLayout("Property", 5, ())
h3d_anim_DataLayout.SingleFrame = h3d_anim_DataLayout("SingleFrame", 6, ())
h3d_anim_DataLayout._hx_class = h3d_anim_DataLayout
_hx_classes["h3d.anim.DataLayout"] = h3d_anim_DataLayout


class h3d_anim_BufferObject(h3d_anim_AnimatedObject):
    _hx_class_name = "h3d.anim.BufferObject"
    _hx_is_interface = "False"
    __slots__ = ("layout", "dataOffset", "propCurrentValue", "propName", "matrix")
    _hx_fields = ["layout", "dataOffset", "propCurrentValue", "propName", "matrix"]
    _hx_methods = ["getStride", "clone"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_AnimatedObject


    def __init__(self,objectName,dataOffset):
        self.matrix = None
        self.propName = None
        self.propCurrentValue = None
        self.dataOffset = None
        self.layout = None
        super().__init__(objectName)
        self.dataOffset = dataOffset

    def getStride(self):
        stride = 0
        if (((self.layout & ((1 << h3d_anim_DataLayout.Position.index)))) != 0):
            stride = (stride + 3)
        if (((self.layout & ((1 << h3d_anim_DataLayout.Rotation.index)))) != 0):
            stride = (stride + 3)
        if (((self.layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0):
            stride = (stride + 3)
        if (((self.layout & ((1 << h3d_anim_DataLayout.UV.index)))) != 0):
            stride = (stride + 2)
        if (((self.layout & ((1 << h3d_anim_DataLayout.Alpha.index)))) != 0):
            stride = (stride + 1)
        if (((self.layout & ((1 << h3d_anim_DataLayout.Property.index)))) != 0):
            stride = (stride + 1)
        return stride

    def clone(self):
        o = h3d_anim_BufferObject(self.objectName,self.dataOffset)
        o.layout = self.layout
        o.propName = self.propName
        return o

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.layout = None
        _hx_o.dataOffset = None
        _hx_o.propCurrentValue = None
        _hx_o.propName = None
        _hx_o.matrix = None
h3d_anim_BufferObject._hx_class = h3d_anim_BufferObject
_hx_classes["h3d.anim.BufferObject"] = h3d_anim_BufferObject


class h3d_anim_BufferAnimation(h3d_anim_Animation):
    _hx_class_name = "h3d.anim.BufferAnimation"
    _hx_is_interface = "False"
    __slots__ = ("syncFrame", "data", "stride")
    _hx_fields = ["syncFrame", "data", "stride"]
    _hx_methods = ["setData", "addObject", "getPropValue", "getFrames", "clone", "endFrame", "initInstance", "sortByFrameCountDesc", "uvLerp", "sync"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_Animation


    def __init__(self,name,frame,sampling):
        self.stride = None
        self.data = None
        self.syncFrame = None
        super().__init__(name,frame,sampling)
        self.syncFrame = -1

    def setData(self,data,stride):
        self.data = data
        self.stride = stride

    def addObject(self,objName,offset):
        f = h3d_anim_BufferObject(objName,offset)
        _this = self.objects
        _this.append(f)
        return f

    def getPropValue(self,objName,propName):
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((o.objectName == objName) and ((o.propName == propName))):
                return o.propCurrentValue
        return None

    def getFrames(self):
        return self.objects

    def clone(self,a = None):
        if (a is None):
            a = h3d_anim_BufferAnimation(self.name,self.frameCount,self.sampling)
        super().clone(a)
        la = Std.downcast(a,h3d_anim_BufferAnimation)
        la.setData(self.data,self.stride)
        return a

    def endFrame(self):
        if self.loop:
            return self.frameCount
        else:
            return (self.frameCount - 1)

    def initInstance(self):
        super().initInstance()
        frames = self.objects
        _g = 0
        while (_g < len(frames)):
            a = (frames[_g] if _g >= 0 and _g < len(frames) else None)
            _g = (_g + 1)
            if (((a.layout & ((1 << h3d_anim_DataLayout.Property.index)))) != 0):
                a.propCurrentValue = self.data[a.dataOffset]
            if ((((a.layout & ((1 << h3d_anim_DataLayout.Alpha.index)))) != 0) and (((a.targetObject is None) or ((Std.downcast(a.targetObject,h3d_scene_Mesh) is None))))):
                raise haxe_Exception.thrown((HxOverrides.stringOrNull(a.objectName) + " should be a mesh (for alpha animation)"))
            if (((((a.layout & ((1 << h3d_anim_DataLayout.Position.index)))) != 0) or ((((a.layout & ((1 << h3d_anim_DataLayout.Rotation.index)))) != 0))) or ((((a.layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0))):
                a.matrix = h3d_Matrix()
                a.matrix.identity()
                if ((((a.layout & ((1 << h3d_anim_DataLayout.Position.index)))) == 0) and ((a.targetSkin is not None))):
                    m2 = python_internal_ArrayImpl._get(a.targetSkin.getSkinData().allJoints, a.targetJoint).defMat
                    a.matrix._14 = m2._41
                    a.matrix._24 = m2._42
                    a.matrix._34 = m2._43
        frames.sort(key= python_lib_Functools.cmp_to_key(self.sortByFrameCountDesc))

    def sortByFrameCountDesc(self,o1,o2):
        return (((0 if ((((o2.layout & ((1 << h3d_anim_DataLayout.SingleFrame.index)))) != 0)) else 1)) - ((0 if ((((o1.layout & ((1 << h3d_anim_DataLayout.SingleFrame.index)))) != 0)) else 1)))

    def uvLerp(self,v1,v2,k):
        v1 = HxOverrides.modf(v1, 1.)
        v2 = HxOverrides.modf(v2, 1.)
        if (v1 < ((v2 - 0.5))):
            v1 = (v1 + 1)
        elif (v1 > ((v2 + 0.5))):
            v1 = (v1 - 1)
        return ((v1 * ((1 - k))) + ((v2 * k)))

    def sync(self,decompose = None):
        if (decompose is None):
            decompose = False
        _gthis = self
        if ((self.frame == self.syncFrame) and (not decompose)):
            return
        x = self.frame
        f = None
        try:
            f = int(x)
        except BaseException as _g:
            None
            f = None
        _hx_max = self.endFrame()
        if (f == _hx_max):
            f = (f - 1)
        frame1 = f
        frame2 = HxOverrides.mod(((frame1 + 1)), self.frameCount)
        k2 = (self.frame - frame1)
        k1 = (1 - k2)
        if (frame1 < 0):
            frame2 = 0
            frame1 = frame2
        elif (self.frame >= self.frameCount):
            frame2 = (self.frameCount - 1)
            frame1 = frame2
        elif ((not self.loop) and ((frame2 == 0))):
            frame2 = (self.frameCount - 1)
        self.syncFrame = self.frame
        if decompose:
            self.isSync = False
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((o.targetObject is None) and ((o.targetSkin is None))):
                continue
            layout = o.layout
            offset1 = ((self.stride * frame1) + o.dataOffset)
            offset2 = ((self.stride * frame2) + o.dataOffset)
            frame11 = frame1
            frame21 = frame2
            if (((layout & ((1 << h3d_anim_DataLayout.SingleFrame.index)))) != 0):
                if self.isSync:
                    break
                frame21 = 0
                frame11 = frame21
                offset2 = o.dataOffset
                offset1 = offset2
            m = o.matrix
            if (m is not None):
                if (((layout & ((1 << h3d_anim_DataLayout.Position.index)))) != 0):
                    index = offset1
                    offset1 = (offset1 + 1)
                    index1 = offset2
                    offset2 = (offset2 + 1)
                    m._41 = ((_gthis.data[index] * k1) + ((_gthis.data[index1] * k2)))
                    index2 = offset1
                    offset1 = (offset1 + 1)
                    index3 = offset2
                    offset2 = (offset2 + 1)
                    m._42 = ((_gthis.data[index2] * k1) + ((_gthis.data[index3] * k2)))
                    index4 = offset1
                    offset1 = (offset1 + 1)
                    index5 = offset2
                    offset2 = (offset2 + 1)
                    m._43 = ((_gthis.data[index4] * k1) + ((_gthis.data[index5] * k2)))
                else:
                    m._41 = m._14
                    m._42 = m._24
                    m._43 = m._34
                if (((layout & ((1 << h3d_anim_DataLayout.Rotation.index)))) != 0):
                    index6 = offset1
                    offset1 = (offset1 + 1)
                    q1x = self.data[index6]
                    index7 = offset1
                    offset1 = (offset1 + 1)
                    q1y = self.data[index7]
                    index8 = offset1
                    offset1 = (offset1 + 1)
                    q1z = self.data[index8]
                    f = (1 - ((((q1x * q1x) + ((q1y * q1y))) + ((q1z * q1z)))))
                    v = (-f if ((f < 0)) else f)
                    q1w = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
                    index9 = offset2
                    offset2 = (offset2 + 1)
                    q2x = self.data[index9]
                    index10 = offset2
                    offset2 = (offset2 + 1)
                    q2y = self.data[index10]
                    index11 = offset2
                    offset2 = (offset2 + 1)
                    q2z = self.data[index11]
                    f1 = (1 - ((((q2x * q2x) + ((q2y * q2y))) + ((q2z * q2z)))))
                    v1 = (-f1 if ((f1 < 0)) else f1)
                    q2w = (Math.NaN if ((v1 < 0)) else python_lib_Math.sqrt(v1))
                    dot = ((((q1x * q2x) + ((q1y * q2y))) + ((q1z * q2z))) + ((q1w * q2w)))
                    q2 = (-k2 if ((dot < 0)) else k2)
                    qx = ((q1x * k1) + ((q2x * q2)))
                    qy = ((q1y * k1) + ((q2y * q2)))
                    qz = ((q1z * k1) + ((q2z * q2)))
                    qw = ((q1w * k1) + ((q2w * q2)))
                    v2 = ((((qx * qx) + ((qy * qy))) + ((qz * qz))) + ((qw * qw)))
                    ql = (1 / ((Math.NaN if ((v2 < 0)) else python_lib_Math.sqrt(v2))))
                    qx = (qx * ql)
                    qy = (qy * ql)
                    qz = (qz * ql)
                    qw = (qw * ql)
                    if decompose:
                        m._12 = qx
                        m._13 = qy
                        m._21 = qz
                        m._23 = qw
                        if (((layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0):
                            index12 = offset1
                            offset1 = (offset1 + 1)
                            index13 = offset2
                            offset2 = (offset2 + 1)
                            m._11 = ((_gthis.data[index12] * k1) + ((_gthis.data[index13] * k2)))
                            index14 = offset1
                            offset1 = (offset1 + 1)
                            index15 = offset2
                            offset2 = (offset2 + 1)
                            m._22 = ((_gthis.data[index14] * k1) + ((_gthis.data[index15] * k2)))
                            index16 = offset1
                            offset1 = (offset1 + 1)
                            index17 = offset2
                            offset2 = (offset2 + 1)
                            m._33 = ((_gthis.data[index16] * k1) + ((_gthis.data[index17] * k2)))
                        else:
                            m._11 = 1
                            m._22 = 1
                            m._33 = 1
                    else:
                        xx = (qx * qx)
                        xy = (qx * qy)
                        xz = (qx * qz)
                        xw = (qx * qw)
                        yy = (qy * qy)
                        yz = (qy * qz)
                        yw = (qy * qw)
                        zz = (qz * qz)
                        zw = (qz * qw)
                        m._11 = (1 - ((2 * ((yy + zz)))))
                        m._12 = (2 * ((xy + zw)))
                        m._13 = (2 * ((xz - yw)))
                        m._21 = (2 * ((xy - zw)))
                        m._22 = (1 - ((2 * ((xx + zz)))))
                        m._23 = (2 * ((yz + xw)))
                        m._31 = (2 * ((xz + yw)))
                        m._32 = (2 * ((yz - xw)))
                        m._33 = (1 - ((2 * ((xx + yy)))))
                        if (((layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0):
                            index18 = offset1
                            offset1 = (offset1 + 1)
                            index19 = offset2
                            offset2 = (offset2 + 1)
                            sx = ((_gthis.data[index18] * k1) + ((_gthis.data[index19] * k2)))
                            index20 = offset1
                            offset1 = (offset1 + 1)
                            index21 = offset2
                            offset2 = (offset2 + 1)
                            sy = ((_gthis.data[index20] * k1) + ((_gthis.data[index21] * k2)))
                            index22 = offset1
                            offset1 = (offset1 + 1)
                            index23 = offset2
                            offset2 = (offset2 + 1)
                            sz = ((_gthis.data[index22] * k1) + ((_gthis.data[index23] * k2)))
                            m._11 = (m._11 * sx)
                            m._12 = (m._12 * sx)
                            m._13 = (m._13 * sx)
                            m._21 = (m._21 * sy)
                            m._22 = (m._22 * sy)
                            m._23 = (m._23 * sy)
                            m._31 = (m._31 * sz)
                            m._32 = (m._32 * sz)
                            m._33 = (m._33 * sz)
                else:
                    m._12 = 0
                    m._13 = 0
                    m._21 = 0
                    m._23 = (1 if decompose else 0)
                    if (((layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0):
                        index24 = offset1
                        offset1 = (offset1 + 1)
                        index25 = offset2
                        offset2 = (offset2 + 1)
                        m._11 = ((_gthis.data[index24] * k1) + ((_gthis.data[index25] * k2)))
                        index26 = offset1
                        offset1 = (offset1 + 1)
                        index27 = offset2
                        offset2 = (offset2 + 1)
                        m._22 = ((_gthis.data[index26] * k1) + ((_gthis.data[index27] * k2)))
                        index28 = offset1
                        offset1 = (offset1 + 1)
                        index29 = offset2
                        offset2 = (offset2 + 1)
                        m._33 = ((_gthis.data[index28] * k1) + ((_gthis.data[index29] * k2)))
                    else:
                        m._11 = 1
                        m._22 = 1
                        m._33 = 1
                if (o.targetSkin is not None):
                    python_internal_ArrayImpl._set(o.targetSkin.currentRelPose, o.targetJoint, m)
                    o.targetSkin.jointsUpdated = True
                else:
                    _this = o.targetObject
                    _this.defaultTransform = m
                    f2 = 1
                    b = True
                    if b:
                        _this.flags = (_this.flags | f2)
                    else:
                        _this.flags = (_this.flags & ~f2)
            if (((layout & ((1 << h3d_anim_DataLayout.UV.index)))) != 0):
                mat = o.targetObject.toMesh().material
                s = mat.passes.getShader(h3d_shader_UVDelta)
                if (s is None):
                    s = mat.passes.addShader(h3d_shader_UVDelta())
                    mat.get_texture().set_wrap(h3d_mat_Wrap.Repeat)
                index30 = offset1
                offset1 = (offset1 + 1)
                v11 = self.data[index30]
                index31 = offset2
                offset2 = (offset2 + 1)
                v21 = self.data[index31]
                v11 = HxOverrides.modf(v11, 1.)
                v21 = HxOverrides.modf(v21, 1.)
                if (v11 < ((v21 - 0.5))):
                    v11 = (v11 + 1)
                elif (v11 > ((v21 + 0.5))):
                    v11 = (v11 - 1)
                s.uvDelta__.x = ((v11 * ((1 - k2))) + ((v21 * k2)))
                index32 = offset1
                offset1 = (offset1 + 1)
                v12 = self.data[index32]
                index33 = offset2
                offset2 = (offset2 + 1)
                v22 = self.data[index33]
                v12 = HxOverrides.modf(v12, 1.)
                v22 = HxOverrides.modf(v22, 1.)
                if (v12 < ((v22 - 0.5))):
                    v12 = (v12 + 1)
                elif (v12 > ((v22 + 0.5))):
                    v12 = (v12 - 1)
                s.uvDelta__.y = ((v12 * ((1 - k2))) + ((v22 * k2)))
            if (((layout & ((1 << h3d_anim_DataLayout.Alpha.index)))) != 0):
                mat1 = o.targetObject.toMesh().material
                if (mat1.blendMode == h2d_BlendMode._hx_None):
                    mat1.set_blendMode(h2d_BlendMode.Alpha)
                index34 = offset1
                offset1 = (offset1 + 1)
                tmp = (_gthis.data[index34] * k1)
                index35 = offset2
                offset2 = (offset2 + 1)
                tmp1 = (_gthis.data[index35] * k2)
                mat1.mshader.color__.w = (tmp + tmp1)
            if (((layout & ((1 << h3d_anim_DataLayout.Property.index)))) != 0):
                index36 = offset1
                offset1 = (offset1 + 1)
                index37 = offset2
                offset2 = (offset2 + 1)
                o.propCurrentValue = ((_gthis.data[index36] * k1) + ((_gthis.data[index37] * k2)))
        if (not decompose):
            self.isSync = True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.syncFrame = None
        _hx_o.data = None
        _hx_o.stride = None
h3d_anim_BufferAnimation._hx_class = h3d_anim_BufferAnimation
_hx_classes["h3d.anim.BufferAnimation"] = h3d_anim_BufferAnimation


class h3d_anim_LinearFrame:
    _hx_class_name = "h3d.anim.LinearFrame"
    _hx_is_interface = "False"
    __slots__ = ("tx", "ty", "tz", "qx", "qy", "qz", "qw", "sx", "sy", "sz")
    _hx_fields = ["tx", "ty", "tz", "qx", "qy", "qz", "qw", "sx", "sy", "sz"]
    _hx_methods = ["toMatrix"]

    def __init__(self):
        self.sz = None
        self.sy = None
        self.sx = None
        self.qw = None
        self.qz = None
        self.qy = None
        self.qx = None
        self.tz = None
        self.ty = None
        self.tx = None

    def toMatrix(self):
        m = h3d_Matrix()
        h3d_Quat(self.qx,self.qy,self.qz,self.qw).toMatrix(m)
        m.prependScale(self.sx,self.sy,self.sz)
        m.translate(self.tx,self.ty,self.tz)
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tx = None
        _hx_o.ty = None
        _hx_o.tz = None
        _hx_o.qx = None
        _hx_o.qy = None
        _hx_o.qz = None
        _hx_o.qw = None
        _hx_o.sx = None
        _hx_o.sy = None
        _hx_o.sz = None
h3d_anim_LinearFrame._hx_class = h3d_anim_LinearFrame
_hx_classes["h3d.anim.LinearFrame"] = h3d_anim_LinearFrame


class h3d_anim_LinearObject(h3d_anim_AnimatedObject):
    _hx_class_name = "h3d.anim.LinearObject"
    _hx_is_interface = "False"
    __slots__ = ("hasPosition", "hasRotation", "hasScale", "frames", "alphas", "uvs", "propName", "propValues", "matrix", "propCurrentValue")
    _hx_fields = ["hasPosition", "hasRotation", "hasScale", "frames", "alphas", "uvs", "propName", "propValues", "matrix", "propCurrentValue"]
    _hx_methods = ["clone"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_AnimatedObject


    def __init__(self,name):
        self.propCurrentValue = None
        self.matrix = None
        self.propValues = None
        self.propName = None
        self.uvs = None
        self.alphas = None
        self.frames = None
        self.hasScale = None
        self.hasRotation = None
        self.hasPosition = True
        super().__init__(name)

    def clone(self):
        o = h3d_anim_LinearObject(self.objectName)
        o.hasPosition = self.hasPosition
        o.hasRotation = self.hasRotation
        o.hasScale = self.hasScale
        o.frames = self.frames
        o.alphas = self.alphas
        o.uvs = self.uvs
        o.propName = self.propName
        o.propValues = self.propValues
        return o

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.hasPosition = None
        _hx_o.hasRotation = None
        _hx_o.hasScale = None
        _hx_o.frames = None
        _hx_o.alphas = None
        _hx_o.uvs = None
        _hx_o.propName = None
        _hx_o.propValues = None
        _hx_o.matrix = None
        _hx_o.propCurrentValue = None
h3d_anim_LinearObject._hx_class = h3d_anim_LinearObject
_hx_classes["h3d.anim.LinearObject"] = h3d_anim_LinearObject


class h3d_anim_LinearAnimation(h3d_anim_Animation):
    _hx_class_name = "h3d.anim.LinearAnimation"
    _hx_is_interface = "False"
    __slots__ = ("syncFrame",)
    _hx_fields = ["syncFrame"]
    _hx_methods = ["addCurve", "addAlphaCurve", "addUVCurve", "addPropCurve", "getPropValue", "getFrames", "clone", "endFrame", "initInstance", "sortByFrameCountDesc", "uvLerp", "sync"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_Animation


    def __init__(self,name,frame,sampling):
        self.syncFrame = None
        super().__init__(name,frame,sampling)
        self.syncFrame = -1

    def addCurve(self,objName,frames,hasPos,hasRot,hasScale):
        f = h3d_anim_LinearObject(objName)
        f.frames = frames
        f.hasPosition = hasPos
        f.hasRotation = hasRot
        f.hasScale = hasScale
        _this = self.objects
        _this.append(f)

    def addAlphaCurve(self,objName,alphas):
        f = h3d_anim_LinearObject(objName)
        f.alphas = alphas
        _this = self.objects
        _this.append(f)

    def addUVCurve(self,objName,uvs):
        f = h3d_anim_LinearObject(objName)
        f.uvs = uvs
        _this = self.objects
        _this.append(f)

    def addPropCurve(self,objName,propName,values):
        f = h3d_anim_LinearObject(objName)
        f.propName = propName
        f.propValues = values
        _this = self.objects
        _this.append(f)

    def getPropValue(self,objName,propName):
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((o.objectName == objName) and ((o.propName == propName))):
                return o.propCurrentValue
        return None

    def getFrames(self):
        return self.objects

    def clone(self,a = None):
        if (a is None):
            a = h3d_anim_LinearAnimation(self.name,self.frameCount,self.sampling)
        super().clone(a)
        return a

    def endFrame(self):
        if self.loop:
            return self.frameCount
        else:
            return (self.frameCount - 1)

    def initInstance(self):
        super().initInstance()
        frames = self.objects
        _g = 0
        while (_g < len(frames)):
            a = (frames[_g] if _g >= 0 and _g < len(frames) else None)
            _g = (_g + 1)
            if (a.propValues is not None):
                a.propCurrentValue = a.propValues[0]
                continue
            if ((a.alphas is not None) and (((a.targetObject is None) or ((Std.downcast(a.targetObject,h3d_scene_Mesh) is None))))):
                raise haxe_Exception.thrown((HxOverrides.stringOrNull(a.objectName) + " should be a mesh (for alpha animation)"))
            if ((a.uvs is not None) or ((a.alphas is not None))):
                continue
            a.matrix = h3d_Matrix()
            a.matrix.identity()
        frames.sort(key= python_lib_Functools.cmp_to_key(self.sortByFrameCountDesc))

    def sortByFrameCountDesc(self,o1,o2):
        return (((10 if ((o2.frames is None)) else len(o2.frames))) - ((10 if ((o1.frames is None)) else len(o1.frames))))

    def uvLerp(self,v1,v2,k):
        v1 = HxOverrides.modf(v1, 1.)
        v2 = HxOverrides.modf(v2, 1.)
        if (v1 < ((v2 - 0.5))):
            v1 = (v1 + 1)
        elif (v1 > ((v2 + 0.5))):
            v1 = (v1 - 1)
        return ((v1 * ((1 - k))) + ((v2 * k)))

    def sync(self,decompose = None):
        if (decompose is None):
            decompose = False
        if ((self.frame == self.syncFrame) and (not decompose)):
            return
        x = self.frame
        f = None
        try:
            f = int(x)
        except BaseException as _g:
            None
            f = None
        _hx_max = self.endFrame()
        if (f == _hx_max):
            f = (f - 1)
        frame1 = f
        frame2 = HxOverrides.mod(((frame1 + 1)), self.frameCount)
        k2 = (self.frame - frame1)
        k1 = (1 - k2)
        if (frame1 < 0):
            frame2 = 0
            frame1 = frame2
        elif (self.frame >= self.frameCount):
            frame2 = (self.frameCount - 1)
            frame1 = frame2
        elif ((not self.loop) and ((frame2 == 0))):
            frame2 = (self.frameCount - 1)
        self.syncFrame = self.frame
        if decompose:
            self.isSync = False
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((o.targetObject is None) and ((o.targetSkin is None))):
                continue
            if (o.alphas is not None):
                mat = o.targetObject.toMesh().material
                if (mat.blendMode == h2d_BlendMode._hx_None):
                    mat.set_blendMode(h2d_BlendMode.Alpha)
                tmp = (o.alphas[frame1] * k1)
                tmp1 = (o.alphas[frame2] * k2)
                mat.mshader.color__.w = (tmp + tmp1)
                continue
            if (o.uvs is not None):
                mat1 = o.targetObject.toMesh().material
                s = mat1.passes.getShader(h3d_shader_UVDelta)
                if (s is None):
                    s = mat1.passes.addShader(h3d_shader_UVDelta())
                    mat1.get_texture().set_wrap(h3d_mat_Wrap.Repeat)
                v1 = o.uvs[(frame1 << 1)]
                v2 = o.uvs[(frame2 << 1)]
                v1 = HxOverrides.modf(v1, 1.)
                v2 = HxOverrides.modf(v2, 1.)
                if (v1 < ((v2 - 0.5))):
                    v1 = (v1 + 1)
                elif (v1 > ((v2 + 0.5))):
                    v1 = (v1 - 1)
                s.uvDelta__.x = ((v1 * ((1 - k2))) + ((v2 * k2)))
                v11 = o.uvs[((frame1 << 1) | 1)]
                v21 = o.uvs[((frame2 << 1) | 1)]
                v11 = HxOverrides.modf(v11, 1.)
                v21 = HxOverrides.modf(v21, 1.)
                if (v11 < ((v21 - 0.5))):
                    v11 = (v11 + 1)
                elif (v11 > ((v21 + 0.5))):
                    v11 = (v11 - 1)
                s.uvDelta__.y = ((v11 * ((1 - k2))) + ((v21 * k2)))
                continue
            if (o.propValues is not None):
                o.propCurrentValue = ((o.propValues[frame1] * k1) + ((o.propValues[frame2] * k2)))
                continue
            frame11 = frame1
            frame21 = frame2
            if (len(o.frames) == 1):
                if self.isSync:
                    break
                frame21 = 0
                frame11 = frame21
            f1 = o.frames[frame11]
            f2 = o.frames[frame21]
            m = o.matrix
            m._41 = ((f1.tx * k1) + ((f2.tx * k2)))
            m._42 = ((f1.ty * k1) + ((f2.ty * k2)))
            m._43 = ((f1.tz * k1) + ((f2.tz * k2)))
            if o.hasRotation:
                dot = ((((f1.qx * f2.qx) + ((f1.qy * f2.qy))) + ((f1.qz * f2.qz))) + ((f1.qw * f2.qw)))
                q2 = (-k2 if ((dot < 0)) else k2)
                qx = ((f1.qx * k1) + ((f2.qx * q2)))
                qy = ((f1.qy * k1) + ((f2.qy * q2)))
                qz = ((f1.qz * k1) + ((f2.qz * q2)))
                qw = ((f1.qw * k1) + ((f2.qw * q2)))
                v = ((((qx * qx) + ((qy * qy))) + ((qz * qz))) + ((qw * qw)))
                ql = (1 / ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))
                qx = (qx * ql)
                qy = (qy * ql)
                qz = (qz * ql)
                qw = (qw * ql)
                if decompose:
                    m._12 = qx
                    m._13 = qy
                    m._21 = qz
                    m._23 = qw
                    if o.hasScale:
                        m._11 = ((f1.sx * k1) + ((f2.sx * k2)))
                        m._22 = ((f1.sy * k1) + ((f2.sy * k2)))
                        m._33 = ((f1.sz * k1) + ((f2.sz * k2)))
                    else:
                        m._11 = 1
                        m._22 = 1
                        m._33 = 1
                else:
                    xx = (qx * qx)
                    xy = (qx * qy)
                    xz = (qx * qz)
                    xw = (qx * qw)
                    yy = (qy * qy)
                    yz = (qy * qz)
                    yw = (qy * qw)
                    zz = (qz * qz)
                    zw = (qz * qw)
                    m._11 = (1 - ((2 * ((yy + zz)))))
                    m._12 = (2 * ((xy + zw)))
                    m._13 = (2 * ((xz - yw)))
                    m._21 = (2 * ((xy - zw)))
                    m._22 = (1 - ((2 * ((xx + zz)))))
                    m._23 = (2 * ((yz + xw)))
                    m._31 = (2 * ((xz + yw)))
                    m._32 = (2 * ((yz - xw)))
                    m._33 = (1 - ((2 * ((xx + yy)))))
                    if o.hasScale:
                        sx = ((f1.sx * k1) + ((f2.sx * k2)))
                        sy = ((f1.sy * k1) + ((f2.sy * k2)))
                        sz = ((f1.sz * k1) + ((f2.sz * k2)))
                        m._11 = (m._11 * sx)
                        m._12 = (m._12 * sx)
                        m._13 = (m._13 * sx)
                        m._21 = (m._21 * sy)
                        m._22 = (m._22 * sy)
                        m._23 = (m._23 * sy)
                        m._31 = (m._31 * sz)
                        m._32 = (m._32 * sz)
                        m._33 = (m._33 * sz)
            else:
                m._12 = 0
                m._13 = 0
                m._21 = 0
                m._23 = (1 if decompose else 0)
                if o.hasScale:
                    m._11 = ((f1.sx * k1) + ((f2.sx * k2)))
                    m._22 = ((f1.sy * k1) + ((f2.sy * k2)))
                    m._33 = ((f1.sz * k1) + ((f2.sz * k2)))
                else:
                    m._11 = 1
                    m._22 = 1
                    m._33 = 1
            if (o.targetSkin is not None):
                python_internal_ArrayImpl._set(o.targetSkin.currentRelPose, o.targetJoint, o.matrix)
                o.targetSkin.jointsUpdated = True
            else:
                _this = o.targetObject
                v3 = o.matrix
                _this.defaultTransform = v3
                f = 1
                b = True
                if b:
                    _this.flags = (_this.flags | f)
                else:
                    _this.flags = (_this.flags & ~f)
        if (not decompose):
            self.isSync = True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.syncFrame = None
h3d_anim_LinearAnimation._hx_class = h3d_anim_LinearAnimation
_hx_classes["h3d.anim.LinearAnimation"] = h3d_anim_LinearAnimation


class h3d_anim_Joint:
    _hx_class_name = "h3d.anim.Joint"
    _hx_is_interface = "False"
    __slots__ = ("index", "name", "bindIndex", "splitIndex", "defMat", "transPos", "parent", "subs", "offsets", "offsetRay", "retargetAnim")
    _hx_fields = ["index", "name", "bindIndex", "splitIndex", "defMat", "transPos", "parent", "subs", "offsets", "offsetRay", "retargetAnim"]

    def __init__(self):
        self.retargetAnim = None
        self.offsetRay = None
        self.offsets = None
        self.parent = None
        self.transPos = None
        self.defMat = None
        self.name = None
        self.index = None
        self.bindIndex = -1
        self.splitIndex = -1
        self.subs = []

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.name = None
        _hx_o.bindIndex = None
        _hx_o.splitIndex = None
        _hx_o.defMat = None
        _hx_o.transPos = None
        _hx_o.parent = None
        _hx_o.subs = None
        _hx_o.offsets = None
        _hx_o.offsetRay = None
        _hx_o.retargetAnim = None
h3d_anim_Joint._hx_class = h3d_anim_Joint
_hx_classes["h3d.anim.Joint"] = h3d_anim_Joint


class h3d_anim__Skin_Permut:
    _hx_class_name = "h3d.anim._Skin.Permut"
    _hx_is_interface = "False"
    __slots__ = ("joints", "triangles", "material", "indexedJoints")
    _hx_fields = ["joints", "triangles", "material", "indexedJoints"]

    def __init__(self):
        self.indexedJoints = None
        self.material = None
        self.triangles = None
        self.joints = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.joints = None
        _hx_o.triangles = None
        _hx_o.material = None
        _hx_o.indexedJoints = None
h3d_anim__Skin_Permut._hx_class = h3d_anim__Skin_Permut
_hx_classes["h3d.anim._Skin.Permut"] = h3d_anim__Skin_Permut


class h3d_anim__Skin_Influence:
    _hx_class_name = "h3d.anim._Skin.Influence"
    _hx_is_interface = "False"
    __slots__ = ("j", "w")
    _hx_fields = ["j", "w"]

    def __init__(self,j,w):
        self.j = j
        self.w = w

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.j = None
        _hx_o.w = None
h3d_anim__Skin_Influence._hx_class = h3d_anim__Skin_Influence
_hx_classes["h3d.anim._Skin.Influence"] = h3d_anim__Skin_Influence


class h3d_anim_Skin:
    _hx_class_name = "h3d.anim.Skin"
    _hx_is_interface = "False"
    __slots__ = ("name", "vertexCount", "bonesPerVertex", "vertexJoints", "vertexWeights", "rootJoints", "namedJoints", "allJoints", "boundJoints", "primitive", "splitJoints", "triangleGroups", "envelop")
    _hx_fields = ["name", "vertexCount", "bonesPerVertex", "vertexJoints", "vertexWeights", "rootJoints", "namedJoints", "allJoints", "boundJoints", "primitive", "splitJoints", "triangleGroups", "envelop"]
    _hx_methods = ["setJoints", "addInfluence", "sortInfluences", "isSplit", "initWeights", "sortByBindIndex", "isSub", "merge", "jointsDiff", "split"]

    def __init__(self,name,vertexCount,bonesPerVertex):
        self.envelop = None
        self.triangleGroups = None
        self.splitJoints = None
        self.primitive = None
        self.boundJoints = None
        self.allJoints = None
        self.namedJoints = None
        self.rootJoints = None
        self.vertexWeights = None
        self.vertexJoints = None
        self.name = name
        self.vertexCount = vertexCount
        self.bonesPerVertex = bonesPerVertex
        if (vertexCount > 0):
            this1 = [None]*(vertexCount * bonesPerVertex)
            self.vertexJoints = this1
            this1 = [None]*(vertexCount * bonesPerVertex)
            self.vertexWeights = this1
            self.envelop = []

    def setJoints(self,joints,roots):
        self.rootJoints = roots
        self.allJoints = joints
        self.namedJoints = haxe_ds_StringMap()
        _g = 0
        while (_g < len(joints)):
            j = (joints[_g] if _g >= 0 and _g < len(joints) else None)
            _g = (_g + 1)
            if (j.name is not None):
                self.namedJoints.h[j.name] = j

    def addInfluence(self,vid,j,w):
        il = (self.envelop[vid] if vid >= 0 and vid < len(self.envelop) else None)
        if (il is None):
            def _hx_local_0():
                python_internal_ArrayImpl._set(self.envelop, vid, [])
                return (self.envelop[vid] if vid >= 0 and vid < len(self.envelop) else None)
            il = _hx_local_0()
        x = h3d_anim__Skin_Influence(j,w)
        il.append(x)

    def sortInfluences(self,i1,i2):
        if (i2.w > i1.w):
            return 1
        else:
            return -1

    def isSplit(self):
        return (self.splitJoints is not None)

    def initWeights(self):
        self.boundJoints = []
        pos = 0
        _g = 0
        _g1 = self.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            il = (self.envelop[i] if i >= 0 and i < len(self.envelop) else None)
            if (il is None):
                il = []
            haxe_ds_ArraySort.sort(il,self.sortInfluences)
            if (len(il) > self.bonesPerVertex):
                il = il[0:self.bonesPerVertex]
            tw = 0.
            _g2 = 0
            while (_g2 < len(il)):
                i1 = (il[_g2] if _g2 >= 0 and _g2 < len(il) else None)
                _g2 = (_g2 + 1)
                tw = (tw + i1.w)
            tw = (1 / tw)
            _g3 = 0
            _g4 = self.bonesPerVertex
            while (_g3 < _g4):
                i2 = _g3
                _g3 = (_g3 + 1)
                i3 = (il[i2] if i2 >= 0 and i2 < len(il) else None)
                if (i3 is None):
                    self.vertexJoints[pos] = 0
                    self.vertexWeights[pos] = 0
                else:
                    if (i3.j.bindIndex == -1):
                        i3.j.bindIndex = len(self.boundJoints)
                        _this = self.boundJoints
                        x = i3.j
                        _this.append(x)
                    val = i3.j.bindIndex
                    self.vertexJoints[pos] = val
                    val1 = (i3.w * tw)
                    self.vertexWeights[pos] = val1
                pos = (pos + 1)
        self.envelop = None

    def sortByBindIndex(self,j1,j2):
        return (j1.bindIndex - j2.bindIndex)

    def isSub(self,a,b):
        j = 0
        _hx_max = len(b)
        _g = 0
        while (_g < len(a)):
            e = (a[_g] if _g >= 0 and _g < len(a) else None)
            _g = (_g + 1)
            while True:
                b1 = j
                j = (j + 1)
                if (not ((e != (b[b1] if b1 >= 0 and b1 < len(b) else None)))):
                    break
                if (j >= _hx_max):
                    return False
        return True

    def merge(self,permuts):
        _g = 0
        while (_g < len(permuts)):
            p1 = (permuts[_g] if _g >= 0 and _g < len(permuts) else None)
            _g = (_g + 1)
            _g1 = 0
            while (_g1 < len(permuts)):
                p2 = (permuts[_g1] if _g1 >= 0 and _g1 < len(permuts) else None)
                _g1 = (_g1 + 1)
                if (((p1 != p2) and ((p1.material == p2.material))) and self.isSub(p1.joints,p2.joints)):
                    _g2 = 0
                    _g3 = p1.triangles
                    while (_g2 < len(_g3)):
                        t = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                        _g2 = (_g2 + 1)
                        _this = p2.triangles
                        _this.append(t)
                    python_internal_ArrayImpl.remove(permuts,p1)
                    return True
        return False

    def jointsDiff(self,p1,p2):
        diff = 0
        i = 0
        j = 0
        imax = len(p1.joints)
        jmax = len(p2.joints)
        while ((i < imax) and ((j < jmax))):
            j1 = (p1.joints[i] if i >= 0 and i < len(p1.joints) else None)
            j2 = (p2.joints[j] if j >= 0 and j < len(p2.joints) else None)
            if (j1 == j2):
                i = (i + 1)
                j = (j + 1)
            else:
                diff = (diff + 1)
                if (j1.bindIndex < j2.bindIndex):
                    i = (i + 1)
                else:
                    j = (j + 1)
        return ((diff + ((imax - i))) + ((jmax - j)))

    def split(self,maxBones,index,triangleMaterials):
        if (self.splitJoints is not None):
            return True
        if (len(self.boundJoints) <= maxBones):
            return False
        self.splitJoints = []
        x = (len(index) / 3)
        length = None
        try:
            length = int(x)
        except BaseException as _g:
            None
            length = None
        this1 = [None]*length
        self.triangleGroups = this1
        permuts = list()
        _g = 0
        x = (len(index) / 3)
        _g1 = None
        try:
            _g1 = int(x)
        except BaseException as _g2:
            None
            _g1 = None
        while (_g < _g1):
            tri = _g
            _g = (_g + 1)
            iid = (tri * 3)
            mid = (0 if ((triangleMaterials is None)) else (triangleMaterials[tri] if tri >= 0 and tri < len(triangleMaterials) else None))
            jl = []
            _g2 = 0
            while (_g2 < 3):
                i = _g2
                _g2 = (_g2 + 1)
                vid = python_internal_ArrayImpl._get(index, (iid + i))
                _g3 = 0
                _g4 = self.bonesPerVertex
                while (_g3 < _g4):
                    b = _g3
                    _g3 = (_g3 + 1)
                    bidx = ((vid * self.bonesPerVertex) + b)
                    if (self.vertexWeights[bidx] == 0):
                        continue
                    j = python_internal_ArrayImpl._get(self.boundJoints, self.vertexJoints[bidx])
                    if (j.splitIndex != iid):
                        j.splitIndex = iid
                        jl.append(j)
            jl.sort(key= python_lib_Functools.cmp_to_key(self.sortByBindIndex))
            _g5 = 0
            while (_g5 < len(permuts)):
                p2 = (permuts[_g5] if _g5 >= 0 and _g5 < len(permuts) else None)
                _g5 = (_g5 + 1)
                if ((p2.material == mid) and self.isSub(jl,p2.joints)):
                    _this = p2.triangles
                    _this.append(tri)
                    jl = None
                    break
            if (jl is None):
                continue
            _g6 = 0
            while (_g6 < len(permuts)):
                p21 = (permuts[_g6] if _g6 >= 0 and _g6 < len(permuts) else None)
                _g6 = (_g6 + 1)
                if ((p21.material == mid) and self.isSub(p21.joints,jl)):
                    p21.joints = jl
                    _this1 = p21.triangles
                    _this1.append(tri)
                    jl = None
                    break
            if (jl is None):
                continue
            pr = h3d_anim__Skin_Permut()
            pr.joints = jl
            pr.triangles = [tri]
            pr.material = mid
            permuts.append(pr)
        while True:
            while self.merge(permuts):
                pass
            minDif = 100000
            minTot = 100000
            minP1 = None
            minP2 = None
            _g = 0
            _g1 = len(permuts)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p1 = (permuts[i] if i >= 0 and i < len(permuts) else None)
                if (len(p1.joints) == maxBones):
                    continue
                _g2 = (i + 1)
                _g3 = len(permuts)
                while (_g2 < _g3):
                    j = _g2
                    _g2 = (_g2 + 1)
                    p2 = (permuts[j] if j >= 0 and j < len(permuts) else None)
                    if ((len(p2.joints) == maxBones) or ((p1.material != p2.material))):
                        continue
                    count = self.jointsDiff(p1,p2)
                    tot = (count + ((((len(p1.joints) + len(p2.joints)) - count) >> 1)))
                    if (((tot > maxBones) or ((tot > minTot))) or (((tot == minTot) and ((count > minDif))))):
                        continue
                    minDif = count
                    minTot = tot
                    minP1 = p1
                    minP2 = p2
            if (minP1 is None):
                break
            p11 = minP1
            p21 = minP2
            _g4 = 0
            _g5 = p11.joints
            while (_g4 < len(_g5)):
                j1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                python_internal_ArrayImpl.remove(p21.joints,j1)
                _this = p21.joints
                _this.append(j1)
            p21.joints.sort(key= python_lib_Functools.cmp_to_key(self.sortByBindIndex))
            _g6 = 0
            _g7 = p11.triangles
            while (_g6 < len(_g7)):
                t = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                _g6 = (_g6 + 1)
                _this1 = p21.triangles
                _this1.append(t)
            python_internal_ArrayImpl.remove(permuts,p11)
        _g = 0
        _g1 = len(permuts)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = (permuts[i] if i >= 0 and i < len(permuts) else None).triangles
            while (_g2 < len(_g3)):
                tri = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.triangleGroups[tri] = i
        jointsPermuts = []
        _g = 0
        _g1 = self.boundJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            pl = []
            _g2 = 0
            while (_g2 < len(permuts)):
                p = (permuts[_g2] if _g2 >= 0 and _g2 < len(permuts) else None)
                _g2 = (_g2 + 1)
                if (python_internal_ArrayImpl.indexOf(p.joints,j,None) >= 0):
                    pl.append(p)
            jointsPermuts.append(_hx_AnonObject({'j': j, 'pl': pl, 'priority': 0}))
        while True:
            def _hx_local_7(j1,j2):
                return ((len(j2.pl) + ((j2.priority * 100))) - ((len(j1.pl) + ((j1.priority * 100)))))
            jointsPermuts.sort(key= python_lib_Functools.cmp_to_key(_hx_local_7))
            _g = 0
            while (_g < len(permuts)):
                p = (permuts[_g] if _g >= 0 and _g < len(permuts) else None)
                _g = (_g + 1)
                p.indexedJoints = []
            fail = False
            _g1 = 0
            while (_g1 < len(jointsPermuts)):
                j = (jointsPermuts[_g1] if _g1 >= 0 and _g1 < len(jointsPermuts) else None)
                _g1 = (_g1 + 1)
                j.j.splitIndex = -1
                _g2 = 0
                _g3 = maxBones
                while (_g2 < _g3):
                    id = _g2
                    _g2 = (_g2 + 1)
                    ok = True
                    _g4 = 0
                    _g5 = j.pl
                    while (_g4 < len(_g5)):
                        p1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                        _g4 = (_g4 + 1)
                        if ((p1.indexedJoints[id] if id >= 0 and id < len(p1.indexedJoints) else None) is not None):
                            ok = False
                            break
                    if ok:
                        j.j.splitIndex = id
                        _g6 = 0
                        _g7 = j.pl
                        while (_g6 < len(_g7)):
                            p2 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                            _g6 = (_g6 + 1)
                            python_internal_ArrayImpl._set(p2.indexedJoints, id, j.j)
                        break
                if (j.j.splitIndex < 0):
                    j.priority = (j.priority + 1)
                    if (j.priority > 10):
                        raise haxe_Exception.thrown("Failed to assign index while spliting skin")
                    fail = True
                    break
            if (not fail):
                break
        self.splitJoints = []
        _g = 0
        while (_g < len(permuts)):
            p = (permuts[_g] if _g >= 0 and _g < len(permuts) else None)
            _g = (_g + 1)
            jl = []
            _g1 = 0
            _g2 = len(p.indexedJoints)
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                j = (p.indexedJoints[i] if i >= 0 and i < len(p.indexedJoints) else None)
                if (j is None):
                    j = (self.boundJoints[0] if 0 < len(self.boundJoints) else None)
                jl.append(j)
            _this = self.splitJoints
            x = _hx_AnonObject({'material': p.material, 'joints': jl})
            _this.append(x)
        _g = 0
        _g1 = len(self.vertexJoints)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            this1 = self.vertexJoints
            val = python_internal_ArrayImpl._get(self.boundJoints, self.vertexJoints[i]).splitIndex
            this1[i] = val
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.vertexCount = None
        _hx_o.bonesPerVertex = None
        _hx_o.vertexJoints = None
        _hx_o.vertexWeights = None
        _hx_o.rootJoints = None
        _hx_o.namedJoints = None
        _hx_o.allJoints = None
        _hx_o.boundJoints = None
        _hx_o.primitive = None
        _hx_o.splitJoints = None
        _hx_o.triangleGroups = None
        _hx_o.envelop = None
h3d_anim_Skin._hx_class = h3d_anim_Skin
_hx_classes["h3d.anim.Skin"] = h3d_anim_Skin


class h3d_col_Collider:
    _hx_class_name = "h3d.col.Collider"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["rayIntersection", "contains", "inFrustum", "inSphere"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]
h3d_col_Collider._hx_class = h3d_col_Collider
_hx_classes["h3d.col.Collider"] = h3d_col_Collider


class h3d_col_Bounds:
    _hx_class_name = "h3d.col.Bounds"
    _hx_is_interface = "False"
    __slots__ = ("xMin", "xMax", "yMin", "yMax", "zMin", "zMax")
    _hx_fields = ["xMin", "xMax", "yMin", "yMax", "zMin", "zMax"]
    _hx_methods = ["inFrustum", "inSphere", "testPlane", "rayIntersection", "inFrustumDetails", "transform3x3", "transform", "collide", "contains", "containsBounds", "containsSphere", "add", "addPoint", "addPos", "addSphere", "addSpherePos", "intersection", "offset", "setMin", "setMax", "load", "scalePivot", "scaleCenter", "getMin", "getCenter", "getSize", "getMax", "getVolume", "get_xSize", "get_ySize", "get_zSize", "set_xSize", "set_ySize", "set_zSize", "isEmpty", "empty", "all", "clone", "toString", "toSphere"]
    _hx_statics = ["fromPoints", "fromValues"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self):
        self.xMin = 1e20
        self.xMax = -1e20
        self.yMin = 1e20
        self.yMax = -1e20
        self.zMin = 1e20
        self.zMax = -1e20

    def inFrustum(self,f,m = None):
        if (m is not None):
            raise haxe_Exception.thrown("Not implemented")
        return f.hasBounds(self)

    def inSphere(self,s):
        x = s.x
        y = s.y
        z = s.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        c_x = x
        c_y = y
        c_z = z
        a = self.xMin
        a1 = s.x
        b = self.xMax
        b1 = (b if ((a1 > b)) else a1)
        x = (b1 if ((a < b1)) else a)
        a = self.yMin
        a1 = s.y
        b = self.yMax
        b1 = (b if ((a1 > b)) else a1)
        y = (b1 if ((a < b1)) else a)
        a = self.zMin
        a1 = s.z
        b = self.zMax
        b1 = (b if ((a1 > b)) else a1)
        z = (b1 if ((a < b1)) else a)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        dx = (p_x - c_x)
        dy = (p_y - c_y)
        dz = (p_z - c_z)
        return ((((dx * dx) + ((dy * dy))) + ((dz * dz))) < ((s.r * s.r)))

    def testPlane(self,p):
        a = p.nx
        b = p.ny
        c = p.nz
        dd = (((a * ((self.xMax + self.xMin))) + ((b * ((self.yMax + self.yMin))))) + ((c * ((self.zMax + self.zMin)))))
        if (a < 0):
            a = -a
        if (b < 0):
            b = -b
        if (c < 0):
            c = -c
        rr = (((a * ((self.xMax - self.xMin))) + ((b * ((self.yMax - self.yMin))))) + ((c * ((self.zMax - self.zMin)))))
        return ((dd + rr) - ((p.d * 2)))

    def rayIntersection(self,r,bestMatch):
        minTx = (((self.xMin - r.px)) / r.lx)
        minTy = (((self.yMin - r.py)) / r.ly)
        minTz = (((self.zMin - r.pz)) / r.lz)
        maxTx = (((self.xMax - r.px)) / r.lx)
        maxTy = (((self.yMax - r.py)) / r.ly)
        maxTz = (((self.zMax - r.pz)) / r.lz)
        realMinTx = (maxTx if ((minTx > maxTx)) else minTx)
        realMinTy = (maxTy if ((minTy > maxTy)) else minTy)
        realMinTz = (maxTz if ((minTz > maxTz)) else minTz)
        realMaxTx = (maxTx if ((minTx < maxTx)) else minTx)
        realMaxTy = (maxTy if ((minTy < maxTy)) else minTy)
        realMaxTz = (maxTz if ((minTz < maxTz)) else minTz)
        a = (realMaxTy if ((realMaxTx > realMaxTy)) else realMaxTx)
        minmax = (realMaxTz if ((a > realMaxTz)) else a)
        a = (realMinTy if ((realMinTx < realMinTy)) else realMinTx)
        maxmin = (realMinTz if ((a < realMinTz)) else a)
        if (minmax < maxmin):
            return -1
        return maxmin

    def inFrustumDetails(self,mvp,checkZ = None):
        if (checkZ is None):
            checkZ = True
        ret = 1
        p_nx = (mvp._14 + mvp._11)
        p_ny = (mvp._24 + mvp._21)
        p_nz = (mvp._34 + mvp._31)
        p_d = (mvp._44 + mvp._41)
        m = (((p_nx * ((self.xMax if ((p_nx > 0)) else self.xMin))) + ((p_ny * ((self.yMax if ((p_ny > 0)) else self.yMin))))) + ((p_nz * ((self.zMax if ((p_nz > 0)) else self.zMin)))))
        if ((m + p_d) < 0):
            return -1
        n = (((p_nx * ((self.xMin if ((p_nx > 0)) else self.xMax))) + ((p_ny * ((self.yMin if ((p_ny > 0)) else self.yMax))))) + ((p_nz * ((self.zMin if ((p_nz > 0)) else self.zMax)))))
        if ((n + p_d) < 0):
            ret = 0
        p_nx = (mvp._14 - mvp._11)
        p_ny = (mvp._24 - mvp._21)
        p_nz = (mvp._34 - mvp._31)
        p_d = (mvp._44 - mvp._41)
        m = (((p_nx * ((self.xMax if ((p_nx > 0)) else self.xMin))) + ((p_ny * ((self.yMax if ((p_ny > 0)) else self.yMin))))) + ((p_nz * ((self.zMax if ((p_nz > 0)) else self.zMin)))))
        if ((m + p_d) < 0):
            return -1
        n = (((p_nx * ((self.xMin if ((p_nx > 0)) else self.xMax))) + ((p_ny * ((self.yMin if ((p_ny > 0)) else self.yMax))))) + ((p_nz * ((self.zMin if ((p_nz > 0)) else self.zMax)))))
        if ((n + p_d) < 0):
            ret = 0
        p_nx = (mvp._14 + mvp._12)
        p_ny = (mvp._24 + mvp._22)
        p_nz = (mvp._34 + mvp._32)
        p_d = (mvp._44 + mvp._42)
        m = (((p_nx * ((self.xMax if ((p_nx > 0)) else self.xMin))) + ((p_ny * ((self.yMax if ((p_ny > 0)) else self.yMin))))) + ((p_nz * ((self.zMax if ((p_nz > 0)) else self.zMin)))))
        if ((m + p_d) < 0):
            return -1
        n = (((p_nx * ((self.xMin if ((p_nx > 0)) else self.xMax))) + ((p_ny * ((self.yMin if ((p_ny > 0)) else self.yMax))))) + ((p_nz * ((self.zMin if ((p_nz > 0)) else self.zMax)))))
        if ((n + p_d) < 0):
            ret = 0
        p_nx = (mvp._14 - mvp._12)
        p_ny = (mvp._24 - mvp._22)
        p_nz = (mvp._34 - mvp._32)
        p_d = (mvp._44 - mvp._42)
        m = (((p_nx * ((self.xMax if ((p_nx > 0)) else self.xMin))) + ((p_ny * ((self.yMax if ((p_ny > 0)) else self.yMin))))) + ((p_nz * ((self.zMax if ((p_nz > 0)) else self.zMin)))))
        if ((m + p_d) < 0):
            return -1
        n = (((p_nx * ((self.xMin if ((p_nx > 0)) else self.xMax))) + ((p_ny * ((self.yMin if ((p_ny > 0)) else self.yMax))))) + ((p_nz * ((self.zMin if ((p_nz > 0)) else self.zMax)))))
        if ((n + p_d) < 0):
            ret = 0
        if checkZ:
            p_nx = mvp._13
            p_ny = mvp._23
            p_nz = mvp._33
            p_d = mvp._43
            m = (((p_nx * ((self.xMax if ((p_nx > 0)) else self.xMin))) + ((p_ny * ((self.yMax if ((p_ny > 0)) else self.yMin))))) + ((p_nz * ((self.zMax if ((p_nz > 0)) else self.zMin)))))
            if ((m + p_d) < 0):
                return -1
            n = (((p_nx * ((self.xMin if ((p_nx > 0)) else self.xMax))) + ((p_ny * ((self.yMin if ((p_ny > 0)) else self.yMax))))) + ((p_nz * ((self.zMin if ((p_nz > 0)) else self.zMax)))))
            if ((n + p_d) < 0):
                ret = 0
            p_nx = (mvp._14 - mvp._13)
            p_ny = (mvp._24 - mvp._23)
            p_nz = (mvp._34 - mvp._33)
            p_d = (mvp._44 - mvp._43)
            m = (((p_nx * ((self.xMax if ((p_nx > 0)) else self.xMin))) + ((p_ny * ((self.yMax if ((p_ny > 0)) else self.yMin))))) + ((p_nz * ((self.zMax if ((p_nz > 0)) else self.zMin)))))
            if ((m + p_d) < 0):
                return -1
            n = (((p_nx * ((self.xMin if ((p_nx > 0)) else self.xMax))) + ((p_ny * ((self.yMin if ((p_ny > 0)) else self.yMax))))) + ((p_nz * ((self.zMin if ((p_nz > 0)) else self.zMax)))))
            if ((n + p_d) < 0):
                ret = 0
        return ret

    def transform3x3(self,m):
        xMin = self.xMin
        yMin = self.yMin
        zMin = self.zMin
        xMax = self.xMax
        yMax = self.yMax
        zMax = self.zMax
        self.xMin = 1e20
        self.xMax = -1e20
        self.yMin = 1e20
        self.yMax = -1e20
        self.zMin = 1e20
        self.zMax = -1e20
        v_x = 0.
        v_y = 0.
        v_z = 0.
        x = xMin
        y = yMin
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMin
        y = yMin
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMin
        y = yMax
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMin
        y = yMax
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMin
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMin
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMax
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMax
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z

    def transform(self,m):
        xMin = self.xMin
        yMin = self.yMin
        zMin = self.zMin
        xMax = self.xMax
        yMax = self.yMax
        zMax = self.zMax
        self.xMin = 1e20
        self.xMax = -1e20
        self.yMin = 1e20
        self.yMax = -1e20
        self.zMin = 1e20
        self.zMax = -1e20
        if (((xMax < xMin) and ((yMax < yMin))) and ((zMax < zMin))):
            return
        v_x = 0.
        v_y = 0.
        v_z = 0.
        x = xMin
        y = yMin
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMin
        y = yMin
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMin
        y = yMax
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMin
        y = yMax
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMin
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMin
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMax
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMax
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z

    def collide(self,b):
        return (not (((((((self.xMin > b.xMax) or ((self.yMin > b.yMax))) or ((self.zMin > b.zMax))) or ((self.xMax < b.xMin))) or ((self.yMax < b.yMin))) or ((self.zMax < b.zMin)))))

    def contains(self,p):
        if (((((p.x >= self.xMin) and ((p.x < self.xMax))) and ((p.y >= self.yMin))) and ((p.y < self.yMax))) and ((p.z >= self.zMin))):
            return (p.z < self.zMax)
        else:
            return False

    def containsBounds(self,b):
        if (((((self.xMin <= b.xMin) and ((self.yMin <= b.yMin))) and ((self.zMin <= b.zMin))) and ((self.xMax >= b.xMax))) and ((self.yMax >= b.yMax))):
            return (self.zMax >= b.zMax)
        else:
            return False

    def containsSphere(self,s):
        if (((((self.xMin <= ((s.x - s.r))) and ((self.yMin <= ((s.y - s.r))))) and ((self.zMin <= ((s.z - s.r))))) and ((self.xMax >= ((s.x + s.r))))) and ((self.yMax >= ((s.y + s.r))))):
            return (self.zMax >= ((s.z + s.r)))
        else:
            return False

    def add(self,b):
        if (b.xMin < self.xMin):
            self.xMin = b.xMin
        if (b.xMax > self.xMax):
            self.xMax = b.xMax
        if (b.yMin < self.yMin):
            self.yMin = b.yMin
        if (b.yMax > self.yMax):
            self.yMax = b.yMax
        if (b.zMin < self.zMin):
            self.zMin = b.zMin
        if (b.zMax > self.zMax):
            self.zMax = b.zMax

    def addPoint(self,p):
        if (p.x < self.xMin):
            self.xMin = p.x
        if (p.x > self.xMax):
            self.xMax = p.x
        if (p.y < self.yMin):
            self.yMin = p.y
        if (p.y > self.yMax):
            self.yMax = p.y
        if (p.z < self.zMin):
            self.zMin = p.z
        if (p.z > self.zMax):
            self.zMax = p.z

    def addPos(self,x,y,z):
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y
        if (z < self.zMin):
            self.zMin = z
        if (z > self.zMax):
            self.zMax = z

    def addSphere(self,s):
        x = s.x
        y = s.y
        z = s.z
        r = s.r
        if ((x - r) < self.xMin):
            self.xMin = (x - r)
        if ((x + r) > self.xMax):
            self.xMax = (x + r)
        if ((y - r) < self.yMin):
            self.yMin = (y - r)
        if ((y + r) > self.yMax):
            self.yMax = (y + r)
        if ((z - r) < self.zMin):
            self.zMin = (z - r)
        if ((z + r) > self.zMax):
            self.zMax = (z + r)

    def addSpherePos(self,x,y,z,r):
        if ((x - r) < self.xMin):
            self.xMin = (x - r)
        if ((x + r) > self.xMax):
            self.xMax = (x + r)
        if ((y - r) < self.yMin):
            self.yMin = (y - r)
        if ((y + r) > self.yMax):
            self.yMax = (y + r)
        if ((z - r) < self.zMin):
            self.zMin = (z - r)
        if ((z + r) > self.zMax):
            self.zMax = (z + r)

    def intersection(self,a,b):
        a1 = a.xMin
        b1 = b.xMin
        xMin = (b1 if ((a1 < b1)) else a1)
        a1 = a.yMin
        b1 = b.yMin
        yMin = (b1 if ((a1 < b1)) else a1)
        a1 = a.zMin
        b1 = b.zMin
        zMin = (b1 if ((a1 < b1)) else a1)
        a1 = a.xMax
        b1 = b.xMax
        xMax = (b1 if ((a1 > b1)) else a1)
        a1 = a.yMax
        b1 = b.yMax
        yMax = (b1 if ((a1 > b1)) else a1)
        a1 = a.zMax
        b1 = b.zMax
        zMax = (b1 if ((a1 > b1)) else a1)
        self.xMin = xMin
        self.xMax = xMax
        self.yMin = yMin
        self.yMax = yMax
        self.zMin = zMin
        self.zMax = zMax

    def offset(self,dx,dy,dz):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 + dx)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.xMax
        _hx_local_2.xMax = (_hx_local_3 + dx)
        _hx_local_2.xMax
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.yMin
        _hx_local_4.yMin = (_hx_local_5 + dy)
        _hx_local_4.yMin
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.yMax
        _hx_local_6.yMax = (_hx_local_7 + dy)
        _hx_local_6.yMax
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.zMin
        _hx_local_8.zMin = (_hx_local_9 + dz)
        _hx_local_8.zMin
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.zMax
        _hx_local_10.zMax = (_hx_local_11 + dz)
        _hx_local_10.zMax

    def setMin(self,p):
        self.xMin = p.x
        self.yMin = p.y
        self.zMin = p.z

    def setMax(self,p):
        self.xMax = p.x
        self.yMax = p.y
        self.zMax = p.z

    def load(self,b):
        self.xMin = b.xMin
        self.xMax = b.xMax
        self.yMin = b.yMin
        self.yMax = b.yMax
        self.zMin = b.zMin
        self.zMax = b.zMax

    def scalePivot(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 * v)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.yMin
        _hx_local_2.yMin = (_hx_local_3 * v)
        _hx_local_2.yMin
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.zMin
        _hx_local_4.zMin = (_hx_local_5 * v)
        _hx_local_4.zMin
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.xMax
        _hx_local_6.xMax = (_hx_local_7 * v)
        _hx_local_6.xMax
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.yMax
        _hx_local_8.yMax = (_hx_local_9 * v)
        _hx_local_8.yMax
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.zMax
        _hx_local_10.zMax = (_hx_local_11 * v)
        _hx_local_10.zMax

    def scaleCenter(self,v):
        dx = ((((self.xMax - self.xMin)) * 0.5) * v)
        dy = ((((self.yMax - self.yMin)) * 0.5) * v)
        dz = ((((self.zMax - self.zMin)) * 0.5) * v)
        mx = (((self.xMax + self.xMin)) * 0.5)
        my = (((self.yMax + self.yMin)) * 0.5)
        mz = (((self.zMax + self.zMin)) * 0.5)
        self.xMin = (mx - dx)
        self.yMin = (my - dy)
        self.zMin = (mz - dz)
        self.xMax = (mx + dx)
        self.yMax = (my + dy)
        self.zMax = (mz + dz)

    def getMin(self):
        return h3d_col_Point(self.xMin,self.yMin,self.zMin)

    def getCenter(self):
        return h3d_col_Point((((self.xMin + self.xMax)) * 0.5),(((self.yMin + self.yMax)) * 0.5),(((self.zMin + self.zMax)) * 0.5))

    def getSize(self):
        return h3d_col_Point((self.xMax - self.xMin),(self.yMax - self.yMin),(self.zMax - self.zMin))

    def getMax(self):
        return h3d_col_Point(self.xMax,self.yMax,self.zMax)

    def getVolume(self):
        return ((((self.xMax - self.xMin)) * ((self.yMax - self.yMin))) * ((self.zMax - self.zMin)))

    def get_xSize(self):
        return (self.xMax - self.xMin)

    def get_ySize(self):
        return (self.yMax - self.yMin)

    def get_zSize(self):
        return (self.zMax - self.zMin)

    def set_xSize(self,v):
        self.xMax = (self.xMin + v)
        return v

    def set_ySize(self,v):
        self.yMax = (self.yMin + v)
        return v

    def set_zSize(self,v):
        self.zMax = (self.zMin + v)
        return v

    def isEmpty(self):
        if (not (((self.xMax < self.xMin) or ((self.yMax < self.yMin))))):
            return (self.zMax < self.zMin)
        else:
            return True

    def empty(self):
        self.xMin = 1e20
        self.xMax = -1e20
        self.yMin = 1e20
        self.yMax = -1e20
        self.zMin = 1e20
        self.zMax = -1e20

    def all(self):
        self.xMin = -1e20
        self.xMax = 1e20
        self.yMin = -1e20
        self.yMax = 1e20
        self.zMin = -1e20
        self.zMax = 1e20

    def clone(self):
        b = h3d_col_Bounds()
        b.xMin = self.xMin
        b.xMax = self.xMax
        b.yMin = self.yMin
        b.yMax = self.yMax
        b.zMin = self.zMin
        b.zMax = self.zMax
        return b

    def toString(self):
        return (((("Bounds{" + Std.string(h3d_col_Point(self.xMin,self.yMin,self.zMin))) + ",") + Std.string(h3d_col_Point((self.xMax - self.xMin),(self.yMax - self.yMin),(self.zMax - self.zMin)))) + "}")

    def toSphere(self):
        dx = (self.xMax - self.xMin)
        dy = (self.yMax - self.yMin)
        dz = (self.zMax - self.zMin)
        f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
        return h3d_col_Sphere((((self.xMin + self.xMax)) * 0.5),(((self.yMin + self.yMax)) * 0.5),(((self.zMin + self.zMax)) * 0.5),(((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 0.5))

    @staticmethod
    def fromPoints(_hx_min,_hx_max):
        b = h3d_col_Bounds()
        b.xMin = _hx_min.x
        b.yMin = _hx_min.y
        b.zMin = _hx_min.z
        b.xMax = _hx_max.x
        b.yMax = _hx_max.y
        b.zMax = _hx_max.z
        return b

    @staticmethod
    def fromValues(x,y,z,dx,dy,dz):
        b = h3d_col_Bounds()
        b.xMin = x
        b.yMin = y
        b.zMin = z
        b.xMax = (x + dx)
        b.yMax = (y + dy)
        b.zMax = (z + dz)
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.xMin = None
        _hx_o.xMax = None
        _hx_o.yMin = None
        _hx_o.yMax = None
        _hx_o.zMin = None
        _hx_o.zMax = None
h3d_col_Bounds._hx_class = h3d_col_Bounds
_hx_classes["h3d.col.Bounds"] = h3d_col_Bounds


class h3d_col_OptimizedCollider:
    _hx_class_name = "h3d.col.OptimizedCollider"
    _hx_is_interface = "False"
    __slots__ = ("a", "b")
    _hx_fields = ["a", "b"]
    _hx_methods = ["rayIntersection", "contains", "inFrustum", "inSphere"]
    _hx_interfaces = [h3d_col_Collider, hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,a,b):
        self.a = a
        self.b = b

    def rayIntersection(self,r,bestMatch):
        if (self.a.rayIntersection(r,bestMatch) < 0):
            return -1
        return self.b.rayIntersection(r,bestMatch)

    def contains(self,p):
        if self.a.contains(p):
            return self.b.contains(p)
        else:
            return False

    def inFrustum(self,f,m = None):
        if self.a.inFrustum(f,m):
            return self.b.inFrustum(f,m)
        else:
            return False

    def inSphere(self,s):
        if self.a.inSphere(s):
            return self.b.inSphere(s)
        else:
            return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a = None
        _hx_o.b = None
h3d_col_OptimizedCollider._hx_class = h3d_col_OptimizedCollider
_hx_classes["h3d.col.OptimizedCollider"] = h3d_col_OptimizedCollider


class h3d_col_GroupCollider:
    _hx_class_name = "h3d.col.GroupCollider"
    _hx_is_interface = "False"
    __slots__ = ("colliders",)
    _hx_fields = ["colliders"]
    _hx_methods = ["rayIntersection", "contains", "inFrustum", "inSphere"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self,colliders):
        self.colliders = colliders

    def rayIntersection(self,r,bestMatch):
        best = -1.
        _g = 0
        _g1 = self.colliders
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            d = c.rayIntersection(r,bestMatch)
            if (d >= 0):
                if (not bestMatch):
                    return d
                if ((best < 0) or ((d < best))):
                    best = d
        return best

    def contains(self,p):
        _g = 0
        _g1 = self.colliders
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if c.contains(p):
                return True
        return False

    def inFrustum(self,f,m = None):
        _g = 0
        _g1 = self.colliders
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if c.inFrustum(f,m):
                return True
        return False

    def inSphere(self,s):
        _g = 0
        _g1 = self.colliders
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if c.inSphere(s):
                return True
        return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.colliders = None
h3d_col_GroupCollider._hx_class = h3d_col_GroupCollider
_hx_classes["h3d.col.GroupCollider"] = h3d_col_GroupCollider


class h3d_col_FPoint:
    _hx_class_name = "h3d.col.FPoint"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z")
    _hx_fields = ["x", "y", "z"]
    _hx_methods = ["sub", "add", "cross", "dot", "toString"]

    def __init__(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        self.x = x
        self.y = y
        self.z = z

    def sub(self,p):
        return h3d_col_FPoint((self.x - p.x),(self.y - p.y),(self.z - p.z))

    def add(self,p):
        return h3d_col_FPoint((self.x + p.x),(self.y + p.y),(self.z + p.z))

    def cross(self,p):
        return h3d_col_FPoint(((self.y * p.z) - ((self.z * p.y))),((self.z * p.x) - ((self.x * p.z))),((self.x * p.y) - ((self.y * p.x))))

    def dot(self,p):
        return (((self.x * p.x) + ((self.y * p.y))) + ((self.z * p.z)))

    def toString(self):
        return (((((("FPoint{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.z))) + "}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
h3d_col_FPoint._hx_class = h3d_col_FPoint
_hx_classes["h3d.col.FPoint"] = h3d_col_FPoint


class h3d_col_Frustum:
    _hx_class_name = "h3d.col.Frustum"
    _hx_is_interface = "False"
    __slots__ = ("pleft", "pright", "ptop", "pbottom", "pnear", "pfar", "checkNearFar")
    _hx_fields = ["pleft", "pright", "ptop", "pbottom", "pnear", "pfar", "checkNearFar"]
    _hx_methods = ["clone", "loadMatrix", "transform", "transform3x3", "hasPoint", "hasSphere", "hasBounds"]

    def __init__(self,mvp = None):
        self.checkNearFar = True
        self.pleft = h3d_col_Plane(1,0,0,0.0)
        self.pright = h3d_col_Plane(1,0,0,0.0)
        self.ptop = h3d_col_Plane(1,0,0,0.0)
        self.pbottom = h3d_col_Plane(1,0,0,0.0)
        self.pnear = h3d_col_Plane(1,0,0,0.0)
        self.pfar = h3d_col_Plane(1,0,0,0.0)
        if (mvp is not None):
            self.loadMatrix(mvp)

    def clone(self):
        f = h3d_col_Frustum()
        _this = f.pleft
        p = self.pleft
        _this.nx = p.nx
        _this.ny = p.ny
        _this.nz = p.nz
        _this.d = p.d
        _this = f.pright
        p = self.pright
        _this.nx = p.nx
        _this.ny = p.ny
        _this.nz = p.nz
        _this.d = p.d
        _this = f.ptop
        p = self.ptop
        _this.nx = p.nx
        _this.ny = p.ny
        _this.nz = p.nz
        _this.d = p.d
        _this = f.pbottom
        p = self.pbottom
        _this.nx = p.nx
        _this.ny = p.ny
        _this.nz = p.nz
        _this.d = p.d
        _this = f.pnear
        p = self.pnear
        _this.nx = p.nx
        _this.ny = p.ny
        _this.nz = p.nz
        _this.d = p.d
        _this = f.pfar
        p = self.pfar
        _this.nx = p.nx
        _this.ny = p.ny
        _this.nz = p.nz
        _this.d = p.d
        f.checkNearFar = self.checkNearFar
        return f

    def loadMatrix(self,mvp):
        _this = self.pleft
        p_nx = (mvp._14 + mvp._11)
        p_ny = (mvp._24 + mvp._21)
        p_nz = (mvp._34 + mvp._31)
        p_d = -((mvp._44 + mvp._41))
        _this.nx = p_nx
        _this.ny = p_ny
        _this.nz = p_nz
        _this.d = p_d
        _this = self.pright
        p_nx = (mvp._14 - mvp._11)
        p_ny = (mvp._24 - mvp._21)
        p_nz = (mvp._34 - mvp._31)
        p_d = (mvp._41 - mvp._44)
        _this.nx = p_nx
        _this.ny = p_ny
        _this.nz = p_nz
        _this.d = p_d
        _this = self.ptop
        p_nx = (mvp._14 - mvp._12)
        p_ny = (mvp._24 - mvp._22)
        p_nz = (mvp._34 - mvp._32)
        p_d = (mvp._42 - mvp._44)
        _this.nx = p_nx
        _this.ny = p_ny
        _this.nz = p_nz
        _this.d = p_d
        _this = self.pbottom
        p_nx = (mvp._14 + mvp._12)
        p_ny = (mvp._24 + mvp._22)
        p_nz = (mvp._34 + mvp._32)
        p_d = -((mvp._44 + mvp._42))
        _this.nx = p_nx
        _this.ny = p_ny
        _this.nz = p_nz
        _this.d = p_d
        _this = self.pnear
        p_nx = mvp._13
        p_ny = mvp._23
        p_nz = mvp._33
        p_d = -mvp._43
        _this.nx = p_nx
        _this.ny = p_ny
        _this.nz = p_nz
        _this.d = p_d
        _this = self.pfar
        p_nx = (mvp._14 - mvp._13)
        p_ny = (mvp._24 - mvp._23)
        p_nz = (mvp._34 - mvp._33)
        p_d = (mvp._43 - mvp._44)
        _this.nx = p_nx
        _this.ny = p_ny
        _this.nz = p_nz
        _this.d = p_d
        _this = self.pleft
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pright
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.ptop
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pbottom
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pnear
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pfar
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)

    def transform(self,m):
        m2 = h3d_Matrix()
        m2.initInverse(m)
        m2.transpose()
        _this = self.pleft
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pright
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.ptop
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pbottom
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pfar
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pnear
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pleft
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pright
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.ptop
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pbottom
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pnear
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pfar
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)

    def transform3x3(self,m):
        m2 = h3d_Matrix()
        m2.initInverse3x3(m)
        m2.transpose()
        _this = self.pleft
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pright
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.ptop
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pbottom
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pfar
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pnear
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pleft
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pright
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.ptop
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pbottom
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pnear
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pfar
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)

    def hasPoint(self,p):
        _this = self.pleft
        if (((((_this.nx * p.x) + ((_this.ny * p.y))) + ((_this.nz * p.z))) - _this.d) < 0):
            return False
        _this = self.pright
        if (((((_this.nx * p.x) + ((_this.ny * p.y))) + ((_this.nz * p.z))) - _this.d) < 0):
            return False
        _this = self.ptop
        if (((((_this.nx * p.x) + ((_this.ny * p.y))) + ((_this.nz * p.z))) - _this.d) < 0):
            return False
        _this = self.pbottom
        if (((((_this.nx * p.x) + ((_this.ny * p.y))) + ((_this.nz * p.z))) - _this.d) < 0):
            return False
        if self.checkNearFar:
            _this = self.pnear
            if (((((_this.nx * p.x) + ((_this.ny * p.y))) + ((_this.nz * p.z))) - _this.d) < 0):
                return False
            _this = self.pfar
            if (((((_this.nx * p.x) + ((_this.ny * p.y))) + ((_this.nz * p.z))) - _this.d) < 0):
                return False
        return True

    def hasSphere(self,s):
        x = s.x
        y = s.y
        z = s.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        _this = self.pleft
        if (((((_this.nx * p_x) + ((_this.ny * p_y))) + ((_this.nz * p_z))) - _this.d) < -s.r):
            return False
        _this = self.pright
        if (((((_this.nx * p_x) + ((_this.ny * p_y))) + ((_this.nz * p_z))) - _this.d) < -s.r):
            return False
        _this = self.ptop
        if (((((_this.nx * p_x) + ((_this.ny * p_y))) + ((_this.nz * p_z))) - _this.d) < -s.r):
            return False
        _this = self.pbottom
        if (((((_this.nx * p_x) + ((_this.ny * p_y))) + ((_this.nz * p_z))) - _this.d) < -s.r):
            return False
        if self.checkNearFar:
            _this = self.pnear
            if (((((_this.nx * p_x) + ((_this.ny * p_y))) + ((_this.nz * p_z))) - _this.d) < -s.r):
                return False
            _this = self.pfar
            if (((((_this.nx * p_x) + ((_this.ny * p_y))) + ((_this.nz * p_z))) - _this.d) < -s.r):
                return False
        return True

    def hasBounds(self,b):
        p = self.pleft
        a = p.nx
        b1 = p.ny
        c = p.nz
        dd = (((a * ((b.xMax + b.xMin))) + ((b1 * ((b.yMax + b.yMin))))) + ((c * ((b.zMax + b.zMin)))))
        if (a < 0):
            a = -a
        if (b1 < 0):
            b1 = -b1
        if (c < 0):
            c = -c
        rr = (((a * ((b.xMax - b.xMin))) + ((b1 * ((b.yMax - b.yMin))))) + ((c * ((b.zMax - b.zMin)))))
        if (((dd + rr) - ((p.d * 2))) < 0):
            return False
        p = self.pright
        a = p.nx
        b1 = p.ny
        c = p.nz
        dd = (((a * ((b.xMax + b.xMin))) + ((b1 * ((b.yMax + b.yMin))))) + ((c * ((b.zMax + b.zMin)))))
        if (a < 0):
            a = -a
        if (b1 < 0):
            b1 = -b1
        if (c < 0):
            c = -c
        rr = (((a * ((b.xMax - b.xMin))) + ((b1 * ((b.yMax - b.yMin))))) + ((c * ((b.zMax - b.zMin)))))
        if (((dd + rr) - ((p.d * 2))) < 0):
            return False
        p = self.ptop
        a = p.nx
        b1 = p.ny
        c = p.nz
        dd = (((a * ((b.xMax + b.xMin))) + ((b1 * ((b.yMax + b.yMin))))) + ((c * ((b.zMax + b.zMin)))))
        if (a < 0):
            a = -a
        if (b1 < 0):
            b1 = -b1
        if (c < 0):
            c = -c
        rr = (((a * ((b.xMax - b.xMin))) + ((b1 * ((b.yMax - b.yMin))))) + ((c * ((b.zMax - b.zMin)))))
        if (((dd + rr) - ((p.d * 2))) < 0):
            return False
        p = self.ptop
        a = p.nx
        b1 = p.ny
        c = p.nz
        dd = (((a * ((b.xMax + b.xMin))) + ((b1 * ((b.yMax + b.yMin))))) + ((c * ((b.zMax + b.zMin)))))
        if (a < 0):
            a = -a
        if (b1 < 0):
            b1 = -b1
        if (c < 0):
            c = -c
        rr = (((a * ((b.xMax - b.xMin))) + ((b1 * ((b.yMax - b.yMin))))) + ((c * ((b.zMax - b.zMin)))))
        if (((dd + rr) - ((p.d * 2))) < 0):
            return False
        p = self.pnear
        a = p.nx
        b1 = p.ny
        c = p.nz
        dd = (((a * ((b.xMax + b.xMin))) + ((b1 * ((b.yMax + b.yMin))))) + ((c * ((b.zMax + b.zMin)))))
        if (a < 0):
            a = -a
        if (b1 < 0):
            b1 = -b1
        if (c < 0):
            c = -c
        rr = (((a * ((b.xMax - b.xMin))) + ((b1 * ((b.yMax - b.yMin))))) + ((c * ((b.zMax - b.zMin)))))
        if (((dd + rr) - ((p.d * 2))) < 0):
            return False
        p = self.pfar
        a = p.nx
        b1 = p.ny
        c = p.nz
        dd = (((a * ((b.xMax + b.xMin))) + ((b1 * ((b.yMax + b.yMin))))) + ((c * ((b.zMax + b.zMin)))))
        if (a < 0):
            a = -a
        if (b1 < 0):
            b1 = -b1
        if (c < 0):
            c = -c
        rr = (((a * ((b.xMax - b.xMin))) + ((b1 * ((b.yMax - b.yMin))))) + ((c * ((b.zMax - b.zMin)))))
        if (((dd + rr) - ((p.d * 2))) < 0):
            return False
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pleft = None
        _hx_o.pright = None
        _hx_o.ptop = None
        _hx_o.pbottom = None
        _hx_o.pnear = None
        _hx_o.pfar = None
        _hx_o.checkNearFar = None
h3d_col_Frustum._hx_class = h3d_col_Frustum
_hx_classes["h3d.col.Frustum"] = h3d_col_Frustum


class h3d_col_Ray:
    _hx_class_name = "h3d.col.Ray"
    _hx_is_interface = "False"
    __slots__ = ("px", "py", "pz", "lx", "ly", "lz")
    _hx_fields = ["px", "py", "pz", "lx", "ly", "lz"]
    _hx_methods = ["clone", "load", "normalize", "transform", "getPos", "getDir", "getPoint", "toString", "intersect", "collideFrustum", "collide"]
    _hx_statics = ["fromPoints", "fromValues"]

    def __init__(self):
        self.lz = None
        self.ly = None
        self.lx = None
        self.pz = None
        self.py = None
        self.px = None

    def clone(self):
        r = h3d_col_Ray()
        r.px = self.px
        r.py = self.py
        r.pz = self.pz
        r.lx = self.lx
        r.ly = self.ly
        r.lz = self.lz
        return r

    def load(self,r):
        self.px = r.px
        self.py = r.py
        self.pz = r.pz
        self.lx = r.lx
        self.ly = r.ly
        self.lz = r.lz

    def normalize(self):
        l = (((self.lx * self.lx) + ((self.ly * self.ly))) + ((self.lz * self.lz)))
        if (l == 1.):
            return
        if (l < 1e-10):
            l = 0
        else:
            l = (1. / ((Math.NaN if ((l < 0)) else python_lib_Math.sqrt(l))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.lx
        _hx_local_0.lx = (_hx_local_1 * l)
        _hx_local_0.lx
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.ly
        _hx_local_2.ly = (_hx_local_3 * l)
        _hx_local_2.ly
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.lz
        _hx_local_4.lz = (_hx_local_5 * l)
        _hx_local_4.lz

    def transform(self,m):
        x = self.px
        y = self.py
        z = self.pz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        p_w = 1.
        px = ((((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31))) + ((p_w * m._41)))
        py = ((((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32))) + ((p_w * m._42)))
        pz = ((((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33))) + ((p_w * m._43)))
        p_x = px
        p_y = py
        p_z = pz
        self.px = p_x
        self.py = p_y
        self.pz = p_z
        x = self.lx
        y = self.ly
        z = self.lz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        l_x = x
        l_y = y
        l_z = z
        l_w = 1.
        px = (((l_x * m._11) + ((l_y * m._21))) + ((l_z * m._31)))
        py = (((l_x * m._12) + ((l_y * m._22))) + ((l_z * m._32)))
        pz = (((l_x * m._13) + ((l_y * m._23))) + ((l_z * m._33)))
        l_x = px
        l_y = py
        l_z = pz
        self.lx = l_x
        self.ly = l_y
        self.lz = l_z
        self.normalize()

    def getPos(self):
        return h3d_col_Point(self.px,self.py,self.pz)

    def getDir(self):
        return h3d_col_Point(self.lx,self.ly,self.lz)

    def getPoint(self,distance):
        return h3d_col_Point((self.px + ((distance * self.lx))),(self.py + ((distance * self.ly))),(self.pz + ((distance * self.lz))))

    def toString(self):
        return (((("Ray{" + Std.string(h3d_col_Point(self.px,self.py,self.pz))) + ",") + Std.string(h3d_col_Point(self.lx,self.ly,self.lz))) + "}")

    def intersect(self,p):
        d = (((self.lx * p.nx) + ((self.ly * p.ny))) + ((self.lz * p.nz)))
        nd = (p.d - ((((self.px * p.nx) + ((self.py * p.ny))) + ((self.pz * p.nz)))))
        if (((-d if ((d < 0)) else d)) < 1e-10):
            if (((-nd if ((nd < 0)) else nd)) < 1e-10):
                return h3d_col_Point(self.px,self.py,self.pz)
            else:
                return None
        else:
            k = (nd / d)
            return h3d_col_Point((self.px + ((self.lx * k))),(self.py + ((self.ly * k))),(self.pz + ((self.lz * k))))

    def collideFrustum(self,mvp):
        x = self.px
        y = self.py
        z = self.pz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        a_x = x
        a_y = y
        a_z = z
        a_w = 1.
        px = ((((a_x * mvp._11) + ((a_y * mvp._21))) + ((a_z * mvp._31))) + ((a_w * mvp._41)))
        py = ((((a_x * mvp._12) + ((a_y * mvp._22))) + ((a_z * mvp._32))) + ((a_w * mvp._42)))
        pz = ((((a_x * mvp._13) + ((a_y * mvp._23))) + ((a_z * mvp._33))) + ((a_w * mvp._43)))
        iw = (1 / (((((a_x * mvp._14) + ((a_y * mvp._24))) + ((a_z * mvp._34))) + ((a_w * mvp._44)))))
        a_x = (px * iw)
        a_y = (py * iw)
        a_z = (pz * iw)
        a_w = 1
        x = (self.px + self.lx)
        y = (self.py + self.ly)
        z = (self.pz + self.lz)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        b_x = x
        b_y = y
        b_z = z
        b_w = 1.
        px = ((((b_x * mvp._11) + ((b_y * mvp._21))) + ((b_z * mvp._31))) + ((b_w * mvp._41)))
        py = ((((b_x * mvp._12) + ((b_y * mvp._22))) + ((b_z * mvp._32))) + ((b_w * mvp._42)))
        pz = ((((b_x * mvp._13) + ((b_y * mvp._23))) + ((b_z * mvp._33))) + ((b_w * mvp._43)))
        iw = (1 / (((((b_x * mvp._14) + ((b_y * mvp._24))) + ((b_z * mvp._34))) + ((b_w * mvp._44)))))
        b_x = (px * iw)
        b_y = (py * iw)
        b_z = (pz * iw)
        b_w = 1
        lx = (b_x - a_x)
        ly = (b_y - a_y)
        lz = (b_z - a_z)
        dx = (1 / lx)
        dy = (1 / ly)
        dz = (1 / lz)
        t1 = (((-1 - a_x)) * dx)
        t2 = (((1 - a_x)) * dx)
        t3 = (((-1 - a_y)) * dy)
        t4 = (((1 - a_y)) * dy)
        t5 = (((0 - a_z)) * dz)
        t6 = (((1 - a_z)) * dz)
        a = (t2 if ((t1 > t2)) else t1)
        b = (t4 if ((t3 > t4)) else t3)
        a1 = (b if ((a < b)) else a)
        b = (t6 if ((t5 > t6)) else t5)
        tmin = (b if ((a1 < b)) else a1)
        a = (t2 if ((t1 < t2)) else t1)
        b = (t4 if ((t3 < t4)) else t3)
        a1 = (b if ((a > b)) else a)
        b = (t6 if ((t5 < t6)) else t5)
        tmax = (b if ((a1 > b)) else a1)
        return (not (((tmax < 0) or ((tmin > tmax)))))

    def collide(self,b):
        dx = (1 / self.lx)
        dy = (1 / self.ly)
        dz = (1 / self.lz)
        t1 = (((b.xMin - self.px)) * dx)
        t2 = (((b.xMax - self.px)) * dx)
        t3 = (((b.yMin - self.py)) * dy)
        t4 = (((b.yMax - self.py)) * dy)
        t5 = (((b.zMin - self.pz)) * dz)
        t6 = (((b.zMax - self.pz)) * dz)
        a = (t2 if ((t1 > t2)) else t1)
        b = (t4 if ((t3 > t4)) else t3)
        a1 = (b if ((a < b)) else a)
        b = (t6 if ((t5 > t6)) else t5)
        tmin = (b if ((a1 < b)) else a1)
        a = (t2 if ((t1 < t2)) else t1)
        b = (t4 if ((t3 < t4)) else t3)
        a1 = (b if ((a > b)) else a)
        b = (t6 if ((t5 < t6)) else t5)
        tmax = (b if ((a1 > b)) else a1)
        if (tmax < 0):
            return False
        elif (tmin > tmax):
            return False
        else:
            return True

    @staticmethod
    def fromPoints(p1,p2):
        r = h3d_col_Ray()
        r.px = p1.x
        r.py = p1.y
        r.pz = p1.z
        r.lx = (p2.x - p1.x)
        r.ly = (p2.y - p1.y)
        r.lz = (p2.z - p1.z)
        r.normalize()
        return r

    @staticmethod
    def fromValues(x,y,z,dx,dy,dz):
        r = h3d_col_Ray()
        r.px = x
        r.py = y
        r.pz = z
        r.lx = dx
        r.ly = dy
        r.lz = dz
        r.normalize()
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.px = None
        _hx_o.py = None
        _hx_o.pz = None
        _hx_o.lx = None
        _hx_o.ly = None
        _hx_o.lz = None
h3d_col_Ray._hx_class = h3d_col_Ray
_hx_classes["h3d.col.Ray"] = h3d_col_Ray


class h3d_col_ObjectCollider:
    _hx_class_name = "h3d.col.ObjectCollider"
    _hx_is_interface = "False"
    __slots__ = ("obj", "collider")
    _hx_fields = ["obj", "collider"]
    _hx_methods = ["rayIntersection", "contains", "inFrustum", "inSphere"]
    _hx_statics = ["TMP_RAY", "TMP_MAT"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport, h3d_col_Collider]

    def __init__(self,obj,collider):
        self.obj = obj
        self.collider = collider

    def rayIntersection(self,r,bestMatch):
        tmpRay = h3d_col_ObjectCollider.TMP_RAY
        h3d_col_ObjectCollider.TMP_RAY = None
        tmpRay.px = r.px
        tmpRay.py = r.py
        tmpRay.pz = r.pz
        tmpRay.lx = r.lx
        tmpRay.ly = r.ly
        tmpRay.lz = r.lz
        m = self.obj.getInvPos()
        x = r.px
        y = r.py
        z = r.pz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        p_w = 1.
        px = ((((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31))) + ((p_w * m._41)))
        py = ((((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32))) + ((p_w * m._42)))
        pz = ((((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33))) + ((p_w * m._43)))
        p_x = px
        p_y = py
        p_z = pz
        r.px = p_x
        r.py = p_y
        r.pz = p_z
        x = r.lx
        y = r.ly
        z = r.lz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        l_x = x
        l_y = y
        l_z = z
        l_w = 1.
        px = (((l_x * m._11) + ((l_y * m._21))) + ((l_z * m._31)))
        py = (((l_x * m._12) + ((l_y * m._22))) + ((l_z * m._32)))
        pz = (((l_x * m._13) + ((l_y * m._23))) + ((l_z * m._33)))
        l_x = px
        l_y = py
        l_z = pz
        r.lx = l_x
        r.ly = l_y
        r.lz = l_z
        r.normalize()
        hit = self.collider.rayIntersection(r,bestMatch)
        if (hit < 0):
            r.px = tmpRay.px
            r.py = tmpRay.py
            r.pz = tmpRay.pz
            r.lx = tmpRay.lx
            r.ly = tmpRay.ly
            r.lz = tmpRay.lz
            h3d_col_ObjectCollider.TMP_RAY = tmpRay
            return hit
        x = (r.px + ((hit * r.lx)))
        y = (r.py + ((hit * r.ly)))
        z = (r.pz + ((hit * r.lz)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        pt_x = x
        pt_y = y
        pt_z = z
        m = self.obj.absPos
        px = ((((pt_x * m._11) + ((pt_y * m._21))) + ((pt_z * m._31))) + m._41)
        py = ((((pt_x * m._12) + ((pt_y * m._22))) + ((pt_z * m._32))) + m._42)
        pz = ((((pt_x * m._13) + ((pt_y * m._23))) + ((pt_z * m._33))) + m._43)
        pt_x = px
        pt_y = py
        pt_z = pz
        r.px = tmpRay.px
        r.py = tmpRay.py
        r.pz = tmpRay.pz
        r.lx = tmpRay.lx
        r.ly = tmpRay.ly
        r.lz = tmpRay.lz
        h3d_col_ObjectCollider.TMP_RAY = tmpRay
        dx = (pt_x - r.px)
        dy = (pt_y - r.py)
        dz = (pt_z - r.pz)
        if (dz is None):
            dz = 0.
        dz1 = dz
        if (dz1 is None):
            dz1 = 0.
        f = (((dx * dx) + ((dy * dy))) + ((dz1 * dz1)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def contains(self,p):
        x = p.x
        y = p.y
        z = p.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ptmp_x = x
        ptmp_y = y
        ptmp_z = z
        m = self.obj.getInvPos()
        px = ((((p.x * m._11) + ((p.y * m._21))) + ((p.z * m._31))) + m._41)
        py = ((((p.x * m._12) + ((p.y * m._22))) + ((p.z * m._32))) + m._42)
        pz = ((((p.x * m._13) + ((p.y * m._23))) + ((p.z * m._33))) + m._43)
        p.x = px
        p.y = py
        p.z = pz
        b = self.collider.contains(p)
        p.x = ptmp_x
        p.y = ptmp_y
        p.z = ptmp_z
        return b

    def inFrustum(self,f,m = None):
        if (m is None):
            return self.collider.inFrustum(f,self.obj.getAbsPos())
        mat = h3d_col_ObjectCollider.TMP_MAT
        b = self.obj.getAbsPos()
        m11 = m._11
        m12 = m._12
        m13 = m._13
        m21 = m._21
        m22 = m._22
        m23 = m._23
        a31 = m._31
        a32 = m._32
        a33 = m._33
        a41 = m._41
        a42 = m._42
        a43 = m._43
        b11 = b._11
        b12 = b._12
        b13 = b._13
        b21 = b._21
        b22 = b._22
        b23 = b._23
        b31 = b._31
        b32 = b._32
        b33 = b._33
        b41 = b._41
        b42 = b._42
        b43 = b._43
        mat._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
        mat._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
        mat._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
        mat._14 = 0
        mat._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
        mat._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
        mat._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
        mat._24 = 0
        mat._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
        mat._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
        mat._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
        mat._34 = 0
        mat._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
        mat._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
        mat._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
        mat._44 = 1
        return self.collider.inFrustum(f,mat)

    def inSphere(self,s):
        invMat = self.obj.getInvPos()
        oldX = s.x
        oldY = s.y
        oldZ = s.z
        oldR = s.r
        x = s.x
        y = s.y
        z = s.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        center_x = x
        center_y = y
        center_z = z
        px = ((((center_x * invMat._11) + ((center_y * invMat._21))) + ((center_z * invMat._31))) + invMat._41)
        py = ((((center_x * invMat._12) + ((center_y * invMat._22))) + ((center_z * invMat._32))) + invMat._42)
        pz = ((((center_x * invMat._13) + ((center_y * invMat._23))) + ((center_z * invMat._33))) + invMat._43)
        center_x = px
        center_y = py
        center_z = pz
        v = None
        if (v is None):
            v = h3d_Vector()
        f = (((invMat._11 * invMat._11) + ((invMat._12 * invMat._12))) + ((invMat._13 * invMat._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((invMat._21 * invMat._21) + ((invMat._22 * invMat._22))) + ((invMat._23 * invMat._23)))
        v.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((invMat._31 * invMat._31) + ((invMat._32 * invMat._32))) + ((invMat._33 * invMat._33)))
        v.z = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if ((((invMat._11 * (((invMat._22 * invMat._33) - ((invMat._23 * invMat._32))))) + ((invMat._12 * (((invMat._23 * invMat._31) - ((invMat._21 * invMat._33))))))) + ((invMat._13 * (((invMat._21 * invMat._32) - ((invMat._22 * invMat._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        scale = v
        s.x = center_x
        s.y = center_y
        s.z = center_z
        s1 = s
        s2 = s1.r
        a = scale.x
        b = scale.y
        a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        b = scale.z
        s1.r = (s2 * ((a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else max(a1,b)))))
        res = self.collider.inSphere(s)
        s.x = oldX
        s.y = oldY
        s.z = oldZ
        s.r = oldR
        return res

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.collider = None
h3d_col_ObjectCollider._hx_class = h3d_col_ObjectCollider
_hx_classes["h3d.col.ObjectCollider"] = h3d_col_ObjectCollider


class h3d_col_Plane:
    _hx_class_name = "h3d.col.Plane"
    _hx_is_interface = "False"
    __slots__ = ("nx", "ny", "nz", "d")
    _hx_fields = ["nx", "ny", "nz", "d"]
    _hx_methods = ["getNormal", "getNormalDistance", "load", "transform", "transform3x3", "transformInverseTranspose", "normalize", "toString", "distance", "side", "project", "projectTo"]
    _hx_statics = ["fromPoints", "fromNormalPoint", "X", "Y", "Z", "frustumLeft", "frustumRight", "frustumBottom", "frustumTop", "frustumNear", "frustumFar"]

    def __init__(self,nx,ny,nz,d):
        self.nx = nx
        self.ny = ny
        self.nz = nz
        self.d = d

    def getNormal(self):
        return h3d_col_Point(self.nx,self.ny,self.nz)

    def getNormalDistance(self):
        return self.d

    def load(self,p):
        self.nx = p.nx
        self.ny = p.ny
        self.nz = p.nz
        self.d = p.d

    def transform(self,m):
        m2 = h3d_Matrix()
        m2.initInverse(m)
        m2.transpose()
        x = self.nx
        y = self.ny
        z = self.nz
        w = -self.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        self.nx = v_x
        self.ny = v_y
        self.nz = v_z
        self.d = -v_w

    def transform3x3(self,m):
        m2 = h3d_Matrix()
        m2.initInverse3x3(m)
        m2.transpose()
        x = self.nx
        y = self.ny
        z = self.nz
        w = -self.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        self.nx = v_x
        self.ny = v_y
        self.nz = v_z
        self.d = -v_w

    def transformInverseTranspose(self,m):
        x = self.nx
        y = self.ny
        z = self.nz
        w = -self.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + ((v_w * m._41)))
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + ((v_w * m._42)))
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + ((v_w * m._43)))
        pw = ((((v_x * m._14) + ((v_y * m._24))) + ((v_z * m._34))) + ((v_w * m._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        self.nx = v_x
        self.ny = v_y
        self.nz = v_z
        self.d = -v_w

    def normalize(self):
        f = (((self.nx * self.nx) + ((self.ny * self.ny))) + ((self.nz * self.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nx
        _hx_local_0.nx = (_hx_local_1 * _hx_len)
        _hx_local_0.nx
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.ny
        _hx_local_2.ny = (_hx_local_3 * _hx_len)
        _hx_local_2.ny
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.nz
        _hx_local_4.nz = (_hx_local_5 * _hx_len)
        _hx_local_4.nz
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.d
        _hx_local_6.d = (_hx_local_7 * _hx_len)
        _hx_local_6.d

    def toString(self):
        return (((("Plane{" + Std.string(h3d_col_Point(self.nx,self.ny,self.nz))) + ",") + Std.string(hxd_Math.fmt(self.d))) + "}")

    def distance(self,p):
        return ((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d)

    def side(self,p):
        return (((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d) >= 0)

    def project(self,p):
        d = ((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d)
        return h3d_col_Point((p.x - ((d * self.nx))),(p.y - ((d * self.ny))),(p.z - ((d * self.nz))))

    def projectTo(self,p,out):
        d = ((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d)
        out.x = (p.x - ((d * self.nx)))
        out.y = (p.y - ((d * self.ny)))
        out.z = (p.z - ((d * self.nz)))

    @staticmethod
    def fromPoints(p0,p1,p2):
        x = (p1.x - p0.x)
        y = (p1.y - p0.y)
        z = (p1.z - p0.z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d1_x = x
        d1_y = y
        d1_z = z
        x = (p2.x - p0.x)
        y = (p2.y - p0.y)
        z = (p2.z - p0.z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d2_x = x
        d2_y = y
        d2_z = z
        x = ((d1_y * d2_z) - ((d1_z * d2_y)))
        y = ((d1_z * d2_x) - ((d1_x * d2_z)))
        z = ((d1_x * d2_y) - ((d1_y * d2_x)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        n_x = x
        n_y = y
        n_z = z
        return h3d_col_Plane(n_x,n_y,n_z,(((n_x * p0.x) + ((n_y * p0.y))) + ((n_z * p0.z))))

    @staticmethod
    def fromNormalPoint(n,p):
        return h3d_col_Plane(n.x,n.y,n.z,(((n.x * p.x) + ((n.y * p.y))) + ((n.z * p.z))))

    @staticmethod
    def X(v = None):
        if (v is None):
            v = 0.0
        return h3d_col_Plane(1,0,0,v)

    @staticmethod
    def Y(v = None):
        if (v is None):
            v = 0.0
        return h3d_col_Plane(0,1,0,v)

    @staticmethod
    def Z(v = None):
        if (v is None):
            v = 0.0
        return h3d_col_Plane(0,0,1,v)

    @staticmethod
    def frustumLeft(mvp):
        return h3d_col_Plane((mvp._14 + mvp._11),(mvp._24 + mvp._21),(mvp._34 + mvp._31),-((mvp._44 + mvp._41)))

    @staticmethod
    def frustumRight(mvp):
        return h3d_col_Plane((mvp._14 - mvp._11),(mvp._24 - mvp._21),(mvp._34 - mvp._31),(mvp._41 - mvp._44))

    @staticmethod
    def frustumBottom(mvp):
        return h3d_col_Plane((mvp._14 + mvp._12),(mvp._24 + mvp._22),(mvp._34 + mvp._32),-((mvp._44 + mvp._42)))

    @staticmethod
    def frustumTop(mvp):
        return h3d_col_Plane((mvp._14 - mvp._12),(mvp._24 - mvp._22),(mvp._34 - mvp._32),(mvp._42 - mvp._44))

    @staticmethod
    def frustumNear(mvp):
        return h3d_col_Plane(mvp._13,mvp._23,mvp._33,-mvp._43)

    @staticmethod
    def frustumFar(mvp):
        return h3d_col_Plane((mvp._14 - mvp._13),(mvp._24 - mvp._23),(mvp._34 - mvp._33),(mvp._43 - mvp._44))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nx = None
        _hx_o.ny = None
        _hx_o.nz = None
        _hx_o.d = None
h3d_col_Plane._hx_class = h3d_col_Plane
_hx_classes["h3d.col.Plane"] = h3d_col_Plane


class h3d_col_Point:
    _hx_class_name = "h3d.col.Point"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z")
    _hx_fields = ["x", "y", "z"]
    _hx_methods = ["scale", "set", "sub", "add", "multiply", "cross", "equals", "lengthSq", "length", "dot", "distanceSq", "distance", "normalize", "normalized", "lerp", "transform", "transformed", "transform3x3", "transformed3x3", "clone", "load", "toString", "inFrustum", "toVector"]

    def __init__(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        self.x = x
        self.y = y
        self.z = z

    def scale(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * v)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * v)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * v)
        _hx_local_4.z

    def set(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        self.x = x
        self.y = y
        self.z = z

    def sub(self,p):
        return h3d_col_Point((self.x - p.x),(self.y - p.y),(self.z - p.z))

    def add(self,p):
        return h3d_col_Point((self.x + p.x),(self.y + p.y),(self.z + p.z))

    def multiply(self,v):
        return h3d_col_Point((self.x * v),(self.y * v),(self.z * v))

    def cross(self,p):
        return h3d_col_Point(((self.y * p.z) - ((self.z * p.y))),((self.z * p.x) - ((self.x * p.z))),((self.x * p.y) - ((self.y * p.x))))

    def equals(self,other):
        if ((self.x == other.x) and ((self.y == other.y))):
            return (self.z == other.z)
        else:
            return False

    def lengthSq(self):
        return (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))

    def length(self):
        f = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def dot(self,p):
        return (((self.x * p.x) + ((self.y * p.y))) + ((self.z * p.z)))

    def distanceSq(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        dz = (p.z - self.z)
        return (((dx * dx) + ((dy * dy))) + ((dz * dz)))

    def distance(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        dz = (p.z - self.z)
        f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def normalize(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * k)
        _hx_local_4.z

    def normalized(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        return h3d_col_Point((self.x * k),(self.y * k),(self.z * k))

    def lerp(self,p1,p2,k):
        a = p1.x
        x = (a + ((k * ((p2.x - a)))))
        a = p1.y
        y = (a + ((k * ((p2.y - a)))))
        a = p1.z
        z = (a + ((k * ((p2.z - a)))))
        self.x = x
        self.y = y
        self.z = z

    def transform(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + m._41)
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + m._42)
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + m._43)
        self.x = px
        self.y = py
        self.z = pz

    def transformed(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + m._41)
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + m._42)
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + m._43)
        return h3d_col_Point(px,py,pz)

    def transform3x3(self,m):
        px = (((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31)))
        py = (((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32)))
        pz = (((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33)))
        self.x = px
        self.y = py
        self.z = pz

    def transformed3x3(self,m):
        px = (((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31)))
        py = (((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32)))
        pz = (((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33)))
        return h3d_col_Point(px,py,pz)

    def clone(self):
        return h3d_col_Point(self.x,self.y,self.z)

    def load(self,p):
        self.x = p.x
        self.y = p.y
        self.z = p.z

    def toString(self):
        return (((((("Point{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.z))) + "}")

    def inFrustum(self,f,m = None):
        return f.hasPoint(self)

    def toVector(self):
        return h3d_Vector(self.x,self.y,self.z)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
h3d_col_Point._hx_class = h3d_col_Point
_hx_classes["h3d.col.Point"] = h3d_col_Point


class h3d_col_TriPlane:
    _hx_class_name = "h3d.col.TriPlane"
    _hx_is_interface = "False"
    __slots__ = ("next", "p0x", "p0y", "p0z", "d1x", "d1y", "d1z", "d2x", "d2y", "d2z", "dot00", "dot01", "dot11", "invDenom", "nx", "ny", "nz", "d")
    _hx_fields = ["next", "p0x", "p0y", "p0z", "d1x", "d1y", "d1z", "d2x", "d2y", "d2z", "dot00", "dot01", "dot11", "invDenom", "nx", "ny", "nz", "d"]
    _hx_methods = ["init", "clone", "load", "transform", "contains", "side", "inFrustum", "inSphere", "rayIntersection", "isPointInTriangle", "getPoints"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self):
        self.d = None
        self.nz = None
        self.ny = None
        self.nx = None
        self.invDenom = None
        self.dot11 = None
        self.dot01 = None
        self.dot00 = None
        self.d2z = None
        self.d2y = None
        self.d2x = None
        self.d1z = None
        self.d1y = None
        self.d1x = None
        self.p0z = None
        self.p0y = None
        self.p0x = None
        self.next = None

    def init(self,p0,p1,p2):
        self.p0x = p0.x
        self.p0y = p0.y
        self.p0z = p0.z
        x = (p1.x - p0.x)
        y = (p1.y - p0.y)
        z = (p1.z - p0.z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d1_x = x
        d1_y = y
        d1_z = z
        x = (p2.x - p0.x)
        y = (p2.y - p0.y)
        z = (p2.z - p0.z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d2_x = x
        d2_y = y
        d2_z = z
        x = ((d1_y * d2_z) - ((d1_z * d2_y)))
        y = ((d1_z * d2_x) - ((d1_x * d2_z)))
        z = ((d1_x * d2_y) - ((d1_y * d2_x)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        n_x = x
        n_y = y
        n_z = z
        self.d = (((n_x * p0.x) + ((n_y * p0.y))) + ((n_z * p0.z)))
        self.nx = n_x
        self.ny = n_y
        self.nz = n_z
        self.d1x = d1_x
        self.d1y = d1_y
        self.d1z = d1_z
        self.d2x = d2_x
        self.d2y = d2_y
        self.d2z = d2_z
        self.dot00 = (((d1_x * d1_x) + ((d1_y * d1_y))) + ((d1_z * d1_z)))
        self.dot01 = (((d1_x * d2_x) + ((d1_y * d2_y))) + ((d1_z * d2_z)))
        self.dot11 = (((d2_x * d2_x) + ((d2_y * d2_y))) + ((d2_z * d2_z)))
        self.invDenom = (1 / (((self.dot00 * self.dot11) - ((self.dot01 * self.dot01)))))

    def clone(self):
        clone = h3d_col_TriPlane()
        clone.p0x = self.p0x
        clone.p0y = self.p0y
        clone.p0z = self.p0z
        clone.d1x = self.d1x
        clone.d1y = self.d1y
        clone.d1z = self.d1z
        clone.d2x = self.d2x
        clone.d2y = self.d2y
        clone.d2z = self.d2z
        clone.dot00 = self.dot00
        clone.dot01 = self.dot01
        clone.dot11 = self.dot11
        clone.invDenom = self.invDenom
        clone.nx = self.nx
        clone.ny = self.ny
        clone.nz = self.nz
        clone.d = self.d
        if (self.next is not None):
            clone.next = self.next.clone()
        return clone

    def load(self,tp):
        self.p0x = tp.p0x
        self.p0y = tp.p0y
        self.p0z = tp.p0z
        self.d1x = tp.d1x
        self.d1y = tp.d1y
        self.d1z = tp.d1z
        self.d2x = tp.d2x
        self.d2y = tp.d2y
        self.d2z = tp.d2z
        self.dot00 = tp.dot00
        self.dot01 = tp.dot01
        self.dot11 = tp.dot11
        self.invDenom = tp.invDenom
        self.nx = tp.nx
        self.ny = tp.ny
        self.nz = tp.nz
        self.d = tp.d

    def transform(self,m):
        x = self.p0x
        y = self.p0y
        z = self.p0z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p0_x = x
        p0_y = y
        p0_z = z
        x = (self.d1x + self.p0x)
        y = (self.d1y + self.p0y)
        z = (self.d1z + self.p0z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p1_x = x
        p1_y = y
        p1_z = z
        x = (self.d2x + self.p0x)
        y = (self.d2y + self.p0y)
        z = (self.d2z + self.p0z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p2_x = x
        p2_y = y
        p2_z = z
        px = ((((p0_x * m._11) + ((p0_y * m._21))) + ((p0_z * m._31))) + m._41)
        py = ((((p0_x * m._12) + ((p0_y * m._22))) + ((p0_z * m._32))) + m._42)
        pz = ((((p0_x * m._13) + ((p0_y * m._23))) + ((p0_z * m._33))) + m._43)
        p0_x = px
        p0_y = py
        p0_z = pz
        px = ((((p1_x * m._11) + ((p1_y * m._21))) + ((p1_z * m._31))) + m._41)
        py = ((((p1_x * m._12) + ((p1_y * m._22))) + ((p1_z * m._32))) + m._42)
        pz = ((((p1_x * m._13) + ((p1_y * m._23))) + ((p1_z * m._33))) + m._43)
        p1_x = px
        p1_y = py
        p1_z = pz
        px = ((((p2_x * m._11) + ((p2_y * m._21))) + ((p2_z * m._31))) + m._41)
        py = ((((p2_x * m._12) + ((p2_y * m._22))) + ((p2_z * m._32))) + m._42)
        pz = ((((p2_x * m._13) + ((p2_y * m._23))) + ((p2_z * m._33))) + m._43)
        p2_x = px
        p2_y = py
        p2_z = pz
        self.p0x = p0_x
        self.p0y = p0_y
        self.p0z = p0_z
        x = (p1_x - p0_x)
        y = (p1_y - p0_y)
        z = (p1_z - p0_z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d1_x = x
        d1_y = y
        d1_z = z
        x = (p2_x - p0_x)
        y = (p2_y - p0_y)
        z = (p2_z - p0_z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d2_x = x
        d2_y = y
        d2_z = z
        x = ((d1_y * d2_z) - ((d1_z * d2_y)))
        y = ((d1_z * d2_x) - ((d1_x * d2_z)))
        z = ((d1_x * d2_y) - ((d1_y * d2_x)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        n_x = x
        n_y = y
        n_z = z
        self.d = (((n_x * p0_x) + ((n_y * p0_y))) + ((n_z * p0_z)))
        self.nx = n_x
        self.ny = n_y
        self.nz = n_z
        self.d1x = d1_x
        self.d1y = d1_y
        self.d1z = d1_z
        self.d2x = d2_x
        self.d2y = d2_y
        self.d2z = d2_z
        self.dot00 = (((d1_x * d1_x) + ((d1_y * d1_y))) + ((d1_z * d1_z)))
        self.dot01 = (((d1_x * d2_x) + ((d1_y * d2_y))) + ((d1_z * d2_z)))
        self.dot11 = (((d2_x * d2_x) + ((d2_y * d2_y))) + ((d2_z * d2_z)))
        self.invDenom = (1 / (((self.dot00 * self.dot11) - ((self.dot01 * self.dot01)))))

    def contains(self,p):
        x = (p.x - self.p0x)
        y = (p.y - self.p0y)
        z = (p.z - self.p0z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v2_x = x
        v2_y = y
        v2_z = z
        dot02 = (((self.d1x * v2_x) + ((self.d1y * v2_y))) + ((self.d1z * v2_z)))
        dot12 = (((self.d2x * v2_x) + ((self.d2y * v2_y))) + ((self.d2z * v2_z)))
        u = ((((self.dot11 * dot02) - ((self.dot01 * dot12)))) * self.invDenom)
        v = ((((self.dot00 * dot12) - ((self.dot01 * dot02)))) * self.invDenom)
        if ((u >= 0) and ((v >= 0))):
            return ((u + v) < 1)
        else:
            return False

    def side(self,p):
        return (((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d) >= 0)

    def inFrustum(self,f,m = None):
        raise haxe_Exception.thrown("Not implemented")

    def inSphere(self,s):
        raise haxe_Exception.thrown("Not implemented")

    def rayIntersection(self,r,bestMatch):
        dr = (((r.lx * self.nx) + ((r.ly * self.ny))) + ((r.lz * self.nz)))
        if (dr >= 0):
            return -1.
        nd = (self.d - ((((r.px * self.nx) + ((r.py * self.ny))) + ((r.pz * self.nz)))))
        k = (nd / dr)
        if (k < 0):
            return -1
        px = (r.px + ((r.lx * k)))
        py = (r.py + ((r.ly * k)))
        pz = (r.pz + ((r.lz * k)))
        x = (px - self.p0x)
        y = (py - self.p0y)
        z = (pz - self.p0z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v2_x = x
        v2_y = y
        v2_z = z
        dot02 = (((self.d1x * v2_x) + ((self.d1y * v2_y))) + ((self.d1z * v2_z)))
        dot12 = (((self.d2x * v2_x) + ((self.d2y * v2_y))) + ((self.d2z * v2_z)))
        u = ((((self.dot11 * dot02) - ((self.dot01 * dot12)))) * self.invDenom)
        v = ((((self.dot00 * dot12) - ((self.dot01 * dot02)))) * self.invDenom)
        if (not ((((u >= 0) and ((v >= 0))) and (((u + v) < 1))))):
            return -1
        return k

    def isPointInTriangle(self,x,y,z):
        x1 = (x - self.p0x)
        y1 = (y - self.p0y)
        z1 = (z - self.p0z)
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        v2_x = x1
        v2_y = y1
        v2_z = z1
        dot02 = (((self.d1x * v2_x) + ((self.d1y * v2_y))) + ((self.d1z * v2_z)))
        dot12 = (((self.d2x * v2_x) + ((self.d2y * v2_y))) + ((self.d2z * v2_z)))
        u = ((((self.dot11 * dot02) - ((self.dot01 * dot12)))) * self.invDenom)
        v = ((((self.dot00 * dot12) - ((self.dot01 * dot02)))) * self.invDenom)
        if ((u >= 0) and ((v >= 0))):
            return ((u + v) < 1)
        else:
            return False

    def getPoints(self):
        return [h3d_col_Point(self.p0x,self.p0y,self.p0z), h3d_col_Point((self.d1x + self.p0x),(self.d1y + self.p0y),(self.d1z + self.p0z)), h3d_col_Point((self.d2x + self.p0x),(self.d2y + self.p0y),(self.d2z + self.p0z))]

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.p0x = None
        _hx_o.p0y = None
        _hx_o.p0z = None
        _hx_o.d1x = None
        _hx_o.d1y = None
        _hx_o.d1z = None
        _hx_o.d2x = None
        _hx_o.d2y = None
        _hx_o.d2z = None
        _hx_o.dot00 = None
        _hx_o.dot01 = None
        _hx_o.dot11 = None
        _hx_o.invDenom = None
        _hx_o.nx = None
        _hx_o.ny = None
        _hx_o.nz = None
        _hx_o.d = None
h3d_col_TriPlane._hx_class = h3d_col_TriPlane
_hx_classes["h3d.col.TriPlane"] = h3d_col_TriPlane


class h3d_col_Polygon:
    _hx_class_name = "h3d.col.Polygon"
    _hx_is_interface = "False"
    __slots__ = ("triPlanes",)
    _hx_fields = ["triPlanes"]
    _hx_methods = ["addBuffers", "isConvex", "clone", "transform", "getPoints", "getBounds", "contains", "rayIntersection", "inFrustum", "inSphere"]
    _hx_statics = ["fromPolygon2D"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self):
        self.triPlanes = None

    def addBuffers(self,vertexes,indexes,stride = None):
        if (stride is None):
            stride = 3
        _g = 0
        x = (len(indexes) / 3)
        _g1 = None
        try:
            _g1 = int(x)
        except BaseException as _g2:
            None
            _g1 = None
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            k = (i * 3)
            t = h3d_col_TriPlane()
            i0 = (indexes[k] * stride)
            i1 = (indexes[(k + 1)] * stride)
            i2 = (indexes[(k + 2)] * stride)
            x = python_Syntax._arrayAccess(vertexes,[i0])
            y = python_Syntax._arrayAccess(vertexes,[(i0 + 1)])
            z = python_Syntax._arrayAccess(vertexes,[(i0 + 2)])
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p0_x = x
            p0_y = y
            p0_z = z
            x1 = python_Syntax._arrayAccess(vertexes,[i1])
            y1 = python_Syntax._arrayAccess(vertexes,[(i1 + 1)])
            z1 = python_Syntax._arrayAccess(vertexes,[(i1 + 2)])
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            p1_x = x1
            p1_y = y1
            p1_z = z1
            x2 = python_Syntax._arrayAccess(vertexes,[i2])
            y2 = python_Syntax._arrayAccess(vertexes,[(i2 + 1)])
            z2 = python_Syntax._arrayAccess(vertexes,[(i2 + 2)])
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            p2_x = x2
            p2_y = y2
            p2_z = z2
            t.p0x = p0_x
            t.p0y = p0_y
            t.p0z = p0_z
            x3 = (p1_x - p0_x)
            y3 = (p1_y - p0_y)
            z3 = (p1_z - p0_z)
            if (z3 is None):
                z3 = 0.
            if (y3 is None):
                y3 = 0.
            if (x3 is None):
                x3 = 0.
            d1_x = x3
            d1_y = y3
            d1_z = z3
            x4 = (p2_x - p0_x)
            y4 = (p2_y - p0_y)
            z4 = (p2_z - p0_z)
            if (z4 is None):
                z4 = 0.
            if (y4 is None):
                y4 = 0.
            if (x4 is None):
                x4 = 0.
            d2_x = x4
            d2_y = y4
            d2_z = z4
            x5 = ((d1_y * d2_z) - ((d1_z * d2_y)))
            y5 = ((d1_z * d2_x) - ((d1_x * d2_z)))
            z5 = ((d1_x * d2_y) - ((d1_y * d2_x)))
            if (z5 is None):
                z5 = 0.
            if (y5 is None):
                y5 = 0.
            if (x5 is None):
                x5 = 0.
            n_x = x5
            n_y = y5
            n_z = z5
            t.d = (((n_x * p0_x) + ((n_y * p0_y))) + ((n_z * p0_z)))
            t.nx = n_x
            t.ny = n_y
            t.nz = n_z
            t.d1x = d1_x
            t.d1y = d1_y
            t.d1z = d1_z
            t.d2x = d2_x
            t.d2y = d2_y
            t.d2z = d2_z
            t.dot00 = (((d1_x * d1_x) + ((d1_y * d1_y))) + ((d1_z * d1_z)))
            t.dot01 = (((d1_x * d2_x) + ((d1_y * d2_y))) + ((d1_z * d2_z)))
            t.dot11 = (((d2_x * d2_x) + ((d2_y * d2_y))) + ((d2_z * d2_z)))
            t.invDenom = (1 / (((t.dot00 * t.dot11) - ((t.dot01 * t.dot01)))))
            t.next = self.triPlanes
            self.triPlanes = t

    def isConvex(self):
        return True

    def clone(self):
        clone = h3d_col_Polygon()
        clone.triPlanes = h3d_col_TriPlane()
        _this = self.triPlanes
        clone1 = h3d_col_TriPlane()
        clone1.p0x = _this.p0x
        clone1.p0y = _this.p0y
        clone1.p0z = _this.p0z
        clone1.d1x = _this.d1x
        clone1.d1y = _this.d1y
        clone1.d1z = _this.d1z
        clone1.d2x = _this.d2x
        clone1.d2y = _this.d2y
        clone1.d2z = _this.d2z
        clone1.dot00 = _this.dot00
        clone1.dot01 = _this.dot01
        clone1.dot11 = _this.dot11
        clone1.invDenom = _this.invDenom
        clone1.nx = _this.nx
        clone1.ny = _this.ny
        clone1.nz = _this.nz
        clone1.d = _this.d
        if (_this.next is not None):
            _this1 = _this.next
            clone2 = h3d_col_TriPlane()
            clone2.p0x = _this1.p0x
            clone2.p0y = _this1.p0y
            clone2.p0z = _this1.p0z
            clone2.d1x = _this1.d1x
            clone2.d1y = _this1.d1y
            clone2.d1z = _this1.d1z
            clone2.d2x = _this1.d2x
            clone2.d2y = _this1.d2y
            clone2.d2z = _this1.d2z
            clone2.dot00 = _this1.dot00
            clone2.dot01 = _this1.dot01
            clone2.dot11 = _this1.dot11
            clone2.invDenom = _this1.invDenom
            clone2.nx = _this1.nx
            clone2.ny = _this1.ny
            clone2.nz = _this1.nz
            clone2.d = _this1.d
            if (_this1.next is not None):
                clone2.next = _this1.next.clone()
            clone1.next = clone2
        clone.triPlanes = clone1
        return clone

    def transform(self,m):
        t = self.triPlanes
        while (t is not None):
            t.transform(m)
            t = t.next

    def getPoints(self):
        ret = []
        t = self.triPlanes
        while (t is not None):
            ret = (ret + t.getPoints())
            t = t.next
        return ret

    def getBounds(self,bnds = None):
        if (bnds is None):
            bnds = h3d_col_Bounds()
        bnds.xMin = 1e20
        bnds.xMax = -1e20
        bnds.yMin = 1e20
        bnds.yMax = -1e20
        bnds.zMin = 1e20
        bnds.zMax = -1e20
        t = self.triPlanes
        while (t is not None):
            x = t.p0x
            y = t.p0y
            z = t.p0z
            if (x < bnds.xMin):
                bnds.xMin = x
            if (x > bnds.xMax):
                bnds.xMax = x
            if (y < bnds.yMin):
                bnds.yMin = y
            if (y > bnds.yMax):
                bnds.yMax = y
            if (z < bnds.zMin):
                bnds.zMin = z
            if (z > bnds.zMax):
                bnds.zMax = z
            x1 = (t.d1x + t.p0x)
            y1 = (t.d1y + t.p0y)
            z1 = (t.d1z + t.p0z)
            if (x1 < bnds.xMin):
                bnds.xMin = x1
            if (x1 > bnds.xMax):
                bnds.xMax = x1
            if (y1 < bnds.yMin):
                bnds.yMin = y1
            if (y1 > bnds.yMax):
                bnds.yMax = y1
            if (z1 < bnds.zMin):
                bnds.zMin = z1
            if (z1 > bnds.zMax):
                bnds.zMax = z1
            x2 = (t.d2x + t.p0x)
            y2 = (t.d2y + t.p0y)
            z2 = (t.d2z + t.p0z)
            if (x2 < bnds.xMin):
                bnds.xMin = x2
            if (x2 > bnds.xMax):
                bnds.xMax = x2
            if (y2 < bnds.yMin):
                bnds.yMin = y2
            if (y2 > bnds.yMax):
                bnds.yMax = y2
            if (z2 < bnds.zMin):
                bnds.zMin = z2
            if (z2 > bnds.zMax):
                bnds.zMax = z2
            t = t.next
        return bnds

    def contains(self,p):
        if (not self.isConvex()):
            raise haxe_Exception.thrown("Not implemented for concave polygon")
        t = self.triPlanes
        while (t is not None):
            if (((((t.nx * p.x) + ((t.ny * p.y))) + ((t.nz * p.z))) - t.d) >= 0):
                return False
            t = t.next
        return True

    def rayIntersection(self,r,bestMatch):
        t = self.triPlanes
        best = -1.
        while (t is not None):
            dr = (((r.lx * t.nx) + ((r.ly * t.ny))) + ((r.lz * t.nz)))
            d = None
            if (dr >= 0):
                d = -1.
            else:
                nd = (t.d - ((((r.px * t.nx) + ((r.py * t.ny))) + ((r.pz * t.nz)))))
                k = (nd / dr)
                if (k < 0):
                    d = -1
                else:
                    px = (r.px + ((r.lx * k)))
                    py = (r.py + ((r.ly * k)))
                    pz = (r.pz + ((r.lz * k)))
                    x = (px - t.p0x)
                    y = (py - t.p0y)
                    z = (pz - t.p0z)
                    if (z is None):
                        z = 0.
                    if (y is None):
                        y = 0.
                    if (x is None):
                        x = 0.
                    v2_x = x
                    v2_y = y
                    v2_z = z
                    dot02 = (((t.d1x * v2_x) + ((t.d1y * v2_y))) + ((t.d1z * v2_z)))
                    dot12 = (((t.d2x * v2_x) + ((t.d2y * v2_y))) + ((t.d2z * v2_z)))
                    u = ((((t.dot11 * dot02) - ((t.dot01 * dot12)))) * t.invDenom)
                    v = ((((t.dot00 * dot12) - ((t.dot01 * dot02)))) * t.invDenom)
                    d = (-1 if ((not ((((u >= 0) and ((v >= 0))) and (((u + v) < 1)))))) else k)
            if (d >= 0):
                if (not bestMatch):
                    return d
                if ((best < 0) or ((d < best))):
                    best = d
            t = t.next
        return best

    def inFrustum(self,f,m = None):
        raise haxe_Exception.thrown("Not implemented")

    def inSphere(self,s):
        raise haxe_Exception.thrown("Not implemented")

    @staticmethod
    def fromPolygon2D(p,z = None):
        if (z is None):
            z = 0.
        pout = h3d_col_Polygon()
        if h2d_col__Polygon_Polygon_Impl_.isConvex(p):
            p0 = (p[0] if 0 < len(p) else None)
            _g = 0
            _g1 = (len(p) - 2)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p1 = python_internal_ArrayImpl._get(p, (i + 1))
                p2 = python_internal_ArrayImpl._get(p, (i + 2))
                t = h3d_col_TriPlane()
                x = p0.x
                y = p0.y
                z1 = z
                if (z1 is None):
                    z1 = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p0_x = x
                p0_y = y
                p0_z = z1
                x1 = p1.x
                y1 = p1.y
                z2 = z
                if (z2 is None):
                    z2 = 0.
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                p1_x = x1
                p1_y = y1
                p1_z = z2
                x2 = p2.x
                y2 = p2.y
                z3 = z
                if (z3 is None):
                    z3 = 0.
                if (y2 is None):
                    y2 = 0.
                if (x2 is None):
                    x2 = 0.
                p2_x = x2
                p2_y = y2
                p2_z = z3
                t.p0x = p0_x
                t.p0y = p0_y
                t.p0z = p0_z
                x3 = (p1_x - p0_x)
                y3 = (p1_y - p0_y)
                z4 = (p1_z - p0_z)
                if (z4 is None):
                    z4 = 0.
                if (y3 is None):
                    y3 = 0.
                if (x3 is None):
                    x3 = 0.
                d1_x = x3
                d1_y = y3
                d1_z = z4
                x4 = (p2_x - p0_x)
                y4 = (p2_y - p0_y)
                z5 = (p2_z - p0_z)
                if (z5 is None):
                    z5 = 0.
                if (y4 is None):
                    y4 = 0.
                if (x4 is None):
                    x4 = 0.
                d2_x = x4
                d2_y = y4
                d2_z = z5
                x5 = ((d1_y * d2_z) - ((d1_z * d2_y)))
                y5 = ((d1_z * d2_x) - ((d1_x * d2_z)))
                z6 = ((d1_x * d2_y) - ((d1_y * d2_x)))
                if (z6 is None):
                    z6 = 0.
                if (y5 is None):
                    y5 = 0.
                if (x5 is None):
                    x5 = 0.
                n_x = x5
                n_y = y5
                n_z = z6
                t.d = (((n_x * p0_x) + ((n_y * p0_y))) + ((n_z * p0_z)))
                t.nx = n_x
                t.ny = n_y
                t.nz = n_z
                t.d1x = d1_x
                t.d1y = d1_y
                t.d1z = d1_z
                t.d2x = d2_x
                t.d2y = d2_y
                t.d2z = d2_z
                t.dot00 = (((d1_x * d1_x) + ((d1_y * d1_y))) + ((d1_z * d1_z)))
                t.dot01 = (((d1_x * d2_x) + ((d1_y * d2_y))) + ((d1_z * d2_z)))
                t.dot11 = (((d2_x * d2_x) + ((d2_y * d2_y))) + ((d2_z * d2_z)))
                t.invDenom = (1 / (((t.dot00 * t.dot11) - ((t.dot01 * t.dot01)))))
                t.next = pout.triPlanes
                pout.triPlanes = t
        else:
            idx = h2d_col__Polygon_Polygon_Impl_.fastTriangulate(p)
            _g = 0
            x = (len(idx) / 3)
            _g1 = None
            try:
                _g1 = int(x)
            except BaseException as _g2:
                None
                _g1 = None
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p0 = python_internal_ArrayImpl._get(p, python_internal_ArrayImpl._get(idx, (i * 3)))
                p1 = python_internal_ArrayImpl._get(p, python_internal_ArrayImpl._get(idx, ((i * 3) + 1)))
                p2 = python_internal_ArrayImpl._get(p, python_internal_ArrayImpl._get(idx, ((i * 3) + 2)))
                t = h3d_col_TriPlane()
                x = p0.x
                y = p0.y
                z1 = z
                if (z1 is None):
                    z1 = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p0_x = x
                p0_y = y
                p0_z = z1
                x1 = p1.x
                y1 = p1.y
                z2 = z
                if (z2 is None):
                    z2 = 0.
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                p1_x = x1
                p1_y = y1
                p1_z = z2
                x2 = p2.x
                y2 = p2.y
                z3 = z
                if (z3 is None):
                    z3 = 0.
                if (y2 is None):
                    y2 = 0.
                if (x2 is None):
                    x2 = 0.
                p2_x = x2
                p2_y = y2
                p2_z = z3
                t.p0x = p0_x
                t.p0y = p0_y
                t.p0z = p0_z
                x3 = (p1_x - p0_x)
                y3 = (p1_y - p0_y)
                z4 = (p1_z - p0_z)
                if (z4 is None):
                    z4 = 0.
                if (y3 is None):
                    y3 = 0.
                if (x3 is None):
                    x3 = 0.
                d1_x = x3
                d1_y = y3
                d1_z = z4
                x4 = (p2_x - p0_x)
                y4 = (p2_y - p0_y)
                z5 = (p2_z - p0_z)
                if (z5 is None):
                    z5 = 0.
                if (y4 is None):
                    y4 = 0.
                if (x4 is None):
                    x4 = 0.
                d2_x = x4
                d2_y = y4
                d2_z = z5
                x5 = ((d1_y * d2_z) - ((d1_z * d2_y)))
                y5 = ((d1_z * d2_x) - ((d1_x * d2_z)))
                z6 = ((d1_x * d2_y) - ((d1_y * d2_x)))
                if (z6 is None):
                    z6 = 0.
                if (y5 is None):
                    y5 = 0.
                if (x5 is None):
                    x5 = 0.
                n_x = x5
                n_y = y5
                n_z = z6
                t.d = (((n_x * p0_x) + ((n_y * p0_y))) + ((n_z * p0_z)))
                t.nx = n_x
                t.ny = n_y
                t.nz = n_z
                t.d1x = d1_x
                t.d1y = d1_y
                t.d1z = d1_z
                t.d2x = d2_x
                t.d2y = d2_y
                t.d2z = d2_z
                t.dot00 = (((d1_x * d1_x) + ((d1_y * d1_y))) + ((d1_z * d1_z)))
                t.dot01 = (((d1_x * d2_x) + ((d1_y * d2_y))) + ((d1_z * d2_z)))
                t.dot11 = (((d2_x * d2_x) + ((d2_y * d2_y))) + ((d2_z * d2_z)))
                t.invDenom = (1 / (((t.dot00 * t.dot11) - ((t.dot01 * t.dot01)))))
                t.next = pout.triPlanes
                pout.triPlanes = t
        return pout

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.triPlanes = None
h3d_col_Polygon._hx_class = h3d_col_Polygon
_hx_classes["h3d.col.Polygon"] = h3d_col_Polygon


class h3d_col_PolygonBuffer:
    _hx_class_name = "h3d.col.PolygonBuffer"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "indexes", "startIndex", "triCount", "source")
    _hx_fields = ["buffer", "indexes", "startIndex", "triCount", "source"]
    _hx_methods = ["setData", "contains", "inFrustum", "inSphere", "rayIntersection"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self):
        self.source = None
        self.triCount = None
        self.startIndex = None
        self.indexes = None
        self.buffer = None

    def setData(self,buffer,indexes,startIndex = None,triCount = None):
        if (startIndex is None):
            startIndex = 0
        if (triCount is None):
            triCount = -1
        self.buffer = buffer
        self.indexes = indexes
        self.startIndex = startIndex
        tmp = None
        if (triCount >= 0):
            tmp = triCount
        else:
            x = (((len(indexes) - startIndex)) / 3)
            try:
                tmp = int(x)
            except BaseException as _g:
                None
                tmp = None
        self.triCount = tmp

    def contains(self,p):
        i = self.startIndex
        x = p.x
        y = p.y
        z = p.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        _g = 0
        _g1 = self.triCount
        while (_g < _g1):
            t = _g
            _g = (_g + 1)
            index = i
            i = (i + 1)
            i0 = (self.indexes[index] * 3)
            index1 = i0
            i0 = (i0 + 1)
            x = python_Syntax._arrayAccess(self.buffer,[index1])
            index2 = i0
            i0 = (i0 + 1)
            y = python_Syntax._arrayAccess(self.buffer,[index2])
            z = python_Syntax._arrayAccess(self.buffer,[i0])
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p0_x = x
            p0_y = y
            p0_z = z
            index3 = i
            i = (i + 1)
            i1 = (self.indexes[index3] * 3)
            index4 = i1
            i1 = (i1 + 1)
            x1 = python_Syntax._arrayAccess(self.buffer,[index4])
            index5 = i1
            i1 = (i1 + 1)
            y1 = python_Syntax._arrayAccess(self.buffer,[index5])
            z1 = python_Syntax._arrayAccess(self.buffer,[i1])
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            p1_x = x1
            p1_y = y1
            p1_z = z1
            index6 = i
            i = (i + 1)
            i2 = (self.indexes[index6] * 3)
            index7 = i2
            i2 = (i2 + 1)
            x2 = python_Syntax._arrayAccess(self.buffer,[index7])
            index8 = i2
            i2 = (i2 + 1)
            y2 = python_Syntax._arrayAccess(self.buffer,[index8])
            z2 = python_Syntax._arrayAccess(self.buffer,[i2])
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            p2_x = x2
            p2_y = y2
            p2_z = z2
            x3 = (p1_x - p0_x)
            y3 = (p1_y - p0_y)
            z3 = (p1_z - p0_z)
            if (z3 is None):
                z3 = 0.
            if (y3 is None):
                y3 = 0.
            if (x3 is None):
                x3 = 0.
            d1_x = x3
            d1_y = y3
            d1_z = z3
            x4 = (p2_x - p0_x)
            y4 = (p2_y - p0_y)
            z4 = (p2_z - p0_z)
            if (z4 is None):
                z4 = 0.
            if (y4 is None):
                y4 = 0.
            if (x4 is None):
                x4 = 0.
            d2_x = x4
            d2_y = y4
            d2_z = z4
            x5 = ((d1_y * d2_z) - ((d1_z * d2_y)))
            y5 = ((d1_z * d2_x) - ((d1_x * d2_z)))
            z5 = ((d1_x * d2_y) - ((d1_y * d2_x)))
            if (z5 is None):
                z5 = 0.
            if (y5 is None):
                y5 = 0.
            if (x5 is None):
                x5 = 0.
            n_x = x5
            n_y = y5
            n_z = z5
            d = (((n_x * p0_x) + ((n_y * p0_y))) + ((n_z * p0_z)))
            if ((((n_x * p_x) + ((n_y * p_y))) + ((n_z * p_z))) >= d):
                return False
        return True

    def inFrustum(self,f,m = None):
        raise haxe_Exception.thrown("Not implemented")

    def inSphere(self,s):
        raise haxe_Exception.thrown("Not implemented")

    def rayIntersection(self,r,bestMatch):
        i = self.startIndex
        x = r.lx
        y = r.ly
        z = r.lz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        rdir_x = x
        rdir_y = y
        rdir_z = z
        x = r.px
        y = r.py
        z = r.pz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        r0_x = x
        r0_y = y
        r0_z = z
        best = -1.
        _g = 0
        _g1 = self.triCount
        while (_g < _g1):
            t = _g
            _g = (_g + 1)
            index = i
            i = (i + 1)
            i0 = (self.indexes[index] * 3)
            index1 = i0
            i0 = (i0 + 1)
            x = python_Syntax._arrayAccess(self.buffer,[index1])
            index2 = i0
            i0 = (i0 + 1)
            y = python_Syntax._arrayAccess(self.buffer,[index2])
            z = python_Syntax._arrayAccess(self.buffer,[i0])
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p0_x = x
            p0_y = y
            p0_z = z
            index3 = i
            i = (i + 1)
            i1 = (self.indexes[index3] * 3)
            index4 = i1
            i1 = (i1 + 1)
            x1 = python_Syntax._arrayAccess(self.buffer,[index4])
            index5 = i1
            i1 = (i1 + 1)
            y1 = python_Syntax._arrayAccess(self.buffer,[index5])
            z1 = python_Syntax._arrayAccess(self.buffer,[i1])
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            p1_x = x1
            p1_y = y1
            p1_z = z1
            index6 = i
            i = (i + 1)
            i2 = (self.indexes[index6] * 3)
            index7 = i2
            i2 = (i2 + 1)
            x2 = python_Syntax._arrayAccess(self.buffer,[index7])
            index8 = i2
            i2 = (i2 + 1)
            y2 = python_Syntax._arrayAccess(self.buffer,[index8])
            z2 = python_Syntax._arrayAccess(self.buffer,[i2])
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            p2_x = x2
            p2_y = y2
            p2_z = z2
            x3 = (p1_x - p0_x)
            y3 = (p1_y - p0_y)
            z3 = (p1_z - p0_z)
            if (z3 is None):
                z3 = 0.
            if (y3 is None):
                y3 = 0.
            if (x3 is None):
                x3 = 0.
            e1_x = x3
            e1_y = y3
            e1_z = z3
            x4 = (p2_x - p0_x)
            y4 = (p2_y - p0_y)
            z4 = (p2_z - p0_z)
            if (z4 is None):
                z4 = 0.
            if (y4 is None):
                y4 = 0.
            if (x4 is None):
                x4 = 0.
            e2_x = x4
            e2_y = y4
            e2_z = z4
            x5 = ((rdir_y * e2_z) - ((rdir_z * e2_y)))
            y5 = ((rdir_z * e2_x) - ((rdir_x * e2_z)))
            z5 = ((rdir_x * e2_y) - ((rdir_y * e2_x)))
            if (z5 is None):
                z5 = 0.
            if (y5 is None):
                y5 = 0.
            if (x5 is None):
                x5 = 0.
            p_x = x5
            p_y = y5
            p_z = z5
            det = (((e1_x * p_x) + ((e1_y * p_y))) + ((e1_z * p_z)))
            if (det < 1e-10):
                continue
            invDet = (1 / det)
            x6 = (r0_x - p0_x)
            y6 = (r0_y - p0_y)
            z6 = (r0_z - p0_z)
            if (z6 is None):
                z6 = 0.
            if (y6 is None):
                y6 = 0.
            if (x6 is None):
                x6 = 0.
            T_x = x6
            T_y = y6
            T_z = z6
            u = (((((T_x * p_x) + ((T_y * p_y))) + ((T_z * p_z)))) * invDet)
            if ((u < 0) or ((u > 1))):
                continue
            x7 = ((T_y * e1_z) - ((T_z * e1_y)))
            y7 = ((T_z * e1_x) - ((T_x * e1_z)))
            z7 = ((T_x * e1_y) - ((T_y * e1_x)))
            if (z7 is None):
                z7 = 0.
            if (y7 is None):
                y7 = 0.
            if (x7 is None):
                x7 = 0.
            q_x = x7
            q_y = y7
            q_z = z7
            v = (((((rdir_x * q_x) + ((rdir_y * q_y))) + ((rdir_z * q_z)))) * invDet)
            if ((v < 0) or (((u + v) > 1))):
                continue
            t1 = (((((e2_x * q_x) + ((e2_y * q_y))) + ((e2_z * q_z)))) * invDet)
            if (t1 < 1e-10):
                continue
            if (not bestMatch):
                return t1
            if ((best < 0) or ((t1 < best))):
                best = t1
        return best

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.indexes = None
        _hx_o.startIndex = None
        _hx_o.triCount = None
        _hx_o.source = None
h3d_col_PolygonBuffer._hx_class = h3d_col_PolygonBuffer
_hx_classes["h3d.col.PolygonBuffer"] = h3d_col_PolygonBuffer


class h3d_col_SkinCollider:
    _hx_class_name = "h3d.col.SkinCollider"
    _hx_is_interface = "False"
    __slots__ = ("obj", "col", "currentBounds", "transform", "lastFrame", "lastBoundsFrame")
    _hx_fields = ["obj", "col", "currentBounds", "transform", "lastFrame", "lastBoundsFrame"]
    _hx_methods = ["contains", "inFrustum", "inSphere", "rayIntersection", "checkBounds", "applyTransform"]
    _hx_interfaces = [h3d_col_Collider, hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,obj,col):
        self.currentBounds = None
        self.lastBoundsFrame = -1
        self.lastFrame = -1
        self.obj = obj
        self.col = col
        self.transform = h3d_col_PolygonBuffer()
        tmp = self.transform
        this1 = col.buffer
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        tmp.setData(r,col.indexes,col.startIndex,col.triCount)
        self.currentBounds = h3d_col_Bounds()

    def contains(self,p):
        self.checkBounds()
        _this = self.currentBounds
        if (not (((((((p.x >= _this.xMin) and ((p.x < _this.xMax))) and ((p.y >= _this.yMin))) and ((p.y < _this.yMax))) and ((p.z >= _this.zMin))) and ((p.z < _this.zMax))))):
            return False
        self.applyTransform()
        return self.transform.contains(p)

    def inFrustum(self,p,m = None):
        self.checkBounds()
        _this = self.currentBounds
        if (m is not None):
            raise haxe_Exception.thrown("Not implemented")
        if (not p.hasBounds(_this)):
            return False
        if (m is not None):
            raise haxe_Exception.thrown("Not implemented")
        self.applyTransform()
        return self.transform.inFrustum(p)

    def inSphere(self,s):
        self.checkBounds()
        _this = self.currentBounds
        x = s.x
        y = s.y
        z = s.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        c_x = x
        c_y = y
        c_z = z
        a = _this.xMin
        a1 = s.x
        b = _this.xMax
        b1 = (b if ((a1 > b)) else a1)
        x = (b1 if ((a < b1)) else a)
        a = _this.yMin
        a1 = s.y
        b = _this.yMax
        b1 = (b if ((a1 > b)) else a1)
        y = (b1 if ((a < b1)) else a)
        a = _this.zMin
        a1 = s.z
        b = _this.zMax
        b1 = (b if ((a1 > b)) else a1)
        z = (b1 if ((a < b1)) else a)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        dx = (p_x - c_x)
        dy = (p_y - c_y)
        dz = (p_z - c_z)
        if (not (((((dx * dx) + ((dy * dy))) + ((dz * dz))) < ((s.r * s.r))))):
            return False
        self.applyTransform()
        raise haxe_Exception.thrown("Not implemented")

    def rayIntersection(self,r,bestMatch):
        self.checkBounds()
        if (self.currentBounds.rayIntersection(r,False) < 0):
            return -1.
        self.applyTransform()
        return self.transform.rayIntersection(r,bestMatch)

    def checkBounds(self):
        if ((not self.obj.jointsUpdated) and ((self.lastBoundsFrame == self.obj.lastFrame))):
            return
        self.lastBoundsFrame = self.obj.lastFrame
        self.obj.syncJoints()
        _this = self.currentBounds
        _this.xMin = 1e20
        _this.xMax = -1e20
        _this.yMin = 1e20
        _this.yMax = -1e20
        _this.zMin = 1e20
        _this.zMax = -1e20
        self.obj.getBoundsRec(self.currentBounds)

    def applyTransform(self):
        if ((not self.obj.jointsUpdated) and ((self.lastFrame == self.obj.lastFrame))):
            return
        self.lastFrame = self.obj.lastFrame
        self.obj.syncJoints()
        j = 0
        v = 0
        nbones = self.obj.skinData.bonesPerVertex
        _g = 0
        _g1 = self.obj.skinData.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            px = 0.
            py = 0.
            pz = 0.
            x = python_Syntax._arrayAccess(self.col.buffer,[v])
            y = python_Syntax._arrayAccess(self.col.buffer,[(v + 1)])
            z = python_Syntax._arrayAccess(self.col.buffer,[(v + 2)])
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p_x = x
            p_y = y
            p_z = z
            _g2 = 0
            _g3 = nbones
            while (_g2 < _g3):
                k = _g2
                _g2 = (_g2 + 1)
                w = self.obj.skinData.vertexWeights[j]
                if (w == 0):
                    j = (j + 1)
                    continue
                index = j
                j = (j + 1)
                bid = self.obj.skinData.vertexJoints[index]
                x1 = p_x
                y1 = p_y
                z1 = p_z
                if (z1 is None):
                    z1 = 0.
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                p2_x = x1
                p2_y = y1
                p2_z = z1
                m = python_internal_ArrayImpl._get(self.obj.currentPalette, bid)
                px1 = ((((p2_x * m._11) + ((p2_y * m._21))) + ((p2_z * m._31))) + m._41)
                py1 = ((((p2_x * m._12) + ((p2_y * m._22))) + ((p2_z * m._32))) + m._42)
                pz1 = ((((p2_x * m._13) + ((p2_y * m._23))) + ((p2_z * m._33))) + m._43)
                p2_x = px1
                p2_y = py1
                p2_z = pz1
                px = (px + ((p2_x * w)))
                py = (py + ((p2_y * w)))
                pz = (pz + ((p2_z * w)))
            index1 = v
            v = (v + 1)
            self.transform.buffer[index1] = px
            index2 = v
            v = (v + 1)
            self.transform.buffer[index2] = py
            index3 = v
            v = (v + 1)
            self.transform.buffer[index3] = pz

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.col = None
        _hx_o.currentBounds = None
        _hx_o.transform = None
        _hx_o.lastFrame = None
        _hx_o.lastBoundsFrame = None
h3d_col_SkinCollider._hx_class = h3d_col_SkinCollider
_hx_classes["h3d.col.SkinCollider"] = h3d_col_SkinCollider


class h3d_col_Sphere:
    _hx_class_name = "h3d.col.Sphere"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "r")
    _hx_fields = ["x", "y", "z", "r"]
    _hx_methods = ["load", "getCenter", "distance", "distanceSq", "contains", "rayIntersection", "inFrustum", "inFrustumMatrix", "inSphere", "toString"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self,x = None,y = None,z = None,r = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (r is None):
            r = 0.
        sx = x
        sy = y
        sz = z
        sr = r
        if (sr is None):
            sr = 0.
        if (sz is None):
            sz = 0.
        if (sy is None):
            sy = 0.
        if (sx is None):
            sx = 0.
        self.x = sx
        self.y = sy
        self.z = sz
        self.r = sr

    def load(self,sx = None,sy = None,sz = None,sr = None):
        if (sx is None):
            sx = 0.
        if (sy is None):
            sy = 0.
        if (sz is None):
            sz = 0.
        if (sr is None):
            sr = 0.
        self.x = sx
        self.y = sy
        self.z = sz
        self.r = sr

    def getCenter(self):
        return h3d_col_Point(self.x,self.y,self.z)

    def distance(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        dz = (p.z - self.z)
        d = ((((dx * dx) + ((dy * dy))) + ((dz * dz))) - ((self.r * self.r)))
        if (d < 0):
            v = -d
            return -((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v)))
        elif (d < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(d)

    def distanceSq(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        dz = (p.z - self.z)
        return ((((dx * dx) + ((dy * dy))) + ((dz * dz))) - ((self.r * self.r)))

    def contains(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        dz = (p.z - self.z)
        return (((((dx * dx) + ((dy * dy))) + ((dz * dz))) - ((self.r * self.r))) < 0)

    def rayIntersection(self,r,bestMatch):
        r2 = (self.r * self.r)
        px = (r.px + r.lx)
        py = (r.py + r.ly)
        pz = (r.pz + r.lz)
        a = (((r.lx * r.lx) + ((r.ly * r.ly))) + ((r.lz * r.lz)))
        b = ((((2 * r.lx) * ((self.x - px))) + (((2 * r.ly) * ((self.y - py))))) + (((2 * r.lz) * ((self.z - pz)))))
        c = ((((((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z))) + ((((px * px) + ((py * py))) + ((pz * pz))))) - ((2 * ((((self.x * px) + ((self.y * py))) + ((self.z * pz))))))) - r2)
        d = ((b * b) - (((4 * a) * c)))
        if (d < 0):
            return -1
        d = (Math.NaN if ((d < 0)) else python_lib_Math.sqrt(d))
        t = (((-b + d)) / ((2 * a)))
        return (1 - t)

    def inFrustum(self,f,m = None):
        if (m is not None):
            return self.inFrustumMatrix(f,m)
        return f.hasSphere(self)

    def inFrustumMatrix(self,f,m):
        oldX = self.x
        oldY = self.y
        oldZ = self.z
        oldR = self.r
        x = self.x
        y = self.y
        z = self.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        self.x = v_x
        self.y = v_y
        self.z = v_z
        v = None
        if (v is None):
            v = h3d_Vector()
        f1 = (((m._11 * m._11) + ((m._12 * m._12))) + ((m._13 * m._13)))
        v.x = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        f1 = (((m._21 * m._21) + ((m._22 * m._22))) + ((m._23 * m._23)))
        v.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        f1 = (((m._31 * m._31) + ((m._32 * m._32))) + ((m._33 * m._33)))
        v.z = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        if ((((m._11 * (((m._22 * m._33) - ((m._23 * m._32))))) + ((m._12 * (((m._23 * m._31) - ((m._21 * m._33))))))) + ((m._13 * (((m._21 * m._32) - ((m._22 * m._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        scale = v
        tmp = self
        tmp1 = tmp.r
        a = scale.x
        b = scale.y
        a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        b = scale.z
        tmp.r = (tmp1 * ((a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else max(a1,b)))))
        res = f.hasSphere(self)
        self.x = oldX
        self.y = oldY
        self.z = oldZ
        self.r = oldR
        return res

    def inSphere(self,s):
        x = self.x
        y = self.y
        z = self.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this_x = x
        _this_y = y
        _this_z = z
        x = s.x
        y = s.y
        z = s.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        dx = (p_x - _this_x)
        dy = (p_y - _this_y)
        dz = (p_z - _this_z)
        return ((((dx * dx) + ((dy * dy))) + ((dz * dz))) < ((((s.r + self.r)) * ((s.r + self.r)))))

    def toString(self):
        return (((("Sphere{" + Std.string(h3d_col_Point(self.x,self.y,self.z))) + ",") + Std.string(hxd_Math.fmt(self.r))) + "}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.r = None
h3d_col_Sphere._hx_class = h3d_col_Sphere
_hx_classes["h3d.col.Sphere"] = h3d_col_Sphere

class h3d_impl_Feature(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.impl.Feature"
    _hx_constructs = ["StandardDerivatives", "FloatTextures", "AllocDepthBuffer", "HardwareAccelerated", "MultipleRenderTargets", "Queries", "SRGBTextures", "ShaderModel3", "BottomLeftCoords", "Wireframe", "InstancedRendering"]
h3d_impl_Feature.StandardDerivatives = h3d_impl_Feature("StandardDerivatives", 0, ())
h3d_impl_Feature.FloatTextures = h3d_impl_Feature("FloatTextures", 1, ())
h3d_impl_Feature.AllocDepthBuffer = h3d_impl_Feature("AllocDepthBuffer", 2, ())
h3d_impl_Feature.HardwareAccelerated = h3d_impl_Feature("HardwareAccelerated", 3, ())
h3d_impl_Feature.MultipleRenderTargets = h3d_impl_Feature("MultipleRenderTargets", 4, ())
h3d_impl_Feature.Queries = h3d_impl_Feature("Queries", 5, ())
h3d_impl_Feature.SRGBTextures = h3d_impl_Feature("SRGBTextures", 6, ())
h3d_impl_Feature.ShaderModel3 = h3d_impl_Feature("ShaderModel3", 7, ())
h3d_impl_Feature.BottomLeftCoords = h3d_impl_Feature("BottomLeftCoords", 8, ())
h3d_impl_Feature.Wireframe = h3d_impl_Feature("Wireframe", 9, ())
h3d_impl_Feature.InstancedRendering = h3d_impl_Feature("InstancedRendering", 10, ())
h3d_impl_Feature._hx_class = h3d_impl_Feature
_hx_classes["h3d.impl.Feature"] = h3d_impl_Feature

class h3d_impl_QueryKind(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.impl.QueryKind"
    _hx_constructs = ["TimeStamp", "Samples"]
h3d_impl_QueryKind.TimeStamp = h3d_impl_QueryKind("TimeStamp", 0, ())
h3d_impl_QueryKind.Samples = h3d_impl_QueryKind("Samples", 1, ())
h3d_impl_QueryKind._hx_class = h3d_impl_QueryKind
_hx_classes["h3d.impl.QueryKind"] = h3d_impl_QueryKind

class h3d_impl_RenderFlag(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.impl.RenderFlag"
    _hx_constructs = ["CameraHandness"]
h3d_impl_RenderFlag.CameraHandness = h3d_impl_RenderFlag("CameraHandness", 0, ())
h3d_impl_RenderFlag._hx_class = h3d_impl_RenderFlag
_hx_classes["h3d.impl.RenderFlag"] = h3d_impl_RenderFlag


class h3d_impl_InputNames:
    _hx_class_name = "h3d.impl.InputNames"
    _hx_is_interface = "False"
    __slots__ = ("id", "names")
    _hx_fields = ["id", "names"]
    _hx_statics = ["UID", "CACHE", "get"]

    def __init__(self,names):
        def _hx_local_2():
            _hx_local_0 = h3d_impl_InputNames
            _hx_local_1 = _hx_local_0.UID
            _hx_local_0.UID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()
        self.names = names

    @staticmethod
    def get(names):
        key = "|".join([python_Boot.toString1(x1,'') for x1 in names])
        i = h3d_impl_InputNames.CACHE.h.get(key,None)
        if (i is None):
            i = h3d_impl_InputNames(list(names))
            h3d_impl_InputNames.CACHE.h[key] = i
        return i

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.names = None
h3d_impl_InputNames._hx_class = h3d_impl_InputNames
_hx_classes["h3d.impl.InputNames"] = h3d_impl_InputNames


class h3d_impl_Driver:
    _hx_class_name = "h3d.impl.Driver"
    _hx_is_interface = "False"
    __slots__ = ("logEnable",)
    _hx_fields = ["logEnable"]
    _hx_methods = ["hasFeature", "setRenderFlag", "isSupportedFormat", "isDisposed", "dispose", "begin", "log", "generateMipMaps", "getNativeShaderCode", "logImpl", "clear", "captureRenderBuffer", "capturePixels", "getDriverName", "init", "resize", "selectShader", "selectMaterial", "uploadShaderBuffers", "getShaderInputNames", "selectBuffer", "selectMultiBuffers", "draw", "drawInstanced", "setRenderZone", "setRenderTarget", "setRenderTargets", "allocDepthBuffer", "disposeDepthBuffer", "getDefaultDepthBuffer", "present", "end", "setDebug", "allocTexture", "allocIndexes", "allocVertexes", "allocInstanceBuffer", "disposeTexture", "disposeIndexes", "disposeVertexes", "disposeInstanceBuffer", "uploadIndexBuffer", "uploadIndexBytes", "uploadVertexBuffer", "uploadVertexBytes", "uploadTextureBitmap", "uploadTexturePixels", "readVertexBytes", "readIndexBytes", "copyTexture", "allocQuery", "deleteQuery", "beginQuery", "endQuery", "queryResultAvailable", "queryResult"]

    def hasFeature(self,f):
        return False

    def setRenderFlag(self,r,value):
        pass

    def isSupportedFormat(self,fmt):
        return False

    def isDisposed(self):
        return True

    def dispose(self):
        pass

    def begin(self,frame):
        pass

    def log(self,_hx_str):
        pass

    def generateMipMaps(self,texture):
        raise haxe_Exception.thrown("Mipmaps auto generation is not supported on this platform")

    def getNativeShaderCode(self,shader):
        return None

    def logImpl(self,_hx_str):
        pass

    def clear(self,color = None,depth = None,stencil = None):
        pass

    def captureRenderBuffer(self,pixels):
        pass

    def capturePixels(self,tex,layer,mipLevel,region = None):
        raise haxe_Exception.thrown("Can't capture pixels on this platform")

    def getDriverName(self,details):
        return "Not available"

    def init(self,onCreate,forceSoftware = None):
        if (forceSoftware is None):
            forceSoftware = False

    def resize(self,width,height):
        pass

    def selectShader(self,shader):
        return False

    def selectMaterial(self,_hx_pass):
        pass

    def uploadShaderBuffers(self,buffers,which):
        pass

    def getShaderInputNames(self):
        return None

    def selectBuffer(self,buffer):
        pass

    def selectMultiBuffers(self,buffers):
        pass

    def draw(self,ibuf,startIndex,ntriangles):
        pass

    def drawInstanced(self,ibuf,commands):
        pass

    def setRenderZone(self,x,y,width,height):
        pass

    def setRenderTarget(self,tex,layer = None,mipLevel = None):
        if (layer is None):
            layer = 0
        if (mipLevel is None):
            mipLevel = 0

    def setRenderTargets(self,textures):
        pass

    def allocDepthBuffer(self,b):
        return None

    def disposeDepthBuffer(self,b):
        pass

    def getDefaultDepthBuffer(self):
        return None

    def present(self):
        pass

    def end(self):
        pass

    def setDebug(self,b):
        pass

    def allocTexture(self,t):
        return None

    def allocIndexes(self,count,is32):
        return None

    def allocVertexes(self,m):
        return None

    def allocInstanceBuffer(self,b,_hx_bytes):
        pass

    def disposeTexture(self,t):
        pass

    def disposeIndexes(self,i):
        pass

    def disposeVertexes(self,v):
        pass

    def disposeInstanceBuffer(self,b):
        pass

    def uploadIndexBuffer(self,i,startIndice,indiceCount,buf,bufPos):
        pass

    def uploadIndexBytes(self,i,startIndice,indiceCount,buf,bufPos):
        pass

    def uploadVertexBuffer(self,v,startVertex,vertexCount,buf,bufPos):
        pass

    def uploadVertexBytes(self,v,startVertex,vertexCount,buf,bufPos):
        pass

    def uploadTextureBitmap(self,t,bmp,mipLevel,side):
        pass

    def uploadTexturePixels(self,t,pixels,mipLevel,side):
        pass

    def readVertexBytes(self,v,startVertex,vertexCount,buf,bufPos):
        raise haxe_Exception.thrown("Driver does not allow to read vertex bytes")

    def readIndexBytes(self,v,startVertex,vertexCount,buf,bufPos):
        raise haxe_Exception.thrown("Driver does not allow to read index bytes")

    def copyTexture(self,_hx_from,to):
        return False

    def allocQuery(self,queryKind):
        return None

    def deleteQuery(self,q):
        pass

    def beginQuery(self,q):
        pass

    def endQuery(self,q):
        pass

    def queryResultAvailable(self,q):
        return True

    def queryResult(self,q):
        return 0.

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.logEnable = None
h3d_impl_Driver._hx_class = h3d_impl_Driver
_hx_classes["h3d.impl.Driver"] = h3d_impl_Driver


class h3d_impl_InstanceBuffer:
    _hx_class_name = "h3d.impl.InstanceBuffer"
    _hx_is_interface = "False"
    __slots__ = ("data", "driver", "indexCount", "triCount", "commandCount")
    _hx_fields = ["data", "driver", "indexCount", "triCount", "commandCount"]
    _hx_methods = ["setCommand", "setBuffer", "dispose"]

    def __init__(self):
        self.commandCount = None
        self.driver = None
        self.data = None
        self.triCount = 0
        self.indexCount = 0

    def setCommand(self,commandCount,indexCount):
        self.commandCount = commandCount
        self.indexCount = indexCount
        tmp = None
        try:
            tmp = int(((commandCount * indexCount) / 3))
        except BaseException as _g:
            None
            tmp = None
        self.triCount = tmp

    def setBuffer(self,commandCount,_hx_bytes):
        self.dispose()
        _g = 0
        _g1 = commandCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i * 20)
            v = (((_hx_bytes.b[pos] | ((_hx_bytes.b[(pos + 1)] << 8))) | ((_hx_bytes.b[(pos + 2)] << 16))) | ((_hx_bytes.b[(pos + 3)] << 24)))
            idxCount = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            pos1 = ((i * 20) + 4)
            v1 = (((_hx_bytes.b[pos1] | ((_hx_bytes.b[(pos1 + 1)] << 8))) | ((_hx_bytes.b[(pos1 + 2)] << 16))) | ((_hx_bytes.b[(pos1 + 3)] << 24)))
            instCount = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
            tri = None
            try:
                tri = int(((idxCount * instCount) / 3))
            except BaseException as _g2:
                None
                tri = None
            tri1 = tri
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.triCount
            _hx_local_0.triCount = (_hx_local_1 + tri1)
            _hx_local_0.triCount
        self.commandCount = commandCount
        self.indexCount = 0
        self.driver = h3d_Engine.CURRENT.driver
        self.driver.allocInstanceBuffer(self,_hx_bytes)

    def dispose(self):
        if (self.data is not None):
            self.driver.disposeInstanceBuffer(self)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
        _hx_o.driver = None
        _hx_o.indexCount = None
        _hx_o.triCount = None
        _hx_o.commandCount = None
h3d_impl_InstanceBuffer._hx_class = h3d_impl_InstanceBuffer
_hx_classes["h3d.impl.InstanceBuffer"] = h3d_impl_InstanceBuffer


class h3d_impl_LogDriver(h3d_impl_Driver):
    _hx_class_name = "h3d.impl.LogDriver"
    _hx_is_interface = "False"
    __slots__ = ("d", "loggedShaders", "currentShader", "logLines")
    _hx_fields = ["d", "loggedShaders", "currentShader", "logLines"]
    _hx_methods = ["logImpl", "hasFeature", "isSupportedFormat", "isDisposed", "dispose", "begin", "clear", "captureRenderBuffer", "getDriverName", "init", "resize", "selectShader", "getNativeShaderCode", "selectMaterial", "sizeOf", "uploadShaderBuffers", "textureInfos", "getShaderInputNames", "selectBuffer", "selectMultiBuffers", "draw", "setRenderZone", "setRenderTarget", "setRenderTargets", "end", "present", "setDebug", "allocTexture", "allocIndexes", "allocVertexes", "disposeTexture", "disposeIndexes", "disposeVertexes", "uploadIndexBuffer", "uploadIndexBytes", "uploadVertexBuffer", "uploadVertexBytes", "uploadTextureBitmap", "uploadTexturePixels"]
    _hx_statics = ["debug"]
    _hx_interfaces = []
    _hx_super = h3d_impl_Driver


    def __init__(self,driver):
        self.currentShader = None
        self.logLines = None
        self.loggedShaders = haxe_ds_IntMap()
        self.d = driver
        self.logEnable = True
        driver.logEnable = True

    def logImpl(self,_hx_str):
        if (self.logLines is None):
            self.d.logImpl(_hx_str)
        else:
            _this = self.logLines
            _this.append(_hx_str)

    def hasFeature(self,f):
        return self.d.hasFeature(f)

    def isSupportedFormat(self,fmt):
        return self.d.isSupportedFormat(fmt)

    def isDisposed(self):
        return self.d.isDisposed()

    def dispose(self):
        self.d.dispose()

    def begin(self,frame):
        self.d.begin(frame)

    def clear(self,color = None,depth = None,stencil = None):
        _hx_str = ((((("Clear color=" + Std.string(color)) + " depth=") + Std.string(depth)) + " stencil=") + Std.string(stencil))
        self.d.clear(color,depth,stencil)

    def captureRenderBuffer(self,pixels):
        self.d.captureRenderBuffer(pixels)

    def getDriverName(self,details):
        return self.d.getDriverName(details)

    def init(self,onCreate,forceSoftware = None):
        if (forceSoftware is None):
            forceSoftware = False
        _gthis = self
        def _hx_local_0(b):
            _hx_str = ("OnCreate " + Std.string(b))
            onCreate(b)
        self.d.init(_hx_local_0,forceSoftware)

    def resize(self,width,height):
        self.d.resize(width,height)

    def selectShader(self,shader):
        self.currentShader = shader
        ret = self.d.selectShader(shader)
        if (not self.loggedShaders.h.get(shader.id,None)):
            def _hx_local_8(shader):
                _hx_str = hxsl_Printer.shaderToString(shader.data)
                def _hx_local_2(r):
                    name = None
                    cid = (Std.parseInt(r.matchObj.group(4)) << 2)
                    swiz = r.matchObj.group(5)
                    if (swiz is not None):
                        d = (HxString.charCodeAt(swiz,1) - 120)
                        cid = (cid + d)
                        _g = []
                        _g1 = 1
                        _g2 = len(swiz)
                        while (_g1 < _g2):
                            i = _g1
                            _g1 = (_g1 + 1)
                            code = (HxString.charCodeAt(swiz,i) - d)
                            x = "".join(map(chr,[code]))
                            _g.append(x)
                        swiz = ("." + HxOverrides.stringOrNull("".join([python_Boot.toString1(x1,'') for x1 in _g])))
                    g = shader.globals
                    while (g is not None):
                        _hx_str = None
                        if ((g.path == "__consts__") and ((cid >= g.pos))):
                            _g = g.type
                            str1 = None
                            if (_g.index == 15):
                                _g1 = _g.params[1]
                                if (_g.params[0].index == 3):
                                    if (_g1.index == 0):
                                        n = _g1.params[0]
                                        str1 = n
                                    else:
                                        str1 = 0
                                else:
                                    str1 = 0
                            else:
                                str1 = 0
                            _hx_str = (cid < ((g.pos + str1)))
                        else:
                            _hx_str = False
                        if (_hx_str and ((swiz == ".x"))):
                            swiz = None
                            name = ("" + Std.string(python_internal_ArrayImpl._get(shader.consts, (cid - g.pos))))
                            break
                        if (g.pos == cid):
                            name = g.path
                            break
                        g = g.next
                    if (name is None):
                        return r.matchObj.group(0)
                    if (swiz is not None):
                        name = (("null" if name is None else name) + ("null" if swiz is None else swiz))
                    return name
                _hx_str = EReg("((fragment)|(vertex))Globals\\[([0-9]+)\\](.[xyz]+)?","g").map(_hx_str,_hx_local_2)
                def _hx_local_5(r):
                    name = None
                    cid = (Std.parseInt(r.matchObj.group(4)) << 2)
                    swiz = r.matchObj.group(5)
                    if (swiz is not None):
                        d = (HxString.charCodeAt(swiz,1) - 120)
                        cid = (cid + d)
                        _g = []
                        _g1 = 1
                        _g2 = len(swiz)
                        while (_g1 < _g2):
                            i = _g1
                            _g1 = (_g1 + 1)
                            code = (HxString.charCodeAt(swiz,i) - d)
                            x = "".join(map(chr,[code]))
                            _g.append(x)
                        swiz = ("." + HxOverrides.stringOrNull("".join([python_Boot.toString1(x1,'') for x1 in _g])))
                    p = shader.params
                    while (p is not None):
                        if (p.pos == cid):
                            name = p.name
                            break
                        p = p.next
                    if (name is None):
                        return r.matchObj.group(0)
                    if (swiz is not None):
                        name = (("null" if name is None else name) + ("null" if swiz is None else swiz))
                    return name
                _hx_str = EReg("((fragment)|(vertex))Params\\[([0-9]+)\\](.[xyz]+)?","g").map(_hx_str,_hx_local_5)
                def _hx_local_6(r):
                    name = None
                    cid = Std.parseInt(r.matchObj.group(4))
                    t = shader.textures
                    while (t is not None):
                        if ((t.pos == cid) and ((t.type == hxsl_Type.TSampler2D))):
                            return t.name
                        t = t.next
                    return r.matchObj.group(0)
                _hx_str = EReg("((fragment)|(vertex))Textures\\[([0-9]+)\\]","g").map(_hx_str,_hx_local_6)
                def _hx_local_7(r):
                    name = None
                    cid = Std.parseInt(r.matchObj.group(4))
                    t = shader.textures
                    while (t is not None):
                        if ((t.pos == cid) and ((t.type == hxsl_Type.TSamplerCube))):
                            return t.name
                        t = t.next
                    return r.matchObj.group(0)
                _hx_str = EReg("((fragment)|(vertex))TexturesCube\\[([0-9]+)\\]","g").map(_hx_str,_hx_local_7)
                return _hx_str
            fmt = _hx_local_8
            _hx_str = ((HxOverrides.stringOrNull(fmt(shader.vertex)) + "\n") + HxOverrides.stringOrNull(fmt(shader.fragment)))
            _this = _hx_str.split("\n")
            _hx_str = ("\t" + HxOverrides.stringOrNull("\n\t".join([python_Boot.toString1(x1,'') for x1 in _this])))
            _hx_str = self.getNativeShaderCode(shader)
            if (_hx_str is not None):
                _this = _hx_str.split("\n")
                _hx_str = ("\t" + HxOverrides.stringOrNull("\n\t".join([python_Boot.toString1(x1,'') for x1 in _this])))
            self.loggedShaders.set(shader.id,True)
        return ret

    def getNativeShaderCode(self,shader):
        return self.d.getNativeShaderCode(shader)

    def selectMaterial(self,_hx_pass):
        _hx_str = (((((((((("Select Material Cull=" + Std.string(_hx_pass.culling)) + " depth=") + Std.string(_hx_pass.depthTest)) + HxOverrides.stringOrNull((("" if (_hx_pass.depthWrite) else " nowrite")))) + " blend=") + Std.string(_hx_pass.blendSrc)) + ",") + Std.string(_hx_pass.blendDst)) + " color=") + Std.string(_hx_pass.colorMask))
        self.d.selectMaterial(_hx_pass)

    def sizeOf(self,t):
        tmp = t.index
        if (tmp == 0):
            return 0
        elif ((tmp == 3) or ((tmp == 1))):
            return 1
        elif (tmp == 5):
            _g = t.params[1]
            n = t.params[0]
            return n
        elif (tmp == 6):
            return 9
        elif (tmp == 7):
            return 16
        elif (tmp == 8):
            return 12
        elif (tmp == 15):
            _g = t.params[1]
            if (_g.index == 0):
                n = _g.params[0]
                t1 = t.params[0]
                return (self.sizeOf(t1) * n)
            else:
                raise haxe_Exception.thrown(("assert " + Std.string(t)))
        else:
            raise haxe_Exception.thrown(("assert " + Std.string(t)))

    def uploadShaderBuffers(self,buffers,which):
        _gthis = self
        which1 = which
        if (which1 == 0):
            s = self.currentShader.vertex
            buf = buffers.vertex
            if (s.globalsSize != 0):
                g = s.globals
                while (g is not None):
                    _hx_str = (((("\t@" + Std.string(g.pos)) + " ") + HxOverrides.stringOrNull(g.path)) + "=")
                    _g = []
                    _g1 = 0
                    _g2 = _gthis.sizeOf(g.type)
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        x = hxd_Math.fmt(buf.globals[(g.pos + i)])
                        _g.append(x)
                    str1 = (("null" if _hx_str is None else _hx_str) + Std.string(_g))
                    g = g.next
            s = self.currentShader.fragment
            buf = buffers.fragment
            if (s.globalsSize != 0):
                g = s.globals
                while (g is not None):
                    _hx_str = (((("\t@" + Std.string(g.pos)) + " ") + HxOverrides.stringOrNull(g.path)) + "=")
                    _g = []
                    _g1 = 0
                    _g2 = _gthis.sizeOf(g.type)
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        x = hxd_Math.fmt(buf.globals[(g.pos + i)])
                        _g.append(x)
                    str1 = (("null" if _hx_str is None else _hx_str) + Std.string(_g))
                    g = g.next
        elif (which1 == 1):
            s = self.currentShader.vertex
            buf = buffers.vertex
            if (s.paramsSize != 0):
                p = s.params
                while (p is not None):
                    pos = p.pos
                    _hx_str = (((("\t@" + Std.string(pos)) + " ") + HxOverrides.stringOrNull(p.name)) + "=")
                    _g = []
                    _g1 = 0
                    _g2 = _gthis.sizeOf(p.type)
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        x = hxd_Math.fmt(buf.params[(p.pos + i)])
                        _g.append(x)
                    str1 = (("null" if _hx_str is None else _hx_str) + Std.string(_g))
                    p = p.next
            s = self.currentShader.fragment
            buf = buffers.fragment
            if (s.paramsSize != 0):
                p = s.params
                while (p is not None):
                    pos = p.pos
                    _hx_str = (((("\t@" + Std.string(pos)) + " ") + HxOverrides.stringOrNull(p.name)) + "=")
                    _g = []
                    _g1 = 0
                    _g2 = _gthis.sizeOf(p.type)
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        x = hxd_Math.fmt(buf.params[(p.pos + i)])
                        _g.append(x)
                    str1 = (("null" if _hx_str is None else _hx_str) + Std.string(_g))
                    p = p.next
        elif (which1 == 2):
            s = self.currentShader.vertex
            buf = buffers.vertex
            t = s.textures
            while (t is not None):
                _hx_str = ((((((("Set " + HxOverrides.stringOrNull((("Vertex" if (s.vertex) else "Fragment")))) + " Texture@") + Std.string(t.pos)) + " ") + HxOverrides.stringOrNull(t.name)) + "=") + HxOverrides.stringOrNull(_gthis.textureInfos(buf.tex,t.pos)))
                t = t.next
            s = self.currentShader.fragment
            buf = buffers.fragment
            t = s.textures
            while (t is not None):
                _hx_str = ((((((("Set " + HxOverrides.stringOrNull((("Vertex" if (s.vertex) else "Fragment")))) + " Texture@") + Std.string(t.pos)) + " ") + HxOverrides.stringOrNull(t.name)) + "=") + HxOverrides.stringOrNull(_gthis.textureInfos(buf.tex,t.pos)))
                t = t.next
        elif (which1 == 3):
            pass
        else:
            pass
        self.d.uploadShaderBuffers(buffers,which)

    def textureInfos(self,buf,tid):
        if ((tid < 0) or ((tid >= len(buf)))):
            return "OUT OF BOUNDS"
        t = buf[tid]
        if (t is None):
            return "NULL"
        inf = ("" + Std.string(t))
        if (t.wrap != h3d_mat_Wrap.Clamp):
            inf = (("null" if inf is None else inf) + ((" wrap=" + Std.string(t.wrap))))
        if (t.mipMap != h3d_mat_MipMap._hx_None):
            inf = (("null" if inf is None else inf) + ((" mip=" + Std.string(t.mipMap))))
        return inf

    def getShaderInputNames(self):
        return self.d.getShaderInputNames()

    def selectBuffer(self,buffer):
        self.d.selectBuffer(buffer)

    def selectMultiBuffers(self,buffers):
        self.d.selectMultiBuffers(buffers)

    def draw(self,ibuf,startIndex,ntriangles):
        self.d.draw(ibuf,startIndex,ntriangles)

    def setRenderZone(self,x,y,width,height):
        self.d.setRenderZone(x,y,width,height)

    def setRenderTarget(self,tex,face = None,mipMap = None):
        if (face is None):
            face = 0
        if (mipMap is None):
            mipMap = 0
        _hx_str = ((((("SetRenderTarget " + Std.string(tex)) + " ") + Std.string(face)) + " ") + Std.string(mipMap))
        self.d.setRenderTarget(tex,face)

    def setRenderTargets(self,textures):
        _hx_str = ("SetRenderTargets " + Std.string(textures))
        self.d.setRenderTargets(textures)

    def end(self):
        self.d.end()

    def present(self):
        self.d.present()

    def setDebug(self,b):
        _hx_str = ("SetDebug " + Std.string(b))
        self.d.setDebug(b)

    def allocTexture(self,t):
        _hx_str = ("AllocTexture " + Std.string(t))
        return self.d.allocTexture(t)

    def allocIndexes(self,count,is32):
        _hx_str = ((("AllocIndexes " + Std.string(count)) + " ") + Std.string(is32))
        return self.d.allocIndexes(count,is32)

    def allocVertexes(self,m):
        return self.d.allocVertexes(m)

    def disposeTexture(self,t):
        self.d.disposeTexture(t)

    def disposeIndexes(self,i):
        self.d.disposeIndexes(i)

    def disposeVertexes(self,v):
        self.d.disposeVertexes(v)

    def uploadIndexBuffer(self,i,startIndice,indiceCount,buf,bufPos):
        self.d.uploadIndexBuffer(i,startIndice,indiceCount,buf,bufPos)

    def uploadIndexBytes(self,i,startIndice,indiceCount,buf,bufPos):
        self.d.uploadIndexBytes(i,startIndice,indiceCount,buf,bufPos)

    def uploadVertexBuffer(self,v,startVertex,vertexCount,buf,bufPos):
        self.d.uploadVertexBuffer(v,startVertex,vertexCount,buf,bufPos)

    def uploadVertexBytes(self,v,startVertex,vertexCount,buf,bufPos):
        self.d.uploadVertexBytes(v,startVertex,vertexCount,buf,bufPos)

    def uploadTextureBitmap(self,t,bmp,mipLevel,side):
        _hx_str = ((((("UploadTextureBitmap " + Std.string(t)) + " mip=") + Std.string(mipLevel)) + " side=") + Std.string(side))
        self.d.uploadTextureBitmap(t,bmp,mipLevel,side)

    def uploadTexturePixels(self,t,pixels,mipLevel,side):
        _hx_str = ((((("UploadTexturePixels " + Std.string(t)) + " mip=") + Std.string(mipLevel)) + " side=") + Std.string(side))
        self.d.uploadTexturePixels(t,pixels,mipLevel,side)

    @staticmethod
    def debug(f):
        raise haxe_Exception.thrown("Requires -debug")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.d = None
        _hx_o.loggedShaders = None
        _hx_o.currentShader = None
        _hx_o.logLines = None
h3d_impl_LogDriver._hx_class = h3d_impl_LogDriver
_hx_classes["h3d.impl.LogDriver"] = h3d_impl_LogDriver


class h3d_impl__ManagedBuffer_FreeCell:
    _hx_class_name = "h3d.impl._ManagedBuffer.FreeCell"
    _hx_is_interface = "False"
    __slots__ = ("pos", "count", "next")
    _hx_fields = ["pos", "count", "next"]

    def __init__(self,pos,count,next):
        self.pos = pos
        self.count = count
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pos = None
        _hx_o.count = None
        _hx_o.next = None
h3d_impl__ManagedBuffer_FreeCell._hx_class = h3d_impl__ManagedBuffer_FreeCell
_hx_classes["h3d.impl._ManagedBuffer.FreeCell"] = h3d_impl__ManagedBuffer_FreeCell


class h3d_impl_ManagedBuffer:
    _hx_class_name = "h3d.impl.ManagedBuffer"
    _hx_is_interface = "False"
    __slots__ = ("mem", "stride", "size", "flags", "vbuf", "freeList", "next")
    _hx_fields = ["mem", "stride", "size", "flags", "vbuf", "freeList", "next"]
    _hx_methods = ["uploadVertexBuffer", "uploadVertexBytes", "readVertexBytes", "alloc", "getFreeVertices", "allocPosition", "allocBuffer", "freeBuffer", "dispose", "isDisposed"]

    def __init__(self,stride,size,flags = None):
        self.next = None
        self.vbuf = None
        this1 = 0
        self.flags = this1
        if (flags is not None):
            _g = 0
            while (_g < len(flags)):
                f = (flags[_g] if _g >= 0 and _g < len(flags) else None)
                _g = (_g + 1)
                _hx_local_1 = self
                _hx_local_2 = _hx_local_1.flags
                _hx_local_1.flags = (_hx_local_2 | ((1 << f.index)))
                _hx_local_1.flags
        self.size = size
        self.stride = stride
        self.freeList = h3d_impl__ManagedBuffer_FreeCell(0,size,None)
        self.mem = h3d_Engine.CURRENT.mem
        self.mem.allocManaged(self)

    def uploadVertexBuffer(self,start,vertices,buf,bufPos = None):
        if (bufPos is None):
            bufPos = 0
        self.mem.driver.uploadVertexBuffer(self.vbuf,start,vertices,buf,bufPos)

    def uploadVertexBytes(self,start,vertices,data,dataPos = None):
        if (dataPos is None):
            dataPos = 0
        self.mem.driver.uploadVertexBytes(self.vbuf,start,vertices,data,dataPos)

    def readVertexBytes(self,start,vertices,data,dataPos = None):
        if (dataPos is None):
            dataPos = 0
        self.mem.driver.readVertexBytes(self.vbuf,start,vertices,data,dataPos)

    def alloc(self,vertices,align):
        p = self.allocPosition(vertices,align)
        if (p < 0):
            return None
        b = h3d_Buffer(vertices,self.stride,[h3d_BufferFlag.NoAlloc])
        b.position = p
        b.buffer = self
        return b

    def getFreeVertices(self):
        m = 0
        l = self.freeList
        while (l is not None):
            m = (m + l.count)
            l = l.next
        return m

    def allocPosition(self,nvert,align):
        free = self.freeList
        while (free is not None):
            if (free.count >= nvert):
                d = HxOverrides.mod(((align - (HxOverrides.mod(free.pos, align)))), align)
                if (d == 0):
                    break
                if (free.count >= ((nvert + d))):
                    free.next = h3d_impl__ManagedBuffer_FreeCell((free.pos + d),(free.count - d),free.next)
                    free.count = d
                    free = free.next
                    break
            free = free.next
        if (free is None):
            return -1
        pos = free.pos
        free.pos = (free.pos + nvert)
        free.count = (free.count - nvert)
        return pos

    def allocBuffer(self,b):
        align = (4 if ((((b.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0)) else (3 if ((((b.flags & ((1 << h3d_BufferFlag.Triangles.index)))) != 0)) else 1))
        p = self.allocPosition(b.vertices,align)
        if (p < 0):
            return False
        b.position = p
        b.buffer = self
        return True

    def freeBuffer(self,b):
        prev = None
        f = self.freeList
        nvert = b.vertices
        end = (b.position + nvert)
        while (f is not None):
            if (f.pos == end):
                f.pos = (f.pos - nvert)
                f.count = (f.count + nvert)
                if ((prev is not None) and (((prev.pos + prev.count) == f.pos))):
                    prev.count = (prev.count + f.count)
                    prev.next = f.next
                nvert = 0
                break
            if (f.pos > end):
                if ((prev is not None) and (((prev.pos + prev.count) == b.position))):
                    prev.count = (prev.count + nvert)
                else:
                    n = h3d_impl__ManagedBuffer_FreeCell(b.position,nvert,f)
                    if (prev is None):
                        self.freeList = n
                    else:
                        prev.next = n
                nvert = 0
                break
            prev = f
            f = f.next
        if (nvert != 0):
            raise haxe_Exception.thrown("assert")
        if ((self.freeList.count == self.size) and ((((self.flags & ((1 << h3d_BufferFlag.Managed.index)))) == 0))):
            self.dispose()

    def dispose(self):
        self.mem.freeManaged(self)

    def isDisposed(self):
        return (self.vbuf is None)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mem = None
        _hx_o.stride = None
        _hx_o.size = None
        _hx_o.flags = None
        _hx_o.vbuf = None
        _hx_o.freeList = None
        _hx_o.next = None
h3d_impl_ManagedBuffer._hx_class = h3d_impl_ManagedBuffer
_hx_classes["h3d.impl.ManagedBuffer"] = h3d_impl_ManagedBuffer


class python_Boot:
    _hx_class_name = "python.Boot"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "hasField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def hasField(o,field):
        if isinstance(o,_hx_AnonObject):
            return o._hx_hasattr(field)
        return hasattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)))

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 4):
                if (field1 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 5):
                if (field1 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 3):
                if (field1 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 8):
                if (field1 == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 6):
                if (field1 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            if hasattr(o,field1):
                return getattr(o,field1)
            else:
                return None

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot
_hx_classes["python.Boot"] = python_Boot


class HxString:
    _hx_class_name = "HxString"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString
_hx_classes["HxString"] = HxString


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    _hx_is_interface = "False"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.func = None
python_internal_MethodClosure._hx_class = python_internal_MethodClosure
_hx_classes["python.internal.MethodClosure"] = python_internal_MethodClosure


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl
_hx_classes["python.internal.ArrayImpl"] = python_internal_ArrayImpl


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    _hx_is_interface = "False"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.it = None
        _hx_o.x = None
        _hx_o.has = None
        _hx_o.checked = None
python_HaxeIterator._hx_class = python_HaxeIterator
_hx_classes["python.HaxeIterator"] = python_HaxeIterator


class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    _hx_is_interface = "False"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.current = None
        _hx_o.array = None
haxe_iterators_ArrayKeyValueIterator._hx_class = haxe_iterators_ArrayKeyValueIterator
_hx_classes["haxe.iterators.ArrayKeyValueIterator"] = haxe_iterators_ArrayKeyValueIterator


class h3d_impl_MemoryManager:
    _hx_class_name = "h3d.impl.MemoryManager"
    _hx_is_interface = "False"
    _hx_fields = ["driver", "buffers", "indexes", "textures", "depths", "triIndexes", "quadIndexes", "usedMemory", "texMemory", "bufferCount"]
    _hx_methods = ["init", "initIndexes", "garbage", "cleanManagedBuffers", "allocManaged", "freeManaged", "allocBuffer", "deleteIndexes", "allocIndexes", "bpp", "cleanTextures", "sortByLRU", "deleteTexture", "allocTexture", "allocDepth", "deleteDepth", "onContextLost", "dispose", "freeMemorySize", "stats", "allocStats"]
    _hx_statics = ["MAX_MEMORY", "MAX_BUFFERS", "SIZE", "ALL_FLAGS"]

    def __init__(self,driver):
        self.quadIndexes = None
        self.triIndexes = None
        self.depths = None
        self.textures = None
        self.indexes = None
        self.buffers = None
        self.bufferCount = 0
        self.texMemory = 0
        self.usedMemory = 0
        self.driver = driver

    def init(self):
        self.indexes = list()
        self.textures = list()
        self.buffers = list()
        self.depths = list()
        self.initIndexes()

    def initIndexes(self):
        this1 = list()
        indices = this1
        _g = 0
        while (_g < 65533):
            i = _g
            _g = (_g + 1)
            indices.append(i)
        self.triIndexes = h3d_Indexes.alloc(indices)
        this1 = list()
        indices = this1
        p = 0
        _g = 0
        _g1 = 16383
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            k = (i << 2)
            indices.append(k)
            indices.append((k + 1))
            indices.append((k + 2))
            indices.append((k + 2))
            indices.append((k + 1))
            indices.append((k + 3))
        indices.append(65533)
        self.quadIndexes = h3d_Indexes.alloc(indices)

    def garbage(self):
        pass

    def cleanManagedBuffers(self):
        _g = 1
        _g1 = len(self.buffers)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            b = (self.buffers[i] if i >= 0 and i < len(self.buffers) else None)
            prev = None
            while (b is not None):
                if (b.freeList.count == b.size):
                    b.dispose()
                    if (prev is None):
                        python_internal_ArrayImpl._set(self.buffers, i, b.next)
                    else:
                        prev.next = b.next
                else:
                    prev = b
                b = b.next

    def allocManaged(self,m):
        if (m.vbuf is not None):
            return
        mem = ((m.size * m.stride) * 4)
        if (mem == 0):
            return
        def _hx_local_0():
            m.vbuf = self.driver.allocVertexes(m)
            return m.vbuf
        while ((((self.usedMemory + mem) > 4294967296.) or ((self.bufferCount >= 65536))) or (((_hx_local_0()) is None))):
            if self.driver.isDisposed():
                return
            size = (self.usedMemory - self.freeMemorySize())
            self.garbage()
            self.cleanManagedBuffers()
            if ((self.usedMemory - self.freeMemorySize()) == size):
                if (self.bufferCount >= 65536):
                    raise haxe_Exception.thrown("Too many buffers")
                v = (size / 1024)
                raise haxe_Exception.thrown((((("Memory full (" + Std.string(((v if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v)) else Math.ceil(v)))))) + " KB,") + Std.string(self.bufferCount)) + " buffers)"))
        _hx_local_1 = self
        _hx_local_2 = _hx_local_1.usedMemory
        _hx_local_1.usedMemory = (_hx_local_2 + mem)
        _hx_local_1.usedMemory
        _hx_local_3 = self
        _hx_local_4 = _hx_local_3.bufferCount
        _hx_local_3.bufferCount = (_hx_local_4 + 1)
        _hx_local_4

    def freeManaged(self,m):
        if (m.vbuf is None):
            return
        self.driver.disposeVertexes(m.vbuf)
        m.vbuf = None
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.usedMemory
        _hx_local_0.usedMemory = (_hx_local_1 - (((m.size * m.stride) * 4)))
        _hx_local_0.usedMemory
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.bufferCount
        _hx_local_2.bufferCount = (_hx_local_3 - 1)
        _hx_local_3
        if (((m.flags & ((1 << h3d_BufferFlag.Managed.index)))) == 0):
            c = (self.buffers[0] if 0 < len(self.buffers) else None)
            prev = None
            while (c is not None):
                if (c == m):
                    if (prev is None):
                        python_internal_ArrayImpl._set(self.buffers, 0, m.next)
                    else:
                        prev.next = m.next
                    break
                prev = c
                c = c.next

    def allocBuffer(self,b,stride):
        _hx_max = (65532 if ((((b.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0)) else (65533 if ((((b.flags & ((1 << h3d_BufferFlag.Triangles.index)))) != 0)) else 65534))
        if (((b.vertices > _hx_max) and ((((b.flags & ((1 << h3d_BufferFlag.UniformBuffer.index)))) == 0))) and ((((b.flags & ((1 << h3d_BufferFlag.LargeBuffer.index)))) == 0))):
            if (_hx_max == 65534):
                raise haxe_Exception.thrown((("Cannot split buffer with " + Std.string(b.vertices)) + " vertices if it's not Quads/Triangles"))
            rem = (b.vertices - _hx_max)
            b.vertices = _hx_max
            self.allocBuffer(b,stride)
            n = b
            while (n.next is not None):
                n = n.next
            flags = []
            _g = 0
            _g1 = h3d_impl_MemoryManager.ALL_FLAGS
            while (_g < len(_g1)):
                f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (((b.flags & ((1 << f.index)))) != 0):
                    flags.append(f)
            n.next = h3d_Buffer(rem,stride,flags)
            return
        if (((b.flags & ((1 << h3d_BufferFlag.Managed.index)))) == 0):
            flags = None
            if (((b.flags & ((1 << h3d_BufferFlag.Dynamic.index)))) != 0):
                if (flags is None):
                    flags = []
                flags.append(h3d_BufferFlag.Dynamic)
            if (((b.flags & ((1 << h3d_BufferFlag.UniformBuffer.index)))) != 0):
                if (flags is None):
                    flags = []
                flags.append(h3d_BufferFlag.UniformBuffer)
            m = h3d_impl_ManagedBuffer(stride,b.vertices,flags)
            m.next = (self.buffers[0] if 0 < len(self.buffers) else None)
            python_internal_ArrayImpl._set(self.buffers, 0, m)
            if (not m.allocBuffer(b)):
                raise haxe_Exception.thrown("assert")
            return
        m = (self.buffers[stride] if stride >= 0 and stride < len(self.buffers) else None)
        prev = None
        while (m is not None):
            if m.allocBuffer(b):
                return
            prev = m
            m = m.next
        align = (3 if ((((b.flags & ((1 << h3d_BufferFlag.Triangles.index)))) != 0)) else (4 if ((((b.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0)) else 0))
        if ((m is None) and ((align > 0))):
            total = b.vertices
            size = total
            while (size > 2048):
                m = (self.buffers[stride] if stride >= 0 and stride < len(self.buffers) else None)
                size = (size >> 1)
                size = (size - (HxOverrides.mod(size, align)))
                b.vertices = size
                while (m is not None):
                    if m.allocBuffer(b):
                        flags = []
                        _g = 0
                        _g1 = h3d_impl_MemoryManager.ALL_FLAGS
                        while (_g < len(_g1)):
                            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                            _g = (_g + 1)
                            if (((b.flags & ((1 << f.index)))) != 0):
                                flags.append(f)
                        b.next = h3d_Buffer((total - size),stride,flags)
                        return
                    m = m.next
            b.vertices = total
        m = h3d_impl_ManagedBuffer(stride,65533,[h3d_BufferFlag.Managed])
        if (prev is None):
            python_internal_ArrayImpl._set(self.buffers, stride, m)
        else:
            prev.next = m
        if (not m.allocBuffer(b)):
            raise haxe_Exception.thrown("assert")

    def deleteIndexes(self,i):
        python_internal_ArrayImpl.remove(self.indexes,i)
        self.driver.disposeIndexes(i.ibuf)
        i.ibuf = None
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.usedMemory
        _hx_local_0.usedMemory = (_hx_local_1 - ((i.count * ((4 if (i.is32) else 2)))))
        _hx_local_0.usedMemory

    def allocIndexes(self,i):
        i.ibuf = self.driver.allocIndexes(i.count,i.is32)
        _this = self.indexes
        _this.append(i)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.usedMemory
        _hx_local_0.usedMemory = (_hx_local_1 + ((i.count * ((4 if (i.is32) else 2)))))
        _hx_local_0.usedMemory

    def bpp(self,t):
        return 4

    def cleanTextures(self,force = None):
        if (force is None):
            force = True
        self.textures.sort(key= python_lib_Functools.cmp_to_key(self.sortByLRU))
        _g = 0
        _g1 = self.textures
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((t.realloc is None) or (((t.t is None) and ((t.realloc is None))))):
                continue
            if (force or ((t.get_lastFrame() < ((hxd_Timer.frameCount - 3600))))):
                t.dispose()
                return True
        return False

    def sortByLRU(self,t1,t2):
        return (t1.get_lastFrame() - t2.get_lastFrame())

    def deleteTexture(self,t):
        if (not python_internal_ArrayImpl.remove(self.textures,t)):
            return
        self.driver.disposeTexture(t)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 - (((t.width * t.height) * self.bpp(t))))
        _hx_local_0.texMemory

    def allocTexture(self,t):
        free = self.cleanTextures(False)
        t.t = self.driver.allocTexture(t)
        if (t.t is None):
            if self.driver.isDisposed():
                return
            if (not self.cleanTextures(True)):
                raise haxe_Exception.thrown("Maximum texture memory reached")
            self.allocTexture(t)
            return
        _this = self.textures
        _this.append(t)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 + (((t.width * t.height) * self.bpp(t))))
        _hx_local_0.texMemory

    def allocDepth(self,b):
        free = self.cleanTextures(False)
        b.b = self.driver.allocDepthBuffer(b)
        if (b.b is None):
            if self.driver.isDisposed():
                return
            if (not self.cleanTextures(True)):
                raise haxe_Exception.thrown("Maximum texture memory reached")
            self.allocDepth(b)
            return
        _this = self.depths
        _this.append(b)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 + (((b.width * b.height) * 4)))
        _hx_local_0.texMemory

    def deleteDepth(self,b):
        if (not python_internal_ArrayImpl.remove(self.depths,b)):
            return
        self.driver.disposeDepthBuffer(b)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 - (((b.width * b.height) * 4)))
        _hx_local_0.texMemory

    def onContextLost(self):
        self.dispose()
        self.initIndexes()

    def dispose(self):
        if (self.triIndexes is not None):
            self.triIndexes.dispose()
        if (self.quadIndexes is not None):
            self.quadIndexes.dispose()
        self.triIndexes = None
        self.quadIndexes = None
        _g = 0
        _g1 = list(self.textures)
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            t.dispose()
        _g = 0
        _g1 = list(self.depths)
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b.dispose()
        _g = 0
        _g1 = list(self.buffers)
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b1 = b
            while (b1 is not None):
                b1.dispose()
                b1 = b1.next
        _g = 0
        _g1 = list(self.indexes)
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            i.dispose()
        self.buffers = []
        self.indexes = []
        self.textures = []
        self.bufferCount = 0
        self.usedMemory = 0
        self.texMemory = 0

    def freeMemorySize(self):
        size = 0
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b1 = b
            while (b1 is not None):
                free = b1.freeList
                while (free is not None):
                    size = (size + (((free.count * b1.stride) * 4)))
                    free = free.next
                b1 = b1.next
        return size

    def stats(self):
        total = 0
        free = 0
        count = 0
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b1 = b
            while (b1 is not None):
                total = (total + (((b1.stride * b1.size) * 4)))
                f = b1.freeList
                while (f is not None):
                    free = (free + (((f.count * b1.stride) * 4)))
                    f = f.next
                count = (count + 1)
                b1 = b1.next
        return _hx_AnonObject({'bufferCount': self.bufferCount, 'freeManagedMemory': free, 'managedMemory': total, 'totalMemory': (self.usedMemory + self.texMemory), 'textureCount': len(self.textures), 'textureMemory': self.texMemory})

    def allocStats(self):
        return []

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.driver = None
        _hx_o.buffers = None
        _hx_o.indexes = None
        _hx_o.textures = None
        _hx_o.depths = None
        _hx_o.triIndexes = None
        _hx_o.quadIndexes = None
        _hx_o.usedMemory = None
        _hx_o.texMemory = None
        _hx_o.bufferCount = None
h3d_impl_MemoryManager._hx_class = h3d_impl_MemoryManager
_hx_classes["h3d.impl.MemoryManager"] = h3d_impl_MemoryManager


class h3d_impl_NullDriver(h3d_impl_Driver):
    _hx_class_name = "h3d.impl.NullDriver"
    _hx_is_interface = "False"
    __slots__ = ("cur",)
    _hx_fields = ["cur"]
    _hx_methods = ["hasFeature", "isSupportedFormat", "logImpl", "isDisposed", "getDriverName", "init", "selectShader", "getShaderInputNames", "allocTexture", "allocIndexes", "allocVertexes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_impl_Driver


    def __init__(self):
        self.cur = None

    def hasFeature(self,f):
        return True

    def isSupportedFormat(self,fmt):
        return True

    def logImpl(self,_hx_str):
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    def isDisposed(self):
        return False

    def getDriverName(self,details):
        return "NullDriver"

    def init(self,onCreate,forceSoftware = None):
        if (forceSoftware is None):
            forceSoftware = False
        onCreate(False)

    def selectShader(self,shader):
        if (self.cur == shader):
            return False
        self.cur = shader
        return True

    def getShaderInputNames(self):
        names = []
        _g = 0
        _g1 = self.cur.vertex.data.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (v.kind == hxsl_VarKind.Input):
                x = v.name
                names.append(x)
        return h3d_impl_InputNames.get(names)

    def allocTexture(self,t):
        return _hx_AnonObject({})

    def allocIndexes(self,count,is32):
        return _hx_AnonObject({})

    def allocVertexes(self,m):
        return _hx_AnonObject({})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cur = None
h3d_impl_NullDriver._hx_class = h3d_impl_NullDriver
_hx_classes["h3d.impl.NullDriver"] = h3d_impl_NullDriver

class h3d_impl_Step(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.impl.Step"
    _hx_constructs = ["MainDraw", "Decals", "Shadows", "Lighting", "Forward", "BeforeTonemapping", "AfterTonemapping", "Overlay"]
h3d_impl_Step.MainDraw = h3d_impl_Step("MainDraw", 0, ())
h3d_impl_Step.Decals = h3d_impl_Step("Decals", 1, ())
h3d_impl_Step.Shadows = h3d_impl_Step("Shadows", 2, ())
h3d_impl_Step.Lighting = h3d_impl_Step("Lighting", 3, ())
h3d_impl_Step.Forward = h3d_impl_Step("Forward", 4, ())
h3d_impl_Step.BeforeTonemapping = h3d_impl_Step("BeforeTonemapping", 5, ())
h3d_impl_Step.AfterTonemapping = h3d_impl_Step("AfterTonemapping", 6, ())
h3d_impl_Step.Overlay = h3d_impl_Step("Overlay", 7, ())
h3d_impl_Step._hx_class = h3d_impl_Step
_hx_classes["h3d.impl.Step"] = h3d_impl_Step


class h3d_impl_RendererFX:
    _hx_class_name = "h3d.impl.RendererFX"
    _hx_is_interface = "True"
    __slots__ = ("enabled",)
    _hx_fields = ["enabled"]
    _hx_methods = ["begin", "end", "dispose"]
h3d_impl_RendererFX._hx_class = h3d_impl_RendererFX
_hx_classes["h3d.impl.RendererFX"] = h3d_impl_RendererFX


class h3d_impl_TextureCache:
    _hx_class_name = "h3d.impl.TextureCache"
    _hx_is_interface = "False"
    __slots__ = ("cache", "position", "defaultDepthBuffer", "ctx", "defaultFormat")
    _hx_fields = ["cache", "position", "defaultDepthBuffer", "ctx", "defaultFormat"]
    _hx_methods = ["get", "getNamed", "set", "begin", "lookupTarget", "allocTarget", "allocTargetScale", "allocTileTarget", "dispose"]

    def __init__(self,ctx):
        self.position = 0
        self.ctx = ctx
        self.cache = []
        engine = h3d_Engine.CURRENT
        self.defaultFormat = h3d_mat_Texture.nativeFormat
        self.defaultDepthBuffer = h3d_mat_DepthBuffer.getDefault()

    def get(self,index = None):
        if (index is None):
            index = 0
        return (self.cache[index] if index >= 0 and index < len(self.cache) else None)

    def getNamed(self,name):
        _g = 0
        _g1 = self.position
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.cache[i] if i >= 0 and i < len(self.cache) else None).name == name):
                return (self.cache[i] if i >= 0 and i < len(self.cache) else None)
        return None

    def set(self,t,index):
        python_internal_ArrayImpl._set(self.cache, index, t)

    def begin(self):
        while (len(self.cache) > self.position):
            _this = self.cache
            t = (None if ((len(_this) == 0)) else _this.pop())
            if (t is not None):
                t.dispose()
        self.position = 0

    def lookupTarget(self,name,width,height,format,isCube):
        t = python_internal_ArrayImpl._get(self.cache, self.position)
        _g = (self.position + 1)
        _g1 = len(self.cache)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            t2 = (self.cache[i] if i >= 0 and i < len(self.cache) else None)
            if ((((((t2 is not None) and (not (((t2.t is None) and ((t2.realloc is None)))))) and ((t2.width == width))) and ((t2.height == height))) and ((t2.format == format))) and ((isCube == ((((t2.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0))))):
                python_internal_ArrayImpl._set(self.cache, self.position, t2)
                python_internal_ArrayImpl._set(self.cache, i, t)
                return t2
        if ((t is not None) and ((t.name == name))):
            t.dispose()
            t = None
        flags = [h3d_mat_TextureFlags.Target]
        if isCube:
            flags.append(h3d_mat_TextureFlags.Cube)
        newt = h3d_mat_Texture(width,height,flags,format)
        if (t is not None):
            pos = self.position
            self.cache.insert(pos, newt)
        else:
            python_internal_ArrayImpl._set(self.cache, self.position, newt)
        return newt

    def allocTarget(self,name,width,height,defaultDepth = None,format = None,isCube = None):
        if (defaultDepth is None):
            defaultDepth = True
        if (isCube is None):
            isCube = False
        t = python_internal_ArrayImpl._get(self.cache, self.position)
        if (format is None):
            format = self.defaultFormat
        if ((((((t is None) or (((t.t is None) and ((t.realloc is None))))) or ((t.width != width))) or ((t.height != height))) or ((t.format != format))) or ((isCube != ((((t.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0))))):
            t = self.lookupTarget(name,width,height,format,isCube)
        t.depthBuffer = (self.defaultDepthBuffer if defaultDepth else None)
        t.setName(name)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.position
        _hx_local_0.position = (_hx_local_1 + 1)
        _hx_local_1
        return t

    def allocTargetScale(self,name,scale,defaultDepth = None,format = None):
        if (defaultDepth is None):
            defaultDepth = True
        e = h3d_Engine.CURRENT
        return self.allocTarget(name,Math.ceil((e.width * scale)),Math.ceil((e.height * scale)),defaultDepth,format)

    def allocTileTarget(self,name,tile,defaultDepth = None,format = None):
        if (defaultDepth is None):
            defaultDepth = False
        return self.allocTarget(name,(Math.ceil((tile.width + tile.x)) - Math.floor(tile.x)),(Math.ceil((tile.height + tile.y)) - Math.floor(tile.y)),defaultDepth,format)

    def dispose(self):
        _g = 0
        _g1 = self.cache
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            t.dispose()
        self.cache = []

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cache = None
        _hx_o.position = None
        _hx_o.defaultDepthBuffer = None
        _hx_o.ctx = None
        _hx_o.defaultFormat = None
h3d_impl_TextureCache._hx_class = h3d_impl_TextureCache
_hx_classes["h3d.impl.TextureCache"] = h3d_impl_TextureCache


class hxd_impl_AnyProps:
    _hx_class_name = "hxd.impl.AnyProps"
    _hx_is_interface = "False"
    __slots__ = ("props",)
    _hx_fields = ["props"]
    _hx_methods = ["set_props", "setDefaultProps", "getDefaultProps", "refreshProps"]

    def set_props(self,p):
        self.props = p
        self.refreshProps()
        return p

    def setDefaultProps(self,kind):
        self.set_props(self.getDefaultProps(kind))

    def getDefaultProps(self,kind = None):
        return _hx_AnonObject({})

    def refreshProps(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.props = None
hxd_impl_AnyProps._hx_class = hxd_impl_AnyProps
_hx_classes["hxd.impl.AnyProps"] = hxd_impl_AnyProps


class h3d_mat_BaseMaterial(hxd_impl_AnyProps):
    _hx_class_name = "h3d.mat.BaseMaterial"
    _hx_is_interface = "False"
    __slots__ = ("passes", "name")
    _hx_fields = ["passes", "name"]
    _hx_methods = ["addPass", "removePass", "get_mainPass", "getPasses", "getPass", "allocPass", "clone"]
    _hx_statics = []
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]
    _hx_super = hxd_impl_AnyProps


    def __init__(self,shader = None):
        self.name = None
        self.passes = None
        if (shader is not None):
            self.addPass(h3d_mat_Pass("default",None)).addShader(shader)

    def addPass(self,p):
        prev = None
        cur = self.passes
        while (cur is not None):
            prev = cur
            cur = cur.nextPass
        if (prev is None):
            self.passes = p
        else:
            prev.nextPass = p
        p.nextPass = None
        return p

    def removePass(self,p):
        prev = None
        cur = self.passes
        while (cur is not None):
            if (cur == p):
                if (prev is None):
                    self.passes = p.nextPass
                else:
                    prev.nextPass = p.nextPass
                p.nextPass = None
                return True
            prev = cur
            cur = cur.nextPass
        return False

    def get_mainPass(self):
        return self.passes

    def getPasses(self):
        p = self.passes
        out = []
        while (p is not None):
            out.append(p)
            p = p.nextPass
        return out

    def getPass(self,name):
        p = self.passes
        while (p is not None):
            if (p.name == name):
                return p
            p = p.nextPass
        return None

    def allocPass(self,name,inheritMain = None):
        if (inheritMain is None):
            inheritMain = True
        p = self.getPass(name)
        if (p is not None):
            return p
        p = h3d_mat_Pass(name,None,(self.passes if inheritMain else None))
        if (inheritMain and ((self.passes is not None))):
            p.set_batchMode(self.passes.batchMode)
        self.addPass(p)
        return p

    def clone(self,m = None):
        if (m is None):
            m = h3d_mat_BaseMaterial()
        m.passes.load(self.passes)
        m.name = self.name
        m.set_props(self.props)
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.passes = None
        _hx_o.name = None
h3d_mat_BaseMaterial._hx_class = h3d_mat_BaseMaterial
_hx_classes["h3d.mat.BaseMaterial"] = h3d_mat_BaseMaterial

class h3d_mat_Face(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Face"
    _hx_constructs = ["None", "Back", "Front", "Both"]
h3d_mat_Face._hx_None = h3d_mat_Face("None", 0, ())
h3d_mat_Face.Back = h3d_mat_Face("Back", 1, ())
h3d_mat_Face.Front = h3d_mat_Face("Front", 2, ())
h3d_mat_Face.Both = h3d_mat_Face("Both", 3, ())
h3d_mat_Face._hx_class = h3d_mat_Face
_hx_classes["h3d.mat.Face"] = h3d_mat_Face

class h3d_mat_Blend(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Blend"
    _hx_constructs = ["One", "Zero", "SrcAlpha", "SrcColor", "DstAlpha", "DstColor", "OneMinusSrcAlpha", "OneMinusSrcColor", "OneMinusDstAlpha", "OneMinusDstColor", "ConstantColor", "ConstantAlpha", "OneMinusConstantColor", "OneMinusConstantAlpha", "SrcAlphaSaturate"]
h3d_mat_Blend.One = h3d_mat_Blend("One", 0, ())
h3d_mat_Blend.Zero = h3d_mat_Blend("Zero", 1, ())
h3d_mat_Blend.SrcAlpha = h3d_mat_Blend("SrcAlpha", 2, ())
h3d_mat_Blend.SrcColor = h3d_mat_Blend("SrcColor", 3, ())
h3d_mat_Blend.DstAlpha = h3d_mat_Blend("DstAlpha", 4, ())
h3d_mat_Blend.DstColor = h3d_mat_Blend("DstColor", 5, ())
h3d_mat_Blend.OneMinusSrcAlpha = h3d_mat_Blend("OneMinusSrcAlpha", 6, ())
h3d_mat_Blend.OneMinusSrcColor = h3d_mat_Blend("OneMinusSrcColor", 7, ())
h3d_mat_Blend.OneMinusDstAlpha = h3d_mat_Blend("OneMinusDstAlpha", 8, ())
h3d_mat_Blend.OneMinusDstColor = h3d_mat_Blend("OneMinusDstColor", 9, ())
h3d_mat_Blend.ConstantColor = h3d_mat_Blend("ConstantColor", 10, ())
h3d_mat_Blend.ConstantAlpha = h3d_mat_Blend("ConstantAlpha", 11, ())
h3d_mat_Blend.OneMinusConstantColor = h3d_mat_Blend("OneMinusConstantColor", 12, ())
h3d_mat_Blend.OneMinusConstantAlpha = h3d_mat_Blend("OneMinusConstantAlpha", 13, ())
h3d_mat_Blend.SrcAlphaSaturate = h3d_mat_Blend("SrcAlphaSaturate", 14, ())
h3d_mat_Blend._hx_class = h3d_mat_Blend
_hx_classes["h3d.mat.Blend"] = h3d_mat_Blend

class h3d_mat_Compare(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Compare"
    _hx_constructs = ["Always", "Never", "Equal", "NotEqual", "Greater", "GreaterEqual", "Less", "LessEqual"]
h3d_mat_Compare.Always = h3d_mat_Compare("Always", 0, ())
h3d_mat_Compare.Never = h3d_mat_Compare("Never", 1, ())
h3d_mat_Compare.Equal = h3d_mat_Compare("Equal", 2, ())
h3d_mat_Compare.NotEqual = h3d_mat_Compare("NotEqual", 3, ())
h3d_mat_Compare.Greater = h3d_mat_Compare("Greater", 4, ())
h3d_mat_Compare.GreaterEqual = h3d_mat_Compare("GreaterEqual", 5, ())
h3d_mat_Compare.Less = h3d_mat_Compare("Less", 6, ())
h3d_mat_Compare.LessEqual = h3d_mat_Compare("LessEqual", 7, ())
h3d_mat_Compare._hx_class = h3d_mat_Compare
_hx_classes["h3d.mat.Compare"] = h3d_mat_Compare

class h3d_mat_StencilOp(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.StencilOp"
    _hx_constructs = ["Keep", "Zero", "Replace", "Increment", "IncrementWrap", "Decrement", "DecrementWrap", "Invert"]
h3d_mat_StencilOp.Keep = h3d_mat_StencilOp("Keep", 0, ())
h3d_mat_StencilOp.Zero = h3d_mat_StencilOp("Zero", 1, ())
h3d_mat_StencilOp.Replace = h3d_mat_StencilOp("Replace", 2, ())
h3d_mat_StencilOp.Increment = h3d_mat_StencilOp("Increment", 3, ())
h3d_mat_StencilOp.IncrementWrap = h3d_mat_StencilOp("IncrementWrap", 4, ())
h3d_mat_StencilOp.Decrement = h3d_mat_StencilOp("Decrement", 5, ())
h3d_mat_StencilOp.DecrementWrap = h3d_mat_StencilOp("DecrementWrap", 6, ())
h3d_mat_StencilOp.Invert = h3d_mat_StencilOp("Invert", 7, ())
h3d_mat_StencilOp._hx_class = h3d_mat_StencilOp
_hx_classes["h3d.mat.StencilOp"] = h3d_mat_StencilOp

class h3d_mat_MipMap(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.MipMap"
    _hx_constructs = ["None", "Nearest", "Linear"]
h3d_mat_MipMap._hx_None = h3d_mat_MipMap("None", 0, ())
h3d_mat_MipMap.Nearest = h3d_mat_MipMap("Nearest", 1, ())
h3d_mat_MipMap.Linear = h3d_mat_MipMap("Linear", 2, ())
h3d_mat_MipMap._hx_class = h3d_mat_MipMap
_hx_classes["h3d.mat.MipMap"] = h3d_mat_MipMap

class h3d_mat_Filter(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Filter"
    _hx_constructs = ["Nearest", "Linear"]
h3d_mat_Filter.Nearest = h3d_mat_Filter("Nearest", 0, ())
h3d_mat_Filter.Linear = h3d_mat_Filter("Linear", 1, ())
h3d_mat_Filter._hx_class = h3d_mat_Filter
_hx_classes["h3d.mat.Filter"] = h3d_mat_Filter

class h3d_mat_Wrap(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Wrap"
    _hx_constructs = ["Clamp", "Repeat"]
h3d_mat_Wrap.Clamp = h3d_mat_Wrap("Clamp", 0, ())
h3d_mat_Wrap.Repeat = h3d_mat_Wrap("Repeat", 1, ())
h3d_mat_Wrap._hx_class = h3d_mat_Wrap
_hx_classes["h3d.mat.Wrap"] = h3d_mat_Wrap

class h3d_mat_Operation(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Operation"
    _hx_constructs = ["Add", "Sub", "ReverseSub", "Min", "Max"]
h3d_mat_Operation.Add = h3d_mat_Operation("Add", 0, ())
h3d_mat_Operation.Sub = h3d_mat_Operation("Sub", 1, ())
h3d_mat_Operation.ReverseSub = h3d_mat_Operation("ReverseSub", 2, ())
h3d_mat_Operation.Min = h3d_mat_Operation("Min", 3, ())
h3d_mat_Operation.Max = h3d_mat_Operation("Max", 4, ())
h3d_mat_Operation._hx_class = h3d_mat_Operation
_hx_classes["h3d.mat.Operation"] = h3d_mat_Operation

class h3d_mat_TextureFlags(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.TextureFlags"
    _hx_constructs = ["Target", "Cube", "MipMapped", "ManualMipMapGen", "IsNPOT", "NoAlloc", "Dynamic", "AlphaPremultiplied", "WasCleared", "Loading", "Serialize", "IsArray"]
h3d_mat_TextureFlags.Target = h3d_mat_TextureFlags("Target", 0, ())
h3d_mat_TextureFlags.Cube = h3d_mat_TextureFlags("Cube", 1, ())
h3d_mat_TextureFlags.MipMapped = h3d_mat_TextureFlags("MipMapped", 2, ())
h3d_mat_TextureFlags.ManualMipMapGen = h3d_mat_TextureFlags("ManualMipMapGen", 3, ())
h3d_mat_TextureFlags.IsNPOT = h3d_mat_TextureFlags("IsNPOT", 4, ())
h3d_mat_TextureFlags.NoAlloc = h3d_mat_TextureFlags("NoAlloc", 5, ())
h3d_mat_TextureFlags.Dynamic = h3d_mat_TextureFlags("Dynamic", 6, ())
h3d_mat_TextureFlags.AlphaPremultiplied = h3d_mat_TextureFlags("AlphaPremultiplied", 7, ())
h3d_mat_TextureFlags.WasCleared = h3d_mat_TextureFlags("WasCleared", 8, ())
h3d_mat_TextureFlags.Loading = h3d_mat_TextureFlags("Loading", 9, ())
h3d_mat_TextureFlags.Serialize = h3d_mat_TextureFlags("Serialize", 10, ())
h3d_mat_TextureFlags.IsArray = h3d_mat_TextureFlags("IsArray", 11, ())
h3d_mat_TextureFlags._hx_class = h3d_mat_TextureFlags
_hx_classes["h3d.mat.TextureFlags"] = h3d_mat_TextureFlags


class h3d_mat_Defaults:
    _hx_class_name = "h3d.mat.Defaults"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["defaultKillAlphaThreshold", "loadingTextureColor", "shadowShader", "get_shadowShader", "set_shadowShader", "makeVolumeDecal"]
    shadowShader = None

    @staticmethod
    def get_shadowShader():
        s = h3d_mat_Defaults.shadowShader
        if (s is None):
            s = h3d_shader_Shadow()
            h3d_mat_Defaults.set_shadowShader(s)
            h3d_mat_Defaults.shadowShader.setPriority(-1)
        return s

    @staticmethod
    def set_shadowShader(s):
        def _hx_local_1():
            def _hx_local_0():
                h3d_mat_Defaults.shadowShader = s
                return h3d_mat_Defaults.shadowShader
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def makeVolumeDecal(bounds):
        return h3d_shader_VolumeDecal((bounds.xMax - bounds.xMin),(bounds.yMax - bounds.yMin))
h3d_mat_Defaults._hx_class = h3d_mat_Defaults
_hx_classes["h3d.mat.Defaults"] = h3d_mat_Defaults

class h3d_mat_DepthFormat(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.DepthFormat"
    _hx_constructs = ["Depth16", "Depth24", "Depth24Stencil8"]
h3d_mat_DepthFormat.Depth16 = h3d_mat_DepthFormat("Depth16", 0, ())
h3d_mat_DepthFormat.Depth24 = h3d_mat_DepthFormat("Depth24", 1, ())
h3d_mat_DepthFormat.Depth24Stencil8 = h3d_mat_DepthFormat("Depth24Stencil8", 2, ())
h3d_mat_DepthFormat._hx_class = h3d_mat_DepthFormat
_hx_classes["h3d.mat.DepthFormat"] = h3d_mat_DepthFormat


class h3d_mat_DepthBuffer:
    _hx_class_name = "h3d.mat.DepthBuffer"
    _hx_is_interface = "False"
    __slots__ = ("b", "width", "height", "format")
    _hx_fields = ["b", "width", "height", "format"]
    _hx_methods = ["hasStencil", "alloc", "dispose", "isDisposed"]
    _hx_statics = ["getDefault"]

    def __init__(self,width,height,format = None):
        self.b = None
        self.width = width
        self.height = height
        self.format = format
        if (width > 0):
            self.alloc()

    def hasStencil(self):
        tmp = self.format.index
        if ((tmp == 1) or ((tmp == 0))):
            return False
        elif (tmp == 2):
            return True
        else:
            pass

    def alloc(self):
        h3d_Engine.CURRENT.mem.allocDepth(self)

    def dispose(self):
        if (self.b is not None):
            h3d_Engine.CURRENT.mem.deleteDepth(self)
            self.b = None

    def isDisposed(self):
        return (self.b is None)

    @staticmethod
    def getDefault():
        return h3d_Engine.CURRENT.driver.getDefaultDepthBuffer()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.format = None
h3d_mat_DepthBuffer._hx_class = h3d_mat_DepthBuffer
_hx_classes["h3d.mat.DepthBuffer"] = h3d_mat_DepthBuffer


class h3d_mat_Material(h3d_mat_BaseMaterial):
    _hx_class_name = "h3d.mat.Material"
    _hx_is_interface = "False"
    __slots__ = ("mshader", "normalShader", "model", "castShadows", "receiveShadows", "staticShadows", "textureShader", "specularShader", "blendMode")
    _hx_fields = ["mshader", "normalShader", "model", "castShadows", "receiveShadows", "staticShadows", "textureShader", "specularShader", "blendMode"]
    _hx_methods = ["get_specularPower", "set_specularPower", "get_specularAmount", "set_specularAmount", "get_color", "set_color", "get_shadows", "set_shadows", "set_castShadows", "set_receiveShadows", "set_staticShadows", "clone", "set_blendMode", "get_specularTexture", "get_texture", "set_texture", "get_normalMap", "set_normalMap", "set_specularTexture", "getDefaultModelProps", "getDefaultProps", "refreshProps"]
    _hx_statics = ["create"]
    _hx_interfaces = []
    _hx_super = h3d_mat_BaseMaterial


    def __init__(self,texture = None):
        self.blendMode = None
        self.specularShader = None
        self.textureShader = None
        self.staticShadows = None
        self.receiveShadows = None
        self.castShadows = None
        self.model = None
        self.normalShader = None
        self.mshader = h3d_shader_BaseMesh()
        self.set_blendMode(h2d_BlendMode._hx_None)
        super().__init__(self.mshader)
        self.set_texture(texture)

    def get_specularPower(self):
        return self.mshader.specularPower__

    def set_specularPower(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.mshader.specularPower__ = v
                return self.mshader.specularPower__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularAmount(self):
        return self.mshader.specularAmount__

    def set_specularAmount(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.mshader.specularAmount__ = v
                return self.mshader.specularAmount__
            return _hx_local_0()
        return _hx_local_1()

    def get_color(self):
        return self.mshader.color__

    def set_color(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.mshader.color__ = v
                return self.mshader.color__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadows(self):
        if self.castShadows:
            return self.receiveShadows
        else:
            return False

    def set_shadows(self,v):
        self.set_castShadows(v)
        self.set_receiveShadows(v)
        return v

    def set_castShadows(self,v):
        if (self.castShadows == v):
            return v
        if (self.passes is not None):
            if v:
                self.addPass(h3d_mat_Pass("shadow",None,self.passes)).set_isStatic(self.staticShadows)
            else:
                self.removePass(self.getPass("shadow"))
        def _hx_local_1():
            def _hx_local_0():
                self.castShadows = v
                return self.castShadows
            return _hx_local_0()
        return _hx_local_1()

    def set_receiveShadows(self,v):
        if (v == self.receiveShadows):
            return v
        if (self.passes is not None):
            shadows = h3d_mat_Defaults.get_shadowShader()
            if v:
                self.passes.addShader(shadows)
            else:
                self.passes.removeShader(shadows)
        def _hx_local_1():
            def _hx_local_0():
                self.receiveShadows = v
                return self.receiveShadows
            return _hx_local_0()
        return _hx_local_1()

    def set_staticShadows(self,v):
        p = self.getPass("shadow")
        if (p is not None):
            p.set_isStatic(v)
        def _hx_local_1():
            def _hx_local_0():
                self.staticShadows = v
                return self.staticShadows
            return _hx_local_0()
        return _hx_local_1()

    def clone(self,m = None):
        m1 = (h3d_mat_Material() if ((m is None)) else m)
        super().clone(m1)
        m1.set_castShadows(self.castShadows)
        m1.set_receiveShadows(self.receiveShadows)
        m1.set_texture(self.get_texture())
        m1.set_specularTexture(self.get_specularTexture())
        m1.set_normalMap(self.get_normalMap())
        if (self.textureShader is not None):
            _this = m1.textureShader
            _this.constModified = True
            _this.additive__ = self.textureShader.additive__
            _this = m1.textureShader
            _this.constModified = True
            _this.killAlpha__ = self.textureShader.killAlpha__
            m1.textureShader.killAlphaThreshold__ = self.textureShader.killAlphaThreshold__
        m1.mshader.color__ = self.mshader.color__
        m1.set_blendMode(self.blendMode)
        return m1

    def set_blendMode(self,v):
        if (self.passes is not None):
            self.passes.setBlendMode(v)
            tmp = v.index
            if (tmp == 0):
                self.passes.set_depthWrite(True)
                self.passes.setPassName("default")
            elif (tmp == 1):
                self.passes.set_depthWrite(True)
                self.passes.setPassName("alpha")
            elif ((((((((((tmp == 11) or ((tmp == 10))) or ((tmp == 9))) or ((tmp == 8))) or ((tmp == 7))) or ((tmp == 6))) or ((tmp == 5))) or ((tmp == 4))) or ((tmp == 3))) or ((tmp == 2))):
                self.passes.set_depthWrite(False)
                self.passes.setPassName("additive")
            else:
                pass
        def _hx_local_1():
            def _hx_local_0():
                self.blendMode = v
                return self.blendMode
            return _hx_local_0()
        return _hx_local_1()

    def get_specularTexture(self):
        if (self.specularShader is None):
            return None
        else:
            return self.specularShader.texture__

    def get_texture(self):
        if (self.textureShader is None):
            return None
        else:
            return self.textureShader.texture__

    def set_texture(self,t):
        if (t is None):
            if (self.textureShader is not None):
                self.passes.removeShader(self.textureShader)
                self.textureShader = None
        else:
            if (self.textureShader is None):
                self.textureShader = h3d_shader_Texture()
                self.passes.addShader(self.textureShader)
            self.textureShader.texture__ = t
        return t

    def get_normalMap(self):
        if (self.normalShader is None):
            return None
        else:
            return self.normalShader.texture__

    def set_normalMap(self,t):
        if (t is None):
            if (self.normalShader is not None):
                self.passes.removeShader(self.normalShader)
                self.normalShader = None
        else:
            if (self.normalShader is None):
                self.normalShader = h3d_shader_NormalMap()
                if (self.textureShader is not None):
                    self.passes.addShaderAtIndex(self.normalShader,(self.passes.getShaderIndex(self.textureShader) + 1))
                else:
                    self.passes.addShader(self.normalShader)
            self.normalShader.texture__ = t
        return t

    def set_specularTexture(self,t):
        if (t is None):
            if (self.specularShader is not None):
                self.passes.removeShader(self.specularShader)
                self.specularShader = None
        else:
            if (self.specularShader is None):
                self.specularShader = h3d_shader_SpecularTexture()
                self.passes.addShader(self.specularShader)
            self.specularShader.texture__ = t
        return t

    def getDefaultModelProps(self):
        props = self.getDefaultProps()
        tmp = self.blendMode.index
        if (tmp == 0):
            pass
        elif (tmp == 1):
            props.kind = "Alpha"
        elif (tmp == 2):
            props.kind = "Add"
            props.culling = False
            props.shadows = False
            props.light = False
        else:
            raise haxe_Exception.thrown(("Unsupported HMD material " + Std.string(self.blendMode)))
        return props

    def getDefaultProps(self,_hx_type = None):
        props = None
        if (_hx_type is None):
            props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
        else:
            type1 = _hx_type
            _hx_local_0 = len(type1)
            if (_hx_local_0 == 11):
                if (type1 == "particles3D"):
                    props = _hx_AnonObject({'kind': "Alpha", 'shadows': False, 'culling': False, 'light': True})
                else:
                    props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
            elif (_hx_local_0 == 7):
                if (type1 == "trail3D"):
                    props = _hx_AnonObject({'kind': "Alpha", 'shadows': False, 'culling': False, 'light': True})
                else:
                    props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
            elif (_hx_local_0 == 2):
                if (type1 == "ui"):
                    props = _hx_AnonObject({'kind': "Alpha", 'shadows': False, 'culling': False, 'light': False})
                else:
                    props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
            else:
                props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
        return props

    def refreshProps(self):
        if ((self.props is None) or ((self.passes is None))):
            return
        props = self.props
        _g = props.kind
        if (_g == "Add"):
            self.set_blendMode(h2d_BlendMode.Add)
        elif (_g == "Alpha"):
            self.set_blendMode(h2d_BlendMode.Alpha)
        elif (((_g == "Opaque") or ((_g == "Hidden"))) or ((_g == "AlphaKill"))):
            self.set_blendMode(h2d_BlendMode._hx_None)
        elif (_g == "SoftAdd"):
            self.set_blendMode(h2d_BlendMode.SoftAdd)
        else:
            pass
        tshader = self.textureShader
        if (tshader is not None):
            tshader.constModified = True
            tshader.killAlpha__ = (props.kind == "AlphaKill")
            tshader.killAlphaThreshold__ = 0.5
        self.passes.set_culling((h3d_mat_Face.Both if ((props.kind == "Hidden")) else (h3d_mat_Face.Back if (props.culling) else h3d_mat_Face._hx_None)))
        self.passes.set_enableLights(props.light)
        v = props.shadows
        self.set_castShadows(v)
        self.set_receiveShadows(v)
        if (self.castShadows and self.receiveShadows):
            self.getPass("shadow").set_culling(self.passes.culling)

    @staticmethod
    def create(tex = None):
        mat = h3d_mat_MaterialSetup.current.createMaterial()
        mat.set_texture(tex)
        mat.set_props(mat.getDefaultProps())
        return mat

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mshader = None
        _hx_o.normalShader = None
        _hx_o.model = None
        _hx_o.castShadows = None
        _hx_o.receiveShadows = None
        _hx_o.staticShadows = None
        _hx_o.textureShader = None
        _hx_o.specularShader = None
        _hx_o.blendMode = None
h3d_mat_Material._hx_class = h3d_mat_Material
_hx_classes["h3d.mat.Material"] = h3d_mat_Material


class h3d_mat_MaterialDatabase:
    _hx_class_name = "h3d.mat.MaterialDatabase"
    _hx_is_interface = "False"
    __slots__ = ("db",)
    _hx_fields = ["db"]
    _hx_methods = ["getFilePath", "getModelData", "saveData", "loadMatProps", "saveMatProps"]

    def __init__(self):
        self.db = haxe_ds_StringMap()

    def getFilePath(self,model):
        return (HxOverrides.stringOrNull(model.entry.get_directory()) + "/materials.props")

    def getModelData(self,model):
        if (model is None):
            return None
        this1 = self.db
        key = model.entry.get_directory()
        cached = this1.h.get(key,None)
        if (cached is not None):
            return cached.v
        file = self.getFilePath(model)
        value = None
        try:
            value = python_lib_Json.loads(hxd_res_Loader.currentInstance.load(file).toText(),**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),hxd_fs_NotFound):
                value = _hx_AnonObject({})
            else:
                raise _g
        this1 = self.db
        key = model.entry.get_directory()
        this1.h[key] = _hx_AnonObject({'v': value})
        return value

    def saveData(self,model,data):
        file = self.getFilePath(model)
        fs = Std.downcast(hxd_res_Loader.currentInstance.fs,hxd_fs_LocalFileSystem)
        if ((fs is not None) and (not haxe_io_Path.isAbsolute(file))):
            file = (HxOverrides.stringOrNull(fs.baseDir) + ("null" if file is None else file))
        if (data is None):
            try:
                sys_FileSystem.deleteFile(file)
            except BaseException as _g:
                None
        else:
            sys_io_File.saveContent(file,haxe_format_JsonPrinter.print(data,None,"\t"))

    def loadMatProps(self,material,setup):
        p = self.getModelData(material.model)
        if (p is None):
            return p
        p = Reflect.field(p,"materials")
        if (p is None):
            return p
        p = Reflect.field(p,setup.name)
        if (p is None):
            return p
        return Reflect.field(p,material.name)

    def saveMatProps(self,material,setup):
        path = ["materials", setup.name, material.name]
        root = self.getModelData(material.model)
        if (root is None):
            return
        realRoot = root
        prevs = []
        _g = 0
        _g1 = (len(path) - 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            next = Reflect.field(root,(path[i] if i >= 0 and i < len(path) else None))
            if (next is None):
                next = _hx_AnonObject({})
                field = (path[i] if i >= 0 and i < len(path) else None)
                setattr(root,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),next)
            prevs.append(root)
            root = next
        name = (None if ((len(path) == 0)) else path.pop())
        Reflect.deleteField(root,name)
        currentProps = material.props
        defaultProps = material.getDefaultProps()
        if ((currentProps is None) or ((Std.string(defaultProps) == Std.string(currentProps)))):
            while (len(path) > 0):
                name1 = (None if ((len(path) == 0)) else path.pop())
                root1 = (None if ((len(prevs) == 0)) else prevs.pop())
                if (len(python_Boot.fields(Reflect.field(root1,name1))) != 0):
                    break
                Reflect.deleteField(root1,name1)
        else:
            setattr(root,(("_hx_" + name) if ((name in python_Boot.keywords)) else (("_hx_" + name) if (((((len(name) > 2) and ((ord(name[0]) == 95))) and ((ord(name[1]) == 95))) and ((ord(name[(len(name) - 1)]) != 95)))) else name)),currentProps)
        file = self.getFilePath(material.model)
        if (len(python_Boot.fields(realRoot)) == 0):
            realRoot = None
        self.saveData(material.model,realRoot)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.db = None
h3d_mat_MaterialDatabase._hx_class = h3d_mat_MaterialDatabase
_hx_classes["h3d.mat.MaterialDatabase"] = h3d_mat_MaterialDatabase


class h3d_mat_MaterialSetup:
    _hx_class_name = "h3d.mat.MaterialSetup"
    _hx_is_interface = "False"
    __slots__ = ("name", "displayName", "database", "emptyMat")
    _hx_fields = ["name", "displayName", "database", "emptyMat"]
    _hx_methods = ["createRenderer", "createLightSystem", "createMaterial", "getDefaults", "loadMaterialProps", "saveMaterialProps", "customMeshInit"]
    _hx_statics = ["current"]

    def __init__(self,name):
        self.emptyMat = None
        self.database = None
        self.displayName = None
        self.name = None
        if (self.database is None):
            self.database = h3d_mat_MaterialDatabase()
        self.name = name

    def createRenderer(self):
        return h3d_scene_fwd_Renderer()

    def createLightSystem(self):
        return h3d_scene_fwd_LightSystem()

    def createMaterial(self):
        return h3d_mat_Material()

    def getDefaults(self,kind = None):
        if (self.emptyMat is None):
            self.emptyMat = self.createMaterial()
        return self.emptyMat.getDefaultProps(kind)

    def loadMaterialProps(self,material):
        return self.database.loadMatProps(material,self)

    def saveMaterialProps(self,material):
        self.database.saveMatProps(material,self)

    def customMeshInit(self,mesh):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.displayName = None
        _hx_o.database = None
        _hx_o.emptyMat = None
h3d_mat_MaterialSetup._hx_class = h3d_mat_MaterialSetup
_hx_classes["h3d.mat.MaterialSetup"] = h3d_mat_MaterialSetup


class h3d_mat_Pass:
    _hx_class_name = "h3d.mat.Pass"
    _hx_is_interface = "False"
    __slots__ = ("name", "flags", "passId", "bits", "parentPass", "parentShaders", "shaders", "nextPass", "enableLights", "dynamicParameters", "isStatic", "batchMode", "culling", "depthWrite", "depthTest", "blendSrc", "blendDst", "blendAlphaSrc", "blendAlphaDst", "blendOp", "blendAlphaOp", "wireframe", "colorMask", "stencil", "reserved")
    _hx_fields = ["name", "flags", "passId", "bits", "parentPass", "parentShaders", "shaders", "nextPass", "enableLights", "dynamicParameters", "isStatic", "batchMode", "culling", "depthWrite", "depthTest", "blendSrc", "blendDst", "blendAlphaSrc", "blendAlphaDst", "blendOp", "blendAlphaOp", "wireframe", "colorMask", "stencil", "reserved"]
    _hx_methods = ["load", "setPassName", "blend", "setBlendMode", "depth", "setColorMask", "setColorChannel", "addShader", "addShaderAtIndex", "getShaderIndex", "removeShader", "getShader", "getShaderByName", "getShaders", "getShadersRec", "clone", "getDebugShaderCode", "set_enableLights", "set_dynamicParameters", "set_isStatic", "set_batchMode", "set_culling", "set_depthWrite", "set_depthTest", "set_blendSrc", "set_blendDst", "set_blendAlphaSrc", "set_blendAlphaDst", "set_blendOp", "set_blendAlphaOp", "set_wireframe", "set_reserved", "loadFlags", "loadBits"]
    _hx_statics = ["getEnableLights", "enableLights_bits", "enableLights_offset", "enableLights_mask", "getDynamicParameters", "dynamicParameters_bits", "dynamicParameters_offset", "dynamicParameters_mask", "getIsStatic", "isStatic_bits", "isStatic_offset", "isStatic_mask", "getBatchMode", "batchMode_bits", "batchMode_offset", "batchMode_mask", "getCulling", "culling_bits", "culling_offset", "culling_mask", "getDepthWrite", "depthWrite_bits", "depthWrite_offset", "depthWrite_mask", "getDepthTest", "depthTest_bits", "depthTest_offset", "depthTest_mask", "getBlendSrc", "blendSrc_bits", "blendSrc_offset", "blendSrc_mask", "getBlendDst", "blendDst_bits", "blendDst_offset", "blendDst_mask", "getBlendAlphaSrc", "blendAlphaSrc_bits", "blendAlphaSrc_offset", "blendAlphaSrc_mask", "getBlendAlphaDst", "blendAlphaDst_bits", "blendAlphaDst_offset", "blendAlphaDst_mask", "getBlendOp", "blendOp_bits", "blendOp_offset", "blendOp_mask", "getBlendAlphaOp", "blendAlphaOp_bits", "blendAlphaOp_offset", "blendAlphaOp_mask", "getWireframe", "wireframe_bits", "wireframe_offset", "wireframe_mask", "getReserved", "reserved_bits", "reserved_offset", "reserved_mask"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,name,shaders = None,parent = None):
        self.reserved = None
        self.stencil = None
        self.colorMask = None
        self.wireframe = None
        self.blendAlphaOp = None
        self.blendOp = None
        self.blendAlphaDst = None
        self.blendAlphaSrc = None
        self.blendDst = None
        self.blendSrc = None
        self.depthTest = None
        self.depthWrite = None
        self.culling = None
        self.batchMode = None
        self.isStatic = None
        self.dynamicParameters = None
        self.enableLights = None
        self.nextPass = None
        self.parentShaders = None
        self.passId = None
        self.flags = None
        self.name = None
        self.bits = 0
        self.parentPass = parent
        self.shaders = shaders
        self.setPassName(name)
        self.set_culling(h3d_mat_Face.Back)
        src = h3d_mat_Blend.One
        dst = h3d_mat_Blend.Zero
        self.set_blendSrc(src)
        self.set_blendAlphaSrc(src)
        self.set_blendDst(dst)
        self.set_blendAlphaDst(dst)
        self.depth(True,h3d_mat_Compare.Less)
        self.set_blendOp(self.set_blendAlphaOp(h3d_mat_Operation.Add))
        self.colorMask = 15

    def load(self,p):
        self.name = p.name
        self.passId = p.passId
        self.bits = p.bits
        self.set_enableLights(p.enableLights)
        self.set_dynamicParameters(p.dynamicParameters)
        self.set_culling(p.culling)
        self.set_depthWrite(p.depthWrite)
        self.set_depthTest(p.depthTest)
        self.set_blendSrc(p.blendSrc)
        self.set_blendDst(p.blendDst)
        self.set_blendOp(p.blendOp)
        self.set_blendAlphaSrc(p.blendAlphaSrc)
        self.set_blendAlphaDst(p.blendAlphaDst)
        self.set_blendAlphaOp(p.blendAlphaOp)
        self.colorMask = p.colorMask
        if (p.stencil is not None):
            if (self.stencil is None):
                self.stencil = h3d_mat_Stencil()
            self.stencil.load(p.stencil)

    def setPassName(self,name):
        self.name = name
        self.passId = hxsl_Globals.allocID(name)

    def blend(self,src,dst):
        self.set_blendSrc(src)
        self.set_blendAlphaSrc(src)
        self.set_blendDst(dst)
        self.set_blendAlphaDst(dst)

    def setBlendMode(self,b):
        tmp = b.index
        if (tmp == 0):
            src = h3d_mat_Blend.One
            dst = h3d_mat_Blend.Zero
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 1):
            src = h3d_mat_Blend.SrcAlpha
            dst = h3d_mat_Blend.OneMinusSrcAlpha
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 2):
            src = h3d_mat_Blend.SrcAlpha
            dst = h3d_mat_Blend.One
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 3):
            src = h3d_mat_Blend.One
            dst = h3d_mat_Blend.OneMinusSrcAlpha
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 4):
            src = h3d_mat_Blend.OneMinusDstColor
            dst = h3d_mat_Blend.One
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 5):
            src = h3d_mat_Blend.DstColor
            dst = h3d_mat_Blend.Zero
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 6):
            src = h3d_mat_Blend.DstColor
            dst = h3d_mat_Blend.OneMinusSrcAlpha
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 7):
            src = h3d_mat_Blend.Zero
            dst = h3d_mat_Blend.OneMinusSrcColor
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 8):
            src = h3d_mat_Blend.One
            dst = h3d_mat_Blend.OneMinusSrcColor
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 9):
            src = h3d_mat_Blend.SrcAlpha
            dst = h3d_mat_Blend.One
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.ReverseSub)
            self.set_blendAlphaOp(h3d_mat_Operation.ReverseSub)
        elif (tmp == 10):
            self.set_blendSrc(h3d_mat_Blend.Zero)
            self.set_blendAlphaSrc(h3d_mat_Blend.Zero)
            self.set_blendDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaSrc(h3d_mat_Blend.Zero)
            self.set_blendAlphaDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaOp(h3d_mat_Operation.Max)
            self.set_blendOp(h3d_mat_Operation.Max)
        elif (tmp == 11):
            self.set_blendSrc(h3d_mat_Blend.Zero)
            self.set_blendAlphaSrc(h3d_mat_Blend.Zero)
            self.set_blendDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaSrc(h3d_mat_Blend.Zero)
            self.set_blendAlphaDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaOp(h3d_mat_Operation.Min)
            self.set_blendOp(h3d_mat_Operation.Min)
        else:
            pass

    def depth(self,write,test):
        self.set_depthWrite(write)
        self.set_depthTest(test)

    def setColorMask(self,r,g,b,a):
        self.colorMask = (((((1 if r else 0)) | ((2 if g else 0))) | ((4 if b else 0))) | ((8 if a else 0)))

    def setColorChannel(self,c):
        tmp = c.index
        if (tmp == 1):
            self.setColorMask(True,False,False,False)
        elif (tmp == 2):
            self.setColorMask(False,True,False,False)
        elif (tmp == 3):
            self.setColorMask(False,False,True,False)
        elif (tmp == 4):
            self.setColorMask(False,False,False,True)
        else:
            raise haxe_Exception.thrown(("Unsupported channel " + Std.string(c)))

    def addShader(self,s):
        if (s is None):
            return None
        self.shaders = hxsl_ShaderList.addSort(s,self.shaders)
        return s

    def addShaderAtIndex(self,s,index):
        prev = None
        cur = self.shaders
        while ((index > 0) and ((cur != self.parentShaders))):
            prev = cur
            cur = cur.next
            index = (index - 1)
        if (prev is None):
            self.shaders = hxsl_ShaderList(s,cur)
        else:
            prev.next = hxsl_ShaderList(s,cur)
        return s

    def getShaderIndex(self,s):
        index = 0
        cur = self.shaders
        while (cur != self.parentShaders):
            if (cur.s == s):
                return index
            cur = cur.next
            index = (index + 1)
        return -1

    def removeShader(self,s):
        sl = self.shaders
        prev = None
        while (sl is not None):
            if (sl.s == s):
                if (prev is None):
                    self.shaders = sl.next
                else:
                    prev.next = sl.next
                return True
            prev = sl
            sl = sl.next
        return False

    def getShader(self,t):
        s = self.shaders
        while (s != self.parentShaders):
            sh = Std.downcast(s.s,t)
            if (sh is not None):
                return sh
            s = s.next
        return None

    def getShaderByName(self,name):
        s = self.shaders
        while (s != self.parentShaders):
            if (s.s.shader.data.name == name):
                return s.s
            s = s.next
        return None

    def getShaders(self):
        return hxsl__ShaderList_ShaderIterator(self.shaders,self.parentShaders)

    def getShadersRec(self):
        if ((self.parentPass is None) or ((self.parentShaders == self.parentPass.shaders))):
            return self.shaders
        s = self.shaders
        prev = None
        while ((s is not None) and ((s != self.parentShaders))):
            prev = s
            s = s.next
        self.parentShaders = self.parentPass.shaders
        if (prev is None):
            self.shaders = self.parentShaders
        else:
            prev.next = self.parentShaders
        return self.shaders

    def clone(self):
        p = h3d_mat_Pass(self.name,self.shaders.clone())
        p.bits = self.bits
        p.set_enableLights(self.enableLights)
        if (self.stencil is not None):
            p.stencil = self.stencil.clone()
        return p

    def getDebugShaderCode(self,scene,toHxsl = None):
        if (toHxsl is None):
            toHxsl = True
        shader = scene.renderer.debugCompileShader(self)
        if toHxsl:
            varId = True
            def _hx_local_0(s):
                return hxsl_Printer.shaderToString(s,varId)
            toString = _hx_local_0
            return ((("// vertex:\n" + HxOverrides.stringOrNull(toString(shader.vertex.data))) + "\n\nfragment:\n") + HxOverrides.stringOrNull(toString(shader.fragment.data)))
        else:
            return h3d_Engine.CURRENT.driver.getNativeShaderCode(shader)

    def set_enableLights(self,v):
        self.flags = ((self.flags & -2) | ((1 if v else 0)))
        def _hx_local_1():
            def _hx_local_0():
                self.enableLights = v
                return self.enableLights
            return _hx_local_0()
        return _hx_local_1()

    def set_dynamicParameters(self,v):
        self.flags = ((self.flags & -3) | ((((1 if v else 0)) << 1)))
        def _hx_local_1():
            def _hx_local_0():
                self.dynamicParameters = v
                return self.dynamicParameters
            return _hx_local_0()
        return _hx_local_1()

    def set_isStatic(self,v):
        self.flags = ((self.flags & -5) | ((((1 if v else 0)) << 2)))
        def _hx_local_1():
            def _hx_local_0():
                self.isStatic = v
                return self.isStatic
            return _hx_local_0()
        return _hx_local_1()

    def set_batchMode(self,v):
        self.flags = ((self.flags & -9) | ((((1 if v else 0)) << 3)))
        def _hx_local_1():
            def _hx_local_0():
                self.batchMode = v
                return self.batchMode
            return _hx_local_0()
        return _hx_local_1()

    def set_culling(self,v):
        self.bits = ((self.bits & -4) | v.index)
        def _hx_local_1():
            def _hx_local_0():
                self.culling = v
                return self.culling
            return _hx_local_0()
        return _hx_local_1()

    def set_depthWrite(self,v):
        self.bits = ((self.bits & -5) | ((((1 if v else 0)) << 2)))
        def _hx_local_1():
            def _hx_local_0():
                self.depthWrite = v
                return self.depthWrite
            return _hx_local_0()
        return _hx_local_1()

    def set_depthTest(self,v):
        self.bits = ((self.bits & -57) | ((v.index << 3)))
        def _hx_local_1():
            def _hx_local_0():
                self.depthTest = v
                return self.depthTest
            return _hx_local_0()
        return _hx_local_1()

    def set_blendSrc(self,v):
        self.bits = ((self.bits & -961) | ((v.index << 6)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendSrc = v
                return self.blendSrc
            return _hx_local_0()
        return _hx_local_1()

    def set_blendDst(self,v):
        self.bits = ((self.bits & -15361) | ((v.index << 10)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendDst = v
                return self.blendDst
            return _hx_local_0()
        return _hx_local_1()

    def set_blendAlphaSrc(self,v):
        self.bits = ((self.bits & -245761) | ((v.index << 14)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendAlphaSrc = v
                return self.blendAlphaSrc
            return _hx_local_0()
        return _hx_local_1()

    def set_blendAlphaDst(self,v):
        self.bits = ((self.bits & -3932161) | ((v.index << 18)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendAlphaDst = v
                return self.blendAlphaDst
            return _hx_local_0()
        return _hx_local_1()

    def set_blendOp(self,v):
        self.bits = ((self.bits & -29360129) | ((v.index << 22)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendOp = v
                return self.blendOp
            return _hx_local_0()
        return _hx_local_1()

    def set_blendAlphaOp(self,v):
        self.bits = ((self.bits & -234881025) | ((v.index << 25)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendAlphaOp = v
                return self.blendAlphaOp
            return _hx_local_0()
        return _hx_local_1()

    def set_wireframe(self,v):
        self.bits = ((self.bits & -268435457) | ((((1 if v else 0)) << 28)))
        def _hx_local_1():
            def _hx_local_0():
                self.wireframe = v
                return self.wireframe
            return _hx_local_0()
        return _hx_local_1()

    def set_reserved(self,v):
        self.bits = ((self.bits & -536870913) | ((((1 if v else 0)) << 29)))
        def _hx_local_1():
            def _hx_local_0():
                self.reserved = v
                return self.reserved
            return _hx_local_0()
        return _hx_local_1()

    def loadFlags(self,bits):
        self.flags = bits
        self.set_enableLights((((self.flags & 1)) != 0))
        self.set_dynamicParameters(((((self.flags >> 1) & 1)) != 0))
        self.set_isStatic(((((self.flags >> 2) & 1)) != 0))
        self.set_batchMode(((((self.flags >> 3) & 1)) != 0))

    def loadBits(self,bits):
        self.bits = bits
        self.set_culling(Type.createEnumIndex(h3d_mat_Face,(self.bits & 3)))
        self.set_depthWrite(((((self.bits >> 2) & 1)) != 0))
        self.set_depthTest(Type.createEnumIndex(h3d_mat_Compare,((self.bits >> 3) & 7)))
        self.set_blendSrc(Type.createEnumIndex(h3d_mat_Blend,((self.bits >> 6) & 15)))
        self.set_blendDst(Type.createEnumIndex(h3d_mat_Blend,((self.bits >> 10) & 15)))
        self.set_blendAlphaSrc(Type.createEnumIndex(h3d_mat_Blend,((self.bits >> 14) & 15)))
        self.set_blendAlphaDst(Type.createEnumIndex(h3d_mat_Blend,((self.bits >> 18) & 15)))
        self.set_blendOp(Type.createEnumIndex(h3d_mat_Operation,((self.bits >> 22) & 7)))
        self.set_blendAlphaOp(Type.createEnumIndex(h3d_mat_Operation,((self.bits >> 25) & 7)))
        self.set_wireframe(((((self.bits >> 28) & 1)) != 0))
        self.set_reserved(((((self.bits >> 29) & 1)) != 0))

    @staticmethod
    def getEnableLights(v):
        return (v & 1)

    @staticmethod
    def getDynamicParameters(v):
        return ((v >> 1) & 1)

    @staticmethod
    def getIsStatic(v):
        return ((v >> 2) & 1)

    @staticmethod
    def getBatchMode(v):
        return ((v >> 3) & 1)

    @staticmethod
    def getCulling(v):
        return (v & 3)

    @staticmethod
    def getDepthWrite(v):
        return ((v >> 2) & 1)

    @staticmethod
    def getDepthTest(v):
        return ((v >> 3) & 7)

    @staticmethod
    def getBlendSrc(v):
        return ((v >> 6) & 15)

    @staticmethod
    def getBlendDst(v):
        return ((v >> 10) & 15)

    @staticmethod
    def getBlendAlphaSrc(v):
        return ((v >> 14) & 15)

    @staticmethod
    def getBlendAlphaDst(v):
        return ((v >> 18) & 15)

    @staticmethod
    def getBlendOp(v):
        return ((v >> 22) & 7)

    @staticmethod
    def getBlendAlphaOp(v):
        return ((v >> 25) & 7)

    @staticmethod
    def getWireframe(v):
        return ((v >> 28) & 1)

    @staticmethod
    def getReserved(v):
        return ((v >> 29) & 1)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.flags = None
        _hx_o.passId = None
        _hx_o.bits = None
        _hx_o.parentPass = None
        _hx_o.parentShaders = None
        _hx_o.shaders = None
        _hx_o.nextPass = None
        _hx_o.enableLights = None
        _hx_o.dynamicParameters = None
        _hx_o.isStatic = None
        _hx_o.batchMode = None
        _hx_o.culling = None
        _hx_o.depthWrite = None
        _hx_o.depthTest = None
        _hx_o.blendSrc = None
        _hx_o.blendDst = None
        _hx_o.blendAlphaSrc = None
        _hx_o.blendAlphaDst = None
        _hx_o.blendOp = None
        _hx_o.blendAlphaOp = None
        _hx_o.wireframe = None
        _hx_o.colorMask = None
        _hx_o.stencil = None
        _hx_o.reserved = None
h3d_mat_Pass._hx_class = h3d_mat_Pass
_hx_classes["h3d.mat.Pass"] = h3d_mat_Pass


class h3d_mat_Stencil:
    _hx_class_name = "h3d.mat.Stencil"
    _hx_is_interface = "False"
    __slots__ = ("maskBits", "opBits", "readMask", "writeMask", "reference", "frontTest", "frontPass", "frontSTfail", "frontDPfail", "backTest", "backPass", "backSTfail", "backDPfail")
    _hx_fields = ["maskBits", "opBits", "readMask", "writeMask", "reference", "frontTest", "frontPass", "frontSTfail", "frontDPfail", "backTest", "backPass", "backSTfail", "backDPfail"]
    _hx_methods = ["setFront", "setBack", "setOp", "setFunc", "clone", "load", "set_readMask", "set_writeMask", "set_reference", "set_frontTest", "set_frontPass", "set_frontSTfail", "set_frontDPfail", "set_backTest", "set_backPass", "set_backSTfail", "set_backDPfail", "loadOpBits", "loadMaskBits"]
    _hx_statics = ["getReadMask", "readMask_bits", "readMask_offset", "readMask_mask", "getWriteMask", "writeMask_bits", "writeMask_offset", "writeMask_mask", "getReference", "reference_bits", "reference_offset", "reference_mask", "getFrontTest", "frontTest_bits", "frontTest_offset", "frontTest_mask", "getFrontPass", "frontPass_bits", "frontPass_offset", "frontPass_mask", "getFrontSTfail", "frontSTfail_bits", "frontSTfail_offset", "frontSTfail_mask", "getFrontDPfail", "frontDPfail_bits", "frontDPfail_offset", "frontDPfail_mask", "getBackTest", "backTest_bits", "backTest_offset", "backTest_mask", "getBackPass", "backPass_bits", "backPass_offset", "backPass_mask", "getBackSTfail", "backSTfail_bits", "backSTfail_offset", "backSTfail_mask", "getBackDPfail", "backDPfail_bits", "backDPfail_offset", "backDPfail_mask"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self):
        self.backDPfail = None
        self.backSTfail = None
        self.backPass = None
        self.backTest = None
        self.frontDPfail = None
        self.frontSTfail = None
        self.frontPass = None
        self.frontTest = None
        self.reference = None
        self.writeMask = None
        self.readMask = None
        self.opBits = 0
        self.maskBits = 0
        self.setOp(h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep)
        self.setFunc(h3d_mat_Compare.Always)

    def setFront(self,stfail,dpfail,_hx_pass):
        self.set_frontSTfail(stfail)
        self.set_frontDPfail(dpfail)
        self.set_frontPass(_hx_pass)

    def setBack(self,stfail,dpfail,_hx_pass):
        self.set_backSTfail(stfail)
        self.set_backDPfail(dpfail)
        self.set_backPass(_hx_pass)

    def setOp(self,stfail,dpfail,_hx_pass):
        self.setFront(stfail,dpfail,_hx_pass)
        self.setBack(stfail,dpfail,_hx_pass)

    def setFunc(self,f,reference = None,readMask = None,writeMask = None):
        if (reference is None):
            reference = 0
        if (readMask is None):
            readMask = 255
        if (writeMask is None):
            writeMask = 255
        self.set_frontTest(self.set_backTest(f))
        self.set_reference(reference)
        self.set_readMask(readMask)
        self.set_writeMask(writeMask)

    def clone(self):
        s = h3d_mat_Stencil()
        s.opBits = self.opBits
        s.maskBits = self.maskBits
        return s

    def load(self,s):
        self.opBits = s.opBits
        self.maskBits = s.maskBits

    def set_readMask(self,v):
        self.maskBits = ((self.maskBits & -256) | ((v & 255)))
        def _hx_local_1():
            def _hx_local_0():
                self.readMask = v
                return self.readMask
            return _hx_local_0()
        return _hx_local_1()

    def set_writeMask(self,v):
        self.maskBits = ((self.maskBits & -65281) | ((((v & 255)) << 8)))
        def _hx_local_1():
            def _hx_local_0():
                self.writeMask = v
                return self.writeMask
            return _hx_local_0()
        return _hx_local_1()

    def set_reference(self,v):
        self.maskBits = ((self.maskBits & -16711681) | ((((v & 255)) << 16)))
        def _hx_local_1():
            def _hx_local_0():
                self.reference = v
                return self.reference
            return _hx_local_0()
        return _hx_local_1()

    def set_frontTest(self,v):
        self.opBits = ((self.opBits & -8) | v.index)
        def _hx_local_1():
            def _hx_local_0():
                self.frontTest = v
                return self.frontTest
            return _hx_local_0()
        return _hx_local_1()

    def set_frontPass(self,v):
        self.opBits = ((self.opBits & -57) | ((v.index << 3)))
        def _hx_local_1():
            def _hx_local_0():
                self.frontPass = v
                return self.frontPass
            return _hx_local_0()
        return _hx_local_1()

    def set_frontSTfail(self,v):
        self.opBits = ((self.opBits & -449) | ((v.index << 6)))
        def _hx_local_1():
            def _hx_local_0():
                self.frontSTfail = v
                return self.frontSTfail
            return _hx_local_0()
        return _hx_local_1()

    def set_frontDPfail(self,v):
        self.opBits = ((self.opBits & -3585) | ((v.index << 9)))
        def _hx_local_1():
            def _hx_local_0():
                self.frontDPfail = v
                return self.frontDPfail
            return _hx_local_0()
        return _hx_local_1()

    def set_backTest(self,v):
        self.opBits = ((self.opBits & -28673) | ((v.index << 12)))
        def _hx_local_1():
            def _hx_local_0():
                self.backTest = v
                return self.backTest
            return _hx_local_0()
        return _hx_local_1()

    def set_backPass(self,v):
        self.opBits = ((self.opBits & -229377) | ((v.index << 15)))
        def _hx_local_1():
            def _hx_local_0():
                self.backPass = v
                return self.backPass
            return _hx_local_0()
        return _hx_local_1()

    def set_backSTfail(self,v):
        self.opBits = ((self.opBits & -1835009) | ((v.index << 18)))
        def _hx_local_1():
            def _hx_local_0():
                self.backSTfail = v
                return self.backSTfail
            return _hx_local_0()
        return _hx_local_1()

    def set_backDPfail(self,v):
        self.opBits = ((self.opBits & -14680065) | ((v.index << 21)))
        def _hx_local_1():
            def _hx_local_0():
                self.backDPfail = v
                return self.backDPfail
            return _hx_local_0()
        return _hx_local_1()

    def loadOpBits(self,bits):
        self.opBits = bits
        self.set_frontTest(Type.createEnumIndex(h3d_mat_Compare,(self.opBits & 7)))
        self.set_frontPass(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 3) & 7)))
        self.set_frontSTfail(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 6) & 7)))
        self.set_frontDPfail(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 9) & 7)))
        self.set_backTest(Type.createEnumIndex(h3d_mat_Compare,((self.opBits >> 12) & 7)))
        self.set_backPass(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 15) & 7)))
        self.set_backSTfail(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 18) & 7)))
        self.set_backDPfail(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 21) & 7)))

    def loadMaskBits(self,bits):
        self.maskBits = bits
        self.set_readMask((self.maskBits & 255))
        self.set_writeMask(((self.maskBits >> 8) & 255))
        self.set_reference(((self.maskBits >> 16) & 255))

    @staticmethod
    def getReadMask(v):
        return (v & 255)

    @staticmethod
    def getWriteMask(v):
        return ((v >> 8) & 255)

    @staticmethod
    def getReference(v):
        return ((v >> 16) & 255)

    @staticmethod
    def getFrontTest(v):
        return (v & 7)

    @staticmethod
    def getFrontPass(v):
        return ((v >> 3) & 7)

    @staticmethod
    def getFrontSTfail(v):
        return ((v >> 6) & 7)

    @staticmethod
    def getFrontDPfail(v):
        return ((v >> 9) & 7)

    @staticmethod
    def getBackTest(v):
        return ((v >> 12) & 7)

    @staticmethod
    def getBackPass(v):
        return ((v >> 15) & 7)

    @staticmethod
    def getBackSTfail(v):
        return ((v >> 18) & 7)

    @staticmethod
    def getBackDPfail(v):
        return ((v >> 21) & 7)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.maskBits = None
        _hx_o.opBits = None
        _hx_o.readMask = None
        _hx_o.writeMask = None
        _hx_o.reference = None
        _hx_o.frontTest = None
        _hx_o.frontPass = None
        _hx_o.frontSTfail = None
        _hx_o.frontDPfail = None
        _hx_o.backTest = None
        _hx_o.backPass = None
        _hx_o.backSTfail = None
        _hx_o.backDPfail = None
h3d_mat_Stencil._hx_class = h3d_mat_Stencil
_hx_classes["h3d.mat.Stencil"] = h3d_mat_Stencil

class hxd_PixelFormat(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.PixelFormat"
    _hx_constructs = ["ARGB", "BGRA", "RGBA", "RGBA16F", "RGBA32F", "R8", "R16F", "R32F", "RG8", "RG16F", "RG32F", "RGB8", "RGB16F", "RGB32F", "SRGB", "SRGB_ALPHA", "RGB10A2", "RG11B10UF", "R16U", "RGB16U", "RGBA16U", "S3TC"]

    @staticmethod
    def S3TC(v):
        return hxd_PixelFormat("S3TC", 21, (v,))
hxd_PixelFormat.ARGB = hxd_PixelFormat("ARGB", 0, ())
hxd_PixelFormat.BGRA = hxd_PixelFormat("BGRA", 1, ())
hxd_PixelFormat.RGBA = hxd_PixelFormat("RGBA", 2, ())
hxd_PixelFormat.RGBA16F = hxd_PixelFormat("RGBA16F", 3, ())
hxd_PixelFormat.RGBA32F = hxd_PixelFormat("RGBA32F", 4, ())
hxd_PixelFormat.R8 = hxd_PixelFormat("R8", 5, ())
hxd_PixelFormat.R16F = hxd_PixelFormat("R16F", 6, ())
hxd_PixelFormat.R32F = hxd_PixelFormat("R32F", 7, ())
hxd_PixelFormat.RG8 = hxd_PixelFormat("RG8", 8, ())
hxd_PixelFormat.RG16F = hxd_PixelFormat("RG16F", 9, ())
hxd_PixelFormat.RG32F = hxd_PixelFormat("RG32F", 10, ())
hxd_PixelFormat.RGB8 = hxd_PixelFormat("RGB8", 11, ())
hxd_PixelFormat.RGB16F = hxd_PixelFormat("RGB16F", 12, ())
hxd_PixelFormat.RGB32F = hxd_PixelFormat("RGB32F", 13, ())
hxd_PixelFormat.SRGB = hxd_PixelFormat("SRGB", 14, ())
hxd_PixelFormat.SRGB_ALPHA = hxd_PixelFormat("SRGB_ALPHA", 15, ())
hxd_PixelFormat.RGB10A2 = hxd_PixelFormat("RGB10A2", 16, ())
hxd_PixelFormat.RG11B10UF = hxd_PixelFormat("RG11B10UF", 17, ())
hxd_PixelFormat.R16U = hxd_PixelFormat("R16U", 18, ())
hxd_PixelFormat.RGB16U = hxd_PixelFormat("RGB16U", 19, ())
hxd_PixelFormat.RGBA16U = hxd_PixelFormat("RGBA16U", 20, ())
hxd_PixelFormat._hx_class = hxd_PixelFormat
_hx_classes["hxd.PixelFormat"] = hxd_PixelFormat


class h3d_mat_Texture:
    _hx_class_name = "h3d.mat.Texture"
    _hx_is_interface = "False"
    __slots__ = ("t", "mem", "id", "name", "width", "height", "flags", "format", "bits", "waitLoads", "mipMap", "filter", "wrap", "lodBias", "realloc", "depthBuffer", "_lastFrame")
    _hx_fields = ["t", "mem", "id", "name", "width", "height", "flags", "format", "bits", "waitLoads", "mipMap", "filter", "wrap", "lodBias", "realloc", "depthBuffer", "_lastFrame"]
    _hx_methods = ["set_lastFrame", "get_lastFrame", "get_mipLevels", "get_layerCount", "alloc", "isSRGB", "checkAlloc", "clone", "preventAutoDispose", "waitLoad", "toString", "setName", "set_mipMap", "set_filter", "set_wrap", "isDisposed", "resize", "clearF", "clear", "checkSize", "checkMipMapGen", "uploadBitmap", "uploadPixels", "dispose", "swapTexture", "capturePixels"]
    _hx_statics = ["UID", "PREVENT_AUTO_DISPOSE", "nativeFormat", "fromBitmap", "fromPixels", "fromColor", "genDisc", "genTexture", "drawGenTexture", "defaultCubeTexture", "genChecker", "checkerTextureKeys", "noiseTextureKeys", "genTextureKeys", "genNoise", "allocNoise", "allocChecker"]

    def __init__(self,w,h,flags = None,format = None):
        self._lastFrame = None
        self.depthBuffer = None
        self.realloc = None
        self.wrap = None
        self.filter = None
        self.mipMap = None
        self.waitLoads = None
        self.bits = None
        self.height = None
        self.width = None
        self.name = None
        self.t = None
        self.lodBias = 0.
        engine = h3d_Engine.CURRENT
        self.mem = engine.mem
        if (format is None):
            format = h3d_mat_Texture.nativeFormat
        def _hx_local_2():
            _hx_local_0 = h3d_mat_Texture
            _hx_local_1 = _hx_local_0.UID
            _hx_local_0.UID = (_hx_local_1 + 1)
            return _hx_local_0.UID
        self.id = _hx_local_2()
        self.format = format
        this1 = 0
        self.flags = this1
        if (flags is not None):
            _g = 0
            while (_g < len(flags)):
                f = (flags[_g] if _g >= 0 and _g < len(flags) else None)
                _g = (_g + 1)
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.flags
                _hx_local_4.flags = (_hx_local_5 | ((1 << f.index)))
                _hx_local_4.flags
        tw = 1
        th = 1
        while (tw < w):
            tw = (tw << 1)
        while (th < h):
            th = (th << 1)
        if ((tw != w) or ((th != h))):
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | ((1 << h3d_mat_TextureFlags.IsNPOT.index)))
            _hx_local_8.flags
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Target.index)))) != 0):
            def _hx_local_10():
                pass
            self.realloc = _hx_local_10
        self.width = w
        self.height = h
        self.set_mipMap((h3d_mat_MipMap.Nearest if ((((self.flags & ((1 << h3d_mat_TextureFlags.MipMapped.index)))) != 0)) else h3d_mat_MipMap._hx_None))
        self.set_filter(h3d_mat_Filter.Linear)
        self.set_wrap(h3d_mat_Wrap.Clamp)
        _hx_local_11 = self
        _hx_local_12 = _hx_local_11.bits
        _hx_local_11.bits = (_hx_local_12 & 32767)
        _hx_local_11.bits
        if (((self.flags & ((1 << h3d_mat_TextureFlags.NoAlloc.index)))) == 0):
            self.alloc()

    def set_lastFrame(self,lf):
        if (self._lastFrame != h3d_mat_Texture.PREVENT_AUTO_DISPOSE):
            self._lastFrame = lf
        return self._lastFrame

    def get_lastFrame(self):
        return self._lastFrame

    def get_mipLevels(self):
        if (((self.flags & ((1 << h3d_mat_TextureFlags.MipMapped.index)))) == 0):
            return 1
        lv = 1
        w = self.width
        h = self.height
        while (((w >> lv) >= 1) or (((h >> lv) >= 1))):
            lv = (lv + 1)
        return lv

    def get_layerCount(self):
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0):
            return 6
        else:
            return 1

    def alloc(self):
        if (self.t is None):
            self.mem.allocTexture(self)

    def isSRGB(self):
        tmp = self.format.index
        if ((tmp == 15) or ((tmp == 14))):
            return True
        else:
            return False

    def checkAlloc(self):
        if ((self.t is None) and ((self.realloc is not None))):
            self.alloc()
            self.realloc()

    def clone(self):
        self.checkAlloc()
        if (self.t is None):
            raise haxe_Exception.thrown("Can't clone disposed texture")
        old = self.get_lastFrame()
        self.preventAutoDispose()
        flags = []
        f = h3d_mat_TextureFlags.Target
        if (((self.flags & ((1 << f.index)))) != 0):
            flags.append(f)
        f = h3d_mat_TextureFlags.Cube
        if (((self.flags & ((1 << f.index)))) != 0):
            flags.append(f)
        f = h3d_mat_TextureFlags.MipMapped
        if (((self.flags & ((1 << f.index)))) != 0):
            flags.append(f)
        f = h3d_mat_TextureFlags.IsArray
        if (((self.flags & ((1 << f.index)))) != 0):
            flags.append(f)
        t = h3d_mat_Texture(self.width,self.height,flags,self.format)
        t.name = self.name
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0):
            h3d_pass_CubeCopy.run(self,t)
        else:
            h3d_pass_Copy.run(self,t)
        self.set_lastFrame(old)
        return t

    def preventAutoDispose(self):
        self.set_lastFrame(h3d_mat_Texture.PREVENT_AUTO_DISPOSE)

    def waitLoad(self,f):
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Loading.index)))) == 0):
            f()
            return
        if (self.waitLoads is None):
            self.waitLoads = []
        _this = self.waitLoads
        _this.append(f)

    def toString(self):
        _hx_str = self.name
        if (self.name is None):
            _hx_str = ("Texture_" + Std.string(self.id))
        return (((((("null" if _hx_str is None else _hx_str) + "(") + Std.string(self.width)) + "x") + Std.string(self.height)) + ")")

    def setName(self,n):
        self.name = n

    def set_mipMap(self,m):
        self.bits = ((self.bits & -4) | m.index)
        def _hx_local_1():
            def _hx_local_0():
                self.mipMap = m
                return self.mipMap
            return _hx_local_0()
        return _hx_local_1()

    def set_filter(self,f):
        self.bits = ((self.bits & -25) | ((f.index << 3)))
        def _hx_local_1():
            def _hx_local_0():
                self.filter = f
                return self.filter
            return _hx_local_0()
        return _hx_local_1()

    def set_wrap(self,w):
        self.bits = ((self.bits & -193) | ((w.index << 6)))
        def _hx_local_1():
            def _hx_local_0():
                self.wrap = w
                return self.wrap
            return _hx_local_0()
        return _hx_local_1()

    def isDisposed(self):
        if (self.t is None):
            return (self.realloc is None)
        else:
            return False

    def resize(self,width,height):
        self.dispose()
        tw = 1
        th = 1
        while (tw < width):
            tw = (tw << 1)
        while (th < height):
            th = (th << 1)
        if ((tw != width) or ((th != height))):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 | ((1 << h3d_mat_TextureFlags.IsNPOT.index)))
            _hx_local_2.flags
        else:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 & ((-1 - ((1 << h3d_mat_TextureFlags.IsNPOT.index)))))
            _hx_local_4.flags
        self.width = width
        self.height = height
        if (((self.flags & ((1 << h3d_mat_TextureFlags.NoAlloc.index)))) == 0):
            self.alloc()

    def clearF(self,r = None,g = None,b = None,a = None,layer = None):
        if (r is None):
            r = 0.
        if (g is None):
            g = 0.
        if (b is None):
            b = 0.
        if (a is None):
            a = 0.
        if (layer is None):
            layer = -1
        self.alloc()
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Target.index)))) == 0):
            raise haxe_Exception.thrown("Texture should be target")
        engine = h3d_Engine.CURRENT
        color = h3d_Vector(r,g,b,a)
        if (layer < 0):
            _g = 0
            _g1 = self.get_layerCount()
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                engine.pushTarget(self,i)
                engine.clearF(color)
                engine.popTarget()
        else:
            engine.pushTarget(self,layer)
            engine.clearF(color)
            engine.popTarget()

    def clear(self,color,alpha = None,layer = None):
        if (alpha is None):
            alpha = 1.
        if (layer is None):
            layer = -1
        self.alloc()
        if ((self.width == 0) or ((self.height == 0))):
            return
        if ((((self.flags & ((1 << h3d_mat_TextureFlags.Target.index)))) != 0) and (((self.width != 1) or ((self.height != 1))))):
            engine = h3d_Engine.CURRENT
            color1 = None
            try:
                color1 = int((((0. if ((alpha < 0.)) else (1. if ((alpha > 1.)) else alpha))) * 255))
            except BaseException as _g:
                None
                color1 = None
            color = (color | ((color1 << 24)))
            if (layer < 0):
                _g = 0
                _g1 = self.get_layerCount()
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    engine.pushTarget(self,i)
                    engine.clear(color)
                    engine.popTarget()
            else:
                engine.pushTarget(self,layer)
                engine.clear(color)
                engine.popTarget()
        else:
            p = hxd_Pixels.alloc(self.width,self.height,h3d_mat_Texture.nativeFormat)
            k = 0
            b = (color & 255)
            g = ((color >> 8) & 255)
            r = ((color >> 16) & 255)
            a = None
            try:
                a = int((alpha * 255))
            except BaseException as _g:
                None
                a = None
            a1 = a
            if (a1 < 0):
                a1 = 0
            elif (a1 > 255):
                a1 = 255
            tmp = h3d_mat_Texture.nativeFormat.index
            if (tmp == 1):
                tmp = r
                r = b
                b = tmp
            elif (tmp == 2):
                pass
            else:
                raise haxe_Exception.thrown("TODO")
            _g = 0
            _g1 = (self.width * self.height)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                pos = k
                k = (k + 1)
                p.bytes.b[pos] = (r & 255)
                pos1 = k
                k = (k + 1)
                p.bytes.b[pos1] = (g & 255)
                pos2 = k
                k = (k + 1)
                p.bytes.b[pos2] = (b & 255)
                pos3 = k
                k = (k + 1)
                p.bytes.b[pos3] = (a1 & 255)
            if (layer < 0):
                _g = 0
                _g1 = self.get_layerCount()
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    self.uploadPixels(p,0,i)
            else:
                self.uploadPixels(p,0,layer)
            p.dispose()

    def checkSize(self,width,height,mip):
        mw = (self.width >> mip)
        if (mw == 0):
            mw = 1
        mh = (self.height >> mip)
        if (mh == 0):
            mh = 1
        if ((width != mw) or ((height != mh))):
            raise haxe_Exception.thrown(((((((("Invalid upload size : " + Std.string(width)) + "x") + Std.string(height)) + " should be ") + Std.string(mw)) + "x") + Std.string(mh)))

    def checkMipMapGen(self,mipLevel,layer):
        if ((((mipLevel == 0) and ((((self.flags & ((1 << h3d_mat_TextureFlags.MipMapped.index)))) != 0))) and ((((self.flags & ((1 << h3d_mat_TextureFlags.ManualMipMapGen.index)))) == 0))) and ((layer == ((self.get_layerCount() - 1))))):
            self.mem.driver.generateMipMaps(self)

    def uploadBitmap(self,bmp,mipLevel = None,layer = None):
        if (mipLevel is None):
            mipLevel = 0
        if (layer is None):
            layer = 0
        self.alloc()
        self.checkSize(bmp.data.width,bmp.data.height,mipLevel)
        self.mem.driver.uploadTextureBitmap(self,bmp,mipLevel,layer)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 | ((1 << h3d_mat_TextureFlags.WasCleared.index)))
        _hx_local_0.flags
        self.checkMipMapGen(mipLevel,layer)

    def uploadPixels(self,pixels,mipLevel = None,layer = None):
        if (mipLevel is None):
            mipLevel = 0
        if (layer is None):
            layer = 0
        self.alloc()
        self.checkSize(pixels.width,pixels.height,mipLevel)
        self.mem.driver.uploadTexturePixels(self,pixels,mipLevel,layer)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 | ((1 << h3d_mat_TextureFlags.WasCleared.index)))
        _hx_local_0.flags
        self.checkMipMapGen(mipLevel,layer)

    def dispose(self):
        if (self.t is not None):
            self.mem.deleteTexture(self)

    def swapTexture(self,t):
        self.checkAlloc()
        t.checkAlloc()
        if (((self.t is None) and ((self.realloc is None))) or (((t.t is None) and ((t.realloc is None))))):
            raise haxe_Exception.thrown("One of the two texture is disposed")
        tmp = self.t
        self.t = t.t
        t.t = tmp

    def capturePixels(self,face = None,mipLevel = None,region = None):
        if (face is None):
            face = 0
        if (mipLevel is None):
            mipLevel = 0
        old = self.get_lastFrame()
        self.preventAutoDispose()
        pix = self.mem.driver.capturePixels(self,face,mipLevel,region)
        self.set_lastFrame(old)
        return pix

    @staticmethod
    def fromBitmap(bmp):
        t = h3d_mat_Texture(bmp.data.width,bmp.data.height)
        t.uploadBitmap(bmp)
        return t

    @staticmethod
    def fromPixels(pixels):
        t = h3d_mat_Texture(pixels.width,pixels.height)
        t.uploadPixels(pixels)
        return t

    @staticmethod
    def fromColor(color,alpha = None):
        if (alpha is None):
            alpha = 1.
        engine = h3d_Engine.CURRENT
        aval = None
        try:
            aval = int((alpha * 255))
        except BaseException as _g:
            None
            aval = None
        aval1 = aval
        if (aval1 < 0):
            aval1 = 0
        elif (aval1 > 255):
            aval1 = 255
        key = ((color & 16777215) | ((aval1 << 24)))
        t = engine.textureColorCache.h.get(key,None)
        if (t is not None):
            return t
        t = h3d_mat_Texture(1,1,None)
        t.clear(color,alpha)
        def _hx_local_0():
            t.clear(color,alpha)
        t.realloc = _hx_local_0
        engine.textureColorCache.set(key,t)
        return t

    @staticmethod
    def genDisc(size,color,alpha = None):
        if (alpha is None):
            alpha = 1.
        return h3d_mat_Texture.genTexture(0,size,color,alpha)

    @staticmethod
    def genTexture(mode,size,color,alpha):
        engine = h3d_Engine.CURRENT
        aval = None
        try:
            aval = int((alpha * 255))
        except BaseException as _g:
            None
            aval = None
        aval1 = aval
        if (aval1 < 0):
            aval1 = 0
        elif (aval1 > 255):
            aval1 = 255
        color = ((color & 16777215) | ((aval1 << 24)))
        key = ((Std.string((((size << 16) | mode))) + ",") + Std.string(color))
        k = h3d_mat_Texture.genTextureKeys.h.get(key,None)
        t = (None if ((k is None)) else engine.resCache.h.get(k,None))
        if (t is not None):
            return t
        if (k is None):
            k = _hx_AnonObject({})
            h3d_mat_Texture.genTextureKeys.h[key] = k
        t = h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.Target])
        def _hx_local_0():
            h3d_mat_Texture.drawGenTexture(t,color,mode)
        t.realloc = _hx_local_0
        h3d_mat_Texture.drawGenTexture(t,color,mode)
        engine.resCache.set(k,t)
        return t

    @staticmethod
    def drawGenTexture(t,color,mode):
        s = h3d_pass_ScreenFx(h3d_shader_GenTexture())
        engine = h3d_Engine.CURRENT
        _this = s.shader
        _this.constModified = True
        _this.mode__ = mode
        _this = s.shader.color__
        _this.x = ((((color >> 16) & 255)) / 255)
        _this.y = ((((color >> 8) & 255)) / 255)
        _this.z = (((color & 255)) / 255)
        _this.w = ((HxOverrides.rshift(color, 24)) / 255)
        engine.pushTarget(t)
        s.render()
        engine.popTarget()

    @staticmethod
    def defaultCubeTexture():
        engine = h3d_Engine.CURRENT
        t = engine.resCache.h.get(h3d_mat_Texture,None)
        if (t is not None):
            return t
        t = h3d_mat_Texture(1,1,[h3d_mat_TextureFlags.Cube])
        t.clear(2105376)
        def _hx_local_0():
            t.clear(2105376)
        t.realloc = _hx_local_0
        engine.resCache.set(h3d_mat_Texture,t)
        return t

    @staticmethod
    def genChecker(size):
        engine = h3d_Engine.CURRENT
        k = h3d_mat_Texture.checkerTextureKeys.h.get(size,None)
        t = (None if ((k is None)) else engine.resCache.h.get(k,None))
        if ((t is not None) and (not (((t.t is None) and ((t.realloc is None)))))):
            return t
        if (k is None):
            k = _hx_AnonObject({})
            h3d_mat_Texture.checkerTextureKeys.set(size,k)
        t = h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.NoAlloc])
        t1 = t
        size1 = size
        def _hx_local_0():
            h3d_mat_Texture.allocChecker(t1,size1)
        t.realloc = _hx_local_0
        engine.resCache.set(k,t)
        return t

    @staticmethod
    def genNoise(size):
        engine = h3d_Engine.CURRENT
        k = h3d_mat_Texture.noiseTextureKeys.h.get(size,None)
        t = (None if ((k is None)) else engine.resCache.h.get(k,None))
        if ((t is not None) and (not (((t.t is None) and ((t.realloc is None)))))):
            return t
        if (k is None):
            k = _hx_AnonObject({})
            h3d_mat_Texture.noiseTextureKeys.set(size,k)
        t = h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.NoAlloc])
        t1 = t
        size1 = size
        def _hx_local_0():
            h3d_mat_Texture.allocNoise(t1,size1)
        t.realloc = _hx_local_0
        engine.resCache.set(k,t)
        return t

    @staticmethod
    def allocNoise(t,size):
        b = hxd_BitmapData(size,size)
        _g = 0
        _g1 = size
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = size
            while (_g2 < _g3):
                y = _g2
                _g2 = (_g2 + 1)
                n = int((python_lib_Random.random() * 256))
                b.setPixel(x,y,(((-16777216 | n) | ((n << 8))) | ((n << 16))))
        t.uploadBitmap(b)
        b.data = None

    @staticmethod
    def allocChecker(t,size):
        b = hxd_BitmapData(size,size)
        b.clear(-1)
        _g = 0
        _g1 = (size >> 1)
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = (size >> 1)
            while (_g2 < _g3):
                y = _g2
                _g2 = (_g2 + 1)
                b.setPixel(x,y,-16777216)
                b.setPixel((x + ((size >> 1))),(y + ((size >> 1))),-16777216)
        t.uploadBitmap(b)
        b.data = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.t = None
        _hx_o.mem = None
        _hx_o.id = None
        _hx_o.name = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.flags = None
        _hx_o.format = None
        _hx_o.bits = None
        _hx_o.waitLoads = None
        _hx_o.mipMap = None
        _hx_o.filter = None
        _hx_o.wrap = None
        _hx_o.lodBias = None
        _hx_o.realloc = None
        _hx_o.depthBuffer = None
        _hx_o._lastFrame = None
h3d_mat_Texture._hx_class = h3d_mat_Texture
_hx_classes["h3d.mat.Texture"] = h3d_mat_Texture


class h3d_mat_TextureArray(h3d_mat_Texture):
    _hx_class_name = "h3d.mat.TextureArray"
    _hx_is_interface = "False"
    __slots__ = ("layers",)
    _hx_fields = ["layers"]
    _hx_methods = ["get_layerCount", "clone", "toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_mat_Texture


    def __init__(self,w,h,layers,flags = None,format = None):
        self.layers = layers
        if (flags is None):
            flags = []
        flags.append(h3d_mat_TextureFlags.IsArray)
        super().__init__(w,h,flags,format)

    def get_layerCount(self):
        return self.layers

    def clone(self):
        old = self.get_lastFrame()
        self.preventAutoDispose()
        t = h3d_mat_TextureArray(self.width,self.height,self.layers,None,self.format)
        h3d_pass_Copy.run(self,t)
        self.set_lastFrame(old)
        return t

    def toString(self):
        return (((HxOverrides.stringOrNull(super().toString()) + "[") + Std.string(self.layers)) + "]")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.layers = None
h3d_mat_TextureArray._hx_class = h3d_mat_TextureArray
_hx_classes["h3d.mat.TextureArray"] = h3d_mat_TextureArray


class h3d_pass_Base:
    _hx_class_name = "h3d.pass.Base"
    _hx_is_interface = "False"
    __slots__ = ("ctx", "name")
    _hx_fields = ["ctx", "name"]
    _hx_methods = ["compileShader", "setContext", "dispose", "draw"]

    def __init__(self,name):
        self.ctx = None
        self.name = name

    def compileShader(self,p):
        raise haxe_Exception.thrown("Not implemented for this pass")

    def setContext(self,ctx):
        self.ctx = ctx

    def dispose(self):
        pass

    def draw(self,passes,sort = None):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.ctx = None
        _hx_o.name = None
h3d_pass_Base._hx_class = h3d_pass_Base
_hx_classes["h3d.pass.Base"] = h3d_pass_Base


class h3d_pass_ScreenFx:
    _hx_class_name = "h3d.pass.ScreenFx"
    _hx_is_interface = "False"
    __slots__ = ("shader", "_hx_pass", "primitive", "manager", "_engine", "shaders", "buffers")
    _hx_fields = ["shader", "pass", "primitive", "manager", "_engine", "shaders", "buffers"]
    _hx_methods = ["get_engine", "copy", "setGlobals", "addShader", "removeShader", "getShader", "render", "dispose"]
    _hx_statics = ["run"]

    def __init__(self,shader,output = None):
        self.buffers = None
        self._engine = None
        self.primitive = None
        self.shader = shader
        self.shaders = hxsl_ShaderList(shader)
        self.manager = h3d_pass_ShaderManager(output)
        self._hx_pass = h3d_mat_Pass("screenfx",hxsl_ShaderList(shader))
        self._hx_pass.set_culling(h3d_mat_Face._hx_None)
        self._hx_pass.depth(False,h3d_mat_Compare.Always)

    def get_engine(self):
        if (self._engine is None):
            self._engine = h3d_Engine.CURRENT
        return self._engine

    def copy(self,src,dst):
        h3d_pass_Copy.run(src,dst)

    def setGlobals(self,ctx):
        _g = 0
        _g1 = ctx.sharedGlobals
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.manager.globals.map.set(g.gid,g.value)

    def addShader(self,s):
        self.shaders = hxsl_ShaderList.addSort(s,self.shaders)
        return self._hx_pass.addShader(s)

    def removeShader(self,s):
        prev = None
        cur = self.shaders
        while (cur is not None):
            if (cur.s == s):
                if (prev is None):
                    self.shaders = cur.next
                else:
                    prev.next = cur.next
                return True
            prev = cur
            cur = cur.next
        return False

    def getShader(self,cl):
        _g_l = self.shaders
        _g_last = None
        while (_g_l != _g_last):
            s = _g_l.s
            _g_l = _g_l.next
            s1 = s
            si = Std.downcast(s1,cl)
            if (si is not None):
                return si
        return None

    def render(self):
        if (self.primitive is None):
            self.primitive = h3d_prim_Plane2D.get()
        self.shader.flipY__ = (-1 if ((self.get_engine().driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) and ((self.get_engine().getCurrentTarget() is not None)))) else 1)
        rts = self.manager.compileShaders(self.shaders)
        self.get_engine().selectMaterial(self._hx_pass)
        self.get_engine().selectShader(rts)
        if (self.buffers is None):
            self.buffers = h3d_shader_Buffers(rts)
        else:
            _this = self.buffers
            _this.vertex.grow(rts.vertex)
            _this.fragment.grow(rts.fragment)
        self.manager.fillGlobals(self.buffers,rts)
        self.manager.fillParams(self.buffers,rts,self.shaders)
        self.get_engine().uploadShaderBuffers(self.buffers,0)
        self.get_engine().uploadShaderBuffers(self.buffers,1)
        self.get_engine().uploadShaderBuffers(self.buffers,2)
        self.primitive.render(self.get_engine())

    def dispose(self):
        pass

    @staticmethod
    def run(shader,output,layer = None):
        engine = h3d_Engine.CURRENT
        engine.pushTarget(output,layer)
        h3d_pass_ScreenFx(shader).render()
        engine.popTarget()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shader = None
        _hx_o._hx_pass = None
        _hx_o.primitive = None
        _hx_o.manager = None
        _hx_o._engine = None
        _hx_o.shaders = None
        _hx_o.buffers = None
h3d_pass_ScreenFx._hx_class = h3d_pass_ScreenFx
_hx_classes["h3d.pass.ScreenFx"] = h3d_pass_ScreenFx


class h3d_pass_Blur(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.Blur"
    _hx_is_interface = "False"
    __slots__ = ("cubeDir", "radius", "gain", "linear", "quality", "values", "offsets")
    _hx_fields = ["cubeDir", "radius", "gain", "linear", "quality", "values", "offsets"]
    _hx_methods = ["set_radius", "set_quality", "set_gain", "set_linear", "gauss", "calcValues", "getKernelSize", "apply"]
    _hx_statics = ["__meta__"]
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self,radius = None,gain = None,linear = None,quality = None):
        if (radius is None):
            radius = 1.
        if (gain is None):
            gain = 1.
        if (linear is None):
            linear = 0.
        if (quality is None):
            quality = 1.
        self.offsets = None
        self.values = None
        self.quality = None
        self.linear = None
        self.gain = None
        self.radius = None
        self.cubeDir = [h3d_Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d_Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0]), h3d_Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]
        super().__init__(h3d_shader_Blur())
        self.set_radius(radius)
        self.set_quality(quality)
        self.set_gain(gain)
        self.set_linear(linear)

    def set_radius(self,r):
        if (self.radius == r):
            return r
        self.values = None
        def _hx_local_1():
            def _hx_local_0():
                self.radius = r
                return self.radius
            return _hx_local_0()
        return _hx_local_1()

    def set_quality(self,q):
        if (self.quality == q):
            return q
        self.values = None
        def _hx_local_1():
            def _hx_local_0():
                self.quality = q
                return self.quality
            return _hx_local_0()
        return _hx_local_1()

    def set_gain(self,s):
        if (self.gain == s):
            return s
        self.values = None
        def _hx_local_1():
            def _hx_local_0():
                self.gain = s
                return self.gain
            return _hx_local_0()
        return _hx_local_1()

    def set_linear(self,b):
        if (self.linear == b):
            return b
        self.values = None
        def _hx_local_1():
            def _hx_local_0():
                self.linear = b
                return self.linear
            return _hx_local_0()
        return _hx_local_1()

    def gauss(self,x,s):
        if (s <= 0):
            if (x == 0):
                return 1
            else:
                return 0
        sq = (s * s)
        p = Math.pow(2.718281828459,(-((x * x)) / ((2 * sq))))
        v = ((2 * Math.PI) * sq)
        return (p / ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))

    def calcValues(self):
        self.values = []
        self.offsets = []
        tot = 0.
        f = self.quality
        qadj = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 0.7) + 0.3)
        width = None
        if (self.radius > 0):
            a = (self.radius - 1)
            width = Math.ceil(((((1 if ((a < 1)) else a)) * qadj) / 2))
        else:
            width = 0
        v = self.radius
        sigma = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        _g = 0
        _g1 = (width + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            i1 = (i * 2)
            i2 = (0 if ((i == 0)) else ((i * 2) - 1))
            g1 = self.gauss(i1,sigma)
            g2 = self.gauss(i2,sigma)
            g = (g1 + g2)
            python_internal_ArrayImpl._set(self.values, i, g)
            python_internal_ArrayImpl._set(self.offsets, i, (0 if ((i == 0)) else ((((g1 * i1) + ((g2 * i2)))) / (((g * i) * ((Math.NaN if ((qadj < 0)) else python_lib_Math.sqrt(qadj))))))))
            tot = (tot + g)
            if (i > 0):
                tot = (tot + g)
        minVal = ((self.values[0] if 0 < len(self.values) else None) * ((0.01 / qadj)))
        while (len(self.values) > 2):
            last = python_internal_ArrayImpl._get(self.values, (len(self.values) - 1))
            if (last > minVal):
                break
            tot = (tot - ((last * 2)))
            _this = self.values
            if (len(_this) != 0):
                _this.pop()
        tot = (tot / self.gain)
        _g = 0
        _g1 = len(self.values)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _hx_local_4 = self.values
            _hx_local_5 = i
            _hx_local_6 = (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
            python_internal_ArrayImpl._set(_hx_local_4, _hx_local_5, (_hx_local_6 / tot))
            (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        if (self.linear > 0):
            m = (self.gain / (((len(self.values) * 2) - 1)))
            _g = 0
            _g1 = len(self.values)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                a = (self.values[i] if i >= 0 and i < len(self.values) else None)
                python_internal_ArrayImpl._set(self.values, i, (a + ((self.linear * ((m - a))))))
                a1 = (self.offsets[i] if i >= 0 and i < len(self.offsets) else None)
                python_internal_ArrayImpl._set(self.offsets, i, (a1 + ((self.linear * ((((0 if ((i == 0)) else ((((i * 2) - 0.5)) / ((i * qadj))))) - a1))))))

    def getKernelSize(self):
        if (self.values is None):
            self.calcValues()
        if (self.radius <= 0):
            return 0
        else:
            return ((len(self.values) * 2) - 1)

    def apply(self,ctx,src,output = None):
        if ((self.radius <= 0) and ((self.shader.fixedColor__ is None))):
            if (output is not None):
                h3d_pass_Copy.run(src,output)
            return
        if (output is None):
            output = src
        if (self.values is None):
            self.calcValues()
        isCube = (((src.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0)
        faceCount = (6 if isCube else 1)
        tmp = ctx.textures.allocTarget((HxOverrides.stringOrNull(src.name) + "BlurTmp"),src.width,src.height,False,src.format,isCube)
        _this = self.shader
        _this.constModified = True
        _this.Quality__ = len(self.values)
        self.shader.values__ = self.values
        self.shader.offsets__ = self.offsets
        if isCube:
            self.shader.cubeTexture__ = src
            _this = self.shader
            _this.constModified = True
            _this.isCube__ = True
        else:
            self.shader.texture__ = src
            _this = self.shader
            _this.constModified = True
            _this.isCube__ = False
        _this = self.shader.pixel__
        x = (1 / src.width)
        y = 0
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        _g = 0
        _g1 = faceCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.get_engine().pushTarget(tmp,i)
            if isCube:
                self.shader.cubeDir__ = (self.cubeDir[i] if i >= 0 and i < len(self.cubeDir) else None)
            self.render()
            self.get_engine().popTarget()
        if isCube:
            self.shader.cubeTexture__ = tmp
        else:
            self.shader.texture__ = tmp
        _this = self.shader.pixel__
        x = 0
        y = (1 / src.height)
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        outDepth = output.depthBuffer
        output.depthBuffer = None
        _g = 0
        _g1 = faceCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.get_engine().pushTarget(output,i)
            if isCube:
                self.shader.cubeDir__ = (self.cubeDir[i] if i >= 0 and i < len(self.cubeDir) else None)
            self.render()
            self.get_engine().popTarget()
        output.depthBuffer = outDepth

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cubeDir = None
        _hx_o.radius = None
        _hx_o.gain = None
        _hx_o.linear = None
        _hx_o.quality = None
        _hx_o.values = None
        _hx_o.offsets = None
h3d_pass_Blur._hx_class = h3d_pass_Blur
_hx_classes["h3d.pass.Blur"] = h3d_pass_Blur


class hxsl_Shader:
    _hx_class_name = "hxsl.Shader"
    _hx_is_interface = "False"
    __slots__ = ("priority", "shader", "instance", "constBits", "constModified")
    _hx_fields = ["priority", "shader", "instance", "constBits", "constModified"]
    _hx_methods = ["initialize", "setPriority", "getParamValue", "getParamFloatValue", "updateConstants", "updateConstantsFinal", "clone", "toString"]

    def __init__(self):
        self.constModified = None
        self.constBits = None
        self.instance = None
        self.shader = None
        self.priority = 0
        self.initialize()

    def initialize(self):
        self.constModified = True
        if (self.shader is not None):
            return
        cl = Type.getClass(self)
        self.shader = Reflect.field(cl,"_SHADER")
        if (self.shader is None):
            curClass = cl
            while ((curClass is not None) and ((Reflect.field(curClass,"SRC") is None))):
                curClass = Type.getSuperClass(curClass)
            if (curClass is None):
                raise haxe_Exception.thrown((HxOverrides.stringOrNull(Type.getClassName(cl)) + " has no shader source"))
            self.shader = Reflect.field(curClass,"_SHADER")
            if (self.shader is None):
                self.shader = hxsl_SharedShader(Reflect.field(curClass,"SRC"))
                Reflect.setField(curClass,"_SHADER",self.shader)

    def setPriority(self,v):
        self.priority = v

    def getParamValue(self,index):
        raise haxe_Exception.thrown("assert")

    def getParamFloatValue(self,index):
        raise haxe_Exception.thrown("assert")

    def updateConstants(self,globals):
        raise haxe_Exception.thrown("assert")

    def updateConstantsFinal(self,globals):
        c = self.shader.consts
        while (c is not None):
            if (c.globalId == 0):
                c = c.next
                continue
            v = globals.map.h.get(c.globalId,None)
            _g = c.v.type
            tmp = _g.index
            if (tmp == 1):
                v1 = v
                if (HxOverrides.rshift(v1, c.bits) != 0):
                    raise haxe_Exception.thrown((((((("Constant " + HxOverrides.stringOrNull(c.v.name)) + " is outside range (") + Std.string(v1)) + " > ") + Std.string(((((1 << c.bits)) - 1)))) + ")"))
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.constBits
                _hx_local_0.constBits = (_hx_local_1 | ((v1 << c.pos)))
                _hx_local_0.constBits
            elif (tmp == 2):
                v2 = v
                if v2:
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2.constBits
                    _hx_local_2.constBits = (_hx_local_3 | ((1 << c.pos)))
                    _hx_local_2.constBits
            elif (tmp == 17):
                count = _g.params[0]
                if (v is None):
                    c = c.next
                    continue
                v3 = v
                sel = v3.channel
                if (v3.texture is None):
                    sel = hxsl_Channel.Unknown
                elif ((sel is None) or ((sel == hxsl_Channel.Unknown))):
                    count1 = count
                    if (count1 == 1):
                        if (v3.texture.format == h3d_mat_Texture.nativeFormat):
                            sel = hxsl_Channel.PackedFloat
                        else:
                            raise haxe_Exception.thrown((("Constant " + HxOverrides.stringOrNull(c.v.name)) + " does not define channel select value"))
                    elif (count1 == 3):
                        if (v3.texture.format == h3d_mat_Texture.nativeFormat):
                            sel = hxsl_Channel.PackedNormal
                        else:
                            raise haxe_Exception.thrown((("Constant " + HxOverrides.stringOrNull(c.v.name)) + " does not define channel select value"))
                    else:
                        raise haxe_Exception.thrown((("Constant " + HxOverrides.stringOrNull(c.v.name)) + " does not define channel select value"))
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.constBits
                _hx_local_4.constBits = (_hx_local_5 | (((((globals.allocChannelID(v3.texture) << 3) | sel.index)) << c.pos)))
                _hx_local_4.constBits
            else:
                raise haxe_Exception.thrown("assert")
            c = c.next
        _this = self.shader
        constBits = self.constBits
        i = _this.instanceCache.h.get(constBits,None)
        self.instance = (_this.makeInstance(constBits) if ((i is None)) else i)

    def clone(self):
        return self

    def toString(self):
        return Type.getClassName(Type.getClass(self))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.priority = None
        _hx_o.shader = None
        _hx_o.instance = None
        _hx_o.constBits = None
        _hx_o.constModified = None
hxsl_Shader._hx_class = hxsl_Shader
_hx_classes["hxsl.Shader"] = hxsl_Shader


class h3d_shader_ScreenShader(hxsl_Shader):
    _hx_class_name = "h3d.shader.ScreenShader"
    _hx_is_interface = "False"
    __slots__ = ("flipY__",)
    _hx_fields = ["flipY__"]
    _hx_methods = ["get_flipY", "set_flipY", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.flipY__ = 0
        super().__init__()

    def get_flipY(self):
        return self.flipY__

    def set_flipY(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.flipY__ = _v
                return self.flipY__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.flipY__
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_ScreenShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.flipY__ = None
h3d_shader_ScreenShader._hx_class = h3d_shader_ScreenShader
_hx_classes["h3d.shader.ScreenShader"] = h3d_shader_ScreenShader


class h3d_pass__Border_BorderShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.pass._Border.BorderShader"
    _hx_is_interface = "False"
    __slots__ = ("color__",)
    _hx_fields = ["color__"]
    _hx_methods = ["get_color", "set_color", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.color__ = h3d_Vector()
        super().__init__()

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.color__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__Border_BorderShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.color__ = self.color__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color__ = None
h3d_pass__Border_BorderShader._hx_class = h3d_pass__Border_BorderShader
_hx_classes["h3d.pass._Border.BorderShader"] = h3d_pass__Border_BorderShader


class h3d_pass_Border(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.Border"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["dispose"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self,width,height,size = None):
        if (size is None):
            size = 1
        super().__init__(h3d_pass__Border_BorderShader())
        this1 = list()
        bbuf = this1
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((size / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((size / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((size / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((size / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((((height - size)) / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((((height - size)) / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((((width - size)) / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((((width - size)) / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        self.primitive = h3d_prim_RawPrimitive(_hx_AnonObject({'vbuf': bbuf, 'stride': 2, 'quads': True}),True)
        _this = self.shader.color__
        x = 1
        y = 1
        z = 1
        w = 1
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = w

    def dispose(self):
        super().dispose()
        self.primitive.dispose()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_pass_Border._hx_class = h3d_pass_Border
_hx_classes["h3d.pass.Border"] = h3d_pass_Border


class h3d_pass__Copy_ArrayCopyShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.pass._Copy.ArrayCopyShader"
    _hx_is_interface = "False"
    __slots__ = ("texture__", "layer__")
    _hx_fields = ["texture__", "layer__"]
    _hx_methods = ["get_texture", "set_texture", "get_layer", "set_layer", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.texture__ = None
        self.layer__ = 0
        super().__init__()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def get_layer(self):
        return self.layer__

    def set_layer(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.layer__ = _v
                return self.layer__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texture__
        elif (index1 == 2):
            return self.layer__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__Copy_ArrayCopyShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texture__ = self.texture__
        s.layer__ = self.layer__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
        _hx_o.layer__ = None
h3d_pass__Copy_ArrayCopyShader._hx_class = h3d_pass__Copy_ArrayCopyShader
_hx_classes["h3d.pass._Copy.ArrayCopyShader"] = h3d_pass__Copy_ArrayCopyShader


class h3d_pass_ArrayCopy(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.ArrayCopy"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["apply"]
    _hx_statics = ["run"]
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self):
        super().__init__(h3d_pass__Copy_ArrayCopyShader())

    def apply(self,_hx_from,fromLayer,to,blend = None,customPass = None,layer = None):
        if (to is not None):
            self.get_engine().pushTarget(to,(layer if ((layer is not None)) else 0))
        self.shader.texture__ = _hx_from
        self.shader.layer__ = fromLayer
        if (customPass is not None):
            old = self._hx_pass
            self._hx_pass = customPass
            if (blend is not None):
                self._hx_pass.setBlendMode(blend)
            h = self.shaders
            while (h.next is not None):
                h = h.next
            h.next = self._hx_pass.shaders
            self.render()
            self._hx_pass = old
            h.next = None
        else:
            self._hx_pass.setBlendMode((h2d_BlendMode._hx_None if ((blend is None)) else blend))
            self.render()
        self.shader.texture__ = None
        self.shader.layer__ = 0
        if (to is not None):
            self.get_engine().popTarget()

    @staticmethod
    def run(_hx_from,fromLayer,to,blend = None,_hx_pass = None,layer = None):
        engine = h3d_Engine.CURRENT
        if (((((to is not None) and ((_hx_from is not None))) and (((blend is None) or ((blend == h2d_BlendMode._hx_None))))) and ((_hx_pass is None))) and engine.driver.copyTexture(_hx_from,to)):
            return
        inst = engine.resCache.h.get(h3d_pass_ArrayCopy,None)
        if (inst is None):
            inst = h3d_pass_ArrayCopy()
            engine.resCache.set(h3d_pass_ArrayCopy,inst)
        inst.apply(_hx_from,fromLayer,to,blend,_hx_pass,layer)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_pass_ArrayCopy._hx_class = h3d_pass_ArrayCopy
_hx_classes["h3d.pass.ArrayCopy"] = h3d_pass_ArrayCopy


class h3d_pass__Copy_CopyShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.pass._Copy.CopyShader"
    _hx_is_interface = "False"
    __slots__ = ("texture__",)
    _hx_fields = ["texture__"]
    _hx_methods = ["get_texture", "set_texture", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.texture__ = None
        super().__init__()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texture__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__Copy_CopyShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texture__ = self.texture__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
h3d_pass__Copy_CopyShader._hx_class = h3d_pass__Copy_CopyShader
_hx_classes["h3d.pass._Copy.CopyShader"] = h3d_pass__Copy_CopyShader


class h3d_pass_Copy(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.Copy"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["apply"]
    _hx_statics = ["run"]
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self):
        super().__init__(h3d_pass__Copy_CopyShader())

    def apply(self,_hx_from,to,blend = None,customPass = None,layer = None):
        if (to is not None):
            self.get_engine().pushTarget(to,(layer if ((layer is not None)) else 0))
        self.shader.texture__ = _hx_from
        if (customPass is not None):
            old = self._hx_pass
            self._hx_pass = customPass
            if (blend is not None):
                self._hx_pass.setBlendMode(blend)
            h = self.shaders
            while (h.next is not None):
                h = h.next
            h.next = self._hx_pass.shaders
            self.render()
            self._hx_pass = old
            h.next = None
        else:
            self._hx_pass.setBlendMode((h2d_BlendMode._hx_None if ((blend is None)) else blend))
            self.render()
        self.shader.texture__ = None
        if (to is not None):
            self.get_engine().popTarget()

    @staticmethod
    def run(_hx_from,to,blend = None,_hx_pass = None,layer = None):
        engine = h3d_Engine.CURRENT
        if ((((((to is not None) and ((_hx_from is not None))) and (((blend is None) or ((blend == h2d_BlendMode._hx_None))))) and ((_hx_pass is None))) and ((layer is None))) and engine.driver.copyTexture(_hx_from,to)):
            return
        inst = engine.resCache.h.get(h3d_pass_Copy,None)
        if (inst is None):
            inst = h3d_pass_Copy()
            engine.resCache.set(h3d_pass_Copy,inst)
        inst.apply(_hx_from,to,blend,_hx_pass,layer)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_pass_Copy._hx_class = h3d_pass_Copy
_hx_classes["h3d.pass.Copy"] = h3d_pass_Copy


class h3d_pass__CubeCopy_CubeCopyShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.pass._CubeCopy.CubeCopyShader"
    _hx_is_interface = "False"
    __slots__ = ("texture__", "mat__")
    _hx_fields = ["texture__", "mat__"]
    _hx_methods = ["get_texture", "set_texture", "get_mat", "set_mat", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.texture__ = None
        self.mat__ = h3d_Matrix()
        super().__init__()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def get_mat(self):
        return self.mat__

    def set_mat(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.mat__ = _v
                return self.mat__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texture__
        elif (index1 == 2):
            return self.mat__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__CubeCopy_CubeCopyShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texture__ = self.texture__
        s.mat__ = self.mat__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
        _hx_o.mat__ = None
h3d_pass__CubeCopy_CubeCopyShader._hx_class = h3d_pass__CubeCopy_CubeCopyShader
_hx_classes["h3d.pass._CubeCopy.CubeCopyShader"] = h3d_pass__CubeCopy_CubeCopyShader


class h3d_pass_CubeCopy(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.CubeCopy"
    _hx_is_interface = "False"
    __slots__ = ("cubeDir",)
    _hx_fields = ["cubeDir"]
    _hx_methods = ["apply"]
    _hx_statics = ["run"]
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self):
        self.cubeDir = [h3d_Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d_Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0]), h3d_Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]
        super().__init__(h3d_pass__CubeCopy_CubeCopyShader())

    def apply(self,_hx_from,to,blend = None,customPass = None):
        self.shader.texture__ = _hx_from
        _g = 0
        while (_g < 6):
            i = _g
            _g = (_g + 1)
            if (to is not None):
                self.get_engine().pushTarget(to,i)
            self.shader.mat__ = (self.cubeDir[i] if i >= 0 and i < len(self.cubeDir) else None)
            if (customPass is not None):
                old = self._hx_pass
                self._hx_pass = customPass
                if (blend is not None):
                    self._hx_pass.setBlendMode(blend)
                h = self.shaders
                while (h.next is not None):
                    h = h.next
                h.next = self._hx_pass.shaders
                self.render()
                self._hx_pass = old
                h.next = None
            else:
                self._hx_pass.setBlendMode((h2d_BlendMode._hx_None if ((blend is None)) else blend))
                self.render()
            if (to is not None):
                self.get_engine().popTarget()
        self.shader.texture__ = None

    @staticmethod
    def run(_hx_from,to,blend = None,_hx_pass = None):
        engine = h3d_Engine.CURRENT
        if (((((to is not None) and ((_hx_from is not None))) and (((blend is None) or ((blend == h2d_BlendMode._hx_None))))) and ((_hx_pass is None))) and engine.driver.copyTexture(_hx_from,to)):
            return
        inst = engine.resCache.h.get(h3d_pass_CubeCopy,None)
        if (inst is None):
            inst = h3d_pass_CubeCopy()
            engine.resCache.set(h3d_pass_CubeCopy,inst)
        inst.apply(_hx_from,to,blend,_hx_pass)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cubeDir = None
h3d_pass_CubeCopy._hx_class = h3d_pass_CubeCopy
_hx_classes["h3d.pass.CubeCopy"] = h3d_pass_CubeCopy


class h3d_pass_Default(h3d_pass_Base):
    _hx_class_name = "h3d.pass.Default"
    _hx_is_interface = "False"
    __slots__ = ("manager", "defaultSort", "cameraView_id", "cameraNear_id", "cameraFar_id", "cameraProj_id", "cameraPos_id", "cameraProjDiag_id", "cameraProjFlip_id", "cameraViewProj_id", "cameraInverseViewProj_id", "globalTime_id", "pixelSize_id", "globalModelView_id", "globalModelViewInverse_id")
    _hx_fields = ["manager", "defaultSort", "cameraView_id", "cameraNear_id", "cameraFar_id", "cameraProj_id", "cameraPos_id", "cameraProjDiag_id", "cameraProjFlip_id", "cameraViewProj_id", "cameraInverseViewProj_id", "globalTime_id", "pixelSize_id", "globalModelView_id", "globalModelViewInverse_id"]
    _hx_methods = ["get_globals", "getCurrentPixelSize", "getOutputs", "compileShader", "processShaders", "setupShaders", "log", "drawObject", "draw", "get_cameraView", "set_cameraView", "get_cameraNear", "set_cameraNear", "get_cameraFar", "set_cameraFar", "get_cameraProj", "set_cameraProj", "get_cameraPos", "set_cameraPos", "get_cameraProjDiag", "set_cameraProjDiag", "get_cameraProjFlip", "set_cameraProjFlip", "get_cameraViewProj", "set_cameraViewProj", "get_cameraInverseViewProj", "set_cameraInverseViewProj", "get_globalTime", "set_globalTime", "get_pixelSize", "set_pixelSize", "get_globalModelView", "set_globalModelView", "get_globalModelViewInverse", "set_globalModelViewInverse", "initGlobals", "setGlobals"]
    _hx_statics = ["__meta__"]
    _hx_interfaces = []
    _hx_super = h3d_pass_Base


    def __init__(self,name):
        self.globalModelViewInverse_id = None
        self.globalModelView_id = None
        self.pixelSize_id = None
        self.globalTime_id = None
        self.cameraInverseViewProj_id = None
        self.cameraViewProj_id = None
        self.cameraProjFlip_id = None
        self.cameraProjDiag_id = None
        self.cameraPos_id = None
        self.cameraProj_id = None
        self.cameraFar_id = None
        self.cameraNear_id = None
        self.cameraView_id = None
        self.manager = None
        self.defaultSort = h3d_pass_SortByMaterial().sort
        super().__init__(name)
        self.manager = h3d_pass_ShaderManager(self.getOutputs())
        self.initGlobals()

    def get_globals(self):
        return self.manager.globals

    def getCurrentPixelSize(self):
        t = self.ctx.engine.getCurrentTarget()
        return h3d_Vector((2 / ((self.ctx.engine.width if ((t is None)) else t.width))),(2 / ((self.ctx.engine.height if ((t is None)) else t.height))))

    def getOutputs(self):
        return [hxsl_Output.Value("output.color")]

    def compileShader(self,p):
        o = h3d_pass_PassObject()
        o._hx_pass = p
        self.setupShaders(h3d_pass_PassList(o))
        return self.manager.compileShaders(o.shaders,p.batchMode)

    def processShaders(self,p,shaders):
        p = self.ctx.extraShaders
        while (p is not None):
            shaders = self.ctx.allocShaderList(p.s,shaders)
            p = p.next
        return shaders

    def setupShaders(self,passes):
        lightInit = False
        _g_o = passes.current
        while (_g_o is not None):
            tmp = _g_o
            _g_o = _g_o.next
            p = tmp
            shaders = p._hx_pass.getShadersRec()
            shaders = self.processShaders(p,shaders)
            if (p._hx_pass.enableLights and ((self.ctx.lightSystem is not None))):
                if (not lightInit):
                    self.ctx.lightSystem.initGlobals(self.manager.globals)
                    lightInit = True
                shaders = self.ctx.lightSystem.computeLight(p.obj,shaders)
            p.shader = self.manager.compileShaders(shaders,p._hx_pass.batchMode)
            p.shaders = shaders
            t = p.shader.fragment.textures
            if (t is None):
                p.texture = 0
            else:
                _this = self.manager
                opt = True
                if (opt is None):
                    opt = False
                t1 = None
                if (t.perObjectGlobal is not None):
                    v = _this.globals.map.h.get(t.perObjectGlobal.gid,None)
                    if (v is None):
                        raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(t.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_this.shaderInfo(shaders,t.perObjectGlobal.path))))
                    _g = t.type
                    t2 = None
                    if (_g.index == 17):
                        _g1 = _g.params[0]
                        t2 = True
                    else:
                        t2 = False
                    t1 = (Reflect.field(v,"texture") if t2 else v)
                else:
                    si = shaders
                    n = t.instance
                    while True:
                        n = (n - 1)
                        t3 = n
                        if (not ((t3 > 0))):
                            break
                        si = si.next
                    v1 = si.s.getParamValue(t.index)
                    if ((v1 is None) and (not opt)):
                        raise haxe_Exception.thrown(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(t.name)))
                    t1 = v1
                p.texture = (0 if ((t1 is None)) else t1.id)

    def log(self,_hx_str):
        pass

    def drawObject(self,p):
        self.ctx.drawPass = p
        self.ctx.engine.selectMaterial(p._hx_pass)
        p.obj.draw(self.ctx)

    def draw(self,passes,sort = None):
        if (passes.current is None):
            return
        _g = 0
        _g1 = self.ctx.sharedGlobals
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.manager.globals.map.set(g.gid,g.value)
        self.setGlobals()
        self.setupShaders(passes)
        if (sort is None):
            self.defaultSort(passes)
        else:
            sort(passes)
        self.ctx.currentManager = self.manager
        buf = self.ctx.shaderBuffers
        prevShader = None
        _g2_o = passes.current
        while (_g2_o is not None):
            tmp = _g2_o
            _g2_o = _g2_o.next
            p = tmp
            v = p.obj.absPos
            self.manager.globals.map.set(self.globalModelView_id,v)
            if (self.globalModelViewInverse_id in p.shader.globals.h):
                v1 = p.obj.getInvPos()
                self.manager.globals.map.set(self.globalModelViewInverse_id,v1)
            if (prevShader != p.shader):
                prevShader = p.shader
                self.ctx.engine.selectShader(p.shader)
                if (buf is None):
                    def _hx_local_1():
                        self.ctx.shaderBuffers = h3d_shader_Buffers(p.shader)
                        return self.ctx.shaderBuffers
                    buf = _hx_local_1()
                else:
                    s = p.shader
                    buf.vertex.grow(s.vertex)
                    buf.fragment.grow(s.fragment)
                self.manager.fillGlobals(buf,p.shader)
                self.ctx.engine.uploadShaderBuffers(buf,0)
            if (not p._hx_pass.dynamicParameters):
                self.manager.fillParams(buf,p.shader,p.shaders)
                self.ctx.engine.uploadShaderBuffers(buf,1)
                self.ctx.engine.uploadShaderBuffers(buf,2)
                self.ctx.engine.uploadShaderBuffers(buf,3)
            self.drawObject(p)
        _this = self.ctx
        _this.cachedPos = 0
        _this.drawPass = None

    def get_cameraView(self):
        return self.manager.globals.map.h.get(self.cameraView_id,None)

    def set_cameraView(self,v):
        self.manager.globals.map.set(self.cameraView_id,v)
        return v

    def get_cameraNear(self):
        return self.manager.globals.map.h.get(self.cameraNear_id,None)

    def set_cameraNear(self,v):
        self.manager.globals.map.set(self.cameraNear_id,v)
        return v

    def get_cameraFar(self):
        return self.manager.globals.map.h.get(self.cameraFar_id,None)

    def set_cameraFar(self,v):
        self.manager.globals.map.set(self.cameraFar_id,v)
        return v

    def get_cameraProj(self):
        return self.manager.globals.map.h.get(self.cameraProj_id,None)

    def set_cameraProj(self,v):
        self.manager.globals.map.set(self.cameraProj_id,v)
        return v

    def get_cameraPos(self):
        return self.manager.globals.map.h.get(self.cameraPos_id,None)

    def set_cameraPos(self,v):
        self.manager.globals.map.set(self.cameraPos_id,v)
        return v

    def get_cameraProjDiag(self):
        return self.manager.globals.map.h.get(self.cameraProjDiag_id,None)

    def set_cameraProjDiag(self,v):
        self.manager.globals.map.set(self.cameraProjDiag_id,v)
        return v

    def get_cameraProjFlip(self):
        return self.manager.globals.map.h.get(self.cameraProjFlip_id,None)

    def set_cameraProjFlip(self,v):
        self.manager.globals.map.set(self.cameraProjFlip_id,v)
        return v

    def get_cameraViewProj(self):
        return self.manager.globals.map.h.get(self.cameraViewProj_id,None)

    def set_cameraViewProj(self,v):
        self.manager.globals.map.set(self.cameraViewProj_id,v)
        return v

    def get_cameraInverseViewProj(self):
        return self.manager.globals.map.h.get(self.cameraInverseViewProj_id,None)

    def set_cameraInverseViewProj(self,v):
        self.manager.globals.map.set(self.cameraInverseViewProj_id,v)
        return v

    def get_globalTime(self):
        return self.manager.globals.map.h.get(self.globalTime_id,None)

    def set_globalTime(self,v):
        self.manager.globals.map.set(self.globalTime_id,v)
        return v

    def get_pixelSize(self):
        return self.manager.globals.map.h.get(self.pixelSize_id,None)

    def set_pixelSize(self,v):
        self.manager.globals.map.set(self.pixelSize_id,v)
        return v

    def get_globalModelView(self):
        return self.manager.globals.map.h.get(self.globalModelView_id,None)

    def set_globalModelView(self,v):
        self.manager.globals.map.set(self.globalModelView_id,v)
        return v

    def get_globalModelViewInverse(self):
        return self.manager.globals.map.h.get(self.globalModelViewInverse_id,None)

    def set_globalModelViewInverse(self,v):
        self.manager.globals.map.set(self.globalModelViewInverse_id,v)
        return v

    def initGlobals(self):
        this1 = hxsl_Globals.allocID("camera.view")
        self.cameraView_id = this1
        this1 = hxsl_Globals.allocID("camera.zNear")
        self.cameraNear_id = this1
        this1 = hxsl_Globals.allocID("camera.zFar")
        self.cameraFar_id = this1
        this1 = hxsl_Globals.allocID("camera.proj")
        self.cameraProj_id = this1
        this1 = hxsl_Globals.allocID("camera.position")
        self.cameraPos_id = this1
        this1 = hxsl_Globals.allocID("camera.projDiag")
        self.cameraProjDiag_id = this1
        this1 = hxsl_Globals.allocID("camera.projFlip")
        self.cameraProjFlip_id = this1
        this1 = hxsl_Globals.allocID("camera.viewProj")
        self.cameraViewProj_id = this1
        this1 = hxsl_Globals.allocID("camera.inverseViewProj")
        self.cameraInverseViewProj_id = this1
        this1 = hxsl_Globals.allocID("global.time")
        self.globalTime_id = this1
        this1 = hxsl_Globals.allocID("global.pixelSize")
        self.pixelSize_id = this1
        this1 = hxsl_Globals.allocID("global.modelView")
        self.globalModelView_id = this1
        this1 = hxsl_Globals.allocID("global.modelViewInverse")
        self.globalModelViewInverse_id = this1

    def setGlobals(self):
        v = self.ctx.camera.mcam
        self.manager.globals.map.set(self.cameraView_id,v)
        v = self.ctx.camera.zNear
        self.manager.globals.map.set(self.cameraNear_id,v)
        v = self.ctx.camera.zFar
        self.manager.globals.map.set(self.cameraFar_id,v)
        v = self.ctx.camera.mproj
        self.manager.globals.map.set(self.cameraProj_id,v)
        v = self.ctx.camera.pos
        self.manager.globals.map.set(self.cameraPos_id,v)
        v = h3d_Vector(self.ctx.camera.mproj._11,self.ctx.camera.mproj._22,self.ctx.camera.mproj._33,self.ctx.camera.mproj._44)
        self.manager.globals.map.set(self.cameraProjDiag_id,v)
        v = (-1 if ((self.ctx.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) and ((self.ctx.engine.getCurrentTarget() is not None)))) else 1)
        self.manager.globals.map.set(self.cameraProjFlip_id,v)
        v = self.ctx.camera.m
        self.manager.globals.map.set(self.cameraViewProj_id,v)
        v = self.ctx.camera.getInverseViewProj()
        self.manager.globals.map.set(self.cameraInverseViewProj_id,v)
        v = self.ctx.time
        self.manager.globals.map.set(self.globalTime_id,v)
        v = self.getCurrentPixelSize()
        self.manager.globals.map.set(self.pixelSize_id,v)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.manager = None
        _hx_o.defaultSort = None
        _hx_o.cameraView_id = None
        _hx_o.cameraNear_id = None
        _hx_o.cameraFar_id = None
        _hx_o.cameraProj_id = None
        _hx_o.cameraPos_id = None
        _hx_o.cameraProjDiag_id = None
        _hx_o.cameraProjFlip_id = None
        _hx_o.cameraViewProj_id = None
        _hx_o.cameraInverseViewProj_id = None
        _hx_o.globalTime_id = None
        _hx_o.pixelSize_id = None
        _hx_o.globalModelView_id = None
        _hx_o.globalModelViewInverse_id = None
h3d_pass_Default._hx_class = h3d_pass_Default
_hx_classes["h3d.pass.Default"] = h3d_pass_Default


class h3d_pass_Shadows(h3d_pass_Default):
    _hx_class_name = "h3d.pass.Shadows"
    _hx_is_interface = "False"
    __slots__ = ("lightCamera", "format", "staticTexture", "light", "enabled", "mode", "size", "shader", "blur", "samplingKind", "power", "bias", "pcfQuality", "pcfScale")
    _hx_fields = ["lightCamera", "format", "staticTexture", "light", "enabled", "mode", "size", "shader", "blur", "samplingKind", "power", "bias", "pcfQuality", "pcfScale"]
    _hx_methods = ["set_mode", "set_enabled", "set_size", "dispose", "getShadowProj", "getShadowTex", "isUsingWorldDist", "getOutputs", "loadStaticData", "saveStaticData", "computeStatic", "createDefaultShadowMap", "syncShader", "filterPasses", "cullPasses"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Default


    def __init__(self,light):
        self.blur = None
        self.shader = None
        self.light = None
        self.staticTexture = None
        self.format = None
        self.lightCamera = None
        self.pcfScale = 1.0
        self.pcfQuality = 1
        self.bias = 0.01
        self.power = 30.0
        self.samplingKind = h3d_pass_ShadowSamplingKind._hx_None
        self.size = 1024
        self.mode = h3d_pass_RenderMode._hx_None
        self.enabled = True
        if (self.format is None):
            self.format = hxd_PixelFormat.R16F
        if (not h3d_Engine.CURRENT.driver.isSupportedFormat(self.format)):
            self.format = h3d_mat_Texture.nativeFormat
        super().__init__("shadow")
        self.light = light
        self.blur = h3d_pass_Blur(5)
        self.blur.set_quality(0.5)
        _this = self.blur.shader
        _this.constModified = True
        _this.isDepth__ = (self.format == h3d_mat_Texture.nativeFormat)

    def set_mode(self,m):
        if (m != h3d_pass_RenderMode._hx_None):
            raise haxe_Exception.thrown(((("Shadow mode " + Std.string(m)) + " not supported for ") + Std.string(self.light)))
        def _hx_local_1():
            def _hx_local_0():
                self.mode = m
                return self.mode
            return _hx_local_0()
        return _hx_local_1()

    def set_enabled(self,b):
        def _hx_local_1():
            def _hx_local_0():
                self.enabled = b
                return self.enabled
            return _hx_local_0()
        return _hx_local_1()

    def set_size(self,s):
        if ((s != self.size) and ((self.staticTexture is not None))):
            self.staticTexture.dispose()
            self.staticTexture = None
        def _hx_local_1():
            def _hx_local_0():
                self.size = s
                return self.size
            return _hx_local_0()
        return _hx_local_1()

    def dispose(self):
        super().dispose()
        self.blur.dispose()
        if (self.staticTexture is not None):
            self.staticTexture.dispose()

    def getShadowProj(self):
        return self.lightCamera.m

    def getShadowTex(self):
        return None

    def isUsingWorldDist(self):
        return False

    def getOutputs(self):
        if self.isUsingWorldDist():
            return [hxsl_Output.Swiz(hxsl_Output.Value("output.worldDist",1),[hxsl_Component.X, hxsl_Component.X, hxsl_Component.X, hxsl_Component.X])]
        if (self.format == h3d_mat_Texture.nativeFormat):
            return [hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))]
        return [hxsl_Output.Swiz(hxsl_Output.Value("output.depth",1),[hxsl_Component.X, hxsl_Component.X, hxsl_Component.X, hxsl_Component.X])]

    def loadStaticData(self,_hx_bytes):
        return False

    def saveStaticData(self):
        return None

    def computeStatic(self,passes):
        raise haxe_Exception.thrown("Not implemented")

    def createDefaultShadowMap(self):
        tex = h3d_mat_Texture.fromColor(16777215)
        tex.name = "defaultShadowMap"
        return tex

    def syncShader(self,texture):
        pass

    def filterPasses(self,passes):
        if (not self.ctx.computingStatic):
            tmp = self.mode.index
            if (tmp == 0):
                return False
            elif (tmp == 1):
                tmp = None
                if (self.staticTexture is not None):
                    _this = self.staticTexture
                    tmp = ((_this.t is None) and ((_this.realloc is None)))
                else:
                    tmp = True
                if tmp:
                    self.staticTexture = self.createDefaultShadowMap()
                self.syncShader(self.staticTexture)
                return False
            elif (tmp == 2):
                return True
            elif (tmp == 3):
                tmp = None
                if (self.staticTexture is not None):
                    _this = self.staticTexture
                    tmp = ((_this.t is None) and ((_this.realloc is None)))
                else:
                    tmp = True
                if tmp:
                    self.staticTexture = self.createDefaultShadowMap()
                return True
            else:
                pass
        else:
            tmp = self.mode.index
            if (tmp == 0):
                return False
            elif (tmp == 1):
                head = None
                prev = None
                disc = passes.discarded
                discQueue = passes.lastDisc
                cur = passes.current
                while (cur is not None):
                    if (cur._hx_pass.isStatic == True):
                        if (head is None):
                            prev = cur
                            head = prev
                        else:
                            prev.next = cur
                            prev = cur
                    elif (disc is None):
                        discQueue = cur
                        disc = discQueue
                    else:
                        discQueue.next = cur
                        discQueue = cur
                    cur = cur.next
                if (prev is not None):
                    prev.next = None
                if (discQueue is not None):
                    discQueue.next = None
                passes.current = head
                passes.discarded = disc
                passes.lastDisc = discQueue
                return True
            elif (tmp == 2):
                return False
            elif (tmp == 3):
                head = None
                prev = None
                disc = passes.discarded
                discQueue = passes.lastDisc
                cur = passes.current
                while (cur is not None):
                    if (cur._hx_pass.isStatic == True):
                        if (head is None):
                            prev = cur
                            head = prev
                        else:
                            prev.next = cur
                            prev = cur
                    elif (disc is None):
                        discQueue = cur
                        disc = discQueue
                    else:
                        discQueue.next = cur
                        discQueue = cur
                    cur = cur.next
                if (prev is not None):
                    prev.next = None
                if (discQueue is not None):
                    discQueue.next = None
                passes.current = head
                passes.discarded = disc
                passes.lastDisc = discQueue
                return True
            else:
                pass

    def cullPasses(self,passes,f):
        prevCollider = None
        prevResult = True
        head = None
        prev = None
        disc = passes.discarded
        discQueue = passes.lastDisc
        cur = passes.current
        while (cur is not None):
            col = cur.obj.cullingCollider
            tmp = None
            if (col is None):
                tmp = True
            else:
                if (col != prevCollider):
                    prevCollider = col
                    prevResult = f(col)
                tmp = prevResult
            if tmp:
                if (head is None):
                    prev = cur
                    head = prev
                else:
                    prev.next = cur
                    prev = cur
            elif (disc is None):
                discQueue = cur
                disc = discQueue
            else:
                discQueue.next = cur
                discQueue = cur
            cur = cur.next
        if (prev is not None):
            prev.next = None
        if (discQueue is not None):
            discQueue.next = None
        passes.current = head
        passes.discarded = disc
        passes.lastDisc = discQueue

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lightCamera = None
        _hx_o.format = None
        _hx_o.staticTexture = None
        _hx_o.light = None
        _hx_o.enabled = None
        _hx_o.mode = None
        _hx_o.size = None
        _hx_o.shader = None
        _hx_o.blur = None
        _hx_o.samplingKind = None
        _hx_o.power = None
        _hx_o.bias = None
        _hx_o.pcfQuality = None
        _hx_o.pcfScale = None
h3d_pass_Shadows._hx_class = h3d_pass_Shadows
_hx_classes["h3d.pass.Shadows"] = h3d_pass_Shadows


class h3d_pass_DirShadowMap(h3d_pass_Shadows):
    _hx_class_name = "h3d.pass.DirShadowMap"
    _hx_is_interface = "False"
    _hx_fields = ["customDepth", "depth", "dshader", "border", "mergePass", "autoShrink", "maxDist", "minDist"]
    _hx_methods = ["set_mode", "set_enabled", "set_size", "dispose", "getShadowTex", "calcShadowBounds", "setGlobals", "syncShader", "saveStaticData", "loadStaticData", "draw", "computeStatic"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Shadows


    def __init__(self,light):
        self.border = None
        self.dshader = None
        self.depth = None
        self.customDepth = None
        self.minDist = -1.0
        self.maxDist = -1.0
        self.autoShrink = True
        self.mergePass = h3d_pass_ScreenFx(h3d_shader_MinMaxShader())
        super().__init__(light)
        self.lightCamera = h3d_Camera()
        self.lightCamera.orthoBounds = h3d_col_Bounds()
        def _hx_local_0():
            self.dshader = h3d_shader_DirShadow()
            return self.dshader
        self.shader = _hx_local_0()
        self.border = h3d_pass_Border(self.size,self.size)
        self.customDepth = h3d_Engine.CURRENT.driver.hasFeature(h3d_impl_Feature.AllocDepthBuffer)
        if (not self.customDepth):
            self.depth = h3d_mat_DepthBuffer.getDefault()

    def set_mode(self,m):
        _this = self.dshader
        _this.constModified = True
        _this.enable__ = (m != h3d_pass_RenderMode._hx_None)
        def _hx_local_1():
            def _hx_local_0():
                self.mode = m
                return self.mode
            return _hx_local_0()
        return _hx_local_1()

    def set_enabled(self,b):
        _this = self.dshader
        _this.constModified = True
        _this.enable__ = (b and ((self.mode != h3d_pass_RenderMode._hx_None)))
        def _hx_local_1():
            def _hx_local_0():
                self.enabled = b
                return self.enabled
            return _hx_local_0()
        return _hx_local_1()

    def set_size(self,s):
        if ((self.border is not None) and ((self.size != s))):
            self.border.dispose()
            self.border = h3d_pass_Border(s,s)
        return super().set_size(s)

    def dispose(self):
        super().dispose()
        if (self.customDepth and ((self.depth is not None))):
            self.depth.dispose()
        self.border.dispose()

    def getShadowTex(self):
        return self.dshader.shadowMap__

    def calcShadowBounds(self,camera):
        bounds = camera.orthoBounds
        if self.autoShrink:
            mtmp = h3d_Matrix()
            def _hx_local_0(m):
                if ((m.primitive is None) or (not m.material.castShadows)):
                    return
                b = m.primitive.getBounds()
                if (b.xMin > b.xMax):
                    return
                mtmp.multiply3x4(m.getAbsPos(),camera.mcam)
                x = b.xMin
                y = b.yMin
                z = b.zMin
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMin
                y = b.yMin
                z = b.zMax
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMin
                y = b.yMax
                z = b.zMin
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMin
                y = b.yMax
                z = b.zMax
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMax
                y = b.yMin
                z = b.zMin
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMax
                y = b.yMin
                z = b.zMax
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMax
                y = b.yMax
                z = b.zMin
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMax
                y = b.yMax
                z = b.zMax
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
            self.ctx.scene.iterVisibleMeshes(_hx_local_0)
        elif (self.mode == h3d_pass_RenderMode.Dynamic):
            bounds.xMin = -1e20
            bounds.xMax = 1e20
            bounds.yMin = -1e20
            bounds.yMax = 1e20
            bounds.zMin = -1e20
            bounds.zMax = 1e20
        if (self.mode == h3d_pass_RenderMode.Dynamic):
            cameraBounds = h3d_col_Bounds()
            zMax = 1.0
            zMin = 0.0
            n = self.ctx.camera.zNear
            f = self.ctx.camera.zFar
            if (self.maxDist > 0):
                f1 = self.maxDist
                _hx_min = n
                _hx_max = f
                if (_hx_max is None):
                    _hx_max = 1.
                if (_hx_min is None):
                    _hx_min = 0.
                zMax = (((((((f + n) - ((((2.0 * n) * f) / ((_hx_min if ((f1 < _hx_min)) else (_hx_max if ((f1 > _hx_max)) else f1))))))) / ((f - n))) + 1.0)) / 2.0)
            if (self.minDist > 0):
                f1 = self.minDist
                _hx_min = n
                _hx_max = f
                if (_hx_max is None):
                    _hx_max = 1.
                if (_hx_min is None):
                    _hx_min = 0.
                zMin = (((((((f + n) - ((((2.0 * n) * f) / ((_hx_min if ((f1 < _hx_min)) else (_hx_max if ((f1 > _hx_max)) else f1))))))) / ((f - n))) + 1.0)) / 2.0)
            _g = 0
            _g1 = self.ctx.camera.getFrustumCorners(zMax,zMin)
            while (_g < len(_g1)):
                pt = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                m = camera.mcam
                px = ((((pt.x * m._11) + ((pt.y * m._21))) + ((pt.z * m._31))) + ((pt.w * m._41)))
                py = ((((pt.x * m._12) + ((pt.y * m._22))) + ((pt.z * m._32))) + ((pt.w * m._42)))
                pz = ((((pt.x * m._13) + ((pt.y * m._23))) + ((pt.z * m._33))) + ((pt.w * m._43)))
                pw = ((((pt.x * m._14) + ((pt.y * m._24))) + ((pt.z * m._34))) + ((pt.w * m._44)))
                pt.x = px
                pt.y = py
                pt.z = pz
                pt.w = pw
                x = pt.x
                y = pt.y
                z = pt.z
                if (x < cameraBounds.xMin):
                    cameraBounds.xMin = x
                if (x > cameraBounds.xMax):
                    cameraBounds.xMax = x
                if (y < cameraBounds.yMin):
                    cameraBounds.yMin = y
                if (y > cameraBounds.yMax):
                    cameraBounds.yMax = y
                if (z < cameraBounds.zMin):
                    cameraBounds.zMin = z
                if (z > cameraBounds.zMax):
                    cameraBounds.zMax = z
            if self.autoShrink:
                cameraBounds.zMin = bounds.zMin
                bounds.intersection(bounds,cameraBounds)
            else:
                bounds.load(cameraBounds)
        bounds.scaleCenter(1.01)

    def setGlobals(self):
        super().setGlobals()
        if ((self.mode != h3d_pass_RenderMode.Mixed) or self.ctx.computingStatic):
            _this = self.lightCamera.orthoBounds
            _this.xMin = 1e20
            _this.xMax = -1e20
            _this.yMin = 1e20
            _this.yMax = -1e20
            _this.zMin = 1e20
            _this.zMax = -1e20
            self.calcShadowBounds(self.lightCamera)
            self.lightCamera.update()
        v = self.getShadowProj()
        self.manager.globals.map.set(self.cameraViewProj_id,v)

    def syncShader(self,texture):
        _this = self.dshader
        _this.constModified = True
        _this.shadowMap__ = texture
        _this = self.dshader
        _this.constModified = True
        _this.shadowMapChannel__ = (hxsl_Channel.PackedFloat if ((self.format == h3d_mat_Texture.nativeFormat)) else hxsl_Channel.R)
        self.dshader.shadowBias__ = self.bias
        self.dshader.shadowPower__ = self.power
        self.dshader.shadowProj__ = self.getShadowProj()
        _this = self.dshader
        _this.constModified = True
        _this.USE_ESM__ = (self.samplingKind == h3d_pass_ShadowSamplingKind.ESM)
        self.dshader.shadowPower__ = self.power
        _this = self.dshader
        _this.constModified = True
        _this.USE_PCF__ = (self.samplingKind == h3d_pass_ShadowSamplingKind.PCF)
        _this = self.dshader.shadowRes__
        x = texture.width
        y = texture.height
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        self.dshader.pcfScale__ = self.pcfScale
        _this = self.dshader
        _this.constModified = True
        _this.pcfQuality__ = self.pcfQuality

    def saveStaticData(self):
        if ((self.mode != h3d_pass_RenderMode.Mixed) and ((self.mode != h3d_pass_RenderMode.Static))):
            return None
        if (self.staticTexture is None):
            raise haxe_Exception.thrown("Data not computed")
        _hx_bytes = haxe_zip_Compress.run(self.staticTexture.capturePixels().bytes,9)
        buffer = haxe_io_BytesBuffer()
        buffer.addInt32(self.staticTexture.width)
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.pos.x))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.pos.y))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.pos.z))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.target.x))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.target.y))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.target.z))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.xMin))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.yMin))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.zMin))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.xMax))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.yMax))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.zMax))
        buffer.addInt32(_hx_bytes.length)
        buffer.b.extend(_hx_bytes.b)
        return buffer.getBytes()

    def loadStaticData(self,_hx_bytes):
        if (((self.mode != h3d_pass_RenderMode.Mixed) and ((self.mode != h3d_pass_RenderMode.Static))) or ((_hx_bytes is None))):
            return False
        buffer = haxe_io_BytesInput(_hx_bytes)
        size = buffer.readInt32()
        if (size != self.size):
            return False
        self.lightCamera.pos.x = buffer.readFloat()
        self.lightCamera.pos.y = buffer.readFloat()
        self.lightCamera.pos.z = buffer.readFloat()
        self.lightCamera.target.x = buffer.readFloat()
        self.lightCamera.target.y = buffer.readFloat()
        self.lightCamera.target.z = buffer.readFloat()
        self.lightCamera.orthoBounds.xMin = buffer.readFloat()
        self.lightCamera.orthoBounds.yMin = buffer.readFloat()
        self.lightCamera.orthoBounds.zMin = buffer.readFloat()
        self.lightCamera.orthoBounds.xMax = buffer.readFloat()
        self.lightCamera.orthoBounds.yMax = buffer.readFloat()
        self.lightCamera.orthoBounds.zMax = buffer.readFloat()
        self.lightCamera.update()
        _hx_len = buffer.readInt32()
        pixels = hxd_Pixels(size,size,haxe_zip_Uncompress.run(buffer.read(_hx_len)),self.format)
        if (self.staticTexture is not None):
            self.staticTexture.dispose()
        self.staticTexture = h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.Target],self.format)
        self.staticTexture.uploadPixels(pixels)
        self.staticTexture.name = "staticTexture"
        self.staticTexture.preventAutoDispose()
        self.syncShader(self.staticTexture)
        return True

    def draw(self,passes,sort = None):
        _gthis = self
        if (not self.enabled):
            return
        if (not self.filterPasses(passes)):
            return
        def _hx_local_0(col):
            return col.inFrustum(_gthis.lightCamera.frustum)
        f = _hx_local_0
        prevCollider = None
        prevResult = True
        head = None
        prev = None
        disc = passes.discarded
        discQueue = passes.lastDisc
        cur = passes.current
        while (cur is not None):
            col = cur.obj.cullingCollider
            tmp = None
            if (col is None):
                tmp = True
            else:
                if (col != prevCollider):
                    prevCollider = col
                    prevResult = f(col)
                tmp = prevResult
            if tmp:
                if (head is None):
                    prev = cur
                    head = prev
                else:
                    prev.next = cur
                    prev = cur
            elif (disc is None):
                discQueue = cur
                disc = discQueue
            else:
                discQueue.next = cur
                discQueue = cur
            cur = cur.next
        if (prev is not None):
            prev.next = None
        if (discQueue is not None):
            discQueue.next = None
        passes.current = head
        passes.discarded = disc
        passes.lastDisc = discQueue
        texture = self.ctx.textures.allocTarget("dirShadowMap",self.size,self.size,False,self.format)
        if (self.customDepth and (((((self.depth is None) or ((self.depth.width != self.size))) or ((self.depth.height != self.size))) or self.depth.isDisposed()))):
            if (self.depth is not None):
                self.depth.dispose()
            self.depth = h3d_mat_DepthBuffer(self.size,self.size)
        texture.depthBuffer = self.depth
        if ((self.mode != h3d_pass_RenderMode.Mixed) or self.ctx.computingStatic):
            ct = self.ctx.camera.target
            slight = (self.ctx.lightSystem.shadowLight if ((self.light is None)) else self.light)
            ldir = (None if ((slight is None)) else slight.getShadowDirection())
            if (ldir is None):
                _this = self.lightCamera.target
                x = 0
                y = 0
                z = -1
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                _this.x = x
                _this.y = y
                _this.z = z
                _this.w = 1.
            else:
                _this = self.lightCamera.target
                x = ldir.x
                y = ldir.y
                z = ldir.z
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                _this.x = x
                _this.y = y
                _this.z = z
                _this.w = 1.
                _this = self.lightCamera.target
                k = (((_this.x * _this.x) + ((_this.y * _this.y))) + ((_this.z * _this.z)))
                if (k < 1e-10):
                    k = 0
                else:
                    k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
                _this.x = (_this.x * k)
                _this.y = (_this.y * k)
                _this.z = (_this.z * k)
            _hx_local_4 = self.lightCamera.target
            _hx_local_5 = _hx_local_4.x
            _hx_local_4.x = (_hx_local_5 + ct.x)
            _hx_local_4.x
            _hx_local_6 = self.lightCamera.target
            _hx_local_7 = _hx_local_6.y
            _hx_local_6.y = (_hx_local_7 + ct.y)
            _hx_local_6.y
            _hx_local_8 = self.lightCamera.target
            _hx_local_9 = _hx_local_8.z
            _hx_local_8.z = (_hx_local_9 + ct.z)
            _hx_local_8.z
            _this = self.lightCamera.pos
            _this.x = ct.x
            _this.y = ct.y
            _this.z = ct.z
            _this.w = ct.w
            self.lightCamera.update()
        self.ctx.engine.pushTarget(texture)
        self.ctx.engine.clear(16777215,1)
        super().draw(passes,sort)
        if (self.border is not None):
            self.border.render()
        self.ctx.engine.popTarget()
        if ((self.mode == h3d_pass_RenderMode.Mixed) and (not self.ctx.computingStatic)):
            merge = self.ctx.textures.allocTarget("mergedDirShadowMap",self.size,self.size,False,self.format)
            self.mergePass.shader.texA__ = texture
            self.mergePass.shader.texB__ = self.staticTexture
            self.ctx.engine.pushTarget(merge)
            self.mergePass.render()
            self.ctx.engine.popTarget()
            texture = merge
        if ((self.blur.radius > 0) and (((self.mode != h3d_pass_RenderMode.Mixed) or (not self.ctx.computingStatic)))):
            self.blur.apply(self.ctx,texture)
        self.syncShader(texture)

    def computeStatic(self,passes):
        if ((self.mode != h3d_pass_RenderMode.Static) and ((self.mode != h3d_pass_RenderMode.Mixed))):
            return
        self.draw(passes)
        texture = self.dshader.shadowMap__
        old = self.staticTexture
        self.staticTexture = texture.clone()
        self.staticTexture.name = "StaticDirShadowMap"
        self.staticTexture.preventAutoDispose()
        _this = self.dshader
        _this.constModified = True
        _this.shadowMap__ = self.staticTexture
        if (old is not None):
            old.dispose()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.customDepth = None
        _hx_o.depth = None
        _hx_o.dshader = None
        _hx_o.border = None
        _hx_o.mergePass = None
        _hx_o.autoShrink = None
        _hx_o.maxDist = None
        _hx_o.minDist = None
h3d_pass_DirShadowMap._hx_class = h3d_pass_DirShadowMap
_hx_classes["h3d.pass.DirShadowMap"] = h3d_pass_DirShadowMap


class h3d_pass_DefaultShadowMap(h3d_pass_DirShadowMap):
    _hx_class_name = "h3d.pass.DefaultShadowMap"
    _hx_is_interface = "False"
    __slots__ = ("shadowMapId", "shadowProjId", "shadowColorId", "shadowPowerId", "shadowBiasId", "color")
    _hx_fields = ["shadowMapId", "shadowProjId", "shadowColorId", "shadowPowerId", "shadowBiasId", "color"]
    _hx_methods = ["draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_DirShadowMap


    def __init__(self,size = None,format = None):
        if (size is None):
            size = 1024
        self.color = None
        self.shadowBiasId = None
        self.shadowPowerId = None
        self.shadowColorId = None
        self.shadowProjId = None
        self.shadowMapId = None
        if (format is not None):
            self.format = format
        super().__init__(None)
        self.set_size(size)
        self.color = h3d_Vector()
        self.set_mode(h3d_pass_RenderMode.Dynamic)
        self.shadowMapId = hxsl_Globals.allocID("shadow.map")
        self.shadowProjId = hxsl_Globals.allocID("shadow.proj")
        self.shadowColorId = hxsl_Globals.allocID("shadow.color")
        self.shadowPowerId = hxsl_Globals.allocID("shadow.power")
        self.shadowBiasId = hxsl_Globals.allocID("shadow.bias")

    def draw(self,passes,sort = None):
        super().draw(passes,sort)
        self.ctx.setGlobalID(self.shadowMapId,_hx_AnonObject({'texture': self.dshader.shadowMap__, 'channel': (hxsl_Channel.PackedFloat if ((self.format == h3d_mat_Texture.nativeFormat)) else hxsl_Channel.R)}))
        self.ctx.setGlobalID(self.shadowProjId,self.getShadowProj())
        self.ctx.setGlobalID(self.shadowColorId,self.color)
        self.ctx.setGlobalID(self.shadowPowerId,self.power)
        self.ctx.setGlobalID(self.shadowBiasId,self.bias)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shadowMapId = None
        _hx_o.shadowProjId = None
        _hx_o.shadowColorId = None
        _hx_o.shadowPowerId = None
        _hx_o.shadowBiasId = None
        _hx_o.color = None
h3d_pass_DefaultShadowMap._hx_class = h3d_pass_DefaultShadowMap
_hx_classes["h3d.pass.DefaultShadowMap"] = h3d_pass_DefaultShadowMap


class h3d_pass__HardwarePick_FixedColor(hxsl_Shader):
    _hx_class_name = "h3d.pass._HardwarePick.FixedColor"
    _hx_is_interface = "False"
    __slots__ = ("colorID__", "viewport__")
    _hx_fields = ["colorID__", "viewport__"]
    _hx_methods = ["get_colorID", "set_colorID", "get_viewport", "set_viewport", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.viewport__ = h3d_Vector()
        self.colorID__ = h3d_Vector()
        super().__init__()

    def get_colorID(self):
        return self.colorID__

    def set_colorID(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.colorID__ = _v
                return self.colorID__
            return _hx_local_0()
        return _hx_local_1()

    def get_viewport(self):
        return self.viewport__

    def set_viewport(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.viewport__ = _v
                return self.viewport__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.colorID__
        elif (index1 == 1):
            return self.viewport__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__HardwarePick_FixedColor)
        s.shader = self.shader
        s.colorID__ = self.colorID__
        s.viewport__ = self.viewport__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.colorID__ = None
        _hx_o.viewport__ = None
h3d_pass__HardwarePick_FixedColor._hx_class = h3d_pass__HardwarePick_FixedColor
_hx_classes["h3d.pass._HardwarePick.FixedColor"] = h3d_pass__HardwarePick_FixedColor


class h3d_pass_HardwarePick(h3d_pass_Default):
    _hx_class_name = "h3d.pass.HardwarePick"
    _hx_is_interface = "False"
    __slots__ = ("pickX", "pickY", "fixedColor", "colorID", "texOut", "material", "pickedIndex")
    _hx_fields = ["pickX", "pickY", "fixedColor", "colorID", "texOut", "material", "pickedIndex"]
    _hx_methods = ["dispose", "getOutputs", "drawObject", "nextID", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Default


    def __init__(self):
        self.material = None
        self.texOut = None
        self.colorID = None
        self.pickY = None
        self.pickX = None
        self.pickedIndex = -1
        self.fixedColor = h3d_pass__HardwarePick_FixedColor()
        super().__init__("hwpick")
        self.material = h3d_mat_Pass("")
        _this = self.material
        src = h3d_mat_Blend.One
        dst = h3d_mat_Blend.Zero
        _this.set_blendSrc(src)
        _this.set_blendAlphaSrc(src)
        _this.set_blendDst(dst)
        _this.set_blendAlphaDst(dst)
        self.texOut = h3d_mat_Texture(3,3,[h3d_mat_TextureFlags.Target])
        self.texOut.depthBuffer = h3d_mat_DepthBuffer(3,3)

    def dispose(self):
        super().dispose()
        self.texOut.dispose()
        self.texOut.depthBuffer.dispose()

    def getOutputs(self):
        return [hxsl_Output.Value("output.colorID")]

    def drawObject(self,p):
        super().drawObject(p)
        _this = self.fixedColor.colorID__
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.colorID
            _hx_local_0.colorID = (_hx_local_1 + 1)
            return _hx_local_0.colorID
        c = (-16777216 | _hx_local_2())
        _this.x = ((((c >> 16) & 255)) / 255)
        _this.y = ((((c >> 8) & 255)) / 255)
        _this.z = (((c & 255)) / 255)
        _this.w = ((HxOverrides.rshift(c, 24)) / 255)

    def nextID(self):
        _this = self.fixedColor.colorID__
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.colorID
            _hx_local_0.colorID = (_hx_local_1 + 1)
            return _hx_local_0.colorID
        c = (-16777216 | _hx_local_2())
        _this.x = ((((c >> 16) & 255)) / 255)
        _this.y = ((((c >> 8) & 255)) / 255)
        _this.z = (((c & 255)) / 255)
        _this.w = ((HxOverrides.rshift(c, 24)) / 255)

    def draw(self,passes,sort = None):
        _g_o = passes.current
        while (_g_o is not None):
            tmp = _g_o
            _g_o = _g_o.next
            cur = tmp
            mask = 268435392
            _hx_local_0 = cur._hx_pass
            _hx_local_1 = _hx_local_0.bits
            _hx_local_0.bits = (_hx_local_1 & ~mask)
            _hx_local_0.bits
            _hx_local_2 = cur._hx_pass
            _hx_local_3 = _hx_local_2.bits
            _hx_local_2.bits = (_hx_local_3 | ((self.material.bits & mask)))
            _hx_local_2.bits
        self.colorID = 0
        _this = self.fixedColor.colorID__
        def _hx_local_6():
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.colorID
            _hx_local_4.colorID = (_hx_local_5 + 1)
            return _hx_local_4.colorID
        c = (-16777216 | _hx_local_6())
        _this.x = ((((c >> 16) & 255)) / 255)
        _this.y = ((((c >> 8) & 255)) / 255)
        _this.z = (((c & 255)) / 255)
        _this.w = ((HxOverrides.rshift(c, 24)) / 255)
        _this = self.fixedColor.viewport__
        x = -((((self.pickX * 2) / self.ctx.engine.width) - 1))
        y = (((self.pickY * 2) / self.ctx.engine.height) - 1)
        z = (self.ctx.engine.width / self.texOut.width)
        w = (self.ctx.engine.height / self.texOut.height)
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = w
        self.ctx.engine.pushTarget(self.texOut)
        self.ctx.engine.clear(-16777216,1)
        self.ctx.extraShaders = self.ctx.allocShaderList(self.fixedColor)
        super().draw(passes,sort)
        self.ctx.extraShaders = None
        self.ctx.engine.popTarget()
        _g1_o = passes.current
        while (_g1_o is not None):
            tmp = _g1_o
            _g1_o = _g1_o.next
            cur = tmp
            cur._hx_pass.set_blendSrc(cur._hx_pass.blendSrc)
            cur._hx_pass.set_blendDst(cur._hx_pass.blendDst)
            cur._hx_pass.set_blendOp(cur._hx_pass.blendOp)
            cur._hx_pass.set_blendAlphaSrc(cur._hx_pass.blendAlphaSrc)
            cur._hx_pass.set_blendAlphaDst(cur._hx_pass.blendAlphaDst)
            cur._hx_pass.set_blendAlphaOp(cur._hx_pass.blendAlphaOp)
            cur._hx_pass.colorMask = cur._hx_pass.colorMask
        self.ctx.engine.clear(None,None,0)
        pix = self.texOut.capturePixels()
        self.pickedIndex = (((pix.getPixel((pix.width >> 1),(pix.height >> 1)) & 16777215)) - 1)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pickX = None
        _hx_o.pickY = None
        _hx_o.fixedColor = None
        _hx_o.colorID = None
        _hx_o.texOut = None
        _hx_o.material = None
        _hx_o.pickedIndex = None
h3d_pass_HardwarePick._hx_class = h3d_pass_HardwarePick
_hx_classes["h3d.pass.HardwarePick"] = h3d_pass_HardwarePick


class h3d_pass_PassListIterator:
    _hx_class_name = "h3d.pass.PassListIterator"
    _hx_is_interface = "False"
    __slots__ = ("o",)
    _hx_fields = ["o"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,o):
        self.o = o

    def hasNext(self):
        return (self.o is not None)

    def next(self):
        tmp = self.o
        self.o = self.o.next
        return tmp

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.o = None
h3d_pass_PassListIterator._hx_class = h3d_pass_PassListIterator
_hx_classes["h3d.pass.PassListIterator"] = h3d_pass_PassListIterator


class h3d_pass_PassList:
    _hx_class_name = "h3d.pass.PassList"
    _hx_is_interface = "False"
    __slots__ = ("current", "discarded", "lastDisc")
    _hx_fields = ["current", "discarded", "lastDisc"]
    _hx_methods = ["init", "reset", "save", "load", "isEmpty", "clear", "sort", "filter", "iterator", "getFiltered"]

    def __init__(self,current = None):
        self.current = current
        def _hx_local_0():
            self.lastDisc = None
            return self.lastDisc
        self.discarded = _hx_local_0()

    def init(self,_hx_pass):
        self.current = _hx_pass
        def _hx_local_0():
            self.lastDisc = None
            return self.lastDisc
        self.discarded = _hx_local_0()

    def reset(self):
        if (self.discarded is not None):
            self.lastDisc.next = self.current
            self.current = self.discarded
            def _hx_local_0():
                self.lastDisc = None
                return self.lastDisc
            self.discarded = _hx_local_0()

    def save(self):
        return self.lastDisc

    def load(self,p):
        if (self.lastDisc != p):
            self.lastDisc.next = self.current
            if (p is None):
                self.current = self.discarded
                self.discarded = None
            else:
                self.current = p.next
                p.next = None
            self.lastDisc = p

    def isEmpty(self):
        return (self.current is None)

    def clear(self):
        if (self.current is None):
            return
        if (self.discarded is None):
            self.discarded = self.current
        else:
            self.lastDisc.next = self.current
        p = self.current
        while (p.next is not None):
            p = p.next
        self.lastDisc = p
        self.current = None

    def sort(self,f):
        _hx_list = self.current
        tmp = None
        if (_hx_list is None):
            tmp = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p = None
            q = None
            e = None
            tail = None
            while True:
                p = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p is not None):
                    nmerges = (nmerges + 1)
                    q = p
                    psize = 0
                    _g = 0
                    _g1 = insize
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        elif (((qsize == 0) or ((q is None))) or ((f(p,q) <= 0))):
                            e = p
                            p = p.next
                            psize = (psize - 1)
                        else:
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            tmp = _hx_list
        self.current = tmp

    def filter(self,f):
        head = None
        prev = None
        disc = self.discarded
        discQueue = self.lastDisc
        cur = self.current
        while (cur is not None):
            if f(cur):
                if (head is None):
                    prev = cur
                    head = prev
                else:
                    prev.next = cur
                    prev = cur
            elif (disc is None):
                discQueue = cur
                disc = discQueue
            else:
                discQueue.next = cur
                discQueue = cur
            cur = cur.next
        if (prev is not None):
            prev.next = None
        if (discQueue is not None):
            discQueue.next = None
        self.current = head
        self.discarded = disc
        self.lastDisc = discQueue

    def iterator(self):
        return h3d_pass_PassListIterator(self.current)

    def getFiltered(self):
        return h3d_pass_PassListIterator(self.discarded)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.current = None
        _hx_o.discarded = None
        _hx_o.lastDisc = None
h3d_pass_PassList._hx_class = h3d_pass_PassList
_hx_classes["h3d.pass.PassList"] = h3d_pass_PassList


class h3d_pass_PassObject:
    _hx_class_name = "h3d.pass.PassObject"
    _hx_is_interface = "False"
    __slots__ = ("next", "nextAlloc", "_hx_pass", "obj", "index", "shaders", "shader", "depth", "texture")
    _hx_fields = ["next", "nextAlloc", "pass", "obj", "index", "shaders", "shader", "depth", "texture"]

    def __init__(self):
        self.depth = None
        self.shader = None
        self.shaders = None
        self.index = None
        self.obj = None
        self._hx_pass = None
        self.nextAlloc = None
        self.next = None
        self.texture = 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.nextAlloc = None
        _hx_o._hx_pass = None
        _hx_o.obj = None
        _hx_o.index = None
        _hx_o.shaders = None
        _hx_o.shader = None
        _hx_o.depth = None
        _hx_o.texture = None
h3d_pass_PassObject._hx_class = h3d_pass_PassObject
_hx_classes["h3d.pass.PassObject"] = h3d_pass_PassObject


class h3d_pass_ShaderManager:
    _hx_class_name = "h3d.pass.ShaderManager"
    _hx_is_interface = "False"
    __slots__ = ("globals", "shaderCache", "currentOutput")
    _hx_fields = ["globals", "shaderCache", "currentOutput"]
    _hx_methods = ["setOutput", "fillRec", "shaderInfo", "getPtr", "getParamValue", "fillGlobals", "fillParams", "compileShaders"]
    _hx_statics = ["STRICT"]

    def __init__(self,output = None):
        self.shaderCache = hxsl_Cache.get()
        self.globals = hxsl_Globals()
        self.currentOutput = hxsl_ShaderList(None)
        self.setOutput(output)

    def setOutput(self,output = None):
        if (output is None):
            output = [hxsl_Output.Value("output.color")]
        self.currentOutput.s = self.shaderCache.getLinkShader(output)

    def fillRec(self,v,_hx_type,out,pos):
        tmp = _hx_type.index
        if (tmp == 1):
            val = v
            out[pos] = val
            return 1
        elif (tmp == 3):
            val = v
            out[pos] = val
            return 1
        elif (tmp == 5):
            _g = _hx_type.params[1]
            n = _hx_type.params[0]
            v1 = v
            index = pos
            pos = (pos + 1)
            val = v1.x
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = v1.y
            out[index] = val
            n1 = n
            if (n1 == 3):
                index = pos
                pos = (pos + 1)
                val = v1.z
                out[index] = val
            elif (n1 == 4):
                index = pos
                pos = (pos + 1)
                val = v1.z
                out[index] = val
                index = pos
                pos = (pos + 1)
                val = v1.w
                out[index] = val
            else:
                pass
            return n
        elif (tmp == 6):
            m = v
            index = pos
            pos = (pos + 1)
            val = m._11
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._21
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._31
            out[index] = val
            index = pos
            pos = (pos + 1)
            out[index] = 0
            index = pos
            pos = (pos + 1)
            val = m._12
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._22
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._32
            out[index] = val
            index = pos
            pos = (pos + 1)
            out[index] = 0
            index = pos
            pos = (pos + 1)
            val = m._13
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._23
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._33
            out[index] = val
            index = pos
            pos = (pos + 1)
            out[index] = 0
            return 12
        elif (tmp == 7):
            m = v
            index = pos
            pos = (pos + 1)
            val = m._11
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._21
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._31
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._41
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._12
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._22
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._32
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._42
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._13
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._23
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._33
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._43
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._14
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._24
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._34
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._44
            out[index] = val
            return 16
        elif (tmp == 8):
            m = v
            index = pos
            pos = (pos + 1)
            val = m._11
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._21
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._31
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._41
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._12
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._22
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._32
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._42
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._13
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._23
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._33
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._43
            out[index] = val
            return 12
        elif (tmp == 13):
            vl = _hx_type.params[0]
            tot = 0
            _g = 0
            while (_g < len(vl)):
                vv = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                tot = (tot + self.fillRec(Reflect.field(v,vv.name),vv.type,out,(pos + tot)))
            return tot
        elif (tmp == 15):
            _g = _hx_type.params[0]
            _g1 = _hx_type.params[1]
            tmp = _g.index
            if (tmp == 3):
                if (_g1.index == 0):
                    _hx_len = _g1.params[0]
                    v1 = v
                    size = 0
                    count = (len(v1) if ((len(v1) < _hx_len)) else _hx_len)
                    _g2 = 0
                    _g3 = count
                    while (_g2 < _g3):
                        i = _g2
                        _g2 = (_g2 + 1)
                        index = pos
                        pos = (pos + 1)
                        val = (v1[i] if i >= 0 and i < len(v1) else None)
                        out[index] = val
                    return _hx_len
                else:
                    raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))
            elif (tmp == 5):
                if (_g.params[0] == 4):
                    if (_g.params[1].index == 1):
                        if (_g1.index == 0):
                            _hx_len = _g1.params[0]
                            v1 = v
                            _g2 = 0
                            _g3 = _hx_len
                            while (_g2 < _g3):
                                i = _g2
                                _g2 = (_g2 + 1)
                                n = (v1[i] if i >= 0 and i < len(v1) else None)
                                if (n is None):
                                    break
                                index = pos
                                pos = (pos + 1)
                                val = n.x
                                out[index] = val
                                index1 = pos
                                pos = (pos + 1)
                                val1 = n.y
                                out[index1] = val1
                                index2 = pos
                                pos = (pos + 1)
                                val2 = n.z
                                out[index2] = val2
                                index3 = pos
                                pos = (pos + 1)
                                val3 = n.w
                                out[index3] = val3
                            return (_hx_len * 4)
                        else:
                            raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))
                    elif (_g1.index == 0):
                        t = _g
                        _hx_len = _g1.params[0]
                        v1 = v
                        size = 0
                        _g2 = 0
                        _g3 = _hx_len
                        while (_g2 < _g3):
                            i = _g2
                            _g2 = (_g2 + 1)
                            n = (v1[i] if i >= 0 and i < len(v1) else None)
                            if (n is None):
                                break
                            size = self.fillRec(n,t,out,pos)
                            pos = (pos + size)
                        return (_hx_len * size)
                    else:
                        raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))
                elif (_g1.index == 0):
                    t = _g
                    _hx_len = _g1.params[0]
                    v1 = v
                    size = 0
                    _g2 = 0
                    _g3 = _hx_len
                    while (_g2 < _g3):
                        i = _g2
                        _g2 = (_g2 + 1)
                        n = (v1[i] if i >= 0 and i < len(v1) else None)
                        if (n is None):
                            break
                        size = self.fillRec(n,t,out,pos)
                        pos = (pos + size)
                    return (_hx_len * size)
                else:
                    raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))
            elif (tmp == 8):
                if (_g1.index == 0):
                    _hx_len = _g1.params[0]
                    v1 = v
                    _g2 = 0
                    _g3 = _hx_len
                    while (_g2 < _g3):
                        i = _g2
                        _g2 = (_g2 + 1)
                        m = (v1[i] if i >= 0 and i < len(v1) else None)
                        if (m is None):
                            break
                        index = pos
                        pos = (pos + 1)
                        val = m._11
                        out[index] = val
                        index1 = pos
                        pos = (pos + 1)
                        val1 = m._21
                        out[index1] = val1
                        index2 = pos
                        pos = (pos + 1)
                        val2 = m._31
                        out[index2] = val2
                        index3 = pos
                        pos = (pos + 1)
                        val3 = m._41
                        out[index3] = val3
                        index4 = pos
                        pos = (pos + 1)
                        val4 = m._12
                        out[index4] = val4
                        index5 = pos
                        pos = (pos + 1)
                        val5 = m._22
                        out[index5] = val5
                        index6 = pos
                        pos = (pos + 1)
                        val6 = m._32
                        out[index6] = val6
                        index7 = pos
                        pos = (pos + 1)
                        val7 = m._42
                        out[index7] = val7
                        index8 = pos
                        pos = (pos + 1)
                        val8 = m._13
                        out[index8] = val8
                        index9 = pos
                        pos = (pos + 1)
                        val9 = m._23
                        out[index9] = val9
                        index10 = pos
                        pos = (pos + 1)
                        val10 = m._33
                        out[index10] = val10
                        index11 = pos
                        pos = (pos + 1)
                        val11 = m._43
                        out[index11] = val11
                    return (_hx_len * 12)
                else:
                    raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))
            elif (_g1.index == 0):
                t = _g
                _hx_len = _g1.params[0]
                v1 = v
                size = 0
                _g = 0
                _g1 = _hx_len
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    n = (v1[i] if i >= 0 and i < len(v1) else None)
                    if (n is None):
                        break
                    size = self.fillRec(n,t,out,pos)
                    pos = (pos + size)
                return (_hx_len * size)
            else:
                raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))
        else:
            raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))

    def shaderInfo(self,shaders,path):
        _this = path.split(".")
        name = (None if ((len(_this) == 0)) else _this.pop())
        while (shaders is not None):
            inst = shaders.s.instance
            _g = 0
            _g1 = inst.shader.vars
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v.name == name):
                    return shaders.s.toString()
            shaders = shaders.next
        return "(not found)"

    def getPtr(self,data):
        return data

    def getParamValue(self,p,shaders,opt = None):
        if (opt is None):
            opt = False
        if (p.perObjectGlobal is not None):
            v = self.globals.map.h.get(p.perObjectGlobal.gid,None)
            if (v is None):
                raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(self.shaderInfo(shaders,p.perObjectGlobal.path))))
            _g = p.type
            tmp = None
            if (_g.index == 17):
                _g1 = _g.params[0]
                tmp = True
            else:
                tmp = False
            if tmp:
                return Reflect.field(v,"texture")
            return v
        si = shaders
        n = p.instance
        while True:
            n = (n - 1)
            tmp = n
            if (not ((tmp > 0))):
                break
            si = si.next
        v = si.s.getParamValue(p.index)
        if ((v is None) and (not opt)):
            raise haxe_Exception.thrown(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(p.name)))
        return v

    def fillGlobals(self,buf,s):
        _gthis = self
        s1 = s.vertex
        g = s1.globals
        ptr = buf.vertex.globals
        while (g is not None):
            v = _gthis.globals.map.h.get(g.gid,None)
            if (v is None):
                if (g.path == "__consts__"):
                    _gthis.fillRec(s1.consts,g.type,ptr,g.pos)
                    g = g.next
                    continue
                raise haxe_Exception.thrown(("Missing global value " + HxOverrides.stringOrNull(g.path)))
            _gthis.fillRec(v,g.type,ptr,g.pos)
            g = g.next
        s1 = s.fragment
        g = s1.globals
        ptr = buf.fragment.globals
        while (g is not None):
            v = _gthis.globals.map.h.get(g.gid,None)
            if (v is None):
                if (g.path == "__consts__"):
                    _gthis.fillRec(s1.consts,g.type,ptr,g.pos)
                    g = g.next
                    continue
                raise haxe_Exception.thrown(("Missing global value " + HxOverrides.stringOrNull(g.path)))
            _gthis.fillRec(v,g.type,ptr,g.pos)
            g = g.next

    def fillParams(self,buf,s,shaders):
        _gthis = self
        curInstance = -1
        curInstanceValue = None
        buf1 = buf.vertex
        s1 = s.vertex
        p = s1.params
        ptr = buf1.params
        while (p is not None):
            v = None
            if (p.perObjectGlobal is None):
                if (p.type == hxsl_Type.TFloat):
                    index = p.instance
                    i = None
                    if (curInstance == index):
                        i = curInstanceValue
                    else:
                        si = shaders
                        curInstance = index
                        while True:
                            index = (index - 1)
                            i1 = index
                            if (not ((i1 > 0))):
                                break
                            si = si.next
                        curInstanceValue = si.s
                        i = curInstanceValue
                    index1 = p.pos
                    val = i.getParamFloatValue(p.index)
                    ptr[index1] = val
                    p = p.next
                    continue
                index2 = p.instance
                v1 = None
                if (curInstance == index2):
                    v1 = curInstanceValue
                else:
                    si1 = shaders
                    curInstance = index2
                    while True:
                        index2 = (index2 - 1)
                        v2 = index2
                        if (not ((v2 > 0))):
                            break
                        si1 = si1.next
                    curInstanceValue = si1.s
                    v1 = curInstanceValue
                v = v1.getParamValue(p.index)
                if (v is None):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(curInstanceValue)) + ".") + HxOverrides.stringOrNull(p.name)))
            elif (p.perObjectGlobal is not None):
                v3 = _gthis.globals.map.h.get(p.perObjectGlobal.gid,None)
                if (v3 is None):
                    raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p.perObjectGlobal.path))))
                _g = p.type
                v4 = None
                if (_g.index == 17):
                    _g1 = _g.params[0]
                    v4 = True
                else:
                    v4 = False
                v = (Reflect.field(v3,"texture") if v4 else v3)
            else:
                si2 = shaders
                n = p.instance
                while True:
                    n = (n - 1)
                    v5 = n
                    if (not ((v5 > 0))):
                        break
                    si2 = si2.next
                v6 = si2.s.getParamValue(p.index)
                if (v6 is None):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(si2.s)) + ".") + HxOverrides.stringOrNull(p.name)))
                v = v6
            _gthis.fillRec(v,p.type,ptr,p.pos)
            p = p.next
        tid = 0
        p = s1.textures
        while (p is not None):
            opt = (not h3d_pass_ShaderManager.STRICT)
            if (opt is None):
                opt = False
            t = None
            if (p.perObjectGlobal is not None):
                v = _gthis.globals.map.h.get(p.perObjectGlobal.gid,None)
                if (v is None):
                    raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p.perObjectGlobal.path))))
                _g = p.type
                t1 = None
                if (_g.index == 17):
                    _g1 = _g.params[0]
                    t1 = True
                else:
                    t1 = False
                t = (Reflect.field(v,"texture") if t1 else v)
            else:
                si = shaders
                n = p.instance
                while True:
                    n = (n - 1)
                    t2 = n
                    if (not ((t2 > 0))):
                        break
                    si = si.next
                v1 = si.s.getParamValue(p.index)
                if ((v1 is None) and (not opt)):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(p.name)))
                t = v1
            if (p.pos < 0):
                arr = t
                _g2 = 0
                _g3 = -p.pos
                while (_g2 < _g3):
                    i = _g2
                    _g2 = (_g2 + 1)
                    index = tid
                    tid = (tid + 1)
                    val = (arr[i] if i >= 0 and i < len(arr) else None)
                    buf1.tex[index] = val
            else:
                index1 = tid
                tid = (tid + 1)
                val1 = t
                buf1.tex[index1] = val1
            p = p.next
        p = s1.buffers
        bid = 0
        while (p is not None):
            opt = (not h3d_pass_ShaderManager.STRICT)
            if (opt is None):
                opt = False
            b = None
            if (p.perObjectGlobal is not None):
                v = _gthis.globals.map.h.get(p.perObjectGlobal.gid,None)
                if (v is None):
                    raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p.perObjectGlobal.path))))
                _g = p.type
                b1 = None
                if (_g.index == 17):
                    _g1 = _g.params[0]
                    b1 = True
                else:
                    b1 = False
                b = (Reflect.field(v,"texture") if b1 else v)
            else:
                si = shaders
                n = p.instance
                while True:
                    n = (n - 1)
                    b2 = n
                    if (not ((b2 > 0))):
                        break
                    si = si.next
                v1 = si.s.getParamValue(p.index)
                if ((v1 is None) and (not opt)):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(p.name)))
                b = v1
            index = bid
            bid = (bid + 1)
            buf1.buffers[index] = b
            p = p.next
        buf1 = buf.fragment
        s1 = s.fragment
        p = s1.params
        ptr = buf1.params
        while (p is not None):
            v = None
            if (p.perObjectGlobal is None):
                if (p.type == hxsl_Type.TFloat):
                    index = p.instance
                    i = None
                    if (curInstance == index):
                        i = curInstanceValue
                    else:
                        si = shaders
                        curInstance = index
                        while True:
                            index = (index - 1)
                            i1 = index
                            if (not ((i1 > 0))):
                                break
                            si = si.next
                        curInstanceValue = si.s
                        i = curInstanceValue
                    index1 = p.pos
                    val = i.getParamFloatValue(p.index)
                    ptr[index1] = val
                    p = p.next
                    continue
                index2 = p.instance
                v1 = None
                if (curInstance == index2):
                    v1 = curInstanceValue
                else:
                    si1 = shaders
                    curInstance = index2
                    while True:
                        index2 = (index2 - 1)
                        v2 = index2
                        if (not ((v2 > 0))):
                            break
                        si1 = si1.next
                    curInstanceValue = si1.s
                    v1 = curInstanceValue
                v = v1.getParamValue(p.index)
                if (v is None):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(curInstanceValue)) + ".") + HxOverrides.stringOrNull(p.name)))
            elif (p.perObjectGlobal is not None):
                v3 = _gthis.globals.map.h.get(p.perObjectGlobal.gid,None)
                if (v3 is None):
                    raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p.perObjectGlobal.path))))
                _g = p.type
                v4 = None
                if (_g.index == 17):
                    _g1 = _g.params[0]
                    v4 = True
                else:
                    v4 = False
                v = (Reflect.field(v3,"texture") if v4 else v3)
            else:
                si2 = shaders
                n = p.instance
                while True:
                    n = (n - 1)
                    v5 = n
                    if (not ((v5 > 0))):
                        break
                    si2 = si2.next
                v6 = si2.s.getParamValue(p.index)
                if (v6 is None):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(si2.s)) + ".") + HxOverrides.stringOrNull(p.name)))
                v = v6
            _gthis.fillRec(v,p.type,ptr,p.pos)
            p = p.next
        tid = 0
        p = s1.textures
        while (p is not None):
            opt = (not h3d_pass_ShaderManager.STRICT)
            if (opt is None):
                opt = False
            t = None
            if (p.perObjectGlobal is not None):
                v = _gthis.globals.map.h.get(p.perObjectGlobal.gid,None)
                if (v is None):
                    raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p.perObjectGlobal.path))))
                _g = p.type
                t1 = None
                if (_g.index == 17):
                    _g1 = _g.params[0]
                    t1 = True
                else:
                    t1 = False
                t = (Reflect.field(v,"texture") if t1 else v)
            else:
                si = shaders
                n = p.instance
                while True:
                    n = (n - 1)
                    t2 = n
                    if (not ((t2 > 0))):
                        break
                    si = si.next
                v1 = si.s.getParamValue(p.index)
                if ((v1 is None) and (not opt)):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(p.name)))
                t = v1
            if (p.pos < 0):
                arr = t
                _g2 = 0
                _g3 = -p.pos
                while (_g2 < _g3):
                    i = _g2
                    _g2 = (_g2 + 1)
                    index = tid
                    tid = (tid + 1)
                    val = (arr[i] if i >= 0 and i < len(arr) else None)
                    buf1.tex[index] = val
            else:
                index1 = tid
                tid = (tid + 1)
                val1 = t
                buf1.tex[index1] = val1
            p = p.next
        p = s1.buffers
        bid = 0
        while (p is not None):
            opt = (not h3d_pass_ShaderManager.STRICT)
            if (opt is None):
                opt = False
            b = None
            if (p.perObjectGlobal is not None):
                v = _gthis.globals.map.h.get(p.perObjectGlobal.gid,None)
                if (v is None):
                    raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p.perObjectGlobal.path))))
                _g = p.type
                b1 = None
                if (_g.index == 17):
                    _g1 = _g.params[0]
                    b1 = True
                else:
                    b1 = False
                b = (Reflect.field(v,"texture") if b1 else v)
            else:
                si = shaders
                n = p.instance
                while True:
                    n = (n - 1)
                    b2 = n
                    if (not ((b2 > 0))):
                        break
                    si = si.next
                v1 = si.s.getParamValue(p.index)
                if ((v1 is None) and (not opt)):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(p.name)))
                b = v1
            index = bid
            bid = (bid + 1)
            buf1.buffers[index] = b
            p = p.next

    def compileShaders(self,shaders,batchMode = None):
        if (batchMode is None):
            batchMode = False
        self.globals.maxChannels = 0
        _g_l = shaders
        _g_last = None
        while (_g_l != _g_last):
            s = _g_l.s
            _g_l = _g_l.next
            s1 = s
            s1.updateConstants(self.globals)
        self.currentOutput.next = shaders
        s = self.shaderCache.link(self.currentOutput,batchMode)
        self.currentOutput.next = None
        return s

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.globals = None
        _hx_o.shaderCache = None
        _hx_o.currentOutput = None
h3d_pass_ShaderManager._hx_class = h3d_pass_ShaderManager
_hx_classes["h3d.pass.ShaderManager"] = h3d_pass_ShaderManager

class h3d_pass_RenderMode(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.pass.RenderMode"
    _hx_constructs = ["None", "Static", "Dynamic", "Mixed"]
h3d_pass_RenderMode._hx_None = h3d_pass_RenderMode("None", 0, ())
h3d_pass_RenderMode.Static = h3d_pass_RenderMode("Static", 1, ())
h3d_pass_RenderMode.Dynamic = h3d_pass_RenderMode("Dynamic", 2, ())
h3d_pass_RenderMode.Mixed = h3d_pass_RenderMode("Mixed", 3, ())
h3d_pass_RenderMode._hx_class = h3d_pass_RenderMode
_hx_classes["h3d.pass.RenderMode"] = h3d_pass_RenderMode

class h3d_pass_ShadowSamplingKind(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.pass.ShadowSamplingKind"
    _hx_constructs = ["None", "PCF", "ESM"]
h3d_pass_ShadowSamplingKind._hx_None = h3d_pass_ShadowSamplingKind("None", 0, ())
h3d_pass_ShadowSamplingKind.PCF = h3d_pass_ShadowSamplingKind("PCF", 1, ())
h3d_pass_ShadowSamplingKind.ESM = h3d_pass_ShadowSamplingKind("ESM", 2, ())
h3d_pass_ShadowSamplingKind._hx_class = h3d_pass_ShadowSamplingKind
_hx_classes["h3d.pass.ShadowSamplingKind"] = h3d_pass_ShadowSamplingKind


class h3d_pass_SortByMaterial:
    _hx_class_name = "h3d.pass.SortByMaterial"
    _hx_is_interface = "False"
    __slots__ = ("shaderCount", "textureCount", "shaderIdMap", "textureIdMap")
    _hx_fields = ["shaderCount", "textureCount", "shaderIdMap", "textureIdMap"]
    _hx_methods = ["sort"]

    def __init__(self):
        self.textureCount = 1
        self.shaderCount = 1
        self.shaderIdMap = []
        self.textureIdMap = []

    def sort(self,passes):
        _gthis = self
        shaderStart = self.shaderCount
        textureStart = self.textureCount
        _g_o = passes.current
        while (_g_o is not None):
            tmp = _g_o
            _g_o = _g_o.next
            p = tmp
            if (python_internal_ArrayImpl._get(self.shaderIdMap, p.shader.id) < shaderStart):
                def _hx_local_2():
                    _hx_local_0 = self
                    _hx_local_1 = _hx_local_0.shaderCount
                    _hx_local_0.shaderCount = (_hx_local_1 + 1)
                    return _hx_local_1
                python_internal_ArrayImpl._set(self.shaderIdMap, p.shader.id, _hx_local_2())
            if (python_internal_ArrayImpl._get(self.textureIdMap, p.texture) < textureStart):
                def _hx_local_5():
                    _hx_local_3 = self
                    _hx_local_4 = _hx_local_3.textureCount
                    _hx_local_3.textureCount = (_hx_local_4 + 1)
                    return _hx_local_4
                python_internal_ArrayImpl._set(self.textureIdMap, p.texture, _hx_local_5())
        _hx_list = passes.current
        tmp = None
        if (_hx_list is None):
            tmp = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p = None
            q = None
            e = None
            tail = None
            while True:
                p = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p is not None):
                    nmerges = (nmerges + 1)
                    q = p
                    psize = 0
                    _g = 0
                    _g1 = insize
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        else:
                            tmp1 = None
                            if (not (((qsize == 0) or ((q is None))))):
                                d = (python_internal_ArrayImpl._get(_gthis.shaderIdMap, p.shader.id) - python_internal_ArrayImpl._get(_gthis.shaderIdMap, q.shader.id))
                                tmp1 = (((d if ((d != 0)) else (python_internal_ArrayImpl._get(_gthis.textureIdMap, p.texture) - python_internal_ArrayImpl._get(_gthis.textureIdMap, q.texture)))) <= 0)
                            else:
                                tmp1 = True
                            if tmp1:
                                e = p
                                p = p.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            tmp = _hx_list
        passes.current = tmp

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shaderCount = None
        _hx_o.textureCount = None
        _hx_o.shaderIdMap = None
        _hx_o.textureIdMap = None
h3d_pass_SortByMaterial._hx_class = h3d_pass_SortByMaterial
_hx_classes["h3d.pass.SortByMaterial"] = h3d_pass_SortByMaterial


class h3d_prim_BigPrimitive(h3d_prim_Primitive):
    _hx_class_name = "h3d.prim.BigPrimitive"
    _hx_is_interface = "False"
    __slots__ = ("isRaw", "stride", "buffers", "allIndexes", "tmpBuf", "tmpIdx", "bounds", "bufPos", "idxPos", "startIndex", "flushing", "hasTangents", "isStatic")
    _hx_fields = ["isRaw", "stride", "buffers", "allIndexes", "tmpBuf", "tmpIdx", "bounds", "bufPos", "idxPos", "startIndex", "flushing", "hasTangents", "isStatic"]
    _hx_methods = ["begin", "addPoint", "addBounds", "addVertexValue", "addIndex", "triCount", "vertexCount", "flush", "render", "getBounds", "dispose", "clear", "add", "addSub"]
    _hx_statics = ["PREV_BUFFER", "PREV_INDEX"]
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self,stride,isRaw = None):
        if (isRaw is None):
            isRaw = False
        self.flushing = None
        self.bounds = None
        self.tmpIdx = None
        self.tmpBuf = None
        self.allIndexes = None
        self.buffers = None
        self.stride = None
        self.isRaw = None
        self.isStatic = True
        self.hasTangents = False
        self.startIndex = 0
        self.idxPos = 0
        self.bufPos = 0
        super().__init__()
        self.isRaw = isRaw
        self.buffers = []
        self.allIndexes = []
        self.bounds = h3d_col_Bounds()
        self.stride = stride
        if (stride < 3):
            raise haxe_Exception.thrown("Minimum stride = 3")

    def begin(self,vcount,icount):
        x = (self.bufPos / self.stride)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        self.startIndex = tmp
        if ((self.startIndex + vcount) >= 65535):
            if (vcount >= 65535):
                raise haxe_Exception.thrown("Too many vertices in begin()")
            self.flush()
        if (self.tmpBuf is None):
            self.tmpBuf = h3d_prim_BigPrimitive.PREV_BUFFER
            if (self.tmpBuf is None):
                this1 = list()
                self.tmpBuf = this1
            else:
                h3d_prim_BigPrimitive.PREV_BUFFER = None
            if self.isStatic:
                this1 = self.tmpBuf
                v = (65535 * self.stride)
                if (v > len(this1)):
                    python_internal_ArrayImpl._set(this1, (v - 1), 0.)
        if (not self.isStatic):
            this1 = self.tmpBuf
            v = ((vcount * self.stride) + self.bufPos)
            if (v > len(this1)):
                python_internal_ArrayImpl._set(this1, (v - 1), 0.)
        if (self.tmpIdx is None):
            self.tmpIdx = h3d_prim_BigPrimitive.PREV_INDEX
            if (self.tmpIdx is None):
                this1 = list()
                self.tmpIdx = this1
            else:
                h3d_prim_BigPrimitive.PREV_INDEX = None
        if ((self.idxPos + icount) > len(self.tmpIdx)):
            size = (1024 if ((len(self.tmpIdx) == 0)) else len(self.tmpIdx))
            req = (self.idxPos + icount)
            while (size < req):
                size = (size << 1)
            this1 = self.tmpIdx
            if (size > len(this1)):
                python_internal_ArrayImpl._set(this1, (size - 1), 0)

    def addPoint(self,x,y,z):
        key = self.bufPos
        self.bufPos = (self.bufPos + 1)
        python_internal_ArrayImpl._set(self.tmpBuf, key, x)
        key = self.bufPos
        self.bufPos = (self.bufPos + 1)
        python_internal_ArrayImpl._set(self.tmpBuf, key, y)
        key = self.bufPos
        self.bufPos = (self.bufPos + 1)
        python_internal_ArrayImpl._set(self.tmpBuf, key, z)
        _this = self.bounds
        if (x < _this.xMin):
            _this.xMin = x
        if (x > _this.xMax):
            _this.xMax = x
        if (y < _this.yMin):
            _this.yMin = y
        if (y > _this.yMax):
            _this.yMax = y
        if (z < _this.zMin):
            _this.zMin = z
        if (z > _this.zMax):
            _this.zMax = z

    def addBounds(self,x,y,z):
        _this = self.bounds
        if (x < _this.xMin):
            _this.xMin = x
        if (x > _this.xMax):
            _this.xMax = x
        if (y < _this.yMin):
            _this.yMin = y
        if (y > _this.yMax):
            _this.yMax = y
        if (z < _this.zMin):
            _this.zMin = z
        if (z > _this.zMax):
            _this.zMax = z

    def addVertexValue(self,v):
        key = self.bufPos
        self.bufPos = (self.bufPos + 1)
        python_internal_ArrayImpl._set(self.tmpBuf, key, v)

    def addIndex(self,i):
        key = self.idxPos
        self.idxPos = (self.idxPos + 1)
        python_internal_ArrayImpl._set(self.tmpIdx, key, (i + self.startIndex))

    def triCount(self):
        count = 0
        _g = 0
        _g1 = self.allIndexes
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            count = (count + i.count)
        count = (count + self.idxPos)
        tmp = None
        try:
            tmp = int((count / 3))
        except BaseException as _g:
            None
            tmp = None
        return tmp

    def vertexCount(self):
        count = 0
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            count = (count + b.vertices)
        x = (self.bufPos / self.stride)
        count1 = None
        try:
            count1 = int(x)
        except BaseException as _g:
            None
            count1 = None
        count = (count + count1)
        return count

    def flush(self):
        if (self.tmpBuf is not None):
            if ((self.bufPos > 0) and ((self.idxPos > 0))):
                self.flushing = True
                b = self.tmpBuf
                b1 = self.stride
                x = (self.bufPos / self.stride)
                b2 = None
                try:
                    b2 = int(x)
                except BaseException as _g:
                    None
                    b2 = None
                b3 = h3d_Buffer.ofSubFloats(b,b1,b2)
                if self.isRaw:
                    b3.flags = (b3.flags | ((1 << h3d_BufferFlag.RawFormat.index)))
                _this = self.buffers
                _this.append(b3)
                idx = h3d_Indexes.alloc(self.tmpIdx,0,self.idxPos)
                _this = self.allIndexes
                _this.append(idx)
                self.flushing = False
            if ((h3d_prim_BigPrimitive.PREV_BUFFER is None) or ((len(h3d_prim_BigPrimitive.PREV_BUFFER) < len(self.tmpBuf)))):
                h3d_prim_BigPrimitive.PREV_BUFFER = self.tmpBuf
            if ((h3d_prim_BigPrimitive.PREV_INDEX is None) or ((len(h3d_prim_BigPrimitive.PREV_INDEX) < len(self.tmpIdx)))):
                h3d_prim_BigPrimitive.PREV_INDEX = self.tmpIdx
            self.tmpBuf = None
            self.tmpIdx = None
            self.bufPos = 0
            self.idxPos = 0
            self.startIndex = 0

    def render(self,engine):
        if (self.tmpBuf is not None):
            self.flush()
        _g = 0
        _g1 = len(self.buffers)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            engine.renderIndexed((self.buffers[i] if i >= 0 and i < len(self.buffers) else None),(self.allIndexes[i] if i >= 0 and i < len(self.allIndexes) else None))

    def getBounds(self):
        return self.bounds

    def dispose(self):
        self.clear()

    def clear(self):
        if self.flushing:
            raise haxe_Exception.thrown("Cannot clear() BigPrimitive while it's flushing")
        _this = self.bounds
        _this.xMin = 1e20
        _this.xMax = -1e20
        _this.yMin = 1e20
        _this.yMax = -1e20
        _this.zMin = 1e20
        _this.zMax = -1e20
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b.dispose()
        _g = 0
        _g1 = self.allIndexes
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            i.dispose()
        self.buffers = []
        self.allIndexes = []
        self.bufPos = 0
        self.idxPos = 0
        self.tmpBuf = None
        self.tmpIdx = None

    def add(self,buf,idx,dx = None,dy = None,dz = None,rotation = None,scale = None,stride = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        if (dz is None):
            dz = 0.
        if (rotation is None):
            rotation = 0.
        if (scale is None):
            scale = 1.
        if (stride is None):
            stride = -1
        x = (len(buf) / ((self.stride if ((stride < 0)) else stride)))
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        x = (len(idx) / 3)
        tmp1 = None
        try:
            tmp1 = int(x)
        except BaseException as _g:
            None
            tmp1 = None
        self.addSub(buf,idx,0,0,tmp,tmp1,dx,dy,dz,rotation,scale,stride)

    def addSub(self,buf,idx,startVert,startTri,nvert,triCount,dx = None,dy = None,dz = None,rotation = None,scale = None,stride = None,deltaU = None,deltaV = None,color = None,mat = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        if (dz is None):
            dz = 0.
        if (rotation is None):
            rotation = 0.
        if (scale is None):
            scale = 1.
        if (stride is None):
            stride = -1
        if (deltaU is None):
            deltaU = 0.
        if (deltaV is None):
            deltaV = 0.
        if (color is None):
            color = 1.
        if (stride < 0):
            stride = self.stride
        if (stride < self.stride):
            raise haxe_Exception.thrown((("only stride >= " + Std.string(self.stride)) + " allowed"))
        self.begin(nvert,(triCount * 3))
        start = self.startIndex
        cr = (Math.NaN if (((rotation == Math.POSITIVE_INFINITY) or ((rotation == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(rotation))
        sr = (Math.NaN if (((rotation == Math.POSITIVE_INFINITY) or ((rotation == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(rotation))
        pos = self.bufPos
        tmpBuf = self.tmpBuf
        _g = 0
        _g1 = nvert
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p = (((i + startVert)) * stride)
            key = p
            p = (p + 1)
            x = python_internal_ArrayImpl._get(buf, key)
            key1 = p
            p = (p + 1)
            y = python_internal_ArrayImpl._get(buf, key1)
            key2 = p
            p = (p + 1)
            z = python_internal_ArrayImpl._get(buf, key2)
            if (mat is not None):
                x1 = x
                y1 = y
                z1 = z
                if (z1 is None):
                    z1 = 0.
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                pt_x = x1
                pt_y = y1
                pt_z = z1
                px = ((((pt_x * mat._11) + ((pt_y * mat._21))) + ((pt_z * mat._31))) + mat._41)
                py = ((((pt_x * mat._12) + ((pt_y * mat._22))) + ((pt_z * mat._32))) + mat._42)
                pz = ((((pt_x * mat._13) + ((pt_y * mat._23))) + ((pt_z * mat._33))) + mat._43)
                pt_x = px
                pt_y = py
                pt_z = pz
                key3 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key3, pt_x)
                key4 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key4, pt_y)
                key5 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key5, pt_z)
                _this = self.bounds
                if (pt_x < _this.xMin):
                    _this.xMin = pt_x
                if (pt_x > _this.xMax):
                    _this.xMax = pt_x
                if (pt_y < _this.yMin):
                    _this.yMin = pt_y
                if (pt_y > _this.yMax):
                    _this.yMax = pt_y
                if (pt_z < _this.zMin):
                    _this.zMin = pt_z
                if (pt_z > _this.zMax):
                    _this.zMax = pt_z
            else:
                tx = ((((x * cr) - ((y * sr)))) * scale)
                ty = ((((x * sr) + ((y * cr)))) * scale)
                vx = (dx + tx)
                vy = (dy + ty)
                vz = (dz + ((z * scale)))
                key6 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key6, vx)
                key7 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key7, vy)
                key8 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key8, vz)
                _this1 = self.bounds
                if (vx < _this1.xMin):
                    _this1.xMin = vx
                if (vx > _this1.xMax):
                    _this1.xMax = vx
                if (vy < _this1.yMin):
                    _this1.yMin = vy
                if (vy > _this1.yMax):
                    _this1.yMax = vy
                if (vz < _this1.zMin):
                    _this1.zMin = vz
                if (vz > _this1.zMax):
                    _this1.zMax = vz
            if (self.stride >= 6):
                key9 = p
                p = (p + 1)
                nx = python_internal_ArrayImpl._get(buf, key9)
                key10 = p
                p = (p + 1)
                ny = python_internal_ArrayImpl._get(buf, key10)
                key11 = p
                p = (p + 1)
                nz = python_internal_ArrayImpl._get(buf, key11)
                if (mat is not None):
                    x2 = nx
                    y2 = ny
                    z2 = nz
                    if (z2 is None):
                        z2 = 0.
                    if (y2 is None):
                        y2 = 0.
                    if (x2 is None):
                        x2 = 0.
                    pt_x1 = x2
                    pt_y1 = y2
                    pt_z1 = z2
                    px1 = (((pt_x1 * mat._11) + ((pt_y1 * mat._21))) + ((pt_z1 * mat._31)))
                    py1 = (((pt_x1 * mat._12) + ((pt_y1 * mat._22))) + ((pt_z1 * mat._32)))
                    pz1 = (((pt_x1 * mat._13) + ((pt_y1 * mat._23))) + ((pt_z1 * mat._33)))
                    pt_x1 = px1
                    pt_y1 = py1
                    pt_z1 = pz1
                    k = (((pt_x1 * pt_x1) + ((pt_y1 * pt_y1))) + ((pt_z1 * pt_z1)))
                    if (k < 1e-10):
                        k = 0
                    else:
                        k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
                    pt_x1 = (pt_x1 * k)
                    pt_y1 = (pt_y1 * k)
                    pt_z1 = (pt_z1 * k)
                    key12 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key12, pt_x1)
                    key13 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key13, pt_y1)
                    key14 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key14, pt_z1)
                else:
                    tnx = ((nx * cr) - ((ny * sr)))
                    tny = ((nx * sr) + ((ny * cr)))
                    key15 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key15, tnx)
                    key16 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key16, tny)
                    key17 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key17, nz)
            stride1 = self.stride
            if self.hasTangents:
                key18 = p
                p = (p + 1)
                tx1 = python_internal_ArrayImpl._get(buf, key18)
                key19 = p
                p = (p + 1)
                ty1 = python_internal_ArrayImpl._get(buf, key19)
                key20 = p
                p = (p + 1)
                tz = python_internal_ArrayImpl._get(buf, key20)
                if (mat is not None):
                    x3 = tx1
                    y3 = ty1
                    z3 = tz
                    if (z3 is None):
                        z3 = 0.
                    if (y3 is None):
                        y3 = 0.
                    if (x3 is None):
                        x3 = 0.
                    pt_x2 = x3
                    pt_y2 = y3
                    pt_z2 = z3
                    _hx_len = (((pt_x2 * pt_x2) + ((pt_y2 * pt_y2))) + ((pt_z2 * pt_z2)))
                    px2 = (((pt_x2 * mat._11) + ((pt_y2 * mat._21))) + ((pt_z2 * mat._31)))
                    py2 = (((pt_x2 * mat._12) + ((pt_y2 * mat._22))) + ((pt_z2 * mat._32)))
                    pz2 = (((pt_x2 * mat._13) + ((pt_y2 * mat._23))) + ((pt_z2 * mat._33)))
                    pt_x2 = px2
                    pt_y2 = py2
                    pt_z2 = pz2
                    k1 = (((pt_x2 * pt_x2) + ((pt_y2 * pt_y2))) + ((pt_z2 * pt_z2)))
                    if (k1 < 1e-10):
                        k1 = 0
                    else:
                        k1 = (1. / ((Math.NaN if ((k1 < 0)) else python_lib_Math.sqrt(k1))))
                    pt_x2 = (pt_x2 * k1)
                    pt_y2 = (pt_y2 * k1)
                    pt_z2 = (pt_z2 * k1)
                    if (_hx_len < 0.5):
                        pt_x2 = (pt_x2 * 0.5)
                        pt_y2 = (pt_y2 * 0.5)
                        pt_z2 = (pt_z2 * 0.5)
                    key21 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key21, pt_x2)
                    key22 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key22, pt_y2)
                    key23 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key23, pt_z2)
                else:
                    tnx1 = ((tx1 * cr) - ((ty1 * sr)))
                    tny1 = ((tx1 * sr) + ((ty1 * cr)))
                    key24 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key24, tnx1)
                    key25 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key25, tny1)
                    key26 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key26, tz)
                stride1 = (stride1 - 3)
            stride2 = stride1
            if ((stride2 == 6) or ((stride2 == 3))):
                continue
            elif ((stride2 == 7) or ((stride2 == 4))):
                key27 = p
                p = (p + 1)
                key28 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key28, (python_internal_ArrayImpl._get(buf, key27) + deltaU))
            elif ((((stride2 == 10) or ((stride2 == 9))) or ((stride2 == 8))) or ((stride2 == 5))):
                key29 = p
                p = (p + 1)
                key30 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key30, (python_internal_ArrayImpl._get(buf, key29) + deltaU))
                key31 = p
                p = (p + 1)
                key32 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key32, (python_internal_ArrayImpl._get(buf, key31) + deltaV))
                _g2 = 8
                _g3 = stride1
                while (_g2 < _g3):
                    i1 = _g2
                    _g2 = (_g2 + 1)
                    key33 = p
                    p = (p + 1)
                    key34 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key34, python_internal_ArrayImpl._get(buf, key33))
            else:
                key35 = p
                p = (p + 1)
                key36 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key36, (python_internal_ArrayImpl._get(buf, key35) + deltaU))
                key37 = p
                p = (p + 1)
                key38 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key38, (python_internal_ArrayImpl._get(buf, key37) + deltaV))
                key39 = p
                p = (p + 1)
                key40 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key40, (python_internal_ArrayImpl._get(buf, key39) * color))
                key41 = p
                p = (p + 1)
                key42 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key42, (python_internal_ArrayImpl._get(buf, key41) * color))
                key43 = p
                p = (p + 1)
                key44 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key44, (python_internal_ArrayImpl._get(buf, key43) * color))
                _g4 = 11
                _g5 = stride1
                while (_g4 < _g5):
                    i2 = _g4
                    _g4 = (_g4 + 1)
                    key45 = p
                    p = (p + 1)
                    key46 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key46, python_internal_ArrayImpl._get(buf, key45))
        self.bufPos = pos
        start = (start - startVert)
        _g = 0
        _g1 = (triCount * 3)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            key = self.idxPos
            self.idxPos = (self.idxPos + 1)
            python_internal_ArrayImpl._set(self.tmpIdx, key, (python_internal_ArrayImpl._get(idx, (i + ((startTri * 3)))) + start))
    PREV_BUFFER = None
    PREV_INDEX = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.isRaw = None
        _hx_o.stride = None
        _hx_o.buffers = None
        _hx_o.allIndexes = None
        _hx_o.tmpBuf = None
        _hx_o.tmpIdx = None
        _hx_o.bounds = None
        _hx_o.bufPos = None
        _hx_o.idxPos = None
        _hx_o.startIndex = None
        _hx_o.flushing = None
        _hx_o.hasTangents = None
        _hx_o.isStatic = None
h3d_prim_BigPrimitive._hx_class = h3d_prim_BigPrimitive
_hx_classes["h3d.prim.BigPrimitive"] = h3d_prim_BigPrimitive


class h3d_prim_MeshPrimitive(h3d_prim_Primitive):
    _hx_class_name = "h3d.prim.MeshPrimitive"
    _hx_is_interface = "False"
    __slots__ = ("bufferCache", "layouts")
    _hx_fields = ["bufferCache", "layouts"]
    _hx_methods = ["allocBuffer", "hasBuffer", "addBuffer", "dispose", "getBuffers", "render"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self):
        self.layouts = None
        self.bufferCache = None
        super().__init__()

    def allocBuffer(self,engine,name):
        return None

    def hasBuffer(self,name):
        if (self.bufferCache is None):
            return False
        this1 = self.bufferCache
        return (hxsl_Globals.allocID(name) in this1.h)

    def addBuffer(self,name,buf,offset = None):
        if (offset is None):
            offset = 0
        if (self.bufferCache is None):
            self.bufferCache = haxe_ds_IntMap()
        id = hxsl_Globals.allocID(name)
        old = self.bufferCache.h.get(id,None)
        if (old is not None):
            old.dispose()
        self.bufferCache.set(id,h3d_BufferOffset(buf,offset))
        self.layouts = None

    def dispose(self):
        super().dispose()
        if (self.bufferCache is not None):
            b = self.bufferCache.iterator()
            while b.hasNext():
                b1 = b.next()
                b1.dispose()
        self.bufferCache = None
        self.layouts = None

    def getBuffers(self,engine):
        if (self.bufferCache is None):
            self.bufferCache = haxe_ds_IntMap()
        if (self.layouts is None):
            self.layouts = haxe_ds_IntMap()
        inputs = engine.driver.getShaderInputNames()
        buffers = self.layouts.h.get(inputs.id,None)
        if (buffers is not None):
            return buffers
        prev = None
        _g = 0
        _g1 = inputs.names
        while (_g < len(_g1)):
            name = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            id = hxsl_Globals.allocID(name)
            b = self.bufferCache.h.get(id,None)
            if (b is None):
                b = self.allocBuffer(engine,name)
                if (b is None):
                    raise haxe_Exception.thrown((("Buffer " + ("null" if name is None else name)) + " is not available"))
                self.bufferCache.set(id,b)
            b1 = h3d_BufferOffset(b.buffer,b.offset)
            b = b1
            if (prev is None):
                prev = b
                buffers = prev
            else:
                prev.next = b
                prev = b
        self.layouts.set(inputs.id,buffers)
        return buffers

    def render(self,engine):
        if ((self.indexes is None) or self.indexes.isDisposed()):
            self.alloc(engine)
        engine.renderMultiBuffers(self.getBuffers(engine),self.indexes)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bufferCache = None
        _hx_o.layouts = None
h3d_prim_MeshPrimitive._hx_class = h3d_prim_MeshPrimitive
_hx_classes["h3d.prim.MeshPrimitive"] = h3d_prim_MeshPrimitive


class h3d_prim_HMDModel(h3d_prim_MeshPrimitive):
    _hx_class_name = "h3d.prim.HMDModel"
    _hx_is_interface = "False"
    __slots__ = ("data", "dataPosition", "indexCount", "indexesTriPos", "lib", "curMaterial", "collider", "normalsRecomputed", "bufferAliases")
    _hx_fields = ["data", "dataPosition", "indexCount", "indexesTriPos", "lib", "curMaterial", "collider", "normalsRecomputed", "bufferAliases"]
    _hx_methods = ["triCount", "vertexCount", "getBounds", "selectMaterial", "getDataBuffers", "loadSkin", "addAlias", "alloc", "allocAlias", "recomputeNormals", "addTangents", "render", "initCollider", "getCollider"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_MeshPrimitive


    def __init__(self,data,dataPos,lib):
        self.normalsRecomputed = None
        self.collider = None
        self.curMaterial = None
        self.lib = None
        self.indexesTriPos = None
        self.indexCount = None
        self.dataPosition = None
        self.data = None
        self.bufferAliases = haxe_ds_StringMap()
        super().__init__()
        self.data = data
        self.dataPosition = dataPos
        self.lib = lib

    def triCount(self):
        x = (self.data.get_indexCount() / 3)
        try:
            return int(x)
        except BaseException as _g:
            None
            return None

    def vertexCount(self):
        return self.data.vertexCount

    def getBounds(self):
        return self.data.bounds

    def selectMaterial(self,i):
        self.curMaterial = i

    def getDataBuffers(self,fmt,defaults = None,material = None):
        return self.lib.getBuffers(self.data,fmt,defaults,material)

    def loadSkin(self,skin):
        self.lib.loadSkin(self.data,skin)

    def addAlias(self,name,realName,offset = None):
        if (offset is None):
            offset = 0
        old = self.bufferAliases.h.get(name,None)
        if (old is not None):
            if ((old.realName != realName) or ((old.offset != offset))):
                raise haxe_Exception.thrown(("Conflicting alias " + ("null" if name is None else name)))
            return
        self.bufferAliases.h[name] = _hx_AnonObject({'realName': realName, 'offset': offset})
        if (self.bufferCache is not None):
            self.allocAlias(name)

    def alloc(self,engine):
        self.dispose()
        self.buffer = h3d_Buffer(self.data.vertexCount,self.data.vertexStride,[h3d_BufferFlag.LargeBuffer])
        entry = self.lib.resource.entry
        entry.open()
        entry.skip((self.dataPosition + self.data.vertexPosition))
        size = ((self.data.vertexCount * self.data.vertexStride) * 4)
        _hx_bytes = haxe_io_Bytes.alloc(size)
        entry.read(_hx_bytes,0,size)
        self.buffer.uploadBytes(_hx_bytes,0,self.data.vertexCount)
        self.indexCount = 0
        self.indexesTriPos = []
        _g = 0
        _g1 = self.data.indexCounts
        while (_g < len(_g1)):
            n = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _this = self.indexesTriPos
            x = (self.indexCount / 3)
            x1 = None
            try:
                x1 = int(x)
            except BaseException as _g2:
                None
                x1 = None
            _this.append(x1)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.indexCount
            _hx_local_1.indexCount = (_hx_local_2 + n)
            _hx_local_1.indexCount
        is32 = (self.data.vertexCount > 65536)
        self.indexes = h3d_Indexes(self.indexCount,is32)
        entry.skip((self.data.indexPosition - ((self.data.vertexPosition + size))))
        imult = (4 if is32 else 2)
        _hx_bytes = haxe_io_Bytes.alloc((self.indexCount * imult))
        entry.read(_hx_bytes,0,(self.indexCount * imult))
        self.indexes.uploadBytes(_hx_bytes,0,self.indexCount)
        entry.close()
        pos = 0
        _g = 0
        _g1 = self.data.vertexFormat
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.addBuffer(f.name,self.buffer,pos)
            pos = (pos + ((f.format & 7)))
        if (self.normalsRecomputed is not None):
            self.recomputeNormals(self.normalsRecomputed)
        name = self.bufferAliases.keys()
        while name.hasNext():
            name1 = name.next()
            self.allocAlias(name1)

    def allocAlias(self,name):
        alias = self.bufferAliases.h.get(name,None)
        this1 = self.bufferCache
        key = hxsl_Globals.allocID(alias.realName)
        buffer = this1.h.get(key,None)
        if (buffer is None):
            raise haxe_Exception.thrown(((("Buffer " + HxOverrides.stringOrNull(alias.realName)) + " not found for alias ") + ("null" if name is None else name)))
        if ((buffer.offset + alias.offset) > buffer.buffer.buffer.stride):
            raise haxe_Exception.thrown((((("Alias " + ("null" if name is None else name)) + " for buffer ") + HxOverrides.stringOrNull(alias.realName)) + " outside stride"))
        self.addBuffer(name,buffer.buffer,(buffer.offset + alias.offset))

    def recomputeNormals(self,name = None):
        if (name is None):
            name = "normal"
        pos = self.lib.getBuffers(self.data,[hxd_fmt_hmd_GeometryFormat("position",3)])
        ids = list()
        pts = []
        _g = 0
        _g1 = self.data.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            added = False
            px = pos.vertexes[(i * 3)]
            py = pos.vertexes[((i * 3) + 1)]
            pz = pos.vertexes[((i * 3) + 2)]
            _g2 = 0
            _g3 = len(pts)
            while (_g2 < _g3):
                i1 = _g2
                _g2 = (_g2 + 1)
                p = (pts[i1] if i1 >= 0 and i1 < len(pts) else None)
                if (((p.x == px) and ((p.y == py))) and ((p.z == pz))):
                    ids.append(i1)
                    added = True
                    break
            if (not added):
                x = len(pts)
                ids.append(x)
                x1 = h3d_col_Point(px,py,pz)
                pts.append(x1)
        this1 = list()
        idx = this1
        _g = 0
        _g1 = pos.indexes
        while (_g < len(_g1)):
            i = _g1[_g]
            _g = (_g + 1)
            idx.append((ids[i] if i >= 0 and i < len(ids) else None))
        pol = h3d_prim_Polygon(pts,idx)
        pol.addNormals()
        this1 = list()
        v = this1
        v1 = (self.data.vertexCount * 3)
        if (v1 > len(v)):
            python_internal_ArrayImpl._set(v, (v1 - 1), 0.)
        k = 0
        _g = 0
        _g1 = self.data.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            n = python_internal_ArrayImpl._get(pol.normals, (ids[i] if i >= 0 and i < len(ids) else None))
            key = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key, n.x)
            key1 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key1, n.y)
            key2 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key2, n.z)
        buf = h3d_Buffer.ofFloats(v,3)
        self.addBuffer(name,buf,0)
        self.normalsRecomputed = name

    def addTangents(self):
        pos = self.lib.getBuffers(self.data,[hxd_fmt_hmd_GeometryFormat("position",3)])
        ids = list()
        pts = []
        _g = 0
        _g1 = self.data.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            added = False
            px = pos.vertexes[(i * 3)]
            py = pos.vertexes[((i * 3) + 1)]
            pz = pos.vertexes[((i * 3) + 2)]
            _g2 = 0
            _g3 = len(pts)
            while (_g2 < _g3):
                i1 = _g2
                _g2 = (_g2 + 1)
                p = (pts[i1] if i1 >= 0 and i1 < len(pts) else None)
                if (((p.x == px) and ((p.y == py))) and ((p.z == pz))):
                    ids.append(i1)
                    added = True
                    break
            if (not added):
                x = len(pts)
                ids.append(x)
                x1 = h3d_col_Point(px,py,pz)
                pts.append(x1)
        this1 = list()
        idx = this1
        _g = 0
        _g1 = pos.indexes
        while (_g < len(_g1)):
            i = _g1[_g]
            _g = (_g + 1)
            idx.append((ids[i] if i >= 0 and i < len(ids) else None))
        pol = h3d_prim_Polygon(pts,idx)
        pol.addNormals()
        pol.addTangents()
        this1 = list()
        v = this1
        v1 = (self.data.vertexCount * 3)
        if (v1 > len(v)):
            python_internal_ArrayImpl._set(v, (v1 - 1), 0.)
        k = 0
        _g = 0
        _g1 = self.data.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            t = python_internal_ArrayImpl._get(pol.tangents, (ids[i] if i >= 0 and i < len(ids) else None))
            key = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key, t.x)
            key1 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key1, t.y)
            key2 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key2, t.z)
        buf = h3d_Buffer.ofFloats(v,3)
        self.addBuffer("tangent",buf,0)

    def render(self,engine):
        if (self.curMaterial < 0):
            super().render(engine)
            return
        if ((self.indexes is None) or self.indexes.isDisposed()):
            self.alloc(engine)
        tmp = self.getBuffers(engine)
        tmp1 = self.indexes
        tmp2 = python_internal_ArrayImpl._get(self.indexesTriPos, self.curMaterial)
        x = (python_internal_ArrayImpl._get(self.data.indexCounts, self.curMaterial) / 3)
        tmp3 = None
        try:
            tmp3 = int(x)
        except BaseException as _g:
            None
            tmp3 = None
        engine.renderMultiBuffers(tmp,tmp1,tmp2,tmp3)
        self.curMaterial = -1

    def initCollider(self,poly):
        buf = self.lib.getBuffers(self.data,[hxd_fmt_hmd_GeometryFormat("position",3)])
        poly.setData(buf.vertexes,buf.indexes)
        if (self.collider is None):
            _this = self.data.bounds
            dx = (_this.xMax - _this.xMin)
            dy = (_this.yMax - _this.yMin)
            dz = (_this.zMax - _this.zMin)
            f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
            sphere = h3d_col_Sphere((((_this.xMin + _this.xMax)) * 0.5),(((_this.yMin + _this.yMax)) * 0.5),(((_this.zMin + _this.zMax)) * 0.5),(((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 0.5))
            self.collider = h3d_col_OptimizedCollider(sphere,poly)

    def getCollider(self):
        if (self.collider is not None):
            return self.collider
        poly = h3d_col_PolygonBuffer()
        poly.source = _hx_AnonObject({'entry': self.lib.resource.entry, 'geometryName': None})
        _g = 0
        _g1 = self.lib.header.models
        while (_g < len(_g1)):
            h = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (python_internal_ArrayImpl._get(self.lib.header.geometries, h.geometry) == self.data):
                poly.source.geometryName = h.name
                break
        self.initCollider(poly)
        return self.collider

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
        _hx_o.dataPosition = None
        _hx_o.indexCount = None
        _hx_o.indexesTriPos = None
        _hx_o.lib = None
        _hx_o.curMaterial = None
        _hx_o.collider = None
        _hx_o.normalsRecomputed = None
        _hx_o.bufferAliases = None
h3d_prim_HMDModel._hx_class = h3d_prim_HMDModel
_hx_classes["h3d.prim.HMDModel"] = h3d_prim_HMDModel


class h3d_prim_Plane2D(h3d_prim_Primitive):
    _hx_class_name = "h3d.prim.Plane2D"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["triCount", "vertexCount", "alloc", "render"]
    _hx_statics = ["get"]
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self):
        super().__init__()

    def triCount(self):
        return 2

    def vertexCount(self):
        return 4

    def alloc(self,engine):
        this1 = list()
        v = this1
        v.append(-1)
        v.append(-1)
        v.append(0)
        v.append(1)
        v.append(-1)
        v.append(1)
        v.append(0)
        v.append(0)
        v.append(1)
        v.append(-1)
        v.append(1)
        v.append(1)
        v.append(1)
        v.append(1)
        v.append(1)
        v.append(0)
        self.buffer = h3d_Buffer.ofFloats(v,4,[h3d_BufferFlag.Quads, h3d_BufferFlag.RawFormat])

    def render(self,engine):
        tmp = None
        if (self.buffer is not None):
            _this = self.buffer
            tmp = ((_this.buffer is None) or ((_this.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            self.alloc(engine)
        engine.renderBuffer(self.buffer,engine.mem.quadIndexes,2,0,-1)

    @staticmethod
    def get():
        engine = h3d_Engine.CURRENT
        inst = engine.resCache.h.get(h3d_prim_Plane2D,None)
        if (inst is None):
            inst = h3d_prim_Plane2D()
            engine.resCache.set(h3d_prim_Plane2D,inst)
        return inst

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_prim_Plane2D._hx_class = h3d_prim_Plane2D
_hx_classes["h3d.prim.Plane2D"] = h3d_prim_Plane2D


class h3d_prim_Polygon(h3d_prim_MeshPrimitive):
    _hx_class_name = "h3d.prim.Polygon"
    _hx_is_interface = "False"
    __slots__ = ("points", "normals", "tangents", "uvs", "idx", "colors", "scaled", "translatedX", "translatedY", "translatedZ")
    _hx_fields = ["points", "normals", "tangents", "uvs", "idx", "colors", "scaled", "translatedX", "translatedY", "translatedZ"]
    _hx_methods = ["getBounds", "alloc", "unindex", "translate", "scale", "addNormals", "addTangents", "addUVs", "uvScale", "triCount", "vertexCount", "getCollider", "render"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_MeshPrimitive


    def __init__(self,points,idx = None):
        self.colors = None
        self.idx = None
        self.uvs = None
        self.tangents = None
        self.normals = None
        self.points = None
        self.translatedZ = 0.
        self.translatedY = 0.
        self.translatedX = 0.
        self.scaled = 1.
        super().__init__()
        self.points = points
        self.idx = idx

    def getBounds(self):
        b = h3d_col_Bounds()
        _g = 0
        _g1 = self.points
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (p.x < b.xMin):
                b.xMin = p.x
            if (p.x > b.xMax):
                b.xMax = p.x
            if (p.y < b.yMin):
                b.yMin = p.y
            if (p.y > b.yMax):
                b.yMax = p.y
            if (p.z < b.zMin):
                b.zMin = p.z
            if (p.z > b.zMax):
                b.zMax = p.z
        return b

    def alloc(self,engine):
        self.dispose()
        size = 3
        names = ["position"]
        positions = [0]
        if (self.normals is not None):
            names.append("normal")
            positions.append(size)
            size = (size + 3)
        if (self.tangents is not None):
            names.append("tangent")
            positions.append(size)
            size = (size + 3)
        if (self.uvs is not None):
            names.append("uv")
            positions.append(size)
            size = (size + 2)
        if (self.colors is not None):
            names.append("color")
            positions.append(size)
            size = (size + 3)
        this1 = list()
        buf = this1
        _g = 0
        _g1 = len(self.points)
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            p = (self.points[k] if k >= 0 and k < len(self.points) else None)
            v = p.x
            buf.append(v)
            v1 = p.y
            buf.append(v1)
            v2 = p.z
            buf.append(v2)
            if (self.normals is not None):
                n = (self.normals[k] if k >= 0 and k < len(self.normals) else None)
                v3 = n.x
                buf.append(v3)
                v4 = n.y
                buf.append(v4)
                v5 = n.z
                buf.append(v5)
            if (self.tangents is not None):
                t = (self.tangents[k] if k >= 0 and k < len(self.tangents) else None)
                v6 = t.x
                buf.append(v6)
                v7 = t.y
                buf.append(v7)
                v8 = t.z
                buf.append(v8)
            if (self.uvs is not None):
                t1 = (self.uvs[k] if k >= 0 and k < len(self.uvs) else None)
                v9 = t1.u
                buf.append(v9)
                v10 = t1.v
                buf.append(v10)
            if (self.colors is not None):
                c = (self.colors[k] if k >= 0 and k < len(self.colors) else None)
                v11 = c.x
                buf.append(v11)
                v12 = c.y
                buf.append(v12)
                v13 = c.z
                buf.append(v13)
        flags = []
        if (self.idx is None):
            flags.append(h3d_BufferFlag.Triangles)
        if ((self.normals is None) or ((self.tangents is not None))):
            flags.append(h3d_BufferFlag.RawFormat)
        self.buffer = h3d_Buffer.ofFloats(buf,size,flags)
        _g = 0
        _g1 = len(names)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.addBuffer((names[i] if i >= 0 and i < len(names) else None),self.buffer,(positions[i] if i >= 0 and i < len(positions) else None))
        if (self.idx is not None):
            self.indexes = h3d_Indexes.alloc(self.idx)

    def unindex(self):
        if ((self.idx is not None) and ((len(self.points) != len(self.idx)))):
            p = []
            _g = 0
            _g1 = len(self.idx)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this = python_internal_ArrayImpl._get(self.points, python_internal_ArrayImpl._get(self.idx, i))
                x = h3d_col_Point(_this.x,_this.y,_this.z)
                p.append(x)
            if (self.normals is not None):
                n = []
                _g = 0
                _g1 = len(self.idx)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    _this = python_internal_ArrayImpl._get(self.normals, python_internal_ArrayImpl._get(self.idx, i))
                    x = h3d_col_Point(_this.x,_this.y,_this.z)
                    n.append(x)
                self.normals = n
            if (self.tangents is not None):
                t = []
                _g = 0
                _g1 = len(self.idx)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    _this = python_internal_ArrayImpl._get(self.tangents, python_internal_ArrayImpl._get(self.idx, i))
                    x = h3d_col_Point(_this.x,_this.y,_this.z)
                    t.append(x)
                self.tangents = t
            if (self.colors is not None):
                n = []
                _g = 0
                _g1 = len(self.idx)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    _this = python_internal_ArrayImpl._get(self.colors, python_internal_ArrayImpl._get(self.idx, i))
                    x = h3d_col_Point(_this.x,_this.y,_this.z)
                    n.append(x)
                self.colors = n
            if (self.uvs is not None):
                t = []
                _g = 0
                _g1 = len(self.idx)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    x = python_internal_ArrayImpl._get(self.uvs, python_internal_ArrayImpl._get(self.idx, i)).clone()
                    t.append(x)
                self.uvs = t
            self.points = p
            self.idx = None

    def translate(self,dx,dy,dz):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.translatedX
        _hx_local_0.translatedX = (_hx_local_1 + dx)
        _hx_local_0.translatedX
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.translatedY
        _hx_local_2.translatedY = (_hx_local_3 + dy)
        _hx_local_2.translatedY
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.translatedZ
        _hx_local_4.translatedZ = (_hx_local_5 + dz)
        _hx_local_4.translatedZ
        _g = 0
        _g1 = self.points
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.x = (p.x + dx)
            p.y = (p.y + dy)
            p.z = (p.z + dz)

    def scale(self,s):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.scaled
        _hx_local_0.scaled = (_hx_local_1 * s)
        _hx_local_0.scaled
        _g = 0
        _g1 = self.points
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.x = (p.x * s)
            p.y = (p.y * s)
            p.z = (p.z * s)

    def addNormals(self):
        self.normals = list()
        _g = 0
        _g1 = len(self.points)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.normals, i, h3d_col_Point())
        pos = 0
        _g = 0
        _g1 = self.triCount()
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            i0 = None
            i1 = None
            i2 = None
            if (self.idx is None):
                pos = (pos + 1)
                i0 = (pos - 1)
                pos = (pos + 1)
                i1 = (pos - 1)
                pos = (pos + 1)
                i2 = (pos - 1)
            else:
                key = pos
                pos = (pos + 1)
                i0 = python_internal_ArrayImpl._get(self.idx, key)
                key1 = pos
                pos = (pos + 1)
                i1 = python_internal_ArrayImpl._get(self.idx, key1)
                key2 = pos
                pos = (pos + 1)
                i2 = python_internal_ArrayImpl._get(self.idx, key2)
            p0 = (self.points[i0] if i0 >= 0 and i0 < len(self.points) else None)
            p1 = (self.points[i1] if i1 >= 0 and i1 < len(self.points) else None)
            p2 = (self.points[i2] if i2 >= 0 and i2 < len(self.points) else None)
            x = (p1.x - p0.x)
            y = (p1.y - p0.y)
            z = (p1.z - p0.z)
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this_x = x
            _this_y = y
            _this_z = z
            x1 = (p2.x - p0.x)
            y1 = (p2.y - p0.y)
            z1 = (p2.z - p0.z)
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            p_x = x1
            p_y = y1
            p_z = z1
            x2 = ((_this_y * p_z) - ((_this_z * p_y)))
            y2 = ((_this_z * p_x) - ((_this_x * p_z)))
            z2 = ((_this_x * p_y) - ((_this_y * p_x)))
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            n_x = x2
            n_y = y2
            n_z = z2
            _hx_local_3 = (self.normals[i0] if i0 >= 0 and i0 < len(self.normals) else None)
            _hx_local_4 = _hx_local_3.x
            _hx_local_3.x = (_hx_local_4 + n_x)
            _hx_local_3.x
            _hx_local_5 = (self.normals[i0] if i0 >= 0 and i0 < len(self.normals) else None)
            _hx_local_6 = _hx_local_5.y
            _hx_local_5.y = (_hx_local_6 + n_y)
            _hx_local_5.y
            _hx_local_7 = (self.normals[i0] if i0 >= 0 and i0 < len(self.normals) else None)
            _hx_local_8 = _hx_local_7.z
            _hx_local_7.z = (_hx_local_8 + n_z)
            _hx_local_7.z
            _hx_local_9 = (self.normals[i1] if i1 >= 0 and i1 < len(self.normals) else None)
            _hx_local_10 = _hx_local_9.x
            _hx_local_9.x = (_hx_local_10 + n_x)
            _hx_local_9.x
            _hx_local_11 = (self.normals[i1] if i1 >= 0 and i1 < len(self.normals) else None)
            _hx_local_12 = _hx_local_11.y
            _hx_local_11.y = (_hx_local_12 + n_y)
            _hx_local_11.y
            _hx_local_13 = (self.normals[i1] if i1 >= 0 and i1 < len(self.normals) else None)
            _hx_local_14 = _hx_local_13.z
            _hx_local_13.z = (_hx_local_14 + n_z)
            _hx_local_13.z
            _hx_local_15 = (self.normals[i2] if i2 >= 0 and i2 < len(self.normals) else None)
            _hx_local_16 = _hx_local_15.x
            _hx_local_15.x = (_hx_local_16 + n_x)
            _hx_local_15.x
            _hx_local_17 = (self.normals[i2] if i2 >= 0 and i2 < len(self.normals) else None)
            _hx_local_18 = _hx_local_17.y
            _hx_local_17.y = (_hx_local_18 + n_y)
            _hx_local_17.y
            _hx_local_19 = (self.normals[i2] if i2 >= 0 and i2 < len(self.normals) else None)
            _hx_local_20 = _hx_local_19.z
            _hx_local_19.z = (_hx_local_20 + n_z)
            _hx_local_19.z
        _g = 0
        _g1 = self.normals
        while (_g < len(_g1)):
            n = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            k = (((n.x * n.x) + ((n.y * n.y))) + ((n.z * n.z)))
            if (k < 1e-10):
                k = 0
            else:
                k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
            n.x = (n.x * k)
            n.y = (n.y * k)
            n.z = (n.z * k)

    def addTangents(self):
        if (self.normals is None):
            self.addNormals()
        if (self.uvs is None):
            self.addUVs()
        self.tangents = []
        _g = 0
        _g1 = len(self.points)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.tangents, i, h3d_col_Point())
        pos = 0
        _g = 0
        _g1 = self.triCount()
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            i0 = None
            i1 = None
            i2 = None
            if (self.idx is None):
                pos = (pos + 1)
                i0 = (pos - 1)
                pos = (pos + 1)
                i1 = (pos - 1)
                pos = (pos + 1)
                i2 = (pos - 1)
            else:
                key = pos
                pos = (pos + 1)
                i0 = python_internal_ArrayImpl._get(self.idx, key)
                key1 = pos
                pos = (pos + 1)
                i1 = python_internal_ArrayImpl._get(self.idx, key1)
                key2 = pos
                pos = (pos + 1)
                i2 = python_internal_ArrayImpl._get(self.idx, key2)
            p0 = (self.points[i0] if i0 >= 0 and i0 < len(self.points) else None)
            p1 = (self.points[i1] if i1 >= 0 and i1 < len(self.points) else None)
            p2 = (self.points[i2] if i2 >= 0 and i2 < len(self.points) else None)
            uv0 = (self.uvs[i0] if i0 >= 0 and i0 < len(self.uvs) else None)
            uv1 = (self.uvs[i1] if i1 >= 0 and i1 < len(self.uvs) else None)
            uv2 = (self.uvs[i2] if i2 >= 0 and i2 < len(self.uvs) else None)
            n = (self.normals[i0] if i0 >= 0 and i0 < len(self.normals) else None)
            x = (p1.x - p0.x)
            y = (p1.y - p0.y)
            z = (p1.z - p0.z)
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            k0_x = x
            k0_y = y
            k0_z = z
            x1 = (p2.x - p0.x)
            y1 = (p2.y - p0.y)
            z1 = (p2.z - p0.z)
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            k1_x = x1
            k1_y = y1
            k1_z = z1
            v = (uv2.v - uv0.v)
            k0_x = (k0_x * v)
            k0_y = (k0_y * v)
            k0_z = (k0_z * v)
            v1 = (uv1.v - uv0.v)
            k1_x = (k1_x * v1)
            k1_y = (k1_y * v1)
            k1_z = (k1_z * v1)
            t = h3d_col_Point((k0_x - k1_x),(k0_y - k1_y),(k0_z - k1_z))
            x2 = ((n.y * t.z) - ((n.z * t.y)))
            y2 = ((n.z * t.x) - ((n.x * t.z)))
            z2 = ((n.x * t.y) - ((n.y * t.x)))
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            b_x = x2
            b_y = y2
            b_z = z2
            k = (((b_x * b_x) + ((b_y * b_y))) + ((b_z * b_z)))
            if (k < 1e-10):
                k = 0
            else:
                k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
            b_x = (b_x * k)
            b_y = (b_y * k)
            b_z = (b_z * k)
            t = h3d_col_Point(((b_y * n.z) - ((b_z * n.y))),((b_z * n.x) - ((b_x * n.z))),((b_x * n.y) - ((b_y * n.x))))
            k1 = (((t.x * t.x) + ((t.y * t.y))) + ((t.z * t.z)))
            if (k1 < 1e-10):
                k1 = 0
            else:
                k1 = (1. / ((Math.NaN if ((k1 < 0)) else python_lib_Math.sqrt(k1))))
            t.x = (t.x * k1)
            t.y = (t.y * k1)
            t.z = (t.z * k1)
            _hx_local_15 = (self.tangents[i0] if i0 >= 0 and i0 < len(self.tangents) else None)
            _hx_local_16 = _hx_local_15.x
            _hx_local_15.x = (_hx_local_16 + t.x)
            _hx_local_15.x
            _hx_local_17 = (self.tangents[i0] if i0 >= 0 and i0 < len(self.tangents) else None)
            _hx_local_18 = _hx_local_17.y
            _hx_local_17.y = (_hx_local_18 + t.y)
            _hx_local_17.y
            _hx_local_19 = (self.tangents[i0] if i0 >= 0 and i0 < len(self.tangents) else None)
            _hx_local_20 = _hx_local_19.z
            _hx_local_19.z = (_hx_local_20 + t.z)
            _hx_local_19.z
            _hx_local_21 = (self.tangents[i1] if i1 >= 0 and i1 < len(self.tangents) else None)
            _hx_local_22 = _hx_local_21.x
            _hx_local_21.x = (_hx_local_22 + t.x)
            _hx_local_21.x
            _hx_local_23 = (self.tangents[i1] if i1 >= 0 and i1 < len(self.tangents) else None)
            _hx_local_24 = _hx_local_23.y
            _hx_local_23.y = (_hx_local_24 + t.y)
            _hx_local_23.y
            _hx_local_25 = (self.tangents[i1] if i1 >= 0 and i1 < len(self.tangents) else None)
            _hx_local_26 = _hx_local_25.z
            _hx_local_25.z = (_hx_local_26 + t.z)
            _hx_local_25.z
            _hx_local_27 = (self.tangents[i2] if i2 >= 0 and i2 < len(self.tangents) else None)
            _hx_local_28 = _hx_local_27.x
            _hx_local_27.x = (_hx_local_28 + t.x)
            _hx_local_27.x
            _hx_local_29 = (self.tangents[i2] if i2 >= 0 and i2 < len(self.tangents) else None)
            _hx_local_30 = _hx_local_29.y
            _hx_local_29.y = (_hx_local_30 + t.y)
            _hx_local_29.y
            _hx_local_31 = (self.tangents[i2] if i2 >= 0 and i2 < len(self.tangents) else None)
            _hx_local_32 = _hx_local_31.z
            _hx_local_31.z = (_hx_local_32 + t.z)
            _hx_local_31.z
        _g = 0
        _g1 = self.tangents
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            k = (((t.x * t.x) + ((t.y * t.y))) + ((t.z * t.z)))
            if (k < 1e-10):
                k = 0
            else:
                k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
            t.x = (t.x * k)
            t.y = (t.y * k)
            t.z = (t.z * k)

    def addUVs(self):
        self.uvs = []
        _g = 0
        _g1 = len(self.points)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.uvs, i, h3d_prim_UV((self.points[i] if i >= 0 and i < len(self.points) else None).x,(self.points[i] if i >= 0 and i < len(self.points) else None).y))

    def uvScale(self,su,sv):
        if (self.uvs is None):
            raise haxe_Exception.thrown("Missing UVs")
        m = haxe_ds_ObjectMap()
        _g = 0
        _g1 = self.uvs
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (t in m.h):
                continue
            m.set(t,True)
            t.u = (t.u * su)
            t.v = (t.v * sv)

    def triCount(self):
        n = super().triCount()
        if (n != 0):
            return n
        x = (((len(self.points) if ((self.idx is None)) else len(self.idx))) / 3)
        try:
            return int(x)
        except BaseException as _g:
            None
            return None

    def vertexCount(self):
        return len(self.points)

    def getCollider(self):
        this1 = [None]*(len(self.points) * 3)
        vertexes = this1
        this1 = [None]*len(self.idx)
        indexes = this1
        vid = 0
        _g = 0
        _g1 = self.points
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            index = vid
            vid = (vid + 1)
            val = p.x
            vertexes[index] = val
            index1 = vid
            vid = (vid + 1)
            val1 = p.y
            vertexes[index1] = val1
            index2 = vid
            vid = (vid + 1)
            val2 = p.z
            vertexes[index2] = val2
        _g = 0
        _g1 = len(self.idx)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            val = python_internal_ArrayImpl._get(self.idx, i)
            indexes[i] = val
        poly = h3d_col_Polygon()
        poly.addBuffers(vertexes,indexes)
        return poly

    def render(self,engine):
        tmp = None
        if (self.buffer is not None):
            _this = self.buffer
            tmp = ((_this.buffer is None) or ((_this.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            self.alloc(engine)
        bufs = self.getBuffers(engine)
        if (self.indexes is not None):
            engine.renderMultiBuffers(bufs,self.indexes)
        elif (((self.buffer.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0):
            engine.renderMultiBuffers(bufs,engine.mem.quadIndexes,0,self.triCount())
        else:
            engine.renderMultiBuffers(bufs,engine.mem.triIndexes,0,self.triCount())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.points = None
        _hx_o.normals = None
        _hx_o.tangents = None
        _hx_o.uvs = None
        _hx_o.idx = None
        _hx_o.colors = None
        _hx_o.scaled = None
        _hx_o.translatedX = None
        _hx_o.translatedY = None
        _hx_o.translatedZ = None
h3d_prim_Polygon._hx_class = h3d_prim_Polygon
_hx_classes["h3d.prim.Polygon"] = h3d_prim_Polygon


class h3d_prim_RawPrimitive(h3d_prim_Primitive):
    _hx_class_name = "h3d.prim.RawPrimitive"
    _hx_is_interface = "False"
    __slots__ = ("vcount", "tcount", "bounds", "onContextLost")
    _hx_fields = ["vcount", "tcount", "bounds", "onContextLost"]
    _hx_methods = ["alloc", "getBounds", "triCount", "vertexCount"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self,inf,persist = None):
        if (persist is None):
            persist = False
        self.onContextLost = None
        self.bounds = None
        self.tcount = None
        self.vcount = None
        super().__init__()
        def _hx_local_0():
            return inf
        self.onContextLost = _hx_local_0
        self.bounds = Reflect.field(inf,"bounds")
        self.alloc(None)
        if (not persist):
            self.onContextLost = None

    def alloc(self,engine):
        if (self.onContextLost is None):
            raise haxe_Exception.thrown(("Cannot realloc " + Std.string(self)))
        inf = self.onContextLost()
        flags = []
        if (Reflect.field(inf,"ibuf") is None):
            x = (h3d_BufferFlag.Quads if (Reflect.field(inf,"quads")) else h3d_BufferFlag.Triangles)
            flags.append(x)
        if (inf.stride < 8):
            flags.append(h3d_BufferFlag.RawFormat)
        self.buffer = h3d_Buffer.ofFloats(inf.vbuf,inf.stride,flags)
        self.vcount = self.buffer.vertices
        tmp = None
        if (Reflect.field(inf,"ibuf") is not None):
            x = (len(Reflect.field(inf,"ibuf")) / 3)
            try:
                tmp = int(x)
            except BaseException as _g:
                None
                tmp = None
        elif Reflect.field(inf,"quads"):
            tmp = (self.vcount >> 1)
        else:
            x = (self.vcount / 3)
            try:
                tmp = int(x)
            except BaseException as _g:
                None
                tmp = None
        self.tcount = tmp
        if (Reflect.field(inf,"ibuf") is not None):
            self.indexes = h3d_Indexes.alloc(Reflect.field(inf,"ibuf"))
        elif (self.indexes is not None):
            self.indexes.dispose()
            self.indexes = None

    def getBounds(self):
        if (self.bounds is None):
            raise haxe_Exception.thrown(("Bounds not defined for " + Std.string(self)))
        return self.bounds

    def triCount(self):
        return self.tcount

    def vertexCount(self):
        return self.vcount

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vcount = None
        _hx_o.tcount = None
        _hx_o.bounds = None
        _hx_o.onContextLost = None
h3d_prim_RawPrimitive._hx_class = h3d_prim_RawPrimitive
_hx_classes["h3d.prim.RawPrimitive"] = h3d_prim_RawPrimitive


class h3d_prim_UV:
    _hx_class_name = "h3d.prim.UV"
    _hx_is_interface = "False"
    __slots__ = ("u", "v")
    _hx_fields = ["u", "v"]
    _hx_methods = ["clone", "toString"]

    def __init__(self,u,v):
        self.u = u
        self.v = v

    def clone(self):
        return h3d_prim_UV(self.u,self.v)

    def toString(self):
        return (((("{" + Std.string(hxd_Math.fmt(self.u))) + ",") + Std.string(hxd_Math.fmt(self.v))) + "}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.u = None
        _hx_o.v = None
h3d_prim_UV._hx_class = h3d_prim_UV
_hx_classes["h3d.prim.UV"] = h3d_prim_UV


class h3d_scene__Graphics_GPoint:
    _hx_class_name = "h3d.scene._Graphics.GPoint"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "r", "g", "b", "a")
    _hx_fields = ["x", "y", "z", "r", "g", "b", "a"]

    def __init__(self,x,y,z,r,g,b,a):
        self.x = x
        self.y = y
        self.z = z
        self.r = r
        self.g = g
        self.b = b
        self.a = a

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.r = None
        _hx_o.g = None
        _hx_o.b = None
        _hx_o.a = None
h3d_scene__Graphics_GPoint._hx_class = h3d_scene__Graphics_GPoint
_hx_classes["h3d.scene._Graphics.GPoint"] = h3d_scene__Graphics_GPoint


class h3d_scene_Object:
    _hx_class_name = "h3d.scene.Object"
    _hx_is_interface = "False"
    __slots__ = ("flags", "children", "parent", "name", "x", "y", "z", "scaleX", "scaleY", "scaleZ", "follow", "defaultTransform", "currentAnimation", "cullingCollider", "absPos", "invPos", "qRot", "lastFrame")
    _hx_fields = ["flags", "children", "parent", "name", "x", "y", "z", "scaleX", "scaleY", "scaleZ", "follow", "defaultTransform", "currentAnimation", "cullingCollider", "absPos", "invPos", "qRot", "lastFrame"]
    _hx_methods = ["set_cullingCollider", "get_visible", "get_allocated", "get_posChanged", "get_culled", "get_followPositionOnly", "get_lightCameraCenter", "get_alwaysSync", "get_inheritCulled", "get_ignoreBounds", "get_ignoreCollide", "get_allowSerialize", "get_ignoreParentTransform", "get_cullingColliderInherited", "set_posChanged", "set_culled", "set_visible", "set_allocated", "set_followPositionOnly", "set_lightCameraCenter", "set_alwaysSync", "set_ignoreBounds", "set_inheritCulled", "set_ignoreCollide", "set_allowSerialize", "set_ignoreParentTransform", "set_cullingColliderInherited", "playAnimation", "switchToAnimation", "stopAnimation", "applyAnimationTransform", "getObjectsCount", "getMaterialByName", "contains", "find", "findAll", "getMaterials", "localToGlobal", "globalToLocal", "getInvPos", "getBounds", "getBoundsRec", "getMeshes", "getMeshByName", "getObjectByName", "clone", "addChild", "addChildAt", "iterVisibleMeshes", "onParentChanged", "onAdd", "onRemove", "removeChild", "removeChildren", "remove", "getScene", "getAbsPos", "getRelPos", "isMesh", "toMesh", "getCollider", "getGlobalCollider", "getLocalCollider", "draw", "set_follow", "calcAbsPos", "sync", "syncRec", "syncPos", "emit", "emitRec", "set_x", "set_y", "set_z", "set_scaleX", "set_scaleY", "set_scaleZ", "set_defaultTransform", "setPosition", "setTransform", "getTransform", "rotate", "setRotation", "setRotationAxis", "setDirection", "getLocalDirection", "getRotationQuat", "setRotationQuat", "scale", "setScale", "toString", "getChildAt", "getChildIndex", "get_numChildren", "iterator"]
    _hx_statics = ["ROT2RAD", "tmpMat", "tmpVec"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,parent = None):
        self.lastFrame = None
        self.qRot = None
        self.invPos = None
        self.cullingCollider = None
        self.currentAnimation = None
        self.defaultTransform = None
        self.follow = None
        self.scaleZ = None
        self.scaleY = None
        self.scaleX = None
        self.z = None
        self.y = None
        self.x = None
        self.name = None
        self.parent = None
        self.children = None
        this1 = 0
        self.flags = this1
        self.absPos = h3d_Matrix()
        self.absPos.identity()
        self.x = 0
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        self.y = 0
        f = 1
        b = True
        if b:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 | f)
            _hx_local_4.flags
        else:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 & ~f)
            _hx_local_6.flags
        self.z = 0
        f = 1
        b = True
        if b:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | f)
            _hx_local_8.flags
        else:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.flags
            _hx_local_10.flags = (_hx_local_11 & ~f)
            _hx_local_10.flags
        self.scaleX = 1
        f = 1
        b = True
        if b:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.flags
            _hx_local_12.flags = (_hx_local_13 | f)
            _hx_local_12.flags
        else:
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.flags
            _hx_local_14.flags = (_hx_local_15 & ~f)
            _hx_local_14.flags
        self.scaleY = 1
        f = 1
        b = True
        if b:
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.flags
            _hx_local_16.flags = (_hx_local_17 | f)
            _hx_local_16.flags
        else:
            _hx_local_18 = self
            _hx_local_19 = _hx_local_18.flags
            _hx_local_18.flags = (_hx_local_19 & ~f)
            _hx_local_18.flags
        self.scaleZ = 1
        f = 1
        b = True
        if b:
            _hx_local_20 = self
            _hx_local_21 = _hx_local_20.flags
            _hx_local_20.flags = (_hx_local_21 | f)
            _hx_local_20.flags
        else:
            _hx_local_22 = self
            _hx_local_23 = _hx_local_22.flags
            _hx_local_22.flags = (_hx_local_23 & ~f)
            _hx_local_22.flags
        self.qRot = h3d_Quat()
        f = 1
        b = (self.follow is not None)
        if b:
            _hx_local_24 = self
            _hx_local_25 = _hx_local_24.flags
            _hx_local_24.flags = (_hx_local_25 | f)
            _hx_local_24.flags
        else:
            _hx_local_26 = self
            _hx_local_27 = _hx_local_26.flags
            _hx_local_26.flags = (_hx_local_27 & ~f)
            _hx_local_26.flags
        f = 2
        _hx_local_28 = self
        _hx_local_29 = _hx_local_28.flags
        _hx_local_28.flags = (_hx_local_29 | f)
        _hx_local_28.flags
        self.children = []
        if (parent is not None):
            parent.addChild(self)

    def set_cullingCollider(self,c):
        self.cullingCollider = c
        f = 4096
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 & ~f)
        _hx_local_0.flags
        return c

    def get_visible(self):
        return (((self.flags & 2)) != 0)

    def get_allocated(self):
        return (((self.flags & 32)) != 0)

    def get_posChanged(self):
        return (((self.flags & 1)) != 0)

    def get_culled(self):
        return (((self.flags & 4)) != 0)

    def get_followPositionOnly(self):
        return (((self.flags & 8)) != 0)

    def get_lightCameraCenter(self):
        return (((self.flags & 16)) != 0)

    def get_alwaysSync(self):
        return (((self.flags & 64)) != 0)

    def get_inheritCulled(self):
        return (((self.flags & 128)) != 0)

    def get_ignoreBounds(self):
        return (((self.flags & 512)) != 0)

    def get_ignoreCollide(self):
        return (((self.flags & 1024)) != 0)

    def get_allowSerialize(self):
        return (((self.flags & 256)) == 0)

    def get_ignoreParentTransform(self):
        return (((self.flags & 2048)) != 0)

    def get_cullingColliderInherited(self):
        return (((self.flags & 4096)) != 0)

    def set_posChanged(self,b):
        f = 1
        b1 = (b or ((self.follow is not None)))
        if b1:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b1

    def set_culled(self,b):
        f = 4
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_visible(self,b):
        f = 2
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_allocated(self,b):
        f = 32
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_followPositionOnly(self,b):
        f = 8
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_lightCameraCenter(self,b):
        f = 16
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_alwaysSync(self,b):
        f = 64
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_ignoreBounds(self,b):
        f = 512
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_inheritCulled(self,b):
        f = 128
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_ignoreCollide(self,b):
        f = 1024
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_allowSerialize(self,b):
        f = 256
        b1 = (not b)
        if b1:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return (not b1)

    def set_ignoreParentTransform(self,b):
        if (b != ((((self.flags & 2048)) != 0))):
            f = 1
            b1 = True
            if b1:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.flags
                _hx_local_0.flags = (_hx_local_1 | f)
                _hx_local_0.flags
            else:
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.flags
                _hx_local_2.flags = (_hx_local_3 & ~f)
                _hx_local_2.flags
        f = 2048
        if b:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 | f)
            _hx_local_4.flags
        else:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 & ~f)
            _hx_local_6.flags
        return b

    def set_cullingColliderInherited(self,b):
        f = 4096
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def playAnimation(self,a):
        def _hx_local_1():
            def _hx_local_0():
                self.currentAnimation = a.createInstance(self)
                return self.currentAnimation
            return _hx_local_0()
        return _hx_local_1()

    def switchToAnimation(self,a):
        def _hx_local_1():
            def _hx_local_0():
                self.currentAnimation = a
                return self.currentAnimation
            return _hx_local_0()
        return _hx_local_1()

    def stopAnimation(self,recursive = None):
        if (recursive is None):
            recursive = False
        self.currentAnimation = None
        if recursive:
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.stopAnimation(True)

    def applyAnimationTransform(self,recursive = None):
        if (recursive is None):
            recursive = True
        if (self.defaultTransform is not None):
            _this = self.defaultTransform
            v = None
            if (v is None):
                v = h3d_Vector()
            f = (((_this._11 * _this._11) + ((_this._12 * _this._12))) + ((_this._13 * _this._13)))
            v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
            f = (((_this._21 * _this._21) + ((_this._22 * _this._22))) + ((_this._23 * _this._23)))
            v.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
            f = (((_this._31 * _this._31) + ((_this._32 * _this._32))) + ((_this._33 * _this._33)))
            v.z = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
            if ((((_this._11 * (((_this._22 * _this._33) - ((_this._23 * _this._32))))) + ((_this._12 * (((_this._23 * _this._31) - ((_this._21 * _this._33))))))) + ((_this._13 * (((_this._21 * _this._32) - ((_this._22 * _this._31))))))) < 0):
                v.x = (v.x * -1)
                v.y = (v.y * -1)
                v.z = (v.z * -1)
            s = v
            v = s.x
            self.scaleX = v
            f = 1
            b = True
            if b:
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.flags
                _hx_local_3.flags = (_hx_local_4 | f)
                _hx_local_3.flags
            else:
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.flags
                _hx_local_5.flags = (_hx_local_6 & ~f)
                _hx_local_5.flags
            v = s.y
            self.scaleY = v
            f = 1
            b = True
            if b:
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.flags
                _hx_local_7.flags = (_hx_local_8 | f)
                _hx_local_7.flags
            else:
                _hx_local_9 = self
                _hx_local_10 = _hx_local_9.flags
                _hx_local_9.flags = (_hx_local_10 & ~f)
                _hx_local_9.flags
            v = s.z
            self.scaleZ = v
            f = 1
            b = True
            if b:
                _hx_local_11 = self
                _hx_local_12 = _hx_local_11.flags
                _hx_local_11.flags = (_hx_local_12 | f)
                _hx_local_11.flags
            else:
                _hx_local_13 = self
                _hx_local_14 = _hx_local_13.flags
                _hx_local_13.flags = (_hx_local_14 & ~f)
                _hx_local_13.flags
            self.qRot.initRotateMatrix(self.defaultTransform)
            v = self.defaultTransform._41
            self.x = v
            f = 1
            b = True
            if b:
                _hx_local_15 = self
                _hx_local_16 = _hx_local_15.flags
                _hx_local_15.flags = (_hx_local_16 | f)
                _hx_local_15.flags
            else:
                _hx_local_17 = self
                _hx_local_18 = _hx_local_17.flags
                _hx_local_17.flags = (_hx_local_18 & ~f)
                _hx_local_17.flags
            v = self.defaultTransform._42
            self.y = v
            f = 1
            b = True
            if b:
                _hx_local_19 = self
                _hx_local_20 = _hx_local_19.flags
                _hx_local_19.flags = (_hx_local_20 | f)
                _hx_local_19.flags
            else:
                _hx_local_21 = self
                _hx_local_22 = _hx_local_21.flags
                _hx_local_21.flags = (_hx_local_22 & ~f)
                _hx_local_21.flags
            v = self.defaultTransform._43
            self.z = v
            f = 1
            b = True
            if b:
                _hx_local_23 = self
                _hx_local_24 = _hx_local_23.flags
                _hx_local_23.flags = (_hx_local_24 | f)
                _hx_local_23.flags
            else:
                _hx_local_25 = self
                _hx_local_26 = _hx_local_25.flags
                _hx_local_25.flags = (_hx_local_26 & ~f)
                _hx_local_25.flags
            v = None
            self.defaultTransform = v
            f = 1
            b = True
            if b:
                _hx_local_27 = self
                _hx_local_28 = _hx_local_27.flags
                _hx_local_27.flags = (_hx_local_28 | f)
                _hx_local_27.flags
            else:
                _hx_local_29 = self
                _hx_local_30 = _hx_local_29.flags
                _hx_local_29.flags = (_hx_local_30 & ~f)
                _hx_local_29.flags
        if recursive:
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.applyAnimationTransform()

    def getObjectsCount(self):
        k = 0
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            k = (k + ((c.getObjectsCount() + 1)))
        return k

    def getMaterialByName(self,name):
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            m = o.getMaterialByName(name)
            if (m is not None):
                return m
        return None

    def contains(self,o):
        while (o is not None):
            o = o.parent
            if (o == self):
                return True
        return False

    def find(self,f):
        v = f(self)
        if (v is not None):
            return v
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            v = o.find(f)
            if (v is not None):
                return v
        return None

    def findAll(self,f,arr = None):
        if (arr is None):
            arr = []
        v = f(self)
        if (v is not None):
            arr.append(v)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o.findAll(f,arr)
        return arr

    def getMaterials(self,a = None,recursive = None):
        if (recursive is None):
            recursive = True
        if (a is None):
            a = []
        if recursive:
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                o.getMaterials(a)
        return a

    def localToGlobal(self,pt = None):
        self.syncPos()
        if (pt is None):
            pt = h3d_col_Point()
        m = self.absPos
        px = ((((pt.x * m._11) + ((pt.y * m._21))) + ((pt.z * m._31))) + m._41)
        py = ((((pt.x * m._12) + ((pt.y * m._22))) + ((pt.z * m._32))) + m._42)
        pz = ((((pt.x * m._13) + ((pt.y * m._23))) + ((pt.z * m._33))) + m._43)
        pt.x = px
        pt.y = py
        pt.z = pz
        return pt

    def globalToLocal(self,pt):
        m = self.getInvPos()
        px = ((((pt.x * m._11) + ((pt.y * m._21))) + ((pt.z * m._31))) + m._41)
        py = ((((pt.x * m._12) + ((pt.y * m._22))) + ((pt.z * m._32))) + m._42)
        pz = ((((pt.x * m._13) + ((pt.y * m._23))) + ((pt.z * m._33))) + m._43)
        pt.x = px
        pt.y = py
        pt.z = pz
        return pt

    def getInvPos(self):
        self.syncPos()
        if (self.invPos is None):
            self.invPos = h3d_Matrix()
            self.invPos._44 = 0
        if (self.invPos._44 == 0):
            self.invPos.inverse3x4(self.absPos)
        return self.invPos

    def getBounds(self,b = None):
        if (b is None):
            b = h3d_col_Bounds()
        if (self.parent is not None):
            self.parent.syncPos()
        return self.getBoundsRec(b)

    def getBoundsRec(self,b):
        if (((self.flags & 1)) != 0):
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                f = 1
                b1 = True
                if b1:
                    c.flags = (c.flags | f)
                else:
                    c.flags = (c.flags & ~f)
            f = 1
            b1 = (self.follow is not None)
            if b1:
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.flags
                _hx_local_3.flags = (_hx_local_4 | f)
                _hx_local_3.flags
            else:
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.flags
                _hx_local_5.flags = (_hx_local_6 & ~f)
                _hx_local_5.flags
            self.calcAbsPos()
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.getBoundsRec(b)
        return b

    def getMeshes(self,out = None):
        if (out is None):
            out = []
        m = Std.downcast(self,h3d_scene_Mesh)
        if (m is not None):
            out.append(m)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.getMeshes(out)
        return out

    def getMeshByName(self,name):
        return Std.downcast(self.getObjectByName(name),h3d_scene_Mesh)

    def getObjectByName(self,name):
        if (self.name == name):
            return self
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o = c.getObjectByName(name)
            if (o is not None):
                return o
        return None

    def clone(self,o = None):
        if (o is None):
            o = h3d_scene_Object()
        v = self.x
        o.x = v
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        v = self.y
        o.y = v
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        v = self.z
        o.z = v
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        v = self.scaleX
        o.scaleX = v
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        v = self.scaleY
        o.scaleY = v
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        v = self.scaleZ
        o.scaleZ = v
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        _this = o.qRot
        q = self.qRot
        _this.x = q.x
        _this.y = q.y
        _this.z = q.z
        _this.w = q.w
        o.name = self.name
        o.set_follow(self.follow)
        b = (((self.flags & 8)) != 0)
        f = 8
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        b = (((self.flags & 2)) != 0)
        f = 2
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        if (self.defaultTransform is not None):
            v = self.defaultTransform.clone()
            o.defaultTransform = v
            f = 1
            b = True
            if b:
                o.flags = (o.flags | f)
            else:
                o.flags = (o.flags & ~f)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c1 = c.clone()
            c1.parent = o
            _this = o.children
            _this.append(c1)
        return o

    def addChild(self,o):
        self.addChildAt(o,len(self.children))

    def addChildAt(self,o,pos):
        if (pos < 0):
            pos = 0
        if (pos > len(self.children)):
            pos = len(self.children)
        p = self
        while (p is not None):
            if (p == o):
                raise haxe_Exception.thrown("Recursive addChild")
            p = p.parent
        if (o.parent is not None):
            old = (((o.flags & 32)) != 0)
            f = 32
            o.flags = (o.flags & ~f)
            o.parent.removeChild(o)
            f = 32
            if old:
                o.flags = (o.flags | f)
            else:
                o.flags = (o.flags & ~f)
        self.children.insert(pos, o)
        if ((((self.flags & 32)) == 0) and ((((o.flags & 32)) != 0))):
            o.onRemove()
        o.parent = self
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        if (((self.flags & 32)) != 0):
            if (((o.flags & 32)) == 0):
                o.onAdd()
            else:
                o.onParentChanged()

    def iterVisibleMeshes(self,callb):
        if ((((self.flags & 2)) == 0) or (((((self.flags & 4)) != 0) and ((((self.flags & 128)) != 0))))):
            return
        if (((self.flags & 4)) == 0):
            m = Std.downcast(self,h3d_scene_Mesh)
            if (m is not None):
                callb(m)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o.iterVisibleMeshes(callb)

    def onParentChanged(self):
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onParentChanged()

    def onAdd(self):
        f = 32
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 | f)
        _hx_local_0.flags
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onAdd()

    def onRemove(self):
        f = 32
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 & ~f)
        _hx_local_0.flags
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onRemove()

    def removeChild(self,o):
        if python_internal_ArrayImpl.remove(self.children,o):
            if (((o.flags & 32)) != 0):
                o.onRemove()
            o.parent = None
            f = 1
            b = True
            if b:
                o.flags = (o.flags | f)
            else:
                o.flags = (o.flags & ~f)

    def removeChildren(self):
        while (len(self.children) > 0):
            self.removeChild((self.children[0] if 0 < len(self.children) else None))

    def remove(self):
        if (self.parent is not None):
            self.parent.removeChild(self)

    def getScene(self):
        p = self
        while (p.parent is not None):
            p = p.parent
        return Std.downcast(p,h3d_scene_Scene)

    def getAbsPos(self):
        self.syncPos()
        return self.absPos

    def getRelPos(self,obj):
        if (obj is None):
            return self.getAbsPos()
        self.syncPos()
        m = h3d_Matrix()
        m.multiply(self.absPos,obj.getInvPos())
        return m

    def isMesh(self):
        return (Std.downcast(self,h3d_scene_Mesh) is not None)

    def toMesh(self):
        m = Std.downcast(self,h3d_scene_Mesh)
        if (m is not None):
            return m
        raise haxe_Exception.thrown((Std.string(self) + " is not a Mesh"))

    def getCollider(self):
        if (((self.flags & 1024)) != 0):
            return None
        colliders = []
        col = self.getGlobalCollider()
        if (col is not None):
            colliders.append(col)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            obj = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c = obj.getCollider()
            if (c is None):
                continue
            cgrp = Std.downcast(c,h3d_col_GroupCollider)
            if (cgrp is not None):
                _g2 = 0
                _g3 = cgrp.colliders
                while (_g2 < len(_g3)):
                    c1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    colliders.append(c1)
            else:
                colliders.append(c)
        if (len(colliders) == 0):
            return None
        if (len(colliders) == 1):
            return (colliders[0] if 0 < len(colliders) else None)
        return h3d_col_GroupCollider(colliders)

    def getGlobalCollider(self):
        if (((self.flags & 1024)) != 0):
            return None
        col = self.getLocalCollider()
        if (col is None):
            return None
        else:
            return h3d_col_ObjectCollider(self,col)

    def getLocalCollider(self):
        return None

    def draw(self,ctx):
        pass

    def set_follow(self,v):
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        def _hx_local_5():
            def _hx_local_4():
                self.follow = v
                return self.follow
            return _hx_local_4()
        return _hx_local_5()

    def calcAbsPos(self):
        self.qRot.toMatrix(self.absPos)
        _hx_local_0 = self.absPos
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * self.scaleX)
        _hx_local_0._11
        _hx_local_2 = self.absPos
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * self.scaleX)
        _hx_local_2._12
        _hx_local_4 = self.absPos
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * self.scaleX)
        _hx_local_4._13
        _hx_local_6 = self.absPos
        _hx_local_7 = _hx_local_6._21
        _hx_local_6._21 = (_hx_local_7 * self.scaleY)
        _hx_local_6._21
        _hx_local_8 = self.absPos
        _hx_local_9 = _hx_local_8._22
        _hx_local_8._22 = (_hx_local_9 * self.scaleY)
        _hx_local_8._22
        _hx_local_10 = self.absPos
        _hx_local_11 = _hx_local_10._23
        _hx_local_10._23 = (_hx_local_11 * self.scaleY)
        _hx_local_10._23
        _hx_local_12 = self.absPos
        _hx_local_13 = _hx_local_12._31
        _hx_local_12._31 = (_hx_local_13 * self.scaleZ)
        _hx_local_12._31
        _hx_local_14 = self.absPos
        _hx_local_15 = _hx_local_14._32
        _hx_local_14._32 = (_hx_local_15 * self.scaleZ)
        _hx_local_14._32
        _hx_local_16 = self.absPos
        _hx_local_17 = _hx_local_16._33
        _hx_local_16._33 = (_hx_local_17 * self.scaleZ)
        _hx_local_16._33
        self.absPos._41 = self.x
        self.absPos._42 = self.y
        self.absPos._43 = self.z
        if (self.follow is not None):
            self.follow.syncPos()
            if (((self.flags & 8)) != 0):
                _this = self.absPos
                a = self.absPos
                b = self.parent.absPos
                m11 = a._11
                m12 = a._12
                m13 = a._13
                m21 = a._21
                m22 = a._22
                m23 = a._23
                a31 = a._31
                a32 = a._32
                a33 = a._33
                a41 = a._41
                a42 = a._42
                a43 = a._43
                b11 = b._11
                b12 = b._12
                b13 = b._13
                b21 = b._21
                b22 = b._22
                b23 = b._23
                b31 = b._31
                b32 = b._32
                b33 = b._33
                b41 = b._41
                b42 = b._42
                b43 = b._43
                _this._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
                _this._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
                _this._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
                _this._14 = 0
                _this._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
                _this._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
                _this._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
                _this._24 = 0
                _this._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
                _this._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
                _this._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
                _this._34 = 0
                _this._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
                _this._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
                _this._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
                _this._44 = 1
                self.absPos._41 = (self.x + self.follow.absPos._41)
                self.absPos._42 = (self.y + self.follow.absPos._42)
                self.absPos._43 = (self.z + self.follow.absPos._43)
            else:
                self.absPos.multiply3x4(self.absPos,self.follow.absPos)
        elif ((self.parent is not None) and ((((self.flags & 2048)) == 0))):
            _this = self.absPos
            a = self.absPos
            b = self.parent.absPos
            m11 = a._11
            m12 = a._12
            m13 = a._13
            m21 = a._21
            m22 = a._22
            m23 = a._23
            a31 = a._31
            a32 = a._32
            a33 = a._33
            a41 = a._41
            a42 = a._42
            a43 = a._43
            b11 = b._11
            b12 = b._12
            b13 = b._13
            b21 = b._21
            b22 = b._22
            b23 = b._23
            b31 = b._31
            b32 = b._32
            b33 = b._33
            b41 = b._41
            b42 = b._42
            b43 = b._43
            _this._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
            _this._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
            _this._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
            _this._14 = 0
            _this._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
            _this._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
            _this._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
            _this._24 = 0
            _this._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
            _this._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
            _this._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
            _this._34 = 0
            _this._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
            _this._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
            _this._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
            _this._44 = 1
        if (self.defaultTransform is not None):
            _this = self.absPos
            a = self.defaultTransform
            b = self.absPos
            m11 = a._11
            m12 = a._12
            m13 = a._13
            m21 = a._21
            m22 = a._22
            m23 = a._23
            a31 = a._31
            a32 = a._32
            a33 = a._33
            a41 = a._41
            a42 = a._42
            a43 = a._43
            b11 = b._11
            b12 = b._12
            b13 = b._13
            b21 = b._21
            b22 = b._22
            b23 = b._23
            b31 = b._31
            b32 = b._32
            b33 = b._33
            b41 = b._41
            b42 = b._42
            b43 = b._43
            _this._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
            _this._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
            _this._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
            _this._14 = 0
            _this._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
            _this._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
            _this._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
            _this._24 = 0
            _this._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
            _this._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
            _this._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
            _this._34 = 0
            _this._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
            _this._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
            _this._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
            _this._44 = 1
        if (self.invPos is not None):
            self.invPos._44 = 0

    def sync(self,ctx):
        pass

    def syncRec(self,ctx):
        if (self.currentAnimation is not None):
            old = self.parent
            dt = ctx.elapsedTime
            while ((dt > 0) and ((self.currentAnimation is not None))):
                dt = self.currentAnimation.update(dt)
            if ((self.currentAnimation is not None) and ((((ctx.visibleFlag and ((((self.flags & 2)) != 0))) and ((((self.flags & 4)) == 0))) or ((((self.flags & 64)) != 0))))):
                self.currentAnimation.sync()
            if ((self.parent is None) and ((old is not None))):
                return
        old = ctx.visibleFlag
        if ((((self.flags & 2)) == 0) or (((((self.flags & 4)) != 0) and ((((self.flags & 128)) != 0))))):
            ctx.visibleFlag = False
        if ((ctx.cullingCollider is not None) and (((self.cullingCollider is None) or ((((self.flags & 4096)) != 0))))):
            self.set_cullingCollider(ctx.cullingCollider)
            f = 4096
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        elif (((self.flags & 4096)) != 0):
            self.set_cullingCollider(None)
        prevCollider = ctx.cullingCollider
        if (((self.flags & 128)) != 0):
            ctx.cullingCollider = self.cullingCollider
        changed = (((self.flags & 1)) != 0)
        if changed:
            self.calcAbsPos()
        self.sync(ctx)
        f = 1
        b = (self.follow is not None)
        if b:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 | f)
            _hx_local_2.flags
        else:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 & ~f)
            _hx_local_4.flags
        self.lastFrame = ctx.frame
        p = 0
        _hx_len = len(self.children)
        while (p < _hx_len):
            c = (self.children[p] if p >= 0 and p < len(self.children) else None)
            if (c is None):
                break
            if (c.lastFrame != ctx.frame):
                if changed:
                    f = 1
                    b = True
                    if b:
                        c.flags = (c.flags | f)
                    else:
                        c.flags = (c.flags & ~f)
                c.syncRec(ctx)
            if ((self.children[p] if p >= 0 and p < len(self.children) else None) != c):
                p = 0
                _hx_len = len(self.children)
            else:
                p = (p + 1)
        ctx.visibleFlag = old
        ctx.cullingCollider = prevCollider

    def syncPos(self):
        if (self.parent is not None):
            self.parent.syncPos()
        if (((self.flags & 1)) != 0):
            f = 1
            b = (self.follow is not None)
            if b:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.flags
                _hx_local_0.flags = (_hx_local_1 | f)
                _hx_local_0.flags
            else:
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.flags
                _hx_local_2.flags = (_hx_local_3 & ~f)
                _hx_local_2.flags
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                f = 1
                b = True
                if b:
                    c.flags = (c.flags | f)
                else:
                    c.flags = (c.flags & ~f)

    def emit(self,ctx):
        pass

    def emitRec(self,ctx):
        if ((((self.flags & 2)) == 0) or ((((((self.flags & 4)) != 0) and ((((self.flags & 128)) != 0))) and (not ctx.computingStatic)))):
            return
        if (((self.flags & 1)) != 0):
            if (self.currentAnimation is not None):
                self.currentAnimation.sync()
            f = 1
            b = (self.follow is not None)
            if b:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.flags
                _hx_local_0.flags = (_hx_local_1 | f)
                _hx_local_0.flags
            else:
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.flags
                _hx_local_2.flags = (_hx_local_3 & ~f)
                _hx_local_2.flags
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                f = 1
                b = True
                if b:
                    c.flags = (c.flags | f)
                else:
                    c.flags = (c.flags & ~f)
        if ((((self.flags & 4)) == 0) or ctx.computingStatic):
            self.emit(ctx)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.emitRec(ctx)

    def set_x(self,v):
        self.x = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_y(self,v):
        self.y = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_z(self,v):
        self.z = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_scaleX(self,v):
        self.scaleX = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_scaleY(self,v):
        self.scaleY = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_scaleZ(self,v):
        self.scaleZ = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_defaultTransform(self,v):
        self.defaultTransform = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def setPosition(self,x,y,z):
        self.x = x
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        self.y = y
        f = 1
        b = True
        if b:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 | f)
            _hx_local_4.flags
        else:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 & ~f)
            _hx_local_6.flags
        self.z = z
        f = 1
        b = True
        if b:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | f)
            _hx_local_8.flags
        else:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.flags
            _hx_local_10.flags = (_hx_local_11 & ~f)
            _hx_local_10.flags
        f = 1
        b = True
        if b:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.flags
            _hx_local_12.flags = (_hx_local_13 | f)
            _hx_local_12.flags
        else:
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.flags
            _hx_local_14.flags = (_hx_local_15 & ~f)
            _hx_local_14.flags

    def setTransform(self,mat):
        v = h3d_scene_Object.tmpVec
        if (v is None):
            v = h3d_Vector()
        f = (((mat._11 * mat._11) + ((mat._12 * mat._12))) + ((mat._13 * mat._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((mat._21 * mat._21) + ((mat._22 * mat._22))) + ((mat._23 * mat._23)))
        v.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((mat._31 * mat._31) + ((mat._32 * mat._32))) + ((mat._33 * mat._33)))
        v.z = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if ((((mat._11 * (((mat._22 * mat._33) - ((mat._23 * mat._32))))) + ((mat._12 * (((mat._23 * mat._31) - ((mat._21 * mat._33))))))) + ((mat._13 * (((mat._21 * mat._32) - ((mat._22 * mat._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        s = v
        v = mat._41
        self.x = v
        f = 1
        b = True
        if b:
            _hx_local_3 = self
            _hx_local_4 = _hx_local_3.flags
            _hx_local_3.flags = (_hx_local_4 | f)
            _hx_local_3.flags
        else:
            _hx_local_5 = self
            _hx_local_6 = _hx_local_5.flags
            _hx_local_5.flags = (_hx_local_6 & ~f)
            _hx_local_5.flags
        v = mat._42
        self.y = v
        f = 1
        b = True
        if b:
            _hx_local_7 = self
            _hx_local_8 = _hx_local_7.flags
            _hx_local_7.flags = (_hx_local_8 | f)
            _hx_local_7.flags
        else:
            _hx_local_9 = self
            _hx_local_10 = _hx_local_9.flags
            _hx_local_9.flags = (_hx_local_10 & ~f)
            _hx_local_9.flags
        v = mat._43
        self.z = v
        f = 1
        b = True
        if b:
            _hx_local_11 = self
            _hx_local_12 = _hx_local_11.flags
            _hx_local_11.flags = (_hx_local_12 | f)
            _hx_local_11.flags
        else:
            _hx_local_13 = self
            _hx_local_14 = _hx_local_13.flags
            _hx_local_13.flags = (_hx_local_14 & ~f)
            _hx_local_13.flags
        v = s.x
        self.scaleX = v
        f = 1
        b = True
        if b:
            _hx_local_15 = self
            _hx_local_16 = _hx_local_15.flags
            _hx_local_15.flags = (_hx_local_16 | f)
            _hx_local_15.flags
        else:
            _hx_local_17 = self
            _hx_local_18 = _hx_local_17.flags
            _hx_local_17.flags = (_hx_local_18 & ~f)
            _hx_local_17.flags
        v = s.y
        self.scaleY = v
        f = 1
        b = True
        if b:
            _hx_local_19 = self
            _hx_local_20 = _hx_local_19.flags
            _hx_local_19.flags = (_hx_local_20 | f)
            _hx_local_19.flags
        else:
            _hx_local_21 = self
            _hx_local_22 = _hx_local_21.flags
            _hx_local_21.flags = (_hx_local_22 & ~f)
            _hx_local_21.flags
        v = s.z
        self.scaleZ = v
        f = 1
        b = True
        if b:
            _hx_local_23 = self
            _hx_local_24 = _hx_local_23.flags
            _hx_local_23.flags = (_hx_local_24 | f)
            _hx_local_23.flags
        else:
            _hx_local_25 = self
            _hx_local_26 = _hx_local_25.flags
            _hx_local_25.flags = (_hx_local_26 & ~f)
            _hx_local_25.flags
        h3d_scene_Object.tmpMat.load(mat)
        h3d_scene_Object.tmpMat.prependScale((1.0 / s.x),(1.0 / s.y),(1.0 / s.z))
        self.qRot.initRotateMatrix(h3d_scene_Object.tmpMat)
        f = 1
        b = True
        if b:
            _hx_local_27 = self
            _hx_local_28 = _hx_local_27.flags
            _hx_local_27.flags = (_hx_local_28 | f)
            _hx_local_27.flags
        else:
            _hx_local_29 = self
            _hx_local_30 = _hx_local_29.flags
            _hx_local_29.flags = (_hx_local_30 & ~f)
            _hx_local_29.flags

    def getTransform(self,mat = None):
        if (mat is None):
            mat = h3d_Matrix()
        mat.initScale(self.scaleX,self.scaleY,self.scaleZ)
        self.qRot.toMatrix(h3d_scene_Object.tmpMat)
        mat.multiply3x4(mat,h3d_scene_Object.tmpMat)
        mat._41 = self.x
        mat._42 = self.y
        mat._43 = self.z
        return mat

    def rotate(self,rx,ry,rz):
        qTmp = h3d_Quat()
        qTmp.initRotation(rx,ry,rz)
        self.qRot.multiply(qTmp,self.qRot)
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def setRotation(self,rx,ry,rz):
        self.qRot.initRotation(rx,ry,rz)
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def setRotationAxis(self,ax,ay,az,angle):
        self.qRot.initRotateAxis(ax,ay,az,angle)
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def setDirection(self,v):
        self.qRot.initDirection(v)
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def getLocalDirection(self):
        _this = self.qRot
        return h3d_Vector((1 - ((2 * (((_this.y * _this.y) + ((_this.z * _this.z))))))),(2 * (((_this.x * _this.y) + ((_this.z * _this.w))))),(2 * (((_this.x * _this.z) - ((_this.y * _this.w))))))

    def getRotationQuat(self):
        return self.qRot

    def setRotationQuat(self,q):
        self.qRot = q
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def scale(self,v):
        v1 = (self.scaleX * v)
        self.scaleX = v1
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        v1 = (self.scaleY * v)
        self.scaleY = v1
        f = 1
        b = True
        if b:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 | f)
            _hx_local_4.flags
        else:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 & ~f)
            _hx_local_6.flags
        v1 = (self.scaleZ * v)
        self.scaleZ = v1
        f = 1
        b = True
        if b:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | f)
            _hx_local_8.flags
        else:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.flags
            _hx_local_10.flags = (_hx_local_11 & ~f)
            _hx_local_10.flags
        f = 1
        b = True
        if b:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.flags
            _hx_local_12.flags = (_hx_local_13 | f)
            _hx_local_12.flags
        else:
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.flags
            _hx_local_14.flags = (_hx_local_15 & ~f)
            _hx_local_14.flags

    def setScale(self,v):
        self.scaleX = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        self.scaleY = v
        f = 1
        b = True
        if b:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 | f)
            _hx_local_4.flags
        else:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 & ~f)
            _hx_local_6.flags
        self.scaleZ = v
        f = 1
        b = True
        if b:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | f)
            _hx_local_8.flags
        else:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.flags
            _hx_local_10.flags = (_hx_local_11 & ~f)
            _hx_local_10.flags
        f = 1
        b = True
        if b:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.flags
            _hx_local_12.flags = (_hx_local_13 | f)
            _hx_local_12.flags
        else:
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.flags
            _hx_local_14.flags = (_hx_local_15 & ~f)
            _hx_local_14.flags

    def toString(self):
        _this = Type.getClassName(Type.getClass(self))
        _this1 = _this.split(".")
        return (HxOverrides.stringOrNull(((None if ((len(_this1) == 0)) else _this1.pop()))) + HxOverrides.stringOrNull((("" if ((self.name is None)) else (("(" + HxOverrides.stringOrNull(self.name)) + ")")))))

    def getChildAt(self,n):
        return (self.children[n] if n >= 0 and n < len(self.children) else None)

    def getChildIndex(self,o):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == o):
                return i
        return -1

    def get_numChildren(self):
        return len(self.children)

    def iterator(self):
        return hxd_impl_ArrayIterator_h3d_scene_Object(self.children)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.flags = None
        _hx_o.children = None
        _hx_o.parent = None
        _hx_o.name = None
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.scaleX = None
        _hx_o.scaleY = None
        _hx_o.scaleZ = None
        _hx_o.follow = None
        _hx_o.defaultTransform = None
        _hx_o.currentAnimation = None
        _hx_o.cullingCollider = None
        _hx_o.absPos = None
        _hx_o.invPos = None
        _hx_o.qRot = None
        _hx_o.lastFrame = None
h3d_scene_Object._hx_class = h3d_scene_Object
_hx_classes["h3d.scene.Object"] = h3d_scene_Object


class h3d_scene_Mesh(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Mesh"
    _hx_is_interface = "False"
    __slots__ = ("primitive", "material")
    _hx_fields = ["primitive", "material"]
    _hx_methods = ["getMeshMaterials", "getBoundsRec", "clone", "getLocalCollider", "draw", "emit", "getMaterialByName", "getMaterials", "onAdd", "onRemove", "set_primitive"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Object


    def __init__(self,primitive,material = None,parent = None):
        self.material = None
        self.primitive = None
        super().__init__(parent)
        self.set_primitive(primitive)
        if (material is None):
            material = h3d_mat_MaterialSetup.current.createMaterial()
            material.set_props(material.getDefaultProps())
        self.material = material

    def getMeshMaterials(self):
        return [self.material]

    def getBoundsRec(self,b):
        b = super().getBoundsRec(b)
        if ((self.primitive is None) or ((((self.flags & 512)) != 0))):
            return b
        _this = self.primitive.getBounds()
        b1 = h3d_col_Bounds()
        b1.xMin = _this.xMin
        b1.xMax = _this.xMax
        b1.yMin = _this.yMin
        b1.yMax = _this.yMax
        b1.zMin = _this.zMin
        b1.zMax = _this.zMax
        tmp = b1
        tmp.transform(self.absPos)
        if (tmp.xMin < b.xMin):
            b.xMin = tmp.xMin
        if (tmp.xMax > b.xMax):
            b.xMax = tmp.xMax
        if (tmp.yMin < b.yMin):
            b.yMin = tmp.yMin
        if (tmp.yMax > b.yMax):
            b.yMax = tmp.yMax
        if (tmp.zMin < b.zMin):
            b.zMin = tmp.zMin
        if (tmp.zMax > b.zMax):
            b.zMax = tmp.zMax
        return b

    def clone(self,o = None):
        m = (h3d_scene_Mesh(None,self.material) if ((o is None)) else o)
        m.set_primitive(self.primitive)
        m.material = self.material.clone()
        super().clone(m)
        return m

    def getLocalCollider(self):
        return self.primitive.getCollider()

    def draw(self,ctx):
        self.primitive.render(ctx.engine)

    def emit(self,ctx):
        p = self.material.passes
        while (p is not None):
            ctx.emitPass(p,self).index = 0
            p = p.nextPass

    def getMaterialByName(self,name):
        if ((self.material is not None) and ((self.material.name == name))):
            return self.material
        return super().getMaterialByName(name)

    def getMaterials(self,a = None,recursive = None):
        if (recursive is None):
            recursive = True
        if (a is None):
            a = []
        if ((self.material is not None) and ((python_internal_ArrayImpl.indexOf(a,self.material,None) < 0))):
            x = self.material
            a.append(x)
        return super().getMaterials(a,recursive)

    def onAdd(self):
        super().onAdd()
        if (self.primitive is not None):
            self.primitive.incref()

    def onRemove(self):
        if (self.primitive is not None):
            self.primitive.decref()
        super().onRemove()

    def set_primitive(self,prim):
        if ((prim != self.primitive) and ((((self.flags & 32)) != 0))):
            if (self.primitive is not None):
                self.primitive.decref()
            if (prim is not None):
                prim.incref()
        def _hx_local_1():
            def _hx_local_0():
                self.primitive = prim
                return self.primitive
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.primitive = None
        _hx_o.material = None
h3d_scene_Mesh._hx_class = h3d_scene_Mesh
_hx_classes["h3d.scene.Mesh"] = h3d_scene_Mesh


class h3d_scene_Graphics(h3d_scene_Mesh):
    _hx_class_name = "h3d.scene.Graphics"
    _hx_is_interface = "False"
    __slots__ = ("bprim", "curX", "curY", "curZ", "curR", "curG", "curB", "curA", "lineSize", "lineShader", "tmpPoints", "is3D")
    _hx_fields = ["bprim", "curX", "curY", "curZ", "curR", "curG", "curB", "curA", "lineSize", "lineShader", "tmpPoints", "is3D"]
    _hx_methods = ["onRemove", "set_is3D", "flushLine", "flush", "sync", "draw", "clear", "lineStyle", "setColor", "drawLine", "moveTo", "addVertex", "lineTo"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Mesh


    def __init__(self,parent = None):
        self.is3D = None
        self.tmpPoints = None
        self.lineShader = None
        self.curA = None
        self.curB = None
        self.curG = None
        self.lineSize = 0.
        self.curR = 0.
        self.curZ = 0.
        self.curY = 0.
        self.curX = 0.
        self.bprim = h3d_prim_BigPrimitive(12)
        self.bprim.isStatic = False
        super().__init__(self.bprim,None,parent)
        self.tmpPoints = []
        self.lineShader = h3d_shader_LineShader()
        self.lineShader.setPriority(-100)
        _this = self.material
        _this.set_castShadows(False)
        _this.set_receiveShadows(False)
        self.material.passes.set_enableLights(False)
        self.material.passes.addShader(self.lineShader)
        vcolor = h3d_shader_VertexColorAlpha()
        vcolor.setPriority(-100)
        self.material.passes.addShader(vcolor)
        self.material.passes.set_culling(h3d_mat_Face._hx_None)

    def onRemove(self):
        super().onRemove()
        self.bprim.clear()

    def set_is3D(self,v):
        if (self.is3D == v):
            return v
        if v:
            self.material.passes.removeShader(self.lineShader)
        else:
            self.material.passes.addShader(self.lineShader)
        self.bprim.clear()
        self.tmpPoints = []
        def _hx_local_1():
            def _hx_local_0():
                self.is3D = v
                return self.is3D
            return _hx_local_0()
        return _hx_local_1()

    def flushLine(self):
        _gthis = self
        pts = self.tmpPoints
        last = (len(pts) - 1)
        prev = (pts[last] if last >= 0 and last < len(pts) else None)
        p = (pts[0] if 0 < len(pts) else None)
        closed = (((p.x == prev.x) and ((p.y == prev.y))) and ((p.z == prev.z)))
        count = len(pts)
        if (not closed):
            prevLast = python_internal_ArrayImpl._get(pts, (last - 1))
            if (prevLast is None):
                prevLast = p
            x = h3d_scene__Graphics_GPoint(((prev.x * 2) - prevLast.x),((prev.y * 2) - prevLast.y),((prev.z * 2) - prevLast.z),0,0,0,0)
            pts.append(x)
            pNext = (pts[1] if 1 < len(pts) else None)
            if (pNext is None):
                pNext = p
            prev = h3d_scene__Graphics_GPoint(((p.x * 2) - pNext.x),((p.y * 2) - pNext.y),((p.z * 2) - pNext.z),0,0,0,0)
        elif (p != prev):
            count = (count - 1)
            last = (last - 1)
            prev = (pts[last] if last >= 0 and last < len(pts) else None)
        start = self.bprim.vertexCount()
        pindex = start
        v = 0.
        _g = 0
        _g1 = count
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            next = python_internal_ArrayImpl._get(pts, HxOverrides.mod(((i + 1)), len(pts)))
            nx1 = (prev.y - p.y)
            ny1 = (p.x - prev.x)
            f = ((nx1 * nx1) + ((ny1 * ny1)))
            ns1 = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
            nx2 = (p.y - next.y)
            ny2 = (next.x - p.x)
            f1 = ((nx2 * nx2) + ((ny2 * ny2)))
            ns2 = (1. / ((Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))))
            nx = ((nx1 * ns1) + ((nx2 * ns2)))
            ny = ((ny1 * ns1) + ((ny2 * ns2)))
            f2 = ((nx * nx) + ((ny * ny)))
            ns = (1. / ((Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))))
            nx = (nx * ns)
            ny = (ny * ns)
            size = (((nx * nx1) * ns1) + (((ny * ny1) * ns1)))
            d = ((self.lineSize * 0.5) / size)
            nx = (nx * d)
            ny = (ny * d)
            hasIndex = ((i < ((count - 1))) or closed)
            self.bprim.begin(2,(6 if hasIndex else 0))
            _this = _gthis.bprim
            def _hx_local_7():
                _hx_local_6 = _this.bufPos
                _this.bufPos = (_this.bufPos + 1)
                return _hx_local_6
            key = _hx_local_7()
            python_internal_ArrayImpl._set(_this.tmpBuf, key, (p.x + nx))
            _this1 = _gthis.bprim
            def _hx_local_9():
                _hx_local_8 = _this1.bufPos
                _this1.bufPos = (_this1.bufPos + 1)
                return _hx_local_8
            key1 = _hx_local_9()
            python_internal_ArrayImpl._set(_this1.tmpBuf, key1, (p.y + ny))
            _this2 = _gthis.bprim
            def _hx_local_11():
                _hx_local_10 = _this2.bufPos
                _this2.bufPos = (_this2.bufPos + 1)
                return _hx_local_10
            key2 = _hx_local_11()
            python_internal_ArrayImpl._set(_this2.tmpBuf, key2, p.z)
            _this3 = _gthis.bprim
            def _hx_local_13():
                _hx_local_12 = _this3.bufPos
                _this3.bufPos = (_this3.bufPos + 1)
                return _hx_local_12
            key3 = _hx_local_13()
            python_internal_ArrayImpl._set(_this3.tmpBuf, key3, 0)
            _this4 = _gthis.bprim
            def _hx_local_15():
                _hx_local_14 = _this4.bufPos
                _this4.bufPos = (_this4.bufPos + 1)
                return _hx_local_14
            key4 = _hx_local_15()
            python_internal_ArrayImpl._set(_this4.tmpBuf, key4, 0)
            _this5 = _gthis.bprim
            def _hx_local_17():
                _hx_local_16 = _this5.bufPos
                _this5.bufPos = (_this5.bufPos + 1)
                return _hx_local_16
            key5 = _hx_local_17()
            python_internal_ArrayImpl._set(_this5.tmpBuf, key5, 1)
            _this6 = _gthis.bprim
            def _hx_local_19():
                _hx_local_18 = _this6.bufPos
                _this6.bufPos = (_this6.bufPos + 1)
                return _hx_local_18
            key6 = _hx_local_19()
            python_internal_ArrayImpl._set(_this6.tmpBuf, key6, 0)
            _this7 = _gthis.bprim
            def _hx_local_21():
                _hx_local_20 = _this7.bufPos
                _this7.bufPos = (_this7.bufPos + 1)
                return _hx_local_20
            key7 = _hx_local_21()
            python_internal_ArrayImpl._set(_this7.tmpBuf, key7, v)
            _this8 = _gthis.bprim
            def _hx_local_23():
                _hx_local_22 = _this8.bufPos
                _this8.bufPos = (_this8.bufPos + 1)
                return _hx_local_22
            key8 = _hx_local_23()
            python_internal_ArrayImpl._set(_this8.tmpBuf, key8, p.r)
            _this9 = _gthis.bprim
            def _hx_local_25():
                _hx_local_24 = _this9.bufPos
                _this9.bufPos = (_this9.bufPos + 1)
                return _hx_local_24
            key9 = _hx_local_25()
            python_internal_ArrayImpl._set(_this9.tmpBuf, key9, p.g)
            _this10 = _gthis.bprim
            def _hx_local_27():
                _hx_local_26 = _this10.bufPos
                _this10.bufPos = (_this10.bufPos + 1)
                return _hx_local_26
            key10 = _hx_local_27()
            python_internal_ArrayImpl._set(_this10.tmpBuf, key10, p.b)
            _this11 = _gthis.bprim
            def _hx_local_29():
                _hx_local_28 = _this11.bufPos
                _this11.bufPos = (_this11.bufPos + 1)
                return _hx_local_28
            key11 = _hx_local_29()
            python_internal_ArrayImpl._set(_this11.tmpBuf, key11, p.a)
            _this12 = _gthis.bprim
            def _hx_local_31():
                _hx_local_30 = _this12.bufPos
                _this12.bufPos = (_this12.bufPos + 1)
                return _hx_local_30
            key12 = _hx_local_31()
            python_internal_ArrayImpl._set(_this12.tmpBuf, key12, (p.x - nx))
            _this13 = _gthis.bprim
            def _hx_local_33():
                _hx_local_32 = _this13.bufPos
                _this13.bufPos = (_this13.bufPos + 1)
                return _hx_local_32
            key13 = _hx_local_33()
            python_internal_ArrayImpl._set(_this13.tmpBuf, key13, (p.y - ny))
            _this14 = _gthis.bprim
            def _hx_local_35():
                _hx_local_34 = _this14.bufPos
                _this14.bufPos = (_this14.bufPos + 1)
                return _hx_local_34
            key14 = _hx_local_35()
            python_internal_ArrayImpl._set(_this14.tmpBuf, key14, p.z)
            _this15 = _gthis.bprim
            def _hx_local_37():
                _hx_local_36 = _this15.bufPos
                _this15.bufPos = (_this15.bufPos + 1)
                return _hx_local_36
            key15 = _hx_local_37()
            python_internal_ArrayImpl._set(_this15.tmpBuf, key15, 0)
            _this16 = _gthis.bprim
            def _hx_local_39():
                _hx_local_38 = _this16.bufPos
                _this16.bufPos = (_this16.bufPos + 1)
                return _hx_local_38
            key16 = _hx_local_39()
            python_internal_ArrayImpl._set(_this16.tmpBuf, key16, 0)
            _this17 = _gthis.bprim
            def _hx_local_41():
                _hx_local_40 = _this17.bufPos
                _this17.bufPos = (_this17.bufPos + 1)
                return _hx_local_40
            key17 = _hx_local_41()
            python_internal_ArrayImpl._set(_this17.tmpBuf, key17, 1)
            _this18 = _gthis.bprim
            def _hx_local_43():
                _hx_local_42 = _this18.bufPos
                _this18.bufPos = (_this18.bufPos + 1)
                return _hx_local_42
            key18 = _hx_local_43()
            python_internal_ArrayImpl._set(_this18.tmpBuf, key18, 1)
            _this19 = _gthis.bprim
            def _hx_local_45():
                _hx_local_44 = _this19.bufPos
                _this19.bufPos = (_this19.bufPos + 1)
                return _hx_local_44
            key19 = _hx_local_45()
            python_internal_ArrayImpl._set(_this19.tmpBuf, key19, v)
            _this20 = _gthis.bprim
            def _hx_local_47():
                _hx_local_46 = _this20.bufPos
                _this20.bufPos = (_this20.bufPos + 1)
                return _hx_local_46
            key20 = _hx_local_47()
            python_internal_ArrayImpl._set(_this20.tmpBuf, key20, p.r)
            _this21 = _gthis.bprim
            def _hx_local_49():
                _hx_local_48 = _this21.bufPos
                _this21.bufPos = (_this21.bufPos + 1)
                return _hx_local_48
            key21 = _hx_local_49()
            python_internal_ArrayImpl._set(_this21.tmpBuf, key21, p.g)
            _this22 = _gthis.bprim
            def _hx_local_51():
                _hx_local_50 = _this22.bufPos
                _this22.bufPos = (_this22.bufPos + 1)
                return _hx_local_50
            key22 = _hx_local_51()
            python_internal_ArrayImpl._set(_this22.tmpBuf, key22, p.b)
            _this23 = _gthis.bprim
            def _hx_local_53():
                _hx_local_52 = _this23.bufPos
                _this23.bufPos = (_this23.bufPos + 1)
                return _hx_local_52
            key23 = _hx_local_53()
            python_internal_ArrayImpl._set(_this23.tmpBuf, key23, p.a)
            v = (1 - v)
            if hasIndex:
                pnext = ((start - pindex) if ((i == last)) else 2)
                _this24 = self.bprim
                def _hx_local_55():
                    _hx_local_54 = _this24.idxPos
                    _this24.idxPos = (_this24.idxPos + 1)
                    return _hx_local_54
                key24 = _hx_local_55()
                python_internal_ArrayImpl._set(_this24.tmpIdx, key24, _this24.startIndex)
                _this25 = self.bprim
                def _hx_local_57():
                    _hx_local_56 = _this25.idxPos
                    _this25.idxPos = (_this25.idxPos + 1)
                    return _hx_local_56
                key25 = _hx_local_57()
                python_internal_ArrayImpl._set(_this25.tmpIdx, key25, (1 + _this25.startIndex))
                _this26 = self.bprim
                def _hx_local_59():
                    _hx_local_58 = _this26.idxPos
                    _this26.idxPos = (_this26.idxPos + 1)
                    return _hx_local_58
                key26 = _hx_local_59()
                python_internal_ArrayImpl._set(_this26.tmpIdx, key26, (pnext + _this26.startIndex))
                _this27 = self.bprim
                def _hx_local_61():
                    _hx_local_60 = _this27.idxPos
                    _this27.idxPos = (_this27.idxPos + 1)
                    return _hx_local_60
                key27 = _hx_local_61()
                python_internal_ArrayImpl._set(_this27.tmpIdx, key27, (pnext + _this27.startIndex))
                _this28 = self.bprim
                def _hx_local_63():
                    _hx_local_62 = _this28.idxPos
                    _this28.idxPos = (_this28.idxPos + 1)
                    return _hx_local_62
                key28 = _hx_local_63()
                python_internal_ArrayImpl._set(_this28.tmpIdx, key28, (1 + _this28.startIndex))
                _this29 = self.bprim
                def _hx_local_65():
                    _hx_local_64 = _this29.idxPos
                    _this29.idxPos = (_this29.idxPos + 1)
                    return _hx_local_64
                key29 = _hx_local_65()
                python_internal_ArrayImpl._set(_this29.tmpIdx, key29, ((pnext + 1) + _this29.startIndex))
            pindex = (pindex + 2)
            prev = p
            p = next

    def flush(self):
        if (len(self.tmpPoints) == 0):
            return
        if self.is3D:
            self.flushLine()
            self.tmpPoints = []

    def sync(self,ctx):
        super().sync(ctx)
        self.flush()
        self.bprim.flush()

    def draw(self,ctx):
        self.flush()
        self.bprim.flush()
        super().draw(ctx)

    def clear(self):
        self.flush()
        self.bprim.clear()

    def lineStyle(self,size = None,color = None,alpha = None):
        if (size is None):
            size = 0.
        if (color is None):
            color = 0
        if (alpha is None):
            alpha = 1.
        self.flush()
        if ((size > 0) and ((self.lineSize != size))):
            self.lineSize = size
            if (not self.is3D):
                self.lineShader.width__ = self.lineSize
        self.setColor(color,alpha)

    def setColor(self,color,alpha = None):
        if (alpha is None):
            alpha = 1.
        self.curA = alpha
        self.curR = ((((color >> 16) & 255)) / 255.)
        self.curG = ((((color >> 8) & 255)) / 255.)
        self.curB = (((color & 255)) / 255.)

    def drawLine(self,p1,p2):
        self.moveTo(p1.x,p1.y,p1.z)
        self.lineTo(p2.x,p2.y,p2.z)

    def moveTo(self,x,y,z):
        if self.is3D:
            self.flush()
            self.lineTo(x,y,z)
        else:
            self.curX = x
            self.curY = y
            self.curZ = z

    def addVertex(self,x,y,z,r,g,b,a):
        _this = self.tmpPoints
        x1 = h3d_scene__Graphics_GPoint(x,y,z,r,g,b,a)
        _this.append(x1)

    def lineTo(self,x,y,z):
        _gthis = self
        if self.is3D:
            _this = self.tmpPoints
            x1 = h3d_scene__Graphics_GPoint(x,y,z,self.curR,self.curG,self.curB,self.curA)
            _this.append(x1)
            return
        self.bprim.begin(4,6)
        nx = (x - self.curX)
        ny = (y - self.curY)
        nz = (z - self.curZ)
        x1 = self.curX
        y1 = self.curY
        z1 = self.curZ
        _this = self.bprim.bounds
        if (x1 < _this.xMin):
            _this.xMin = x1
        if (x1 > _this.xMax):
            _this.xMax = x1
        if (y1 < _this.yMin):
            _this.yMin = y1
        if (y1 > _this.yMax):
            _this.yMax = y1
        if (z1 < _this.zMin):
            _this.zMin = z1
        if (z1 > _this.zMax):
            _this.zMax = z1
        _this = self.bprim.bounds
        if (x < _this.xMin):
            _this.xMin = x
        if (x > _this.xMax):
            _this.xMax = x
        if (y < _this.yMin):
            _this.yMin = y
        if (y > _this.yMax):
            _this.yMax = y
        if (z < _this.zMin):
            _this.zMin = z
        if (z > _this.zMax):
            _this.zMax = z
        _this = _gthis.bprim
        def _hx_local_1():
            _hx_local_0 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_0
        key = _hx_local_1()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curX)
        _this = _gthis.bprim
        def _hx_local_3():
            _hx_local_2 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_2
        key = _hx_local_3()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curY)
        _this = _gthis.bprim
        def _hx_local_5():
            _hx_local_4 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_4
        key = _hx_local_5()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curZ)
        _this = _gthis.bprim
        def _hx_local_7():
            _hx_local_6 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_6
        key = _hx_local_7()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nx)
        _this = _gthis.bprim
        def _hx_local_9():
            _hx_local_8 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_8
        key = _hx_local_9()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, ny)
        _this = _gthis.bprim
        def _hx_local_11():
            _hx_local_10 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_10
        key = _hx_local_11()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nz)
        _this = _gthis.bprim
        def _hx_local_13():
            _hx_local_12 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_12
        key = _hx_local_13()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 0)
        _this = _gthis.bprim
        def _hx_local_15():
            _hx_local_14 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_14
        key = _hx_local_15()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 0)
        _this = _gthis.bprim
        def _hx_local_17():
            _hx_local_16 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_16
        key = _hx_local_17()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curR)
        _this = _gthis.bprim
        def _hx_local_19():
            _hx_local_18 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_18
        key = _hx_local_19()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curG)
        _this = _gthis.bprim
        def _hx_local_21():
            _hx_local_20 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_20
        key = _hx_local_21()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curB)
        _this = _gthis.bprim
        def _hx_local_23():
            _hx_local_22 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_22
        key = _hx_local_23()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curA)
        _this = _gthis.bprim
        def _hx_local_25():
            _hx_local_24 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_24
        key = _hx_local_25()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curX)
        _this = _gthis.bprim
        def _hx_local_27():
            _hx_local_26 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_26
        key = _hx_local_27()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curY)
        _this = _gthis.bprim
        def _hx_local_29():
            _hx_local_28 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_28
        key = _hx_local_29()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curZ)
        _this = _gthis.bprim
        def _hx_local_31():
            _hx_local_30 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_30
        key = _hx_local_31()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nx)
        _this = _gthis.bprim
        def _hx_local_33():
            _hx_local_32 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_32
        key = _hx_local_33()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, ny)
        _this = _gthis.bprim
        def _hx_local_35():
            _hx_local_34 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_34
        key = _hx_local_35()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nz)
        _this = _gthis.bprim
        def _hx_local_37():
            _hx_local_36 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_36
        key = _hx_local_37()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 0)
        _this = _gthis.bprim
        def _hx_local_39():
            _hx_local_38 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_38
        key = _hx_local_39()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 1)
        _this = _gthis.bprim
        def _hx_local_41():
            _hx_local_40 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_40
        key = _hx_local_41()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curR)
        _this = _gthis.bprim
        def _hx_local_43():
            _hx_local_42 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_42
        key = _hx_local_43()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curG)
        _this = _gthis.bprim
        def _hx_local_45():
            _hx_local_44 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_44
        key = _hx_local_45()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curB)
        _this = _gthis.bprim
        def _hx_local_47():
            _hx_local_46 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_46
        key = _hx_local_47()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curA)
        _this = _gthis.bprim
        def _hx_local_49():
            _hx_local_48 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_48
        key = _hx_local_49()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curX)
        _this = _gthis.bprim
        def _hx_local_51():
            _hx_local_50 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_50
        key = _hx_local_51()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curY)
        _this = _gthis.bprim
        def _hx_local_53():
            _hx_local_52 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_52
        key = _hx_local_53()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curZ)
        _this = _gthis.bprim
        def _hx_local_55():
            _hx_local_54 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_54
        key = _hx_local_55()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nx)
        _this = _gthis.bprim
        def _hx_local_57():
            _hx_local_56 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_56
        key = _hx_local_57()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, ny)
        _this = _gthis.bprim
        def _hx_local_59():
            _hx_local_58 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_58
        key = _hx_local_59()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nz)
        _this = _gthis.bprim
        def _hx_local_61():
            _hx_local_60 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_60
        key = _hx_local_61()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 1)
        _this = _gthis.bprim
        def _hx_local_63():
            _hx_local_62 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_62
        key = _hx_local_63()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 0)
        _this = _gthis.bprim
        def _hx_local_65():
            _hx_local_64 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_64
        key = _hx_local_65()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curR)
        _this = _gthis.bprim
        def _hx_local_67():
            _hx_local_66 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_66
        key = _hx_local_67()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curG)
        _this = _gthis.bprim
        def _hx_local_69():
            _hx_local_68 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_68
        key = _hx_local_69()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curB)
        _this = _gthis.bprim
        def _hx_local_71():
            _hx_local_70 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_70
        key = _hx_local_71()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curA)
        _this = _gthis.bprim
        def _hx_local_73():
            _hx_local_72 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_72
        key = _hx_local_73()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curX)
        _this = _gthis.bprim
        def _hx_local_75():
            _hx_local_74 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_74
        key = _hx_local_75()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curY)
        _this = _gthis.bprim
        def _hx_local_77():
            _hx_local_76 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_76
        key = _hx_local_77()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curZ)
        _this = _gthis.bprim
        def _hx_local_79():
            _hx_local_78 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_78
        key = _hx_local_79()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nx)
        _this = _gthis.bprim
        def _hx_local_81():
            _hx_local_80 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_80
        key = _hx_local_81()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, ny)
        _this = _gthis.bprim
        def _hx_local_83():
            _hx_local_82 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_82
        key = _hx_local_83()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nz)
        _this = _gthis.bprim
        def _hx_local_85():
            _hx_local_84 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_84
        key = _hx_local_85()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 1)
        _this = _gthis.bprim
        def _hx_local_87():
            _hx_local_86 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_86
        key = _hx_local_87()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 1)
        _this = _gthis.bprim
        def _hx_local_89():
            _hx_local_88 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_88
        key = _hx_local_89()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curR)
        _this = _gthis.bprim
        def _hx_local_91():
            _hx_local_90 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_90
        key = _hx_local_91()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curG)
        _this = _gthis.bprim
        def _hx_local_93():
            _hx_local_92 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_92
        key = _hx_local_93()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curB)
        _this = _gthis.bprim
        def _hx_local_95():
            _hx_local_94 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_94
        key = _hx_local_95()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curA)
        _this = self.bprim
        def _hx_local_97():
            _hx_local_96 = _this.idxPos
            _this.idxPos = (_this.idxPos + 1)
            return _hx_local_96
        key = _hx_local_97()
        python_internal_ArrayImpl._set(_this.tmpIdx, key, _this.startIndex)
        _this = self.bprim
        def _hx_local_99():
            _hx_local_98 = _this.idxPos
            _this.idxPos = (_this.idxPos + 1)
            return _hx_local_98
        key = _hx_local_99()
        python_internal_ArrayImpl._set(_this.tmpIdx, key, (1 + _this.startIndex))
        _this = self.bprim
        def _hx_local_101():
            _hx_local_100 = _this.idxPos
            _this.idxPos = (_this.idxPos + 1)
            return _hx_local_100
        key = _hx_local_101()
        python_internal_ArrayImpl._set(_this.tmpIdx, key, (2 + _this.startIndex))
        _this = self.bprim
        def _hx_local_103():
            _hx_local_102 = _this.idxPos
            _this.idxPos = (_this.idxPos + 1)
            return _hx_local_102
        key = _hx_local_103()
        python_internal_ArrayImpl._set(_this.tmpIdx, key, (2 + _this.startIndex))
        _this = self.bprim
        def _hx_local_105():
            _hx_local_104 = _this.idxPos
            _this.idxPos = (_this.idxPos + 1)
            return _hx_local_104
        key = _hx_local_105()
        python_internal_ArrayImpl._set(_this.tmpIdx, key, (3 + _this.startIndex))
        _this = self.bprim
        def _hx_local_107():
            _hx_local_106 = _this.idxPos
            _this.idxPos = (_this.idxPos + 1)
            return _hx_local_106
        key = _hx_local_107()
        python_internal_ArrayImpl._set(_this.tmpIdx, key, (1 + _this.startIndex))
        self.curX = x
        self.curY = y
        self.curZ = z

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bprim = None
        _hx_o.curX = None
        _hx_o.curY = None
        _hx_o.curZ = None
        _hx_o.curR = None
        _hx_o.curG = None
        _hx_o.curB = None
        _hx_o.curA = None
        _hx_o.lineSize = None
        _hx_o.lineShader = None
        _hx_o.tmpPoints = None
        _hx_o.is3D = None
h3d_scene_Graphics._hx_class = h3d_scene_Graphics
_hx_classes["h3d.scene.Graphics"] = h3d_scene_Graphics


class h3d_scene_Interactive(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Interactive"
    _hx_is_interface = "False"
    _hx_fields = ["shape", "preciseShape", "priority", "cursor", "cancelEvents", "propagateEvents", "enableRightButton", "bestMatch", "scene", "mouseDownButton", "hitPoint"]
    _hx_methods = ["onAdd", "onRemove", "preventClick", "getInteractiveScene", "handleEvent", "set_cursor", "focus", "blur", "isOver", "hasFocus", "onOver", "onOut", "onPush", "onRelease", "onReleaseOutside", "onClick", "onMove", "onWheel", "onFocus", "onFocusLost", "onKeyUp", "onKeyDown", "onCheck", "onTextInput"]
    _hx_statics = []
    _hx_interfaces = [hxd_Interactive]
    _hx_super = h3d_scene_Object


    def __init__(self,shape,parent = None):
        self.scene = None
        self.bestMatch = None
        self.enableRightButton = None
        self.cursor = None
        self.priority = None
        self.preciseShape = None
        self.shape = None
        self.hitPoint = h3d_Vector()
        self.mouseDownButton = -1
        self.propagateEvents = False
        self.cancelEvents = False
        super().__init__(parent)
        self.shape = shape
        self.set_cursor(hxd_Cursor.Button)

    def onAdd(self):
        self.scene = self.getScene()
        if (self.scene is not None):
            self.scene.addEventTarget(self)
        super().onAdd()

    def onRemove(self):
        if (self.scene is not None):
            self.scene.removeEventTarget(self)
            self.scene = None
        super().onRemove()

    def preventClick(self):
        self.mouseDownButton = -1

    def getInteractiveScene(self):
        return self.scene

    def handleEvent(self,e):
        if self.propagateEvents:
            e.propagate = True
        if self.cancelEvents:
            e.cancel = True
        tmp = e.kind.index
        if (tmp == 0):
            if (self.enableRightButton or ((e.button == 0))):
                self.mouseDownButton = e.button
                self.onPush(e)
                if e.cancel:
                    self.mouseDownButton = -1
        elif (tmp == 1):
            if (self.enableRightButton or ((e.button == 0))):
                self.onRelease(e)
                if (self.mouseDownButton == e.button):
                    self.onClick(e)
            self.mouseDownButton = -1
        elif (tmp == 2):
            self.onMove(e)
        elif (tmp == 3):
            self.onOver(e)
        elif (tmp == 4):
            self.onOut(e)
        elif (tmp == 5):
            self.onWheel(e)
        elif (tmp == 6):
            self.onFocus(e)
        elif (tmp == 7):
            self.onFocusLost(e)
        elif (tmp == 8):
            self.onKeyDown(e)
        elif (tmp == 9):
            self.onKeyUp(e)
        elif (tmp == 10):
            if (self.enableRightButton or ((e.button == 0))):
                self.onRelease(e)
                if (self.mouseDownButton == e.button):
                    self.onReleaseOutside(e)
            self.mouseDownButton = -1
        elif (tmp == 11):
            self.onTextInput(e)
        elif (tmp == 12):
            self.onCheck(e)
        else:
            pass

    def set_cursor(self,c):
        self.cursor = c
        if ((self.scene is not None) and ((self.scene.events is not None))):
            self.scene.events.updateCursor(self)
        return c

    def focus(self):
        if ((self.scene is None) or ((self.scene.events is None))):
            return
        self.scene.events.focus(self)

    def blur(self):
        if self.hasFocus():
            self.scene.events.blur()

    def isOver(self):
        if ((self.scene is not None) and ((self.scene.events is not None))):
            return (python_internal_ArrayImpl.indexOf(self.scene.events.overList,self,None) != -1)
        else:
            return False

    def hasFocus(self):
        if ((self.scene is not None) and ((self.scene.events is not None))):
            return (self.scene.events.currentFocus == self)
        else:
            return False

    def onOver(self,e):
        pass

    def onOut(self,e):
        pass

    def onPush(self,e):
        pass

    def onRelease(self,e):
        pass

    def onReleaseOutside(self,e):
        pass

    def onClick(self,e):
        pass

    def onMove(self,e):
        pass

    def onWheel(self,e):
        pass

    def onFocus(self,e):
        pass

    def onFocusLost(self,e):
        pass

    def onKeyUp(self,e):
        pass

    def onKeyDown(self,e):
        pass

    def onCheck(self,e):
        pass

    def onTextInput(self,e):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shape = None
        _hx_o.preciseShape = None
        _hx_o.priority = None
        _hx_o.cursor = None
        _hx_o.cancelEvents = None
        _hx_o.propagateEvents = None
        _hx_o.enableRightButton = None
        _hx_o.bestMatch = None
        _hx_o.scene = None
        _hx_o.mouseDownButton = None
        _hx_o.hitPoint = None
h3d_scene_Interactive._hx_class = h3d_scene_Interactive
_hx_classes["h3d.scene.Interactive"] = h3d_scene_Interactive


class h3d_scene_Light(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Light"
    _hx_is_interface = "False"
    __slots__ = ("shader", "objectDistance", "next", "cullingDistance", "priority")
    _hx_fields = ["shader", "objectDistance", "next", "cullingDistance", "priority"]
    _hx_methods = ["get_color", "set_color", "get_enableSpecular", "set_enableSpecular", "emit", "getShadowDirection"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Object


    def __init__(self,shader,parent = None):
        self.next = None
        self.objectDistance = None
        self.shader = None
        self.priority = 0
        self.cullingDistance = -1
        super().__init__(parent)
        self.shader = shader

    def get_color(self):
        return h3d_Vector()

    def set_color(self,v):
        return v

    def get_enableSpecular(self):
        return False

    def set_enableSpecular(self,b):
        if b:
            raise haxe_Exception.thrown("Not implemented for this light")
        return False

    def emit(self,ctx):
        ctx.emitLight(self)

    def getShadowDirection(self):
        return None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shader = None
        _hx_o.objectDistance = None
        _hx_o.next = None
        _hx_o.cullingDistance = None
        _hx_o.priority = None
h3d_scene_Light._hx_class = h3d_scene_Light
_hx_classes["h3d.scene.Light"] = h3d_scene_Light


class h3d_scene_LightSystem:
    _hx_class_name = "h3d.scene.LightSystem"
    _hx_is_interface = "False"
    __slots__ = ("drawPasses", "ambientLight", "shadowLight", "lightCount", "ctx")
    _hx_fields = ["drawPasses", "ambientLight", "shadowLight", "lightCount", "ctx"]
    _hx_methods = ["initGlobals", "cullLights", "initLights", "computeLight"]

    def __init__(self):
        self.ctx = None
        self.lightCount = None
        self.shadowLight = None
        self.drawPasses = 0
        self.ambientLight = h3d_Vector(1,1,1)

    def initGlobals(self,globals):
        pass

    def cullLights(self):
        l = self.ctx.lights
        prev = None
        s = h3d_col_Sphere()
        while (l is not None):
            s.x = l.absPos._41
            s.y = l.absPos._42
            s.z = l.absPos._43
            s.r = l.cullingDistance
            if (((l.cullingDistance > 0) and (not self.ctx.computingStatic)) and (not self.ctx.camera.frustum.hasSphere(s))):
                if (prev is None):
                    self.ctx.lights = l.next
                else:
                    prev.next = l.next
                l = l.next
                continue
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.lightCount
            _hx_local_0.lightCount = (_hx_local_1 + 1)
            _hx_local_1
            l.objectDistance = 0.
            prev = l
            l = l.next

    def initLights(self,ctx):
        self.lightCount = 0
        self.ctx = ctx
        self.cullLights()
        if ((self.shadowLight is None) or ((((self.shadowLight.flags & 32)) == 0))):
            l = ctx.lights
            while (l is not None):
                dir = l.getShadowDirection()
                if (dir is not None):
                    self.shadowLight = l
                    break
                l = l.next

    def computeLight(self,obj,shaders):
        return shaders

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.drawPasses = None
        _hx_o.ambientLight = None
        _hx_o.shadowLight = None
        _hx_o.lightCount = None
        _hx_o.ctx = None
h3d_scene_LightSystem._hx_class = h3d_scene_LightSystem
_hx_classes["h3d.scene.LightSystem"] = h3d_scene_LightSystem


class h3d_scene_MultiMaterial(h3d_scene_Mesh):
    _hx_class_name = "h3d.scene.MultiMaterial"
    _hx_is_interface = "False"
    __slots__ = ("materials",)
    _hx_fields = ["materials"]
    _hx_methods = ["getMeshMaterials", "clone", "emit", "getMaterialByName", "getMaterials", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Mesh


    def __init__(self,prim,mats = None,parent = None):
        self.materials = None
        super().__init__(prim,(None if ((mats is None)) else (mats[0] if 0 < len(mats) else None)),parent)
        self.materials = ([self.material] if ((mats is None)) else mats)

    def getMeshMaterials(self):
        return list(self.materials)

    def clone(self,o = None):
        m = (h3d_scene_MultiMaterial(None,self.materials) if ((o is None)) else o)
        m.materials = []
        _g = 0
        _g1 = self.materials
        while (_g < len(_g1)):
            mat = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _this = m.materials
            x = (None if ((mat is None)) else mat.clone())
            _this.append(x)
        super().clone(m)
        m.material = (m.materials[0] if 0 < len(m.materials) else None)
        return m

    def emit(self,ctx):
        _g = 0
        _g1 = len(self.materials)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            m = (self.materials[i] if i >= 0 and i < len(self.materials) else None)
            if (m is not None):
                index = i
                if (index is None):
                    index = 0
                p = m.passes
                while (p is not None):
                    ctx.emitPass(p,self).index = index
                    p = p.nextPass

    def getMaterialByName(self,name):
        _g = 0
        _g1 = self.materials
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((m is not None) and ((m.name == name))):
                return m
        return super().getMaterialByName(name)

    def getMaterials(self,a = None,recursive = None):
        if (recursive is None):
            recursive = True
        if (a is None):
            a = []
        _g = 0
        _g1 = self.materials
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((m is not None) and ((python_internal_ArrayImpl.indexOf(a,m,None) < 0))):
                a.append(m)
        if recursive:
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                o.getMaterials(a)
        return a

    def draw(self,ctx):
        if (len(self.materials) > 1):
            self.primitive.selectMaterial(ctx.drawPass.index)
        super().draw(ctx)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.materials = None
h3d_scene_MultiMaterial._hx_class = h3d_scene_MultiMaterial
_hx_classes["h3d.scene.MultiMaterial"] = h3d_scene_MultiMaterial


class h3d_scene__Object_ObjectFlags_Impl_:
    _hx_class_name = "h3d.scene._Object.ObjectFlags_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["FPosChanged", "FVisible", "FCulled", "FFollowPositionOnly", "FLightCameraCenter", "FAllocated", "FAlwaysSync", "FInheritCulled", "FNoSerialize", "FIgnoreBounds", "FIgnoreCollide", "FIgnoreParentTransform", "FCullingColliderInherited", "_new", "toInt", "has", "set"]

    @staticmethod
    def _new(value):
        this1 = value
        return this1

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def has(this1,f):
        return (((this1 & f)) != 0)

    @staticmethod
    def set(this1,f,b):
        if b:
            this1 = (this1 | f)
        else:
            this1 = (this1 & ~f)
        return b
h3d_scene__Object_ObjectFlags_Impl_._hx_class = h3d_scene__Object_ObjectFlags_Impl_
_hx_classes["h3d.scene._Object.ObjectFlags_Impl_"] = h3d_scene__Object_ObjectFlags_Impl_


class h3d_scene__RenderContext_SharedGlobal:
    _hx_class_name = "h3d.scene._RenderContext.SharedGlobal"
    _hx_is_interface = "False"
    __slots__ = ("gid", "value")
    _hx_fields = ["gid", "value"]

    def __init__(self,gid,value):
        self.gid = gid
        self.value = value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.gid = None
        _hx_o.value = None
h3d_scene__RenderContext_SharedGlobal._hx_class = h3d_scene__RenderContext_SharedGlobal
_hx_classes["h3d.scene._RenderContext.SharedGlobal"] = h3d_scene__RenderContext_SharedGlobal


class h3d_scene_RenderContext(h3d_impl_RenderContext):
    _hx_class_name = "h3d.scene.RenderContext"
    _hx_is_interface = "False"
    __slots__ = ("camera", "scene", "drawPass", "pbrLightPass", "computingStatic", "sharedGlobals", "lightSystem", "extraShaders", "visibleFlag", "shaderBuffers", "cullingCollider", "allocPool", "allocFirst", "cachedShaderList", "cachedPassObjects", "cachedPos", "passes", "lights", "currentManager")
    _hx_fields = ["camera", "scene", "drawPass", "pbrLightPass", "computingStatic", "sharedGlobals", "lightSystem", "extraShaders", "visibleFlag", "shaderBuffers", "cullingCollider", "allocPool", "allocFirst", "cachedShaderList", "cachedPassObjects", "cachedPos", "passes", "lights", "currentManager"]
    _hx_methods = ["emit", "start", "nextPass", "getGlobal", "setGlobal", "setGlobalID", "emitPass", "allocShaderList", "emitLight", "uploadParams", "done"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_impl_RenderContext


    def __init__(self):
        self.currentManager = None
        self.lights = None
        self.passes = None
        self.cachedPos = None
        self.cachedPassObjects = None
        self.cachedShaderList = None
        self.allocFirst = None
        self.allocPool = None
        self.cullingCollider = None
        self.shaderBuffers = None
        self.visibleFlag = None
        self.extraShaders = None
        self.lightSystem = None
        self.sharedGlobals = None
        self.computingStatic = None
        self.pbrLightPass = None
        self.drawPass = None
        self.scene = None
        self.camera = None
        super().__init__()
        self.cachedShaderList = []
        self.cachedPassObjects = []

    def emit(self,mat,obj,index = None):
        if (index is None):
            index = 0
        p = mat.passes
        while (p is not None):
            self.emitPass(p,obj).index = index
            p = p.nextPass

    def start(self):
        self.sharedGlobals = []
        self.lights = None
        self.drawPass = None
        self.passes = None
        self.lights = None
        self.cachedPos = 0
        self.visibleFlag = True
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.time
        _hx_local_0.time = (_hx_local_1 + self.elapsedTime)
        _hx_local_0.time
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.frame
        _hx_local_2.frame = (_hx_local_3 + 1)
        _hx_local_3

    def nextPass(self):
        self.cachedPos = 0
        self.drawPass = None

    def getGlobal(self,name):
        id = hxsl_Globals.allocID(name)
        _g = 0
        _g1 = self.sharedGlobals
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (g.gid == id):
                return g.value
        return None

    def setGlobal(self,name,value):
        self.setGlobalID(hxsl_Globals.allocID(name),value)

    def setGlobalID(self,gid,value):
        _g = 0
        _g1 = self.sharedGlobals
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (g.gid == gid):
                g.value = value
                return
        _this = self.sharedGlobals
        x = h3d_scene__RenderContext_SharedGlobal(gid,value)
        _this.append(x)

    def emitPass(self,_hx_pass,obj):
        o = self.allocPool
        if (o is None):
            o = h3d_pass_PassObject()
            o.nextAlloc = self.allocFirst
            self.allocFirst = o
        else:
            self.allocPool = o.nextAlloc
        o._hx_pass = _hx_pass
        o.obj = obj
        o.next = self.passes
        self.passes = o
        return o

    def allocShaderList(self,s,next = None):
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.cachedPos
            _hx_local_0.cachedPos = (_hx_local_1 + 1)
            return _hx_local_1
        sl = python_internal_ArrayImpl._get(self.cachedShaderList, _hx_local_2())
        if (sl is None):
            sl = hxsl_ShaderList(None)
            python_internal_ArrayImpl._set(self.cachedShaderList, (self.cachedPos - 1), sl)
        sl.s = s
        sl.next = next
        return sl

    def emitLight(self,l):
        l.next = self.lights
        self.lights = l

    def uploadParams(self):
        self.currentManager.fillParams(self.shaderBuffers,self.drawPass.shader,self.drawPass.shaders)
        self.engine.uploadShaderBuffers(self.shaderBuffers,1)
        self.engine.uploadShaderBuffers(self.shaderBuffers,2)
        self.engine.uploadShaderBuffers(self.shaderBuffers,3)

    def done(self):
        self.drawPass = None
        p = self.allocFirst
        while ((p is not None) and ((p != self.allocPool))):
            p.obj = None
            p._hx_pass = None
            p.shader = None
            p.shaders = None
            p.next = None
            p.index = 0
            p.texture = 0
            p = p.nextAlloc
        if (self.allocPool is not None):
            self.allocFirst = self.allocFirst.nextAlloc
        self.allocPool = self.allocFirst
        _g = 0
        _g1 = self.cachedShaderList
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.s = None
            c.next = None
        self.passes = None
        self.lights = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.camera = None
        _hx_o.scene = None
        _hx_o.drawPass = None
        _hx_o.pbrLightPass = None
        _hx_o.computingStatic = None
        _hx_o.sharedGlobals = None
        _hx_o.lightSystem = None
        _hx_o.extraShaders = None
        _hx_o.visibleFlag = None
        _hx_o.shaderBuffers = None
        _hx_o.cullingCollider = None
        _hx_o.allocPool = None
        _hx_o.allocFirst = None
        _hx_o.cachedShaderList = None
        _hx_o.cachedPassObjects = None
        _hx_o.cachedPos = None
        _hx_o.passes = None
        _hx_o.lights = None
        _hx_o.currentManager = None
h3d_scene_RenderContext._hx_class = h3d_scene_RenderContext
_hx_classes["h3d.scene.RenderContext"] = h3d_scene_RenderContext


class h3d_scene_PassObjects:
    _hx_class_name = "h3d.scene.PassObjects"
    _hx_is_interface = "False"
    __slots__ = ("name", "passes", "rendered")
    _hx_fields = ["name", "passes", "rendered"]

    def __init__(self):
        self.rendered = None
        self.name = None
        self.passes = h3d_pass_PassList()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.passes = None
        _hx_o.rendered = None
h3d_scene_PassObjects._hx_class = h3d_scene_PassObjects
_hx_classes["h3d.scene.PassObjects"] = h3d_scene_PassObjects

class h3d_scene_RenderMode(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.scene.RenderMode"
    _hx_constructs = ["Default", "LightProbe"]
h3d_scene_RenderMode.Default = h3d_scene_RenderMode("Default", 0, ())
h3d_scene_RenderMode.LightProbe = h3d_scene_RenderMode("LightProbe", 1, ())
h3d_scene_RenderMode._hx_class = h3d_scene_RenderMode
_hx_classes["h3d.scene.RenderMode"] = h3d_scene_RenderMode


class h3d_scene_Renderer(hxd_impl_AnyProps):
    _hx_class_name = "h3d.scene.Renderer"
    _hx_is_interface = "False"
    __slots__ = ("defaultPass", "passObjects", "allPasses", "emptyPasses", "ctx", "hasSetTarget", "frontToBack", "backToFront", "effects", "renderMode")
    _hx_fields = ["defaultPass", "passObjects", "allPasses", "emptyPasses", "ctx", "hasSetTarget", "frontToBack", "backToFront", "effects", "renderMode"]
    _hx_methods = ["getEffect", "dispose", "mark", "addShader", "getPass", "getPassByName", "debugCompileShader", "hasFeature", "getDefaultLight", "getLightSystem", "depthSort", "clear", "allocTarget", "copy", "setTarget", "setTargets", "resetTarget", "has", "get", "draw", "render", "computeStatic", "start", "process"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_impl_AnyProps


    def __init__(self):
        self.backToFront = None
        self.frontToBack = None
        self.ctx = None
        self.defaultPass = None
        self.renderMode = h3d_scene_RenderMode.Default
        self.effects = []
        self.hasSetTarget = False
        self.emptyPasses = h3d_pass_PassList()
        self.allPasses = []
        self.passObjects = haxe_ds_StringMap()
        self.set_props(self.getDefaultProps())
        _g = self.depthSort
        frontToBack = True
        def _hx_local_0(passes):
            _g(frontToBack,passes)
        self.frontToBack = _hx_local_0
        _g1 = self.depthSort
        frontToBack1 = False
        def _hx_local_1(passes):
            _g1(frontToBack1,passes)
        self.backToFront = _hx_local_1

    def getEffect(self,cl):
        _g = 0
        _g1 = self.effects
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f1 = Std.downcast(f,cl)
            if (f1 is not None):
                return f1
        return None

    def dispose(self):
        _g = 0
        _g1 = self.allPasses
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.dispose()
        _g = 0
        _g1 = self.effects
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f.dispose()
        self.passObjects = haxe_ds_StringMap()

    def mark(self,id):
        pass

    def addShader(self,s):
        pass

    def getPass(self,c):
        _g = 0
        _g1 = self.allPasses
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if Std.isOfType(p,c):
                return p
        return None

    def getPassByName(self,name):
        _g = 0
        _g1 = self.allPasses
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (p.name == name):
                return p
        return None

    def debugCompileShader(self,_hx_pass):
        p = self.getPassByName(_hx_pass.name)
        if (p is None):
            p = self.defaultPass
        p.setContext(self.ctx)
        return p.compileShader(_hx_pass)

    def hasFeature(self,f):
        return h3d_Engine.CURRENT.driver.hasFeature(f)

    def getDefaultLight(self,l):
        return l

    def getLightSystem(self):
        return self.ctx.scene.lightSystem

    def depthSort(self,frontToBack,passes):
        cam = self.ctx.camera.m
        _g_o = passes.current
        while (_g_o is not None):
            tmp = _g_o
            _g_o = _g_o.next
            p = tmp
            z = ((((p.obj.absPos._41 * cam._13) + ((p.obj.absPos._42 * cam._23))) + ((p.obj.absPos._43 * cam._33))) + cam._43)
            w = ((((p.obj.absPos._41 * cam._14) + ((p.obj.absPos._42 * cam._24))) + ((p.obj.absPos._43 * cam._34))) + cam._44)
            p.depth = (z / w)
        if frontToBack:
            _hx_list = passes.current
            tmp = None
            if (_hx_list is None):
                tmp = None
            else:
                insize = 1
                nmerges = None
                psize = 0
                qsize = 0
                p = None
                q = None
                e = None
                tail = None
                while True:
                    p = _hx_list
                    _hx_list = None
                    tail = None
                    nmerges = 0
                    while (p is not None):
                        nmerges = (nmerges + 1)
                        q = p
                        psize = 0
                        _g = 0
                        _g1 = insize
                        while (_g < _g1):
                            i = _g
                            _g = (_g + 1)
                            psize = (psize + 1)
                            q = q.next
                            if (q is None):
                                break
                        qsize = insize
                        while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                            if (psize == 0):
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            elif (((qsize == 0) or ((q is None))) or ((((1 if ((p.depth > q.depth)) else -1)) <= 0))):
                                e = p
                                p = p.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            if (tail is not None):
                                tail.next = e
                            else:
                                _hx_list = e
                            tail = e
                        p = q
                    tail.next = None
                    if (nmerges <= 1):
                        break
                    insize = (insize * 2)
                tmp = _hx_list
            passes.current = tmp
        else:
            _hx_list = passes.current
            tmp = None
            if (_hx_list is None):
                tmp = None
            else:
                insize = 1
                nmerges = None
                psize = 0
                qsize = 0
                p = None
                q = None
                e = None
                tail = None
                while True:
                    p = _hx_list
                    _hx_list = None
                    tail = None
                    nmerges = 0
                    while (p is not None):
                        nmerges = (nmerges + 1)
                        q = p
                        psize = 0
                        _g = 0
                        _g1 = insize
                        while (_g < _g1):
                            i = _g
                            _g = (_g + 1)
                            psize = (psize + 1)
                            q = q.next
                            if (q is None):
                                break
                        qsize = insize
                        while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                            if (psize == 0):
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            elif (((qsize == 0) or ((q is None))) or ((((-1 if ((p.depth > q.depth)) else 1)) <= 0))):
                                e = p
                                p = p.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            if (tail is not None):
                                tail.next = e
                            else:
                                _hx_list = e
                            tail = e
                        p = q
                    tail.next = None
                    if (nmerges <= 1):
                        break
                    insize = (insize * 2)
                tmp = _hx_list
            passes.current = tmp

    def clear(self,color = None,depth = None,stencil = None):
        self.ctx.engine.clear(color,depth,stencil)

    def allocTarget(self,name,depth = None,size = None,format = None):
        if (depth is None):
            depth = True
        if (size is None):
            size = 1.
        return self.ctx.textures.allocTarget(name,Math.floor(((self.ctx.engine.width * size) + 0.5)),Math.floor(((self.ctx.engine.height * size) + 0.5)),depth,format)

    def copy(self,_hx_from,to,blend = None):
        h3d_pass_Copy.run(_hx_from,to,blend)

    def setTarget(self,tex):
        if self.hasSetTarget:
            self.ctx.engine.popTarget()
        self.ctx.engine.pushTarget(tex)
        self.hasSetTarget = True

    def setTargets(self,textures):
        if self.hasSetTarget:
            self.ctx.engine.popTarget()
        self.ctx.engine.pushTargets(textures)
        self.hasSetTarget = True

    def resetTarget(self):
        if self.hasSetTarget:
            self.ctx.engine.popTarget()
            self.hasSetTarget = False

    def has(self,name):
        return (self.passObjects.h.get(name,None) is not None)

    def get(self,name):
        p = self.passObjects.h.get(name,None)
        if (p is None):
            return self.emptyPasses
        p.rendered = True
        return p.passes

    def draw(self,name):
        self.defaultPass.draw(self.get(name))

    def render(self):
        raise haxe_Exception.thrown("Not implemented")

    def computeStatic(self):
        raise haxe_Exception.thrown("Not implemented")

    def start(self):
        pass

    def process(self,passes):
        self.hasSetTarget = False
        _g = 0
        _g1 = self.allPasses
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.setContext(self.ctx)
        _g = 0
        while (_g < len(passes)):
            p = (passes[_g] if _g >= 0 and _g < len(passes) else None)
            _g = (_g + 1)
            self.passObjects.h[p.name] = p
        self.ctx.textures.begin()
        if self.ctx.computingStatic:
            self.computeStatic()
        else:
            self.render()
        self.resetTarget()
        _g = 0
        while (_g < len(passes)):
            p = (passes[_g] if _g >= 0 and _g < len(passes) else None)
            _g = (_g + 1)
            self.passObjects.h[p.name] = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.defaultPass = None
        _hx_o.passObjects = None
        _hx_o.allPasses = None
        _hx_o.emptyPasses = None
        _hx_o.ctx = None
        _hx_o.hasSetTarget = None
        _hx_o.frontToBack = None
        _hx_o.backToFront = None
        _hx_o.effects = None
        _hx_o.renderMode = None
h3d_scene_Renderer._hx_class = h3d_scene_Renderer
_hx_classes["h3d.scene.Renderer"] = h3d_scene_Renderer


class h3d_scene_Scene(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Scene"
    _hx_is_interface = "False"
    __slots__ = ("camera", "lightSystem", "renderer", "ctx", "interactives", "events", "hitInteractives", "eventListeners", "window", "hardwarePass")
    _hx_fields = ["camera", "lightSystem", "renderer", "ctx", "interactives", "events", "hitInteractives", "eventListeners", "window", "hardwarePass"]
    _hx_methods = ["setEvents", "addEventListener", "removeEventListener", "dispatchListeners", "set_renderer", "sortHitPointByCameraDistance", "dispatchEvent", "isInteractiveVisible", "handleEvent", "clone", "dispose", "addEventTarget", "removeEventTarget", "setElapsedTime", "hardwarePick", "syncOnly", "computeStatic", "render", "serializeScene"]
    _hx_statics = []
    _hx_interfaces = [hxd_InteractiveScene, h3d_IDrawable]
    _hx_super = h3d_scene_Object


    def __init__(self,createRenderer = None,createLightSystem = None):
        if (createRenderer is None):
            createRenderer = True
        if (createLightSystem is None):
            createLightSystem = True
        self.hardwarePass = None
        self.window = None
        self.eventListeners = None
        self.hitInteractives = None
        self.events = None
        self.interactives = None
        self.ctx = None
        self.renderer = None
        self.lightSystem = None
        self.camera = None
        super().__init__(None)
        self.window = hxd_Window.getInstance()
        self.eventListeners = []
        self.hitInteractives = []
        self.interactives = []
        self.camera = h3d_Camera()
        engine = h3d_Engine.CURRENT
        if (engine is not None):
            self.camera.screenRatio = (engine.width / engine.height)
        self.ctx = h3d_scene_RenderContext()
        if createRenderer:
            self.set_renderer(h3d_mat_MaterialSetup.current.createRenderer())
        if createLightSystem:
            self.lightSystem = h3d_mat_MaterialSetup.current.createLightSystem()

    def setEvents(self,events):
        self.events = events

    def addEventListener(self,f):
        _this = self.eventListeners
        _this.append(f)

    def removeEventListener(self,f):
        _g = 0
        _g1 = self.eventListeners
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if Reflect.compareMethods(e,f):
                python_internal_ArrayImpl.remove(self.eventListeners,e)
                return True
        return False

    def dispatchListeners(self,event):
        _g = 0
        _g1 = self.eventListeners
        while (_g < len(_g1)):
            l = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            l(event)
            if (not event.propagate):
                break

    def set_renderer(self,r):
        self.renderer = r
        if (r is not None):
            r.ctx = self.ctx
        return r

    def sortHitPointByCameraDistance(self,i1,i2):
        z1 = i1.hitPoint.w
        z2 = i2.hitPoint.w
        if (z1 > z2):
            return -1
        return 1

    def dispatchEvent(self,event,to):
        i = to
        i.handleEvent(event)

    def isInteractiveVisible(self,i):
        o = i
        while (o != self):
            if ((o is None) or ((((o.flags & 2)) == 0))):
                return False
            o = o.parent
        return True

    def handleEvent(self,event,last):
        if (len(self.interactives) == 0):
            return None
        if (len(self.hitInteractives) == 0):
            screenX = ((((event.relX / self.window.get_width()) - 0.5)) * 2)
            screenY = (-(((event.relY / self.window.get_height()) - 0.5)) * 2)
            p0 = self.camera.unproject(screenX,screenY,0)
            p1 = self.camera.unproject(screenX,screenY,1)
            x = p0.x
            y = p0.y
            z = p0.z
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p1_x = x
            p1_y = y
            p1_z = z
            x = p1.x
            y = p1.y
            z = p1.z
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p2_x = x
            p2_y = y
            p2_z = z
            r = h3d_col_Ray()
            r.px = p1_x
            r.py = p1_y
            r.pz = p1_z
            r.lx = (p2_x - p1_x)
            r.ly = (p2_y - p1_y)
            r.lz = (p2_z - p1_z)
            r.normalize()
            r1 = r
            saveR_px = r1.px
            saveR_py = r1.py
            saveR_pz = r1.pz
            saveR_lx = r1.lx
            saveR_ly = r1.ly
            saveR_lz = r1.lz
            priority = -2147483648
            _g = 0
            _g1 = self.interactives
            while (_g < len(_g1)):
                i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (i.priority < priority):
                    continue
                p = i
                while ((p is not None) and ((((p.flags & 2)) != 0))):
                    p = p.parent
                if (p is not None):
                    continue
                minv = i.getInvPos()
                x = r1.px
                y = r1.py
                z = r1.pz
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                p_w = 1.
                px = ((((p_x * minv._11) + ((p_y * minv._21))) + ((p_z * minv._31))) + ((p_w * minv._41)))
                py = ((((p_x * minv._12) + ((p_y * minv._22))) + ((p_z * minv._32))) + ((p_w * minv._42)))
                pz = ((((p_x * minv._13) + ((p_y * minv._23))) + ((p_z * minv._33))) + ((p_w * minv._43)))
                p_x = px
                p_y = py
                p_z = pz
                r1.px = p_x
                r1.py = p_y
                r1.pz = p_z
                x1 = r1.lx
                y1 = r1.ly
                z1 = r1.lz
                if (z1 is None):
                    z1 = 0.
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                l_x = x1
                l_y = y1
                l_z = z1
                l_w = 1.
                px1 = (((l_x * minv._11) + ((l_y * minv._21))) + ((l_z * minv._31)))
                py1 = (((l_x * minv._12) + ((l_y * minv._22))) + ((l_z * minv._32)))
                pz1 = (((l_x * minv._13) + ((l_y * minv._23))) + ((l_z * minv._33)))
                l_x = px1
                l_y = py1
                l_z = pz1
                r1.lx = l_x
                r1.ly = l_y
                r1.lz = l_z
                r1.normalize()
                if (r1.lx != r1.lx):
                    r1.px = saveR_px
                    r1.py = saveR_py
                    r1.pz = saveR_pz
                    r1.lx = saveR_lx
                    r1.ly = saveR_ly
                    r1.lz = saveR_lz
                    continue
                hit = i.shape.rayIntersection(r1,i.bestMatch)
                if (hit < 0):
                    r1.px = saveR_px
                    r1.py = saveR_py
                    r1.pz = saveR_pz
                    r1.lx = saveR_lx
                    r1.ly = saveR_ly
                    r1.lz = saveR_lz
                    continue
                x2 = (r1.px + ((hit * r1.lx)))
                y2 = (r1.py + ((hit * r1.ly)))
                z2 = (r1.pz + ((hit * r1.lz)))
                if (z2 is None):
                    z2 = 0.
                if (y2 is None):
                    y2 = 0.
                if (x2 is None):
                    x2 = 0.
                hitPoint_x = x2
                hitPoint_y = y2
                hitPoint_z = z2
                r1.px = saveR_px
                r1.py = saveR_py
                r1.pz = saveR_pz
                r1.lx = saveR_lx
                r1.ly = saveR_ly
                r1.lz = saveR_lz
                i.hitPoint.x = hitPoint_x
                i.hitPoint.y = hitPoint_y
                i.hitPoint.z = hitPoint_z
                if (i.priority > priority):
                    while (len(self.hitInteractives) > 0):
                        _this = self.hitInteractives
                        if (len(_this) != 0):
                            _this.pop()
                    priority = i.priority
                _this1 = self.hitInteractives
                _this1.append(i)
            if (len(self.hitInteractives) == 0):
                return None
            if (len(self.hitInteractives) > 1):
                _g = 0
                _g1 = self.hitInteractives
                while (_g < len(_g1)):
                    i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    m = i.invPos
                    wfactor = 0.
                    if (i.preciseShape is not None):
                        x = r1.px
                        y = r1.py
                        z = r1.pz
                        if (z is None):
                            z = 0.
                        if (y is None):
                            y = 0.
                        if (x is None):
                            x = 0.
                        p_x = x
                        p_y = y
                        p_z = z
                        p_w = 1.
                        px = ((((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31))) + ((p_w * m._41)))
                        py = ((((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32))) + ((p_w * m._42)))
                        pz = ((((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33))) + ((p_w * m._43)))
                        p_x = px
                        p_y = py
                        p_z = pz
                        r1.px = p_x
                        r1.py = p_y
                        r1.pz = p_z
                        x1 = r1.lx
                        y1 = r1.ly
                        z1 = r1.lz
                        if (z1 is None):
                            z1 = 0.
                        if (y1 is None):
                            y1 = 0.
                        if (x1 is None):
                            x1 = 0.
                        l_x = x1
                        l_y = y1
                        l_z = z1
                        l_w = 1.
                        px1 = (((l_x * m._11) + ((l_y * m._21))) + ((l_z * m._31)))
                        py1 = (((l_x * m._12) + ((l_y * m._22))) + ((l_z * m._32)))
                        pz1 = (((l_x * m._13) + ((l_y * m._23))) + ((l_z * m._33)))
                        l_x = px1
                        l_y = py1
                        l_z = pz1
                        r1.lx = l_x
                        r1.ly = l_y
                        r1.lz = l_z
                        r1.normalize()
                        hit = i.preciseShape.rayIntersection(r1,i.bestMatch)
                        if (hit > 0):
                            x2 = (r1.px + ((hit * r1.lx)))
                            y2 = (r1.py + ((hit * r1.ly)))
                            z2 = (r1.pz + ((hit * r1.lz)))
                            if (z2 is None):
                                z2 = 0.
                            if (y2 is None):
                                y2 = 0.
                            if (x2 is None):
                                x2 = 0.
                            hitPoint_x = x2
                            hitPoint_y = y2
                            hitPoint_z = z2
                            i.hitPoint.x = hitPoint_x
                            i.hitPoint.y = hitPoint_y
                            i.hitPoint.z = hitPoint_z
                        else:
                            wfactor = 1.
                        r1.px = saveR_px
                        r1.py = saveR_py
                        r1.pz = saveR_pz
                        r1.lx = saveR_lx
                        r1.ly = saveR_ly
                        r1.lz = saveR_lz
                    _this = i.hitPoint
                    x3 = _this.x
                    y3 = _this.y
                    z3 = _this.z
                    w = _this.w
                    if (w is None):
                        w = 1.
                    if (z3 is None):
                        z3 = 0.
                    if (y3 is None):
                        y3 = 0.
                    if (x3 is None):
                        x3 = 0.
                    p_x1 = x3
                    p_y1 = y3
                    p_z1 = z3
                    p_w1 = w
                    p_w1 = 1
                    m1 = i.absPos
                    px2 = ((((p_x1 * m1._11) + ((p_y1 * m1._21))) + ((p_z1 * m1._31))) + ((p_w1 * m1._41)))
                    py2 = ((((p_x1 * m1._12) + ((p_y1 * m1._22))) + ((p_z1 * m1._32))) + ((p_w1 * m1._42)))
                    pz2 = ((((p_x1 * m1._13) + ((p_y1 * m1._23))) + ((p_z1 * m1._33))) + ((p_w1 * m1._43)))
                    p_x1 = px2
                    p_y1 = py2
                    p_z1 = pz2
                    m2 = self.camera.m
                    px3 = ((((p_x1 * m2._11) + ((p_y1 * m2._21))) + ((p_z1 * m2._31))) + ((p_w1 * m2._41)))
                    py3 = ((((p_x1 * m2._12) + ((p_y1 * m2._22))) + ((p_z1 * m2._32))) + ((p_w1 * m2._42)))
                    pz3 = ((((p_x1 * m2._13) + ((p_y1 * m2._23))) + ((p_z1 * m2._33))) + ((p_w1 * m2._43)))
                    iw = (1 / (((((p_x1 * m2._14) + ((p_y1 * m2._24))) + ((p_z1 * m2._34))) + ((p_w1 * m2._44)))))
                    p_x1 = (px3 * iw)
                    p_y1 = (py3 * iw)
                    p_z1 = (pz3 * iw)
                    p_w1 = 1
                    i.hitPoint.w = (p_z1 + wfactor)
                self.hitInteractives.sort(key= python_lib_Functools.cmp_to_key(self.sortHitPointByCameraDistance))
            self.hitInteractives.insert(0, None)
        while (len(self.hitInteractives) > 0):
            _this = self.hitInteractives
            i = (None if ((len(_this) == 0)) else _this.pop())
            if (i is None):
                return None
            event.relX = i.hitPoint.x
            event.relY = i.hitPoint.y
            event.relZ = i.hitPoint.z
            i.handleEvent(event)
            if event.cancel:
                event.cancel = False
                event.propagate = False
                continue
            if (not event.propagate):
                while (len(self.hitInteractives) > 0):
                    _this1 = self.hitInteractives
                    if (len(_this1) != 0):
                        _this1.pop()
            return i
        return None

    def clone(self,o = None):
        s = (h3d_scene_Scene() if ((o is None)) else o)
        s.camera = self.camera.clone()
        super().clone(s)
        return s

    def dispose(self):
        if (((self.flags & 32)) != 0):
            self.onRemove()
        if (self.hardwarePass is not None):
            self.hardwarePass.dispose()
            self.hardwarePass = None
        self.ctx.dispose()
        if (self.renderer is not None):
            self.renderer.dispose()
            self.set_renderer(h3d_scene_Renderer())

    def addEventTarget(self,i):
        if (python_internal_ArrayImpl.indexOf(self.interactives,i,None) >= 0):
            raise haxe_Exception.thrown("assert")
        _this = self.interactives
        _this.append(i)

    def removeEventTarget(self,i):
        if python_internal_ArrayImpl.remove(self.interactives,i):
            if (self.events is not None):
                self.events.onRemove(i)
            python_internal_ArrayImpl.remove(self.hitInteractives,i)

    def setElapsedTime(self,elapsedTime):
        self.ctx.elapsedTime = elapsedTime

    def hardwarePick(self,pixelX,pixelY):
        _gthis = self
        engine = h3d_Engine.CURRENT
        self.camera.screenRatio = (engine.width / engine.height)
        self.camera.update()
        self.ctx.camera = self.camera
        self.ctx.engine = engine
        self.ctx.scene = self
        self.ctx.start()
        ray = self.camera.rayFromScreen(pixelX,pixelY)
        savedRay_pz = None
        savedRay_py = None
        savedRay_px = None
        savedRay_lz = None
        savedRay_ly = None
        savedRay_lx = None
        savedRay_px = ray.px
        savedRay_py = ray.py
        savedRay_pz = ray.pz
        savedRay_lx = ray.lx
        savedRay_ly = ray.ly
        savedRay_lz = ray.lz
        def _hx_local_0(m):
            if (m.primitive is None):
                return
            m1 = m.getInvPos()
            x = ray.px
            y = ray.py
            z = ray.pz
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p_x = x
            p_y = y
            p_z = z
            p_w = 1.
            px = ((((p_x * m1._11) + ((p_y * m1._21))) + ((p_z * m1._31))) + ((p_w * m1._41)))
            py = ((((p_x * m1._12) + ((p_y * m1._22))) + ((p_z * m1._32))) + ((p_w * m1._42)))
            pz = ((((p_x * m1._13) + ((p_y * m1._23))) + ((p_z * m1._33))) + ((p_w * m1._43)))
            p_x = px
            p_y = py
            p_z = pz
            ray.px = p_x
            ray.py = p_y
            ray.pz = p_z
            x = ray.lx
            y = ray.ly
            z = ray.lz
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            l_x = x
            l_y = y
            l_z = z
            l_w = 1.
            px = (((l_x * m1._11) + ((l_y * m1._21))) + ((l_z * m1._31)))
            py = (((l_x * m1._12) + ((l_y * m1._22))) + ((l_z * m1._32)))
            pz = (((l_x * m1._13) + ((l_y * m1._23))) + ((l_z * m1._33)))
            l_x = px
            l_y = py
            l_z = pz
            ray.lx = l_x
            ray.ly = l_y
            ray.lz = l_z
            ray.normalize()
            if (m.primitive.getBounds().rayIntersection(ray,False) >= 0):
                _gthis.ctx.emitPass(m.material.passes,m)
            ray.px = savedRay_px
            ray.py = savedRay_py
            ray.pz = savedRay_pz
            ray.lx = savedRay_lx
            ray.ly = savedRay_ly
            ray.lz = savedRay_lz
        self.iterVisibleMeshes(_hx_local_0)
        self.ctx.lightSystem = None
        found = None
        passes = h3d_pass_PassList(self.ctx.passes)
        if (passes.current is not None):
            p = self.hardwarePass
            if (p is None):
                p = h3d_pass_HardwarePick()
                self.hardwarePass = p
            _this = self.ctx
            value = _hx_AnonObject({'texture': h3d_mat_Texture.fromColor(267386880,0)})
            _this.setGlobalID(hxsl_Globals.allocID("depthMap"),value)
            p.pickX = pixelX
            p.pickY = pixelY
            p.setContext(self.ctx)
            p.draw(passes)
            if (p.pickedIndex >= 0):
                _g_o = passes.current
                while (_g_o is not None):
                    tmp = _g_o
                    _g_o = _g_o.next
                    po = tmp
                    def _hx_local_2():
                        _hx_local_1 = p.pickedIndex
                        p.pickedIndex = (p.pickedIndex - 1)
                        return _hx_local_1
                    tmp1 = (_hx_local_2() == 0)
                    if tmp1:
                        found = po.obj
                        break
        self.ctx.done()
        self.ctx.camera = None
        self.ctx.engine = None
        self.ctx.scene = None
        return found

    def syncOnly(self,et):
        engine = h3d_Engine.CURRENT
        self.setElapsedTime(et)
        t = engine.getCurrentTarget()
        if (t is None):
            self.camera.screenRatio = (engine.width / engine.height)
        else:
            self.camera.screenRatio = (t.width / t.height)
        self.camera.update()
        self.ctx.camera = self.camera
        self.ctx.engine = engine
        self.ctx.scene = self
        self.ctx.start()
        self.syncRec(self.ctx)
        self.ctx.camera = None
        self.ctx.engine = None
        self.ctx.scene = None

    def computeStatic(self):
        old = self.ctx.elapsedTime
        self.ctx.elapsedTime = 0
        self.ctx.computingStatic = True
        self.render(h3d_Engine.CURRENT)
        self.ctx.computingStatic = False
        self.ctx.elapsedTime = old

    def render(self,engine):
        if (((self.flags & 32)) == 0):
            self.onAdd()
        t = engine.getCurrentTarget()
        if (t is None):
            self.camera.screenRatio = (engine.width / engine.height)
        else:
            self.camera.screenRatio = (t.width / t.height)
        self.camera.update()
        if self.camera.rightHanded:
            engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,1)
        self.ctx.camera = self.camera
        self.ctx.engine = engine
        self.ctx.scene = self
        self.ctx.start()
        self.renderer.start()
        self.syncRec(self.ctx)
        self.emitRec(self.ctx)
        _hx_list = self.ctx.passes
        tmp = None
        if (_hx_list is None):
            tmp = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p = None
            q = None
            e = None
            tail = None
            while True:
                p = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p is not None):
                    nmerges = (nmerges + 1)
                    q = p
                    psize = 0
                    _g = 0
                    _g1 = insize
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        elif (((qsize == 0) or ((q is None))) or (((p._hx_pass.passId - q._hx_pass.passId) <= 0))):
                            e = p
                            p = p.next
                            psize = (psize - 1)
                        else:
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            tmp = _hx_list
        self.ctx.passes = tmp
        curPass = self.ctx.passes
        passes = []
        passIndex = -1
        while (curPass is not None):
            passId = curPass._hx_pass.passId
            p = curPass
            prev = None
            while ((p is not None) and ((p._hx_pass.passId == passId))):
                prev = p
                p = p.next
            prev.next = None
            passIndex = (passIndex + 1)
            pobjs = passIndex
            pobjs1 = python_internal_ArrayImpl._get(self.ctx.cachedPassObjects, pobjs)
            if (pobjs1 is None):
                pobjs1 = h3d_scene_PassObjects()
                python_internal_ArrayImpl._set(self.ctx.cachedPassObjects, passIndex, pobjs1)
            pobjs1.name = curPass._hx_pass.name
            _this = pobjs1.passes
            _this.current = curPass
            def _hx_local_6():
                _this.lastDisc = None
                return _this.lastDisc
            _this.discarded = _hx_local_6()
            passes.append(pobjs1)
            curPass = p
        if (self.lightSystem is not None):
            self.ctx.lightSystem = self.lightSystem
            self.lightSystem.initLights(self.ctx)
        self.renderer.process(passes)
        if self.camera.rightHanded:
            engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,0)
        self.ctx.done()
        self.ctx.scene = None
        self.ctx.camera = None
        self.ctx.engine = None
        _g = 0
        _g1 = passIndex
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p = python_internal_ArrayImpl._get(self.ctx.cachedPassObjects, i)
            p.name = None
            _this = p.passes
            _this.current = None
            def _hx_local_7():
                _this.lastDisc = None
                return _this.lastDisc
            _this.discarded = _hx_local_7()

    def serializeScene(self):
        raise haxe_Exception.thrown("You need -lib hxbit to serialize the scene data")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.camera = None
        _hx_o.lightSystem = None
        _hx_o.renderer = None
        _hx_o.ctx = None
        _hx_o.interactives = None
        _hx_o.events = None
        _hx_o.hitInteractives = None
        _hx_o.eventListeners = None
        _hx_o.window = None
        _hx_o.hardwarePass = None
h3d_scene_Scene._hx_class = h3d_scene_Scene
_hx_classes["h3d.scene.Scene"] = h3d_scene_Scene


class h3d_scene_Joint(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Joint"
    _hx_is_interface = "False"
    __slots__ = ("skin", "index")
    _hx_fields = ["skin", "index"]
    _hx_methods = ["getObjectByName", "syncPos"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Object


    def __init__(self,skin,j):
        self.index = None
        self.skin = None
        super().__init__(None)
        self.name = j.name
        self.skin = skin
        self.parent = skin
        self.index = j.index

    def getObjectByName(self,name):
        sk = self.skin.getSkinData()
        j = sk.namedJoints.h.get(name,None)
        if (j is None):
            return None
        cur = python_internal_ArrayImpl._get(sk.allJoints, self.index)
        if (cur.index != self.index):
            raise haxe_Exception.thrown("assert")
        jp = j.parent
        while (jp is not None):
            if (jp == cur):
                jo = h3d_scene_Joint(self.skin,j)
                jo.parent = self
                return jo
            jp = jp.parent
        return None

    def syncPos(self):
        p = self.parent
        while (p is not None):
            if (((p.flags & 1)) != 0):
                if (self.skin.jointsAbsPosInv is None):
                    self.skin.jointsAbsPosInv = h3d_Matrix()
                    self.skin.jointsAbsPosInv.zero()
                if (self.skin.jointsAbsPosInv._44 == 0):
                    self.skin.jointsAbsPosInv.inverse3x4(self.parent.absPos)
                self.parent.syncPos()
                self.lastFrame = -1
                break
            p = p.parent
        if (self.lastFrame != self.skin.lastFrame):
            self.lastFrame = self.skin.lastFrame
            self.absPos.load(python_internal_ArrayImpl._get(self.skin.currentAbsPose, self.index))
            if ((self.skin.jointsAbsPosInv is not None) and ((self.skin.jointsAbsPosInv._44 != 0))):
                self.absPos.multiply3x4(self.absPos,self.skin.jointsAbsPosInv)
                self.absPos.multiply3x4(self.absPos,self.parent.absPos)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.skin = None
        _hx_o.index = None
h3d_scene_Joint._hx_class = h3d_scene_Joint
_hx_classes["h3d.scene.Joint"] = h3d_scene_Joint


class h3d_scene_Skin(h3d_scene_MultiMaterial):
    _hx_class_name = "h3d.scene.Skin"
    _hx_is_interface = "False"
    __slots__ = ("skinData", "currentRelPose", "currentAbsPose", "currentPalette", "splitPalette", "jointsUpdated", "jointsAbsPosInv", "paletteChanged", "skinShader", "jointsGraphics", "showJoints", "enableRetargeting")
    _hx_fields = ["skinData", "currentRelPose", "currentAbsPose", "currentPalette", "splitPalette", "jointsUpdated", "jointsAbsPosInv", "paletteChanged", "skinShader", "jointsGraphics", "showJoints", "enableRetargeting"]
    _hx_methods = ["clone", "getBoundsRec", "getCurrentSkeletonBounds", "getObjectByName", "getLocalCollider", "getGlobalCollider", "calcAbsPos", "getSkinData", "setSkinData", "sync", "syncJoints", "emit", "draw"]
    _hx_statics = ["TMP_MAT"]
    _hx_interfaces = []
    _hx_super = h3d_scene_MultiMaterial


    def __init__(self,s,mat = None,parent = None):
        self.showJoints = None
        self.jointsGraphics = None
        self.skinShader = None
        self.paletteChanged = None
        self.jointsAbsPosInv = None
        self.jointsUpdated = None
        self.splitPalette = None
        self.currentPalette = None
        self.currentAbsPose = None
        self.currentRelPose = None
        self.skinData = None
        self.enableRetargeting = True
        super().__init__(None,mat,parent)
        if (s is not None):
            self.setSkinData(s)

    def clone(self,o = None):
        s = (h3d_scene_Skin(None,list(self.materials)) if ((o is None)) else o)
        super().clone(s)
        s.setSkinData(self.skinData)
        s.currentRelPose = list(self.currentRelPose)
        return s

    def getBoundsRec(self,b):
        old = self.primitive
        self.set_primitive(None)
        b = super().getBoundsRec(b)
        self.set_primitive(old)
        if (((self.flags & 512)) != 0):
            return b
        self.syncJoints()
        if (self.skinData.vertexWeights is None):
            def _hx_local_1():
                _hx_local_0 = self.primitive
                if (Std.isOfType(_hx_local_0,h3d_prim_HMDModel) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            (_hx_local_1()).loadSkin(self.skinData)
        _g = 0
        _g1 = self.skinData.allJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (j.offsetRay < 0):
                continue
            m = python_internal_ArrayImpl._get(self.currentPalette, j.bindIndex)
            _this = j.offsets
            x = _this.xMin
            y = _this.yMin
            z = _this.zMin
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            pt_x = x
            pt_y = y
            pt_z = z
            px = ((((pt_x * m._11) + ((pt_y * m._21))) + ((pt_z * m._31))) + m._41)
            py = ((((pt_x * m._12) + ((pt_y * m._22))) + ((pt_z * m._32))) + m._42)
            pz = ((((pt_x * m._13) + ((pt_y * m._23))) + ((pt_z * m._33))) + m._43)
            pt_x = px
            pt_y = py
            pt_z = pz
            x1 = pt_x
            y1 = pt_y
            z1 = pt_z
            r = j.offsetRay
            if ((x1 - r) < b.xMin):
                b.xMin = (x1 - r)
            if ((x1 + r) > b.xMax):
                b.xMax = (x1 + r)
            if ((y1 - r) < b.yMin):
                b.yMin = (y1 - r)
            if ((y1 + r) > b.yMax):
                b.yMax = (y1 + r)
            if ((z1 - r) < b.zMin):
                b.zMin = (z1 - r)
            if ((z1 + r) > b.zMax):
                b.zMax = (z1 + r)
            _this1 = j.offsets
            x2 = _this1.xMax
            y2 = _this1.yMax
            z2 = _this1.zMax
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            pt_x1 = x2
            pt_y1 = y2
            pt_z1 = z2
            px1 = ((((pt_x1 * m._11) + ((pt_y1 * m._21))) + ((pt_z1 * m._31))) + m._41)
            py1 = ((((pt_x1 * m._12) + ((pt_y1 * m._22))) + ((pt_z1 * m._32))) + m._42)
            pz1 = ((((pt_x1 * m._13) + ((pt_y1 * m._23))) + ((pt_z1 * m._33))) + m._43)
            pt_x1 = px1
            pt_y1 = py1
            pt_z1 = pz1
            x3 = pt_x1
            y3 = pt_y1
            z3 = pt_z1
            r1 = j.offsetRay
            if ((x3 - r1) < b.xMin):
                b.xMin = (x3 - r1)
            if ((x3 + r1) > b.xMax):
                b.xMax = (x3 + r1)
            if ((y3 - r1) < b.yMin):
                b.yMin = (y3 - r1)
            if ((y3 + r1) > b.yMax):
                b.yMax = (y3 + r1)
            if ((z3 - r1) < b.zMin):
                b.zMin = (z3 - r1)
            if ((z3 + r1) > b.zMax):
                b.zMax = (z3 + r1)
        return b

    def getCurrentSkeletonBounds(self):
        self.syncJoints()
        b = h3d_col_Bounds()
        _g = 0
        _g1 = self.skinData.allJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (j.bindIndex < 0):
                continue
            r = python_internal_ArrayImpl._get(self.currentAbsPose, j.index)
            x = r._41
            y = r._42
            z = r._43
            if (x < b.xMin):
                b.xMin = x
            if (x > b.xMax):
                b.xMax = x
            if (y < b.yMin):
                b.yMin = y
            if (y > b.yMax):
                b.yMax = y
            if (z < b.zMin):
                b.zMin = z
            if (z > b.zMax):
                b.zMax = z
        return b

    def getObjectByName(self,name):
        if ((self.skinData is not None) and ((self.skinData.name == name))):
            return self
        o = super().getObjectByName(name)
        if (o is not None):
            return o
        if (self.skinData is not None):
            j = self.skinData.namedJoints.h.get(name,None)
            if (j is not None):
                return h3d_scene_Joint(self,j)
        return None

    def getLocalCollider(self):
        raise haxe_Exception.thrown("Not implemented")

    def getGlobalCollider(self):
        def _hx_local_1():
            _hx_local_0 = self.primitive.getCollider()
            if (Std.isOfType(_hx_local_0,h3d_col_OptimizedCollider) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise "Class cast error"
            return _hx_local_0
        col = _hx_local_1()
        def _hx_local_3():
            _hx_local_2 = self.primitive
            if (Std.isOfType(_hx_local_2,h3d_prim_HMDModel) or ((_hx_local_2 is None))):
                _hx_local_2
            else:
                raise "Class cast error"
            return _hx_local_2
        (_hx_local_3()).loadSkin(self.skinData)
        def _hx_local_6():
            def _hx_local_5():
                _hx_local_4 = col.b
                if (Std.isOfType(_hx_local_4,h3d_col_PolygonBuffer) or ((_hx_local_4 is None))):
                    _hx_local_4
                else:
                    raise "Class cast error"
                return _hx_local_4
            return h3d_col_SkinCollider(self,_hx_local_5())
        return _hx_local_6()

    def calcAbsPos(self):
        super().calcAbsPos()
        self.jointsUpdated = True

    def getSkinData(self):
        return self.skinData

    def setSkinData(self,s,shaderInit = None):
        if (shaderInit is None):
            shaderInit = True
        self.skinData = s
        self.jointsUpdated = True
        self.set_primitive(s.primitive)
        if shaderInit:
            hasNormalMap = False
            _g = 0
            _g1 = self.materials
            while (_g < len(_g1)):
                m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if ((m is not None) and ((m.get_normalMap() is not None))):
                    hasNormalMap = True
                    break
            self.skinShader = (h3d_shader_SkinTangent() if hasNormalMap else h3d_shader_Skin())
            maxBones = 0
            if (self.skinData.splitJoints is not None):
                _g = 0
                _g1 = self.skinData.splitJoints
                while (_g < len(_g1)):
                    s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    if (len(s.joints) > maxBones):
                        maxBones = len(s.joints)
            else:
                maxBones = len(self.skinData.boundJoints)
            if (self.skinShader.MaxBones__ < maxBones):
                _this = self.skinShader
                _this.constModified = True
                _this.MaxBones__ = maxBones
            _g = 0
            _g1 = self.materials
            while (_g < len(_g1)):
                m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (m is not None):
                    if (m.get_normalMap() is not None):
                        m.passes.addShaderAtIndex(self.skinShader,(m.passes.getShaderIndex(m.normalShader) + 1))
                    else:
                        m.passes.addShader(self.skinShader)
                    if (self.skinData.splitJoints is not None):
                        m.passes.set_dynamicParameters(True)
        self.currentRelPose = []
        self.currentAbsPose = []
        self.currentPalette = []
        self.paletteChanged = True
        _g = 0
        _g1 = self.skinData.allJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _this = self.currentAbsPose
            x = h3d_Matrix.I()
            _this.append(x)
        _g = 0
        _g1 = len(self.skinData.boundJoints)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this = self.currentPalette
            x = h3d_Matrix.I()
            _this.append(x)
        if (self.skinData.splitJoints is not None):
            self.splitPalette = []
            _g = 0
            _g1 = self.skinData.splitJoints
            while (_g < len(_g1)):
                a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _this = self.splitPalette
                _g2 = []
                _g3 = 0
                _g4 = a.joints
                while (_g3 < len(_g4)):
                    j = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                    _g3 = (_g3 + 1)
                    x = python_internal_ArrayImpl._get(self.currentPalette, j.bindIndex)
                    _g2.append(x)
                _this.append(_g2)
        else:
            self.splitPalette = None

    def sync(self,ctx):
        if ((not ctx.visibleFlag) and ((((self.flags & 64)) == 0))):
            return
        self.syncJoints()

    def syncJoints(self):
        if (not self.jointsUpdated):
            return
        tmpMat = h3d_scene_Skin.TMP_MAT
        _g = 0
        _g1 = self.skinData.allJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            id = j.index
            m = (self.currentAbsPose[id] if id >= 0 and id < len(self.currentAbsPose) else None)
            r = (self.currentRelPose[id] if id >= 0 and id < len(self.currentRelPose) else None)
            bid = j.bindIndex
            if (r is None):
                r = j.defMat
            elif (j.retargetAnim and self.enableRetargeting):
                tmpMat.load(r)
                r = tmpMat
                r._41 = j.defMat._41
                r._42 = j.defMat._42
                r._43 = j.defMat._43
            if (j.parent is None):
                b = self.absPos
                m11 = r._11
                m12 = r._12
                m13 = r._13
                m21 = r._21
                m22 = r._22
                m23 = r._23
                a31 = r._31
                a32 = r._32
                a33 = r._33
                a41 = r._41
                a42 = r._42
                a43 = r._43
                b11 = b._11
                b12 = b._12
                b13 = b._13
                b21 = b._21
                b22 = b._22
                b23 = b._23
                b31 = b._31
                b32 = b._32
                b33 = b._33
                b41 = b._41
                b42 = b._42
                b43 = b._43
                m._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
                m._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
                m._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
                m._14 = 0
                m._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
                m._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
                m._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
                m._24 = 0
                m._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
                m._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
                m._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
                m._34 = 0
                m._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
                m._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
                m._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
                m._44 = 1
            else:
                b1 = python_internal_ArrayImpl._get(self.currentAbsPose, j.parent.index)
                m111 = r._11
                m121 = r._12
                m131 = r._13
                m211 = r._21
                m221 = r._22
                m231 = r._23
                a311 = r._31
                a321 = r._32
                a331 = r._33
                a411 = r._41
                a421 = r._42
                a431 = r._43
                b111 = b1._11
                b121 = b1._12
                b131 = b1._13
                b211 = b1._21
                b221 = b1._22
                b231 = b1._23
                b311 = b1._31
                b321 = b1._32
                b331 = b1._33
                b411 = b1._41
                b421 = b1._42
                b431 = b1._43
                m._11 = (((m111 * b111) + ((m121 * b211))) + ((m131 * b311)))
                m._12 = (((m111 * b121) + ((m121 * b221))) + ((m131 * b321)))
                m._13 = (((m111 * b131) + ((m121 * b231))) + ((m131 * b331)))
                m._14 = 0
                m._21 = (((m211 * b111) + ((m221 * b211))) + ((m231 * b311)))
                m._22 = (((m211 * b121) + ((m221 * b221))) + ((m231 * b321)))
                m._23 = (((m211 * b131) + ((m221 * b231))) + ((m231 * b331)))
                m._24 = 0
                m._31 = (((a311 * b111) + ((a321 * b211))) + ((a331 * b311)))
                m._32 = (((a311 * b121) + ((a321 * b221))) + ((a331 * b321)))
                m._33 = (((a311 * b131) + ((a321 * b231))) + ((a331 * b331)))
                m._34 = 0
                m._41 = ((((a411 * b111) + ((a421 * b211))) + ((a431 * b311))) + b411)
                m._42 = ((((a411 * b121) + ((a421 * b221))) + ((a431 * b321))) + b421)
                m._43 = ((((a411 * b131) + ((a421 * b231))) + ((a431 * b331))) + b431)
                m._44 = 1
            if (bid >= 0):
                _this = (self.currentPalette[bid] if bid >= 0 and bid < len(self.currentPalette) else None)
                a = j.transPos
                m112 = a._11
                m122 = a._12
                m132 = a._13
                m212 = a._21
                m222 = a._22
                m232 = a._23
                a312 = a._31
                a322 = a._32
                a332 = a._33
                a412 = a._41
                a422 = a._42
                a432 = a._43
                b112 = m._11
                b122 = m._12
                b132 = m._13
                b212 = m._21
                b222 = m._22
                b232 = m._23
                b312 = m._31
                b322 = m._32
                b332 = m._33
                b412 = m._41
                b422 = m._42
                b432 = m._43
                _this._11 = (((m112 * b112) + ((m122 * b212))) + ((m132 * b312)))
                _this._12 = (((m112 * b122) + ((m122 * b222))) + ((m132 * b322)))
                _this._13 = (((m112 * b132) + ((m122 * b232))) + ((m132 * b332)))
                _this._14 = 0
                _this._21 = (((m212 * b112) + ((m222 * b212))) + ((m232 * b312)))
                _this._22 = (((m212 * b122) + ((m222 * b222))) + ((m232 * b322)))
                _this._23 = (((m212 * b132) + ((m222 * b232))) + ((m232 * b332)))
                _this._24 = 0
                _this._31 = (((a312 * b112) + ((a322 * b212))) + ((a332 * b312)))
                _this._32 = (((a312 * b122) + ((a322 * b222))) + ((a332 * b322)))
                _this._33 = (((a312 * b132) + ((a322 * b232))) + ((a332 * b332)))
                _this._34 = 0
                _this._41 = ((((a412 * b112) + ((a422 * b212))) + ((a432 * b312))) + b412)
                _this._42 = ((((a412 * b122) + ((a422 * b222))) + ((a432 * b322))) + b422)
                _this._43 = ((((a412 * b132) + ((a422 * b232))) + ((a432 * b332))) + b432)
                _this._44 = 1
        self.skinShader.bonesMatrixes__ = self.currentPalette
        if (self.jointsAbsPosInv is not None):
            self.jointsAbsPosInv._44 = 0
        self.jointsUpdated = False

    def emit(self,ctx):
        if (self.splitPalette is None):
            super().emit(ctx)
        else:
            _g = 0
            _g1 = len(self.splitPalette)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                m = python_internal_ArrayImpl._get(self.materials, python_internal_ArrayImpl._get(self.skinData.splitJoints, i).material)
                if (m is not None):
                    index = i
                    if (index is None):
                        index = 0
                    p = m.passes
                    while (p is not None):
                        ctx.emitPass(p,self).index = index
                        p = p.nextPass
        if self.showJoints:
            if (self.jointsGraphics is None):
                self.jointsGraphics = h3d_scene_Graphics(self)
                self.jointsGraphics.material.passes.depth(False,h3d_mat_Compare.Always)
                self.jointsGraphics.material.passes.setPassName("add")
            topParent = self
            while (topParent.parent is not None):
                topParent = topParent.parent
            self.jointsGraphics.set_follow(topParent)
            g = self.jointsGraphics
            g.clear()
            _g = 0
            _g1 = self.skinData.allJoints
            while (_g < len(_g1)):
                j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                m = python_internal_ArrayImpl._get(self.currentAbsPose, j.index)
                mp = (self.absPos if ((j.parent is None)) else python_internal_ArrayImpl._get(self.currentAbsPose, j.parent.index))
                g.lineStyle(1,(-16776961 if ((j.parent is None)) else -256))
                g.moveTo(mp._41,mp._42,mp._43)
                g.lineTo(m._41,m._42,m._43)
        elif (self.jointsGraphics is not None):
            _this = self.jointsGraphics
            if ((_this is not None) and ((_this.parent is not None))):
                _this.parent.removeChild(_this)
            self.jointsGraphics = None

    def draw(self,ctx):
        if (self.splitPalette is None):
            super().draw(ctx)
        else:
            i = ctx.drawPass.index
            self.skinShader.bonesMatrixes__ = (self.splitPalette[i] if i >= 0 and i < len(self.splitPalette) else None)
            self.primitive.selectMaterial(i)
            ctx.uploadParams()
            self.primitive.render(ctx.engine)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.skinData = None
        _hx_o.currentRelPose = None
        _hx_o.currentAbsPose = None
        _hx_o.currentPalette = None
        _hx_o.splitPalette = None
        _hx_o.jointsUpdated = None
        _hx_o.jointsAbsPosInv = None
        _hx_o.paletteChanged = None
        _hx_o.skinShader = None
        _hx_o.jointsGraphics = None
        _hx_o.showJoints = None
        _hx_o.enableRetargeting = None
h3d_scene_Skin._hx_class = h3d_scene_Skin
_hx_classes["h3d.scene.Skin"] = h3d_scene_Skin


class h3d_scene_fwd_LightSystem(h3d_scene_LightSystem):
    _hx_class_name = "h3d.scene.fwd.LightSystem"
    _hx_is_interface = "False"
    __slots__ = ("maxLightsPerObject", "globals", "ambientShader", "perPixelLighting")
    _hx_fields = ["maxLightsPerObject", "globals", "ambientShader", "perPixelLighting"]
    _hx_methods = ["get_additiveLighting", "set_additiveLighting", "initLights", "initGlobals", "sortLight", "computeLight"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_LightSystem


    def __init__(self):
        self.ambientShader = None
        self.globals = None
        self.perPixelLighting = True
        self.maxLightsPerObject = 6
        super().__init__()
        _this = self.ambientLight
        x = 0.5
        y = 0.5
        z = 0.5
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        self.ambientShader = h3d_shader_AmbientLight()
        self.set_additiveLighting(True)

    def get_additiveLighting(self):
        return Std.downcast(self.ambientShader,h3d_shader_AmbientLight).additive__

    def set_additiveLighting(self,b):
        _this = Std.downcast(self.ambientShader,h3d_shader_AmbientLight)
        _this.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                _this.additive__ = b
                return _this.additive__
            return _hx_local_0()
        return _hx_local_1()

    def initLights(self,ctx):
        super().initLights(ctx)
        if (self.lightCount <= self.maxLightsPerObject):
            _hx_list = ctx.lights
            cmp = self.sortLight
            tmp = None
            if (_hx_list is None):
                tmp = None
            else:
                insize = 1
                nmerges = None
                psize = 0
                qsize = 0
                p = None
                q = None
                e = None
                tail = None
                while True:
                    p = _hx_list
                    _hx_list = None
                    tail = None
                    nmerges = 0
                    while (p is not None):
                        nmerges = (nmerges + 1)
                        q = p
                        psize = 0
                        _g = 0
                        _g1 = insize
                        while (_g < _g1):
                            i = _g
                            _g = (_g + 1)
                            psize = (psize + 1)
                            q = q.next
                            if (q is None):
                                break
                        qsize = insize
                        while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                            if (psize == 0):
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            elif (((qsize == 0) or ((q is None))) or ((cmp(p,q) <= 0))):
                                e = p
                                p = p.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            if (tail is not None):
                                tail.next = e
                            else:
                                _hx_list = e
                            tail = e
                        p = q
                    tail.next = None
                    if (nmerges <= 1):
                        break
                    insize = (insize * 2)
                tmp = _hx_list
            ctx.lights = tmp

    def initGlobals(self,globals):
        globals.set("global.ambientLight",self.ambientLight)
        globals.set("global.perPixelLighting",self.perPixelLighting)

    def sortLight(self,l1,l2):
        p = (l1.priority - l2.priority)
        if (p != 0):
            return -p
        if (l1.objectDistance < l2.objectDistance):
            return -1
        else:
            return 1

    def computeLight(self,obj,shaders):
        _gthis = self
        if (self.lightCount > self.maxLightsPerObject):
            l = self.ctx.lights
            while (l is not None):
                if (((obj.flags & 16)) != 0):
                    dx = (l.absPos._41 - self.ctx.camera.target.x)
                    dy = (l.absPos._42 - self.ctx.camera.target.y)
                    dz = (l.absPos._43 - self.ctx.camera.target.z)
                    if (dz is None):
                        dz = 0.
                    l.objectDistance = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
                else:
                    dx1 = (l.absPos._41 - obj.absPos._41)
                    dy1 = (l.absPos._42 - obj.absPos._42)
                    dz1 = (l.absPos._43 - obj.absPos._43)
                    if (dz1 is None):
                        dz1 = 0.
                    l.objectDistance = (((dx1 * dx1) + ((dy1 * dy1))) + ((dz1 * dz1)))
                l = l.next
            _hx_list = self.ctx.lights
            cmp = self.sortLight
            tmp = None
            if (_hx_list is None):
                tmp = None
            else:
                insize = 1
                nmerges = None
                psize = 0
                qsize = 0
                p = None
                q = None
                e = None
                tail = None
                while True:
                    p = _hx_list
                    _hx_list = None
                    tail = None
                    nmerges = 0
                    while (p is not None):
                        nmerges = (nmerges + 1)
                        q = p
                        psize = 0
                        _g = 0
                        _g1 = insize
                        while (_g < _g1):
                            i = _g
                            _g = (_g + 1)
                            psize = (psize + 1)
                            q = q.next
                            if (q is None):
                                break
                        qsize = insize
                        while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                            if (psize == 0):
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            elif (((qsize == 0) or ((q is None))) or ((cmp(p,q) <= 0))):
                                e = p
                                p = p.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            if (tail is not None):
                                tail.next = e
                            else:
                                _hx_list = e
                            tail = e
                        p = q
                    tail.next = None
                    if (nmerges <= 1):
                        break
                    insize = (insize * 2)
                tmp = _hx_list
            self.ctx.lights = tmp
        shaders = _gthis.ctx.allocShaderList(self.ambientShader,shaders)
        l = self.ctx.lights
        i = 0
        while (l is not None):
            tmp = i
            i = (i + 1)
            if (tmp == self.maxLightsPerObject):
                break
            shaders = _gthis.ctx.allocShaderList(l.shader,shaders)
            l = l.next
        return shaders

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.maxLightsPerObject = None
        _hx_o.globals = None
        _hx_o.ambientShader = None
        _hx_o.perPixelLighting = None
h3d_scene_fwd_LightSystem._hx_class = h3d_scene_fwd_LightSystem
_hx_classes["h3d.scene.fwd.LightSystem"] = h3d_scene_fwd_LightSystem


class h3d_scene_fwd_DepthPass(h3d_pass_Default):
    _hx_class_name = "h3d.scene.fwd.DepthPass"
    _hx_is_interface = "False"
    __slots__ = ("depthMapId", "enableSky")
    _hx_fields = ["depthMapId", "enableSky"]
    _hx_methods = ["getOutputs", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Default


    def __init__(self):
        self.depthMapId = None
        self.enableSky = False
        super().__init__("depth")
        self.depthMapId = hxsl_Globals.allocID("depthMap")

    def getOutputs(self):
        return [hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))]

    def draw(self,passes,sort = None):
        texture = self.ctx.textures.allocTarget("depthMap",self.ctx.engine.width,self.ctx.engine.height,True)
        self.ctx.engine.pushTarget(texture)
        self.ctx.engine.clear((0 if (self.enableSky) else 16711680),1)
        super().draw(passes,sort)
        self.ctx.engine.popTarget()
        self.ctx.setGlobalID(self.depthMapId,_hx_AnonObject({'texture': texture}))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.depthMapId = None
        _hx_o.enableSky = None
h3d_scene_fwd_DepthPass._hx_class = h3d_scene_fwd_DepthPass
_hx_classes["h3d.scene.fwd.DepthPass"] = h3d_scene_fwd_DepthPass


class h3d_scene_fwd_NormalPass(h3d_pass_Default):
    _hx_class_name = "h3d.scene.fwd.NormalPass"
    _hx_is_interface = "False"
    __slots__ = ("normalMapId",)
    _hx_fields = ["normalMapId"]
    _hx_methods = ["getOutputs", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Default


    def __init__(self):
        self.normalMapId = None
        super().__init__("normal")
        self.normalMapId = hxsl_Globals.allocID("normalMap")

    def getOutputs(self):
        return [hxsl_Output.PackNormal(hxsl_Output.Value("output.normal"))]

    def draw(self,passes,sort = None):
        texture = self.ctx.textures.allocTarget("normalMap",self.ctx.engine.width,self.ctx.engine.height)
        self.ctx.engine.pushTarget(texture)
        self.ctx.engine.clear(8421504,1)
        super().draw(passes,sort)
        self.ctx.engine.popTarget()
        self.ctx.setGlobalID(self.normalMapId,texture)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.normalMapId = None
h3d_scene_fwd_NormalPass._hx_class = h3d_scene_fwd_NormalPass
_hx_classes["h3d.scene.fwd.NormalPass"] = h3d_scene_fwd_NormalPass


class h3d_scene_fwd_Renderer(h3d_scene_Renderer):
    _hx_class_name = "h3d.scene.fwd.Renderer"
    _hx_is_interface = "False"
    __slots__ = ("depth", "normal", "shadow")
    _hx_fields = ["depth", "normal", "shadow"]
    _hx_methods = ["get_def", "renderPass", "getPassByName", "render"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Renderer


    def __init__(self):
        self.shadow = h3d_pass_DefaultShadowMap(1024)
        self.normal = h3d_scene_fwd_NormalPass()
        self.depth = h3d_scene_fwd_DepthPass()
        super().__init__()
        self.defaultPass = h3d_pass_Default("default")
        self.allPasses = [self.defaultPass, self.depth, self.normal, self.shadow]

    def get_def(self):
        return self.defaultPass

    def renderPass(self,p,passes,sort = None):
        p.draw(passes,sort)

    def getPassByName(self,name):
        if ((name == "alpha") or ((name == "additive"))):
            return self.defaultPass
        return super().getPassByName(name)

    def render(self):
        if self.has("shadow"):
            self.renderPass(self.shadow,self.get("shadow"))
        if self.has("depth"):
            self.renderPass(self.depth,self.get("depth"))
        if self.has("normal"):
            self.renderPass(self.normal,self.get("normal"))
        self.renderPass(self.defaultPass,self.get("default"))
        self.renderPass(self.defaultPass,self.get("alpha"),self.backToFront)
        self.renderPass(self.defaultPass,self.get("additive"))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.depth = None
        _hx_o.normal = None
        _hx_o.shadow = None
h3d_scene_fwd_Renderer._hx_class = h3d_scene_fwd_Renderer
_hx_classes["h3d.scene.fwd.Renderer"] = h3d_scene_fwd_Renderer


class h3d_shader_AmbientLight(hxsl_Shader):
    _hx_class_name = "h3d.shader.AmbientLight"
    _hx_is_interface = "False"
    __slots__ = ("additive__",)
    _hx_fields = ["additive__"]
    _hx_methods = ["get_additive", "set_additive", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.additive__ = None
        super().__init__()

    def get_additive(self):
        return self.additive__

    def set_additive(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.additive__ = _v
                return self.additive__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.additive__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 2)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.additive__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_AmbientLight)
        s.shader = self.shader
        s.additive__ = self.additive__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.additive__ = None
h3d_shader_AmbientLight._hx_class = h3d_shader_AmbientLight
_hx_classes["h3d.shader.AmbientLight"] = h3d_shader_AmbientLight


class h3d_shader_Base2d(hxsl_Shader):
    _hx_class_name = "h3d.shader.Base2d"
    _hx_is_interface = "False"
    __slots__ = ("zValue__", "texture__", "isRelative__", "color__", "absoluteMatrixA__", "absoluteMatrixB__", "filterMatrixA__", "filterMatrixB__", "hasUVPos__", "uvPos__", "killAlpha__", "pixelAlign__", "halfPixelInverse__", "viewportA__", "viewportB__")
    _hx_fields = ["zValue__", "texture__", "isRelative__", "color__", "absoluteMatrixA__", "absoluteMatrixB__", "filterMatrixA__", "filterMatrixB__", "hasUVPos__", "uvPos__", "killAlpha__", "pixelAlign__", "halfPixelInverse__", "viewportA__", "viewportB__"]
    _hx_methods = ["get_zValue", "set_zValue", "get_texture", "set_texture", "get_isRelative", "set_isRelative", "get_color", "set_color", "get_absoluteMatrixA", "set_absoluteMatrixA", "get_absoluteMatrixB", "set_absoluteMatrixB", "get_filterMatrixA", "set_filterMatrixA", "get_filterMatrixB", "set_filterMatrixB", "get_hasUVPos", "set_hasUVPos", "get_uvPos", "set_uvPos", "get_killAlpha", "set_killAlpha", "get_pixelAlign", "set_pixelAlign", "get_halfPixelInverse", "set_halfPixelInverse", "get_viewportA", "set_viewportA", "get_viewportB", "set_viewportB", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.pixelAlign__ = None
        self.killAlpha__ = None
        self.hasUVPos__ = None
        self.isRelative__ = None
        self.texture__ = None
        self.viewportB__ = h3d_Vector()
        self.viewportA__ = h3d_Vector()
        self.halfPixelInverse__ = h3d_Vector()
        self.uvPos__ = h3d_Vector()
        self.filterMatrixB__ = h3d_Vector()
        self.filterMatrixA__ = h3d_Vector()
        self.absoluteMatrixB__ = h3d_Vector()
        self.absoluteMatrixA__ = h3d_Vector()
        self.color__ = h3d_Vector()
        self.zValue__ = 0
        super().__init__()

    def get_zValue(self):
        return self.zValue__

    def set_zValue(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.zValue__ = _v
                return self.zValue__
            return _hx_local_0()
        return _hx_local_1()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def get_isRelative(self):
        return self.isRelative__

    def set_isRelative(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isRelative__ = _v
                return self.isRelative__
            return _hx_local_0()
        return _hx_local_1()

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def get_absoluteMatrixA(self):
        return self.absoluteMatrixA__

    def set_absoluteMatrixA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.absoluteMatrixA__ = _v
                return self.absoluteMatrixA__
            return _hx_local_0()
        return _hx_local_1()

    def get_absoluteMatrixB(self):
        return self.absoluteMatrixB__

    def set_absoluteMatrixB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.absoluteMatrixB__ = _v
                return self.absoluteMatrixB__
            return _hx_local_0()
        return _hx_local_1()

    def get_filterMatrixA(self):
        return self.filterMatrixA__

    def set_filterMatrixA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.filterMatrixA__ = _v
                return self.filterMatrixA__
            return _hx_local_0()
        return _hx_local_1()

    def get_filterMatrixB(self):
        return self.filterMatrixB__

    def set_filterMatrixB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.filterMatrixB__ = _v
                return self.filterMatrixB__
            return _hx_local_0()
        return _hx_local_1()

    def get_hasUVPos(self):
        return self.hasUVPos__

    def set_hasUVPos(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.hasUVPos__ = _v
                return self.hasUVPos__
            return _hx_local_0()
        return _hx_local_1()

    def get_uvPos(self):
        return self.uvPos__

    def set_uvPos(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.uvPos__ = _v
                return self.uvPos__
            return _hx_local_0()
        return _hx_local_1()

    def get_killAlpha(self):
        return self.killAlpha__

    def set_killAlpha(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.killAlpha__ = _v
                return self.killAlpha__
            return _hx_local_0()
        return _hx_local_1()

    def get_pixelAlign(self):
        return self.pixelAlign__

    def set_pixelAlign(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.pixelAlign__ = _v
                return self.pixelAlign__
            return _hx_local_0()
        return _hx_local_1()

    def get_halfPixelInverse(self):
        return self.halfPixelInverse__

    def set_halfPixelInverse(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.halfPixelInverse__ = _v
                return self.halfPixelInverse__
            return _hx_local_0()
        return _hx_local_1()

    def get_viewportA(self):
        return self.viewportA__

    def set_viewportA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.viewportA__ = _v
                return self.viewportA__
            return _hx_local_0()
        return _hx_local_1()

    def get_viewportB(self):
        return self.viewportB__

    def set_viewportB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.viewportB__ = _v
                return self.viewportB__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.isRelative__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        if self.hasUVPos__:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.constBits
            _hx_local_2.constBits = (_hx_local_3 | 2)
            _hx_local_2.constBits
        if self.killAlpha__:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.constBits
            _hx_local_4.constBits = (_hx_local_5 | 4)
            _hx_local_4.constBits
        if self.pixelAlign__:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.constBits
            _hx_local_6.constBits = (_hx_local_7 | 8)
            _hx_local_6.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.zValue__
        elif (index1 == 1):
            return self.texture__
        elif (index1 == 2):
            return self.isRelative__
        elif (index1 == 3):
            return self.color__
        elif (index1 == 4):
            return self.absoluteMatrixA__
        elif (index1 == 5):
            return self.absoluteMatrixB__
        elif (index1 == 6):
            return self.filterMatrixA__
        elif (index1 == 7):
            return self.filterMatrixB__
        elif (index1 == 8):
            return self.hasUVPos__
        elif (index1 == 9):
            return self.uvPos__
        elif (index1 == 10):
            return self.killAlpha__
        elif (index1 == 11):
            return self.pixelAlign__
        elif (index1 == 12):
            return self.halfPixelInverse__
        elif (index1 == 13):
            return self.viewportA__
        elif (index1 == 14):
            return self.viewportB__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.zValue__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_Base2d)
        s.shader = self.shader
        s.zValue__ = self.zValue__
        s.texture__ = self.texture__
        s.isRelative__ = self.isRelative__
        s.color__ = self.color__
        s.absoluteMatrixA__ = self.absoluteMatrixA__
        s.absoluteMatrixB__ = self.absoluteMatrixB__
        s.filterMatrixA__ = self.filterMatrixA__
        s.filterMatrixB__ = self.filterMatrixB__
        s.hasUVPos__ = self.hasUVPos__
        s.uvPos__ = self.uvPos__
        s.killAlpha__ = self.killAlpha__
        s.pixelAlign__ = self.pixelAlign__
        s.halfPixelInverse__ = self.halfPixelInverse__
        s.viewportA__ = self.viewportA__
        s.viewportB__ = self.viewportB__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.zValue__ = None
        _hx_o.texture__ = None
        _hx_o.isRelative__ = None
        _hx_o.color__ = None
        _hx_o.absoluteMatrixA__ = None
        _hx_o.absoluteMatrixB__ = None
        _hx_o.filterMatrixA__ = None
        _hx_o.filterMatrixB__ = None
        _hx_o.hasUVPos__ = None
        _hx_o.uvPos__ = None
        _hx_o.killAlpha__ = None
        _hx_o.pixelAlign__ = None
        _hx_o.halfPixelInverse__ = None
        _hx_o.viewportA__ = None
        _hx_o.viewportB__ = None
h3d_shader_Base2d._hx_class = h3d_shader_Base2d
_hx_classes["h3d.shader.Base2d"] = h3d_shader_Base2d


class h3d_shader_BaseMesh(hxsl_Shader):
    _hx_class_name = "h3d.shader.BaseMesh"
    _hx_is_interface = "False"
    __slots__ = ("color__", "specularPower__", "specularAmount__", "specularColor__")
    _hx_fields = ["color__", "specularPower__", "specularAmount__", "specularColor__"]
    _hx_methods = ["get_color", "set_color", "get_specularPower", "set_specularPower", "get_specularAmount", "set_specularAmount", "get_specularColor", "set_specularColor", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.specularColor__ = h3d_Vector()
        self.specularAmount__ = 0
        self.specularPower__ = 0
        self.color__ = h3d_Vector()
        super().__init__()
        _this = self.color__
        x = 1
        y = 1
        z = 1
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.specularColor__
        x = 1
        y = 1
        z = 1
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        self.specularPower__ = 50
        self.specularAmount__ = 1

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularPower(self):
        return self.specularPower__

    def set_specularPower(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.specularPower__ = _v
                return self.specularPower__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularAmount(self):
        return self.specularAmount__

    def set_specularAmount(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.specularAmount__ = _v
                return self.specularAmount__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularColor(self):
        return self.specularColor__

    def set_specularColor(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.specularColor__ = _v
                return self.specularColor__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.color__
        elif (index1 == 1):
            return self.specularPower__
        elif (index1 == 2):
            return self.specularAmount__
        elif (index1 == 3):
            return self.specularColor__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        index1 = index
        if (index1 == 1):
            return self.specularPower__
        elif (index1 == 2):
            return self.specularAmount__
        else:
            pass
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_BaseMesh)
        s.shader = self.shader
        s.color__ = self.color__
        s.specularPower__ = self.specularPower__
        s.specularAmount__ = self.specularAmount__
        s.specularColor__ = self.specularColor__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color__ = None
        _hx_o.specularPower__ = None
        _hx_o.specularAmount__ = None
        _hx_o.specularColor__ = None
h3d_shader_BaseMesh._hx_class = h3d_shader_BaseMesh
_hx_classes["h3d.shader.BaseMesh"] = h3d_shader_BaseMesh


class h3d_shader_Blur(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.shader.Blur"
    _hx_is_interface = "False"
    __slots__ = ("cameraInverseViewProj__", "texture__", "depthTexture__", "Quality__", "isDepth__", "values__", "offsets__", "pixel__", "hasFixedColor__", "smoothFixedColor__", "fixedColor__", "isDepthDependant__", "hasNormal__", "normalTexture__", "isCube__", "cubeTexture__", "cubeDir__")
    _hx_fields = ["cameraInverseViewProj__", "texture__", "depthTexture__", "Quality__", "isDepth__", "values__", "offsets__", "pixel__", "hasFixedColor__", "smoothFixedColor__", "fixedColor__", "isDepthDependant__", "hasNormal__", "normalTexture__", "isCube__", "cubeTexture__", "cubeDir__"]
    _hx_methods = ["get_cameraInverseViewProj", "set_cameraInverseViewProj", "get_texture", "set_texture", "get_depthTexture", "set_depthTexture", "get_Quality", "set_Quality", "get_isDepth", "set_isDepth", "get_values", "set_values", "get_offsets", "set_offsets", "get_pixel", "set_pixel", "get_hasFixedColor", "set_hasFixedColor", "get_smoothFixedColor", "set_smoothFixedColor", "get_fixedColor", "set_fixedColor", "get_isDepthDependant", "set_isDepthDependant", "get_hasNormal", "set_hasNormal", "get_normalTexture", "set_normalTexture", "get_isCube", "set_isCube", "get_cubeTexture", "set_cubeTexture", "get_cubeDir", "set_cubeDir", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.cubeTexture__ = None
        self.isCube__ = None
        self.normalTexture__ = None
        self.hasNormal__ = None
        self.isDepthDependant__ = None
        self.smoothFixedColor__ = None
        self.hasFixedColor__ = None
        self.isDepth__ = None
        self.depthTexture__ = None
        self.texture__ = None
        self.cubeDir__ = h3d_Matrix()
        self.fixedColor__ = h3d_Vector()
        self.pixel__ = h3d_Vector()
        self.offsets__ = list()
        self.values__ = list()
        self.Quality__ = 0
        self.cameraInverseViewProj__ = h3d_Matrix()
        super().__init__()

    def get_cameraInverseViewProj(self):
        return self.cameraInverseViewProj__

    def set_cameraInverseViewProj(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.cameraInverseViewProj__ = _v
                return self.cameraInverseViewProj__
            return _hx_local_0()
        return _hx_local_1()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def get_depthTexture(self):
        return self.depthTexture__

    def set_depthTexture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.depthTexture__ = _v
                return self.depthTexture__
            return _hx_local_0()
        return _hx_local_1()

    def get_Quality(self):
        return self.Quality__

    def set_Quality(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.Quality__ = _v
                return self.Quality__
            return _hx_local_0()
        return _hx_local_1()

    def get_isDepth(self):
        return self.isDepth__

    def set_isDepth(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isDepth__ = _v
                return self.isDepth__
            return _hx_local_0()
        return _hx_local_1()

    def get_values(self):
        return self.values__

    def set_values(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.values__ = _v
                return self.values__
            return _hx_local_0()
        return _hx_local_1()

    def get_offsets(self):
        return self.offsets__

    def set_offsets(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.offsets__ = _v
                return self.offsets__
            return _hx_local_0()
        return _hx_local_1()

    def get_pixel(self):
        return self.pixel__

    def set_pixel(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.pixel__ = _v
                return self.pixel__
            return _hx_local_0()
        return _hx_local_1()

    def get_hasFixedColor(self):
        return self.hasFixedColor__

    def set_hasFixedColor(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.hasFixedColor__ = _v
                return self.hasFixedColor__
            return _hx_local_0()
        return _hx_local_1()

    def get_smoothFixedColor(self):
        return self.smoothFixedColor__

    def set_smoothFixedColor(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.smoothFixedColor__ = _v
                return self.smoothFixedColor__
            return _hx_local_0()
        return _hx_local_1()

    def get_fixedColor(self):
        return self.fixedColor__

    def set_fixedColor(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.fixedColor__ = _v
                return self.fixedColor__
            return _hx_local_0()
        return _hx_local_1()

    def get_isDepthDependant(self):
        return self.isDepthDependant__

    def set_isDepthDependant(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isDepthDependant__ = _v
                return self.isDepthDependant__
            return _hx_local_0()
        return _hx_local_1()

    def get_hasNormal(self):
        return self.hasNormal__

    def set_hasNormal(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.hasNormal__ = _v
                return self.hasNormal__
            return _hx_local_0()
        return _hx_local_1()

    def get_normalTexture(self):
        return self.normalTexture__

    def set_normalTexture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.normalTexture__ = _v
                return self.normalTexture__
            return _hx_local_0()
        return _hx_local_1()

    def get_isCube(self):
        return self.isCube__

    def set_isCube(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isCube__ = _v
                return self.isCube__
            return _hx_local_0()
        return _hx_local_1()

    def get_cubeTexture(self):
        return self.cubeTexture__

    def set_cubeTexture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.cubeTexture__ = _v
                return self.cubeTexture__
            return _hx_local_0()
        return _hx_local_1()

    def get_cubeDir(self):
        return self.cubeDir__

    def set_cubeDir(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.cubeDir__ = _v
                return self.cubeDir__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.Quality__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("Quality" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        if self.isDepth__:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.constBits
            _hx_local_2.constBits = (_hx_local_3 | 256)
            _hx_local_2.constBits
        if self.hasFixedColor__:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.constBits
            _hx_local_4.constBits = (_hx_local_5 | 512)
            _hx_local_4.constBits
        if self.smoothFixedColor__:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.constBits
            _hx_local_6.constBits = (_hx_local_7 | 1024)
            _hx_local_6.constBits
        if self.isDepthDependant__:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.constBits
            _hx_local_8.constBits = (_hx_local_9 | 2048)
            _hx_local_8.constBits
        if self.hasNormal__:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.constBits
            _hx_local_10.constBits = (_hx_local_11 | 4096)
            _hx_local_10.constBits
        if self.isCube__:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.constBits
            _hx_local_12.constBits = (_hx_local_13 | 8192)
            _hx_local_12.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.cameraInverseViewProj__
        elif (index1 == 2):
            return self.texture__
        elif (index1 == 3):
            return self.depthTexture__
        elif (index1 == 4):
            return self.Quality__
        elif (index1 == 5):
            return self.isDepth__
        elif (index1 == 6):
            return self.values__
        elif (index1 == 7):
            return self.offsets__
        elif (index1 == 8):
            return self.pixel__
        elif (index1 == 9):
            return self.hasFixedColor__
        elif (index1 == 10):
            return self.smoothFixedColor__
        elif (index1 == 11):
            return self.fixedColor__
        elif (index1 == 12):
            return self.isDepthDependant__
        elif (index1 == 13):
            return self.hasNormal__
        elif (index1 == 14):
            return self.normalTexture__
        elif (index1 == 15):
            return self.isCube__
        elif (index1 == 16):
            return self.cubeTexture__
        elif (index1 == 17):
            return self.cubeDir__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_Blur)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.cameraInverseViewProj__ = self.cameraInverseViewProj__
        s.texture__ = self.texture__
        s.depthTexture__ = self.depthTexture__
        s.Quality__ = self.Quality__
        s.isDepth__ = self.isDepth__
        s.values__ = self.values__
        s.offsets__ = self.offsets__
        s.pixel__ = self.pixel__
        s.hasFixedColor__ = self.hasFixedColor__
        s.smoothFixedColor__ = self.smoothFixedColor__
        s.fixedColor__ = self.fixedColor__
        s.isDepthDependant__ = self.isDepthDependant__
        s.hasNormal__ = self.hasNormal__
        s.normalTexture__ = self.normalTexture__
        s.isCube__ = self.isCube__
        s.cubeTexture__ = self.cubeTexture__
        s.cubeDir__ = self.cubeDir__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cameraInverseViewProj__ = None
        _hx_o.texture__ = None
        _hx_o.depthTexture__ = None
        _hx_o.Quality__ = None
        _hx_o.isDepth__ = None
        _hx_o.values__ = None
        _hx_o.offsets__ = None
        _hx_o.pixel__ = None
        _hx_o.hasFixedColor__ = None
        _hx_o.smoothFixedColor__ = None
        _hx_o.fixedColor__ = None
        _hx_o.isDepthDependant__ = None
        _hx_o.hasNormal__ = None
        _hx_o.normalTexture__ = None
        _hx_o.isCube__ = None
        _hx_o.cubeTexture__ = None
        _hx_o.cubeDir__ = None
h3d_shader_Blur._hx_class = h3d_shader_Blur
_hx_classes["h3d.shader.Blur"] = h3d_shader_Blur


class h3d_shader_ShaderBuffers:
    _hx_class_name = "h3d.shader.ShaderBuffers"
    _hx_is_interface = "False"
    __slots__ = ("globals", "params", "tex", "buffers")
    _hx_fields = ["globals", "params", "tex", "buffers"]
    _hx_methods = ["grow"]

    def __init__(self,s):
        this1 = [None]*(s.globalsSize << 2)
        self.globals = this1
        this1 = [None]*(s.paramsSize << 2)
        self.params = this1
        this1 = [None]*s.texturesCount
        self.tex = this1
        tmp = None
        if (s.bufferCount > 0):
            this1 = [None]*s.bufferCount
            tmp = this1
        else:
            tmp = None
        self.buffers = tmp

    def grow(self,s):
        ng = (s.globalsSize << 2)
        np = (s.paramsSize << 2)
        nt = s.texturesCount
        nb = s.bufferCount
        if (len(self.globals) < ng):
            this1 = [None]*ng
            self.globals = this1
        if (len(self.params) < np):
            this1 = [None]*np
            self.params = this1
        if (len(self.tex) < nt):
            this1 = [None]*nt
            self.tex = this1
        if ((nb > 0) and (((self.buffers is None) or ((len(self.buffers) < nb))))):
            this1 = [None]*nb
            self.buffers = this1

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.globals = None
        _hx_o.params = None
        _hx_o.tex = None
        _hx_o.buffers = None
h3d_shader_ShaderBuffers._hx_class = h3d_shader_ShaderBuffers
_hx_classes["h3d.shader.ShaderBuffers"] = h3d_shader_ShaderBuffers


class h3d_shader_Buffers:
    _hx_class_name = "h3d.shader.Buffers"
    _hx_is_interface = "False"
    __slots__ = ("vertex", "fragment")
    _hx_fields = ["vertex", "fragment"]
    _hx_methods = ["grow"]

    def __init__(self,s):
        self.vertex = h3d_shader_ShaderBuffers(s.vertex)
        self.fragment = h3d_shader_ShaderBuffers(s.fragment)

    def grow(self,s):
        self.vertex.grow(s.vertex)
        self.fragment.grow(s.fragment)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vertex = None
        _hx_o.fragment = None
h3d_shader_Buffers._hx_class = h3d_shader_Buffers
_hx_classes["h3d.shader.Buffers"] = h3d_shader_Buffers


class h3d_shader_ColorAdd(hxsl_Shader):
    _hx_class_name = "h3d.shader.ColorAdd"
    _hx_is_interface = "False"
    __slots__ = ("color__",)
    _hx_fields = ["color__"]
    _hx_methods = ["get_color", "set_color", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,color = None):
        if (color is None):
            color = 0
        self.color__ = h3d_Vector()
        super().__init__()
        _this = self.color__
        _this.x = ((((color >> 16) & 255)) / 255)
        _this.y = ((((color >> 8) & 255)) / 255)
        _this.z = (((color & 255)) / 255)
        _this.w = ((HxOverrides.rshift(color, 24)) / 255)

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.color__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_ColorAdd)
        s.shader = self.shader
        s.color__ = self.color__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color__ = None
h3d_shader_ColorAdd._hx_class = h3d_shader_ColorAdd
_hx_classes["h3d.shader.ColorAdd"] = h3d_shader_ColorAdd


class h3d_shader_ColorKey(hxsl_Shader):
    _hx_class_name = "h3d.shader.ColorKey"
    _hx_is_interface = "False"
    __slots__ = ("colorKey__",)
    _hx_fields = ["colorKey__"]
    _hx_methods = ["get_colorKey", "set_colorKey", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,v = None):
        if (v is None):
            v = 0
        self.colorKey__ = h3d_Vector()
        super().__init__()
        _this = self.colorKey__
        _this.x = ((((v >> 16) & 255)) / 255)
        _this.y = ((((v >> 8) & 255)) / 255)
        _this.z = (((v & 255)) / 255)
        _this.w = ((HxOverrides.rshift(v, 24)) / 255)

    def get_colorKey(self):
        return self.colorKey__

    def set_colorKey(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.colorKey__ = _v
                return self.colorKey__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.colorKey__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_ColorKey)
        s.shader = self.shader
        s.colorKey__ = self.colorKey__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.colorKey__ = None
h3d_shader_ColorKey._hx_class = h3d_shader_ColorKey
_hx_classes["h3d.shader.ColorKey"] = h3d_shader_ColorKey


class h3d_shader_ColorMatrix(hxsl_Shader):
    _hx_class_name = "h3d.shader.ColorMatrix"
    _hx_is_interface = "False"
    __slots__ = ("matrix__",)
    _hx_fields = ["matrix__"]
    _hx_methods = ["get_matrix", "set_matrix", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,m = None):
        self.matrix__ = h3d_Matrix()
        super().__init__()
        if (m is not None):
            self.matrix__.loadValues(m)
        else:
            self.matrix__.identity()

    def get_matrix(self):
        return self.matrix__

    def set_matrix(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.matrix__ = _v
                return self.matrix__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.matrix__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_ColorMatrix)
        s.shader = self.shader
        s.matrix__ = self.matrix__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.matrix__ = None
h3d_shader_ColorMatrix._hx_class = h3d_shader_ColorMatrix
_hx_classes["h3d.shader.ColorMatrix"] = h3d_shader_ColorMatrix


class h3d_shader_DirShadow(hxsl_Shader):
    _hx_class_name = "h3d.shader.DirShadow"
    _hx_is_interface = "False"
    __slots__ = ("enable__", "USE_ESM__", "shadowPower__", "USE_PCF__", "pcfQuality__", "pcfScale__", "shadowRes__", "shadowMap__", "shadowMapChannel__", "shadowProj__", "shadowBias__", "poissonDiskLow__", "poissonDiskHigh__", "poissonDiskVeryHigh__")
    _hx_fields = ["enable__", "USE_ESM__", "shadowPower__", "USE_PCF__", "pcfQuality__", "pcfScale__", "shadowRes__", "shadowMap__", "shadowMapChannel__", "shadowProj__", "shadowBias__", "poissonDiskLow__", "poissonDiskHigh__", "poissonDiskVeryHigh__"]
    _hx_methods = ["get_enable", "set_enable", "get_USE_ESM", "set_USE_ESM", "get_shadowPower", "set_shadowPower", "get_USE_PCF", "set_USE_PCF", "get_pcfQuality", "set_pcfQuality", "get_pcfScale", "set_pcfScale", "get_shadowRes", "set_shadowRes", "get_shadowMap", "set_shadowMap", "get_shadowMapChannel", "set_shadowMapChannel", "get_shadowProj", "set_shadowProj", "get_shadowBias", "set_shadowBias", "get_poissonDiskLow", "set_poissonDiskLow", "get_poissonDiskHigh", "set_poissonDiskHigh", "get_poissonDiskVeryHigh", "set_poissonDiskVeryHigh", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.shadowMap__ = None
        self.USE_PCF__ = None
        self.USE_ESM__ = None
        self.enable__ = None
        self.poissonDiskVeryHigh__ = list()
        self.poissonDiskHigh__ = list()
        self.poissonDiskLow__ = list()
        self.shadowBias__ = 0
        self.shadowProj__ = h3d_Matrix()
        self.shadowMapChannel__ = hxsl_Channel.Unknown
        self.shadowRes__ = h3d_Vector()
        self.pcfScale__ = 0
        self.pcfQuality__ = 0
        self.shadowPower__ = 0
        super().__init__()
        self.poissonDiskLow__ = [h3d_Vector(-0.942,-0.399), h3d_Vector(0.945,-0.768), h3d_Vector(-0.094,-0.929), h3d_Vector(0.344,0.293)]
        self.poissonDiskHigh__ = [h3d_Vector(-0.326,-0.406), h3d_Vector(-0.840,-0.074), h3d_Vector(-0.696,0.457), h3d_Vector(-0.203,0.621), h3d_Vector(0.962,-0.195), h3d_Vector(0.473,-0.480), h3d_Vector(0.519,0.767), h3d_Vector(0.185,-0.893), h3d_Vector(0.507,0.064), h3d_Vector(0.896,0.412), h3d_Vector(-0.322,-0.933), h3d_Vector(-0.792,-0.598)]
        self.poissonDiskVeryHigh__ = [h3d_Vector(-0.613392,0.617481), h3d_Vector(0.170019,-0.040254), h3d_Vector(-0.299417,0.791925), h3d_Vector(0.645680,0.493210), h3d_Vector(-0.651784,0.717887), h3d_Vector(0.421003,0.027070), h3d_Vector(-0.817194,-0.271096), h3d_Vector(-0.705374,-0.668203), h3d_Vector(0.977050,-0.108615), h3d_Vector(0.063326,0.142369), h3d_Vector(0.203528,0.214331), h3d_Vector(-0.667531,0.326090), h3d_Vector(-0.098422,-0.295755), h3d_Vector(-0.885922,0.215369), h3d_Vector(0.566637,0.605213), h3d_Vector(0.039766,-0.396100), h3d_Vector(0.751946,0.453352), h3d_Vector(0.078707,-0.715323), h3d_Vector(-0.075838,-0.529344), h3d_Vector(0.724479,-0.580798), h3d_Vector(0.222999,-0.215125), h3d_Vector(-0.467574,-0.405438), h3d_Vector(-0.248268,-0.814753), h3d_Vector(0.354411,-0.887570), h3d_Vector(0.175817,0.382366), h3d_Vector(0.487472,-0.063082), h3d_Vector(-0.084078,0.898312), h3d_Vector(0.488876,-0.783441), h3d_Vector(0.470016,0.217933), h3d_Vector(-0.696890,-0.549791), h3d_Vector(-0.149693,0.605762), h3d_Vector(0.034211,0.979980), h3d_Vector(0.503098,-0.308878), h3d_Vector(-0.016205,-0.872921), h3d_Vector(0.385784,-0.393902), h3d_Vector(-0.146886,-0.859249), h3d_Vector(0.643361,0.164098), h3d_Vector(0.634388,-0.049471), h3d_Vector(-0.688894,0.007843), h3d_Vector(0.464034,-0.188818), h3d_Vector(-0.440840,0.137486), h3d_Vector(0.364483,0.511704), h3d_Vector(0.034028,0.325968), h3d_Vector(0.099094,-0.308023), h3d_Vector(0.693960,-0.366253), h3d_Vector(0.678884,-0.204688), h3d_Vector(0.001801,0.780328), h3d_Vector(0.145177,-0.898984), h3d_Vector(0.062655,-0.611866), h3d_Vector(0.315226,-0.604297), h3d_Vector(-0.780145,0.486251), h3d_Vector(-0.371868,0.882138), h3d_Vector(0.200476,0.494430), h3d_Vector(-0.494552,-0.711051), h3d_Vector(0.612476,0.705252), h3d_Vector(-0.578845,-0.768792), h3d_Vector(-0.772454,-0.090976), h3d_Vector(0.504440,0.372295), h3d_Vector(0.155736,0.065157), h3d_Vector(0.391522,0.849605), h3d_Vector(-0.620106,-0.328104), h3d_Vector(0.789239,-0.419965), h3d_Vector(-0.545396,0.538133), h3d_Vector(-0.178564,-0.596057)]

    def get_enable(self):
        return self.enable__

    def set_enable(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.enable__ = _v
                return self.enable__
            return _hx_local_0()
        return _hx_local_1()

    def get_USE_ESM(self):
        return self.USE_ESM__

    def set_USE_ESM(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.USE_ESM__ = _v
                return self.USE_ESM__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowPower(self):
        return self.shadowPower__

    def set_shadowPower(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.shadowPower__ = _v
                return self.shadowPower__
            return _hx_local_0()
        return _hx_local_1()

    def get_USE_PCF(self):
        return self.USE_PCF__

    def set_USE_PCF(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.USE_PCF__ = _v
                return self.USE_PCF__
            return _hx_local_0()
        return _hx_local_1()

    def get_pcfQuality(self):
        return self.pcfQuality__

    def set_pcfQuality(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.pcfQuality__ = _v
                return self.pcfQuality__
            return _hx_local_0()
        return _hx_local_1()

    def get_pcfScale(self):
        return self.pcfScale__

    def set_pcfScale(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.pcfScale__ = _v
                return self.pcfScale__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowRes(self):
        return self.shadowRes__

    def set_shadowRes(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.shadowRes__ = _v
                return self.shadowRes__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowMap(self):
        return self.shadowMap__

    def set_shadowMap(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.shadowMap__ = _v
                return self.shadowMap__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowMapChannel(self):
        return self.shadowMapChannel__

    def set_shadowMapChannel(self,v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.shadowMapChannel__ = v
                return self.shadowMapChannel__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowProj(self):
        return self.shadowProj__

    def set_shadowProj(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.shadowProj__ = _v
                return self.shadowProj__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowBias(self):
        return self.shadowBias__

    def set_shadowBias(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.shadowBias__ = _v
                return self.shadowBias__
            return _hx_local_0()
        return _hx_local_1()

    def get_poissonDiskLow(self):
        return self.poissonDiskLow__

    def set_poissonDiskLow(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.poissonDiskLow__ = _v
                return self.poissonDiskLow__
            return _hx_local_0()
        return _hx_local_1()

    def get_poissonDiskHigh(self):
        return self.poissonDiskHigh__

    def set_poissonDiskHigh(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.poissonDiskHigh__ = _v
                return self.poissonDiskHigh__
            return _hx_local_0()
        return _hx_local_1()

    def get_poissonDiskVeryHigh(self):
        return self.poissonDiskVeryHigh__

    def set_poissonDiskVeryHigh(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.poissonDiskVeryHigh__ = _v
                return self.poissonDiskVeryHigh__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.enable__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        if self.USE_ESM__:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.constBits
            _hx_local_2.constBits = (_hx_local_3 | 2)
            _hx_local_2.constBits
        if self.USE_PCF__:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.constBits
            _hx_local_4.constBits = (_hx_local_5 | 4)
            _hx_local_4.constBits
        v = self.pcfQuality__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("pcfQuality" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.constBits
        _hx_local_6.constBits = (_hx_local_7 | ((v << 3)))
        _hx_local_6.constBits
        if (self.shadowMap__ is None):
            self.shadowMapChannel__ = hxsl_Channel.Unknown
        elif (self.shadowMapChannel__ == hxsl_Channel.Unknown):
            if (self.shadowMap__.format == h3d_mat_Texture.nativeFormat):
                self.shadowMapChannel__ = hxsl_Channel.PackedFloat
            else:
                raise haxe_Exception.thrown(("shadowMap" + "Channel is not set"))
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.constBits
        _hx_local_8.constBits = (_hx_local_9 | (((((globals.allocChannelID(self.shadowMap__) << 3) | self.shadowMapChannel__.index)) << 11)))
        _hx_local_8.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.enable__
        elif (index1 == 1):
            return self.USE_ESM__
        elif (index1 == 2):
            return self.shadowPower__
        elif (index1 == 3):
            return self.USE_PCF__
        elif (index1 == 4):
            return self.pcfQuality__
        elif (index1 == 5):
            return self.pcfScale__
        elif (index1 == 6):
            return self.shadowRes__
        elif (index1 == 7):
            return self.shadowMap__
        elif (index1 == 8):
            return self.shadowProj__
        elif (index1 == 9):
            return self.shadowBias__
        elif (index1 == 10):
            return self.poissonDiskLow__
        elif (index1 == 11):
            return self.poissonDiskHigh__
        elif (index1 == 12):
            return self.poissonDiskVeryHigh__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        index1 = index
        if (index1 == 2):
            return self.shadowPower__
        elif (index1 == 5):
            return self.pcfScale__
        elif (index1 == 9):
            return self.shadowBias__
        else:
            pass
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_DirShadow)
        s.shader = self.shader
        s.enable__ = self.enable__
        s.USE_ESM__ = self.USE_ESM__
        s.shadowPower__ = self.shadowPower__
        s.USE_PCF__ = self.USE_PCF__
        s.pcfQuality__ = self.pcfQuality__
        s.pcfScale__ = self.pcfScale__
        s.shadowRes__ = self.shadowRes__
        s.shadowMap__ = self.shadowMap__
        s.shadowProj__ = self.shadowProj__
        s.shadowBias__ = self.shadowBias__
        s.poissonDiskLow__ = self.poissonDiskLow__
        s.poissonDiskHigh__ = self.poissonDiskHigh__
        s.poissonDiskVeryHigh__ = self.poissonDiskVeryHigh__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.enable__ = None
        _hx_o.USE_ESM__ = None
        _hx_o.shadowPower__ = None
        _hx_o.USE_PCF__ = None
        _hx_o.pcfQuality__ = None
        _hx_o.pcfScale__ = None
        _hx_o.shadowRes__ = None
        _hx_o.shadowMap__ = None
        _hx_o.shadowMapChannel__ = None
        _hx_o.shadowProj__ = None
        _hx_o.shadowBias__ = None
        _hx_o.poissonDiskLow__ = None
        _hx_o.poissonDiskHigh__ = None
        _hx_o.poissonDiskVeryHigh__ = None
h3d_shader_DirShadow._hx_class = h3d_shader_DirShadow
_hx_classes["h3d.shader.DirShadow"] = h3d_shader_DirShadow


class h3d_shader_GenTexture(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.shader.GenTexture"
    _hx_is_interface = "False"
    __slots__ = ("mode__", "color__")
    _hx_fields = ["mode__", "color__"]
    _hx_methods = ["get_mode", "set_mode", "get_color", "set_color", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.color__ = h3d_Vector()
        self.mode__ = 0
        super().__init__()

    def get_mode(self):
        return self.mode__

    def set_mode(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.mode__ = _v
                return self.mode__
            return _hx_local_0()
        return _hx_local_1()

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.mode__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("mode" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.mode__
        elif (index1 == 2):
            return self.color__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_GenTexture)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.mode__ = self.mode__
        s.color__ = self.color__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mode__ = None
        _hx_o.color__ = None
h3d_shader_GenTexture._hx_class = h3d_shader_GenTexture
_hx_classes["h3d.shader.GenTexture"] = h3d_shader_GenTexture


class h3d_shader_LineShader(hxsl_Shader):
    _hx_class_name = "h3d.shader.LineShader"
    _hx_is_interface = "False"
    __slots__ = ("lengthScale__", "width__")
    _hx_fields = ["lengthScale__", "width__"]
    _hx_methods = ["get_lengthScale", "set_lengthScale", "get_width", "set_width", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,width = None,lengthScale = None):
        if (width is None):
            width = 1.5
        if (lengthScale is None):
            lengthScale = 1.
        self.width__ = 0
        self.lengthScale__ = 0
        super().__init__()
        self.width__ = width
        self.lengthScale__ = lengthScale

    def get_lengthScale(self):
        return self.lengthScale__

    def set_lengthScale(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.lengthScale__ = _v
                return self.lengthScale__
            return _hx_local_0()
        return _hx_local_1()

    def get_width(self):
        return self.width__

    def set_width(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.width__ = _v
                return self.width__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.lengthScale__
        elif (index1 == 1):
            return self.width__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.lengthScale__
        elif (index1 == 1):
            return self.width__
        else:
            pass
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_LineShader)
        s.shader = self.shader
        s.lengthScale__ = self.lengthScale__
        s.width__ = self.width__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lengthScale__ = None
        _hx_o.width__ = None
h3d_shader_LineShader._hx_class = h3d_shader_LineShader
_hx_classes["h3d.shader.LineShader"] = h3d_shader_LineShader


class h3d_shader_MinMaxShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.shader.MinMaxShader"
    _hx_is_interface = "False"
    __slots__ = ("texA__", "texB__", "isMax__")
    _hx_fields = ["texA__", "texB__", "isMax__"]
    _hx_methods = ["get_texA", "set_texA", "get_texB", "set_texB", "get_isMax", "set_isMax", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.isMax__ = None
        self.texB__ = None
        self.texA__ = None
        super().__init__()

    def get_texA(self):
        return self.texA__

    def set_texA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texA__ = _v
                return self.texA__
            return _hx_local_0()
        return _hx_local_1()

    def get_texB(self):
        return self.texB__

    def set_texB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texB__ = _v
                return self.texB__
            return _hx_local_0()
        return _hx_local_1()

    def get_isMax(self):
        return self.isMax__

    def set_isMax(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isMax__ = _v
                return self.isMax__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.isMax__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texA__
        elif (index1 == 2):
            return self.texB__
        elif (index1 == 3):
            return self.isMax__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_MinMaxShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texA__ = self.texA__
        s.texB__ = self.texB__
        s.isMax__ = self.isMax__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texA__ = None
        _hx_o.texB__ = None
        _hx_o.isMax__ = None
h3d_shader_MinMaxShader._hx_class = h3d_shader_MinMaxShader
_hx_classes["h3d.shader.MinMaxShader"] = h3d_shader_MinMaxShader


class h3d_shader_CubeMinMaxShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.shader.CubeMinMaxShader"
    _hx_is_interface = "False"
    __slots__ = ("texA__", "texB__", "isMax__", "mat__")
    _hx_fields = ["texA__", "texB__", "isMax__", "mat__"]
    _hx_methods = ["get_texA", "set_texA", "get_texB", "set_texB", "get_isMax", "set_isMax", "get_mat", "set_mat", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.isMax__ = None
        self.texB__ = None
        self.texA__ = None
        self.mat__ = h3d_Matrix()
        super().__init__()

    def get_texA(self):
        return self.texA__

    def set_texA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texA__ = _v
                return self.texA__
            return _hx_local_0()
        return _hx_local_1()

    def get_texB(self):
        return self.texB__

    def set_texB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texB__ = _v
                return self.texB__
            return _hx_local_0()
        return _hx_local_1()

    def get_isMax(self):
        return self.isMax__

    def set_isMax(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isMax__ = _v
                return self.isMax__
            return _hx_local_0()
        return _hx_local_1()

    def get_mat(self):
        return self.mat__

    def set_mat(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.mat__ = _v
                return self.mat__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.isMax__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texA__
        elif (index1 == 2):
            return self.texB__
        elif (index1 == 3):
            return self.isMax__
        elif (index1 == 4):
            return self.mat__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_CubeMinMaxShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texA__ = self.texA__
        s.texB__ = self.texB__
        s.isMax__ = self.isMax__
        s.mat__ = self.mat__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texA__ = None
        _hx_o.texB__ = None
        _hx_o.isMax__ = None
        _hx_o.mat__ = None
h3d_shader_CubeMinMaxShader._hx_class = h3d_shader_CubeMinMaxShader
_hx_classes["h3d.shader.CubeMinMaxShader"] = h3d_shader_CubeMinMaxShader


class h3d_shader_NormalMap(hxsl_Shader):
    _hx_class_name = "h3d.shader.NormalMap"
    _hx_is_interface = "False"
    __slots__ = ("texture__",)
    _hx_fields = ["texture__"]
    _hx_methods = ["get_texture", "set_texture", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,texture = None):
        self.texture__ = None
        super().__init__()
        self.texture__ = texture

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.texture__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_NormalMap)
        s.shader = self.shader
        s.texture__ = self.texture__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
h3d_shader_NormalMap._hx_class = h3d_shader_NormalMap
_hx_classes["h3d.shader.NormalMap"] = h3d_shader_NormalMap


class h3d_shader_Shadow(hxsl_Shader):
    _hx_class_name = "h3d.shader.Shadow"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["updateConstants", "getParamValue", "getParamFloatValue"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        super().__init__()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        return None

    def getParamFloatValue(self,index):
        return 0.
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_shader_Shadow._hx_class = h3d_shader_Shadow
_hx_classes["h3d.shader.Shadow"] = h3d_shader_Shadow


class h3d_shader_SignedDistanceField(hxsl_Shader):
    _hx_class_name = "h3d.shader.SignedDistanceField"
    _hx_is_interface = "False"
    __slots__ = ("channel__", "alphaCutoff__", "smoothing__")
    _hx_fields = ["channel__", "alphaCutoff__", "smoothing__"]
    _hx_methods = ["get_channel", "set_channel", "get_alphaCutoff", "set_alphaCutoff", "get_smoothing", "set_smoothing", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.smoothing__ = 0.0416666666666666644
        self.alphaCutoff__ = 0.5
        self.channel__ = 0
        super().__init__()

    def get_channel(self):
        return self.channel__

    def set_channel(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.channel__ = _v
                return self.channel__
            return _hx_local_0()
        return _hx_local_1()

    def get_alphaCutoff(self):
        return self.alphaCutoff__

    def set_alphaCutoff(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.alphaCutoff__ = _v
                return self.alphaCutoff__
            return _hx_local_0()
        return _hx_local_1()

    def get_smoothing(self):
        return self.smoothing__

    def set_smoothing(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.smoothing__ = _v
                return self.smoothing__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.channel__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("channel" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.channel__
        elif (index1 == 1):
            return self.alphaCutoff__
        elif (index1 == 2):
            return self.smoothing__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        index1 = index
        if (index1 == 1):
            return self.alphaCutoff__
        elif (index1 == 2):
            return self.smoothing__
        else:
            pass
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_SignedDistanceField)
        s.shader = self.shader
        s.channel__ = self.channel__
        s.alphaCutoff__ = self.alphaCutoff__
        s.smoothing__ = self.smoothing__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.channel__ = None
        _hx_o.alphaCutoff__ = None
        _hx_o.smoothing__ = None
h3d_shader_SignedDistanceField._hx_class = h3d_shader_SignedDistanceField
_hx_classes["h3d.shader.SignedDistanceField"] = h3d_shader_SignedDistanceField


class h3d_shader_SkinBase(hxsl_Shader):
    _hx_class_name = "h3d.shader.SkinBase"
    _hx_is_interface = "False"
    __slots__ = ("MaxBones__", "bonesMatrixes__")
    _hx_fields = ["MaxBones__", "bonesMatrixes__"]
    _hx_methods = ["get_MaxBones", "set_MaxBones", "get_bonesMatrixes", "set_bonesMatrixes", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.bonesMatrixes__ = list()
        self.MaxBones__ = 0
        super().__init__()
        self.constModified = True
        self.MaxBones__ = 34

    def get_MaxBones(self):
        return self.MaxBones__

    def set_MaxBones(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.MaxBones__ = _v
                return self.MaxBones__
            return _hx_local_0()
        return _hx_local_1()

    def get_bonesMatrixes(self):
        return self.bonesMatrixes__

    def set_bonesMatrixes(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.bonesMatrixes__ = _v
                return self.bonesMatrixes__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.MaxBones__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("MaxBones" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.MaxBones__
        elif (index1 == 1):
            return self.bonesMatrixes__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_SkinBase)
        s.shader = self.shader
        s.MaxBones__ = self.MaxBones__
        s.bonesMatrixes__ = self.bonesMatrixes__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.MaxBones__ = None
        _hx_o.bonesMatrixes__ = None
h3d_shader_SkinBase._hx_class = h3d_shader_SkinBase
_hx_classes["h3d.shader.SkinBase"] = h3d_shader_SkinBase


class h3d_shader_Skin(h3d_shader_SkinBase):
    _hx_class_name = "h3d.shader.Skin"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_SkinBase


    def __init__(self):
        super().__init__()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.MaxBones__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("MaxBones" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.MaxBones__
        elif (index1 == 1):
            return self.bonesMatrixes__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_Skin)
        s.shader = self.shader
        s.MaxBones__ = self.MaxBones__
        s.bonesMatrixes__ = self.bonesMatrixes__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_shader_Skin._hx_class = h3d_shader_Skin
_hx_classes["h3d.shader.Skin"] = h3d_shader_Skin


class h3d_shader_SkinTangent(h3d_shader_SkinBase):
    _hx_class_name = "h3d.shader.SkinTangent"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_SkinBase


    def __init__(self):
        super().__init__()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.MaxBones__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("MaxBones" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.MaxBones__
        elif (index1 == 1):
            return self.bonesMatrixes__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_SkinTangent)
        s.shader = self.shader
        s.MaxBones__ = self.MaxBones__
        s.bonesMatrixes__ = self.bonesMatrixes__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_shader_SkinTangent._hx_class = h3d_shader_SkinTangent
_hx_classes["h3d.shader.SkinTangent"] = h3d_shader_SkinTangent


class h3d_shader_SpecularTexture(hxsl_Shader):
    _hx_class_name = "h3d.shader.SpecularTexture"
    _hx_is_interface = "False"
    __slots__ = ("texture__",)
    _hx_fields = ["texture__"]
    _hx_methods = ["get_texture", "set_texture", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,tex = None):
        self.texture__ = None
        super().__init__()
        self.texture__ = tex

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.texture__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_SpecularTexture)
        s.shader = self.shader
        s.texture__ = self.texture__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
h3d_shader_SpecularTexture._hx_class = h3d_shader_SpecularTexture
_hx_classes["h3d.shader.SpecularTexture"] = h3d_shader_SpecularTexture


class h3d_shader_Texture(hxsl_Shader):
    _hx_class_name = "h3d.shader.Texture"
    _hx_is_interface = "False"
    __slots__ = ("additive__", "killAlpha__", "specularAlpha__", "killAlphaThreshold__", "texture__")
    _hx_fields = ["additive__", "killAlpha__", "specularAlpha__", "killAlphaThreshold__", "texture__"]
    _hx_methods = ["get_additive", "set_additive", "get_killAlpha", "set_killAlpha", "get_specularAlpha", "set_specularAlpha", "get_killAlphaThreshold", "set_killAlphaThreshold", "get_texture", "set_texture", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,tex = None):
        self.texture__ = None
        self.specularAlpha__ = None
        self.killAlpha__ = None
        self.additive__ = None
        self.killAlphaThreshold__ = 0
        super().__init__()
        self.texture__ = tex
        self.killAlphaThreshold__ = h3d_mat_Defaults.defaultKillAlphaThreshold

    def get_additive(self):
        return self.additive__

    def set_additive(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.additive__ = _v
                return self.additive__
            return _hx_local_0()
        return _hx_local_1()

    def get_killAlpha(self):
        return self.killAlpha__

    def set_killAlpha(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.killAlpha__ = _v
                return self.killAlpha__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularAlpha(self):
        return self.specularAlpha__

    def set_specularAlpha(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.specularAlpha__ = _v
                return self.specularAlpha__
            return _hx_local_0()
        return _hx_local_1()

    def get_killAlphaThreshold(self):
        return self.killAlphaThreshold__

    def set_killAlphaThreshold(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.killAlphaThreshold__ = _v
                return self.killAlphaThreshold__
            return _hx_local_0()
        return _hx_local_1()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.additive__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        if self.killAlpha__:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.constBits
            _hx_local_2.constBits = (_hx_local_3 | 2)
            _hx_local_2.constBits
        if self.specularAlpha__:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.constBits
            _hx_local_4.constBits = (_hx_local_5 | 4)
            _hx_local_4.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.additive__
        elif (index1 == 1):
            return self.killAlpha__
        elif (index1 == 2):
            return self.specularAlpha__
        elif (index1 == 3):
            return self.killAlphaThreshold__
        elif (index1 == 4):
            return self.texture__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 3):
            return self.killAlphaThreshold__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_Texture)
        s.shader = self.shader
        s.additive__ = self.additive__
        s.killAlpha__ = self.killAlpha__
        s.specularAlpha__ = self.specularAlpha__
        s.killAlphaThreshold__ = self.killAlphaThreshold__
        s.texture__ = self.texture__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.additive__ = None
        _hx_o.killAlpha__ = None
        _hx_o.specularAlpha__ = None
        _hx_o.killAlphaThreshold__ = None
        _hx_o.texture__ = None
h3d_shader_Texture._hx_class = h3d_shader_Texture
_hx_classes["h3d.shader.Texture"] = h3d_shader_Texture


class h3d_shader_UVDelta(hxsl_Shader):
    _hx_class_name = "h3d.shader.UVDelta"
    _hx_is_interface = "False"
    __slots__ = ("uvDelta__", "uvScale__")
    _hx_fields = ["uvDelta__", "uvScale__"]
    _hx_methods = ["get_uvDelta", "set_uvDelta", "get_uvScale", "set_uvScale", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,dx = None,dy = None,sx = None,sy = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        if (sx is None):
            sx = 1.
        if (sy is None):
            sy = 1.
        self.uvScale__ = h3d_Vector()
        self.uvDelta__ = h3d_Vector()
        super().__init__()
        _this = self.uvDelta__
        x = dx
        y = dy
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        _this = self.uvScale__
        x = sx
        y = sy
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.

    def get_uvDelta(self):
        return self.uvDelta__

    def set_uvDelta(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.uvDelta__ = _v
                return self.uvDelta__
            return _hx_local_0()
        return _hx_local_1()

    def get_uvScale(self):
        return self.uvScale__

    def set_uvScale(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.uvScale__ = _v
                return self.uvScale__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.uvDelta__
        elif (index1 == 1):
            return self.uvScale__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_UVDelta)
        s.shader = self.shader
        s.uvDelta__ = self.uvDelta__
        s.uvScale__ = self.uvScale__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.uvDelta__ = None
        _hx_o.uvScale__ = None
h3d_shader_UVDelta._hx_class = h3d_shader_UVDelta
_hx_classes["h3d.shader.UVDelta"] = h3d_shader_UVDelta


class h3d_shader_VertexColorAlpha(hxsl_Shader):
    _hx_class_name = "h3d.shader.VertexColorAlpha"
    _hx_is_interface = "False"
    __slots__ = ("additive__",)
    _hx_fields = ["additive__"]
    _hx_methods = ["get_additive", "set_additive", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.additive__ = None
        super().__init__()

    def get_additive(self):
        return self.additive__

    def set_additive(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.additive__ = _v
                return self.additive__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.additive__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.additive__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_VertexColorAlpha)
        s.shader = self.shader
        s.additive__ = self.additive__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.additive__ = None
h3d_shader_VertexColorAlpha._hx_class = h3d_shader_VertexColorAlpha
_hx_classes["h3d.shader.VertexColorAlpha"] = h3d_shader_VertexColorAlpha


class h3d_shader_VolumeDecal(hxsl_Shader):
    _hx_class_name = "h3d.shader.VolumeDecal"
    _hx_is_interface = "False"
    __slots__ = ("scale__", "normal__", "tangent__", "isCentered__")
    _hx_fields = ["scale__", "normal__", "tangent__", "isCentered__"]
    _hx_methods = ["get_scale", "set_scale", "get_normal", "set_normal", "get_tangent", "set_tangent", "get_isCentered", "set_isCentered", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,objectWidth,objectHeight):
        self.isCentered__ = True
        self.tangent__ = h3d_Vector()
        self.normal__ = h3d_Vector()
        self.scale__ = h3d_Vector()
        super().__init__()
        _this = self.normal__
        x = 0
        y = 0
        z = 1
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.tangent__
        x = 1
        y = 0
        z = 0
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.scale__
        x = (1 / objectWidth)
        y = (1 / objectHeight)
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.

    def get_scale(self):
        return self.scale__

    def set_scale(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.scale__ = _v
                return self.scale__
            return _hx_local_0()
        return _hx_local_1()

    def get_normal(self):
        return self.normal__

    def set_normal(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.normal__ = _v
                return self.normal__
            return _hx_local_0()
        return _hx_local_1()

    def get_tangent(self):
        return self.tangent__

    def set_tangent(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.tangent__ = _v
                return self.tangent__
            return _hx_local_0()
        return _hx_local_1()

    def get_isCentered(self):
        return self.isCentered__

    def set_isCentered(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isCentered__ = _v
                return self.isCentered__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.isCentered__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 64)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.scale__
        elif (index1 == 1):
            return self.normal__
        elif (index1 == 2):
            return self.tangent__
        elif (index1 == 3):
            return self.isCentered__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_VolumeDecal)
        s.shader = self.shader
        s.scale__ = self.scale__
        s.normal__ = self.normal__
        s.tangent__ = self.tangent__
        s.isCentered__ = self.isCentered__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.scale__ = None
        _hx_o.normal__ = None
        _hx_o.tangent__ = None
        _hx_o.isCentered__ = None
h3d_shader_VolumeDecal._hx_class = h3d_shader_VolumeDecal
_hx_classes["h3d.shader.VolumeDecal"] = h3d_shader_VolumeDecal


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    _hx_is_interface = "True"
    __slots__ = ()
haxe_IMap._hx_class = haxe_IMap
_hx_classes["haxe.IMap"] = haxe_IMap


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "remove", "keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def remove(self,key):
        r = (key in self.h)
        if r:
            del self.h[key]
        return r

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap
_hx_classes["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap


class sys_thread_Mutex:
    _hx_class_name = "sys.thread.Mutex"
    _hx_is_interface = "False"
    __slots__ = ("lock",)
    _hx_fields = ["lock"]

    def __init__(self):
        self.lock = sys_thread__Mutex_NativeRLock()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lock = None
sys_thread_Mutex._hx_class = sys_thread_Mutex
_hx_classes["sys.thread.Mutex"] = sys_thread_Mutex


class sys_thread_EventLoop:
    _hx_class_name = "sys.thread.EventLoop"
    _hx_is_interface = "False"
    __slots__ = ("mutex", "oneTimeEvents", "oneTimeEventsIdx", "waitLock", "promisedEventsCount", "regularEvents")
    _hx_fields = ["mutex", "oneTimeEvents", "oneTimeEventsIdx", "waitLock", "promisedEventsCount", "regularEvents"]
    _hx_methods = ["repeat", "cancel", "loop"]

    def __init__(self):
        self.regularEvents = None
        self.promisedEventsCount = 0
        self.waitLock = sys_thread_Lock()
        self.oneTimeEventsIdx = 0
        self.oneTimeEvents = list()
        self.mutex = sys_thread_Mutex()

    def repeat(self,event,intervalMs):
        self.mutex.lock.acquire(True)
        interval = (0.001 * intervalMs)
        event1 = sys_thread__EventLoop_RegularEvent(event,(python_lib_Time.time() + interval),interval)
        _g = self.regularEvents
        if (_g is not None):
            current = _g
            event1.next = current
            current.previous = event1
        self.regularEvents = event1
        self.waitLock.semaphore.release()
        self.mutex.lock.release()
        return event1

    def cancel(self,eventHandler):
        self.mutex.lock.acquire(True)
        event = eventHandler
        if (self.regularEvents == event):
            self.regularEvents = event.next
        _g = event.next
        if (_g is not None):
            e = _g
            e.previous = event.previous
        _g = event.previous
        if (_g is not None):
            e = _g
            e.next = event.next
        self.mutex.lock.release()

    def loop(self):
        events = []
        while True:
            now = python_lib_Time.time()
            eventsToRun = events
            eventsToRunIdx = 0
            nextEventAt = -1
            self.mutex.lock.acquire(True)
            while self.waitLock.semaphore.acquire(True,0.0):
                pass
            current = self.regularEvents
            while (current is not None):
                if (current.nextRunTime <= now):
                    tmp = eventsToRunIdx
                    eventsToRunIdx = (eventsToRunIdx + 1)
                    python_internal_ArrayImpl._set(eventsToRun, tmp, current.run)
                    current.nextRunTime = (current.nextRunTime + current.interval)
                    nextEventAt = -2
                elif ((nextEventAt == -1) or ((current.nextRunTime < nextEventAt))):
                    nextEventAt = current.nextRunTime
                current = current.next
            self.mutex.lock.release()
            _g = 0
            _g1 = eventsToRunIdx
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                (eventsToRun[i] if i >= 0 and i < len(eventsToRun) else None)()
                python_internal_ArrayImpl._set(eventsToRun, i, None)
            eventsToRunIdx = 0
            self.mutex.lock.acquire(True)
            _g2_current = 0
            _g2_array = self.oneTimeEvents
            while (_g2_current < len(_g2_array)):
                _g3_value = (_g2_array[_g2_current] if _g2_current >= 0 and _g2_current < len(_g2_array) else None)
                _g3_key = _g2_current
                _g2_current = (_g2_current + 1)
                i1 = _g3_key
                event = _g3_value
                if (event is None):
                    break
                else:
                    tmp1 = eventsToRunIdx
                    eventsToRunIdx = (eventsToRunIdx + 1)
                    python_internal_ArrayImpl._set(eventsToRun, tmp1, event)
                    python_internal_ArrayImpl._set(self.oneTimeEvents, i1, None)
            self.oneTimeEventsIdx = 0
            hasPromisedEvents = (self.promisedEventsCount > 0)
            self.mutex.lock.release()
            _g2 = 0
            _g3 = eventsToRunIdx
            while (_g2 < _g3):
                i2 = _g2
                _g2 = (_g2 + 1)
                (eventsToRun[i2] if i2 >= 0 and i2 < len(eventsToRun) else None)()
                python_internal_ArrayImpl._set(eventsToRun, i2, None)
            if (eventsToRunIdx > 0):
                nextEventAt = -2
            r_nextEventAt = nextEventAt
            r_anyTime = hasPromisedEvents
            _g4 = r_anyTime
            _g5 = r_nextEventAt
            _g6 = _g5
            if (_g6 == -2):
                pass
            elif (_g6 == -1):
                if _g4:
                    self.waitLock.semaphore.acquire(True,None)
                else:
                    break
            else:
                time = _g5
                timeout = (time - python_lib_Time.time())
                _this = self.waitLock
                timeout1 = (0 if (python_lib_Math.isnan(0)) else (timeout if (python_lib_Math.isnan(timeout)) else max(0,timeout)))
                _this.semaphore.acquire(True,timeout1)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mutex = None
        _hx_o.oneTimeEvents = None
        _hx_o.oneTimeEventsIdx = None
        _hx_o.waitLock = None
        _hx_o.promisedEventsCount = None
        _hx_o.regularEvents = None
sys_thread_EventLoop._hx_class = sys_thread_EventLoop
_hx_classes["sys.thread.EventLoop"] = sys_thread_EventLoop


class sys_thread__Thread_HxThread:
    _hx_class_name = "sys.thread._Thread.HxThread"
    _hx_is_interface = "False"
    __slots__ = ("events", "nativeThread")
    _hx_fields = ["events", "nativeThread"]
    _hx_statics = ["threads", "threadsMutex", "mainThread", "current"]

    def __init__(self,t):
        self.events = None
        self.nativeThread = t
    threads = None
    threadsMutex = None
    mainThread = None

    @staticmethod
    def current():
        sys_thread__Thread_HxThread.threadsMutex.lock.acquire(True)
        ct = threading.current_thread()
        if (ct == threading.main_thread()):
            sys_thread__Thread_HxThread.threadsMutex.lock.release()
            return sys_thread__Thread_HxThread.mainThread
        if (not (ct in sys_thread__Thread_HxThread.threads.h)):
            sys_thread__Thread_HxThread.threads.set(ct,sys_thread__Thread_HxThread(ct))
        t = sys_thread__Thread_HxThread.threads.h.get(ct,None)
        sys_thread__Thread_HxThread.threadsMutex.lock.release()
        return t

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.events = None
        _hx_o.nativeThread = None
sys_thread__Thread_HxThread._hx_class = sys_thread__Thread_HxThread
_hx_classes["sys.thread._Thread.HxThread"] = sys_thread__Thread_HxThread


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run():
        pass
haxe_EntryPoint._hx_class = haxe_EntryPoint
_hx_classes["haxe.EntryPoint"] = haxe_EntryPoint


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    _hx_is_interface = "False"
    __slots__ = ("_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "toString", "get_message", "get_native"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def toString(self):
        return self.get_message()

    def get_message(self):
        return str(self)

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___nativeStack = None
        _hx_o._hx___skipStack = None
        _hx_o._hx___nativeException = None
        _hx_o._hx___previousException = None
haxe_Exception._hx_class = haxe_Exception
_hx_classes["haxe.Exception"] = haxe_Exception


class haxe__Int64____Int64:
    _hx_class_name = "haxe._Int64.___Int64"
    _hx_is_interface = "False"
    __slots__ = ("high", "low")
    _hx_fields = ["high", "low"]

    def __init__(self,high,low):
        self.high = high
        self.low = low

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.high = None
        _hx_o.low = None
haxe__Int64____Int64._hx_class = haxe__Int64____Int64
_hx_classes["haxe._Int64.___Int64"] = haxe__Int64____Int64


class haxe_Log:
    _hx_class_name = "haxe.Log"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        _hx_str = Std.string(v)
        if (infos is None):
            return _hx_str
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        if (Reflect.field(infos,"customParams") is not None):
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v))))
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        _hx_str = haxe_Log.formatOutput(v,infos)
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
haxe_Log._hx_class = haxe_Log
_hx_classes["haxe.Log"] = haxe_Log


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    _hx_is_interface = "False"
    __slots__ = ("f", "prev", "next", "isBlocking", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "isBlocking", "nextRun", "priority"]
    _hx_methods = ["stop"]

    def __init__(self,f,p):
        self.next = None
        self.prev = None
        self.isBlocking = True
        self.f = f
        self.priority = p
        self.nextRun = Math.NEGATIVE_INFINITY

    def stop(self):
        if (self.f is None):
            return
        self.f = None
        self.nextRun = Math.NEGATIVE_INFINITY
        if (self.prev is None):
            haxe_MainLoop.pending = self.next
        else:
            self.prev.next = self.next
        if (self.next is not None):
            self.next.prev = self.prev

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
        _hx_o.prev = None
        _hx_o.next = None
        _hx_o.isBlocking = None
        _hx_o.nextRun = None
        _hx_o.priority = None
haxe_MainEvent._hx_class = haxe_MainEvent
_hx_classes["haxe.MainEvent"] = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["eventLoopHandler", "mutex", "mainThread", "pending", "hasEvents", "add", "injectIntoEventLoop", "sortEvents", "tick"]
    eventLoopHandler = None
    pending = None

    @staticmethod
    def hasEvents():
        p = haxe_MainLoop.pending
        while (p is not None):
            if p.isBlocking:
                return True
            p = p.next
        return False

    @staticmethod
    def add(f,priority = None):
        if (priority is None):
            priority = 0
        if (f is None):
            raise haxe_Exception.thrown("Event function is null")
        e = haxe_MainEvent(f,priority)
        head = haxe_MainLoop.pending
        if (head is not None):
            head.prev = e
        e.next = head
        haxe_MainLoop.pending = e
        haxe_MainLoop.injectIntoEventLoop(0)
        return e

    @staticmethod
    def injectIntoEventLoop(waitMs):
        haxe_MainLoop.mutex.lock.acquire(True)
        if (haxe_MainLoop.eventLoopHandler is not None):
            sys_thread__Thread_Thread_Impl_.get_events(haxe_MainLoop.mainThread).cancel(haxe_MainLoop.eventLoopHandler)
        def _hx_local_0():
            wait = haxe_MainLoop.tick()
            if haxe_MainLoop.hasEvents():
                tmp = None
                try:
                    tmp = int((wait * 1000))
                except BaseException as _g:
                    None
                    tmp = None
                haxe_MainLoop.injectIntoEventLoop(tmp)
        haxe_MainLoop.eventLoopHandler = sys_thread__Thread_Thread_Impl_.get_events(haxe_MainLoop.mainThread).repeat(_hx_local_0,waitMs)
        haxe_MainLoop.mutex.lock.release()

    @staticmethod
    def sortEvents():
        _hx_list = haxe_MainLoop.pending
        if (_hx_list is None):
            return
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        p = None
        q = None
        e = None
        tail = None
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            nmerges = 0
            while (p is not None):
                nmerges = (nmerges + 1)
                q = p
                psize = 0
                _g = 0
                _g1 = insize
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    psize = (psize + 1)
                    q = q.next
                    if (q is None):
                        break
                qsize = insize
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    if (psize == 0):
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        e = p
                        p = p.next
                        psize = (psize - 1)
                    else:
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    e.prev = tail
                    tail = e
                p = q
            tail.next = None
            if (nmerges <= 1):
                break
            insize = (insize * 2)
        _hx_list.prev = None
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        haxe_MainLoop.sortEvents()
        e = haxe_MainLoop.pending
        now = python_lib_Timeit.default_timer()
        wait = 1e9
        while (e is not None):
            next = e.next
            wt = (e.nextRun - now)
            if (wt <= 0):
                wait = 0
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            e = next
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop
_hx_classes["haxe.MainLoop"] = haxe_MainLoop


class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []
haxe_NativeStackTrace._hx_class = haxe_NativeStackTrace
_hx_classes["haxe.NativeStackTrace"] = haxe_NativeStackTrace


class haxe_Serializer:
    _hx_class_name = "haxe.Serializer"
    _hx_is_interface = "False"
    __slots__ = ("buf", "cache", "shash", "scount", "useCache", "useEnumIndex")
    _hx_fields = ["buf", "cache", "shash", "scount", "useCache", "useEnumIndex"]
    _hx_methods = ["toString", "serializeString", "serializeRef", "serializeFields", "serialize"]
    _hx_statics = ["USE_CACHE", "USE_ENUM_INDEX", "BASE64", "BASE64_CODES", "run"]

    def __init__(self):
        self.buf = StringBuf()
        self.cache = list()
        self.useCache = haxe_Serializer.USE_CACHE
        self.useEnumIndex = haxe_Serializer.USE_ENUM_INDEX
        self.shash = haxe_ds_StringMap()
        self.scount = 0

    def toString(self):
        return self.buf.b.getvalue()

    def serializeString(self,s):
        x = self.shash.h.get(s,None)
        if (x is not None):
            self.buf.b.write("R")
            _this = self.buf
            s1 = Std.string(x)
            _this.b.write(s1)
            return
        value = self.scount
        self.scount = (self.scount + 1)
        self.shash.h[s] = value
        self.buf.b.write("y")
        s = python_lib_urllib_Parse.quote(s,"")
        _this = self.buf
        s1 = Std.string(len(s))
        _this.b.write(s1)
        self.buf.b.write(":")
        _this = self.buf
        s1 = Std.string(s)
        _this.b.write(s1)

    def serializeRef(self,v):
        _g = 0
        _g1 = len(self.cache)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq((self.cache[i] if i >= 0 and i < len(self.cache) else None),v):
                self.buf.b.write("r")
                _this = self.buf
                s = Std.string(i)
                _this.b.write(s)
                return True
        _this = self.cache
        _this.append(v)
        return False

    def serializeFields(self,v):
        _g = 0
        _g1 = python_Boot.fields(v)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.serializeString(f)
            self.serialize(Reflect.field(v,f))
        self.buf.b.write("g")

    def serialize(self,v):
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 0):
            self.buf.b.write("n")
        elif (tmp == 1):
            v1 = v
            if (v1 == 0):
                self.buf.b.write("z")
                return
            self.buf.b.write("i")
            _this = self.buf
            s = Std.string(v1)
            _this.b.write(s)
        elif (tmp == 2):
            v1 = v
            if python_lib_Math.isnan(v1):
                self.buf.b.write("k")
            elif (not ((((v1 != Math.POSITIVE_INFINITY) and ((v1 != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(v1))))):
                self.buf.b.write(("m" if ((v1 < 0)) else "p"))
            else:
                self.buf.b.write("d")
                _this = self.buf
                s = Std.string(v1)
                _this.b.write(s)
        elif (tmp == 3):
            self.buf.b.write(("t" if v else "f"))
        elif (tmp == 4):
            if Std.isOfType(v,Class):
                className = Type.getClassName(v)
                self.buf.b.write("A")
                self.serializeString(className)
            elif Std.isOfType(v,Enum):
                self.buf.b.write("B")
                self.serializeString(Type.getEnumName(v))
            else:
                if (self.useCache and self.serializeRef(v)):
                    return
                self.buf.b.write("o")
                self.serializeFields(v)
        elif (tmp == 5):
            raise haxe_Exception.thrown("Cannot serialize function")
        elif (tmp == 6):
            c = _g.params[0]
            if (c == str):
                self.serializeString(v)
                return
            if (self.useCache and self.serializeRef(v)):
                return
            _g1 = Type.getClassName(c)
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 17):
                if (_g1 == "haxe.ds.ObjectMap"):
                    self.buf.b.write("M")
                    v1 = v
                    k = v1.keys()
                    while k.hasNext():
                        k1 = k.next()
                        self.serialize(k1)
                        self.serialize(v1.h.get(k1,None))
                    self.buf.b.write("h")
                elif (_g1 == "haxe.ds.StringMap"):
                    self.buf.b.write("b")
                    v1 = v
                    k = v1.keys()
                    while k.hasNext():
                        k1 = k.next()
                        self.serializeString(k1)
                        self.serialize(v1.h.get(k1,None))
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this = self.cache
                        if (len(_this) != 0):
                            _this.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 5):
                if (_g1 == "Array"):
                    ucount = 0
                    self.buf.b.write("a")
                    v1 = v
                    l = len(v1)
                    _g1 = 0
                    _g2 = l
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        if ((v1[i] if i >= 0 and i < len(v1) else None) is None):
                            ucount = (ucount + 1)
                        else:
                            if (ucount > 0):
                                if (ucount == 1):
                                    self.buf.b.write("n")
                                else:
                                    self.buf.b.write("u")
                                    _this = self.buf
                                    s = Std.string(ucount)
                                    _this.b.write(s)
                                ucount = 0
                            self.serialize((v1[i] if i >= 0 and i < len(v1) else None))
                    if (ucount > 0):
                        if (ucount == 1):
                            self.buf.b.write("n")
                        else:
                            self.buf.b.write("u")
                            _this = self.buf
                            s = Std.string(ucount)
                            _this.b.write(s)
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this = self.cache
                        if (len(_this) != 0):
                            _this.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 4):
                if (_g1 == "Date"):
                    d = v
                    self.buf.b.write("v")
                    _this = self.buf
                    s = Std.string((d.date.timestamp() * 1000))
                    _this.b.write(s)
                else:
                    if self.useCache:
                        _this = self.cache
                        if (len(_this) != 0):
                            _this.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 12):
                if (_g1 == "haxe.ds.List"):
                    self.buf.b.write("l")
                    v1 = v
                    _g_head = v1.h
                    while (_g_head is not None):
                        val = _g_head.item
                        _g_head = _g_head.next
                        i = val
                        self.serialize(i)
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this = self.cache
                        if (len(_this) != 0):
                            _this.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 13):
                if (_g1 == "haxe.io.Bytes"):
                    v1 = v
                    self.buf.b.write("s")
                    _this = self.buf
                    s = Std.string(Math.ceil(((v1.length * 8) / 6)))
                    _this.b.write(s)
                    self.buf.b.write(":")
                    i = 0
                    _hx_max = (v1.length - 2)
                    b64 = haxe_Serializer.BASE64_CODES
                    if (b64 is None):
                        this1 = [None]*len(haxe_Serializer.BASE64)
                        b64 = this1
                        _g1 = 0
                        _g2 = len(haxe_Serializer.BASE64)
                        while (_g1 < _g2):
                            i1 = _g1
                            _g1 = (_g1 + 1)
                            val = HxString.charCodeAt(haxe_Serializer.BASE64,i1)
                            b64[i1] = val
                        haxe_Serializer.BASE64_CODES = b64
                    while (i < _hx_max):
                        pos = i
                        i = (i + 1)
                        b1 = v1.b[pos]
                        pos1 = i
                        i = (i + 1)
                        b2 = v1.b[pos1]
                        pos2 = i
                        i = (i + 1)
                        b3 = v1.b[pos2]
                        _this = self.buf
                        c1 = b64[(b1 >> 2)]
                        s = "".join(map(chr,[c1]))
                        _this.b.write(s)
                        _this1 = self.buf
                        c2 = b64[((((b1 << 4) | ((b2 >> 4)))) & 63)]
                        s1 = "".join(map(chr,[c2]))
                        _this1.b.write(s1)
                        _this2 = self.buf
                        c3 = b64[((((b2 << 2) | ((b3 >> 6)))) & 63)]
                        s2 = "".join(map(chr,[c3]))
                        _this2.b.write(s2)
                        _this3 = self.buf
                        c4 = b64[(b3 & 63)]
                        s3 = "".join(map(chr,[c4]))
                        _this3.b.write(s3)
                    if (i == _hx_max):
                        pos = i
                        i = (i + 1)
                        b1 = v1.b[pos]
                        pos = i
                        i = (i + 1)
                        b2 = v1.b[pos]
                        _this = self.buf
                        c1 = b64[(b1 >> 2)]
                        s = "".join(map(chr,[c1]))
                        _this.b.write(s)
                        _this = self.buf
                        c1 = b64[((((b1 << 4) | ((b2 >> 4)))) & 63)]
                        s = "".join(map(chr,[c1]))
                        _this.b.write(s)
                        _this = self.buf
                        c1 = b64[((b2 << 2) & 63)]
                        s = "".join(map(chr,[c1]))
                        _this.b.write(s)
                    elif (i == ((_hx_max + 1))):
                        pos = i
                        i = (i + 1)
                        b1 = v1.b[pos]
                        _this = self.buf
                        c1 = b64[(b1 >> 2)]
                        s = "".join(map(chr,[c1]))
                        _this.b.write(s)
                        _this = self.buf
                        c1 = b64[((b1 << 4) & 63)]
                        s = "".join(map(chr,[c1]))
                        _this.b.write(s)
                else:
                    if self.useCache:
                        _this = self.cache
                        if (len(_this) != 0):
                            _this.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 14):
                if (_g1 == "haxe.ds.IntMap"):
                    self.buf.b.write("q")
                    v1 = v
                    k = v1.keys()
                    while k.hasNext():
                        k1 = k.next()
                        self.buf.b.write(":")
                        _this = self.buf
                        s = Std.string(k1)
                        _this.b.write(s)
                        self.serialize(v1.h.get(k1,None))
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this = self.cache
                        if (len(_this) != 0):
                            _this.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        self.serializeFields(v)
            else:
                if self.useCache:
                    _this = self.cache
                    if (len(_this) != 0):
                        _this.pop()
                if python_Boot.hasField(v,"hxSerialize"):
                    self.buf.b.write("C")
                    self.serializeString(Type.getClassName(c))
                    if self.useCache:
                        _this = self.cache
                        _this.append(v)
                    Reflect.field(v,"hxSerialize")(self)
                    self.buf.b.write("g")
                else:
                    self.buf.b.write("c")
                    self.serializeString(Type.getClassName(c))
                    if self.useCache:
                        _this = self.cache
                        _this.append(v)
                    self.serializeFields(v)
        elif (tmp == 7):
            e = _g.params[0]
            if self.useCache:
                if self.serializeRef(v):
                    return
                _this = self.cache
                if (len(_this) != 0):
                    _this.pop()
            _this = self.buf
            s = Std.string(("j" if (self.useEnumIndex) else "w"))
            _this.b.write(s)
            self.serializeString(Type.getEnumName(e))
            if self.useEnumIndex:
                self.buf.b.write(":")
                _this = self.buf
                s = Std.string(v.index)
                _this.b.write(s)
            else:
                self.serializeString(v.tag)
            self.buf.b.write(":")
            arr = list(v.params)
            if (arr is not None):
                _this = self.buf
                s = Std.string(len(arr))
                _this.b.write(s)
                _g = 0
                while (_g < len(arr)):
                    v1 = (arr[_g] if _g >= 0 and _g < len(arr) else None)
                    _g = (_g + 1)
                    self.serialize(v1)
            else:
                self.buf.b.write("0")
            if self.useCache:
                _this = self.cache
                _this.append(v)
        else:
            raise haxe_Exception.thrown(("Cannot serialize " + Std.string(v)))

    @staticmethod
    def run(v):
        s = haxe_Serializer()
        s.serialize(v)
        return s.toString()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.cache = None
        _hx_o.shash = None
        _hx_o.scount = None
        _hx_o.useCache = None
        _hx_o.useEnumIndex = None
haxe_Serializer._hx_class = haxe_Serializer
_hx_classes["haxe.Serializer"] = haxe_Serializer


class haxe_Timer:
    _hx_class_name = "haxe.Timer"
    _hx_is_interface = "False"
    _hx_fields = ["thread", "eventHandler"]
    _hx_methods = ["stop", "run"]
    _hx_statics = ["delay"]

    def __init__(self,time_ms):
        self.eventHandler = None
        self.thread = None
        _gthis = self
        self.thread = sys_thread__Thread_HxThread.current()
        def _hx_local_0():
            _gthis.run()
        self.eventHandler = sys_thread__Thread_Thread_Impl_.get_events(self.thread).repeat(_hx_local_0,time_ms)

    def stop(self):
        sys_thread__Thread_Thread_Impl_.get_events(self.thread).cancel(self.eventHandler)

    def run(self):
        pass

    @staticmethod
    def delay(f,time_ms):
        t = haxe_Timer(time_ms)
        def _hx_local_0():
            t.stop()
            f()
        t.run = _hx_local_0
        return t

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.thread = None
        _hx_o.eventHandler = None
haxe_Timer._hx_class = haxe_Timer
_hx_classes["haxe.Timer"] = haxe_Timer


class haxe__Unserializer_DefaultResolver:
    _hx_class_name = "haxe._Unserializer.DefaultResolver"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["resolveClass", "resolveEnum"]

    def __init__(self):
        pass

    def resolveClass(self,name):
        return Type.resolveClass(name)

    def resolveEnum(self,name):
        return Type.resolveEnum(name)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe__Unserializer_DefaultResolver._hx_class = haxe__Unserializer_DefaultResolver
_hx_classes["haxe._Unserializer.DefaultResolver"] = haxe__Unserializer_DefaultResolver


class haxe_Unserializer:
    _hx_class_name = "haxe.Unserializer"
    _hx_is_interface = "False"
    __slots__ = ("buf", "pos", "length", "cache", "scache", "resolver")
    _hx_fields = ["buf", "pos", "length", "cache", "scache", "resolver"]
    _hx_methods = ["readDigits", "readFloat", "unserializeObject", "unserializeEnum", "unserialize"]
    _hx_statics = ["DEFAULT_RESOLVER", "BASE64", "CODES", "initCodes", "run"]

    def __init__(self,buf):
        self.resolver = None
        self.scache = None
        self.cache = None
        self.length = None
        self.pos = None
        self.buf = buf
        self.length = len(self.buf)
        self.pos = 0
        self.scache = list()
        self.cache = list()
        r = haxe_Unserializer.DEFAULT_RESOLVER
        if (r is None):
            r = haxe__Unserializer_DefaultResolver()
            haxe_Unserializer.DEFAULT_RESOLVER = r
        self.resolver = r

    def readDigits(self):
        k = 0
        s = False
        fpos = self.pos
        while True:
            p = self.pos
            s1 = self.buf
            c = (-1 if ((p >= len(s1))) else ord(s1[p]))
            if (c == -1):
                break
            if (c == 45):
                if (self.pos != fpos):
                    break
                s = True
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                _hx_local_1
                continue
            if ((c < 48) or ((c > 57))):
                break
            k = ((k * 10) + ((c - 48)))
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 1)
            _hx_local_3
        if s:
            k = (k * -1)
        return k

    def readFloat(self):
        p1 = self.pos
        while True:
            p = self.pos
            s = self.buf
            c = (-1 if ((p >= len(s))) else ord(s[p]))
            if (c == -1):
                break
            if ((((c >= 43) and ((c < 58))) or ((c == 101))) or ((c == 69))):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                _hx_local_1
            else:
                break
        return Std.parseFloat(HxString.substr(self.buf,p1,(self.pos - p1)))

    def unserializeObject(self,o):
        while True:
            if (self.pos >= self.length):
                raise haxe_Exception.thrown("Invalid object")
            p = self.pos
            s = self.buf
            if (((-1 if ((p >= len(s))) else ord(s[p]))) == 103):
                break
            k = self.unserialize()
            if (not Std.isOfType(k,str)):
                raise haxe_Exception.thrown("Invalid object key")
            v = self.unserialize()
            field = k
            setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 1)
        _hx_local_1

    def unserializeEnum(self,edecl,tag):
        p = self.pos
        self.pos = (self.pos + 1)
        s = self.buf
        if (((-1 if ((p >= len(s))) else ord(s[p]))) != 58):
            raise haxe_Exception.thrown("Invalid enum format")
        nargs = self.readDigits()
        if (nargs == 0):
            return Type.createEnum(edecl,tag)
        args = list()
        while True:
            tmp = nargs
            nargs = (nargs - 1)
            if (not ((tmp > 0))):
                break
            x = self.unserialize()
            args.append(x)
        return Type.createEnum(edecl,tag,args)

    def unserialize(self):
        p = self.pos
        self.pos = (self.pos + 1)
        s = self.buf
        _g = (-1 if ((p >= len(s))) else ord(s[p]))
        if (_g == 65):
            name = self.unserialize()
            cl = self.resolver.resolveClass(name)
            if (cl is None):
                raise haxe_Exception.thrown(("Class not found " + ("null" if name is None else name)))
            return cl
        elif (_g == 66):
            name = self.unserialize()
            e = self.resolver.resolveEnum(name)
            if (e is None):
                raise haxe_Exception.thrown(("Enum not found " + ("null" if name is None else name)))
            return e
        elif (_g == 67):
            name = self.unserialize()
            cl = self.resolver.resolveClass(name)
            if (cl is None):
                raise haxe_Exception.thrown(("Class not found " + ("null" if name is None else name)))
            o = Type.createEmptyInstance(cl)
            _this = self.cache
            _this.append(o)
            Reflect.field(o,"hxUnserialize")(self)
            p = self.pos
            self.pos = (self.pos + 1)
            s = self.buf
            if (((-1 if ((p >= len(s))) else ord(s[p]))) != 103):
                raise haxe_Exception.thrown("Invalid custom data")
            return o
        elif (_g == 77):
            h = haxe_ds_ObjectMap()
            _this = self.cache
            _this.append(h)
            buf = self.buf
            while True:
                p = self.pos
                s = self.buf
                if (not ((((-1 if ((p >= len(s))) else ord(s[p]))) != 104))):
                    break
                s1 = self.unserialize()
                h.set(s1,self.unserialize())
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 1)
            _hx_local_1
            return h
        elif (_g == 82):
            n = self.readDigits()
            if ((n < 0) or ((n >= len(self.scache)))):
                raise haxe_Exception.thrown("Invalid string reference")
            return (self.scache[n] if n >= 0 and n < len(self.scache) else None)
        elif (_g == 97):
            buf = self.buf
            a = list()
            _this = self.cache
            _this.append(a)
            while True:
                p = self.pos
                s = self.buf
                c = (-1 if ((p >= len(s))) else ord(s[p]))
                if (c == 104):
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2.pos
                    _hx_local_2.pos = (_hx_local_3 + 1)
                    _hx_local_3
                    break
                if (c == 117):
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.pos
                    _hx_local_4.pos = (_hx_local_5 + 1)
                    _hx_local_5
                    n = self.readDigits()
                    python_internal_ArrayImpl._set(a, ((len(a) + n) - 1), None)
                else:
                    x = self.unserialize()
                    a.append(x)
            return a
        elif (_g == 98):
            h = haxe_ds_StringMap()
            _this = self.cache
            _this.append(h)
            buf = self.buf
            while True:
                p = self.pos
                s = self.buf
                if (not ((((-1 if ((p >= len(s))) else ord(s[p]))) != 104))):
                    break
                s1 = self.unserialize()
                value = self.unserialize()
                h.h[s1] = value
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 1)
            _hx_local_7
            return h
        elif (_g == 99):
            name = self.unserialize()
            cl = self.resolver.resolveClass(name)
            if (cl is None):
                raise haxe_Exception.thrown(("Class not found " + ("null" if name is None else name)))
            o = Type.createEmptyInstance(cl)
            _this = self.cache
            _this.append(o)
            self.unserializeObject(o)
            return o
        elif (_g == 100):
            return self.readFloat()
        elif (_g == 102):
            return False
        elif (_g == 105):
            return self.readDigits()
        elif (_g == 106):
            name = self.unserialize()
            edecl = self.resolver.resolveEnum(name)
            if (edecl is None):
                raise haxe_Exception.thrown(("Enum not found " + ("null" if name is None else name)))
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.pos
            _hx_local_8.pos = (_hx_local_9 + 1)
            _hx_local_9
            index = self.readDigits()
            tag = python_internal_ArrayImpl._get(Type.getEnumConstructs(edecl), index)
            if (tag is None):
                raise haxe_Exception.thrown(((("Unknown enum index " + ("null" if name is None else name)) + "@") + Std.string(index)))
            e = self.unserializeEnum(edecl,tag)
            _this = self.cache
            _this.append(e)
            return e
        elif (_g == 107):
            return Math.NaN
        elif (_g == 108):
            l = haxe_ds_List()
            _this = self.cache
            _this.append(l)
            buf = self.buf
            while True:
                p = self.pos
                s = self.buf
                if (not ((((-1 if ((p >= len(s))) else ord(s[p]))) != 104))):
                    break
                l.add(self.unserialize())
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.pos
            _hx_local_10.pos = (_hx_local_11 + 1)
            _hx_local_11
            return l
        elif (_g == 109):
            return Math.NEGATIVE_INFINITY
        elif (_g == 110):
            return None
        elif (_g == 111):
            o = _hx_AnonObject({})
            _this = self.cache
            _this.append(o)
            self.unserializeObject(o)
            return o
        elif (_g == 112):
            return Math.POSITIVE_INFINITY
        elif (_g == 113):
            h = haxe_ds_IntMap()
            _this = self.cache
            _this.append(h)
            buf = self.buf
            p = self.pos
            self.pos = (self.pos + 1)
            s = self.buf
            c = (-1 if ((p >= len(s))) else ord(s[p]))
            while (c == 58):
                i = self.readDigits()
                h.set(i,self.unserialize())
                p = self.pos
                self.pos = (self.pos + 1)
                s = self.buf
                c = (-1 if ((p >= len(s))) else ord(s[p]))
            if (c != 104):
                raise haxe_Exception.thrown("Invalid IntMap format")
            return h
        elif (_g == 114):
            n = self.readDigits()
            if ((n < 0) or ((n >= len(self.cache)))):
                raise haxe_Exception.thrown("Invalid reference")
            return (self.cache[n] if n >= 0 and n < len(self.cache) else None)
        elif (_g == 115):
            _hx_len = self.readDigits()
            buf = self.buf
            p = self.pos
            self.pos = (self.pos + 1)
            s = self.buf
            if ((((-1 if ((p >= len(s))) else ord(s[p]))) != 58) or (((self.length - self.pos) < _hx_len))):
                raise haxe_Exception.thrown("Invalid bytes length")
            codes = haxe_Unserializer.CODES
            if (codes is None):
                codes = haxe_Unserializer.initCodes()
                haxe_Unserializer.CODES = codes
            i = self.pos
            rest = (_hx_len & 3)
            size = ((((_hx_len >> 2)) * 3) + (((rest - 1) if ((rest >= 2)) else 0)))
            _hx_max = (i + ((_hx_len - rest)))
            _hx_bytes = haxe_io_Bytes.alloc(size)
            bpos = 0
            while (i < _hx_max):
                index = i
                i = (i + 1)
                c1 = python_internal_ArrayImpl._get(codes, (-1 if ((index >= len(buf))) else ord(buf[index])))
                index1 = i
                i = (i + 1)
                c2 = python_internal_ArrayImpl._get(codes, (-1 if ((index1 >= len(buf))) else ord(buf[index1])))
                pos = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos] = ((((c1 << 2) | ((c2 >> 4)))) & 255)
                index2 = i
                i = (i + 1)
                c3 = python_internal_ArrayImpl._get(codes, (-1 if ((index2 >= len(buf))) else ord(buf[index2])))
                pos1 = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos1] = ((((c2 << 4) | ((c3 >> 2)))) & 255)
                index3 = i
                i = (i + 1)
                c4 = python_internal_ArrayImpl._get(codes, (-1 if ((index3 >= len(buf))) else ord(buf[index3])))
                pos2 = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos2] = ((((c3 << 6) | c4)) & 255)
            if (rest >= 2):
                index = i
                i = (i + 1)
                c1 = python_internal_ArrayImpl._get(codes, (-1 if ((index >= len(buf))) else ord(buf[index])))
                index = i
                i = (i + 1)
                c2 = python_internal_ArrayImpl._get(codes, (-1 if ((index >= len(buf))) else ord(buf[index])))
                pos = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos] = ((((c1 << 2) | ((c2 >> 4)))) & 255)
                if (rest == 3):
                    index = i
                    i = (i + 1)
                    c3 = python_internal_ArrayImpl._get(codes, (-1 if ((index >= len(buf))) else ord(buf[index])))
                    pos = bpos
                    bpos = (bpos + 1)
                    _hx_bytes.b[pos] = ((((c2 << 4) | ((c3 >> 2)))) & 255)
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + _hx_len)
            _hx_local_12.pos
            _this = self.cache
            _this.append(_hx_bytes)
            return _hx_bytes
        elif (_g == 116):
            return True
        elif (_g == 118):
            d = None
            tmp = None
            tmp1 = None
            tmp2 = None
            tmp3 = None
            tmp4 = None
            tmp5 = None
            tmp6 = None
            tmp7 = None
            p = self.pos
            s = self.buf
            if (((-1 if ((p >= len(s))) else ord(s[p]))) >= 48):
                p = self.pos
                s = self.buf
                tmp7 = (((-1 if ((p >= len(s))) else ord(s[p]))) <= 57)
            else:
                tmp7 = False
            if tmp7:
                p = (self.pos + 1)
                s = self.buf
                tmp6 = (((-1 if ((p >= len(s))) else ord(s[p]))) >= 48)
            else:
                tmp6 = False
            if tmp6:
                p = (self.pos + 1)
                s = self.buf
                tmp5 = (((-1 if ((p >= len(s))) else ord(s[p]))) <= 57)
            else:
                tmp5 = False
            if tmp5:
                p = (self.pos + 2)
                s = self.buf
                tmp4 = (((-1 if ((p >= len(s))) else ord(s[p]))) >= 48)
            else:
                tmp4 = False
            if tmp4:
                p = (self.pos + 2)
                s = self.buf
                tmp3 = (((-1 if ((p >= len(s))) else ord(s[p]))) <= 57)
            else:
                tmp3 = False
            if tmp3:
                p = (self.pos + 3)
                s = self.buf
                tmp2 = (((-1 if ((p >= len(s))) else ord(s[p]))) >= 48)
            else:
                tmp2 = False
            if tmp2:
                p = (self.pos + 3)
                s = self.buf
                tmp1 = (((-1 if ((p >= len(s))) else ord(s[p]))) <= 57)
            else:
                tmp1 = False
            if tmp1:
                p = (self.pos + 4)
                s = self.buf
                tmp = (((-1 if ((p >= len(s))) else ord(s[p]))) == 45)
            else:
                tmp = False
            if tmp:
                d = Date.fromString(HxString.substr(self.buf,self.pos,19))
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.pos
                _hx_local_14.pos = (_hx_local_15 + 19)
                _hx_local_14.pos
            else:
                d = Date.fromTime(self.readFloat())
            _this = self.cache
            _this.append(d)
            return d
        elif (_g == 119):
            name = self.unserialize()
            edecl = self.resolver.resolveEnum(name)
            if (edecl is None):
                raise haxe_Exception.thrown(("Enum not found " + ("null" if name is None else name)))
            e = self.unserializeEnum(edecl,self.unserialize())
            _this = self.cache
            _this.append(e)
            return e
        elif (_g == 120):
            raise haxe_Exception.thrown(self.unserialize())
        elif (_g == 121):
            _hx_len = self.readDigits()
            p = self.pos
            self.pos = (self.pos + 1)
            s = self.buf
            if ((((-1 if ((p >= len(s))) else ord(s[p]))) != 58) or (((self.length - self.pos) < _hx_len))):
                raise haxe_Exception.thrown("Invalid string length")
            s = HxString.substr(self.buf,self.pos,_hx_len)
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.pos
            _hx_local_16.pos = (_hx_local_17 + _hx_len)
            _hx_local_16.pos
            s = python_lib_urllib_Parse.unquote(s)
            _this = self.scache
            _this.append(s)
            return s
        elif (_g == 122):
            return 0
        else:
            pass
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18.pos
        _hx_local_18.pos = (_hx_local_19 - 1)
        _hx_local_19
        s = self.buf
        pos = self.pos
        raise haxe_Exception.thrown(((("Invalid char " + HxOverrides.stringOrNull((("" if (((pos < 0) or ((pos >= len(s))))) else s[pos])))) + " at position ") + Std.string(self.pos)))

    @staticmethod
    def initCodes():
        codes = list()
        _g = 0
        _g1 = len(haxe_Unserializer.BASE64)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            s = haxe_Unserializer.BASE64
            python_internal_ArrayImpl._set(codes, (-1 if ((i >= len(s))) else ord(s[i])), i)
        return codes

    @staticmethod
    def run(v):
        return haxe_Unserializer(v).unserialize()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.pos = None
        _hx_o.length = None
        _hx_o.cache = None
        _hx_o.scache = None
        _hx_o.resolver = None
haxe_Unserializer._hx_class = haxe_Unserializer
_hx_classes["haxe.Unserializer"] = haxe_Unserializer


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(Std.string(value),previous,native)
        self.value = value

    def unwrap(self):
        return self.value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
haxe_ValueException._hx_class = haxe_ValueException
_hx_classes["haxe.ValueException"] = haxe_ValueException


class haxe_crypto_Adler32:
    _hx_class_name = "haxe.crypto.Adler32"
    _hx_is_interface = "False"
    __slots__ = ("a1", "a2")
    _hx_fields = ["a1", "a2"]
    _hx_methods = ["update", "equals"]
    _hx_statics = ["read"]

    def __init__(self):
        self.a1 = 1
        self.a2 = 0

    def update(self,b,pos,_hx_len):
        a1 = self.a1
        a2 = self.a2
        _g = pos
        _g1 = (pos + _hx_len)
        while (_g < _g1):
            p = _g
            _g = (_g + 1)
            c = b.b[p]
            a1 = HxOverrides.mod(((a1 + c)), 65521)
            a2 = HxOverrides.mod(((a2 + a1)), 65521)
        self.a1 = a1
        self.a2 = a2

    def equals(self,a):
        if (a.a1 == self.a1):
            return (a.a2 == self.a2)
        else:
            return False

    @staticmethod
    def read(i):
        a = haxe_crypto_Adler32()
        a2a = i.readByte()
        a2b = i.readByte()
        a1a = i.readByte()
        a1b = i.readByte()
        a.a1 = ((a1a << 8) | a1b)
        a.a2 = ((a2a << 8) | a2b)
        return a

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a1 = None
        _hx_o.a2 = None
haxe_crypto_Adler32._hx_class = haxe_crypto_Adler32
_hx_classes["haxe.crypto.Adler32"] = haxe_crypto_Adler32


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    _hx_is_interface = "False"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["blit", "fill", "sub", "getDouble", "getFloat", "setFloat", "getString", "toString", "toHex"]
    _hx_statics = ["alloc", "ofString", "ofData"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def blit(self,pos,src,srcpos,_hx_len):
        if (((((pos < 0) or ((srcpos < 0))) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))) or (((srcpos + _hx_len) > src.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        self.b[pos:pos+_hx_len] = src.b[srcpos:srcpos+_hx_len]

    def fill(self,pos,_hx_len,value):
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos1 = pos
            pos = (pos + 1)
            self.b[pos1] = (value & 255)

    def sub(self,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return haxe_io_Bytes(_hx_len,self.b[pos:(pos + _hx_len)])

    def getDouble(self,pos):
        v = (((self.b[pos] | ((self.b[(pos + 1)] << 8))) | ((self.b[(pos + 2)] << 16))) | ((self.b[(pos + 3)] << 24)))
        pos1 = (pos + 4)
        v1 = (((self.b[pos1] | ((self.b[(pos1 + 1)] << 8))) | ((self.b[(pos1 + 2)] << 16))) | ((self.b[(pos1 + 3)] << 24)))
        return haxe_io_FPHelper.i64ToDouble(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1))

    def getFloat(self,pos):
        v = (((self.b[pos] | ((self.b[(pos + 1)] << 8))) | ((self.b[(pos + 2)] << 16))) | ((self.b[(pos + 3)] << 24)))
        return haxe_io_FPHelper.i32ToFloat(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v))

    def setFloat(self,pos,v):
        v1 = haxe_io_FPHelper.floatToI32(v)
        self.b[pos] = (v1 & 255)
        self.b[(pos + 1)] = ((v1 >> 8) & 255)
        self.b[(pos + 2)] = ((v1 >> 16) & 255)
        self.b[(pos + 3)] = (HxOverrides.rshift(v1, 24) & 255)

    def getString(self,pos,_hx_len,encoding = None):
        tmp = (encoding is None)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)

    def toHex(self):
        s_b = python_lib_io_StringIO()
        chars = []
        _hx_str = "0123456789abcdef"
        _g = 0
        _g1 = len(_hx_str)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = HxString.charCodeAt(_hx_str,i)
            chars.append(x)
        _g = 0
        _g1 = self.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.b[i]
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c >> 4))])))
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c & 15))])))
        return s_b.getvalue()

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofData(b):
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.length = None
        _hx_o.b = None
haxe_io_Bytes._hx_class = haxe_io_Bytes
_hx_classes["haxe.io.Bytes"] = haxe_io_Bytes


class haxe_crypto_Base64:
    _hx_class_name = "haxe.crypto.Base64"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["CHARS", "BYTES", "encode", "decode"]

    @staticmethod
    def encode(_hx_bytes,complement = None):
        if (complement is None):
            complement = True
        _hx_str = haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(_hx_bytes).toString()
        if complement:
            _g = HxOverrides.mod(_hx_bytes.length, 3)
            if (_g == 1):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "==")
            elif (_g == 2):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "=")
            else:
                pass
        return _hx_str

    @staticmethod
    def decode(_hx_str,complement = None):
        if (complement is None):
            complement = True
        if complement:
            while (HxString.charCodeAt(_hx_str,(len(_hx_str) - 1)) == 61):
                _hx_str = HxString.substr(_hx_str,0,-1)
        return haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(_hx_str))
haxe_crypto_Base64._hx_class = haxe_crypto_Base64
_hx_classes["haxe.crypto.Base64"] = haxe_crypto_Base64


class haxe_crypto_BaseCode:
    _hx_class_name = "haxe.crypto.BaseCode"
    _hx_is_interface = "False"
    __slots__ = ("base", "nbits", "tbl")
    _hx_fields = ["base", "nbits", "tbl"]
    _hx_methods = ["encodeBytes", "initTable", "decodeBytes"]

    def __init__(self,base):
        self.tbl = None
        _hx_len = base.length
        nbits = 1
        while (_hx_len > ((1 << nbits))):
            nbits = (nbits + 1)
        if ((nbits > 8) or ((_hx_len != ((1 << nbits))))):
            raise haxe_Exception.thrown("BaseCode : base length must be a power of two.")
        self.base = base
        self.nbits = nbits

    def encodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        x = ((b.length * 8) / nbits)
        size = None
        try:
            size = int(x)
        except BaseException as _g:
            None
            size = None
        out = haxe_io_Bytes.alloc((size + ((0 if ((HxOverrides.mod((b.length * 8), nbits) == 0)) else 1))))
        buf = 0
        curbits = 0
        mask = (((1 << nbits)) - 1)
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < nbits):
                curbits = (curbits + 8)
                buf = (buf << 8)
                pos = pin
                pin = (pin + 1)
                buf = (buf | b.b[pos])
            curbits = (curbits - nbits)
            pos1 = pout
            pout = (pout + 1)
            v = base.b[((buf >> curbits) & mask)]
            out.b[pos1] = (v & 255)
        if (curbits > 0):
            pos = pout
            pout = (pout + 1)
            v = base.b[((buf << ((nbits - curbits))) & mask)]
            out.b[pos] = (v & 255)
        return out

    def initTable(self):
        tbl = list()
        _g = 0
        while (_g < 256):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(tbl, i, -1)
        _g = 0
        _g1 = self.base.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(tbl, self.base.b[i], i)
        self.tbl = tbl

    def decodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        if (self.tbl is None):
            self.initTable()
        tbl = self.tbl
        size = ((b.length * nbits) >> 3)
        out = haxe_io_Bytes.alloc(size)
        buf = 0
        curbits = 0
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < 8):
                curbits = (curbits + nbits)
                buf = (buf << nbits)
                pos = pin
                pin = (pin + 1)
                i = python_internal_ArrayImpl._get(tbl, b.b[pos])
                if (i == -1):
                    raise haxe_Exception.thrown("BaseCode : invalid encoded char")
                buf = (buf | i)
            curbits = (curbits - 8)
            pos1 = pout
            pout = (pout + 1)
            out.b[pos1] = (((buf >> curbits) & 255) & 255)
        return out

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.base = None
        _hx_o.nbits = None
        _hx_o.tbl = None
haxe_crypto_BaseCode._hx_class = haxe_crypto_BaseCode
_hx_classes["haxe.crypto.BaseCode"] = haxe_crypto_BaseCode


class haxe_crypto_Md5:
    _hx_class_name = "haxe.crypto.Md5"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["bitOR", "bitXOR", "bitAND", "addme", "hex", "rol", "cmn", "ff", "gg", "hh", "ii", "doEncode"]
    _hx_statics = ["encode", "str2blks"]

    def __init__(self):
        pass

    def bitOR(self,a,b):
        lsb = ((a & 1) | ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) | (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def bitXOR(self,a,b):
        lsb = ((a & 1) ^ ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) ^ (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def bitAND(self,a,b):
        lsb = ((a & 1) & ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) & (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def addme(self,x,y):
        lsw = (((x & 65535)) + ((y & 65535)))
        msw = ((((x >> 16)) + ((y >> 16))) + ((lsw >> 16)))
        return ((msw << 16) | ((lsw & 65535)))

    def hex(self,a):
        _hx_str = ""
        hex_chr = "0123456789abcdef"
        _g = 0
        while (_g < len(a)):
            num = (a[_g] if _g >= 0 and _g < len(a) else None)
            _g = (_g + 1)
            index = ((num >> 4) & 15)
            index1 = (num & 15)
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull((("" if (((index < 0) or ((index >= len(hex_chr))))) else hex_chr[index]))) + HxOverrides.stringOrNull((("" if (((index1 < 0) or ((index1 >= len(hex_chr))))) else hex_chr[index1])))))))
            index2 = ((num >> 12) & 15)
            index3 = ((num >> 8) & 15)
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull((("" if (((index2 < 0) or ((index2 >= len(hex_chr))))) else hex_chr[index2]))) + HxOverrides.stringOrNull((("" if (((index3 < 0) or ((index3 >= len(hex_chr))))) else hex_chr[index3])))))))
            index4 = ((num >> 20) & 15)
            index5 = ((num >> 16) & 15)
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull((("" if (((index4 < 0) or ((index4 >= len(hex_chr))))) else hex_chr[index4]))) + HxOverrides.stringOrNull((("" if (((index5 < 0) or ((index5 >= len(hex_chr))))) else hex_chr[index5])))))))
            index6 = ((num >> 28) & 15)
            index7 = ((num >> 24) & 15)
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull((("" if (((index6 < 0) or ((index6 >= len(hex_chr))))) else hex_chr[index6]))) + HxOverrides.stringOrNull((("" if (((index7 < 0) or ((index7 >= len(hex_chr))))) else hex_chr[index7])))))))
        return _hx_str

    def rol(self,num,cnt):
        return ((num << cnt) | (HxOverrides.rshift(num, ((32 - cnt)))))

    def cmn(self,q,a,b,x,s,t):
        return self.addme(self.rol(self.addme(self.addme(a,q),self.addme(x,t)),s),b)

    def ff(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitOR(self.bitAND(b,c),self.bitAND(~b,d)),a,b,x,s,t)

    def gg(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitOR(self.bitAND(b,d),self.bitAND(c,~d)),a,b,x,s,t)

    def hh(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitXOR(self.bitXOR(b,c),d),a,b,x,s,t)

    def ii(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitXOR(c,self.bitOR(b,~d)),a,b,x,s,t)

    def doEncode(self,x):
        a = 1732584193
        b = -271733879
        c = -1732584194
        d = 271733878
        step = None
        i = 0
        while (i < len(x)):
            olda = a
            oldb = b
            oldc = c
            oldd = d
            step = 0
            a = self.ff(a,b,c,d,(x[i] if i >= 0 and i < len(x) else None),7,-680876936)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 1)),12,-389564586)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 2)),17,606105819)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 3)),22,-1044525330)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 4)),7,-176418897)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 5)),12,1200080426)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 6)),17,-1473231341)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 7)),22,-45705983)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 8)),7,1770035416)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 9)),12,-1958414417)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 10)),17,-42063)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 11)),22,-1990404162)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 12)),7,1804603682)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 13)),12,-40341101)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 14)),17,-1502002290)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 15)),22,1236535329)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 1)),5,-165796510)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 6)),9,-1069501632)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 11)),14,643717713)
            b = self.gg(b,c,d,a,(x[i] if i >= 0 and i < len(x) else None),20,-373897302)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 5)),5,-701558691)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 10)),9,38016083)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 15)),14,-660478335)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 4)),20,-405537848)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 9)),5,568446438)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 14)),9,-1019803690)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 3)),14,-187363961)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 8)),20,1163531501)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 13)),5,-1444681467)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 2)),9,-51403784)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 7)),14,1735328473)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 12)),20,-1926607734)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 5)),4,-378558)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 8)),11,-2022574463)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 11)),16,1839030562)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 14)),23,-35309556)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 1)),4,-1530992060)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 4)),11,1272893353)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 7)),16,-155497632)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 10)),23,-1094730640)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 13)),4,681279174)
            d = self.hh(d,a,b,c,(x[i] if i >= 0 and i < len(x) else None),11,-358537222)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 3)),16,-722521979)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 6)),23,76029189)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 9)),4,-640364487)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 12)),11,-421815835)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 15)),16,530742520)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 2)),23,-995338651)
            a = self.ii(a,b,c,d,(x[i] if i >= 0 and i < len(x) else None),6,-198630844)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 7)),10,1126891415)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 14)),15,-1416354905)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 5)),21,-57434055)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 12)),6,1700485571)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 3)),10,-1894986606)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 10)),15,-1051523)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 1)),21,-2054922799)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 8)),6,1873313359)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 15)),10,-30611744)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 6)),15,-1560198380)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 13)),21,1309151649)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 4)),6,-145523070)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 11)),10,-1120210379)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 2)),15,718787259)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 9)),21,-343485551)
            a = self.addme(a,olda)
            b = self.addme(b,oldb)
            c = self.addme(c,oldc)
            d = self.addme(d,oldd)
            i = (i + 16)
        return [a, b, c, d]

    @staticmethod
    def encode(s):
        m = haxe_crypto_Md5()
        h = m.doEncode(haxe_crypto_Md5.str2blks(s))
        return m.hex(h)

    @staticmethod
    def str2blks(_hx_str):
        str1 = haxe_io_Bytes.ofString(_hx_str)
        nblk = ((((str1.length + 8) >> 6)) + 1)
        blks = list()
        blksSize = (nblk * 16)
        _g = 0
        _g1 = blksSize
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(blks, i, 0)
        i = 0
        _hx_max = str1.length
        l = (_hx_max * 8)
        while (i < _hx_max):
            _hx_local_0 = blks
            _hx_local_1 = (i >> 2)
            _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 | ((str1.b[i] << ((HxOverrides.mod(((l + i)), 4) * 8))))))
            (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            i = (i + 1)
        _hx_local_4 = blks
        _hx_local_5 = (i >> 2)
        _hx_local_6 = (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        python_internal_ArrayImpl._set(_hx_local_4, _hx_local_5, (_hx_local_6 | ((128 << ((HxOverrides.mod(((l + i)), 4) * 8))))))
        (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        k = ((nblk * 16) - 2)
        python_internal_ArrayImpl._set(blks, k, (l & 255))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 8) & 255)) << 8))))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 16) & 255)) << 16))))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 24) & 255)) << 24))))
        return blks

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_crypto_Md5._hx_class = haxe_crypto_Md5
_hx_classes["haxe.crypto.Md5"] = haxe_crypto_Md5


class haxe_crypto_Sha1:
    _hx_class_name = "haxe.crypto.Sha1"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["doEncode", "ft", "kt"]
    _hx_statics = ["make", "bytes2blks"]

    def __init__(self):
        pass

    def doEncode(self,x):
        w = list()
        a = 1732584193
        b = -271733879
        c = -1732584194
        d = 271733878
        e = -1009589776
        i = 0
        while (i < len(x)):
            olda = a
            oldb = b
            oldc = c
            oldd = d
            olde = e
            j = 0
            while (j < 80):
                if (j < 16):
                    python_internal_ArrayImpl._set(w, j, python_internal_ArrayImpl._get(x, (i + j)))
                else:
                    num = (((python_internal_ArrayImpl._get(w, (j - 3)) ^ python_internal_ArrayImpl._get(w, (j - 8))) ^ python_internal_ArrayImpl._get(w, (j - 14))) ^ python_internal_ArrayImpl._get(w, (j - 16)))
                    python_internal_ArrayImpl._set(w, j, ((num << 1) | (HxOverrides.rshift(num, 31))))
                t = (((((((a << 5) | (HxOverrides.rshift(a, 27)))) + self.ft(j,b,c,d)) + e) + (w[j] if j >= 0 and j < len(w) else None)) + self.kt(j))
                e = d
                d = c
                c = ((b << 30) | (HxOverrides.rshift(b, 2)))
                b = a
                a = t
                j = (j + 1)
            a = (a + olda)
            b = (b + oldb)
            c = (c + oldc)
            d = (d + oldd)
            e = (e + olde)
            i = (i + 16)
        return [a, b, c, d, e]

    def ft(self,t,b,c,d):
        if (t < 20):
            return ((b & c) | ((~b & d)))
        if (t < 40):
            return ((b ^ c) ^ d)
        if (t < 60):
            return (((b & c) | ((b & d))) | ((c & d)))
        return ((b ^ c) ^ d)

    def kt(self,t):
        if (t < 20):
            return 1518500249
        if (t < 40):
            return 1859775393
        if (t < 60):
            return -1894007588
        return -899497514

    @staticmethod
    def make(b):
        h = haxe_crypto_Sha1().doEncode(haxe_crypto_Sha1.bytes2blks(b))
        out = haxe_io_Bytes.alloc(20)
        p = 0
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[0] if 0 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[0] if 0 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[1] if 1 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[1] if 1 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[2] if 2 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[2] if 2 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[3] if 3 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[3] if 3 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[4] if 4 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[4] if 4 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[4] if 4 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[4] if 4 < len(h) else None) & 255) & 255)
        return out

    @staticmethod
    def bytes2blks(b):
        nblk = ((((b.length + 8) >> 6)) + 1)
        blks = list()
        _g = 0
        _g1 = (nblk * 16)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(blks, i, 0)
        _g = 0
        _g1 = b.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p = (i >> 2)
            python_internal_ArrayImpl._set(blks, p, ((blks[p] if p >= 0 and p < len(blks) else None) | ((b.b[i] << ((24 - ((((i & 3)) << 3))))))))
        i = b.length
        p = (i >> 2)
        python_internal_ArrayImpl._set(blks, p, ((blks[p] if p >= 0 and p < len(blks) else None) | ((128 << ((24 - ((((i & 3)) << 3))))))))
        python_internal_ArrayImpl._set(blks, ((nblk * 16) - 1), (b.length * 8))
        return blks

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_crypto_Sha1._hx_class = haxe_crypto_Sha1
_hx_classes["haxe.crypto.Sha1"] = haxe_crypto_Sha1


class haxe_ds_ArraySort:
    _hx_class_name = "haxe.ds.ArraySort"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["sort", "rec", "doMerge", "rotate", "gcd", "upper", "lower", "swap"]

    @staticmethod
    def sort(a,cmp):
        haxe_ds_ArraySort.rec(a,cmp,0,len(a))

    @staticmethod
    def rec(a,cmp,_hx_from,to):
        middle = ((_hx_from + to) >> 1)
        if ((to - _hx_from) < 12):
            if (to <= _hx_from):
                return
            _g = (_hx_from + 1)
            _g1 = to
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                j = i
                while (j > _hx_from):
                    if (cmp((a[j] if j >= 0 and j < len(a) else None),python_internal_ArrayImpl._get(a, (j - 1))) < 0):
                        haxe_ds_ArraySort.swap(a,(j - 1),j)
                    else:
                        break
                    j = (j - 1)
            return
        haxe_ds_ArraySort.rec(a,cmp,_hx_from,middle)
        haxe_ds_ArraySort.rec(a,cmp,middle,to)
        haxe_ds_ArraySort.doMerge(a,cmp,_hx_from,middle,to,(middle - _hx_from),(to - middle))

    @staticmethod
    def doMerge(a,cmp,_hx_from,pivot,to,len1,len2):
        first_cut = None
        second_cut = None
        len11 = None
        len22 = None
        if ((len1 == 0) or ((len2 == 0))):
            return
        if ((len1 + len2) == 2):
            if (cmp((a[pivot] if pivot >= 0 and pivot < len(a) else None),(a[_hx_from] if _hx_from >= 0 and _hx_from < len(a) else None)) < 0):
                haxe_ds_ArraySort.swap(a,pivot,_hx_from)
            return
        if (len1 > len2):
            len11 = (len1 >> 1)
            first_cut = (_hx_from + len11)
            second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut)
            len22 = (second_cut - pivot)
        else:
            len22 = (len2 >> 1)
            second_cut = (pivot + len22)
            first_cut = haxe_ds_ArraySort.upper(a,cmp,_hx_from,pivot,second_cut)
            len11 = (first_cut - _hx_from)
        haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut)
        new_mid = (first_cut + len22)
        haxe_ds_ArraySort.doMerge(a,cmp,_hx_from,first_cut,new_mid,len11,len22)
        haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,(len1 - len11),(len2 - len22))

    @staticmethod
    def rotate(a,cmp,_hx_from,mid,to):
        if ((_hx_from == mid) or ((mid == to))):
            return
        n = haxe_ds_ArraySort.gcd((to - _hx_from),(mid - _hx_from))
        while True:
            tmp = n
            n = (n - 1)
            if (not ((tmp != 0))):
                break
            val = python_internal_ArrayImpl._get(a, (_hx_from + n))
            shift = (mid - _hx_from)
            p1 = (_hx_from + n)
            p2 = ((_hx_from + n) + shift)
            while (p2 != ((_hx_from + n))):
                python_internal_ArrayImpl._set(a, p1, (a[p2] if p2 >= 0 and p2 < len(a) else None))
                p1 = p2
                if ((to - p2) > shift):
                    p2 = (p2 + shift)
                else:
                    p2 = (_hx_from + ((shift - ((to - p2)))))
            python_internal_ArrayImpl._set(a, p1, val)

    @staticmethod
    def gcd(m,n):
        while (n != 0):
            t = HxOverrides.mod(m, n)
            m = n
            n = t
        return m

    @staticmethod
    def upper(a,cmp,_hx_from,to,val):
        _hx_len = (to - _hx_from)
        half = None
        mid = None
        while (_hx_len > 0):
            half = (_hx_len >> 1)
            mid = (_hx_from + half)
            if (cmp((a[val] if val >= 0 and val < len(a) else None),(a[mid] if mid >= 0 and mid < len(a) else None)) < 0):
                _hx_len = half
            else:
                _hx_from = (mid + 1)
                _hx_len = ((_hx_len - half) - 1)
        return _hx_from

    @staticmethod
    def lower(a,cmp,_hx_from,to,val):
        _hx_len = (to - _hx_from)
        half = None
        mid = None
        while (_hx_len > 0):
            half = (_hx_len >> 1)
            mid = (_hx_from + half)
            if (cmp((a[mid] if mid >= 0 and mid < len(a) else None),(a[val] if val >= 0 and val < len(a) else None)) < 0):
                _hx_from = (mid + 1)
                _hx_len = ((_hx_len - half) - 1)
            else:
                _hx_len = half
        return _hx_from

    @staticmethod
    def swap(a,i,j):
        tmp = (a[i] if i >= 0 and i < len(a) else None)
        python_internal_ArrayImpl._set(a, i, (a[j] if j >= 0 and j < len(a) else None))
        python_internal_ArrayImpl._set(a, j, tmp)
haxe_ds_ArraySort._hx_class = haxe_ds_ArraySort
_hx_classes["haxe.ds.ArraySort"] = haxe_ds_ArraySort


class haxe_ds_BalancedTree:
    _hx_class_name = "haxe.ds.BalancedTree"
    _hx_is_interface = "False"
    __slots__ = ("root",)
    _hx_fields = ["root"]
    _hx_methods = ["set", "get", "setLoop", "balance", "compare"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.root = None

    def set(self,key,value):
        self.root = self.setLoop(key,value,self.root)

    def get(self,key):
        node = self.root
        while (node is not None):
            c = self.compare(key,node.key)
            if (c == 0):
                return node.value
            if (c < 0):
                node = node.left
            else:
                node = node.right
        return None

    def setLoop(self,k,v,node):
        if (node is None):
            return haxe_ds_TreeNode(None,k,v,None)
        c = self.compare(k,node.key)
        if (c == 0):
            return haxe_ds_TreeNode(node.left,k,v,node.right,(0 if ((node is None)) else node._height))
        elif (c < 0):
            nl = self.setLoop(k,v,node.left)
            return self.balance(nl,node.key,node.value,node.right)
        else:
            nr = self.setLoop(k,v,node.right)
            return self.balance(node.left,node.key,node.value,nr)

    def balance(self,l,k,v,r):
        hl = (0 if ((l is None)) else l._height)
        hr = (0 if ((r is None)) else r._height)
        if (hl > ((hr + 2))):
            _this = l.left
            _this1 = l.right
            if (((0 if ((_this is None)) else _this._height)) >= ((0 if ((_this1 is None)) else _this1._height))):
                return haxe_ds_TreeNode(l.left,l.key,l.value,haxe_ds_TreeNode(l.right,k,v,r))
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,haxe_ds_TreeNode(l.right.right,k,v,r))
        elif (hr > ((hl + 2))):
            _this = r.right
            _this1 = r.left
            if (((0 if ((_this is None)) else _this._height)) > ((0 if ((_this1 is None)) else _this1._height))):
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right)
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right))
        else:
            return haxe_ds_TreeNode(l,k,v,r,(((hl if ((hl > hr)) else hr)) + 1))

    def compare(self,k1,k2):
        return Reflect.compare(k1,k2)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
haxe_ds_BalancedTree._hx_class = haxe_ds_BalancedTree
_hx_classes["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree


class haxe_ds_TreeNode:
    _hx_class_name = "haxe.ds.TreeNode"
    _hx_is_interface = "False"
    __slots__ = ("left", "right", "key", "value", "_height")
    _hx_fields = ["left", "right", "key", "value", "_height"]

    def __init__(self,l,k,v,r,h = None):
        if (h is None):
            h = -1
        self._height = None
        self.left = l
        self.key = k
        self.value = v
        self.right = r
        if (h == -1):
            tmp = None
            _this = self.left
            _this1 = self.right
            if (((0 if ((_this is None)) else _this._height)) > ((0 if ((_this1 is None)) else _this1._height))):
                _this = self.left
                tmp = (0 if ((_this is None)) else _this._height)
            else:
                _this = self.right
                tmp = (0 if ((_this is None)) else _this._height)
            self._height = (tmp + 1)
        else:
            self._height = h

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.left = None
        _hx_o.right = None
        _hx_o.key = None
        _hx_o.value = None
        _hx_o._height = None
haxe_ds_TreeNode._hx_class = haxe_ds_TreeNode
_hx_classes["haxe.ds.TreeNode"] = haxe_ds_TreeNode


class haxe_ds_EnumValueMap(haxe_ds_BalancedTree):
    _hx_class_name = "haxe.ds.EnumValueMap"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compare", "compareArgs", "compareArg"]
    _hx_statics = []
    _hx_interfaces = [haxe_IMap]
    _hx_super = haxe_ds_BalancedTree


    def __init__(self):
        super().__init__()

    def compare(self,k1,k2):
        d = (k1.index - k2.index)
        if (d != 0):
            return d
        p1 = list(k1.params)
        p2 = list(k2.params)
        if ((len(p1) == 0) and ((len(p2) == 0))):
            return 0
        return self.compareArgs(p1,p2)

    def compareArgs(self,a1,a2):
        ld = (len(a1) - len(a2))
        if (ld != 0):
            return ld
        _g = 0
        _g1 = len(a1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            d = self.compareArg((a1[i] if i >= 0 and i < len(a1) else None),(a2[i] if i >= 0 and i < len(a2) else None))
            if (d != 0):
                return d
        return 0

    def compareArg(self,v1,v2):
        if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)):
            return self.compare(v1,v2)
        elif (Std.isOfType(v1,list) and Std.isOfType(v2,list)):
            return self.compareArgs(v1,v2)
        else:
            return Reflect.compare(v1,v2)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_ds_EnumValueMap._hx_class = haxe_ds_EnumValueMap
_hx_classes["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "remove", "keys", "iterator"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def remove(self,key):
        if (not (key in self.h)):
            return False
        del self.h[key]
        return True

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_IntMap._hx_class = haxe_ds_IntMap
_hx_classes["haxe.ds.IntMap"] = haxe_ds_IntMap


class haxe_ds_List:
    _hx_class_name = "haxe.ds.List"
    _hx_is_interface = "False"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["add", "push", "remove"]

    def __init__(self):
        self.q = None
        self.h = None
        self.length = 0

    def add(self,item):
        x = haxe_ds__List_ListNode(item,None)
        if (self.h is None):
            self.h = x
        else:
            self.q.next = x
        self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def push(self,item):
        x = haxe_ds__List_ListNode(item,self.h)
        self.h = x
        if (self.q is None):
            self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def remove(self,v):
        prev = None
        l = self.h
        while (l is not None):
            if HxOverrides.eq(l.item,v):
                if (prev is None):
                    self.h = l.next
                else:
                    prev.next = l.next
                if (self.q == l):
                    self.q = prev
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.length
                _hx_local_0.length = (_hx_local_1 - 1)
                _hx_local_1
                return True
            prev = l
            l = l.next
        return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
        _hx_o.q = None
        _hx_o.length = None
haxe_ds_List._hx_class = haxe_ds_List
_hx_classes["haxe.ds.List"] = haxe_ds_List


class haxe_ds__List_ListNode:
    _hx_class_name = "haxe.ds._List.ListNode"
    _hx_is_interface = "False"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        self.item = item
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.item = None
        _hx_o.next = None
haxe_ds__List_ListNode._hx_class = haxe_ds__List_ListNode
_hx_classes["haxe.ds._List.ListNode"] = haxe_ds__List_ListNode


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["remove", "keys", "iterator"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def remove(self,key):
        has = (key in self.h)
        if has:
            del self.h[key]
        return has

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_StringMap._hx_class = haxe_ds_StringMap
_hx_classes["haxe.ds.StringMap"] = haxe_ds_StringMap


class haxe_ds__Vector_Vector_Impl_:
    _hx_class_name = "haxe.ds._Vector.Vector_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["blit"]

    @staticmethod
    def blit(src,srcPos,dest,destPos,_hx_len):
        if (src is dest):
            if (srcPos < destPos):
                i = (srcPos + _hx_len)
                j = (destPos + _hx_len)
                _g = 0
                _g1 = _hx_len
                while (_g < _g1):
                    k = _g
                    _g = (_g + 1)
                    i = (i - 1)
                    j = (j - 1)
                    val = src[i]
                    src[j] = val
            elif (srcPos > destPos):
                i = srcPos
                j = destPos
                _g = 0
                _g1 = _hx_len
                while (_g < _g1):
                    k = _g
                    _g = (_g + 1)
                    val = src[i]
                    src[j] = val
                    i = (i + 1)
                    j = (j + 1)
        else:
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                val = src[(srcPos + i)]
                dest[(destPos + i)] = val
haxe_ds__Vector_Vector_Impl_._hx_class = haxe_ds__Vector_Vector_Impl_
_hx_classes["haxe.ds._Vector.Vector_Impl_"] = haxe_ds__Vector_Vector_Impl_


class haxe_exceptions_PosException(haxe_Exception):
    _hx_class_name = "haxe.exceptions.PosException"
    _hx_is_interface = "False"
    __slots__ = ("posInfos",)
    _hx_fields = ["posInfos"]
    _hx_methods = ["toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,message,previous = None,pos = None):
        self.posInfos = None
        super().__init__(message,previous)
        if (pos is None):
            self.posInfos = _hx_AnonObject({'fileName': "(unknown)", 'lineNumber': 0, 'className': "(unknown)", 'methodName': "(unknown)"})
        else:
            self.posInfos = pos

    def toString(self):
        return ((((((((("" + HxOverrides.stringOrNull(super().toString())) + " in ") + HxOverrides.stringOrNull(self.posInfos.className)) + ".") + HxOverrides.stringOrNull(self.posInfos.methodName)) + " at ") + HxOverrides.stringOrNull(self.posInfos.fileName)) + ":") + Std.string(self.posInfos.lineNumber))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.posInfos = None
haxe_exceptions_PosException._hx_class = haxe_exceptions_PosException
_hx_classes["haxe.exceptions.PosException"] = haxe_exceptions_PosException


class haxe_exceptions_NotImplementedException(haxe_exceptions_PosException):
    _hx_class_name = "haxe.exceptions.NotImplementedException"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_exceptions_PosException


    def __init__(self,message = None,previous = None,pos = None):
        if (message is None):
            message = "Not implemented"
        super().__init__(message,previous,pos)
haxe_exceptions_NotImplementedException._hx_class = haxe_exceptions_NotImplementedException
_hx_classes["haxe.exceptions.NotImplementedException"] = haxe_exceptions_NotImplementedException


class haxe_format_JsonPrinter:
    _hx_class_name = "haxe.format.JsonPrinter"
    _hx_is_interface = "False"
    __slots__ = ("buf", "replacer", "indent", "pretty", "nind")
    _hx_fields = ["buf", "replacer", "indent", "pretty", "nind"]
    _hx_methods = ["write", "classString", "fieldsString", "quote"]
    _hx_statics = ["print"]

    def __init__(self,replacer,space):
        self.replacer = replacer
        self.indent = space
        self.pretty = (space is not None)
        self.nind = 0
        self.buf = StringBuf()

    def write(self,k,v):
        if (self.replacer is not None):
            v = self.replacer(k,v)
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 0):
            self.buf.b.write("null")
        elif (tmp == 1):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 2):
            f = v
            v1 = (Std.string(v) if ((((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))) else "null")
            _this = self.buf
            s = Std.string(v1)
            _this.b.write(s)
        elif (tmp == 3):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 4):
            self.fieldsString(v,python_Boot.fields(v))
        elif (tmp == 5):
            self.buf.b.write("\"<fun>\"")
        elif (tmp == 6):
            c = _g.params[0]
            if (c == str):
                self.quote(v)
            elif (c == list):
                v1 = v
                _this = self.buf
                s = "".join(map(chr,[91]))
                _this.b.write(s)
                _hx_len = len(v1)
                last = (_hx_len - 1)
                _g1 = 0
                _g2 = _hx_len
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    if (i > 0):
                        _this = self.buf
                        s = "".join(map(chr,[44]))
                        _this.b.write(s)
                    else:
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.nind
                        _hx_local_0.nind = (_hx_local_1 + 1)
                        _hx_local_1
                    if self.pretty:
                        _this1 = self.buf
                        s1 = "".join(map(chr,[10]))
                        _this1.b.write(s1)
                    if self.pretty:
                        v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                        _this2 = self.buf
                        s2 = Std.string(v2)
                        _this2.b.write(s2)
                    self.write(i,(v1[i] if i >= 0 and i < len(v1) else None))
                    if (i == last):
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.nind
                        _hx_local_2.nind = (_hx_local_3 - 1)
                        _hx_local_3
                        if self.pretty:
                            _this3 = self.buf
                            s3 = "".join(map(chr,[10]))
                            _this3.b.write(s3)
                        if self.pretty:
                            v3 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                            _this4 = self.buf
                            s4 = Std.string(v3)
                            _this4.b.write(s4)
                _this = self.buf
                s = "".join(map(chr,[93]))
                _this.b.write(s)
            elif (c == haxe_ds_StringMap):
                v1 = v
                o = _hx_AnonObject({})
                k = v1.keys()
                while k.hasNext():
                    k1 = k.next()
                    value = v1.h.get(k1,None)
                    setattr(o,(("_hx_" + k1) if ((k1 in python_Boot.keywords)) else (("_hx_" + k1) if (((((len(k1) > 2) and ((ord(k1[0]) == 95))) and ((ord(k1[1]) == 95))) and ((ord(k1[(len(k1) - 1)]) != 95)))) else k1)),value)
                v1 = o
                self.fieldsString(v1,python_Boot.fields(v1))
            elif (c == Date):
                v1 = v
                self.quote(v1.toString())
            else:
                self.classString(v)
        elif (tmp == 7):
            _g1 = _g.params[0]
            i = v.index
            _this = self.buf
            s = Std.string(i)
            _this.b.write(s)
        elif (tmp == 8):
            self.buf.b.write("\"???\"")
        else:
            pass

    def classString(self,v):
        self.fieldsString(v,python_Boot.getInstanceFields(Type.getClass(v)))

    def fieldsString(self,v,fields):
        _this = self.buf
        s = "".join(map(chr,[123]))
        _this.b.write(s)
        _hx_len = len(fields)
        last = (_hx_len - 1)
        first = True
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            f = (fields[i] if i >= 0 and i < len(fields) else None)
            value = Reflect.field(v,f)
            if Reflect.isFunction(value):
                continue
            if first:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nind
                _hx_local_0.nind = (_hx_local_1 + 1)
                _hx_local_1
                first = False
            else:
                _this = self.buf
                s = "".join(map(chr,[44]))
                _this.b.write(s)
            if self.pretty:
                _this1 = self.buf
                s1 = "".join(map(chr,[10]))
                _this1.b.write(s1)
            if self.pretty:
                v1 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                _this2 = self.buf
                s2 = Std.string(v1)
                _this2.b.write(s2)
            self.quote(f)
            _this3 = self.buf
            s3 = "".join(map(chr,[58]))
            _this3.b.write(s3)
            if self.pretty:
                _this4 = self.buf
                s4 = "".join(map(chr,[32]))
                _this4.b.write(s4)
            self.write(f,value)
            if (i == last):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.nind
                _hx_local_2.nind = (_hx_local_3 - 1)
                _hx_local_3
                if self.pretty:
                    _this5 = self.buf
                    s5 = "".join(map(chr,[10]))
                    _this5.b.write(s5)
                if self.pretty:
                    v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                    _this6 = self.buf
                    s6 = Std.string(v2)
                    _this6.b.write(s6)
        _this = self.buf
        s = "".join(map(chr,[125]))
        _this.b.write(s)

    def quote(self,s):
        _this = self.buf
        s1 = "".join(map(chr,[34]))
        _this.b.write(s1)
        i = 0
        length = len(s)
        while (i < length):
            index = i
            i = (i + 1)
            c = ord(s[index])
            c1 = c
            if (c1 == 8):
                self.buf.b.write("\\b")
            elif (c1 == 9):
                self.buf.b.write("\\t")
            elif (c1 == 10):
                self.buf.b.write("\\n")
            elif (c1 == 12):
                self.buf.b.write("\\f")
            elif (c1 == 13):
                self.buf.b.write("\\r")
            elif (c1 == 34):
                self.buf.b.write("\\\"")
            elif (c1 == 92):
                self.buf.b.write("\\\\")
            else:
                _this = self.buf
                s1 = "".join(map(chr,[c]))
                _this.b.write(s1)
        _this = self.buf
        s = "".join(map(chr,[34]))
        _this.b.write(s)

    @staticmethod
    def print(o,replacer = None,space = None):
        printer = haxe_format_JsonPrinter(replacer,space)
        printer.write("",o)
        return printer.buf.b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.replacer = None
        _hx_o.indent = None
        _hx_o.pretty = None
        _hx_o.nind = None
haxe_format_JsonPrinter._hx_class = haxe_format_JsonPrinter
_hx_classes["haxe.format.JsonPrinter"] = haxe_format_JsonPrinter


class haxe_io_ArrayBufferViewImpl:
    _hx_class_name = "haxe.io.ArrayBufferViewImpl"
    _hx_is_interface = "False"
    __slots__ = ("bytes", "byteOffset", "byteLength")
    _hx_fields = ["bytes", "byteOffset", "byteLength"]

    def __init__(self,_hx_bytes,pos,length):
        self.bytes = _hx_bytes
        self.byteOffset = pos
        self.byteLength = length

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bytes = None
        _hx_o.byteOffset = None
        _hx_o.byteLength = None
haxe_io_ArrayBufferViewImpl._hx_class = haxe_io_ArrayBufferViewImpl
_hx_classes["haxe.io.ArrayBufferViewImpl"] = haxe_io_ArrayBufferViewImpl


class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["addInt32", "addInt64", "getBytes"]

    def __init__(self):
        self.b = bytearray()

    def addInt32(self,v):
        self.b.append((v & 255))
        self.b.append(((v >> 8) & 255))
        self.b.append(((v >> 16) & 255))
        self.b.append(HxOverrides.rshift(v, 24))

    def addInt64(self,v):
        self.addInt32(v.low)
        self.addInt32(v.high)

    def getBytes(self):
        _hx_bytes = haxe_io_Bytes(len(self.b),self.b)
        self.b = None
        return _hx_bytes

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
haxe_io_BytesBuffer._hx_class = haxe_io_BytesBuffer
_hx_classes["haxe.io.BytesBuffer"] = haxe_io_BytesBuffer


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    _hx_is_interface = "False"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["readByte", "readBytes", "set_bigEndian", "readFullBytes", "read", "readUntil", "readLine", "readFloat", "readDouble", "readInt16", "readUInt16", "readUInt24", "readInt32", "readString"]

    def readByte(self):
        raise haxe_exceptions_NotImplementedException(None,None,_hx_AnonObject({'fileName': "haxe/io/Input.hx", 'lineNumber': 53, 'className': "haxe.io.Input", 'methodName': "readByte"}))

    def readBytes(self,s,pos,_hx_len):
        k = _hx_len
        b = s.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        try:
            while (k > 0):
                b[pos] = self.readByte()
                pos = (pos + 1)
                k = (k - 1)
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return (_hx_len - k)

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def readFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.readBytes(s,pos,_hx_len)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def read(self,nbytes):
        s = haxe_io_Bytes.alloc(nbytes)
        p = 0
        while (nbytes > 0):
            k = self.readBytes(s,p,nbytes)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            p = (p + k)
            nbytes = (nbytes - k)
        return s

    def readUntil(self,end):
        buf = haxe_io_BytesBuffer()
        last = None
        while True:
            last = self.readByte()
            if (not ((last != end))):
                break
            buf.b.append(last)
        return buf.getBytes().toString()

    def readLine(self):
        buf = haxe_io_BytesBuffer()
        last = None
        s = None
        try:
            while True:
                last = self.readByte()
                if (not ((last != 10))):
                    break
                buf.b.append(last)
            s = buf.getBytes().toString()
            if (HxString.charCodeAt(s,(len(s) - 1)) == 13):
                s = HxString.substr(s,0,-1)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,haxe_io_Eof):
                e = _g1
                s = buf.getBytes().toString()
                if (len(s) == 0):
                    raise haxe_Exception.thrown(e)
            else:
                raise _g
        return s

    def readFloat(self):
        return haxe_io_FPHelper.i32ToFloat(self.readInt32())

    def readDouble(self):
        i1 = self.readInt32()
        i2 = self.readInt32()
        if self.bigEndian:
            return haxe_io_FPHelper.i64ToDouble(i2,i1)
        else:
            return haxe_io_FPHelper.i64ToDouble(i1,i2)

    def readInt16(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        n = ((ch2 | ((ch1 << 8))) if (self.bigEndian) else (ch1 | ((ch2 << 8))))
        if (((n & 32768)) != 0):
            return (n - 65536)
        return n

    def readUInt16(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        if self.bigEndian:
            return (ch2 | ((ch1 << 8)))
        else:
            return (ch1 | ((ch2 << 8)))

    def readUInt24(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        ch3 = self.readByte()
        if self.bigEndian:
            return ((ch3 | ((ch2 << 8))) | ((ch1 << 16)))
        else:
            return ((ch1 | ((ch2 << 8))) | ((ch3 << 16)))

    def readInt32(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        ch3 = self.readByte()
        ch4 = self.readByte()
        n = ((((ch4 | ((ch3 << 8))) | ((ch2 << 16))) | ((ch1 << 24))) if (self.bigEndian) else (((ch1 | ((ch2 << 8))) | ((ch3 << 16))) | ((ch4 << 24))))
        if (((n & -2147483648)) != 0):
            return (n | -2147483648)
        else:
            return n

    def readString(self,_hx_len,encoding = None):
        b = haxe_io_Bytes.alloc(_hx_len)
        self.readFullBytes(b,0,_hx_len)
        return b.getString(0,_hx_len,encoding)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None
haxe_io_Input._hx_class = haxe_io_Input
_hx_classes["haxe.io.Input"] = haxe_io_Input


class haxe_io_BytesInput(haxe_io_Input):
    _hx_class_name = "haxe.io.BytesInput"
    _hx_is_interface = "False"
    __slots__ = ("b", "pos", "len", "totlen")
    _hx_fields = ["b", "pos", "len", "totlen"]
    _hx_methods = ["set_position", "readByte", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,b,pos = None,_hx_len = None):
        if (pos is None):
            pos = 0
        if (_hx_len is None):
            _hx_len = (b.length - pos)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > b.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        self.b = b.b
        self.pos = pos
        self.len = _hx_len
        self.totlen = _hx_len
        self.set_bigEndian(False)

    def set_position(self,p):
        if (p < 0):
            p = 0
        elif (p > self.totlen):
            p = self.totlen
        self.len = (self.totlen - p)
        def _hx_local_1():
            def _hx_local_0():
                self.pos = p
                return self.pos
            return _hx_local_0()
        return _hx_local_1()

    def readByte(self):
        if (self.len == 0):
            raise haxe_Exception.thrown(haxe_io_Eof())
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 - 1)
        _hx_local_1
        b = self.b[self.pos]
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.pos
        _hx_local_2.pos = (_hx_local_3 + 1)
        _hx_local_3
        return b

    def readBytes(self,buf,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        if ((self.len == 0) and ((_hx_len > 0))):
            raise haxe_Exception.thrown(haxe_io_Eof())
        if (self.len < _hx_len):
            _hx_len = self.len
        b1 = self.b
        b2 = buf.b
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            b2[(pos + i)] = b1[(self.pos + i)]
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + _hx_len)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.len
        _hx_local_2.len = (_hx_local_3 - _hx_len)
        _hx_local_2.len
        return _hx_len

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.pos = None
        _hx_o.len = None
        _hx_o.totlen = None
haxe_io_BytesInput._hx_class = haxe_io_BytesInput
_hx_classes["haxe.io.BytesInput"] = haxe_io_BytesInput


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    _hx_is_interface = "False"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "flush", "close", "set_bigEndian", "write", "writeFullBytes", "writeFloat", "writeInt16", "writeUInt16", "writeInt32", "writeString"]

    def writeByte(self,c):
        raise haxe_exceptions_NotImplementedException(None,None,_hx_AnonObject({'fileName': "haxe/io/Output.hx", 'lineNumber': 47, 'className': "haxe.io.Output", 'methodName': "writeByte"}))

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def flush(self):
        pass

    def close(self):
        pass

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def write(self,s):
        l = s.length
        p = 0
        while (l > 0):
            k = self.writeBytes(s,p,l)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            p = (p + k)
            l = (l - k)

    def writeFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.writeBytes(s,pos,_hx_len)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def writeFloat(self,x):
        self.writeInt32(haxe_io_FPHelper.floatToI32(x))

    def writeInt16(self,x):
        if ((x < -32768) or ((x >= 32768))):
            raise haxe_Exception.thrown(haxe_io_Error.Overflow)
        self.writeUInt16((x & 65535))

    def writeUInt16(self,x):
        if ((x < 0) or ((x >= 65536))):
            raise haxe_Exception.thrown(haxe_io_Error.Overflow)
        if self.bigEndian:
            self.writeByte((x >> 8))
            self.writeByte((x & 255))
        else:
            self.writeByte((x & 255))
            self.writeByte((x >> 8))

    def writeInt32(self,x):
        if self.bigEndian:
            self.writeByte(HxOverrides.rshift(x, 24))
            self.writeByte(((x >> 16) & 255))
            self.writeByte(((x >> 8) & 255))
            self.writeByte((x & 255))
        else:
            self.writeByte((x & 255))
            self.writeByte(((x >> 8) & 255))
            self.writeByte(((x >> 16) & 255))
            self.writeByte(HxOverrides.rshift(x, 24))

    def writeString(self,s,encoding = None):
        b = haxe_io_Bytes.ofString(s,encoding)
        self.writeFullBytes(b,0,b.length)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None
haxe_io_Output._hx_class = haxe_io_Output
_hx_classes["haxe.io.Output"] = haxe_io_Output


class haxe_io_BytesOutput(haxe_io_Output):
    _hx_class_name = "haxe.io.BytesOutput"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["writeByte", "writeBytes", "getBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self):
        self.b = haxe_io_BytesBuffer()
        self.set_bigEndian(False)

    def writeByte(self,c):
        self.b.b.append(c)

    def writeBytes(self,buf,pos,_hx_len):
        _this = self.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        _this.b.extend(buf.b[pos:(pos + _hx_len)])
        return _hx_len

    def getBytes(self):
        return self.b.getBytes()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
haxe_io_BytesOutput._hx_class = haxe_io_BytesOutput
_hx_classes["haxe.io.BytesOutput"] = haxe_io_BytesOutput

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())
haxe_io_Encoding._hx_class = haxe_io_Encoding
_hx_classes["haxe.io.Encoding"] = haxe_io_Encoding


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_io_Eof._hx_class = haxe_io_Eof
_hx_classes["haxe.io.Eof"] = haxe_io_Eof

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())
haxe_io_Error._hx_class = haxe_io_Error
_hx_classes["haxe.io.Error"] = haxe_io_Error


class haxe_io_FPHelper:
    _hx_class_name = "haxe.io.FPHelper"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["i64tmp", "i32ToFloat", "floatToI32", "i64ToDouble", "doubleToI64"]

    @staticmethod
    def i32ToFloat(i):
        sign = (1 - ((HxOverrides.rshift(i, 31) << 1)))
        e = ((i >> 23) & 255)
        if (e == 255):
            if (((i & 8388607)) == 0):
                if (sign > 0):
                    return Math.POSITIVE_INFINITY
                else:
                    return Math.NEGATIVE_INFINITY
            else:
                return Math.NaN
        else:
            m = ((((i & 8388607)) << 1) if ((e == 0)) else ((i & 8388607) | 8388608))
            return ((sign * m) * Math.pow(2,(e - 150)))

    @staticmethod
    def floatToI32(f):
        if (f == 0):
            return 0
        else:
            af = (-f if ((f < 0)) else f)
            exp = Math.floor((((Math.NEGATIVE_INFINITY if ((af == 0.0)) else (Math.NaN if ((af < 0.0)) else python_lib_Math.log(af)))) / 0.6931471805599453))
            if (exp > 127):
                return 2139095040
            else:
                if (exp <= -127):
                    exp = -127
                    af = (af * 7.1362384635298e+44)
                else:
                    af = ((((af / Math.pow(2,exp)) - 1.0)) * 8388608)
                return ((((-2147483648 if ((f < 0)) else 0)) | (((exp + 127) << 23))) | Math.floor((af + 0.5)))

    @staticmethod
    def i64ToDouble(low,high):
        sign = (1 - ((HxOverrides.rshift(high, 31) << 1)))
        e = ((high >> 20) & 2047)
        if (e == 2047):
            if ((low == 0) and ((((high & 1048575)) == 0))):
                if (sign > 0):
                    return Math.POSITIVE_INFINITY
                else:
                    return Math.NEGATIVE_INFINITY
            else:
                return Math.NaN
        else:
            m = (2.220446049250313e-16 * ((((((high & 1048575)) * 4294967296.) + (((HxOverrides.rshift(low, 31)) * 2147483648.))) + ((low & 2147483647)))))
            if (e == 0):
                m = (m * 2.0)
            else:
                m = (m + 1.0)
            return ((sign * m) * Math.pow(2,(e - 1023)))

    @staticmethod
    def doubleToI64(v):
        i64 = haxe_io_FPHelper.i64tmp
        if (v == 0):
            i64.low = 0
            i64.high = 0
        elif (not ((((v != Math.POSITIVE_INFINITY) and ((v != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(v))))):
            i64.low = 0
            i64.high = (2146435072 if ((v > 0)) else -1048576)
        else:
            av = (-v if ((v < 0)) else v)
            exp = Math.floor((((Math.NEGATIVE_INFINITY if ((av == 0.0)) else (Math.NaN if ((av < 0.0)) else python_lib_Math.log(av)))) / 0.6931471805599453))
            if (exp > 1023):
                i64.low = -1
                i64.high = 2146435071
            else:
                if (exp <= -1023):
                    exp = -1023
                    av = (av / 2.2250738585072014e-308)
                else:
                    av = ((av / Math.pow(2,exp)) - 1.0)
                v1 = (av * 4503599627370496.)
                sig = (v1 if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v1)) else Math.floor((v1 + 0.5))))
                sig_l = None
                try:
                    sig_l = int(sig)
                except BaseException as _g:
                    None
                    sig_l = None
                sig_l1 = sig_l
                sig_h = None
                try:
                    sig_h = int((sig / 4294967296.0))
                except BaseException as _g:
                    None
                    sig_h = None
                sig_h1 = sig_h
                i64.low = sig_l1
                i64.high = ((((-2147483648 if ((v < 0)) else 0)) | (((exp + 1023) << 20))) | sig_h1)
        return i64
haxe_io_FPHelper._hx_class = haxe_io_FPHelper
_hx_classes["haxe.io.FPHelper"] = haxe_io_FPHelper


class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    _hx_is_interface = "False"
    __slots__ = ("dir", "file", "ext", "backslash")
    _hx_fields = ["dir", "file", "ext", "backslash"]
    _hx_methods = ["toString"]
    _hx_statics = ["directory", "withExtension", "join", "normalize", "addTrailingSlash", "isAbsolute"]

    def __init__(self,path):
        self.backslash = None
        self.ext = None
        self.file = None
        self.dir = None
        path1 = path
        _hx_local_0 = len(path1)
        if (_hx_local_0 == 1):
            if (path1 == "."):
                self.dir = path
                self.file = ""
                return
        elif (_hx_local_0 == 2):
            if (path1 == ".."):
                self.dir = path
                self.file = ""
                return
        else:
            pass
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex = None
        c2 = None
        if (startIndex is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i = path.rfind("\\", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\\"))) if ((i == -1)) else (i + 1))
            check = path.find("\\", startLeft, len(path))
            c2 = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (c1 < c2):
            self.dir = HxString.substr(path,0,c2)
            path = HxString.substr(path,(c2 + 1),None)
            self.backslash = True
        elif (c2 < c1):
            self.dir = HxString.substr(path,0,c1)
            path = HxString.substr(path,(c1 + 1),None)
        else:
            self.dir = None
        startIndex = None
        cp = None
        if (startIndex is None):
            cp = path.rfind(".", 0, len(path))
        else:
            i = path.rfind(".", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("."))) if ((i == -1)) else (i + 1))
            check = path.find(".", startLeft, len(path))
            cp = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (cp != -1):
            self.ext = HxString.substr(path,(cp + 1),None)
            self.file = HxString.substr(path,0,cp)
        else:
            self.ext = None
            self.file = path

    def toString(self):
        return ((HxOverrides.stringOrNull((("" if ((self.dir is None)) else (HxOverrides.stringOrNull(self.dir) + HxOverrides.stringOrNull((("\\" if (self.backslash) else "/"))))))) + HxOverrides.stringOrNull(self.file)) + HxOverrides.stringOrNull((("" if ((self.ext is None)) else ("." + HxOverrides.stringOrNull(self.ext))))))

    @staticmethod
    def directory(path):
        s = haxe_io_Path(path)
        if (s.dir is None):
            return ""
        return s.dir

    @staticmethod
    def withExtension(path,ext):
        s = haxe_io_Path(path)
        s.ext = ext
        return s.toString()

    @staticmethod
    def join(paths):
        def _hx_local_0(s):
            if (s is not None):
                return (s != "")
            else:
                return False
        paths1 = list(filter(_hx_local_0,paths))
        if (len(paths1) == 0):
            return ""
        path = (paths1[0] if 0 < len(paths1) else None)
        _g = 1
        _g1 = len(paths1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            path = haxe_io_Path.addTrailingSlash(path)
            path = (("null" if path is None else path) + HxOverrides.stringOrNull((paths1[i] if i >= 0 and i < len(paths1) else None)))
        return haxe_io_Path.normalize(path)

    @staticmethod
    def normalize(path):
        slash = "/"
        _this = path.split("\\")
        path = slash.join([python_Boot.toString1(x1,'') for x1 in _this])
        if (path == slash):
            return slash
        target = []
        _g = 0
        _g1 = (list(path) if ((slash == "")) else path.split(slash))
        while (_g < len(_g1)):
            token = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((token == "..") and ((len(target) > 0))) and ((python_internal_ArrayImpl._get(target, (len(target) - 1)) != ".."))):
                if (len(target) != 0):
                    target.pop()
            elif (token == ""):
                if ((len(target) > 0) or ((HxString.charCodeAt(path,0) == 47))):
                    target.append(token)
            elif (token != "."):
                target.append(token)
        tmp = slash.join([python_Boot.toString1(x1,'') for x1 in target])
        acc_b = python_lib_io_StringIO()
        colon = False
        slashes = False
        _g = 0
        _g1 = len(tmp)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = (-1 if ((i >= len(tmp))) else ord(tmp[i]))
            _g3 = _g2
            if (_g3 == 47):
                if (not colon):
                    slashes = True
                else:
                    i1 = _g2
                    colon = False
                    if slashes:
                        acc_b.write("/")
                        slashes = False
                    acc_b.write("".join(map(chr,[i1])))
            elif (_g3 == 58):
                acc_b.write(":")
                colon = True
            else:
                i2 = _g2
                colon = False
                if slashes:
                    acc_b.write("/")
                    slashes = False
                acc_b.write("".join(map(chr,[i2])))
        return acc_b.getvalue()

    @staticmethod
    def addTrailingSlash(path):
        if (len(path) == 0):
            return "/"
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex = None
        c2 = None
        if (startIndex is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i = path.rfind("\\", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\\"))) if ((i == -1)) else (i + 1))
            check = path.find("\\", startLeft, len(path))
            c2 = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (c1 < c2):
            if (c2 != ((len(path) - 1))):
                return (("null" if path is None else path) + "\\")
            else:
                return path
        elif (c1 != ((len(path) - 1))):
            return (("null" if path is None else path) + "/")
        else:
            return path

    @staticmethod
    def isAbsolute(path):
        if path.startswith("/"):
            return True
        if ((("" if ((1 >= len(path))) else path[1])) == ":"):
            return True
        if path.startswith("\\\\"):
            return True
        return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.dir = None
        _hx_o.file = None
        _hx_o.ext = None
        _hx_o.backslash = None
haxe_io_Path._hx_class = haxe_io_Path
_hx_classes["haxe.io.Path"] = haxe_io_Path


class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    _hx_is_interface = "False"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.array = None
        _hx_o.current = None
haxe_iterators_ArrayIterator._hx_class = haxe_iterators_ArrayIterator
_hx_classes["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator

class haxe_macro_Binop(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Binop"
    _hx_constructs = ["OpAdd", "OpMult", "OpDiv", "OpSub", "OpAssign", "OpEq", "OpNotEq", "OpGt", "OpGte", "OpLt", "OpLte", "OpAnd", "OpOr", "OpXor", "OpBoolAnd", "OpBoolOr", "OpShl", "OpShr", "OpUShr", "OpMod", "OpAssignOp", "OpInterval", "OpArrow", "OpIn"]

    @staticmethod
    def OpAssignOp(op):
        return haxe_macro_Binop("OpAssignOp", 20, (op,))
haxe_macro_Binop.OpAdd = haxe_macro_Binop("OpAdd", 0, ())
haxe_macro_Binop.OpMult = haxe_macro_Binop("OpMult", 1, ())
haxe_macro_Binop.OpDiv = haxe_macro_Binop("OpDiv", 2, ())
haxe_macro_Binop.OpSub = haxe_macro_Binop("OpSub", 3, ())
haxe_macro_Binop.OpAssign = haxe_macro_Binop("OpAssign", 4, ())
haxe_macro_Binop.OpEq = haxe_macro_Binop("OpEq", 5, ())
haxe_macro_Binop.OpNotEq = haxe_macro_Binop("OpNotEq", 6, ())
haxe_macro_Binop.OpGt = haxe_macro_Binop("OpGt", 7, ())
haxe_macro_Binop.OpGte = haxe_macro_Binop("OpGte", 8, ())
haxe_macro_Binop.OpLt = haxe_macro_Binop("OpLt", 9, ())
haxe_macro_Binop.OpLte = haxe_macro_Binop("OpLte", 10, ())
haxe_macro_Binop.OpAnd = haxe_macro_Binop("OpAnd", 11, ())
haxe_macro_Binop.OpOr = haxe_macro_Binop("OpOr", 12, ())
haxe_macro_Binop.OpXor = haxe_macro_Binop("OpXor", 13, ())
haxe_macro_Binop.OpBoolAnd = haxe_macro_Binop("OpBoolAnd", 14, ())
haxe_macro_Binop.OpBoolOr = haxe_macro_Binop("OpBoolOr", 15, ())
haxe_macro_Binop.OpShl = haxe_macro_Binop("OpShl", 16, ())
haxe_macro_Binop.OpShr = haxe_macro_Binop("OpShr", 17, ())
haxe_macro_Binop.OpUShr = haxe_macro_Binop("OpUShr", 18, ())
haxe_macro_Binop.OpMod = haxe_macro_Binop("OpMod", 19, ())
haxe_macro_Binop.OpInterval = haxe_macro_Binop("OpInterval", 21, ())
haxe_macro_Binop.OpArrow = haxe_macro_Binop("OpArrow", 22, ())
haxe_macro_Binop.OpIn = haxe_macro_Binop("OpIn", 23, ())
haxe_macro_Binop._hx_class = haxe_macro_Binop
_hx_classes["haxe.macro.Binop"] = haxe_macro_Binop

class haxe_macro_Unop(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Unop"
    _hx_constructs = ["OpIncrement", "OpDecrement", "OpNot", "OpNeg", "OpNegBits", "OpSpread"]
haxe_macro_Unop.OpIncrement = haxe_macro_Unop("OpIncrement", 0, ())
haxe_macro_Unop.OpDecrement = haxe_macro_Unop("OpDecrement", 1, ())
haxe_macro_Unop.OpNot = haxe_macro_Unop("OpNot", 2, ())
haxe_macro_Unop.OpNeg = haxe_macro_Unop("OpNeg", 3, ())
haxe_macro_Unop.OpNegBits = haxe_macro_Unop("OpNegBits", 4, ())
haxe_macro_Unop.OpSpread = haxe_macro_Unop("OpSpread", 5, ())
haxe_macro_Unop._hx_class = haxe_macro_Unop
_hx_classes["haxe.macro.Unop"] = haxe_macro_Unop


class haxe_xml__Access_NodeAccess_Impl_:
    _hx_class_name = "haxe.xml._Access.NodeAccess_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["resolve"]

    @staticmethod
    def resolve(this1,name):
        x = this1.elementsNamed(name).next()
        if (x is None):
            xname = None
            if (this1.nodeType == Xml.Document):
                xname = "Document"
            else:
                if (this1.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((this1.nodeType is None)) else _Xml_XmlType_Impl_.toString(this1.nodeType))))))
                xname = this1.nodeName
            raise haxe_Exception.thrown(((("null" if xname is None else xname) + " is missing element ") + ("null" if name is None else name)))
        if ((x.nodeType != Xml.Document) and ((x.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Invalid nodeType " + HxOverrides.stringOrNull((("null" if ((x.nodeType is None)) else _Xml_XmlType_Impl_.toString(x.nodeType))))))
        this1 = x
        return this1
haxe_xml__Access_NodeAccess_Impl_._hx_class = haxe_xml__Access_NodeAccess_Impl_
_hx_classes["haxe.xml._Access.NodeAccess_Impl_"] = haxe_xml__Access_NodeAccess_Impl_


class haxe_xml__Access_AttribAccess_Impl_:
    _hx_class_name = "haxe.xml._Access.AttribAccess_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["resolve"]

    @staticmethod
    def resolve(this1,name):
        if (this1.nodeType == Xml.Document):
            raise haxe_Exception.thrown(("Cannot access document attribute " + ("null" if name is None else name)))
        v = this1.get(name)
        if (v is None):
            if (this1.nodeType != Xml.Element):
                raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((this1.nodeType is None)) else _Xml_XmlType_Impl_.toString(this1.nodeType))))))
            raise haxe_Exception.thrown(((HxOverrides.stringOrNull(this1.nodeName) + " is missing attribute ") + ("null" if name is None else name)))
        return v
haxe_xml__Access_AttribAccess_Impl_._hx_class = haxe_xml__Access_AttribAccess_Impl_
_hx_classes["haxe.xml._Access.AttribAccess_Impl_"] = haxe_xml__Access_AttribAccess_Impl_


class haxe_xml__Access_HasNodeAccess_Impl_:
    _hx_class_name = "haxe.xml._Access.HasNodeAccess_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["resolve"]

    @staticmethod
    def resolve(this1,name):
        return this1.elementsNamed(name).hasNext()
haxe_xml__Access_HasNodeAccess_Impl_._hx_class = haxe_xml__Access_HasNodeAccess_Impl_
_hx_classes["haxe.xml._Access.HasNodeAccess_Impl_"] = haxe_xml__Access_HasNodeAccess_Impl_


class haxe_xml__Access_Access_Impl_:
    _hx_class_name = "haxe.xml._Access.Access_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_innerData"]
    innerData = None

    @staticmethod
    def get_innerData(this1):
        if ((this1.nodeType != Xml.Document) and ((this1.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((this1.nodeType is None)) else _Xml_XmlType_Impl_.toString(this1.nodeType))))))
        it_current = 0
        it_array = this1.children
        if (it_current >= len(it_array)):
            tmp = None
            if (this1.nodeType == Xml.Document):
                tmp = "Document"
            else:
                if (this1.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((this1.nodeType is None)) else _Xml_XmlType_Impl_.toString(this1.nodeType))))))
                tmp = this1.nodeName
            raise haxe_Exception.thrown((("null" if tmp is None else tmp) + " does not have data"))
        v = it_current
        it_current = (it_current + 1)
        v1 = (it_array[v] if v >= 0 and v < len(it_array) else None)
        if (it_current < len(it_array)):
            n = it_current
            it_current = (it_current + 1)
            n1 = (it_array[n] if n >= 0 and n < len(it_array) else None)
            tmp = None
            if ((v1.nodeType == Xml.PCData) and ((n1.nodeType == Xml.CData))):
                if ((v1.nodeType == Xml.Document) or ((v1.nodeType == Xml.Element))):
                    raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((v1.nodeType is None)) else _Xml_XmlType_Impl_.toString(v1.nodeType))))))
                tmp = (StringTools.trim(v1.nodeValue) == "")
            else:
                tmp = False
            if tmp:
                if (it_current >= len(it_array)):
                    if ((n1.nodeType == Xml.Document) or ((n1.nodeType == Xml.Element))):
                        raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((n1.nodeType is None)) else _Xml_XmlType_Impl_.toString(n1.nodeType))))))
                    return n1.nodeValue
                n2 = it_current
                it_current = (it_current + 1)
                n21 = (it_array[n2] if n2 >= 0 and n2 < len(it_array) else None)
                tmp = None
                if (n21.nodeType == Xml.PCData):
                    if ((n21.nodeType == Xml.Document) or ((n21.nodeType == Xml.Element))):
                        raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((n21.nodeType is None)) else _Xml_XmlType_Impl_.toString(n21.nodeType))))))
                    tmp = (StringTools.trim(n21.nodeValue) == "")
                else:
                    tmp = False
                if (tmp and ((it_current >= len(it_array)))):
                    if ((n1.nodeType == Xml.Document) or ((n1.nodeType == Xml.Element))):
                        raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((n1.nodeType is None)) else _Xml_XmlType_Impl_.toString(n1.nodeType))))))
                    return n1.nodeValue
            tmp = None
            if (this1.nodeType == Xml.Document):
                tmp = "Document"
            else:
                if (this1.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((this1.nodeType is None)) else _Xml_XmlType_Impl_.toString(this1.nodeType))))))
                tmp = this1.nodeName
            raise haxe_Exception.thrown((("null" if tmp is None else tmp) + " does not only have data"))
        if ((v1.nodeType != Xml.PCData) and ((v1.nodeType != Xml.CData))):
            tmp = None
            if (this1.nodeType == Xml.Document):
                tmp = "Document"
            else:
                if (this1.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((this1.nodeType is None)) else _Xml_XmlType_Impl_.toString(this1.nodeType))))))
                tmp = this1.nodeName
            raise haxe_Exception.thrown((("null" if tmp is None else tmp) + " does not have data"))
        if ((v1.nodeType == Xml.Document) or ((v1.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((v1.nodeType is None)) else _Xml_XmlType_Impl_.toString(v1.nodeType))))))
        return v1.nodeValue
haxe_xml__Access_Access_Impl_._hx_class = haxe_xml__Access_Access_Impl_
_hx_classes["haxe.xml._Access.Access_Impl_"] = haxe_xml__Access_Access_Impl_


class haxe_xml_XmlParserException:
    _hx_class_name = "haxe.xml.XmlParserException"
    _hx_is_interface = "False"
    __slots__ = ("message", "lineNumber", "positionAtLine", "position", "xml")
    _hx_fields = ["message", "lineNumber", "positionAtLine", "position", "xml"]
    _hx_methods = ["toString"]

    def __init__(self,message,xml,position):
        self.xml = xml
        self.message = message
        self.position = position
        self.lineNumber = 1
        self.positionAtLine = 0
        _g = 0
        _g1 = position
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(xml))) else ord(xml[i]))
            if (c == 10):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.lineNumber
                _hx_local_0.lineNumber = (_hx_local_1 + 1)
                _hx_local_1
                self.positionAtLine = 0
            elif (c != 13):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.positionAtLine
                _hx_local_2.positionAtLine = (_hx_local_3 + 1)
                _hx_local_3

    def toString(self):
        return ((((((HxOverrides.stringOrNull(Type.getClassName(Type.getClass(self))) + ": ") + HxOverrides.stringOrNull(self.message)) + " at line ") + Std.string(self.lineNumber)) + " char ") + Std.string(self.positionAtLine))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.message = None
        _hx_o.lineNumber = None
        _hx_o.positionAtLine = None
        _hx_o.position = None
        _hx_o.xml = None
haxe_xml_XmlParserException._hx_class = haxe_xml_XmlParserException
_hx_classes["haxe.xml.XmlParserException"] = haxe_xml_XmlParserException


class haxe_xml_Parser:
    _hx_class_name = "haxe.xml.Parser"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["escapes", "parse", "doParse"]

    @staticmethod
    def parse(_hx_str,strict = None):
        if (strict is None):
            strict = False
        doc = Xml.createDocument()
        haxe_xml_Parser.doParse(_hx_str,strict,0,doc)
        return doc

    @staticmethod
    def doParse(_hx_str,strict,p = None,parent = None):
        if (p is None):
            p = 0
        xml = None
        state = 1
        next = 1
        aname = None
        start = 0
        nsubs = 0
        nbrackets = 0
        buf = StringBuf()
        escapeNext = 1
        attrValQuote = -1
        while (p < len(_hx_str)):
            c = ord(_hx_str[p])
            state1 = state
            if (state1 == 0):
                c1 = c
                if ((((c1 == 32) or ((c1 == 13))) or ((c1 == 10))) or ((c1 == 9))):
                    pass
                else:
                    state = next
                    continue
            elif (state1 == 1):
                if (c == 60):
                    state = 0
                    next = 2
                else:
                    start = p
                    state = 13
                    continue
            elif (state1 == 2):
                c2 = c
                if (c2 == 33):
                    index = (p + 1)
                    if (((-1 if ((index >= len(_hx_str))) else ord(_hx_str[index]))) == 91):
                        p = (p + 2)
                        if (HxString.substr(_hx_str,p,6).upper() != "CDATA["):
                            raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected <![CDATA[",_hx_str,p))
                        p = (p + 5)
                        state = 17
                        start = (p + 1)
                    else:
                        tmp = None
                        index1 = (p + 1)
                        if (((-1 if ((index1 >= len(_hx_str))) else ord(_hx_str[index1]))) != 68):
                            index2 = (p + 1)
                            tmp = (((-1 if ((index2 >= len(_hx_str))) else ord(_hx_str[index2]))) == 100)
                        else:
                            tmp = True
                        if tmp:
                            if (HxString.substr(_hx_str,(p + 2),6).upper() != "OCTYPE"):
                                raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected <!DOCTYPE",_hx_str,p))
                            p = (p + 8)
                            state = 16
                            start = (p + 1)
                        else:
                            tmp1 = None
                            index3 = (p + 1)
                            if (((-1 if ((index3 >= len(_hx_str))) else ord(_hx_str[index3]))) == 45):
                                index4 = (p + 2)
                                tmp1 = (((-1 if ((index4 >= len(_hx_str))) else ord(_hx_str[index4]))) != 45)
                            else:
                                tmp1 = True
                            if tmp1:
                                raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected <!--",_hx_str,p))
                            else:
                                p = (p + 2)
                                state = 15
                                start = (p + 1)
                elif (c2 == 47):
                    if (parent is None):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    start = (p + 1)
                    state = 0
                    next = 10
                elif (c2 == 63):
                    state = 14
                    start = p
                else:
                    state = 3
                    start = p
                    continue
            elif (state1 == 3):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (p == start):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    xml = Xml.createElement(HxString.substr(_hx_str,start,(p - start)))
                    parent.addChild(xml)
                    nsubs = (nsubs + 1)
                    state = 0
                    next = 4
                    continue
            elif (state1 == 4):
                c3 = c
                if (c3 == 47):
                    state = 11
                elif (c3 == 62):
                    state = 9
                else:
                    state = 5
                    start = p
                    continue
            elif (state1 == 5):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (start == p):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected attribute name",_hx_str,p))
                    tmp2 = HxString.substr(_hx_str,start,(p - start))
                    aname = tmp2
                    if xml.exists(aname):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Duplicate attribute [" + ("null" if aname is None else aname)) + "]"),_hx_str,p))
                    state = 0
                    next = 6
                    continue
            elif (state1 == 6):
                if (c == 61):
                    state = 0
                    next = 7
                else:
                    raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected =",_hx_str,p))
            elif (state1 == 7):
                c4 = c
                if ((c4 == 39) or ((c4 == 34))):
                    buf = StringBuf()
                    state = 8
                    start = (p + 1)
                    attrValQuote = c
                else:
                    raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected \"",_hx_str,p))
            elif (state1 == 8):
                c5 = c
                if (c5 == 38):
                    _hx_len = (p - start)
                    s = (HxString.substr(_hx_str,start,None) if ((_hx_len is None)) else HxString.substr(_hx_str,start,_hx_len))
                    buf.b.write(s)
                    state = 18
                    escapeNext = 8
                    start = (p + 1)
                elif ((c5 == 62) or ((c5 == 60))):
                    if strict:
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Invalid unescaped " + HxOverrides.stringOrNull("".join(map(chr,[c])))) + " in attribute value"),_hx_str,p))
                    elif (c == attrValQuote):
                        len1 = (p - start)
                        s1 = (HxString.substr(_hx_str,start,None) if ((len1 is None)) else HxString.substr(_hx_str,start,len1))
                        buf.b.write(s1)
                        val = buf.b.getvalue()
                        buf = StringBuf()
                        xml.set(aname,val)
                        state = 0
                        next = 4
                elif (c == attrValQuote):
                    len2 = (p - start)
                    s2 = (HxString.substr(_hx_str,start,None) if ((len2 is None)) else HxString.substr(_hx_str,start,len2))
                    buf.b.write(s2)
                    val1 = buf.b.getvalue()
                    buf = StringBuf()
                    xml.set(aname,val1)
                    state = 0
                    next = 4
            elif (state1 == 9):
                p = haxe_xml_Parser.doParse(_hx_str,strict,p,xml)
                start = p
                state = 1
            elif (state1 == 10):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (start == p):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    v = HxString.substr(_hx_str,start,(p - start))
                    if ((parent is None) or ((parent.nodeType != 0))):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Unexpected </" + ("null" if v is None else v)) + ">, tag is not open"),_hx_str,p))
                    if (parent.nodeType != Xml.Element):
                        raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((parent.nodeType is None)) else _Xml_XmlType_Impl_.toString(parent.nodeType))))))
                    if (v != parent.nodeName):
                        if (parent.nodeType != Xml.Element):
                            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((parent.nodeType is None)) else _Xml_XmlType_Impl_.toString(parent.nodeType))))))
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Expected </" + HxOverrides.stringOrNull(parent.nodeName)) + ">"),_hx_str,p))
                    state = 0
                    next = 12
                    continue
            elif (state1 == 11):
                if (c == 62):
                    state = 1
                else:
                    raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected >",_hx_str,p))
            elif (state1 == 12):
                if (c == 62):
                    if (nsubs == 0):
                        parent.addChild(Xml.createPCData(""))
                    return p
                else:
                    raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected >",_hx_str,p))
            elif (state1 == 13):
                if (c == 60):
                    len3 = (p - start)
                    s3 = (HxString.substr(_hx_str,start,None) if ((len3 is None)) else HxString.substr(_hx_str,start,len3))
                    buf.b.write(s3)
                    child = Xml.createPCData(buf.b.getvalue())
                    buf = StringBuf()
                    parent.addChild(child)
                    nsubs = (nsubs + 1)
                    state = 0
                    next = 2
                elif (c == 38):
                    len4 = (p - start)
                    s4 = (HxString.substr(_hx_str,start,None) if ((len4 is None)) else HxString.substr(_hx_str,start,len4))
                    buf.b.write(s4)
                    state = 18
                    escapeNext = 13
                    start = (p + 1)
            elif (state1 == 14):
                tmp3 = None
                if (c == 63):
                    index5 = (p + 1)
                    tmp3 = (((-1 if ((index5 >= len(_hx_str))) else ord(_hx_str[index5]))) == 62)
                else:
                    tmp3 = False
                if tmp3:
                    p = (p + 1)
                    str1 = HxString.substr(_hx_str,(start + 1),((p - start) - 2))
                    parent.addChild(Xml.createProcessingInstruction(str1))
                    nsubs = (nsubs + 1)
                    state = 1
            elif (state1 == 15):
                tmp4 = None
                tmp5 = None
                if (c == 45):
                    index6 = (p + 1)
                    tmp5 = (((-1 if ((index6 >= len(_hx_str))) else ord(_hx_str[index6]))) == 45)
                else:
                    tmp5 = False
                if tmp5:
                    index7 = (p + 2)
                    tmp4 = (((-1 if ((index7 >= len(_hx_str))) else ord(_hx_str[index7]))) == 62)
                else:
                    tmp4 = False
                if tmp4:
                    parent.addChild(Xml.createComment(HxString.substr(_hx_str,start,(p - start))))
                    nsubs = (nsubs + 1)
                    p = (p + 2)
                    state = 1
            elif (state1 == 16):
                if (c == 91):
                    nbrackets = (nbrackets + 1)
                elif (c == 93):
                    nbrackets = (nbrackets - 1)
                elif ((c == 62) and ((nbrackets == 0))):
                    parent.addChild(Xml.createDocType(HxString.substr(_hx_str,start,(p - start))))
                    nsubs = (nsubs + 1)
                    state = 1
            elif (state1 == 17):
                tmp6 = None
                tmp7 = None
                if (c == 93):
                    index8 = (p + 1)
                    tmp7 = (((-1 if ((index8 >= len(_hx_str))) else ord(_hx_str[index8]))) == 93)
                else:
                    tmp7 = False
                if tmp7:
                    index9 = (p + 2)
                    tmp6 = (((-1 if ((index9 >= len(_hx_str))) else ord(_hx_str[index9]))) == 62)
                else:
                    tmp6 = False
                if tmp6:
                    child1 = Xml.createCData(HxString.substr(_hx_str,start,(p - start)))
                    parent.addChild(child1)
                    nsubs = (nsubs + 1)
                    p = (p + 2)
                    state = 1
            elif (state1 == 18):
                if (c == 59):
                    s5 = HxString.substr(_hx_str,start,(p - start))
                    if (((-1 if ((0 >= len(s5))) else ord(s5[0]))) == 35):
                        c6 = (Std.parseInt(("0" + HxOverrides.stringOrNull(HxString.substr(s5,1,(len(s5) - 1))))) if ((((-1 if ((1 >= len(s5))) else ord(s5[1]))) == 120)) else Std.parseInt(HxString.substr(s5,1,(len(s5) - 1))))
                        s6 = "".join(map(chr,[c6]))
                        buf.b.write(s6)
                    elif (not (s5 in haxe_xml_Parser.escapes.h)):
                        if strict:
                            raise haxe_Exception.thrown(haxe_xml_XmlParserException(("Undefined entity: " + ("null" if s5 is None else s5)),_hx_str,p))
                        s7 = Std.string((("&" + ("null" if s5 is None else s5)) + ";"))
                        buf.b.write(s7)
                    else:
                        s8 = Std.string(haxe_xml_Parser.escapes.h.get(s5,None))
                        buf.b.write(s8)
                    start = (p + 1)
                    state = escapeNext
                elif ((not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))) and ((c != 35))):
                    if strict:
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException(("Invalid character in entity: " + HxOverrides.stringOrNull("".join(map(chr,[c])))),_hx_str,p))
                    s9 = "".join(map(chr,[38]))
                    buf.b.write(s9)
                    len5 = (p - start)
                    s10 = (HxString.substr(_hx_str,start,None) if ((len5 is None)) else HxString.substr(_hx_str,start,len5))
                    buf.b.write(s10)
                    p = (p - 1)
                    start = (p + 1)
                    state = escapeNext
            else:
                pass
            p = (p + 1)
        if (state == 1):
            start = p
            state = 13
        if (state == 13):
            if (parent.nodeType == 0):
                if (parent.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((parent.nodeType is None)) else _Xml_XmlType_Impl_.toString(parent.nodeType))))))
                raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Unclosed node <" + HxOverrides.stringOrNull(parent.nodeName)) + ">"),_hx_str,p))
            if ((p != start) or ((nsubs == 0))):
                _hx_len = (p - start)
                s = (HxString.substr(_hx_str,start,None) if ((_hx_len is None)) else HxString.substr(_hx_str,start,_hx_len))
                buf.b.write(s)
                parent.addChild(Xml.createPCData(buf.b.getvalue()))
                nsubs = (nsubs + 1)
            return p
        if (((not strict) and ((state == 18))) and ((escapeNext == 13))):
            s = "".join(map(chr,[38]))
            buf.b.write(s)
            _hx_len = (p - start)
            s = (HxString.substr(_hx_str,start,None) if ((_hx_len is None)) else HxString.substr(_hx_str,start,_hx_len))
            buf.b.write(s)
            parent.addChild(Xml.createPCData(buf.b.getvalue()))
            nsubs = (nsubs + 1)
            return p
        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Unexpected end",_hx_str,p))
haxe_xml_Parser._hx_class = haxe_xml_Parser
_hx_classes["haxe.xml.Parser"] = haxe_xml_Parser


class haxe_xml_Printer:
    _hx_class_name = "haxe.xml.Printer"
    _hx_is_interface = "False"
    __slots__ = ("output", "pretty")
    _hx_fields = ["output", "pretty"]
    _hx_methods = ["writeNode", "hasChildren"]
    _hx_statics = ["print"]

    def __init__(self,pretty):
        self.output = StringBuf()
        self.pretty = pretty

    def writeNode(self,value,tabs):
        _g = value.nodeType
        if (_g == 0):
            _this = self.output
            s = Std.string((("null" if tabs is None else tabs) + "<"))
            _this.b.write(s)
            if (value.nodeType != Xml.Element):
                raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _this = self.output
            s = Std.string(value.nodeName)
            _this.b.write(s)
            attribute = value.attributes()
            while attribute.hasNext():
                attribute1 = attribute.next()
                _this = self.output
                s = Std.string(((" " + ("null" if attribute1 is None else attribute1)) + "=\""))
                _this.b.write(s)
                input = StringTools.htmlEscape(value.get(attribute1),True)
                _this1 = self.output
                s1 = Std.string(input)
                _this1.b.write(s1)
                self.output.b.write("\"")
            if self.hasChildren(value):
                self.output.b.write(">")
                if self.pretty:
                    self.output.b.write("\n")
                if ((value.nodeType != Xml.Document) and ((value.nodeType != Xml.Element))):
                    raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
                _g_current = 0
                _g_array = value.children
                while (_g_current < len(_g_array)):
                    child = _g_current
                    _g_current = (_g_current + 1)
                    child1 = (_g_array[child] if child >= 0 and child < len(_g_array) else None)
                    self.writeNode(child1,((("null" if tabs is None else tabs) + "\t") if (self.pretty) else tabs))
                _this = self.output
                s = Std.string((("null" if tabs is None else tabs) + "</"))
                _this.b.write(s)
                if (value.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
                _this = self.output
                s = Std.string(value.nodeName)
                _this.b.write(s)
                self.output.b.write(">")
                if self.pretty:
                    self.output.b.write("\n")
            else:
                self.output.b.write("/>")
                if self.pretty:
                    self.output.b.write("\n")
        elif (_g == 1):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            nodeValue = value.nodeValue
            if (len(nodeValue) != 0):
                input = (("null" if tabs is None else tabs) + HxOverrides.stringOrNull(StringTools.htmlEscape(nodeValue)))
                _this = self.output
                s = Std.string(input)
                _this.b.write(s)
                if self.pretty:
                    self.output.b.write("\n")
        elif (_g == 2):
            _this = self.output
            s = Std.string((("null" if tabs is None else tabs) + "<![CDATA["))
            _this.b.write(s)
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _this = self.output
            s = Std.string(value.nodeValue)
            _this.b.write(s)
            self.output.b.write("]]>")
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 3):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            commentContent = value.nodeValue
            commentContent = EReg("[\n\r\t]+","g").replace(commentContent,"")
            commentContent = (("<!--" + ("null" if commentContent is None else commentContent)) + "-->")
            _this = self.output
            s = Std.string(tabs)
            _this.b.write(s)
            input = StringTools.trim(commentContent)
            _this = self.output
            s = Std.string(input)
            _this.b.write(s)
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 4):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _this = self.output
            s = Std.string((("<!DOCTYPE " + HxOverrides.stringOrNull(value.nodeValue)) + ">"))
            _this.b.write(s)
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 5):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _this = self.output
            s = Std.string((("<?" + HxOverrides.stringOrNull(value.nodeValue)) + "?>"))
            _this.b.write(s)
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 6):
            if ((value.nodeType != Xml.Document) and ((value.nodeType != Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _g_current = 0
            _g_array = value.children
            while (_g_current < len(_g_array)):
                child = _g_current
                _g_current = (_g_current + 1)
                child1 = (_g_array[child] if child >= 0 and child < len(_g_array) else None)
                self.writeNode(child1,tabs)
        else:
            pass

    def hasChildren(self,value):
        if ((value.nodeType != Xml.Document) and ((value.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
        _g_current = 0
        _g_array = value.children
        while (_g_current < len(_g_array)):
            child = _g_current
            _g_current = (_g_current + 1)
            child1 = (_g_array[child] if child >= 0 and child < len(_g_array) else None)
            _g = child1.nodeType
            if ((_g == 1) or ((_g == 0))):
                return True
            elif ((_g == 3) or ((_g == 2))):
                if ((child1.nodeType == Xml.Document) or ((child1.nodeType == Xml.Element))):
                    raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((child1.nodeType is None)) else _Xml_XmlType_Impl_.toString(child1.nodeType))))))
                if (len(StringTools.ltrim(child1.nodeValue)) != 0):
                    return True
            else:
                pass
        return False

    @staticmethod
    def print(xml,pretty = None):
        if (pretty is None):
            pretty = False
        printer = haxe_xml_Printer(pretty)
        printer.writeNode(xml,"")
        return printer.output.b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.output = None
        _hx_o.pretty = None
haxe_xml_Printer._hx_class = haxe_xml_Printer
_hx_classes["haxe.xml.Printer"] = haxe_xml_Printer


class haxe_zip_Compress:
    _hx_class_name = "haxe.zip.Compress"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(s,level):
        raise haxe_exceptions_NotImplementedException("Not implemented for this platform",None,_hx_AnonObject({'fileName': "haxe/zip/Compress.hx", 'lineNumber': 39, 'className': "haxe.zip.Compress", 'methodName': "run"}))
haxe_zip_Compress._hx_class = haxe_zip_Compress
_hx_classes["haxe.zip.Compress"] = haxe_zip_Compress

class haxe_zip_Huffman(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.zip.Huffman"
    _hx_constructs = ["Found", "NeedBit", "NeedBits"]

    @staticmethod
    def Found(i):
        return haxe_zip_Huffman("Found", 0, (i,))

    @staticmethod
    def NeedBit(left,right):
        return haxe_zip_Huffman("NeedBit", 1, (left,right))

    @staticmethod
    def NeedBits(n,table):
        return haxe_zip_Huffman("NeedBits", 2, (n,table))
haxe_zip_Huffman._hx_class = haxe_zip_Huffman
_hx_classes["haxe.zip.Huffman"] = haxe_zip_Huffman


class haxe_zip_HuffTools:
    _hx_class_name = "haxe.zip.HuffTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["treeDepth", "treeCompress", "treeWalk", "treeMake", "make"]

    def __init__(self):
        pass

    def treeDepth(self,t):
        tmp = t.index
        if (tmp == 0):
            _g = t.params[0]
            return 0
        elif (tmp == 1):
            a = t.params[0]
            b = t.params[1]
            da = self.treeDepth(a)
            db = self.treeDepth(b)
            return (1 + ((da if ((da < db)) else db)))
        elif (tmp == 2):
            _g = t.params[0]
            _g = t.params[1]
            raise haxe_Exception.thrown("assert")
        else:
            pass

    def treeCompress(self,t):
        d = self.treeDepth(t)
        if (d == 0):
            return t
        if (d == 1):
            if (t.index == 1):
                a = t.params[0]
                b = t.params[1]
                return haxe_zip_Huffman.NeedBit(self.treeCompress(a),self.treeCompress(b))
            else:
                raise haxe_Exception.thrown("assert")
        size = (1 << d)
        table = list()
        _g = 0
        _g1 = size
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            table.append(haxe_zip_Huffman.Found(-1))
        self.treeWalk(table,0,0,d,t)
        return haxe_zip_Huffman.NeedBits(d,table)

    def treeWalk(self,table,p,cd,d,t):
        if (t.index == 1):
            a = t.params[0]
            b = t.params[1]
            if (d > 0):
                self.treeWalk(table,p,(cd + 1),(d - 1),a)
                self.treeWalk(table,(p | ((1 << cd))),(cd + 1),(d - 1),b)
            else:
                python_internal_ArrayImpl._set(table, p, self.treeCompress(t))
        else:
            python_internal_ArrayImpl._set(table, p, self.treeCompress(t))

    def treeMake(self,bits,maxbits,v,_hx_len):
        if (_hx_len > maxbits):
            raise haxe_Exception.thrown("Invalid huffman")
        idx = ((v << 5) | _hx_len)
        if (idx in bits.h):
            return haxe_zip_Huffman.Found(bits.h.get(idx,None))
        v = (v << 1)
        _hx_len = (_hx_len + 1)
        return haxe_zip_Huffman.NeedBit(self.treeMake(bits,maxbits,v,_hx_len),self.treeMake(bits,maxbits,(v | 1),_hx_len))

    def make(self,lengths,pos,nlengths,maxbits):
        if (nlengths == 1):
            return haxe_zip_Huffman.NeedBit(haxe_zip_Huffman.Found(0),haxe_zip_Huffman.Found(0))
        counts = list()
        tmp = list()
        if (maxbits > 32):
            raise haxe_Exception.thrown("Invalid huffman")
        _g = 0
        _g1 = maxbits
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            counts.append(0)
            tmp.append(0)
        _g = 0
        _g1 = nlengths
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p = python_internal_ArrayImpl._get(lengths, (i + pos))
            if (p >= maxbits):
                raise haxe_Exception.thrown("Invalid huffman")
            python_internal_ArrayImpl._set(counts, p, ((counts[p] if p >= 0 and p < len(counts) else None) + 1))
        code = 0
        _g = 1
        _g1 = (maxbits - 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            code = ((code + (counts[i] if i >= 0 and i < len(counts) else None)) << 1)
            python_internal_ArrayImpl._set(tmp, i, code)
        bits = haxe_ds_IntMap()
        _g = 0
        _g1 = nlengths
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            l = python_internal_ArrayImpl._get(lengths, (i + pos))
            if (l != 0):
                n = python_internal_ArrayImpl._get(tmp, (l - 1))
                python_internal_ArrayImpl._set(tmp, (l - 1), (n + 1))
                bits.set(((n << 5) | l),i)
        return self.treeCompress(haxe_zip_Huffman.NeedBit(self.treeMake(bits,maxbits,0,1),self.treeMake(bits,maxbits,1,1)))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_zip_HuffTools._hx_class = haxe_zip_HuffTools
_hx_classes["haxe.zip.HuffTools"] = haxe_zip_HuffTools


class haxe_zip__InflateImpl_Window:
    _hx_class_name = "haxe.zip._InflateImpl.Window"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "pos", "crc")
    _hx_fields = ["buffer", "pos", "crc"]
    _hx_methods = ["slide", "addBytes", "addByte", "getLastChar", "available", "checksum"]

    def __init__(self,hasCrc):
        self.crc = None
        self.buffer = haxe_io_Bytes.alloc(65536)
        self.pos = 0
        if hasCrc:
            self.crc = haxe_crypto_Adler32()

    def slide(self):
        if (self.crc is not None):
            self.crc.update(self.buffer,0,32768)
        b = haxe_io_Bytes.alloc(65536)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 - 32768)
        _hx_local_0.pos
        b.blit(0,self.buffer,32768,self.pos)
        self.buffer = b

    def addBytes(self,b,p,_hx_len):
        if ((self.pos + _hx_len) > 65536):
            self.slide()
        self.buffer.blit(self.pos,b,p,_hx_len)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + _hx_len)
        _hx_local_0.pos

    def addByte(self,c):
        if (self.pos == 65536):
            self.slide()
        self.buffer.b[self.pos] = (c & 255)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 1)
        _hx_local_1

    def getLastChar(self):
        return self.buffer.b[(self.pos - 1)]

    def available(self):
        return self.pos

    def checksum(self):
        if (self.crc is not None):
            self.crc.update(self.buffer,0,self.pos)
        return self.crc

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.pos = None
        _hx_o.crc = None
haxe_zip__InflateImpl_Window._hx_class = haxe_zip__InflateImpl_Window
_hx_classes["haxe.zip._InflateImpl.Window"] = haxe_zip__InflateImpl_Window

class haxe_zip__InflateImpl_State(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.zip._InflateImpl.State"
    _hx_constructs = ["Head", "Block", "CData", "Flat", "Crc", "Dist", "DistOne", "Done"]
haxe_zip__InflateImpl_State.Head = haxe_zip__InflateImpl_State("Head", 0, ())
haxe_zip__InflateImpl_State.Block = haxe_zip__InflateImpl_State("Block", 1, ())
haxe_zip__InflateImpl_State.CData = haxe_zip__InflateImpl_State("CData", 2, ())
haxe_zip__InflateImpl_State.Flat = haxe_zip__InflateImpl_State("Flat", 3, ())
haxe_zip__InflateImpl_State.Crc = haxe_zip__InflateImpl_State("Crc", 4, ())
haxe_zip__InflateImpl_State.Dist = haxe_zip__InflateImpl_State("Dist", 5, ())
haxe_zip__InflateImpl_State.DistOne = haxe_zip__InflateImpl_State("DistOne", 6, ())
haxe_zip__InflateImpl_State.Done = haxe_zip__InflateImpl_State("Done", 7, ())
haxe_zip__InflateImpl_State._hx_class = haxe_zip__InflateImpl_State
_hx_classes["haxe.zip._InflateImpl.State"] = haxe_zip__InflateImpl_State


class haxe_zip_InflateImpl:
    _hx_class_name = "haxe.zip.InflateImpl"
    _hx_is_interface = "False"
    __slots__ = ("nbits", "bits", "state", "isFinal", "huffman", "huffdist", "htools", "len", "dist", "needed", "output", "outpos", "input", "lengths", "window")
    _hx_fields = ["nbits", "bits", "state", "isFinal", "huffman", "huffdist", "htools", "len", "dist", "needed", "output", "outpos", "input", "lengths", "window"]
    _hx_methods = ["buildFixedHuffman", "readBytes", "getBits", "getBit", "getRevBits", "resetBits", "addBytes", "addByte", "addDistOne", "addDist", "applyHuffman", "inflateLengths", "inflateLoop"]
    _hx_statics = ["LEN_EXTRA_BITS_TBL", "LEN_BASE_VAL_TBL", "DIST_EXTRA_BITS_TBL", "DIST_BASE_VAL_TBL", "CODE_LENGTHS_POS", "FIXED_HUFFMAN", "run"]

    def __init__(self,i,header = None,crc = None):
        if (header is None):
            header = True
        if (crc is None):
            crc = True
        self.window = None
        self.lengths = None
        self.input = None
        self.outpos = None
        self.output = None
        self.needed = None
        self.dist = None
        self.len = None
        self.huffdist = None
        self.huffman = None
        self.state = None
        self.bits = None
        self.nbits = None
        self.isFinal = False
        self.htools = haxe_zip_HuffTools()
        self.huffman = self.buildFixedHuffman()
        self.huffdist = None
        self.len = 0
        self.dist = 0
        self.state = (haxe_zip__InflateImpl_State.Head if header else haxe_zip__InflateImpl_State.Block)
        self.input = i
        self.bits = 0
        self.nbits = 0
        self.needed = 0
        self.output = None
        self.outpos = 0
        self.lengths = list()
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        self.window = haxe_zip__InflateImpl_Window(crc)

    def buildFixedHuffman(self):
        if (haxe_zip_InflateImpl.FIXED_HUFFMAN is not None):
            return haxe_zip_InflateImpl.FIXED_HUFFMAN
        a = list()
        _g = 0
        while (_g < 288):
            n = _g
            _g = (_g + 1)
            a.append((8 if ((n <= 143)) else (9 if ((n <= 255)) else (7 if ((n <= 279)) else 8))))
        haxe_zip_InflateImpl.FIXED_HUFFMAN = self.htools.make(a,0,288,10)
        return haxe_zip_InflateImpl.FIXED_HUFFMAN

    def readBytes(self,b,pos,_hx_len):
        self.needed = _hx_len
        self.outpos = pos
        self.output = b
        if (_hx_len > 0):
            while self.inflateLoop():
                pass
        return (_hx_len - self.needed)

    def getBits(self,n):
        while (self.nbits < n):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.bits
            _hx_local_0.bits = (_hx_local_1 | ((self.input.readByte() << self.nbits)))
            _hx_local_0.bits
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.nbits
            _hx_local_2.nbits = (_hx_local_3 + 8)
            _hx_local_2.nbits
        b = (self.bits & ((((1 << n)) - 1)))
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.nbits
        _hx_local_4.nbits = (_hx_local_5 - n)
        _hx_local_4.nbits
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.bits
        _hx_local_6.bits = (_hx_local_7 >> n)
        _hx_local_6.bits
        return b

    def getBit(self):
        if (self.nbits == 0):
            self.nbits = 8
            self.bits = self.input.readByte()
        b = (((self.bits & 1)) == 1)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nbits
        _hx_local_0.nbits = (_hx_local_1 - 1)
        _hx_local_1
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.bits
        _hx_local_2.bits = (_hx_local_3 >> 1)
        _hx_local_2.bits
        return b

    def getRevBits(self,n):
        if (n == 0):
            return 0
        elif self.getBit():
            return ((1 << ((n - 1))) | self.getRevBits((n - 1)))
        else:
            return self.getRevBits((n - 1))

    def resetBits(self):
        self.bits = 0
        self.nbits = 0

    def addBytes(self,b,p,_hx_len):
        self.window.addBytes(b,p,_hx_len)
        self.output.blit(self.outpos,b,p,_hx_len)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.needed
        _hx_local_0.needed = (_hx_local_1 - _hx_len)
        _hx_local_0.needed
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.outpos
        _hx_local_2.outpos = (_hx_local_3 + _hx_len)
        _hx_local_2.outpos

    def addByte(self,b):
        self.window.addByte(b)
        self.output.b[self.outpos] = (b & 255)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.needed
        _hx_local_0.needed = (_hx_local_1 - 1)
        _hx_local_1
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.outpos
        _hx_local_2.outpos = (_hx_local_3 + 1)
        _hx_local_3

    def addDistOne(self,n):
        c = self.window.getLastChar()
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.addByte(c)

    def addDist(self,d,_hx_len):
        self.addBytes(self.window.buffer,(self.window.pos - d),_hx_len)

    def applyHuffman(self,h):
        tmp = h.index
        if (tmp == 0):
            n = h.params[0]
            return n
        elif (tmp == 1):
            a = h.params[0]
            b = h.params[1]
            return self.applyHuffman((b if (self.getBit()) else a))
        elif (tmp == 2):
            n = h.params[0]
            tbl = h.params[1]
            return self.applyHuffman(python_internal_ArrayImpl._get(tbl, self.getBits(n)))
        else:
            pass

    def inflateLengths(self,a,_hx_max):
        i = 0
        prev = 0
        while (i < _hx_max):
            n = self.applyHuffman(self.huffman)
            n1 = n
            if ((((((((((((((((n1 == 15) or ((n1 == 14))) or ((n1 == 13))) or ((n1 == 12))) or ((n1 == 11))) or ((n1 == 10))) or ((n1 == 9))) or ((n1 == 8))) or ((n1 == 7))) or ((n1 == 6))) or ((n1 == 5))) or ((n1 == 4))) or ((n1 == 3))) or ((n1 == 2))) or ((n1 == 1))) or ((n1 == 0))):
                prev = n
                python_internal_ArrayImpl._set(a, i, n)
                i = (i + 1)
            elif (n1 == 16):
                end = ((i + 3) + self.getBits(2))
                if (end > _hx_max):
                    raise haxe_Exception.thrown("Invalid data")
                while (i < end):
                    python_internal_ArrayImpl._set(a, i, prev)
                    i = (i + 1)
            elif (n1 == 17):
                i = (i + ((3 + self.getBits(3))))
                if (i > _hx_max):
                    raise haxe_Exception.thrown("Invalid data")
            elif (n1 == 18):
                i = (i + ((11 + self.getBits(7))))
                if (i > _hx_max):
                    raise haxe_Exception.thrown("Invalid data")
            else:
                raise haxe_Exception.thrown("Invalid data")

    def inflateLoop(self):
        tmp = self.state.index
        if (tmp == 0):
            cmf = self.input.readByte()
            cm = (cmf & 15)
            cinfo = (cmf >> 4)
            if (cm != 8):
                raise haxe_Exception.thrown("Invalid data")
            flg = self.input.readByte()
            fdict = (((flg & 32)) != 0)
            if (HxOverrides.mod(((((cmf << 8)) + flg)), 31) != 0):
                raise haxe_Exception.thrown("Invalid data")
            if fdict:
                raise haxe_Exception.thrown("Unsupported dictionary")
            self.state = haxe_zip__InflateImpl_State.Block
            return True
        elif (tmp == 1):
            self.isFinal = self.getBit()
            _g = self.getBits(2)
            if (_g == 0):
                self.len = self.input.readUInt16()
                nlen = self.input.readUInt16()
                if (nlen != ((65535 - self.len))):
                    raise haxe_Exception.thrown("Invalid data")
                self.state = haxe_zip__InflateImpl_State.Flat
                r = self.inflateLoop()
                self.resetBits()
                return r
            elif (_g == 1):
                self.huffman = self.buildFixedHuffman()
                self.huffdist = None
                self.state = haxe_zip__InflateImpl_State.CData
                return True
            elif (_g == 2):
                hlit = (self.getBits(5) + 257)
                hdist = (self.getBits(5) + 1)
                hclen = (self.getBits(4) + 4)
                _g = 0
                _g1 = hclen
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    python_internal_ArrayImpl._set(self.lengths, python_internal_ArrayImpl._get(haxe_zip_InflateImpl.CODE_LENGTHS_POS, i), self.getBits(3))
                _g = hclen
                _g1 = 19
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    python_internal_ArrayImpl._set(self.lengths, python_internal_ArrayImpl._get(haxe_zip_InflateImpl.CODE_LENGTHS_POS, i), 0)
                self.huffman = self.htools.make(self.lengths,0,19,8)
                lengths = list()
                _g = 0
                _g1 = (hlit + hdist)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    lengths.append(0)
                self.inflateLengths(lengths,(hlit + hdist))
                self.huffdist = self.htools.make(lengths,hlit,hdist,16)
                self.huffman = self.htools.make(lengths,0,hlit,16)
                self.state = haxe_zip__InflateImpl_State.CData
                return True
            else:
                raise haxe_Exception.thrown("Invalid data")
        elif (tmp == 2):
            n = self.applyHuffman(self.huffman)
            if (n < 256):
                self.addByte(n)
                return (self.needed > 0)
            elif (n == 256):
                self.state = (haxe_zip__InflateImpl_State.Crc if (self.isFinal) else haxe_zip__InflateImpl_State.Block)
                return True
            else:
                n = (n - 257)
                extra_bits = python_internal_ArrayImpl._get(haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL, n)
                if (extra_bits == -1):
                    raise haxe_Exception.thrown("Invalid data")
                self.len = (python_internal_ArrayImpl._get(haxe_zip_InflateImpl.LEN_BASE_VAL_TBL, n) + self.getBits(extra_bits))
                dist_code = (self.getRevBits(5) if ((self.huffdist is None)) else self.applyHuffman(self.huffdist))
                extra_bits = python_internal_ArrayImpl._get(haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL, dist_code)
                if (extra_bits == -1):
                    raise haxe_Exception.thrown("Invalid data")
                self.dist = (python_internal_ArrayImpl._get(haxe_zip_InflateImpl.DIST_BASE_VAL_TBL, dist_code) + self.getBits(extra_bits))
                if (self.dist > self.window.available()):
                    raise haxe_Exception.thrown("Invalid data")
                self.state = (haxe_zip__InflateImpl_State.DistOne if ((self.dist == 1)) else haxe_zip__InflateImpl_State.Dist)
                return True
        elif (tmp == 3):
            rlen = (self.len if ((self.len < self.needed)) else self.needed)
            _hx_bytes = self.input.read(rlen)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.len
            _hx_local_1.len = (_hx_local_2 - rlen)
            _hx_local_1.len
            self.addBytes(_hx_bytes,0,rlen)
            if (self.len == 0):
                self.state = (haxe_zip__InflateImpl_State.Crc if (self.isFinal) else haxe_zip__InflateImpl_State.Block)
            return (self.needed > 0)
        elif (tmp == 4):
            calc = self.window.checksum()
            if (calc is None):
                self.state = haxe_zip__InflateImpl_State.Done
                return True
            crc = haxe_crypto_Adler32.read(self.input)
            if (not calc.equals(crc)):
                raise haxe_Exception.thrown("Invalid CRC")
            self.state = haxe_zip__InflateImpl_State.Done
            return True
        elif (tmp == 5):
            while ((self.len > 0) and ((self.needed > 0))):
                rdist = (self.len if ((self.len < self.dist)) else self.dist)
                rlen = (self.needed if ((self.needed < rdist)) else rdist)
                self.addDist(self.dist,rlen)
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.len
                _hx_local_3.len = (_hx_local_4 - rlen)
                _hx_local_3.len
            if (self.len == 0):
                self.state = haxe_zip__InflateImpl_State.CData
            return (self.needed > 0)
        elif (tmp == 6):
            rlen = (self.len if ((self.len < self.needed)) else self.needed)
            self.addDistOne(rlen)
            _hx_local_5 = self
            _hx_local_6 = _hx_local_5.len
            _hx_local_5.len = (_hx_local_6 - rlen)
            _hx_local_5.len
            if (self.len == 0):
                self.state = haxe_zip__InflateImpl_State.CData
            return (self.needed > 0)
        elif (tmp == 7):
            return False
        else:
            pass

    @staticmethod
    def run(i,bufsize = None):
        if (bufsize is None):
            bufsize = 65536
        buf = haxe_io_Bytes.alloc(bufsize)
        output = haxe_io_BytesBuffer()
        inflate = haxe_zip_InflateImpl(i)
        while True:
            _hx_len = inflate.readBytes(buf,0,bufsize)
            if ((_hx_len < 0) or ((_hx_len > buf.length))):
                raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
            output.b.extend(buf.b[0:_hx_len])
            if (_hx_len < bufsize):
                break
        return output.getBytes()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nbits = None
        _hx_o.bits = None
        _hx_o.state = None
        _hx_o.isFinal = None
        _hx_o.huffman = None
        _hx_o.huffdist = None
        _hx_o.htools = None
        _hx_o.len = None
        _hx_o.dist = None
        _hx_o.needed = None
        _hx_o.output = None
        _hx_o.outpos = None
        _hx_o.input = None
        _hx_o.lengths = None
        _hx_o.window = None
haxe_zip_InflateImpl._hx_class = haxe_zip_InflateImpl
_hx_classes["haxe.zip.InflateImpl"] = haxe_zip_InflateImpl


class haxe_zip_Uncompress:
    _hx_class_name = "haxe.zip.Uncompress"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(src,bufsize = None):
        return haxe_zip_InflateImpl.run(haxe_io_BytesInput(src),bufsize)
haxe_zip_Uncompress._hx_class = haxe_zip_Uncompress
_hx_classes["haxe.zip.Uncompress"] = haxe_zip_Uncompress


class hxd_BitmapInnerDataImpl:
    _hx_class_name = "hxd.BitmapInnerDataImpl"
    _hx_is_interface = "False"
    __slots__ = ("pixels", "width", "height")
    _hx_fields = ["pixels", "width", "height"]

    def __init__(self):
        self.height = None
        self.width = None
        self.pixels = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pixels = None
        _hx_o.width = None
        _hx_o.height = None
hxd_BitmapInnerDataImpl._hx_class = hxd_BitmapInnerDataImpl
_hx_classes["hxd.BitmapInnerDataImpl"] = hxd_BitmapInnerDataImpl


class hxd_BitmapData:
    _hx_class_name = "hxd.BitmapData"
    _hx_is_interface = "False"
    __slots__ = ("data",)
    _hx_fields = ["data"]
    _hx_methods = ["clear", "fill", "draw", "drawScaled", "line", "dispose", "clone", "sub", "lock", "unlock", "getPixel", "setPixel", "get_width", "get_height", "getPixels", "setPixels", "toNative", "toPNG"]
    _hx_statics = ["notImplemented", "fromNative"]

    def __init__(self,width,height):
        self.data = None
        if (not (((width == -101) and ((height == -102))))):
            self.data = hxd_BitmapInnerDataImpl()
            this1 = [None]*(width * height)
            self.data.pixels = this1
            self.data.width = width
            self.data.height = height

    def clear(self,color):
        self.fill(0,0,self.data.width,self.data.height,color)

    def fill(self,x,y,width,height,color):
        if (x < 0):
            width = (width + x)
            x = 0
        if (y < 0):
            height = (height + y)
            y = 0
        if ((x + width) > self.data.width):
            width = (self.data.width - x)
        if ((y + height) > self.data.height):
            height = (self.data.height - y)
        _g = 0
        _g1 = height
        while (_g < _g1):
            dy = _g
            _g = (_g + 1)
            p = (x + ((((y + dy)) * self.data.width)))
            _g2 = 0
            _g3 = width
            while (_g2 < _g3):
                dx = _g2
                _g2 = (_g2 + 1)
                index = p
                p = (p + 1)
                self.data.pixels[index] = color

    def draw(self,x,y,src,srcX,srcY,width,height,blendMode = None):
        raise haxe_Exception.thrown("Not implemented")

    def drawScaled(self,x,y,width,height,src,srcX,srcY,srcWidth,srcHeight,blendMode = None,smooth = None):
        if (smooth is None):
            smooth = True
        if (blendMode is None):
            blendMode = h2d_BlendMode.Alpha
        raise haxe_Exception.thrown("Not implemented")

    def line(self,x0,y0,x1,y1,color):
        dx = (x1 - x0)
        dy = (y1 - y0)
        if (dx == 0):
            if (y1 < y0):
                tmp = y0
                y0 = y1
                y1 = tmp
            if (y0 < 0):
                y0 = 0
            if (y1 > ((self.data.height - 1))):
                y1 = (self.data.height - 1)
            _g = y0
            _g1 = (y1 + 1)
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                self.setPixel(x0,y,color)
        elif (dy == 0):
            if (x1 < x0):
                tmp = x0
                x0 = x1
                x1 = tmp
            if (x0 < 0):
                x0 = 0
            if (x1 > ((self.data.width - 1))):
                x1 = (self.data.width - 1)
            _g = x0
            _g1 = (x1 + 1)
            while (_g < _g1):
                x = _g
                _g = (_g + 1)
                self.setPixel(x,y0,color)
        else:
            sx = None
            sy = None
            clip_x0 = None
            clip_y0 = None
            clip_x1 = None
            clip_y1 = None
            if (x0 < x1):
                if ((x0 >= self.data.width) or ((x1 < 0))):
                    return
                sx = 1
                clip_x0 = 0
                clip_x1 = (self.data.width - 1)
            else:
                if ((x1 >= self.data.width) or ((x0 < 0))):
                    return
                sx = -1
                x1 = -x1
                x0 = -x0
                clip_x0 = (1 - self.data.width)
                clip_x1 = 0
            if (y0 < y1):
                if ((y0 >= self.data.height) or ((y1 < 0))):
                    return
                sy = 1
                clip_y0 = 0
                clip_y1 = (self.data.height - 1)
            else:
                if ((y1 >= self.data.width) or ((y0 < 0))):
                    return
                sy = -1
                y1 = -y1
                y0 = -y0
                clip_y0 = (1 - self.data.height)
                clip_y1 = 0
            dx = (x1 - x0)
            dy = (y1 - y0)
            d2x = (dx << 1)
            d2y = (dy << 1)
            x = x0
            y = y0
            if (dx >= dy):
                delta = (d2y - dx)
                tracing_can_start = False
                if (y0 < clip_y0):
                    temp = d2x
                    temp = ((temp * ((clip_y0 - y0))) - dx)
                    xinc = (temp / d2y)
                    x2 = None
                    try:
                        x2 = int(xinc)
                    except BaseException as _g:
                        None
                        x2 = None
                    x = (x + x2)
                    if (x > clip_x1):
                        return
                    if (x >= clip_x0):
                        temp = (temp - ((xinc * d2y)))
                        delta1 = None
                        try:
                            delta1 = int(temp)
                        except BaseException as _g:
                            None
                            delta1 = None
                        delta = (delta - ((delta1 + dx)))
                        y = clip_y0
                        if (temp > 0):
                            x = (x + 1)
                            delta = (delta + d2y)
                        tracing_can_start = True
                if ((not tracing_can_start) and ((x0 < clip_x0))):
                    temp = d2y
                    temp = (temp * ((clip_x0 - x0)))
                    yinc = (temp / d2x)
                    y2 = None
                    try:
                        y2 = int(yinc)
                    except BaseException as _g:
                        None
                        y2 = None
                    y = (y + y2)
                    temp = HxOverrides.modf(temp, d2x)
                    if ((y > clip_y1) or (((y == clip_y1) and ((temp > dx))))):
                        return
                    x = clip_x0
                    delta1 = None
                    try:
                        delta1 = int(temp)
                    except BaseException as _g:
                        None
                        delta1 = None
                    delta = (delta + delta1)
                    if (temp >= dx):
                        y = (y + 1)
                        delta = (delta - d2x)
                xend = x1
                if (y1 > clip_y1):
                    temp = d2x
                    temp = ((temp * ((clip_y1 - y1))) + dx)
                    xinc = (temp / d2y)
                    xend1 = None
                    try:
                        xend1 = int(xinc)
                    except BaseException as _g:
                        None
                        xend1 = None
                    xend = (xend + xend1)
                    if ((temp - ((xinc * d2y))) == 0):
                        xend = (xend - 1)
                if (xend > clip_x1):
                    xend = (clip_x1 + 1)
                else:
                    xend = (xend + 1)
                if (sx == -1):
                    x = -x
                    xend = -xend
                if (sy == -1):
                    y = -y
                d2x = (d2x - d2y)
                while (x != xend):
                    self.setPixel(x,y,color)
                    if (delta >= 0):
                        y = (y + sy)
                        delta = (delta - d2x)
                    else:
                        delta = (delta + d2y)
                    x = (x + sx)
            else:
                delta = (d2x - dy)
                tracing_can_start = False
                if (x0 < clip_x0):
                    temp = d2y
                    temp = ((temp * ((clip_x0 - x0))) - dy)
                    yinc = (temp / d2x)
                    y2 = None
                    try:
                        y2 = int(yinc)
                    except BaseException as _g:
                        None
                        y2 = None
                    y = (y + y2)
                    if (y > clip_y1):
                        return
                    if (y >= clip_y0):
                        temp = (temp - ((yinc * d2x)))
                        delta1 = None
                        try:
                            delta1 = int(temp)
                        except BaseException as _g:
                            None
                            delta1 = None
                        delta = (delta - ((delta1 + dy)))
                        x = clip_x0
                        if (temp > 0):
                            y = (y + 1)
                            delta = (delta + d2x)
                        tracing_can_start = True
                if ((not tracing_can_start) and ((y0 < clip_y0))):
                    temp = d2x
                    temp = (temp * ((clip_y0 - y0)))
                    xinc = (temp / d2y)
                    x2 = None
                    try:
                        x2 = int(xinc)
                    except BaseException as _g:
                        None
                        x2 = None
                    x = (x + x2)
                    temp = HxOverrides.modf(temp, d2y)
                    if ((x > clip_x1) or (((x == clip_x1) and ((temp > dy))))):
                        return
                    y = clip_y0
                    delta1 = None
                    try:
                        delta1 = int(temp)
                    except BaseException as _g:
                        None
                        delta1 = None
                    delta = (delta + delta1)
                    if (temp >= dy):
                        x = (x + 1)
                        delta = (delta - d2y)
                yend = y1
                if (x1 > clip_x1):
                    temp = d2y
                    temp = ((temp * ((clip_x1 - x1))) + dy)
                    yinc = (temp / d2x)
                    yend1 = None
                    try:
                        yend1 = int(yinc)
                    except BaseException as _g:
                        None
                        yend1 = None
                    yend = (yend + yend1)
                    if ((temp - ((yinc * d2x))) == 0):
                        yend = (yend - 1)
                if (yend > clip_y1):
                    yend = (clip_y1 + 1)
                else:
                    yend = (yend + 1)
                if (sx == -1):
                    x = -x
                if (sy == -1):
                    y = -y
                    yend = -yend
                d2y = (d2y - d2x)
                while (y != yend):
                    self.setPixel(x,y,color)
                    if (delta >= 0):
                        x = (x + sx)
                        delta = (delta - d2y)
                    else:
                        delta = (delta + d2x)
                    y = (y + sy)

    def dispose(self):
        self.data = None

    def clone(self):
        return self.sub(0,0,self.data.width,self.data.height)

    def sub(self,x,y,w,h):
        if ((((((x < 0) or ((y < 0))) or ((w < 0))) or ((h < 0))) or (((x + w) > self.data.width))) or (((y + h) > self.data.height))):
            raise haxe_Exception.thrown("Outside bounds")
        b = hxd_BitmapInnerDataImpl()
        b.width = w
        b.height = h
        this1 = [None]*(w * h)
        b.pixels = this1
        _g = 0
        _g1 = h
        while (_g < _g1):
            dy = _g
            _g = (_g + 1)
            haxe_ds__Vector_Vector_Impl_.blit(self.data.pixels,(x + ((((y + dy)) * self.data.width))),b.pixels,(dy * w),w)
        return hxd_BitmapData.fromNative(b)

    def lock(self):
        pass

    def unlock(self):
        pass

    def getPixel(self,x,y):
        if ((((x >= 0) and ((y >= 0))) and ((x < self.data.width))) and ((y < self.data.height))):
            return self.data.pixels[(x + ((y * self.data.width)))]
        else:
            return 0

    def setPixel(self,x,y,c):
        if ((((x >= 0) and ((y >= 0))) and ((x < self.data.width))) and ((y < self.data.height))):
            self.data.pixels[(x + ((y * self.data.width)))] = c

    def get_width(self):
        return self.data.width

    def get_height(self):
        return self.data.height

    def getPixels(self):
        out = haxe_io_Bytes.alloc(((self.data.width * self.data.height) * 4))
        _g = 0
        _g1 = (self.data.width * self.data.height)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = self.data.pixels[i]
            out.b[pos] = (v & 255)
            out.b[(pos + 1)] = ((v >> 8) & 255)
            out.b[(pos + 2)] = ((v >> 16) & 255)
            out.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        return hxd_Pixels(self.data.width,self.data.height,out,hxd_PixelFormat.BGRA)

    def setPixels(self,pixels):
        if ((pixels.width != self.data.width) or ((pixels.height != self.data.height))):
            raise haxe_Exception.thrown("Invalid pixels size")
        pixels.setFlip(False)
        pixels.convert(hxd_PixelFormat.BGRA)
        src = pixels.bytes
        _g = 0
        _g1 = (self.data.width * self.data.height)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            this1 = self.data.pixels
            pos = (i << 2)
            v = (((src.b[pos] | ((src.b[(pos + 1)] << 8))) | ((src.b[(pos + 2)] << 16))) | ((src.b[(pos + 3)] << 24)))
            val = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            this1[i] = val

    def toNative(self):
        return self.data

    def toPNG(self):
        pixels = self.getPixels()
        png = pixels.toPNG()
        pixels.dispose()
        return png

    @staticmethod
    def notImplemented():
        raise haxe_Exception.thrown("Not implemented")

    @staticmethod
    def fromNative(data):
        b = hxd_BitmapData(-101,-102)
        b.data = data
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
hxd_BitmapData._hx_class = hxd_BitmapData
_hx_classes["hxd.BitmapData"] = hxd_BitmapData


class hxd_Charset:
    _hx_class_name = "hxd.Charset"
    _hx_is_interface = "False"
    __slots__ = ("map",)
    _hx_fields = ["map"]
    _hx_methods = ["resolveChar", "isCJK", "isSpace", "isBreakChar", "isComplementChar"]
    _hx_statics = ["ASCII", "LATIN1", "CYRILLIC", "POLISH", "TURKISH", "JP_KANA", "UNICODE_SPECIALS", "DEFAULT_CHARS", "complementChars", "inst", "getDefault"]

    def __init__(self):
        self.map = None
        _gthis = self
        self.map = haxe_ds_IntMap()
        _g = 0
        while (_g < 94):
            i = _g
            _g = (_g + 1)
            _gthis.map.set((65281 + i),(33 + i))
        _g = 192
        _g1 = 199
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,65)
        _g = 224
        _g1 = 231
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,97)
        _g = 200
        _g1 = 204
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,69)
        _g = 232
        _g1 = 236
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,101)
        _g = 204
        _g1 = 208
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,73)
        _g = 236
        _g1 = 240
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,105)
        _g = 210
        _g1 = 215
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,79)
        _g = 242
        _g1 = 247
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,111)
        _g = 217
        _g1 = 221
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,85)
        _g = 249
        _g1 = 253
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,117)
        _gthis.map.set(199,67)
        _gthis.map.set(231,67)
        _gthis.map.set(208,68)
        _gthis.map.set(222,100)
        _gthis.map.set(209,78)
        _gthis.map.set(241,110)
        _gthis.map.set(221,89)
        _gthis.map.set(253,121)
        _gthis.map.set(255,121)
        _gthis.map.set(8364,69)
        _gthis.map.set(12288,32)
        _gthis.map.set(160,32)
        _gthis.map.set(171,34)
        _gthis.map.set(187,34)
        _gthis.map.set(8220,34)
        _gthis.map.set(8221,34)
        _gthis.map.set(8216,39)
        _gthis.map.set(8217,39)
        _gthis.map.set(180,39)
        _gthis.map.set(8216,39)
        _gthis.map.set(8249,60)
        _gthis.map.set(8250,62)
        _gthis.map.set(8211,45)

    def resolveChar(self,code,glyphs):
        c = code
        while (c is not None):
            g = glyphs.h.get(c,None)
            if (g is not None):
                return g
            c = self.map.h.get(c,None)
        return None

    def isCJK(self,code):
        if (not ((((code >= 11904) and ((code <= 42191))) or (((code >= 63744) and ((code <= 64255))))))):
            if (code >= 131072):
                return (code <= 262141)
            else:
                return False
        else:
            return True

    def isSpace(self,code):
        if (code != 32):
            return (code == 12288)
        else:
            return True

    def isBreakChar(self,code):
        if (not self.isSpace(code)):
            return self.isCJK(code)
        else:
            return True

    def isComplementChar(self,code):
        return (code in hxd_Charset.complementChars.h)
    inst = None

    @staticmethod
    def getDefault():
        if (hxd_Charset.inst is None):
            hxd_Charset.inst = hxd_Charset()
        return hxd_Charset.inst

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.map = None
hxd_Charset._hx_class = hxd_Charset
_hx_classes["hxd.Charset"] = hxd_Charset

class hxd_Cursor(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.Cursor"
    _hx_constructs = ["Default", "Button", "Move", "TextInput", "Hide", "Custom", "Callback"]

    @staticmethod
    def Custom(custom):
        return hxd_Cursor("Custom", 5, (custom,))

    @staticmethod
    def Callback(f):
        return hxd_Cursor("Callback", 6, (f,))
hxd_Cursor.Default = hxd_Cursor("Default", 0, ())
hxd_Cursor.Button = hxd_Cursor("Button", 1, ())
hxd_Cursor.Move = hxd_Cursor("Move", 2, ())
hxd_Cursor.TextInput = hxd_Cursor("TextInput", 3, ())
hxd_Cursor.Hide = hxd_Cursor("Hide", 4, ())
hxd_Cursor._hx_class = hxd_Cursor
_hx_classes["hxd.Cursor"] = hxd_Cursor


class hxd_CustomCursor:
    _hx_class_name = "hxd.CustomCursor"
    _hx_is_interface = "False"
    __slots__ = ("frames", "speed", "offsetX", "offsetY", "alloc")
    _hx_fields = ["frames", "speed", "offsetX", "offsetY", "alloc"]
    _hx_methods = ["dispose"]

    def __init__(self,frames,speed,offsetX,offsetY):
        self.alloc = None
        self.frames = frames
        self.speed = speed
        self.offsetX = offsetX
        self.offsetY = offsetY

    def dispose(self):
        _g = 0
        _g1 = self.frames
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f.data = None
        self.frames = []
        if (self.alloc is not None):
            raise haxe_Exception.thrown("TODO")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.frames = None
        _hx_o.speed = None
        _hx_o.offsetX = None
        _hx_o.offsetY = None
        _hx_o.alloc = None
hxd_CustomCursor._hx_class = hxd_CustomCursor
_hx_classes["hxd.CustomCursor"] = hxd_CustomCursor

class hxd_EventKind(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.EventKind"
    _hx_constructs = ["EPush", "ERelease", "EMove", "EOver", "EOut", "EWheel", "EFocus", "EFocusLost", "EKeyDown", "EKeyUp", "EReleaseOutside", "ETextInput", "ECheck"]
hxd_EventKind.EPush = hxd_EventKind("EPush", 0, ())
hxd_EventKind.ERelease = hxd_EventKind("ERelease", 1, ())
hxd_EventKind.EMove = hxd_EventKind("EMove", 2, ())
hxd_EventKind.EOver = hxd_EventKind("EOver", 3, ())
hxd_EventKind.EOut = hxd_EventKind("EOut", 4, ())
hxd_EventKind.EWheel = hxd_EventKind("EWheel", 5, ())
hxd_EventKind.EFocus = hxd_EventKind("EFocus", 6, ())
hxd_EventKind.EFocusLost = hxd_EventKind("EFocusLost", 7, ())
hxd_EventKind.EKeyDown = hxd_EventKind("EKeyDown", 8, ())
hxd_EventKind.EKeyUp = hxd_EventKind("EKeyUp", 9, ())
hxd_EventKind.EReleaseOutside = hxd_EventKind("EReleaseOutside", 10, ())
hxd_EventKind.ETextInput = hxd_EventKind("ETextInput", 11, ())
hxd_EventKind.ECheck = hxd_EventKind("ECheck", 12, ())
hxd_EventKind._hx_class = hxd_EventKind
_hx_classes["hxd.EventKind"] = hxd_EventKind


class hxd_Event:
    _hx_class_name = "hxd.Event"
    _hx_is_interface = "False"
    __slots__ = ("kind", "relX", "relY", "relZ", "propagate", "cancel", "button", "touchId", "keyCode", "charCode", "wheelDelta")
    _hx_fields = ["kind", "relX", "relY", "relZ", "propagate", "cancel", "button", "touchId", "keyCode", "charCode", "wheelDelta"]
    _hx_methods = ["toString"]

    def __init__(self,k,x = None,y = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        self.wheelDelta = None
        self.charCode = None
        self.keyCode = None
        self.touchId = None
        self.cancel = None
        self.propagate = None
        self.relZ = None
        self.button = 0
        self.kind = k
        self.relX = x
        self.relY = y

    def toString(self):
        tmp = (Std.string(self.kind) + "[")
        x = self.relX
        tmp1 = None
        try:
            tmp1 = int(x)
        except BaseException as _g:
            None
            tmp1 = None
        tmp2 = ((("null" if tmp is None else tmp) + Std.string(tmp1)) + ",")
        x = self.relY
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        tmp1 = ((("null" if tmp2 is None else tmp2) + Std.string(tmp)) + "]")
        tmp = None
        tmp2 = self.kind.index
        if (tmp2 == 5):
            tmp = (",wheelDelta=" + Std.string(self.wheelDelta))
        elif ((((((tmp2 == 12) or ((tmp2 == 7))) or ((tmp2 == 6))) or ((tmp2 == 4))) or ((tmp2 == 3))) or ((tmp2 == 2))):
            tmp = ""
        elif ((tmp2 == 9) or ((tmp2 == 8))):
            tmp = (",keyCode=" + Std.string(self.keyCode))
        elif (((tmp2 == 10) or ((tmp2 == 1))) or ((tmp2 == 0))):
            tmp = (",button=" + Std.string(self.button))
        elif (tmp2 == 11):
            tmp = (",charCode=" + Std.string(self.charCode))
        else:
            pass
        return (("null" if tmp1 is None else tmp1) + ("null" if tmp is None else tmp))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.kind = None
        _hx_o.relX = None
        _hx_o.relY = None
        _hx_o.relZ = None
        _hx_o.propagate = None
        _hx_o.cancel = None
        _hx_o.button = None
        _hx_o.touchId = None
        _hx_o.keyCode = None
        _hx_o.charCode = None
        _hx_o.wheelDelta = None
hxd_Event._hx_class = hxd_Event
_hx_classes["hxd.Event"] = hxd_Event


class hxd_File:
    _hx_class_name = "hxd.File"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["browse", "saveAs", "exists", "delete", "listDirectory", "getBytes", "saveBytes", "load", "createDirectory", "applicationPath"]

    @staticmethod
    def browse(onSelect,options = None):
        if (options is None):
            options = _hx_AnonObject({})
        raise haxe_Exception.thrown("Not supported")

    @staticmethod
    def saveAs(dataContent,options = None):
        if (options is None):
            options = _hx_AnonObject({})
        raise haxe_Exception.thrown("Not supported")

    @staticmethod
    def exists(path):
        return sys_FileSystem.exists(path)

    @staticmethod
    def delete(path):
        try:
            sys_FileSystem.deleteFile(path)
        except BaseException as _g:
            None

    @staticmethod
    def listDirectory(path):
        return sys_FileSystem.readDirectory(path)

    @staticmethod
    def getBytes(path):
        return sys_io_File.getBytes(path)

    @staticmethod
    def saveBytes(path,data):
        sys_io_File.saveBytes(path,data)

    @staticmethod
    def load(path,onLoad,onError = None):
        if (onError is None):
            def _hx_local_0(_):
                pass
            onError = _hx_local_0
        content = None
        try:
            content = sys_io_File.getBytes(path)
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            if (onError is not None):
                onError(("" + Std.string(e)))
            return
        onLoad(content)

    @staticmethod
    def createDirectory(path):
        sys_FileSystem.createDirectory(path)

    @staticmethod
    def applicationPath():
        raise haxe_Exception.thrown("Not supported")
hxd_File._hx_class = hxd_File
_hx_classes["hxd.File"] = hxd_File


class hxd__FloatBuffer_InnerIterator:
    _hx_class_name = "hxd._FloatBuffer.InnerIterator"
    _hx_is_interface = "False"
    __slots__ = ("b", "len", "pos")
    _hx_fields = ["b", "len", "pos"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,b):
        self.pos = None
        self.len = None
        self.b = b
        self.len = len(self.b)
        self.pos = 0

    def hasNext(self):
        return (self.pos < self.len)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.b, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.len = None
        _hx_o.pos = None
hxd__FloatBuffer_InnerIterator._hx_class = hxd__FloatBuffer_InnerIterator
_hx_classes["hxd._FloatBuffer.InnerIterator"] = hxd__FloatBuffer_InnerIterator


class hxd__FloatBuffer_FloatBuffer_Impl_:
    _hx_class_name = "hxd._FloatBuffer.FloatBuffer_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "push", "grow", "resize", "arrayRead", "arrayWrite", "getNative", "iterator", "get_length"]
    length = None

    @staticmethod
    def _new(length = None):
        if (length is None):
            length = 0
        this1 = list()
        if (length > 0):
            if (length > len(this1)):
                python_internal_ArrayImpl._set(this1, (length - 1), 0.)
        return this1

    @staticmethod
    def push(this1,v):
        this1.append(v)

    @staticmethod
    def grow(this1,v):
        if (v > len(this1)):
            python_internal_ArrayImpl._set(this1, (v - 1), 0.)

    @staticmethod
    def resize(this1,v):
        if (len(this1) > v):
            _hx_len = (len(this1) - v)
            pos = v
            if (pos < 0):
                pos = (len(this1) + pos)
            if (pos < 0):
                pos = 0
            res = this1[pos:(pos + _hx_len)]
            del this1[pos:(pos + _hx_len)]
        elif (v > len(this1)):
            python_internal_ArrayImpl._set(this1, (v - 1), 0.)

    @staticmethod
    def arrayRead(this1,key):
        return (this1[key] if key >= 0 and key < len(this1) else None)

    @staticmethod
    def arrayWrite(this1,key,value):
        def _hx_local_1():
            def _hx_local_0():
                python_internal_ArrayImpl._set(this1, key, value)
                return (this1[key] if key >= 0 and key < len(this1) else None)
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def getNative(this1):
        return this1

    @staticmethod
    def iterator(this1):
        return hxd__FloatBuffer_InnerIterator(this1)

    @staticmethod
    def get_length(this1):
        return len(this1)
hxd__FloatBuffer_FloatBuffer_Impl_._hx_class = hxd__FloatBuffer_FloatBuffer_Impl_
_hx_classes["hxd._FloatBuffer.FloatBuffer_Impl_"] = hxd__FloatBuffer_FloatBuffer_Impl_


class hxd__IndexBuffer_InnerIterator:
    _hx_class_name = "hxd._IndexBuffer.InnerIterator"
    _hx_is_interface = "False"
    __slots__ = ("b", "len", "pos")
    _hx_fields = ["b", "len", "pos"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,b):
        self.pos = None
        self.len = None
        self.b = b
        self.len = len(self.b)
        self.pos = 0

    def hasNext(self):
        return (self.pos < self.len)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.b, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.len = None
        _hx_o.pos = None
hxd__IndexBuffer_InnerIterator._hx_class = hxd__IndexBuffer_InnerIterator
_hx_classes["hxd._IndexBuffer.InnerIterator"] = hxd__IndexBuffer_InnerIterator


class hxd__IndexBuffer_IndexBuffer_Impl_:
    _hx_class_name = "hxd._IndexBuffer.IndexBuffer_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "push", "grow", "arrayRead", "arrayWrite", "getNative", "iterator", "get_length"]
    length = None

    @staticmethod
    def _new(length = None):
        if (length is None):
            length = 0
        this1 = list()
        if (length > 0):
            if (length > len(this1)):
                python_internal_ArrayImpl._set(this1, (length - 1), 0)
        return this1

    @staticmethod
    def push(this1,v):
        this1.append(v)

    @staticmethod
    def grow(this1,v):
        if (v > len(this1)):
            python_internal_ArrayImpl._set(this1, (v - 1), 0)

    @staticmethod
    def arrayRead(this1,key):
        return (this1[key] if key >= 0 and key < len(this1) else None)

    @staticmethod
    def arrayWrite(this1,key,value):
        def _hx_local_1():
            def _hx_local_0():
                python_internal_ArrayImpl._set(this1, key, value)
                return (this1[key] if key >= 0 and key < len(this1) else None)
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def getNative(this1):
        return this1

    @staticmethod
    def iterator(this1):
        return hxd__IndexBuffer_InnerIterator(this1)

    @staticmethod
    def get_length(this1):
        return len(this1)
hxd__IndexBuffer_IndexBuffer_Impl_._hx_class = hxd__IndexBuffer_IndexBuffer_Impl_
_hx_classes["hxd._IndexBuffer.IndexBuffer_Impl_"] = hxd__IndexBuffer_IndexBuffer_Impl_


class hxd_Key:
    _hx_class_name = "hxd.Key"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["BACKSPACE", "TAB", "ENTER", "SHIFT", "CTRL", "ALT", "ESCAPE", "SPACE", "PGUP", "PGDOWN", "END", "HOME", "LEFT", "UP", "RIGHT", "DOWN", "INSERT", "DELETE", "QWERTY_EQUALS", "QWERTY_MINUS", "QWERTY_TILDE", "QWERTY_BRACKET_LEFT", "QWERTY_BRACKET_RIGHT", "QWERTY_SEMICOLON", "QWERTY_QUOTE", "QWERTY_BACKSLASH", "QWERTY_COMMA", "QWERTY_PERIOD", "QWERTY_SLASH", "INTL_BACKSLASH", "LEFT_WINDOW_KEY", "RIGHT_WINDOW_KEY", "CONTEXT_MENU", "PAUSE_BREAK", "CAPS_LOCK", "NUM_LOCK", "SCROLL_LOCK", "NUMBER_0", "NUMBER_1", "NUMBER_2", "NUMBER_3", "NUMBER_4", "NUMBER_5", "NUMBER_6", "NUMBER_7", "NUMBER_8", "NUMBER_9", "NUMPAD_0", "NUMPAD_1", "NUMPAD_2", "NUMPAD_3", "NUMPAD_4", "NUMPAD_5", "NUMPAD_6", "NUMPAD_7", "NUMPAD_8", "NUMPAD_9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "NUMPAD_MULT", "NUMPAD_ADD", "NUMPAD_ENTER", "NUMPAD_SUB", "NUMPAD_DOT", "NUMPAD_DIV", "MOUSE_LEFT", "MOUSE_RIGHT", "MOUSE_MIDDLE", "MOUSE_BACK", "MOUSE_FORWARD", "MOUSE_WHEEL_UP", "MOUSE_WHEEL_DOWN", "LOC_LEFT", "LOC_RIGHT", "LSHIFT", "RSHIFT", "LCTRL", "RCTRL", "LALT", "RALT", "initDone", "keyPressed", "ALLOW_KEY_REPEAT", "isDown", "getFrame", "isPressed", "isReleased", "initialize", "dispose", "onEvent", "getKeyName"]

    @staticmethod
    def isDown(code):
        return (python_internal_ArrayImpl._get(hxd_Key.keyPressed, code) > 0)

    @staticmethod
    def getFrame():
        return (hxd_Timer.frameCount + 2)

    @staticmethod
    def isPressed(code):
        return (python_internal_ArrayImpl._get(hxd_Key.keyPressed, code) == (((hxd_Timer.frameCount + 2) - 1)))

    @staticmethod
    def isReleased(code):
        return (python_internal_ArrayImpl._get(hxd_Key.keyPressed, code) == ((-((hxd_Timer.frameCount + 2)) + 1)))

    @staticmethod
    def initialize():
        if hxd_Key.initDone:
            hxd_Key.dispose()
        hxd_Key.initDone = True
        hxd_Key.keyPressed = []
        hxd_Window.getInstance().addEventTarget(hxd_Key.onEvent)

    @staticmethod
    def dispose():
        if hxd_Key.initDone:
            hxd_Window.getInstance().removeEventTarget(hxd_Key.onEvent)
            hxd_Key.initDone = False
            hxd_Key.keyPressed = []

    @staticmethod
    def onEvent(e):
        tmp = e.kind.index
        if (tmp == 0):
            if (e.button < 5):
                python_internal_ArrayImpl._set(hxd_Key.keyPressed, e.button, (hxd_Timer.frameCount + 2))
        elif (tmp == 1):
            if (e.button < 5):
                python_internal_ArrayImpl._set(hxd_Key.keyPressed, e.button, -((hxd_Timer.frameCount + 2)))
        elif (tmp == 5):
            python_internal_ArrayImpl._set(hxd_Key.keyPressed, (6 if ((e.wheelDelta > 0)) else 5), (hxd_Timer.frameCount + 2))
        elif (tmp == 8):
            if ((not hxd_Key.ALLOW_KEY_REPEAT) and ((python_internal_ArrayImpl._get(hxd_Key.keyPressed, e.keyCode) > 0))):
                return
            python_internal_ArrayImpl._set(hxd_Key.keyPressed, e.keyCode, (hxd_Timer.frameCount + 2))
        elif (tmp == 9):
            python_internal_ArrayImpl._set(hxd_Key.keyPressed, e.keyCode, -((hxd_Timer.frameCount + 2)))
        else:
            pass

    @staticmethod
    def getKeyName(keyCode):
        c = keyCode
        c1 = c
        if (c1 == 0):
            return "MouseLeft"
        elif (c1 == 1):
            return "MouseRight"
        elif (c1 == 2):
            return "MouseMiddle"
        elif (c1 == 3):
            return "Mouse3"
        elif (c1 == 4):
            return "Mouse4"
        elif (c1 == 8):
            return "Backspace"
        elif (c1 == 9):
            return "Tab"
        elif (c1 == 13):
            return "Enter"
        elif (c1 == 16):
            return "Shift"
        elif (c1 == 17):
            return "Ctrl"
        elif (c1 == 18):
            return "Alt"
        elif (c1 == 19):
            return "PauseBreak"
        elif (c1 == 20):
            return "CapsLock"
        elif (c1 == 27):
            return "Escape"
        elif (c1 == 32):
            return "Space"
        elif (c1 == 33):
            return "PageUp"
        elif (c1 == 34):
            return "PageDown"
        elif (c1 == 35):
            return "End"
        elif (c1 == 36):
            return "Home"
        elif (c1 == 37):
            return "Left"
        elif (c1 == 38):
            return "Up"
        elif (c1 == 39):
            return "Right"
        elif (c1 == 40):
            return "Down"
        elif (c1 == 45):
            return "Insert"
        elif (c1 == 46):
            return "Delete"
        elif (c1 == 91):
            return "LeftWindowKey"
        elif (c1 == 92):
            return "RightWindowKey"
        elif (c1 == 93):
            return "ContextMenu"
        elif (c1 == 106):
            return "NumPad*"
        elif (c1 == 107):
            return "NumPad+"
        elif (c1 == 108):
            return "NumPadEnter"
        elif (c1 == 109):
            return "NumPad-"
        elif (c1 == 110):
            return "NumPad."
        elif (c1 == 111):
            return "NumPad/"
        elif (c1 == 144):
            return "NumLock"
        elif (c1 == 145):
            return "ScrollLock"
        elif (c1 == 186):
            return "Semicolon"
        elif (c1 == 187):
            return "Equals"
        elif (c1 == 188):
            return "Comma"
        elif (c1 == 189):
            return "Minus"
        elif (c1 == 190):
            return "Period"
        elif (c1 == 191):
            return "Slash"
        elif (c1 == 192):
            return "Tilde"
        elif (c1 == 219):
            return "BracketLeft"
        elif (c1 == 220):
            return "Backslash"
        elif (c1 == 221):
            return "BacketRight"
        elif (c1 == 222):
            return "Quote"
        elif (c1 == 226):
            return "IntlBackslash"
        elif (c1 == 272):
            return "LShift"
        elif (c1 == 273):
            return "LCtrl"
        elif (c1 == 274):
            return "LAlt"
        elif (c1 == 528):
            return "RShift"
        elif (c1 == 529):
            return "RCtrl"
        elif (c1 == 530):
            return "RAlt"
        elif ((c >= 48) and ((c <= 57))):
            return ("" + Std.string(((c - 48))))
        elif ((c >= 96) and ((c <= 105))):
            return ("NumPad" + Std.string(((c - 96))))
        elif ((c >= 65) and ((c <= 90))):
            return "".join(map(chr,[((65 + c) - 65)]))
        elif ((c >= 112) and ((c <= 135))):
            return ("F" + Std.string((((c - 112) + 1))))
        else:
            return None
hxd_Key._hx_class = hxd_Key
_hx_classes["hxd.Key"] = hxd_Key


class hxd_Math:
    _hx_class_name = "hxd.Math"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["PI", "EPSILON", "get_POSITIVE_INFINITY", "get_NEGATIVE_INFINITY", "get_NaN", "isNaN", "fmt", "floor", "ceil", "round", "clamp", "pow", "cos", "sin", "tan", "acos", "asin", "atan", "sqrt", "invSqrt", "atan2", "abs", "max", "min", "iabs", "imax", "imin", "iclamp", "lerp", "lerpTime", "bitCount", "isPOT", "nextPOT", "distanceSq", "distance", "colorLerp", "angle", "angleLerp", "angleMove", "valueMove", "shuffle", "random", "srand", "b2f", "f2b", "umod", "ufmod", "degToRad", "radToDeg"]
    POSITIVE_INFINITY = None
    NEGATIVE_INFINITY = None
    NaN = None

    @staticmethod
    def get_POSITIVE_INFINITY():
        return Math.POSITIVE_INFINITY

    @staticmethod
    def get_NEGATIVE_INFINITY():
        return Math.NEGATIVE_INFINITY

    @staticmethod
    def get_NaN():
        return Math.NaN

    @staticmethod
    def isNaN(v):
        return python_lib_Math.isnan(v)

    @staticmethod
    def fmt(v):
        neg = None
        if (v < 0):
            neg = -1.0
            v = -v
        else:
            neg = 1.0
        if (python_lib_Math.isnan(v) or (not ((((v != Math.POSITIVE_INFINITY) and ((v != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(v)))))):
            return v
        x = (4 - ((((Math.NEGATIVE_INFINITY if ((v == 0.0)) else (Math.NaN if ((v < 0.0)) else python_lib_Math.log(v)))) / python_lib_Math.log(10))))
        digits = None
        try:
            digits = int(x)
        except BaseException as _g:
            None
            digits = None
        if (digits < 1):
            digits = 1
        elif (digits >= 10):
            return 0.
        exp = Math.pow(10,digits)
        v1 = ((v * exp) + .49999)
        return ((((v1 if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v1)) else Math.floor(v1)))) * neg) / exp)

    @staticmethod
    def floor(f):
        return Math.floor(f)

    @staticmethod
    def ceil(f):
        return Math.ceil(f)

    @staticmethod
    def round(f):
        return Math.floor((f + 0.5))

    @staticmethod
    def clamp(f,_hx_min = None,_hx_max = None):
        if (_hx_min is None):
            _hx_min = 0.
        if (_hx_max is None):
            _hx_max = 1.
        if (f < _hx_min):
            return _hx_min
        elif (f > _hx_max):
            return _hx_max
        else:
            return f

    @staticmethod
    def pow(v,p):
        return Math.pow(v,p)

    @staticmethod
    def cos(f):
        if ((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY))):
            return Math.NaN
        else:
            return python_lib_Math.cos(f)

    @staticmethod
    def sin(f):
        if ((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY))):
            return Math.NaN
        else:
            return python_lib_Math.sin(f)

    @staticmethod
    def tan(f):
        return Math.tan(f)

    @staticmethod
    def acos(f):
        return Math.acos(f)

    @staticmethod
    def asin(f):
        return Math.asin(f)

    @staticmethod
    def atan(f):
        return Math.atan(f)

    @staticmethod
    def sqrt(f):
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    @staticmethod
    def invSqrt(f):
        return (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))

    @staticmethod
    def atan2(dy,dx):
        return Math.atan2(dy,dx)

    @staticmethod
    def abs(f):
        if (f < 0):
            return -f
        else:
            return f

    @staticmethod
    def max(a,b):
        if (a < b):
            return b
        else:
            return a

    @staticmethod
    def min(a,b):
        if (a > b):
            return b
        else:
            return a

    @staticmethod
    def iabs(i):
        if (i < 0):
            return -i
        else:
            return i

    @staticmethod
    def imax(a,b):
        if (a < b):
            return b
        else:
            return a

    @staticmethod
    def imin(a,b):
        if (a > b):
            return b
        else:
            return a

    @staticmethod
    def iclamp(v,_hx_min,_hx_max):
        if (v < _hx_min):
            return _hx_min
        elif (v > _hx_max):
            return _hx_max
        else:
            return v

    @staticmethod
    def lerp(a,b,k):
        return (a + ((k * ((b - a)))))

    @staticmethod
    def lerpTime(a,b,k,dt):
        return (a + ((((1 - Math.pow((1 - k),(dt * hxd_Timer.wantedFPS)))) * ((b - a)))))

    @staticmethod
    def bitCount(v):
        v = (v - (((v >> 1) & 1431655765)))
        v = (((v & 858993459)) + (((v >> 2) & 858993459)))
        return (((((v + ((v >> 4))) & 252645135)) * 16843009) >> 24)

    @staticmethod
    def isPOT(v):
        return (((v & ((v - 1)))) == 0)

    @staticmethod
    def nextPOT(v):
        v = (v - 1)
        v = (v | ((v >> 1)))
        v = (v | ((v >> 2)))
        v = (v | ((v >> 4)))
        v = (v | ((v >> 8)))
        v = (v | ((v >> 16)))
        def _hx_local_8():
            def _hx_local_7():
                nonlocal v
                v = (v + 1)
                return v
            return _hx_local_7()
        return _hx_local_8()

    @staticmethod
    def distanceSq(dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        return (((dx * dx) + ((dy * dy))) + ((dz * dz)))

    @staticmethod
    def distance(dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        dz1 = dz
        if (dz1 is None):
            dz1 = 0.
        f = (((dx * dx) + ((dy * dy))) + ((dz1 * dz1)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    @staticmethod
    def colorLerp(c1,c2,k):
        a1 = HxOverrides.rshift(c1, 24)
        r1 = ((c1 >> 16) & 255)
        g1 = ((c1 >> 8) & 255)
        b1 = (c1 & 255)
        a2 = HxOverrides.rshift(c2, 24)
        r2 = ((c2 >> 16) & 255)
        g2 = ((c2 >> 8) & 255)
        b2 = (c2 & 255)
        a = None
        try:
            a = int(((a1 * ((1 - k))) + ((a2 * k))))
        except BaseException as _g:
            None
            a = None
        a1 = a
        r = None
        try:
            r = int(((r1 * ((1 - k))) + ((r2 * k))))
        except BaseException as _g:
            None
            r = None
        r1 = r
        g = None
        try:
            g = int(((g1 * ((1 - k))) + ((g2 * k))))
        except BaseException as _g:
            None
            g = None
        g1 = g
        b = None
        try:
            b = int(((b1 * ((1 - k))) + ((b2 * k))))
        except BaseException as _g:
            None
            b = None
        b1 = b
        return ((((a1 << 24) | ((r1 << 16))) | ((g1 << 8))) | b1)

    @staticmethod
    def angle(da):
        da = HxOverrides.modf(da, 6.28318530717958623)
        if (da > 3.14159265358979323):
            da = (da - 6.28318530717958623)
        elif (da <= -3.14159265358979312):
            da = (da + 6.28318530717958623)
        return da

    @staticmethod
    def angleLerp(a,b,k):
        da = (b - a)
        da = HxOverrides.modf(da, 6.28318530717958623)
        if (da > 3.14159265358979323):
            da = (da - 6.28318530717958623)
        elif (da <= -3.14159265358979312):
            da = (da + 6.28318530717958623)
        return (a + ((da * k)))

    @staticmethod
    def angleMove(a,b,_hx_max):
        da = (b - a)
        da = HxOverrides.modf(da, 6.28318530717958623)
        if (da > 3.14159265358979323):
            da = (da - 6.28318530717958623)
        elif (da <= -3.14159265358979312):
            da = (da + 6.28318530717958623)
        da1 = da
        if ((da1 > -_hx_max) and ((da1 < _hx_max))):
            return b
        else:
            return (a + ((-_hx_max if ((da1 < 0)) else _hx_max)))

    @staticmethod
    def valueMove(v,target,_hx_max):
        if (v < target):
            v = (v + _hx_max)
            if (v > target):
                v = target
        elif (v > target):
            v = (v - _hx_max)
            if (v < target):
                v = target
        return v

    @staticmethod
    def shuffle(a):
        _hx_len = len(a)
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = (0 if ((_hx_len <= 0)) else int((python_lib_Random.random() * _hx_len)))
            y = (0 if ((_hx_len <= 0)) else int((python_lib_Random.random() * _hx_len)))
            tmp = (a[x] if x >= 0 and x < len(a) else None)
            python_internal_ArrayImpl._set(a, x, (a[y] if y >= 0 and y < len(a) else None))
            python_internal_ArrayImpl._set(a, y, tmp)

    @staticmethod
    def random(_hx_max = None):
        if (_hx_max is None):
            _hx_max = 1.0
        return (python_lib_Random.random() * _hx_max)

    @staticmethod
    def srand(_hx_max = None):
        if (_hx_max is None):
            _hx_max = 1.0
        return (((python_lib_Random.random() - 0.5)) * ((_hx_max * 2)))

    @staticmethod
    def b2f(v):
        return (((v & 255)) * 0.0039215686274509803921568627451)

    @staticmethod
    def f2b(v):
        tmp = None
        try:
            tmp = int((((0. if ((v < 0.)) else (1. if ((v > 1.)) else v))) * 255.0))
        except BaseException as _g:
            None
            tmp = None
        return tmp

    @staticmethod
    def umod(value,modulo):
        r = HxOverrides.mod(value, modulo)
        if (r >= 0):
            return r
        else:
            return (r + modulo)

    @staticmethod
    def ufmod(value,modulo):
        r = HxOverrides.modf(value, modulo)
        if (r >= 0):
            return r
        else:
            return (r + modulo)

    @staticmethod
    def degToRad(deg):
        return ((deg * 3.14159265358979323) / 180.0)

    @staticmethod
    def radToDeg(rad):
        return ((rad * 180.0) / 3.14159265358979323)
hxd_Math._hx_class = hxd_Math
_hx_classes["hxd.Math"] = hxd_Math

class hxd_Flags(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.Flags"
    _hx_constructs = ["ReadOnly", "AlphaPremultiplied", "FlipY"]
hxd_Flags.ReadOnly = hxd_Flags("ReadOnly", 0, ())
hxd_Flags.AlphaPremultiplied = hxd_Flags("AlphaPremultiplied", 1, ())
hxd_Flags.FlipY = hxd_Flags("FlipY", 2, ())
hxd_Flags._hx_class = hxd_Flags
_hx_classes["hxd.Flags"] = hxd_Flags


class hxd__Pixels_PixelsARGB_Impl_:
    _hx_class_name = "hxd._Pixels.PixelsARGB_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getPixel", "setPixel", "fromPixels"]

    @staticmethod
    def getPixel(this1,x,y):
        _this = this1.bytes
        pos = ((((x + ((y * this1.width))) << 2)) + this1.offset)
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        v1 = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        return (((HxOverrides.rshift(v1, 24) | (((v1 >> 8) & 65280))) | (((v1 << 8) & 16711680))) | ((v1 << 24)))

    @staticmethod
    def setPixel(this1,x,y,v):
        _this = this1.bytes
        pos = ((((x + ((y * this1.width))) << 2)) + this1.offset)
        v1 = (((HxOverrides.rshift(v, 24) | (((v >> 8) & 65280))) | (((v << 8) & 16711680))) | ((v << 24)))
        _this.b[pos] = (v1 & 255)
        _this.b[(pos + 1)] = ((v1 >> 8) & 255)
        _this.b[(pos + 2)] = ((v1 >> 16) & 255)
        _this.b[(pos + 3)] = (HxOverrides.rshift(v1, 24) & 255)

    @staticmethod
    def fromPixels(p):
        p.convert(hxd_PixelFormat.ARGB)
        p.setFlip(False)
        return p
hxd__Pixels_PixelsARGB_Impl_._hx_class = hxd__Pixels_PixelsARGB_Impl_
_hx_classes["hxd._Pixels.PixelsARGB_Impl_"] = hxd__Pixels_PixelsARGB_Impl_


class hxd__Pixels_PixelsFloat_Impl_:
    _hx_class_name = "hxd._Pixels.PixelsFloat_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getPixelF", "setPixelF", "fromPixels"]

    @staticmethod
    def getPixelF(this1,x,y,v = None):
        if (v is None):
            v = h3d_Vector()
        pix = ((((x + ((y * this1.width))) << 2)) + this1.offset)
        v.x = this1.bytes.getFloat(pix)
        return v

    @staticmethod
    def setPixelF(this1,x,y,v):
        pix = ((((x + ((y * this1.width))) << 2)) + this1.offset)
        this1.bytes.setFloat(pix,v.x)

    @staticmethod
    def fromPixels(p):
        p.setFlip(False)
        p.convert(hxd_PixelFormat.R32F)
        return p
hxd__Pixels_PixelsFloat_Impl_._hx_class = hxd__Pixels_PixelsFloat_Impl_
_hx_classes["hxd._Pixels.PixelsFloat_Impl_"] = hxd__Pixels_PixelsFloat_Impl_


class hxd__Pixels_PixelsFloatRGBA_Impl_:
    _hx_class_name = "hxd._Pixels.PixelsFloatRGBA_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getPixelF", "setPixelF", "fromPixels"]

    @staticmethod
    def getPixelF(this1,x,y,v = None):
        if (v is None):
            v = h3d_Vector()
        pix = ((((x + ((y * this1.width))) << 4)) + this1.offset)
        v.x = this1.bytes.getFloat(pix)
        v.y = this1.bytes.getFloat((pix + 4))
        v.z = this1.bytes.getFloat((pix + 8))
        v.w = this1.bytes.getFloat((pix + 12))
        return v

    @staticmethod
    def setPixelF(this1,x,y,v):
        pix = ((((x + ((y * this1.width))) << 4)) + this1.offset)
        this1.bytes.setFloat(pix,v.x)
        this1.bytes.setFloat((pix + 4),v.y)
        this1.bytes.setFloat((pix + 8),v.z)
        this1.bytes.setFloat((pix + 12),v.w)

    @staticmethod
    def fromPixels(p):
        p.setFlip(False)
        p.convert(hxd_PixelFormat.RGBA32F)
        return p
hxd__Pixels_PixelsFloatRGBA_Impl_._hx_class = hxd__Pixels_PixelsFloatRGBA_Impl_
_hx_classes["hxd._Pixels.PixelsFloatRGBA_Impl_"] = hxd__Pixels_PixelsFloatRGBA_Impl_


class hxd__Pixels_Channel_Impl_:
    _hx_class_name = "hxd._Pixels.Channel_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["R", "G", "B", "A", "toInt", "fromInt"]

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def fromInt(v):
        return v
hxd__Pixels_Channel_Impl_._hx_class = hxd__Pixels_Channel_Impl_
_hx_classes["hxd._Pixels.Channel_Impl_"] = hxd__Pixels_Channel_Impl_


class hxd_Pixels:
    _hx_class_name = "hxd.Pixels"
    _hx_is_interface = "False"
    __slots__ = ("bytes", "width", "height", "dataSize", "offset", "flags", "stride", "bytesPerPixel", "innerFormat")
    _hx_fields = ["bytes", "width", "height", "dataSize", "offset", "flags", "stride", "bytesPerPixel", "innerFormat"]
    _hx_methods = ["get_format", "set_innerFormat", "invalidFormat", "sub", "yflip", "blit", "clear", "toVector", "makeSquare", "copyInner", "willChange", "setFlip", "convert", "getPixel", "setPixel", "getPixelF", "setPixelF", "dispose", "toString", "toPNG", "clone"]
    _hx_statics = ["switchEndian", "switchBR", "calcDataSize", "calcStride", "isFloatFormat", "getChannelOffset", "alloc", "toDDS"]

    def __init__(self,width,height,_hx_bytes,format,offset = None):
        if (offset is None):
            offset = 0
        self.innerFormat = None
        self.bytesPerPixel = None
        self.stride = None
        self.flags = None
        self.offset = None
        self.dataSize = None
        self.width = width
        self.height = height
        self.bytes = _hx_bytes
        self.set_innerFormat(format)
        self.offset = offset
        i = 0
        if (i is None):
            i = 0
        this1 = i
        self.flags = this1

    def get_format(self):
        return self.innerFormat

    def set_innerFormat(self,fmt):
        self.innerFormat = fmt
        self.stride = hxd_Pixels.calcStride(self.width,fmt)
        self.dataSize = hxd_Pixels.calcDataSize(self.width,self.height,fmt)
        self.bytesPerPixel = hxd_Pixels.calcStride(1,fmt)
        return fmt

    def invalidFormat(self):
        raise haxe_Exception.thrown(("Unsupported format for this operation : " + Std.string(self.innerFormat)))

    def sub(self,x,y,width,height):
        if ((((x < 0) or ((y < 0))) or (((x + width) > self.width))) or (((y + height) > self.height))):
            raise haxe_Exception.thrown("Pixels.sub() outside bounds")
        out = haxe_io_Bytes.alloc((height * self.stride))
        stride = hxd_Pixels.calcStride(width,self.innerFormat)
        outP = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            dy = _g
            _g = (_g + 1)
            y1 = (y + dy)
            p = ((((x + ((((((self.height - 1) - y1) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y1)) * self.width)))) * self.bytesPerPixel) + self.offset)
            out.blit(outP,self.bytes,p,stride)
            outP = (outP + stride)
        return hxd_Pixels(width,height,out,self.innerFormat)

    def yflip(self,y):
        if (((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0):
            return ((self.height - 1) - y)
        else:
            return y

    def blit(self,x,y,src,srcX,srcY,width,height):
        if ((((x < 0) or ((y < 0))) or (((x + width) > self.width))) or (((y + height) > self.height))):
            raise haxe_Exception.thrown("Pixels.blit() outside bounds")
        if ((((srcX < 0) or ((srcX < 0))) or (((srcX + width) > src.width))) or (((srcY + height) > src.height))):
            raise haxe_Exception.thrown("Pixels.blit() outside src bounds")
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        src.convert(self.innerFormat)
        bpp = self.bytesPerPixel
        if (bpp == 0):
            raise haxe_Exception.thrown("assert")
        stride = hxd_Pixels.calcStride(width,self.innerFormat)
        _g = 0
        _g1 = height
        while (_g < _g1):
            dy = _g
            _g = (_g + 1)
            y1 = (dy + srcY)
            srcP = ((((srcX + ((((((src.height - 1) - y1) if ((((src.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y1)) * src.width)))) * bpp) + src.offset)
            y2 = (dy + y)
            dstP = ((((x + ((((((self.height - 1) - y2) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y2)) * self.width)))) * bpp) + self.offset)
            self.bytes.blit(dstP,src.bytes,srcP,stride)

    def clear(self,color,preserveMask = None):
        if (preserveMask is None):
            preserveMask = 0
        mask = preserveMask
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        if (((((color & 255)) == (((color >> 8) & 255))) and ((((color & 65535)) == (HxOverrides.rshift(color, 16))))) and ((mask == 0))):
            self.bytes.fill(self.offset,((self.width * self.height) * self.bytesPerPixel),(color & 255))
            return
        tmp = self.innerFormat.index
        if (tmp == 0):
            color = (((HxOverrides.rshift(color, 24) | (((color >> 8) & 65280))) | (((color << 8) & 16711680))) | ((color << 24)))
            mask = (((HxOverrides.rshift(mask, 24) | (((mask >> 8) & 65280))) | (((mask << 8) & 16711680))) | ((mask << 24)))
        elif (tmp == 1):
            pass
        elif (tmp == 2):
            color = (((color & -16711936) | (((color << 16) & 16711680))) | (((color >> 16) & 255)))
            mask = (((mask & -16711936) | (((mask << 16) & 16711680))) | (((mask >> 16) & 255)))
        else:
            self.invalidFormat()
        p = self.offset
        if (mask == 0):
            _g = 0
            _g1 = (self.width * self.height)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this = self.bytes
                _this.b[p] = (color & 255)
                _this.b[(p + 1)] = ((color >> 8) & 255)
                _this.b[(p + 2)] = ((color >> 16) & 255)
                _this.b[(p + 3)] = (HxOverrides.rshift(color, 24) & 255)
                p = (p + 4)
        else:
            _g = 0
            _g1 = (self.width * self.height)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this = self.bytes
                _this1 = self.bytes
                v = (((_this1.b[p] | ((_this1.b[(p + 1)] << 8))) | ((_this1.b[(p + 2)] << 16))) | ((_this1.b[(p + 3)] << 24)))
                v1 = (color | (((((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)) & mask)))
                _this.b[p] = (v1 & 255)
                _this.b[(p + 1)] = ((v1 >> 8) & 255)
                _this.b[(p + 2)] = ((v1 >> 16) & 255)
                _this.b[(p + 3)] = (HxOverrides.rshift(v1, 24) & 255)
                p = (p + 4)

    def toVector(self):
        this1 = [None]*(self.width * self.height)
        vec = this1
        idx = 0
        p = self.offset
        dl = 0
        if (((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0):
            p = (p + (((((self.height - 1)) * self.width) * self.bytesPerPixel)))
            dl = ((-self.width * 2) * self.bytesPerPixel)
        tmp = self.innerFormat.index
        if (tmp == 0):
            _g = 0
            _g1 = self.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                _g2 = 0
                _g3 = self.width
                while (_g2 < _g3):
                    x = _g2
                    _g2 = (_g2 + 1)
                    _this = self.bytes
                    v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
                    v1 = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                    index = idx
                    idx = (idx + 1)
                    val = (((HxOverrides.rshift(v1, 24) | (((v1 >> 8) & 65280))) | (((v1 << 8) & 16711680))) | ((v1 << 24)))
                    vec[index] = val
                    p = (p + 4)
                p = (p + dl)
        elif (tmp == 1):
            _g = 0
            _g1 = self.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                _g2 = 0
                _g3 = self.width
                while (_g2 < _g3):
                    x = _g2
                    _g2 = (_g2 + 1)
                    index = idx
                    idx = (idx + 1)
                    _this = self.bytes
                    v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
                    val = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                    vec[index] = val
                    p = (p + 4)
                p = (p + dl)
        elif (tmp == 2):
            _g = 0
            _g1 = self.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                _g2 = 0
                _g3 = self.width
                while (_g2 < _g3):
                    x = _g2
                    _g2 = (_g2 + 1)
                    _this = self.bytes
                    v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
                    v1 = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                    index = idx
                    idx = (idx + 1)
                    val = (((v1 & -16711936) | (((v1 << 16) & 16711680))) | (((v1 >> 16) & 255)))
                    vec[index] = val
                    p = (p + 4)
                p = (p + dl)
        else:
            self.invalidFormat()
        return vec

    def makeSquare(self,copy = None):
        w = self.width
        h = self.height
        tw = (0 if ((w == 0)) else 1)
        th = (0 if ((h == 0)) else 1)
        while (tw < w):
            tw = (tw << 1)
        while (th < h):
            th = (th << 1)
        if ((w == tw) and ((h == th))):
            return self
        bpp = self.bytesPerPixel
        out = haxe_io_Bytes.alloc(((tw * th) * bpp))
        p = 0
        b = self.offset
        _g = 0
        _g1 = h
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            out.blit(p,self.bytes,b,(w * bpp))
            p = (p + ((w * bpp)))
            b = (b + ((w * bpp)))
            _g2 = 0
            _g3 = ((((tw - w)) * bpp) >> 2)
            while (_g2 < _g3):
                i = _g2
                _g2 = (_g2 + 1)
                out.b[p] = 0
                out.b[(p + 1)] = 0
                out.b[(p + 2)] = 0
                out.b[(p + 3)] = 0
                p = (p + 4)
        _g = 0
        _g1 = (((((th - h)) * tw) * bpp) >> 2)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            out.b[p] = 0
            out.b[(p + 1)] = 0
            out.b[(p + 2)] = 0
            out.b[(p + 3)] = 0
            p = (p + 4)
        if copy:
            return hxd_Pixels(tw,th,out,self.innerFormat)
        self.bytes = out
        self.width = tw
        self.height = th
        return self

    def copyInner(self):
        old = self.bytes
        self.bytes = haxe_io_Bytes.alloc(self.dataSize)
        self.bytes.blit(0,old,self.offset,self.dataSize)
        self.offset = 0
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 & ((-1 - ((1 << hxd_Flags.ReadOnly.index)))))
        _hx_local_0.flags

    def willChange(self):
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()

    def setFlip(self,b):
        if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0) == b):
            return
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | ((1 << hxd_Flags.FlipY.index)))
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ((-1 - ((1 << hxd_Flags.FlipY.index)))))
            _hx_local_2.flags
        if (HxOverrides.mod(self.stride, 4) != 0):
            self.invalidFormat()
        _g = 0
        _g1 = (self.height >> 1)
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            p1 = ((y * self.stride) + self.offset)
            p2 = (((((self.height - 1) - y)) * self.stride) + self.offset)
            _g2 = 0
            _g3 = (self.stride >> 2)
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                _this = self.bytes
                v = (((_this.b[p1] | ((_this.b[(p1 + 1)] << 8))) | ((_this.b[(p1 + 2)] << 16))) | ((_this.b[(p1 + 3)] << 24)))
                a = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                _this1 = self.bytes
                v1 = (((_this1.b[p2] | ((_this1.b[(p2 + 1)] << 8))) | ((_this1.b[(p2 + 2)] << 16))) | ((_this1.b[(p2 + 3)] << 24)))
                b = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
                _this2 = self.bytes
                _this2.b[p1] = (b & 255)
                _this2.b[(p1 + 1)] = ((b >> 8) & 255)
                _this2.b[(p1 + 2)] = ((b >> 16) & 255)
                _this2.b[(p1 + 3)] = (HxOverrides.rshift(b, 24) & 255)
                _this3 = self.bytes
                _this3.b[p2] = (a & 255)
                _this3.b[(p2 + 1)] = ((a >> 8) & 255)
                _this3.b[(p2 + 2)] = ((a >> 16) & 255)
                _this3.b[(p2 + 3)] = (HxOverrides.rshift(a, 24) & 255)
                p1 = (p1 + 4)
                p2 = (p2 + 4)

    def convert(self,target):
        if ((self.innerFormat == target) or Type.enumEq(self.innerFormat,target)):
            return
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        this1 = self.bytes.b
        _hx_bytes = this1
        _g = self.innerFormat
        tmp = _g.index
        if (tmp == 0):
            tmp = target.index
            if (tmp == 1):
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    p = (((i << 2)) + self.offset)
                    a = _hx_bytes[p]
                    r = _hx_bytes[(p + 1)]
                    g = _hx_bytes[(p + 2)]
                    b = _hx_bytes[(p + 3)]
                    i1 = p
                    p = (p + 1)
                    _hx_bytes[i1] = b
                    i2 = p
                    p = (p + 1)
                    _hx_bytes[i2] = g
                    i3 = p
                    p = (p + 1)
                    _hx_bytes[i3] = r
                    _hx_bytes[p] = a
            elif (tmp == 2):
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    p = (((i << 2)) + self.offset)
                    a = _hx_bytes[p]
                    v = _hx_bytes[(p + 1)]
                    _hx_bytes[p] = v
                    v1 = _hx_bytes[(p + 2)]
                    _hx_bytes[(p + 1)] = v1
                    v2 = _hx_bytes[(p + 3)]
                    _hx_bytes[(p + 2)] = v2
                    _hx_bytes[(p + 3)] = a
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 1):
            tmp = target.index
            if (tmp == 0):
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    p = (((i << 2)) + self.offset)
                    a = _hx_bytes[p]
                    r = _hx_bytes[(p + 1)]
                    g = _hx_bytes[(p + 2)]
                    b = _hx_bytes[(p + 3)]
                    i1 = p
                    p = (p + 1)
                    _hx_bytes[i1] = b
                    i2 = p
                    p = (p + 1)
                    _hx_bytes[i2] = g
                    i3 = p
                    p = (p + 1)
                    _hx_bytes[i3] = r
                    _hx_bytes[p] = a
            elif (tmp == 2):
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    p = (((i << 2)) + self.offset)
                    b = _hx_bytes[p]
                    r = _hx_bytes[(p + 2)]
                    _hx_bytes[p] = r
                    _hx_bytes[(p + 2)] = b
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 2):
            tmp = target.index
            if (tmp == 0):
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    p = (((i << 2)) + self.offset)
                    a = _hx_bytes[(p + 3)]
                    v = _hx_bytes[(p + 2)]
                    _hx_bytes[(p + 3)] = v
                    v1 = _hx_bytes[(p + 1)]
                    _hx_bytes[(p + 2)] = v1
                    v2 = _hx_bytes[p]
                    _hx_bytes[(p + 1)] = v2
                    _hx_bytes[p] = a
            elif (tmp == 1):
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    p = (((i << 2)) + self.offset)
                    b = _hx_bytes[p]
                    r = _hx_bytes[(p + 2)]
                    _hx_bytes[p] = r
                    _hx_bytes[(p + 2)] = b
            elif (tmp == 5):
                nbytes = haxe_io_Bytes.alloc((self.width * self.height))
                this1 = nbytes.b
                out = this1
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    v = _hx_bytes[(i << 2)]
                    out[i] = v
                self.bytes = nbytes
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 4):
            if (target.index == 7):
                nbytes = haxe_io_Bytes.alloc(((self.height * self.width) * 4))
                this1 = nbytes.b
                out = this1
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    nbytes.setFloat((i << 2),self.bytes.getFloat((i << 4)))
                self.bytes = nbytes
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 7):
            tmp = target.index
            if ((tmp == 2) or ((tmp == 1))):
                fbytes = self.bytes
                p = 0
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    x = (fbytes.getFloat(p) * 255)
                    v = None
                    try:
                        v = int(x)
                    except BaseException as _g3:
                        None
                        v = None
                    if (v < 0):
                        v = 0
                    elif (v > 255):
                        v = 255
                    i1 = p
                    p = (p + 1)
                    _hx_bytes[i1] = v
                    i2 = p
                    p = (p + 1)
                    _hx_bytes[i2] = v
                    i3 = p
                    p = (p + 1)
                    _hx_bytes[i3] = v
                    i4 = p
                    p = (p + 1)
                    _hx_bytes[i4] = 255
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 18):
            if (target.index == 7):
                nbytes = haxe_io_Bytes.alloc(((self.width * self.height) * 4))
                fbytes = self.bytes
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    pos = (i << 1)
                    nv = (fbytes.b[pos] | ((fbytes.b[(pos + 1)] << 8)))
                    nbytes.setFloat((i << 2),(nv / 65535.0))
                self.bytes = nbytes
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 21):
            if (target.index == 21):
                b = target.params[0]
                a = _g.params[0]
                if (a != b):
                    raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        else:
            raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        self.set_innerFormat(target)

    def getPixel(self,x,y):
        p = ((((x + ((((((self.height - 1) - y) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y)) * self.width)))) * self.bytesPerPixel) + self.offset)
        tmp = self.innerFormat.index
        if (tmp == 0):
            _this = self.bytes
            v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
            v1 = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            return (((HxOverrides.rshift(v1, 24) | (((v1 >> 8) & 65280))) | (((v1 << 8) & 16711680))) | ((v1 << 24)))
        elif (tmp == 1):
            _this = self.bytes
            v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
            if (((v & -2147483648)) != 0):
                return (v | -2147483648)
            else:
                return v
        elif (tmp == 2):
            _this = self.bytes
            v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
            v1 = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            return (((v1 & -16711936) | (((v1 << 16) & 16711680))) | (((v1 >> 16) & 255)))
        else:
            self.invalidFormat()
            return 0

    def setPixel(self,x,y,color):
        p = ((((x + ((((((self.height - 1) - y) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y)) * self.width)))) * self.bytesPerPixel) + self.offset)
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        tmp = self.innerFormat.index
        if (tmp == 0):
            _this = self.bytes
            v = (((HxOverrides.rshift(color, 24) | (((color >> 8) & 65280))) | (((color << 8) & 16711680))) | ((color << 24)))
            _this.b[p] = (v & 255)
            _this.b[(p + 1)] = ((v >> 8) & 255)
            _this.b[(p + 2)] = ((v >> 16) & 255)
            _this.b[(p + 3)] = (HxOverrides.rshift(v, 24) & 255)
        elif (tmp == 1):
            _this = self.bytes
            _this.b[p] = (color & 255)
            _this.b[(p + 1)] = ((color >> 8) & 255)
            _this.b[(p + 2)] = ((color >> 16) & 255)
            _this.b[(p + 3)] = (HxOverrides.rshift(color, 24) & 255)
        elif (tmp == 2):
            _this = self.bytes
            v = (((color & -16711936) | (((color << 16) & 16711680))) | (((color >> 16) & 255)))
            _this.b[p] = (v & 255)
            _this.b[(p + 1)] = ((v >> 8) & 255)
            _this.b[(p + 2)] = ((v >> 16) & 255)
            _this.b[(p + 3)] = (HxOverrides.rshift(v, 24) & 255)
        elif (tmp == 5):
            self.bytes.b[p] = (color & 255)
        else:
            self.invalidFormat()

    def getPixelF(self,x,y,v = None):
        if (v is None):
            v = h3d_Vector()
        p = ((((x + ((((((self.height - 1) - y) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y)) * self.width)))) * self.bytesPerPixel) + self.offset)
        tmp = self.innerFormat.index
        if (tmp == 4):
            x1 = self.bytes.getFloat(p)
            y1 = self.bytes.getFloat((p + 4))
            z = self.bytes.getFloat((p + 8))
            w = self.bytes.getFloat((p + 12))
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            v.x = x1
            v.y = y1
            v.z = z
            v.w = w
            return v
        elif (tmp == 7):
            x1 = self.bytes.getFloat(p)
            y1 = 0
            z = 0
            w = 0
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            v.x = x1
            v.y = y1
            v.z = z
            v.w = w
            return v
        elif (tmp == 10):
            x1 = self.bytes.getFloat(p)
            y1 = self.bytes.getFloat((p + 4))
            z = 0
            w = 0
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            v.x = x1
            v.y = y1
            v.z = z
            v.w = w
            return v
        else:
            c = self.getPixel(x,y)
            v.x = ((((c >> 16) & 255)) / 255)
            v.y = ((((c >> 8) & 255)) / 255)
            v.z = (((c & 255)) / 255)
            v.w = ((HxOverrides.rshift(c, 24)) / 255)
            return v

    def setPixelF(self,x,y,v):
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        p = ((((x + ((((((self.height - 1) - y) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y)) * self.width)))) * self.bytesPerPixel) + self.offset)
        tmp = self.innerFormat.index
        if (tmp == 4):
            self.bytes.setFloat(p,v.x)
            self.bytes.setFloat((p + 4),v.y)
            self.bytes.setFloat((p + 8),v.z)
            self.bytes.setFloat((p + 12),v.w)
        elif (tmp == 7):
            self.bytes.setFloat(p,v.x)
        else:
            f = v.w
            x1 = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
            tmp = None
            try:
                tmp = int(x1)
            except BaseException as _g:
                None
                tmp = None
            tmp1 = (tmp << 24)
            f = v.x
            x1 = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
            tmp = None
            try:
                tmp = int(x1)
            except BaseException as _g:
                None
                tmp = None
            tmp2 = (tmp1 | ((tmp << 16)))
            f = v.y
            x1 = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
            tmp = None
            try:
                tmp = int(x1)
            except BaseException as _g:
                None
                tmp = None
            tmp1 = (tmp2 | ((tmp << 8)))
            f = v.z
            x1 = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
            tmp = None
            try:
                tmp = int(x1)
            except BaseException as _g:
                None
                tmp = None
            self.setPixel(x,y,(tmp1 | tmp))

    def dispose(self):
        self.bytes = None

    def toString(self):
        return (((((("Pixels(" + Std.string(self.width)) + "x") + Std.string(self.height)) + " ") + Std.string(self.innerFormat)) + ")")

    def toPNG(self,level = None):
        if (level is None):
            level = 9
        png = None
        self.setFlip(False)
        if (self.innerFormat.index == 0):
            png = format_png_Tools.build32ARGB(self.width,self.height,self.bytes,level)
        else:
            self.convert(hxd_PixelFormat.BGRA)
            png = format_png_Tools.build32BGRA(self.width,self.height,self.bytes,level)
        o = haxe_io_BytesOutput()
        format_png_Writer(o).write(png)
        return o.getBytes()

    def clone(self):
        p = hxd_Pixels(self.width,self.height,None,self.innerFormat)
        p.flags = self.flags
        p.flags = (p.flags & ((-1 - ((1 << hxd_Flags.ReadOnly.index)))))
        if (self.bytes is not None):
            p.bytes = haxe_io_Bytes.alloc(self.dataSize)
            p.bytes.blit(0,self.bytes,self.offset,self.dataSize)
        return p

    @staticmethod
    def switchEndian(v):
        return (((HxOverrides.rshift(v, 24) | (((v >> 8) & 65280))) | (((v << 8) & 16711680))) | ((v << 24)))

    @staticmethod
    def switchBR(v):
        return (((v & -16711936) | (((v << 16) & 16711680))) | (((v >> 16) & 255)))

    @staticmethod
    def calcDataSize(width,height,format):
        if (format.index == 21):
            _g = format.params[0]
            return (((((height + 3) >> 2) << 2)) * hxd_Pixels.calcStride(width,format))
        else:
            return (height * hxd_Pixels.calcStride(width,format))

    @staticmethod
    def calcStride(width,format):
        tmp = None
        tmp1 = format.index
        if ((tmp1 == 20) or ((tmp1 == 3))):
            tmp = 8
        elif (tmp1 == 4):
            tmp = 16
        elif (tmp1 == 5):
            tmp = 1
        elif (tmp1 == 7):
            tmp = 4
        elif (tmp1 == 8):
            tmp = 2
        elif (tmp1 == 9):
            tmp = 4
        elif (tmp1 == 10):
            tmp = 8
        elif (tmp1 == 11):
            tmp = 3
        elif ((tmp1 == 19) or ((tmp1 == 12))):
            tmp = 6
        elif (tmp1 == 13):
            tmp = 12
        elif (((((tmp1 == 15) or ((tmp1 == 14))) or ((tmp1 == 2))) or ((tmp1 == 1))) or ((tmp1 == 0))):
            tmp = 4
        elif (tmp1 == 16):
            tmp = 4
        elif (tmp1 == 17):
            tmp = 4
        elif ((tmp1 == 18) or ((tmp1 == 6))):
            tmp = 2
        elif (tmp1 == 21):
            n = format.params[0]
            blocks = ((width + 3) >> 2)
            if ((n == 1) or ((n == 4))):
                return (blocks << 1)
            return (blocks << 2)
        else:
            pass
        return (width * tmp)

    @staticmethod
    def isFloatFormat(format):
        tmp = format.index
        if ((((tmp == 12) or ((tmp == 9))) or ((tmp == 6))) or ((tmp == 3))):
            return True
        elif ((((tmp == 13) or ((tmp == 10))) or ((tmp == 7))) or ((tmp == 4))):
            return True
        elif (tmp == 21):
            if (format.params[0] == 6):
                return True
            else:
                return False
        else:
            return False

    @staticmethod
    def getChannelOffset(format,channel):
        tmp = format.index
        if (tmp == 0):
            return python_internal_ArrayImpl._get([1, 2, 3, 0], channel)
        elif (tmp == 1):
            return python_internal_ArrayImpl._get([2, 1, 0, 3], channel)
        elif ((tmp == 20) or ((tmp == 3))):
            return (channel * 2)
        elif (tmp == 4):
            return (channel * 4)
        elif ((((tmp == 18) or ((tmp == 7))) or ((tmp == 6))) or ((tmp == 5))):
            if (channel == 0):
                return 0
            else:
                return -1
        elif (((tmp == 10) or ((tmp == 9))) or ((tmp == 8))):
            p = hxd_Pixels.calcStride(1,format)
            return python_internal_ArrayImpl._get([0, p, -1, -1], channel)
        elif ((((tmp == 19) or ((tmp == 13))) or ((tmp == 12))) or ((tmp == 11))):
            p = hxd_Pixels.calcStride(1,format)
            return python_internal_ArrayImpl._get([0, p, (p << 1), -1], channel)
        elif (((tmp == 15) or ((tmp == 14))) or ((tmp == 2))):
            return channel
        elif ((tmp == 17) or ((tmp == 16))):
            raise haxe_Exception.thrown("Bit packed format")
        elif (tmp == 21):
            _g = format.params[0]
            raise haxe_Exception.thrown("Not supported")
        else:
            pass

    @staticmethod
    def alloc(width,height,format):
        return hxd_Pixels(width,height,haxe_io_Bytes.alloc(hxd_Pixels.calcDataSize(width,height,format)),format)

    @staticmethod
    def toDDS(pixels,isCubeMap = None):
        if (isCubeMap is None):
            isCubeMap = False
        if (len(pixels) == 0):
            raise haxe_Exception.thrown("Must contain at least one image")
        ref = (pixels[0] if 0 < len(pixels) else None)
        fmt = ref.innerFormat
        levels = []
        outSize = 0
        _g = 0
        while (_g < len(pixels)):
            p = (pixels[_g] if _g >= 0 and _g < len(pixels) else None)
            _g = (_g + 1)
            if (p.innerFormat != fmt):
                raise haxe_Exception.thrown("All images must be of the same pixel format")
            outSize = (outSize + p.dataSize)
            found = False
            _g1 = 0
            while (_g1 < len(levels)):
                sz = (levels[_g1] if _g1 >= 0 and _g1 < len(levels) else None)
                _g1 = (_g1 + 1)
                if (((sz[0] if 0 < len(sz) else None).width == p.width) and (((sz[0] if 0 < len(sz) else None).height == p.height))):
                    sz.append(p)
                    found = True
                    break
            if (not found):
                levels.append([p])
        def _hx_local_3(a1,a2):
            return (((a2[0] if 0 < len(a2) else None).width * (a2[0] if 0 < len(a2) else None).height) - (((a1[0] if 0 < len(a1) else None).width * (a1[0] if 0 < len(a1) else None).height)))
        levels.sort(key= python_lib_Functools.cmp_to_key(_hx_local_3))
        layerCount = len((levels[0] if 0 < len(levels) else None))
        width = python_internal_ArrayImpl._get((levels[0] if 0 < len(levels) else None), 0).width
        height = python_internal_ArrayImpl._get((levels[0] if 0 < len(levels) else None), 0).height
        _g = 1
        _g1 = len(levels)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            level = (levels[i] if i >= 0 and i < len(levels) else None)
            if (len(level) != layerCount):
                raise haxe_Exception.thrown(((((("Invalid number of mipmaps at level " + Std.string(i)) + ": ") + Std.string(len(level))) + " should be ") + Std.string(layerCount)))
            w = (width >> i)
            if (w == 0):
                w = 1
            h = (height >> i)
            if (h == 0):
                h = 1
            lw = (level[0] if 0 < len(level) else None).width
            lh = (level[0] if 0 < len(level) else None).height
            if ((lw != w) or ((lh != h))):
                raise haxe_Exception.thrown(((((((((("Invalid mip level size " + Std.string(i)) + ": ") + Std.string(lw)) + "x") + Std.string(lh)) + " should be ") + Std.string(w)) + "x") + Std.string(h)))
        outSize = (outSize + 128)
        ddsOut = haxe_io_Bytes.alloc(outSize)
        outPos = 0
        ddsOut.b[outPos] = 68
        ddsOut.b[(outPos + 1)] = 68
        ddsOut.b[(outPos + 2)] = 83
        ddsOut.b[(outPos + 3)] = 32
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 124
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 15
        ddsOut.b[(outPos + 1)] = 16
        ddsOut.b[(outPos + 2)] = 2
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = (width & 255)
        ddsOut.b[(outPos + 1)] = ((width >> 8) & 255)
        ddsOut.b[(outPos + 2)] = ((width >> 16) & 255)
        ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(width, 24) & 255)
        outPos = (outPos + 4)
        ddsOut.b[outPos] = (height & 255)
        ddsOut.b[(outPos + 1)] = ((height >> 8) & 255)
        ddsOut.b[(outPos + 2)] = ((height >> 16) & 255)
        ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(height, 24) & 255)
        outPos = (outPos + 4)
        v = ref.stride
        ddsOut.b[outPos] = (v & 255)
        ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
        ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
        ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 1
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        v = len(levels)
        ddsOut.b[outPos] = (v & 255)
        ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
        ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
        ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 32
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        tmp = fmt.index
        if (((tmp == 2) or ((tmp == 1))) or ((tmp == 0))):
            ddsOut.b[outPos] = 65
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 0
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 32
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            byte = hxd_Pixels.getChannelOffset(fmt,0)
            v = (255 << ((byte * 8)))
            ddsOut.b[outPos] = (v & 255)
            ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
            ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
            ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
            outPos = (outPos + 4)
            byte = hxd_Pixels.getChannelOffset(fmt,1)
            v = (255 << ((byte * 8)))
            ddsOut.b[outPos] = (v & 255)
            ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
            ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
            ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
            outPos = (outPos + 4)
            byte = hxd_Pixels.getChannelOffset(fmt,2)
            v = (255 << ((byte * 8)))
            ddsOut.b[outPos] = (v & 255)
            ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
            ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
            ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
            outPos = (outPos + 4)
            byte = hxd_Pixels.getChannelOffset(fmt,3)
            v = (255 << ((byte * 8)))
            ddsOut.b[outPos] = (v & 255)
            ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
            ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
            ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
            outPos = (outPos + 4)
        else:
            alpha = (hxd_Pixels.getChannelOffset(fmt,3) >= 0)
            ddsOut.b[outPos] = 4
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            v = None
            v1 = fmt.index
            if (v1 == 3):
                v = 113
            elif (v1 == 4):
                v = 116
            elif (v1 == 6):
                v = 111
            elif (v1 == 7):
                v = 114
            elif (v1 == 9):
                v = 112
            elif (v1 == 10):
                v = 115
            else:
                raise haxe_Exception.thrown(("Unsupported format " + Std.string(fmt)))
            ddsOut.b[outPos] = (v & 255)
            ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
            ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
            ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 0
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 0
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 0
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 0
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 0
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
        v = ((((0 if ((len(pixels) == 1)) else 8)) | 4096) | ((0 if ((len(levels) == 1)) else 4194304)))
        ddsOut.b[outPos] = (v & 255)
        ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
        ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
        ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        outPos = (outPos + 4)
        cubebits = (((((1536 | ((2048 if ((layerCount > 1)) else 0))) | ((4096 if ((layerCount > 2)) else 0))) | ((8192 if ((layerCount > 3)) else 0))) | ((16384 if ((layerCount > 4)) else 0))) | ((32768 if ((layerCount > 5)) else 0)))
        v = (cubebits if isCubeMap else 0)
        ddsOut.b[outPos] = (v & 255)
        ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
        ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
        ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        _g = 0
        _g1 = layerCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = len(levels)
            while (_g2 < _g3):
                l = _g2
                _g2 = (_g2 + 1)
                p = python_internal_ArrayImpl._get((levels[l] if l >= 0 and l < len(levels) else None), i)
                ddsOut.blit(outPos,p.bytes,p.offset,p.dataSize)
                outPos = (outPos + p.dataSize)
        return ddsOut

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bytes = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.dataSize = None
        _hx_o.offset = None
        _hx_o.flags = None
        _hx_o.stride = None
        _hx_o.bytesPerPixel = None
        _hx_o.innerFormat = None
hxd_Pixels._hx_class = hxd_Pixels
_hx_classes["hxd.Pixels"] = hxd_Pixels


class hxd_Res:
    _hx_class_name = "hxd.Res"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["load", "get_loader", "set_loader"]
    loader = None
    tree = None
    cocoa_yellow = None
    cocoa_red = None
    cocoa_purple = None
    cocoa_green = None
    chest = None
    background = None
    GloriaHallelujah = None
    GloriaHallelujah_Regular = None

    @staticmethod
    def load(name):
        return hxd_Res.get_loader().load(name)

    @staticmethod
    def get_loader():
        l = hxd_res_Loader.currentInstance
        if (l is None):
            raise haxe_Exception.thrown("Resource loader not initialized: call to hxd.Res.initXXX() required")
        return l

    @staticmethod
    def set_loader(l):
        def _hx_local_1():
            def _hx_local_0():
                hxd_res_Loader.currentInstance = l
                return hxd_res_Loader.currentInstance
            return _hx_local_0()
        return _hx_local_1()
hxd_Res._hx_class = hxd_Res
_hx_classes["hxd.Res"] = hxd_Res


class hxd_SceneEvents:
    _hx_class_name = "hxd.SceneEvents"
    _hx_is_interface = "False"
    __slots__ = ("window", "scenes", "overList", "overCandidates", "overIndex", "currentFocus", "pendingEvents", "pushList", "currentDrag", "mouseX", "mouseY", "lastTouch", "focusLost", "checkPos", "onOut", "onOver", "isOut", "enablePhysicalMouse", "mouseCheckMove", "defaultCursor")
    _hx_fields = ["window", "scenes", "overList", "overCandidates", "overIndex", "currentFocus", "pendingEvents", "pushList", "currentDrag", "mouseX", "mouseY", "lastTouch", "focusLost", "checkPos", "onOut", "onOver", "isOut", "enablePhysicalMouse", "mouseCheckMove", "defaultCursor"]
    _hx_methods = ["setMousePos", "onRemove", "addScene", "removeScene", "dispose", "focus", "blur", "checkFocus", "emitEvent", "checkEvents", "startCapture", "stopCapture", "startDrag", "stopDrag", "getFocus", "updateCursor", "set_defaultCursor", "selectCursor", "onEvent", "dispatchListeners"]

    def __init__(self,window = None):
        self.currentDrag = None
        self.currentFocus = None
        self.defaultCursor = hxd_Cursor.Default
        self.mouseCheckMove = True
        self.enablePhysicalMouse = True
        self.isOut = False
        self.onOver = hxd_Event(hxd_EventKind.EOver)
        self.onOut = hxd_Event(hxd_EventKind.EOut)
        self.checkPos = hxd_Event(hxd_EventKind.ECheck)
        self.focusLost = hxd_Event(hxd_EventKind.EFocusLost)
        self.lastTouch = 0
        self.mouseY = -1.
        self.mouseX = -1.
        self.overIndex = -1
        self.scenes = []
        self.pendingEvents = []
        self.pushList = []
        self.overList = []
        self.overCandidates = []
        if (window is None):
            window = hxd_Window.getInstance()
        self.window = window
        window.addEventTarget(self.onEvent)

    def setMousePos(self,xPos,yPos):
        self.mouseX = xPos
        self.mouseY = yPos

    def onRemove(self,i):
        if (i == self.currentFocus):
            self.currentFocus = None
        if (self.overIndex >= 0):
            index = python_internal_ArrayImpl.indexOf(self.overList,i,None)
            if (index >= 0):
                python_internal_ArrayImpl.remove(self.overList,i)
                if (index < self.overIndex):
                    _hx_local_0 = self
                    _hx_local_1 = _hx_local_0.overIndex
                    _hx_local_0.overIndex = (_hx_local_1 - 1)
                    _hx_local_1
        else:
            python_internal_ArrayImpl.remove(self.overList,i)
            self.selectCursor()
        python_internal_ArrayImpl.remove(self.pushList,i)

    def addScene(self,s,index = None):
        s.setEvents(self)
        if (index is None):
            _this = self.scenes
            _this.append(s)
        else:
            self.scenes.insert(index, s)

    def removeScene(self,s):
        if python_internal_ArrayImpl.remove(self.scenes,s):
            s.setEvents(None)

    def dispose(self):
        self.window.removeEventTarget(self.onEvent)

    def focus(self,i):
        if (self.currentFocus == i):
            return
        if (i is None):
            self.blur()
            return
        if (self.currentFocus is not None):
            self.blur()
            if (self.currentFocus is not None):
                return
        e = hxd_Event(hxd_EventKind.EFocus)
        i.handleEvent(e)
        if (not e.cancel):
            self.currentFocus = i

    def blur(self):
        if (self.currentFocus is None):
            return
        self.focusLost.cancel = False
        self.currentFocus.handleEvent(self.focusLost)
        if (not self.focusLost.cancel):
            self.currentFocus = None

    def checkFocus(self):
        if (self.currentFocus is None):
            return
        s = self.currentFocus.getInteractiveScene()
        if (s is None):
            self.currentFocus = None
            return
        if (not s.isInteractiveVisible(self.currentFocus)):
            self.blur()

    def emitEvent(self,event):
        oldX = event.relX
        oldY = event.relY
        overCandidateCount = 0
        handled = False
        checkOver = False
        fillOver = False
        checkPush = False
        cancelFocus = False
        updateCursor = False
        self.overIndex = 0
        tmp = event.kind.index
        if (tmp == 0):
            cancelFocus = True
            checkPush = True
        elif (tmp == 1):
            checkPush = True
        elif ((tmp == 12) or ((tmp == 2))):
            checkOver = True
            fillOver = True
        elif ((((tmp == 11) or ((tmp == 9))) or ((tmp == 8))) or ((tmp == 5))):
            if (self.currentFocus is not None):
                def _hx_local_0():
                    event.relY = 0
                    return event.relY
                event.relX = _hx_local_0()
                self.currentFocus.handleEvent(event)
                event.relX = oldX
                event.relY = oldY
                if (not event.propagate):
                    return
        else:
            pass
        _g = 0
        _g1 = self.scenes
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            last = None
            while True:
                i = s.handleEvent(event,last)
                if (i is None):
                    event.relX = oldX
                    event.relY = oldY
                    break
                if checkOver:
                    if fillOver:
                        idx = python_internal_ArrayImpl.indexOf(self.overList,i,None)
                        if (idx == -1):
                            if (len(self.overCandidates) == overCandidateCount):
                                python_internal_ArrayImpl._set(self.overCandidates, overCandidateCount, _hx_AnonObject({'i': i, 's': s, 'x': event.relX, 'y': event.relY, 'z': event.relZ}))
                            else:
                                info = (self.overCandidates[overCandidateCount] if overCandidateCount >= 0 and overCandidateCount < len(self.overCandidates) else None)
                                info.i = i
                                info.s = s
                                info.x = event.relX
                                info.y = event.relY
                                info.z = event.relZ
                            overCandidateCount = (overCandidateCount + 1)
                            pos = self.overIndex
                            self.overIndex = (self.overIndex + 1)
                            self.overList.insert(pos, i)
                            updateCursor = True
                        else:
                            if (idx < self.overIndex):
                                while True:
                                    python_internal_ArrayImpl._set(self.overList, idx, python_internal_ArrayImpl._get(self.overList, (idx + 1)))
                                    idx = (idx + 1)
                                    if (not ((idx < self.overIndex))):
                                        break
                                python_internal_ArrayImpl._set(self.overList, self.overIndex, i)
                                updateCursor = True
                            elif (idx > self.overIndex):
                                while True:
                                    python_internal_ArrayImpl._set(self.overList, idx, python_internal_ArrayImpl._get(self.overList, (idx - 1)))
                                    idx = (idx - 1)
                                    if (not ((idx > self.overIndex))):
                                        break
                                python_internal_ArrayImpl._set(self.overList, self.overIndex, i)
                                updateCursor = True
                            _hx_local_5 = self
                            _hx_local_6 = _hx_local_5.overIndex
                            _hx_local_5.overIndex = (_hx_local_6 + 1)
                            _hx_local_6
                        fillOver = event.propagate
                else:
                    if checkPush:
                        if (event.kind == hxd_EventKind.EPush):
                            _this = self.pushList
                            _this.append(i)
                        else:
                            python_internal_ArrayImpl.remove(self.pushList,i)
                    if (cancelFocus and ((i == self.currentFocus))):
                        cancelFocus = False
                event.relX = oldX
                event.relY = oldY
                if (not event.propagate):
                    handled = True
                    break
                last = i
                event.propagate = False
            if handled:
                break
        if (cancelFocus and ((self.currentFocus is not None))):
            self.blur()
        if checkOver:
            if (self.overIndex < len(self.overList)):
                while (self.overIndex < len(self.overList)):
                    _this = self.overList
                    e = (None if ((len(_this) == 0)) else _this.pop())
                    e.handleEvent(self.onOut)
                updateCursor = True
            if (overCandidateCount != 0):
                i = 0
                ev = self.onOver
                while True:
                    info = i
                    i = (i + 1)
                    info1 = (self.overCandidates[info] if info >= 0 and info < len(self.overCandidates) else None)
                    ev.relX = info1.x
                    ev.relY = info1.y
                    ev.relZ = info1.z
                    if info1.s.isInteractiveVisible(info1.i):
                        info1.i.handleEvent(ev)
                    else:
                        python_internal_ArrayImpl.remove(self.overList,info1.i)
                    info1.i = None
                    info1.s = None
                    if (not ((i < overCandidateCount))):
                        break
        self.overIndex = -1
        if updateCursor:
            self.selectCursor()
        if ((not handled) and ((event != self.checkPos))):
            if (event.kind == hxd_EventKind.EPush):
                _this = self.pushList
                _this.append(None)
            elif (event.kind == hxd_EventKind.ERelease):
                python_internal_ArrayImpl.remove(self.pushList,None)
            self.dispatchListeners(event)
        if ((event.kind == hxd_EventKind.ERelease) and ((len(self.pushList) > 0))):
            _g = 0
            _g1 = self.pushList
            while (_g < len(_g1)):
                i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (i is None):
                    event.kind = hxd_EventKind.EReleaseOutside
                    self.dispatchListeners(event)
                    event.kind = hxd_EventKind.ERelease
                else:
                    s = i.getInteractiveScene()
                    if (s is None):
                        continue
                    event.kind = hxd_EventKind.EReleaseOutside
                    s.dispatchEvent(event,i)
                    event.kind = hxd_EventKind.ERelease
                    event.relX = oldX
                    event.relY = oldY
            self.pushList = list()

    def checkEvents(self):
        old = self.pendingEvents
        checkMoved = (not self.mouseCheckMove)
        checkFocused = (self.currentFocus is None)
        if (len(old) > 0):
            self.pendingEvents = []
            _g = 0
            while (_g < len(old)):
                e = (old[_g] if _g >= 0 and _g < len(old) else None)
                _g = (_g + 1)
                ox = e.relX
                oy = e.relY
                tmp = e.kind.index
                if ((tmp == 1) or ((tmp == 0))):
                    self.mouseX = e.relX
                    self.mouseY = e.relY
                    self.lastTouch = e.touchId
                elif (tmp == 2):
                    checkMoved = True
                    self.mouseX = e.relX
                    self.mouseY = e.relY
                    self.lastTouch = e.touchId
                elif (tmp == 3):
                    self.isOut = False
                    self.selectCursor()
                    continue
                elif (tmp == 4):
                    self.isOut = True
                    if (len(self.overList) > 0):
                        i = (len(self.overList) - 1)
                        while (i >= 0):
                            self.onOut.cancel = False
                            (self.overList[i] if i >= 0 and i < len(self.overList) else None).handleEvent(self.onOut)
                            python_internal_ArrayImpl.remove(self.overList,(self.overList[i] if i >= 0 and i < len(self.overList) else None))
                            i = (i - 1)
                        self.selectCursor()
                    continue
                elif ((((tmp == 11) or ((tmp == 9))) or ((tmp == 8))) or ((tmp == 5))):
                    if (not checkFocused):
                        checkFocused = True
                        self.checkFocus()
                else:
                    pass
                if ((self.currentDrag is not None) and (((self.currentDrag.ref is None) or ((self.currentDrag.ref == e.touchId))))):
                    e.propagate = True
                    e.cancel = False
                    self.currentDrag.f(e)
                    e.relX = ox
                    e.relY = oy
                    if (not e.propagate):
                        continue
                self.emitEvent(e)
        if (not checkFocused):
            self.checkFocus()
        if (((not checkMoved) and (not self.isOut)) and ((self.currentDrag is None))):
            self.checkPos.relX = self.mouseX
            self.checkPos.relY = self.mouseY
            self.checkPos.touchId = self.lastTouch
            self.checkPos.cancel = False
            self.checkPos.propagate = False
            self.emitEvent(self.checkPos)

    def startCapture(self,f,onCancel = None,touchId = None):
        if ((self.currentDrag is not None) and ((self.currentDrag.onCancel is not None))):
            self.currentDrag.onCancel()
        self.currentDrag = _hx_AnonObject({'f': f, 'ref': touchId, 'onCancel': onCancel})

    def stopCapture(self):
        if ((self.currentDrag is not None) and ((self.currentDrag.onCancel is not None))):
            self.currentDrag.onCancel()
        self.currentDrag = None

    def startDrag(self,f,onCancel = None,refEvent = None):
        self.startCapture(f,onCancel,(refEvent.touchId if ((refEvent is not None)) else None))

    def stopDrag(self):
        self.stopCapture()

    def getFocus(self):
        return self.currentFocus

    def updateCursor(self,i):
        if (python_internal_ArrayImpl.indexOf(self.overList,i,None) != -1):
            self.selectCursor()

    def set_defaultCursor(self,c):
        if Type.enumEq(c,self.defaultCursor):
            return c
        self.defaultCursor = c
        self.selectCursor()
        return c

    def selectCursor(self):
        cur = self.defaultCursor
        _g = 0
        _g1 = self.overList
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (o.cursor is not None):
                cur = o.cursor
                break
        if (cur.index == 6):
            f = cur.params[0]
            f()
        else:
            hxd_System.setCursor(cur)

    def onEvent(self,e):
        if ((not self.enablePhysicalMouse) and ((e.kind == hxd_EventKind.EMove))):
            return
        _this = self.pendingEvents
        _this.append(e)

    def dispatchListeners(self,event):
        ox = event.relX
        oy = event.relY
        event.propagate = True
        _g = 0
        _g1 = self.scenes
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            event.cancel = False
            s.dispatchListeners(event)
            event.relX = ox
            event.relY = oy
            if (not event.propagate):
                break

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.window = None
        _hx_o.scenes = None
        _hx_o.overList = None
        _hx_o.overCandidates = None
        _hx_o.overIndex = None
        _hx_o.currentFocus = None
        _hx_o.pendingEvents = None
        _hx_o.pushList = None
        _hx_o.currentDrag = None
        _hx_o.mouseX = None
        _hx_o.mouseY = None
        _hx_o.lastTouch = None
        _hx_o.focusLost = None
        _hx_o.checkPos = None
        _hx_o.onOut = None
        _hx_o.onOver = None
        _hx_o.isOut = None
        _hx_o.enablePhysicalMouse = None
        _hx_o.mouseCheckMove = None
        _hx_o.defaultCursor = None
hxd_SceneEvents._hx_class = hxd_SceneEvents
_hx_classes["hxd.SceneEvents"] = hxd_SceneEvents

class hxd_Platform(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.Platform"
    _hx_constructs = ["IOS", "Android", "WebGL", "PC", "Console", "FlashPlayer"]
hxd_Platform.IOS = hxd_Platform("IOS", 0, ())
hxd_Platform.Android = hxd_Platform("Android", 1, ())
hxd_Platform.WebGL = hxd_Platform("WebGL", 2, ())
hxd_Platform.PC = hxd_Platform("PC", 3, ())
hxd_Platform.Console = hxd_Platform("Console", 4, ())
hxd_Platform.FlashPlayer = hxd_Platform("FlashPlayer", 5, ())
hxd_Platform._hx_class = hxd_Platform
_hx_classes["hxd.Platform"] = hxd_Platform

class hxd_SystemValue(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.SystemValue"
    _hx_constructs = ["IsTouch", "IsWindowed", "IsMobile"]
hxd_SystemValue.IsTouch = hxd_SystemValue("IsTouch", 0, ())
hxd_SystemValue.IsWindowed = hxd_SystemValue("IsWindowed", 1, ())
hxd_SystemValue.IsMobile = hxd_SystemValue("IsMobile", 2, ())
hxd_SystemValue._hx_class = hxd_SystemValue
_hx_classes["hxd.SystemValue"] = hxd_SystemValue


class hxd_System:
    _hx_class_name = "hxd.System"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["setCursor", "timeoutTick", "loopFunc", "getCurrentLoop", "setLoop", "start", "setNativeCursor", "getDeviceName", "getDefaultFrameRate", "getValue", "exit", "openURL", "get_width", "get_height", "get_lang", "get_platform", "get_screenDPI", "get_allowTimeout", "set_allowTimeout"]
    width = None
    height = None
    lang = None
    platform = None
    screenDPI = None
    allowTimeout = None
    loopFunc = None

    @staticmethod
    def timeoutTick():
        pass

    @staticmethod
    def getCurrentLoop():
        return hxd_System.loopFunc

    @staticmethod
    def setLoop(f):
        hxd_System.loopFunc = f

    @staticmethod
    def start(callb):
        pass

    @staticmethod
    def setNativeCursor(c):
        pass

    @staticmethod
    def getDeviceName():
        return "Unknown"

    @staticmethod
    def getDefaultFrameRate():
        return 60.

    @staticmethod
    def getValue(s):
        return False

    @staticmethod
    def exit():
        pass

    @staticmethod
    def openURL(url):
        pass

    @staticmethod
    def get_width():
        return 0

    @staticmethod
    def get_height():
        return 0

    @staticmethod
    def get_lang():
        return "en"

    @staticmethod
    def get_platform():
        return hxd_Platform.PC

    @staticmethod
    def get_screenDPI():
        return 72

    @staticmethod
    def get_allowTimeout():
        return False

    @staticmethod
    def set_allowTimeout(b):
        return False
hxd_System._hx_class = hxd_System
_hx_classes["hxd.System"] = hxd_System


class hxd_Timer:
    _hx_class_name = "hxd.Timer"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["wantedFPS", "maxDeltaTime", "smoothFactor", "lastTimeStamp", "elapsedTime", "frameCount", "dt", "currentDT", "update", "get_tmod", "set_tmod", "fps", "skip", "reset"]
    tmod = None

    @staticmethod
    def update():
        _hx_local_0 = hxd_Timer
        _hx_local_1 = _hx_local_0.frameCount
        _hx_local_0.frameCount = (_hx_local_1 + 1)
        _hx_local_1
        newTime = python_lib_Timeit.default_timer()
        hxd_Timer.elapsedTime = (newTime - hxd_Timer.lastTimeStamp)
        hxd_Timer.lastTimeStamp = newTime
        if (hxd_Timer.elapsedTime < hxd_Timer.maxDeltaTime):
            a = hxd_Timer.elapsedTime
            hxd_Timer.currentDT = (a + ((hxd_Timer.smoothFactor * ((hxd_Timer.currentDT - a)))))
        else:
            hxd_Timer.elapsedTime = (1 / hxd_Timer.wantedFPS)
        hxd_Timer.dt = hxd_Timer.currentDT

    @staticmethod
    def get_tmod():
        return (hxd_Timer.dt * hxd_Timer.wantedFPS)

    @staticmethod
    def set_tmod(v):
        hxd_Timer.dt = (v / hxd_Timer.wantedFPS)
        return v

    @staticmethod
    def fps():
        return (1. / hxd_Timer.currentDT)

    @staticmethod
    def skip():
        hxd_Timer.lastTimeStamp = python_lib_Timeit.default_timer()

    @staticmethod
    def reset():
        hxd_Timer.lastTimeStamp = python_lib_Timeit.default_timer()
        def _hx_local_0():
            hxd_Timer.currentDT = (1. / hxd_Timer.wantedFPS)
            return hxd_Timer.currentDT
        hxd_Timer.dt = _hx_local_0()
hxd_Timer._hx_class = hxd_Timer
_hx_classes["hxd.Timer"] = hxd_Timer

class hxd_DisplayMode(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.DisplayMode"
    _hx_constructs = ["Windowed", "Borderless", "Fullscreen", "FullscreenResize"]
hxd_DisplayMode.Windowed = hxd_DisplayMode("Windowed", 0, ())
hxd_DisplayMode.Borderless = hxd_DisplayMode("Borderless", 1, ())
hxd_DisplayMode.Fullscreen = hxd_DisplayMode("Fullscreen", 2, ())
hxd_DisplayMode.FullscreenResize = hxd_DisplayMode("FullscreenResize", 3, ())
hxd_DisplayMode._hx_class = hxd_DisplayMode
_hx_classes["hxd.DisplayMode"] = hxd_DisplayMode


class hxd_Window:
    _hx_class_name = "hxd.Window"
    _hx_is_interface = "False"
    _hx_fields = ["resizeEvents", "eventTargets"]
    _hx_methods = ["onClose", "event", "addEventTarget", "removeEventTarget", "addResizeEvent", "removeResizeEvent", "onResize", "resize", "setFullScreen", "get_mouseX", "get_mouseY", "get_width", "get_height", "get_mouseLock", "set_mouseLock", "get_vsync", "set_vsync", "get_isFocused", "get_displayMode", "set_displayMode", "get_title", "set_title"]
    _hx_statics = ["inst", "getInstance"]

    def __init__(self):
        self.eventTargets = haxe_ds_List()
        self.resizeEvents = haxe_ds_List()

    def onClose(self):
        return True

    def event(self,e):
        _g_head = self.eventTargets.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            et = val
            et(e)

    def addEventTarget(self,et):
        self.eventTargets.add(et)

    def removeEventTarget(self,et):
        _g_head = self.eventTargets.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            e = val
            if Reflect.compareMethods(e,et):
                self.eventTargets.remove(e)
                break

    def addResizeEvent(self,f):
        self.resizeEvents.push(f)

    def removeResizeEvent(self,f):
        _g_head = self.resizeEvents.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            e = val
            if Reflect.compareMethods(e,f):
                self.resizeEvents.remove(f)
                break

    def onResize(self,e):
        _g_head = self.resizeEvents.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            r = val
            r()

    def resize(self,width,height):
        pass

    def setFullScreen(self,v):
        pass

    def get_mouseX(self):
        return 0

    def get_mouseY(self):
        return 0

    def get_width(self):
        return 0

    def get_height(self):
        return 0

    def get_mouseLock(self):
        return False

    def set_mouseLock(self,v):
        if v:
            raise haxe_Exception.thrown("Not implemented")
        return False

    def get_vsync(self):
        return True

    def set_vsync(self,b):
        if (not b):
            raise haxe_Exception.thrown("Can't disable vsync on this platform")
        return True

    def get_isFocused(self):
        return True

    def get_displayMode(self):
        return hxd_DisplayMode.Windowed

    def set_displayMode(self,m):
        return m

    def get_title(self):
        return ""

    def set_title(self,t):
        return t

    @staticmethod
    def getInstance():
        if (hxd_Window.inst is None):
            hxd_Window.inst = hxd_Window()
        return hxd_Window.inst

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.resizeEvents = None
        _hx_o.eventTargets = None
hxd_Window._hx_class = hxd_Window
_hx_classes["hxd.Window"] = hxd_Window

class hxd_clipper_ClipType(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.ClipType"
    _hx_constructs = ["Intersection", "Union", "Difference", "Xor"]
hxd_clipper_ClipType.Intersection = hxd_clipper_ClipType("Intersection", 0, ())
hxd_clipper_ClipType.Union = hxd_clipper_ClipType("Union", 1, ())
hxd_clipper_ClipType.Difference = hxd_clipper_ClipType("Difference", 2, ())
hxd_clipper_ClipType.Xor = hxd_clipper_ClipType("Xor", 3, ())
hxd_clipper_ClipType._hx_class = hxd_clipper_ClipType
_hx_classes["hxd.clipper.ClipType"] = hxd_clipper_ClipType

class hxd_clipper__Clipper_EdgeSide(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper._Clipper.EdgeSide"
    _hx_constructs = ["Left", "Right"]
hxd_clipper__Clipper_EdgeSide.Left = hxd_clipper__Clipper_EdgeSide("Left", 0, ())
hxd_clipper__Clipper_EdgeSide.Right = hxd_clipper__Clipper_EdgeSide("Right", 1, ())
hxd_clipper__Clipper_EdgeSide._hx_class = hxd_clipper__Clipper_EdgeSide
_hx_classes["hxd.clipper._Clipper.EdgeSide"] = hxd_clipper__Clipper_EdgeSide

class hxd_clipper__Clipper_Direction(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper._Clipper.Direction"
    _hx_constructs = ["RightToLeft", "LeftToRight"]
hxd_clipper__Clipper_Direction.RightToLeft = hxd_clipper__Clipper_Direction("RightToLeft", 0, ())
hxd_clipper__Clipper_Direction.LeftToRight = hxd_clipper__Clipper_Direction("LeftToRight", 1, ())
hxd_clipper__Clipper_Direction._hx_class = hxd_clipper__Clipper_Direction
_hx_classes["hxd.clipper._Clipper.Direction"] = hxd_clipper__Clipper_Direction


class hxd_clipper__Clipper_PolyNode:
    _hx_class_name = "hxd.clipper._Clipper.PolyNode"
    _hx_is_interface = "False"
    __slots__ = ("parent", "childs", "polygon", "index", "jointype", "endtype")
    _hx_fields = ["parent", "childs", "polygon", "index", "jointype", "endtype"]
    _hx_methods = ["isHoleNode", "get_childCount", "get_contour", "addChild", "getNext", "getNextSiblingUp", "isHole"]

    def __init__(self):
        self.endtype = None
        self.jointype = None
        self.index = None
        self.parent = None
        points = []
        this1 = ([] if ((points is None)) else points)
        self.polygon = this1
        self.childs = []

    def isHoleNode(self):
        result = True
        node = self.parent
        while (node is not None):
            result = (not result)
            node = node.parent
        return result

    def get_childCount(self):
        return len(self.childs)

    def get_contour(self):
        return self.polygon

    def addChild(self,child):
        cnt = len(self.childs)
        _this = self.childs
        _this.append(child)
        child.parent = self
        child.index = cnt

    def getNext(self):
        if (len(self.childs) > 0):
            return (self.childs[0] if 0 < len(self.childs) else None)
        else:
            return self.getNextSiblingUp()

    def getNextSiblingUp(self):
        if (self.parent is None):
            return None
        elif (self.index == ((len(self.parent.childs) - 1))):
            return self.parent.getNextSiblingUp()
        else:
            return python_internal_ArrayImpl._get(self.parent.childs, (self.index + 1))

    def isHole(self):
        return self.isHoleNode()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.parent = None
        _hx_o.childs = None
        _hx_o.polygon = None
        _hx_o.index = None
        _hx_o.jointype = None
        _hx_o.endtype = None
hxd_clipper__Clipper_PolyNode._hx_class = hxd_clipper__Clipper_PolyNode
_hx_classes["hxd.clipper._Clipper.PolyNode"] = hxd_clipper__Clipper_PolyNode


class hxd_clipper__Clipper_PolyTree(hxd_clipper__Clipper_PolyNode):
    _hx_class_name = "hxd.clipper._Clipper.PolyTree"
    _hx_is_interface = "False"
    __slots__ = ("allPolys",)
    _hx_fields = ["allPolys"]
    _hx_methods = ["toPolygons", "addRec", "clear", "getFirst", "get_total"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_clipper__Clipper_PolyNode


    def __init__(self):
        self.allPolys = None
        super().__init__()
        self.allPolys = []

    def toPolygons(self,polygons):
        polygons = []
        self.addRec(self,polygons)

    def addRec(self,polynode,polygons):
        if (len(polynode.polygon) > 0):
            x = polynode.polygon
            polygons.append(x)
        _g = 0
        _g1 = polynode.childs
        while (_g < len(_g1)):
            pn = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.addRec(pn,polygons)

    def clear(self):
        self.allPolys = []
        self.childs = []

    def getFirst(self):
        if (len(self.childs) > 0):
            return (self.childs[0] if 0 < len(self.childs) else None)
        return None

    def get_total(self):
        result = len(self.allPolys)
        if ((result > 0) and (((self.childs[0] if 0 < len(self.childs) else None) != (self.allPolys[0] if 0 < len(self.allPolys) else None)))):
            result = (result - 1)
        return result

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.allPolys = None
hxd_clipper__Clipper_PolyTree._hx_class = hxd_clipper__Clipper_PolyTree
_hx_classes["hxd.clipper._Clipper.PolyTree"] = hxd_clipper__Clipper_PolyTree


class hxd_clipper__Clipper_Ref:
    _hx_class_name = "hxd.clipper._Clipper.Ref"
    _hx_is_interface = "False"
    __slots__ = ("val",)
    _hx_fields = ["val"]

    def __init__(self,v = None):
        self.val = v

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.val = None
hxd_clipper__Clipper_Ref._hx_class = hxd_clipper__Clipper_Ref
_hx_classes["hxd.clipper._Clipper.Ref"] = hxd_clipper__Clipper_Ref


class hxd_clipper__Clipper_TEdge:
    _hx_class_name = "hxd.clipper._Clipper.TEdge"
    _hx_is_interface = "False"
    __slots__ = ("botX", "botY", "currX", "currY", "topX", "topY", "deltaX", "deltaY", "dx", "polyType", "side", "windDelta", "windCnt", "windCnt2", "outIdx", "next", "prev", "nextInLML", "nextInAEL", "prevInAEL", "nextInSEL", "prevInSEL")
    _hx_fields = ["botX", "botY", "currX", "currY", "topX", "topY", "deltaX", "deltaY", "dx", "polyType", "side", "windDelta", "windCnt", "windCnt2", "outIdx", "next", "prev", "nextInLML", "nextInAEL", "prevInAEL", "nextInSEL", "prevInSEL"]
    _hx_methods = ["get_top", "get_bot", "get_curr", "set_top", "set_bot", "set_curr"]

    def __init__(self):
        self.prevInSEL = None
        self.nextInSEL = None
        self.prevInAEL = None
        self.nextInAEL = None
        self.nextInLML = None
        self.prev = None
        self.next = None
        self.outIdx = None
        self.windCnt2 = None
        self.windCnt = None
        self.windDelta = None
        self.side = None
        self.polyType = None
        self.dx = None
        self.deltaY = None
        self.deltaX = None
        self.topY = None
        self.topX = None
        self.currY = None
        self.currX = None
        self.botY = None
        self.botX = None

    def get_top(self):
        return h2d_col_IPoint(self.topX,self.topY)

    def get_bot(self):
        return h2d_col_IPoint(self.botX,self.botY)

    def get_curr(self):
        return h2d_col_IPoint(self.currX,self.currY)

    def set_top(self,p):
        self.topX = p.x
        self.topY = p.y
        return p

    def set_bot(self,p):
        self.botX = p.x
        self.botY = p.y
        return p

    def set_curr(self,p):
        self.currX = p.x
        self.currY = p.y
        return p

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.botX = None
        _hx_o.botY = None
        _hx_o.currX = None
        _hx_o.currY = None
        _hx_o.topX = None
        _hx_o.topY = None
        _hx_o.deltaX = None
        _hx_o.deltaY = None
        _hx_o.dx = None
        _hx_o.polyType = None
        _hx_o.side = None
        _hx_o.windDelta = None
        _hx_o.windCnt = None
        _hx_o.windCnt2 = None
        _hx_o.outIdx = None
        _hx_o.next = None
        _hx_o.prev = None
        _hx_o.nextInLML = None
        _hx_o.nextInAEL = None
        _hx_o.prevInAEL = None
        _hx_o.nextInSEL = None
        _hx_o.prevInSEL = None
hxd_clipper__Clipper_TEdge._hx_class = hxd_clipper__Clipper_TEdge
_hx_classes["hxd.clipper._Clipper.TEdge"] = hxd_clipper__Clipper_TEdge


class hxd_clipper__Clipper_IntersectNode:
    _hx_class_name = "hxd.clipper._Clipper.IntersectNode"
    _hx_is_interface = "False"
    __slots__ = ("edge1", "edge2", "pt")
    _hx_fields = ["edge1", "edge2", "pt"]

    def __init__(self):
        self.pt = None
        self.edge2 = None
        self.edge1 = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.edge1 = None
        _hx_o.edge2 = None
        _hx_o.pt = None
hxd_clipper__Clipper_IntersectNode._hx_class = hxd_clipper__Clipper_IntersectNode
_hx_classes["hxd.clipper._Clipper.IntersectNode"] = hxd_clipper__Clipper_IntersectNode


class hxd_clipper__Clipper_LocalMinima:
    _hx_class_name = "hxd.clipper._Clipper.LocalMinima"
    _hx_is_interface = "False"
    __slots__ = ("y", "leftBound", "rightBound", "next")
    _hx_fields = ["y", "leftBound", "rightBound", "next"]

    def __init__(self):
        self.next = None
        self.rightBound = None
        self.leftBound = None
        self.y = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.y = None
        _hx_o.leftBound = None
        _hx_o.rightBound = None
        _hx_o.next = None
hxd_clipper__Clipper_LocalMinima._hx_class = hxd_clipper__Clipper_LocalMinima
_hx_classes["hxd.clipper._Clipper.LocalMinima"] = hxd_clipper__Clipper_LocalMinima


class hxd_clipper__Clipper_Scanbeam:
    _hx_class_name = "hxd.clipper._Clipper.Scanbeam"
    _hx_is_interface = "False"
    __slots__ = ("y", "next")
    _hx_fields = ["y", "next"]

    def __init__(self):
        self.next = None
        self.y = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.y = None
        _hx_o.next = None
hxd_clipper__Clipper_Scanbeam._hx_class = hxd_clipper__Clipper_Scanbeam
_hx_classes["hxd.clipper._Clipper.Scanbeam"] = hxd_clipper__Clipper_Scanbeam


class hxd_clipper__Clipper_OutRec:
    _hx_class_name = "hxd.clipper._Clipper.OutRec"
    _hx_is_interface = "False"
    __slots__ = ("idx", "isHole", "firstLeft", "pts", "bottomPt", "polyNode")
    _hx_fields = ["idx", "isHole", "firstLeft", "pts", "bottomPt", "polyNode"]

    def __init__(self):
        self.polyNode = None
        self.bottomPt = None
        self.pts = None
        self.firstLeft = None
        self.isHole = None
        self.idx = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.idx = None
        _hx_o.isHole = None
        _hx_o.firstLeft = None
        _hx_o.pts = None
        _hx_o.bottomPt = None
        _hx_o.polyNode = None
hxd_clipper__Clipper_OutRec._hx_class = hxd_clipper__Clipper_OutRec
_hx_classes["hxd.clipper._Clipper.OutRec"] = hxd_clipper__Clipper_OutRec


class hxd_clipper__Clipper_OutPt:
    _hx_class_name = "hxd.clipper._Clipper.OutPt"
    _hx_is_interface = "False"
    __slots__ = ("idx", "pt", "next", "prev")
    _hx_fields = ["idx", "pt", "next", "prev"]

    def __init__(self):
        self.prev = None
        self.next = None
        self.pt = None
        self.idx = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.idx = None
        _hx_o.pt = None
        _hx_o.next = None
        _hx_o.prev = None
hxd_clipper__Clipper_OutPt._hx_class = hxd_clipper__Clipper_OutPt
_hx_classes["hxd.clipper._Clipper.OutPt"] = hxd_clipper__Clipper_OutPt


class hxd_clipper__Clipper_Join:
    _hx_class_name = "hxd.clipper._Clipper.Join"
    _hx_is_interface = "False"
    __slots__ = ("outPt1", "outPt2", "offPt")
    _hx_fields = ["outPt1", "outPt2", "offPt"]

    def __init__(self):
        self.offPt = None
        self.outPt2 = None
        self.outPt1 = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.outPt1 = None
        _hx_o.outPt2 = None
        _hx_o.offPt = None
hxd_clipper__Clipper_Join._hx_class = hxd_clipper__Clipper_Join
_hx_classes["hxd.clipper._Clipper.Join"] = hxd_clipper__Clipper_Join


class hxd_clipper__Clipper_ClipperBase:
    _hx_class_name = "hxd.clipper._Clipper.ClipperBase"
    _hx_is_interface = "False"
    __slots__ = ("preserveCollinear", "m_MinimaList", "m_CurrentLM", "m_edges")
    _hx_fields = ["preserveCollinear", "m_MinimaList", "m_CurrentLM", "m_edges"]
    _hx_methods = ["isHorizontal", "abs", "PointIsVertex", "PointOnLineSegment", "PointOnPolygon", "SlopesEqual", "SlopesEqual3", "clear", "disposeLocalMinimaList", "addPolygons", "addPolygon", "InitEdge", "InitEdge2", "RemoveEdge", "FindNextLocMin", "ProcessBound", "ReverseHorizontal", "Pt2IsBetweenPt1AndPt3", "SetDx", "InsertLocalMinima", "PopLocalMinima", "SwapX", "equals", "Reset"]
    _hx_statics = ["HORIZONTAL", "TOLERANCE", "SKIP", "UNASSIGNED", "nearZero", "getBounds"]

    def __init__(self):
        self.preserveCollinear = None
        self.m_edges = []
        self.m_MinimaList = None
        self.m_CurrentLM = None

    def isHorizontal(self,e):
        return (e.deltaY == 0)

    def abs(self,i):
        if (i < 0):
            return -i
        else:
            return i

    def PointIsVertex(self,pt,pp):
        pp2 = pp
        while True:
            pt1 = pp2.pt
            if ((pt1.x == pt.x) and ((pt1.y == pt.y))):
                return True
            pp2 = pp2.next
            if (not ((pp2 != pp))):
                break
        return False

    def PointOnLineSegment(self,pt,linePt1,linePt2):
        if (not ((((pt.x == linePt1.x) and ((pt.y == linePt1.y))) or (((pt.x == linePt2.x) and ((pt.y == linePt2.y))))))):
            if (((pt.x > linePt1.x) == ((pt.x < linePt2.x))) and (((pt.y > linePt1.y) == ((pt.y < linePt2.y))))):
                return ((((pt.x - linePt1.x)) * ((linePt2.y - linePt1.y))) == ((((linePt2.x - linePt1.x)) * ((pt.y - linePt1.y)))))
            else:
                return False
        else:
            return True

    def PointOnPolygon(self,pt,pp):
        pp2 = pp
        while True:
            if self.PointOnLineSegment(pt,pp2.pt,pp2.next.pt):
                return True
            pp2 = pp2.next
            if (pp2 == pp):
                break
        return False

    def SlopesEqual(self,e1,e2):
        return ((e1.deltaY * e2.deltaX) == ((e1.deltaX * e2.deltaY)))

    def SlopesEqual3(self,pt1,pt2,pt3):
        return (((((pt1.y - pt2.y)) * ((pt2.x - pt3.x))) - ((((pt1.x - pt2.x)) * ((pt2.y - pt3.y))))) == 0)

    def clear(self):
        self.disposeLocalMinimaList()
        self.m_edges = []

    def disposeLocalMinimaList(self):
        while (self.m_MinimaList is not None):
            tmpLm = self.m_MinimaList.next
            self.m_MinimaList = None
            self.m_MinimaList = tmpLm
        self.m_CurrentLM = None

    def addPolygons(self,ppg,polyType):
        result = False
        _g_i = 0
        _g_a = ppg
        _g_l = len(_g_a)
        while (_g_i < _g_l):
            p = _g_i
            _g_i = (_g_i + 1)
            p1 = (_g_a[p] if p >= 0 and p < len(_g_a) else None)
            if self.addPolygon(p1,polyType):
                result = True
        return result

    def addPolygon(self,pg,polyType):
        highI = (len(pg) - 1)
        while ((highI > 0) and (((pg[highI] if highI >= 0 and highI < len(pg) else None) == (pg[0] if 0 < len(pg) else None)))):
            highI = (highI - 1)
        while ((highI > 0) and (((pg[highI] if highI >= 0 and highI < len(pg) else None) == python_internal_ArrayImpl._get(pg, (highI - 1))))):
            highI = (highI - 1)
        if (highI < 2):
            return False
        edges = []
        _g = 0
        _g1 = (highI + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = hxd_clipper__Clipper_TEdge()
            edges.append(x)
        isFlat = True
        _this = (edges[1] if 1 < len(edges) else None)
        p = (pg[1] if 1 < len(pg) else None)
        _this.currX = p.x
        _this.currY = p.y
        e = (edges[0] if 0 < len(edges) else None)
        pt = (pg[0] if 0 < len(pg) else None)
        e.next = (edges[1] if 1 < len(edges) else None)
        e.prev = (edges[highI] if highI >= 0 and highI < len(edges) else None)
        e.currX = pt.x
        e.currY = pt.y
        e.outIdx = -1
        e = (edges[highI] if highI >= 0 and highI < len(edges) else None)
        pt = (pg[highI] if highI >= 0 and highI < len(pg) else None)
        e.next = (edges[0] if 0 < len(edges) else None)
        e.prev = python_internal_ArrayImpl._get(edges, (highI - 1))
        e.currX = pt.x
        e.currY = pt.y
        e.outIdx = -1
        i = (highI - 1)
        while (i > 0):
            e = (edges[i] if i >= 0 and i < len(edges) else None)
            pt = (pg[i] if i >= 0 and i < len(pg) else None)
            e.next = python_internal_ArrayImpl._get(edges, (i + 1))
            e.prev = python_internal_ArrayImpl._get(edges, (i - 1))
            e.currX = pt.x
            e.currY = pt.y
            e.outIdx = -1
            i = (i - 1)
        eStart = (edges[0] if 0 < len(edges) else None)
        eStop = eStart
        e = eStart
        while True:
            if ((e.currX == e.next.currX) and ((e.currY == e.next.currY))):
                if (e == e.next):
                    break
                if (e == eStart):
                    eStart = e.next
                e = self.RemoveEdge(e)
                eStop = e
                continue
            if (e.prev == e.next):
                break
            tmp = None
            _this = e.prev
            x = _this.currX
            y = _this.currY
            if (y is None):
                y = 0
            if (x is None):
                x = 0
            pt1_x = x
            pt1_y = y
            x1 = e.currX
            y1 = e.currY
            if (y1 is None):
                y1 = 0
            if (x1 is None):
                x1 = 0
            pt2_x = x1
            pt2_y = y1
            _this1 = e.next
            x2 = _this1.currX
            y2 = _this1.currY
            if (y2 is None):
                y2 = 0
            if (x2 is None):
                x2 = 0
            pt3_x = x2
            pt3_y = y2
            if (((((pt1_y - pt2_y)) * ((pt2_x - pt3_x))) - ((((pt1_x - pt2_x)) * ((pt2_y - pt3_y))))) == 0):
                if self.preserveCollinear:
                    _this2 = e.prev
                    tmp1 = h2d_col_IPoint(_this2.currX,_this2.currY)
                    tmp2 = h2d_col_IPoint(e.currX,e.currY)
                    _this3 = e.next
                    tmp = (not self.Pt2IsBetweenPt1AndPt3(tmp1,tmp2,h2d_col_IPoint(_this3.currX,_this3.currY)))
                else:
                    tmp = True
            else:
                tmp = False
            if tmp:
                if (e == eStart):
                    eStart = e.next
                e = self.RemoveEdge(e)
                e = e.prev
                eStop = e
                continue
            e = e.next
            if (e == eStop):
                break
        if (e.prev == e.next):
            return False
        e = eStart
        while True:
            if (e.currY >= e.next.currY):
                e.botX = e.currX
                e.botY = e.currY
                e.topX = e.next.currX
                e.topY = e.next.currY
            else:
                e.topX = e.currX
                e.topY = e.currY
                e.botX = e.next.currX
                e.botY = e.next.currY
            self.SetDx(e)
            e.polyType = polyType
            e = e.next
            if (e.currY != eStart.currY):
                isFlat = False
            if (not ((e != eStart))):
                break
        if isFlat:
            return False
        _this = self.m_edges
        _this.append(edges)
        leftBoundIsForward = None
        eMin = None
        if ((e.prev.botX == e.prev.topX) and ((e.prev.botY == e.prev.topY))):
            e = e.next
        old = None
        while True:
            e = self.FindNextLocMin(e)
            if (e == eMin):
                break
            elif (eMin is None):
                eMin = e
            if (e == old):
                raise haxe_Exception.thrown("!")
            old = e
            locMin = hxd_clipper__Clipper_LocalMinima()
            locMin.next = None
            locMin.y = e.botY
            if (e.dx < e.prev.dx):
                locMin.leftBound = e.prev
                locMin.rightBound = e
                leftBoundIsForward = False
            else:
                locMin.leftBound = e
                locMin.rightBound = e.prev
                leftBoundIsForward = True
            locMin.leftBound.side = hxd_clipper__Clipper_EdgeSide.Left
            locMin.rightBound.side = hxd_clipper__Clipper_EdgeSide.Right
            if (locMin.leftBound.next == locMin.rightBound):
                locMin.leftBound.windDelta = -1
            else:
                locMin.leftBound.windDelta = 1
            locMin.rightBound.windDelta = -locMin.leftBound.windDelta
            e = self.ProcessBound(locMin.leftBound,leftBoundIsForward)
            if (e.outIdx == -2):
                e = self.ProcessBound(e,leftBoundIsForward)
            e2 = self.ProcessBound(locMin.rightBound,(not leftBoundIsForward))
            if (e2.outIdx == -2):
                e2 = self.ProcessBound(e2,(not leftBoundIsForward))
            if (locMin.leftBound.outIdx == -2):
                locMin.leftBound = None
            elif (locMin.rightBound.outIdx == -2):
                locMin.rightBound = None
            self.InsertLocalMinima(locMin)
            if (not leftBoundIsForward):
                e = e2
        return True

    def InitEdge(self,e,eNext,ePrev,pt):
        e.next = eNext
        e.prev = ePrev
        e.currX = pt.x
        e.currY = pt.y
        e.outIdx = -1

    def InitEdge2(self,e,polyType):
        if (e.currY >= e.next.currY):
            e.botX = e.currX
            e.botY = e.currY
            e.topX = e.next.currX
            e.topY = e.next.currY
        else:
            e.topX = e.currX
            e.topY = e.currY
            e.botX = e.next.currX
            e.botY = e.next.currY
        self.SetDx(e)
        e.polyType = polyType

    def RemoveEdge(self,e):
        e.prev.next = e.next
        e.next.prev = e.prev
        result = e.next
        e.prev = None
        return result

    def FindNextLocMin(self,e):
        e2 = None
        while True:
            while (((e.botX != e.prev.botX) or ((e.botY != e.prev.botY))) or (((e.currX == e.topX) and ((e.currY == e.topY))))):
                e = e.next
            if ((e.dx != -9007199254740992.) and ((e.prev.dx != -9007199254740992.))):
                break
            while (e.prev.dx == -9007199254740992.):
                e = e.prev
            e2 = e
            while (e.dx == -9007199254740992.):
                e = e.next
            if (e.topY == e.prev.botY):
                continue
            if (e2.prev.botX < e.botX):
                e = e2
            break
        return e

    def ProcessBound(self,E,LeftBoundIsForward):
        EStart = None
        Horz = None
        Result = E
        if (Result.outIdx == -2):
            E = Result
            if LeftBoundIsForward:
                while (E.topY == E.next.botY):
                    E = E.next
                while ((E != Result) and ((E.dx == -9007199254740992.))):
                    E = E.prev
            else:
                while (E.topY == E.prev.botY):
                    E = E.prev
                while ((E != Result) and ((E.dx == -9007199254740992.))):
                    E = E.next
            if (E == Result):
                if LeftBoundIsForward:
                    Result = E.next
                else:
                    Result = E.prev
            else:
                if LeftBoundIsForward:
                    E = Result.next
                else:
                    E = Result.prev
                locMin = hxd_clipper__Clipper_LocalMinima()
                locMin.next = None
                locMin.y = E.botY
                locMin.leftBound = None
                locMin.rightBound = E
                E.windDelta = 0
                Result = self.ProcessBound(E,LeftBoundIsForward)
                self.InsertLocalMinima(locMin)
            return Result
        if (E.dx == -9007199254740992.):
            if LeftBoundIsForward:
                EStart = E.prev
            else:
                EStart = E.next
            if (EStart.outIdx != -2):
                if (EStart.dx == -9007199254740992.):
                    if ((EStart.botX != E.botX) and ((EStart.topX != E.botX))):
                        self.ReverseHorizontal(E)
                elif (EStart.botX != E.botX):
                    self.ReverseHorizontal(E)
        EStart = E
        if LeftBoundIsForward:
            while ((Result.topY == Result.next.botY) and ((Result.next.outIdx != -2))):
                Result = Result.next
            if ((Result.dx == -9007199254740992.) and ((Result.next.outIdx != -2))):
                Horz = Result
                while (Horz.prev.dx == -9007199254740992.):
                    Horz = Horz.prev
                if (Horz.prev.topX == Result.next.topX):
                    if (not LeftBoundIsForward):
                        Result = Horz.prev
                elif (Horz.prev.topX > Result.next.topX):
                    Result = Horz.prev
            while (E != Result):
                E.nextInLML = E.next
                if (((E.dx == -9007199254740992.) and ((E != EStart))) and ((E.botX != E.prev.topX))):
                    self.ReverseHorizontal(E)
                E = E.next
            if (((E.dx == -9007199254740992.) and ((E != EStart))) and ((E.botX != E.prev.topX))):
                self.ReverseHorizontal(E)
            Result = Result.next
        else:
            while ((Result.topY == Result.prev.botY) and ((Result.prev.outIdx != -2))):
                Result = Result.prev
            if ((Result.dx == -9007199254740992.) and ((Result.prev.outIdx != -2))):
                Horz = Result
                while (Horz.next.dx == -9007199254740992.):
                    Horz = Horz.next
                if (Horz.next.topX == Result.prev.topX):
                    if (not LeftBoundIsForward):
                        Result = Horz.next
                elif (Horz.next.topX > Result.prev.topX):
                    Result = Horz.next
            while (E != Result):
                E.nextInLML = E.prev
                if (((E.dx == -9007199254740992.) and ((E != EStart))) and ((E.botX != E.next.topX))):
                    self.ReverseHorizontal(E)
                E = E.prev
            if (((E.dx == -9007199254740992.) and ((E != EStart))) and ((E.botX != E.next.topX))):
                self.ReverseHorizontal(E)
            Result = Result.prev
        return Result

    def ReverseHorizontal(self,e):
        tmp = e.topX
        e.topX = e.botX
        e.botX = tmp

    def Pt2IsBetweenPt1AndPt3(self,pt1,pt2,pt3):
        if ((((pt1.x == pt3.x) and ((pt1.y == pt3.y))) or (((pt1.x == pt2.x) and ((pt1.y == pt2.y))))) or (((pt3.x == pt2.x) and ((pt3.y == pt2.y))))):
            return False
        elif (pt1.x != pt3.x):
            return ((pt2.x > pt1.x) == ((pt2.x < pt3.x)))
        else:
            return ((pt2.y > pt1.y) == ((pt2.y < pt3.y)))

    def SetDx(self,e):
        e.deltaX = (e.topX - e.botX)
        e.deltaY = (e.topY - e.botY)
        if (e.deltaY == 0):
            e.dx = -9007199254740992.
        else:
            e.dx = (e.deltaX / e.deltaY)

    def InsertLocalMinima(self,newLm):
        if (self.m_MinimaList is None):
            self.m_MinimaList = newLm
        elif (newLm.y >= self.m_MinimaList.y):
            newLm.next = self.m_MinimaList
            self.m_MinimaList = newLm
        else:
            tmpLm = self.m_MinimaList
            while ((tmpLm.next is not None) and ((newLm.y < tmpLm.next.y))):
                tmpLm = tmpLm.next
            newLm.next = tmpLm.next
            tmpLm.next = newLm

    def PopLocalMinima(self):
        if (self.m_CurrentLM is None):
            return
        self.m_CurrentLM = self.m_CurrentLM.next

    def SwapX(self,e):
        e.currX = e.topX
        e.topX = e.botX
        e.botX = e.currX

    def equals(self,pt1,pt2):
        if (pt1.x == pt2.x):
            return (pt1.y == pt2.y)
        else:
            return False

    def Reset(self):
        self.m_CurrentLM = self.m_MinimaList
        lm = self.m_MinimaList
        while (lm is not None):
            e = lm.leftBound
            if (e is not None):
                e.currX = e.botX
                e.currY = e.botY
                e.side = hxd_clipper__Clipper_EdgeSide.Left
                e.outIdx = -1
                e = e.nextInLML
            e = lm.rightBound
            if (e is not None):
                e.currX = e.botX
                e.currY = e.botY
                e.side = hxd_clipper__Clipper_EdgeSide.Right
                e.outIdx = -1
                e = e.nextInLML
            lm = lm.next

    @staticmethod
    def nearZero(v):
        if (v > -1e-20):
            return (v < 1E-20)
        else:
            return False

    @staticmethod
    def getBounds(pols):
        result = hxd_clipper_Rect()
        i = 0
        count = len(pols)
        while ((i < count) and ((len((pols[i] if i >= 0 and i < len(pols) else None)) == 0))):
            i = (i + 1)
        tmp = (i == count)
        def _hx_local_1():
            result.right = python_internal_ArrayImpl._get((pols[i] if i >= 0 and i < len(pols) else None), 0).x
            return result.right
        result.left = _hx_local_1()
        def _hx_local_2():
            result.bottom = python_internal_ArrayImpl._get((pols[i] if i >= 0 and i < len(pols) else None), 0).y
            return result.bottom
        result.top = _hx_local_2()
        _g = 0
        _g1 = count
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g_i = 0
            _g_a = (pols[i] if i >= 0 and i < len(pols) else None)
            _g_l = len(_g_a)
            while (_g_i < _g_l):
                p = _g_i
                _g_i = (_g_i + 1)
                p1 = (_g_a[p] if p >= 0 and p < len(_g_a) else None)
                if (p1.x < result.left):
                    result.left = p1.x
                elif (p1.x > result.right):
                    result.right = p1.x
                if (p1.y < result.top):
                    result.top = p1.y
                elif (p1.y > result.bottom):
                    result.bottom = p1.y
        return result

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.preserveCollinear = None
        _hx_o.m_MinimaList = None
        _hx_o.m_CurrentLM = None
        _hx_o.m_edges = None
hxd_clipper__Clipper_ClipperBase._hx_class = hxd_clipper__Clipper_ClipperBase
_hx_classes["hxd.clipper._Clipper.ClipperBase"] = hxd_clipper__Clipper_ClipperBase

class hxd_clipper_NodeType(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.NodeType"
    _hx_constructs = ["Any", "Open", "Closed"]
hxd_clipper_NodeType.Any = hxd_clipper_NodeType("Any", 0, ())
hxd_clipper_NodeType.Open = hxd_clipper_NodeType("Open", 1, ())
hxd_clipper_NodeType.Closed = hxd_clipper_NodeType("Closed", 2, ())
hxd_clipper_NodeType._hx_class = hxd_clipper_NodeType
_hx_classes["hxd.clipper.NodeType"] = hxd_clipper_NodeType

class hxd_clipper_ResultKind(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.ResultKind"
    _hx_constructs = ["All", "NoHoles", "HolesOnly"]
hxd_clipper_ResultKind.All = hxd_clipper_ResultKind("All", 0, ())
hxd_clipper_ResultKind.NoHoles = hxd_clipper_ResultKind("NoHoles", 1, ())
hxd_clipper_ResultKind.HolesOnly = hxd_clipper_ResultKind("HolesOnly", 2, ())
hxd_clipper_ResultKind._hx_class = hxd_clipper_ResultKind
_hx_classes["hxd.clipper.ResultKind"] = hxd_clipper_ResultKind


class hxd_clipper_Clipper(hxd_clipper__Clipper_ClipperBase):
    _hx_class_name = "hxd.clipper.Clipper"
    _hx_is_interface = "False"
    __slots__ = ("strictlySimple", "reverseSolution", "resultKind", "m_PolyOuts", "m_ClipType", "m_Scanbeam", "m_ActiveEdges", "m_SortedEdges", "m_IntersectList", "m_ExecuteLocked", "m_ClipFillType", "m_SubjFillType", "m_Joins", "m_GhostJoins", "m_UsingPolyTree")
    _hx_fields = ["strictlySimple", "reverseSolution", "resultKind", "m_PolyOuts", "m_ClipType", "m_Scanbeam", "m_ActiveEdges", "m_SortedEdges", "m_IntersectList", "m_ExecuteLocked", "m_ClipFillType", "m_SubjFillType", "m_Joins", "m_GhostJoins", "m_UsingPolyTree"]
    _hx_methods = ["xor", "DisposeScanbeamList", "Reset", "InsertScanbeam", "execute", "ExecuteTree", "FixHoleLinkage", "ExecuteInternal", "PopScanbeam", "DisposeAllPolyPts", "DisposeOutRec", "AddJoin", "AddGhostJoin", "InsertLocalMinimaIntoAEL", "InsertEdgeIntoAEL", "E2InsertsBeforeE1", "IsEvenOddFillType", "IsEvenOddAltFillType", "IsContributing", "SetWindingCount", "AddEdgeToSEL", "CopyAELToSEL", "SwapPositionsInAEL", "SwapPositionsInSEL", "AddLocalMaxPoly", "AddLocalMinPoly", "CreateOutRec", "AddOutPt", "HorzSegmentsOverlap", "SetHoleState", "GetDx", "FirstIsBottomPt", "GetBottomPt", "GetLowermostRec", "Param1RightOfParam2", "GetOutRec", "AppendPolygon", "ReversePolyPtLinks", "SwapSides", "SwapPolyIndexes", "IntersectEdges", "DeleteFromAEL", "DeleteFromSEL", "UpdateEdgeIntoAEL", "GetHorzDirection", "ProcessHorizontals", "ProcessHorizontal", "GetNextInAEL", "IsMinima", "IsMaxima", "IsIntermediate", "GetMaximaPair", "ProcessIntersections", "BuildIntersectList", "EdgesAdjacent", "IntersectNodeSort", "FixupIntersectionOrder", "ProcessIntersectList", "Round", "TopX", "IntersectPoint", "ProcessEdgesAtTopOfScanbeam", "DoMaxima", "reversePolygons", "PointCount", "BuildResult", "BuildResult2", "FixupOutPolygon", "DupOutPt", "GetOverlap", "JoinHorz", "JoinPoints", "PointInPolygon", "PointInPolygon2", "Poly2ContainsPoly1", "FixupFirstLefts1", "FixupFirstLefts2", "ParseFirstLeft", "JoinCommonEdges", "UpdateOutPtIdxs", "DoSimplePolygons", "Area", "DistanceFromLineSqrd", "SlopesNearCollinear", "PointsAreClose", "ExcludeOp", "CleanPolygon", "CleanPolygons", "Minkowski", "MinkowskiSum", "TranslatePath", "PolyTreeToPaths", "AddPolyNodeToPaths"]
    _hx_statics = ["compareY", "Orientation", "polArea", "SimplifyPolygon", "SimplifyPolygons", "MinkowskiSums", "MinkowskiDiff"]
    _hx_interfaces = []
    _hx_super = hxd_clipper__Clipper_ClipperBase


    def __init__(self):
        self.m_UsingPolyTree = None
        self.m_GhostJoins = None
        self.m_Joins = None
        self.m_SubjFillType = None
        self.m_ClipFillType = None
        self.m_ExecuteLocked = None
        self.m_IntersectList = None
        self.m_SortedEdges = None
        self.m_ActiveEdges = None
        self.m_Scanbeam = None
        self.m_ClipType = None
        self.m_PolyOuts = None
        self.resultKind = None
        self.reverseSolution = None
        self.strictlySimple = None
        super().__init__()
        self.m_Scanbeam = None
        self.m_ActiveEdges = None
        self.m_SortedEdges = None
        self.m_IntersectList = []
        self.m_ExecuteLocked = False
        self.m_UsingPolyTree = False
        self.m_PolyOuts = []
        self.m_Joins = []
        self.m_GhostJoins = []
        self.reverseSolution = False
        self.strictlySimple = False
        self.preserveCollinear = False
        self.resultKind = hxd_clipper_ResultKind.All

    def xor(self,a,b):
        if a:
            return (not b)
        else:
            return b

    def DisposeScanbeamList(self):
        while (self.m_Scanbeam is not None):
            sb2 = self.m_Scanbeam.next
            self.m_Scanbeam = None
            self.m_Scanbeam = sb2

    def Reset(self):
        super().Reset()
        self.m_Scanbeam = None
        self.m_ActiveEdges = None
        self.m_SortedEdges = None
        lm = self.m_MinimaList
        while (lm is not None):
            self.InsertScanbeam(lm.y)
            lm = lm.next

    def InsertScanbeam(self,y):
        if (self.m_Scanbeam is None):
            self.m_Scanbeam = hxd_clipper__Clipper_Scanbeam()
            self.m_Scanbeam.next = None
            self.m_Scanbeam.y = y
        elif (y > self.m_Scanbeam.y):
            newSb = hxd_clipper__Clipper_Scanbeam()
            newSb.y = y
            newSb.next = self.m_Scanbeam
            self.m_Scanbeam = newSb
        else:
            sb2 = self.m_Scanbeam
            while ((sb2.next is not None) and ((y <= sb2.next.y))):
                sb2 = sb2.next
            if (y == sb2.y):
                return
            newSb = hxd_clipper__Clipper_Scanbeam()
            newSb.y = y
            newSb.next = sb2.next
            sb2.next = newSb

    def execute(self,clipType,subjFillType = None,clipFillType = None):
        if (subjFillType is None):
            subjFillType = hxd_clipper_PolyFillType.EvenOdd
        if (clipFillType is None):
            clipFillType = hxd_clipper_PolyFillType.EvenOdd
        if self.m_ExecuteLocked:
            return []
        self.m_ExecuteLocked = True
        solution = []
        self.m_SubjFillType = subjFillType
        self.m_ClipFillType = clipFillType
        self.m_ClipType = clipType
        self.m_UsingPolyTree = False
        succeeded = self.ExecuteInternal()
        if succeeded:
            solution = self.BuildResult()
        self.DisposeAllPolyPts()
        self.m_ExecuteLocked = False
        return solution

    def ExecuteTree(self,clipType,polytree,subjFillType = None,clipFillType = None):
        if (subjFillType is None):
            subjFillType = hxd_clipper_PolyFillType.EvenOdd
        if (clipFillType is None):
            clipFillType = hxd_clipper_PolyFillType.EvenOdd
        if self.m_ExecuteLocked:
            return False
        self.m_ExecuteLocked = True
        self.m_SubjFillType = subjFillType
        self.m_ClipFillType = clipFillType
        self.m_ClipType = clipType
        self.m_UsingPolyTree = True
        succeeded = self.ExecuteInternal()
        if succeeded:
            self.BuildResult2(polytree)
        self.m_ExecuteLocked = False
        return succeeded

    def FixHoleLinkage(self,outRec):
        if ((outRec.firstLeft is None) or (((outRec.isHole != outRec.firstLeft.isHole) and ((outRec.firstLeft.pts is not None))))):
            return
        orfl = outRec.firstLeft
        while ((orfl is not None) and (((orfl.isHole == outRec.isHole) or ((orfl.pts is None))))):
            orfl = orfl.firstLeft
        outRec.firstLeft = orfl

    def ExecuteInternal(self):
        self.Reset()
        if (self.m_CurrentLM is None):
            return False
        botY = self.PopScanbeam()
        while True:
            self.InsertLocalMinimaIntoAEL(botY)
            if (len(self.m_GhostJoins) > 0):
                self.m_GhostJoins = []
            self.ProcessHorizontals(False)
            if (self.m_Scanbeam is None):
                break
            topY = self.PopScanbeam()
            if (not self.ProcessIntersections(topY)):
                return False
            self.ProcessEdgesAtTopOfScanbeam(topY)
            botY = topY
            if (not (((self.m_Scanbeam is not None) or ((self.m_CurrentLM is not None))))):
                break
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (outRec.pts is None):
                continue
            b = self.reverseSolution
            if ((((not b) if (outRec.isHole) else b)) == ((self.Area(outRec) > 0))):
                self.ReversePolyPtLinks(outRec.pts)
        self.JoinCommonEdges()
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (outRec.pts is not None):
                self.FixupOutPolygon(outRec)
        if self.strictlySimple:
            self.DoSimplePolygons()
        self.m_Joins = []
        self.m_GhostJoins = []
        return True

    def PopScanbeam(self):
        y = self.m_Scanbeam.y
        self.m_Scanbeam = self.m_Scanbeam.next
        return y

    def DisposeAllPolyPts(self):
        _g = 0
        _g1 = len(self.m_PolyOuts)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.DisposeOutRec(i)
        self.m_PolyOuts = []

    def DisposeOutRec(self,index):
        outRec = (self.m_PolyOuts[index] if index >= 0 and index < len(self.m_PolyOuts) else None)
        outRec.pts = None
        outRec = None
        python_internal_ArrayImpl._set(self.m_PolyOuts, index, None)

    def AddJoin(self,op1,op2,offPt):
        j = hxd_clipper__Clipper_Join()
        j.outPt1 = op1
        j.outPt2 = op2
        j.offPt = offPt
        _this = self.m_Joins
        _this.append(j)

    def AddGhostJoin(self,op,offPt):
        j = hxd_clipper__Clipper_Join()
        j.outPt1 = op
        j.offPt = offPt
        _this = self.m_GhostJoins
        _this.append(j)

    def InsertLocalMinimaIntoAEL(self,botY):
        while ((self.m_CurrentLM is not None) and ((self.m_CurrentLM.y == botY))):
            lb = self.m_CurrentLM.leftBound
            rb = self.m_CurrentLM.rightBound
            self.PopLocalMinima()
            op1 = None
            if (lb is None):
                self.InsertEdgeIntoAEL(rb)
                self.SetWindingCount(rb)
                if self.IsContributing(rb):
                    op1 = self.AddOutPt(rb,h2d_col_IPoint(rb.botX,rb.botY))
            elif (rb is None):
                self.InsertEdgeIntoAEL(lb)
                self.SetWindingCount(lb)
                if self.IsContributing(lb):
                    op1 = self.AddOutPt(lb,h2d_col_IPoint(lb.botX,lb.botY))
                self.InsertScanbeam(lb.topY)
            else:
                self.InsertEdgeIntoAEL(lb)
                self.InsertEdgeIntoAEL(rb,lb)
                self.SetWindingCount(lb)
                rb.windCnt = lb.windCnt
                rb.windCnt2 = lb.windCnt2
                if self.IsContributing(lb):
                    op1 = self.AddLocalMinPoly(lb,rb,h2d_col_IPoint(lb.botX,lb.botY))
                self.InsertScanbeam(lb.topY)
            if (rb is not None):
                if (rb.deltaY == 0):
                    self.AddEdgeToSEL(rb)
                else:
                    self.InsertScanbeam(rb.topY)
            if ((lb is None) or ((rb is None))):
                continue
            if ((((op1 is not None) and ((rb.deltaY == 0))) and ((len(self.m_GhostJoins) > 0))) and ((rb.windDelta != 0))):
                _g = 0
                _g1 = self.m_GhostJoins
                while (_g < len(_g1)):
                    j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    if self.HorzSegmentsOverlap(j.outPt1.pt.x,j.offPt.x,rb.botX,rb.topX):
                        self.AddJoin(j.outPt1,op1,j.offPt)
            tmp = None
            if ((((lb.outIdx >= 0) and ((lb.prevInAEL is not None))) and ((lb.prevInAEL.currX == lb.botX))) and ((lb.prevInAEL.outIdx >= 0))):
                e1 = lb.prevInAEL
                tmp = ((e1.deltaY * lb.deltaX) == ((e1.deltaX * lb.deltaY)))
            else:
                tmp = False
            if ((tmp and ((lb.windDelta != 0))) and ((lb.prevInAEL.windDelta != 0))):
                op2 = self.AddOutPt(lb.prevInAEL,h2d_col_IPoint(lb.botX,lb.botY))
                self.AddJoin(op1,op2,h2d_col_IPoint(lb.topX,lb.topY))
            if (lb.nextInAEL != rb):
                tmp1 = None
                if ((rb.outIdx >= 0) and ((rb.prevInAEL.outIdx >= 0))):
                    e11 = rb.prevInAEL
                    tmp1 = ((e11.deltaY * rb.deltaX) == ((e11.deltaX * rb.deltaY)))
                else:
                    tmp1 = False
                if ((tmp1 and ((rb.windDelta != 0))) and ((rb.prevInAEL.windDelta != 0))):
                    op21 = self.AddOutPt(rb.prevInAEL,h2d_col_IPoint(rb.botX,rb.botY))
                    self.AddJoin(op1,op21,h2d_col_IPoint(rb.topX,rb.topY))
                e = lb.nextInAEL
                if (e is not None):
                    while (e != rb):
                        self.IntersectEdges(rb,e,h2d_col_IPoint(lb.currX,lb.currY))
                        e = e.nextInAEL

    def InsertEdgeIntoAEL(self,edge,startEdge = None):
        if (self.m_ActiveEdges is None):
            edge.prevInAEL = None
            edge.nextInAEL = None
            self.m_ActiveEdges = edge
        elif ((startEdge is None) and self.E2InsertsBeforeE1(self.m_ActiveEdges,edge)):
            edge.prevInAEL = None
            edge.nextInAEL = self.m_ActiveEdges
            self.m_ActiveEdges.prevInAEL = edge
            self.m_ActiveEdges = edge
        else:
            if (startEdge is None):
                startEdge = self.m_ActiveEdges
            while ((startEdge.nextInAEL is not None) and (not self.E2InsertsBeforeE1(startEdge.nextInAEL,edge))):
                startEdge = startEdge.nextInAEL
            edge.nextInAEL = startEdge.nextInAEL
            if (startEdge.nextInAEL is not None):
                startEdge.nextInAEL.prevInAEL = edge
            edge.prevInAEL = startEdge
            startEdge.nextInAEL = edge

    def E2InsertsBeforeE1(self,e1,e2):
        if (e2.currX == e1.currX):
            if (e2.topY > e1.topY):
                e21 = e2.topX
                currentY = e2.topY
                tmp = None
                if (currentY == e1.topY):
                    tmp = e1.topX
                else:
                    e11 = e1.botX
                    value = (e1.dx * ((currentY - e1.botY)))
                    tmp1 = None
                    if (value < 0):
                        tmp2 = None
                        try:
                            tmp2 = int((value - 0.5))
                        except BaseException as _g:
                            None
                            tmp2 = None
                        tmp1 = tmp2
                    else:
                        tmp2 = None
                        try:
                            tmp2 = int((value + 0.5))
                        except BaseException as _g:
                            None
                            tmp2 = None
                        tmp1 = tmp2
                    tmp = (e11 + tmp1)
                return (e21 < tmp)
            else:
                e11 = e1.topX
                currentY = e1.topY
                tmp = None
                if (currentY == e2.topY):
                    tmp = e2.topX
                else:
                    e21 = e2.botX
                    value = (e2.dx * ((currentY - e2.botY)))
                    tmp1 = None
                    if (value < 0):
                        tmp2 = None
                        try:
                            tmp2 = int((value - 0.5))
                        except BaseException as _g:
                            None
                            tmp2 = None
                        tmp1 = tmp2
                    else:
                        tmp2 = None
                        try:
                            tmp2 = int((value + 0.5))
                        except BaseException as _g:
                            None
                            tmp2 = None
                        tmp1 = tmp2
                    tmp = (e21 + tmp1)
                return (e11 > tmp)
        else:
            return (e2.currX < e1.currX)

    def IsEvenOddFillType(self,edge):
        if (edge.polyType == hxd_clipper_PolyType.Subject):
            return (self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd)
        else:
            return (self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)

    def IsEvenOddAltFillType(self,edge):
        if (edge.polyType == hxd_clipper_PolyType.Subject):
            return (self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)
        else:
            return (self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd)

    def IsContributing(self,edge):
        pft = None
        pft2 = None
        if (edge.polyType == hxd_clipper_PolyType.Subject):
            pft = self.m_SubjFillType
            pft2 = self.m_ClipFillType
        else:
            pft = self.m_ClipFillType
            pft2 = self.m_SubjFillType
        tmp = pft.index
        if (tmp == 0):
            if ((edge.windDelta == 0) and ((edge.windCnt != 1))):
                return False
        elif (tmp == 1):
            f = edge.windCnt
            if (((-f if ((f < 0)) else f)) != 1):
                return False
        elif (tmp == 2):
            if (edge.windCnt != 1):
                return False
        elif (edge.windCnt != -1):
            return False
        tmp = self.m_ClipType.index
        if (tmp == 0):
            tmp = pft2.index
            if ((tmp == 1) or ((tmp == 0))):
                return (edge.windCnt2 != 0)
            elif (tmp == 2):
                return (edge.windCnt2 > 0)
            else:
                return (edge.windCnt2 < 0)
        elif (tmp == 1):
            tmp = pft2.index
            if ((tmp == 1) or ((tmp == 0))):
                return (edge.windCnt2 == 0)
            elif (tmp == 2):
                return (edge.windCnt2 <= 0)
            else:
                return (edge.windCnt2 >= 0)
        elif (tmp == 2):
            if (edge.polyType == hxd_clipper_PolyType.Subject):
                tmp = pft2.index
                if ((tmp == 1) or ((tmp == 0))):
                    return (edge.windCnt2 == 0)
                elif (tmp == 2):
                    return (edge.windCnt2 <= 0)
                else:
                    return (edge.windCnt2 >= 0)
            else:
                tmp = pft2.index
                if ((tmp == 1) or ((tmp == 0))):
                    return (edge.windCnt2 != 0)
                elif (tmp == 2):
                    return (edge.windCnt2 > 0)
                else:
                    return (edge.windCnt2 < 0)
        elif (tmp == 3):
            if (edge.windDelta == 0):
                tmp = pft2.index
                if ((tmp == 1) or ((tmp == 0))):
                    return (edge.windCnt2 == 0)
                elif (tmp == 2):
                    return (edge.windCnt2 <= 0)
                else:
                    return (edge.windCnt2 >= 0)
            else:
                return True
        else:
            pass

    def SetWindingCount(self,edge):
        e = edge.prevInAEL
        while ((e is not None) and (((e.polyType != edge.polyType) or ((e.windDelta == 0))))):
            e = e.prevInAEL
        if (e is None):
            edge.windCnt = (1 if ((edge.windDelta == 0)) else edge.windDelta)
            edge.windCnt2 = 0
            e = self.m_ActiveEdges
        elif ((edge.windDelta == 0) and ((self.m_ClipType != hxd_clipper_ClipType.Union))):
            edge.windCnt = 1
            edge.windCnt2 = e.windCnt2
            e = e.nextInAEL
        elif ((self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd) if ((edge.polyType == hxd_clipper_PolyType.Subject)) else (self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)):
            if (edge.windDelta == 0):
                Inside = True
                e2 = e.prevInAEL
                while (e2 is not None):
                    if ((e2.polyType == e.polyType) and ((e2.windDelta != 0))):
                        Inside = (not Inside)
                    e2 = e2.prevInAEL
                edge.windCnt = (0 if Inside else 1)
            else:
                edge.windCnt = edge.windDelta
            edge.windCnt2 = e.windCnt2
            e = e.nextInAEL
        else:
            if ((e.windCnt * e.windDelta) < 0):
                if ((e.windCnt > 1) or ((e.windCnt < -1))):
                    if ((e.windDelta * edge.windDelta) < 0):
                        edge.windCnt = e.windCnt
                    else:
                        edge.windCnt = (e.windCnt + edge.windDelta)
                else:
                    edge.windCnt = (1 if ((edge.windDelta == 0)) else edge.windDelta)
            elif (edge.windDelta == 0):
                edge.windCnt = ((e.windCnt - 1) if ((e.windCnt < 0)) else (e.windCnt + 1))
            elif ((e.windDelta * edge.windDelta) < 0):
                edge.windCnt = e.windCnt
            else:
                edge.windCnt = (e.windCnt + edge.windDelta)
            edge.windCnt2 = e.windCnt2
            e = e.nextInAEL
        if ((self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd) if ((edge.polyType == hxd_clipper_PolyType.Subject)) else (self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd)):
            while (e != edge):
                if (e.windDelta != 0):
                    edge.windCnt2 = (1 if ((edge.windCnt2 == 0)) else 0)
                e = e.nextInAEL
        else:
            while (e != edge):
                edge.windCnt2 = (edge.windCnt2 + e.windDelta)
                e = e.nextInAEL

    def AddEdgeToSEL(self,edge):
        if (self.m_SortedEdges is None):
            self.m_SortedEdges = edge
            edge.prevInSEL = None
            edge.nextInSEL = None
        else:
            edge.nextInSEL = self.m_SortedEdges
            edge.prevInSEL = None
            self.m_SortedEdges.prevInSEL = edge
            self.m_SortedEdges = edge

    def CopyAELToSEL(self):
        e = self.m_ActiveEdges
        self.m_SortedEdges = e
        while (e is not None):
            e.prevInSEL = e.prevInAEL
            e.nextInSEL = e.nextInAEL
            e = e.nextInAEL

    def SwapPositionsInAEL(self,edge1,edge2):
        if ((edge1.nextInAEL == edge1.prevInAEL) or ((edge2.nextInAEL == edge2.prevInAEL))):
            return
        if (edge1.nextInAEL == edge2):
            next = edge2.nextInAEL
            if (next is not None):
                next.prevInAEL = edge1
            prev = edge1.prevInAEL
            if (prev is not None):
                prev.nextInAEL = edge2
            edge2.prevInAEL = prev
            edge2.nextInAEL = edge1
            edge1.prevInAEL = edge2
            edge1.nextInAEL = next
        elif (edge2.nextInAEL == edge1):
            next = edge1.nextInAEL
            if (next is not None):
                next.prevInAEL = edge2
            prev = edge2.prevInAEL
            if (prev is not None):
                prev.nextInAEL = edge1
            edge1.prevInAEL = prev
            edge1.nextInAEL = edge2
            edge2.prevInAEL = edge1
            edge2.nextInAEL = next
        else:
            next = edge1.nextInAEL
            prev = edge1.prevInAEL
            edge1.nextInAEL = edge2.nextInAEL
            if (edge1.nextInAEL is not None):
                edge1.nextInAEL.prevInAEL = edge1
            edge1.prevInAEL = edge2.prevInAEL
            if (edge1.prevInAEL is not None):
                edge1.prevInAEL.nextInAEL = edge1
            edge2.nextInAEL = next
            if (edge2.nextInAEL is not None):
                edge2.nextInAEL.prevInAEL = edge2
            edge2.prevInAEL = prev
            if (edge2.prevInAEL is not None):
                edge2.prevInAEL.nextInAEL = edge2
        if (edge1.prevInAEL is None):
            self.m_ActiveEdges = edge1
        elif (edge2.prevInAEL is None):
            self.m_ActiveEdges = edge2

    def SwapPositionsInSEL(self,edge1,edge2):
        if ((edge1.nextInSEL is None) and ((edge1.prevInSEL is None))):
            return
        if ((edge2.nextInSEL is None) and ((edge2.prevInSEL is None))):
            return
        if (edge1.nextInSEL == edge2):
            next = edge2.nextInSEL
            if (next is not None):
                next.prevInSEL = edge1
            prev = edge1.prevInSEL
            if (prev is not None):
                prev.nextInSEL = edge2
            edge2.prevInSEL = prev
            edge2.nextInSEL = edge1
            edge1.prevInSEL = edge2
            edge1.nextInSEL = next
        elif (edge2.nextInSEL == edge1):
            next = edge1.nextInSEL
            if (next is not None):
                next.prevInSEL = edge2
            prev = edge2.prevInSEL
            if (prev is not None):
                prev.nextInSEL = edge1
            edge1.prevInSEL = prev
            edge1.nextInSEL = edge2
            edge2.prevInSEL = edge1
            edge2.nextInSEL = next
        else:
            next = edge1.nextInSEL
            prev = edge1.prevInSEL
            edge1.nextInSEL = edge2.nextInSEL
            if (edge1.nextInSEL is not None):
                edge1.nextInSEL.prevInSEL = edge1
            edge1.prevInSEL = edge2.prevInSEL
            if (edge1.prevInSEL is not None):
                edge1.prevInSEL.nextInSEL = edge1
            edge2.nextInSEL = next
            if (edge2.nextInSEL is not None):
                edge2.nextInSEL.prevInSEL = edge2
            edge2.prevInSEL = prev
            if (edge2.prevInSEL is not None):
                edge2.prevInSEL.nextInSEL = edge2
        if (edge1.prevInSEL is None):
            self.m_SortedEdges = edge1
        elif (edge2.prevInSEL is None):
            self.m_SortedEdges = edge2

    def AddLocalMaxPoly(self,e1,e2,pt):
        self.AddOutPt(e1,pt)
        if (e2.windDelta == 0):
            self.AddOutPt(e2,pt)
        if (e1.outIdx == e2.outIdx):
            e1.outIdx = -1
            e2.outIdx = -1
        elif (e1.outIdx < e2.outIdx):
            self.AppendPolygon(e1,e2)
        else:
            self.AppendPolygon(e2,e1)

    def AddLocalMinPoly(self,e1,e2,pt):
        result = None
        e = None
        prevE = None
        if ((e2.deltaY == 0) or ((e1.dx > e2.dx))):
            result = self.AddOutPt(e1,pt)
            e2.outIdx = e1.outIdx
            e1.side = hxd_clipper__Clipper_EdgeSide.Left
            e2.side = hxd_clipper__Clipper_EdgeSide.Right
            e = e1
            if (e.prevInAEL == e2):
                prevE = e2.prevInAEL
            else:
                prevE = e.prevInAEL
        else:
            result = self.AddOutPt(e2,pt)
            e1.outIdx = e2.outIdx
            e1.side = hxd_clipper__Clipper_EdgeSide.Right
            e2.side = hxd_clipper__Clipper_EdgeSide.Left
            e = e2
            if (e.prevInAEL == e1):
                prevE = e1.prevInAEL
            else:
                prevE = e.prevInAEL
        tmp = None
        if ((prevE is not None) and ((prevE.outIdx >= 0))):
            currentY = pt.y
            tmp1 = None
            if (currentY == prevE.topY):
                tmp1 = prevE.topX
            else:
                prevE1 = prevE.botX
                value = (prevE.dx * ((currentY - prevE.botY)))
                tmp2 = None
                if (value < 0):
                    tmp3 = None
                    try:
                        tmp3 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        tmp3 = None
                    tmp2 = tmp3
                else:
                    tmp3 = None
                    try:
                        tmp3 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        tmp3 = None
                    tmp2 = tmp3
                tmp1 = (prevE1 + tmp2)
            currentY = pt.y
            tmp2 = None
            if (currentY == e.topY):
                tmp2 = e.topX
            else:
                e1 = e.botX
                value = (e.dx * ((currentY - e.botY)))
                tmp3 = None
                if (value < 0):
                    tmp4 = None
                    try:
                        tmp4 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        tmp4 = None
                    tmp3 = tmp4
                else:
                    tmp4 = None
                    try:
                        tmp4 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        tmp4 = None
                    tmp3 = tmp4
                tmp2 = (e1 + tmp3)
            tmp = (tmp1 == tmp2)
        else:
            tmp = False
        if (((tmp and (((e.deltaY * prevE.deltaX) == ((e.deltaX * prevE.deltaY))))) and ((e.windDelta != 0))) and ((prevE.windDelta != 0))):
            out = self.AddOutPt(prevE,pt)
            self.AddJoin(result,out,h2d_col_IPoint(e.topX,e.topY))
        return result

    def CreateOutRec(self):
        result = hxd_clipper__Clipper_OutRec()
        result.idx = -1
        result.isHole = False
        result.firstLeft = None
        result.pts = None
        result.bottomPt = None
        result.polyNode = None
        _this = self.m_PolyOuts
        _this.append(result)
        result.idx = (len(self.m_PolyOuts) - 1)
        return result

    def AddOutPt(self,e,pt):
        ToFront = (e.side == hxd_clipper__Clipper_EdgeSide.Left)
        if (e.outIdx < 0):
            outRec = self.CreateOutRec()
            op = hxd_clipper__Clipper_OutPt()
            outRec.pts = op
            op.idx = outRec.idx
            op.pt = h2d_col_IPoint(pt.x,pt.y)
            op.next = op
            op.prev = op
            self.SetHoleState(e,outRec)
            e.outIdx = outRec.idx
            return op
        else:
            outRec = python_internal_ArrayImpl._get(self.m_PolyOuts, e.outIdx)
            op = outRec.pts
            tmp = None
            if ToFront:
                pt2 = op.pt
                tmp = ((pt.x == pt2.x) and ((pt.y == pt2.y)))
            else:
                tmp = False
            if tmp:
                return op
            else:
                tmp = None
                if (not ToFront):
                    pt2 = op.prev.pt
                    tmp = ((pt.x == pt2.x) and ((pt.y == pt2.y)))
                else:
                    tmp = False
                if tmp:
                    return op.prev
            op2 = hxd_clipper__Clipper_OutPt()
            op2.idx = outRec.idx
            op2.pt = h2d_col_IPoint(pt.x,pt.y)
            op2.next = op
            op2.prev = op.prev
            op2.prev.next = op2
            op.prev = op2
            if ToFront:
                outRec.pts = op2
            return op2

    def HorzSegmentsOverlap(self,seg1a,seg1b,seg2a,seg2b):
        if (seg1a > seg1b):
            tmp = seg1a
            seg1a = seg1b
            seg1b = tmp
        if (seg2a > seg2b):
            tmp = seg2a
            seg2a = seg2b
            seg2b = tmp
        if (seg1a < seg2b):
            return (seg2a < seg1b)
        else:
            return False

    def SetHoleState(self,e,outRec):
        isHole = False
        e2 = e.prevInAEL
        while (e2 is not None):
            if ((e2.outIdx >= 0) and ((e2.windDelta != 0))):
                isHole = (not isHole)
                if (outRec.firstLeft is None):
                    outRec.firstLeft = python_internal_ArrayImpl._get(self.m_PolyOuts, e2.outIdx)
            e2 = e2.prevInAEL
        if isHole:
            outRec.isHole = True

    def GetDx(self,pt1,pt2):
        if (pt1.y == pt2.y):
            return -9007199254740992.
        else:
            return (((pt2.x - pt1.x)) / ((pt2.y - pt1.y)))

    def FirstIsBottomPt(self,btmPt1,btmPt2):
        p = btmPt1.prev
        while True:
            pt1 = p.pt
            pt2 = btmPt1.pt
            if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((p != btmPt1))))):
                break
            p = p.prev
        f = self.GetDx(btmPt1.pt,p.pt)
        dx1p = (-f if ((f < 0)) else f)
        p = btmPt1.next
        while True:
            pt1 = p.pt
            pt2 = btmPt1.pt
            if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((p != btmPt1))))):
                break
            p = p.next
        f = self.GetDx(btmPt1.pt,p.pt)
        dx1n = (-f if ((f < 0)) else f)
        p = btmPt2.prev
        while True:
            pt1 = p.pt
            pt2 = btmPt2.pt
            if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((p != btmPt2))))):
                break
            p = p.prev
        f = self.GetDx(btmPt2.pt,p.pt)
        dx2p = (-f if ((f < 0)) else f)
        p = btmPt2.next
        while True:
            pt1 = p.pt
            pt2 = btmPt2.pt
            if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((p != btmPt2))))):
                break
            p = p.next
        f = self.GetDx(btmPt2.pt,p.pt)
        dx2n = (-f if ((f < 0)) else f)
        if (not (((dx1p >= dx2p) and ((dx1p >= dx2n))))):
            if (dx1n >= dx2p):
                return (dx1n >= dx2n)
            else:
                return False
        else:
            return True

    def GetBottomPt(self,pp):
        dups = None
        p = pp.next
        while (p != pp):
            if (p.pt.y > pp.pt.y):
                pp = p
                dups = None
            elif ((p.pt.y == pp.pt.y) and ((p.pt.x <= pp.pt.x))):
                if (p.pt.x < pp.pt.x):
                    dups = None
                    pp = p
                elif ((p.next != pp) and ((p.prev != pp))):
                    dups = p
            p = p.next
        if (dups is not None):
            n = 0
            while (dups != p):
                if (not self.FirstIsBottomPt(p,dups)):
                    pp = dups
                dups = dups.next
                while True:
                    pt1 = dups.pt
                    pt2 = pp.pt
                    if ((pt1.x == pt2.x) and ((pt1.y == pt2.y))):
                        break
                    dups = dups.next
        return pp

    def GetLowermostRec(self,outRec1,outRec2):
        if (outRec1.bottomPt is None):
            outRec1.bottomPt = self.GetBottomPt(outRec1.pts)
        if (outRec2.bottomPt is None):
            outRec2.bottomPt = self.GetBottomPt(outRec2.pts)
        bPt1 = outRec1.bottomPt
        bPt2 = outRec2.bottomPt
        if (bPt1.pt.y > bPt2.pt.y):
            return outRec1
        elif (bPt1.pt.y < bPt2.pt.y):
            return outRec2
        elif (bPt1.pt.x < bPt2.pt.x):
            return outRec1
        elif (bPt1.pt.x > bPt2.pt.x):
            return outRec2
        elif (bPt1.next == bPt1):
            return outRec2
        elif (bPt2.next == bPt2):
            return outRec1
        elif self.FirstIsBottomPt(bPt1,bPt2):
            return outRec1
        else:
            return outRec2

    def Param1RightOfParam2(self,outRec1,outRec2):
        while True:
            outRec1 = outRec1.firstLeft
            if (outRec1 == outRec2):
                return True
            if (not ((outRec1 is not None))):
                break
        return False

    def GetOutRec(self,idx):
        outrec = (self.m_PolyOuts[idx] if idx >= 0 and idx < len(self.m_PolyOuts) else None)
        while (outrec != python_internal_ArrayImpl._get(self.m_PolyOuts, outrec.idx)):
            outrec = python_internal_ArrayImpl._get(self.m_PolyOuts, outrec.idx)
        return outrec

    def AppendPolygon(self,e1,e2):
        outRec1 = python_internal_ArrayImpl._get(self.m_PolyOuts, e1.outIdx)
        outRec2 = python_internal_ArrayImpl._get(self.m_PolyOuts, e2.outIdx)
        holeStateRec = None
        if self.Param1RightOfParam2(outRec1,outRec2):
            holeStateRec = outRec2
        elif self.Param1RightOfParam2(outRec2,outRec1):
            holeStateRec = outRec1
        else:
            holeStateRec = self.GetLowermostRec(outRec1,outRec2)
        p1_lft = outRec1.pts
        p1_rt = p1_lft.prev
        p2_lft = outRec2.pts
        p2_rt = p2_lft.prev
        side = None
        if (e1.side == hxd_clipper__Clipper_EdgeSide.Left):
            if (e2.side == hxd_clipper__Clipper_EdgeSide.Left):
                self.ReversePolyPtLinks(p2_lft)
                p2_lft.next = p1_lft
                p1_lft.prev = p2_lft
                p1_rt.next = p2_rt
                p2_rt.prev = p1_rt
                outRec1.pts = p2_rt
            else:
                p2_rt.next = p1_lft
                p1_lft.prev = p2_rt
                p2_lft.prev = p1_rt
                p1_rt.next = p2_lft
                outRec1.pts = p2_lft
            side = hxd_clipper__Clipper_EdgeSide.Left
        else:
            if (e2.side == hxd_clipper__Clipper_EdgeSide.Right):
                self.ReversePolyPtLinks(p2_lft)
                p1_rt.next = p2_rt
                p2_rt.prev = p1_rt
                p2_lft.next = p1_lft
                p1_lft.prev = p2_lft
            else:
                p1_rt.next = p2_lft
                p2_lft.prev = p1_rt
                p1_lft.prev = p2_rt
                p2_rt.next = p1_lft
            side = hxd_clipper__Clipper_EdgeSide.Right
        outRec1.bottomPt = None
        if (holeStateRec == outRec2):
            if (outRec2.firstLeft != outRec1):
                outRec1.firstLeft = outRec2.firstLeft
            outRec1.isHole = outRec2.isHole
        outRec2.pts = None
        outRec2.bottomPt = None
        outRec2.firstLeft = outRec1
        OKIdx = e1.outIdx
        ObsoleteIdx = e2.outIdx
        e1.outIdx = -1
        e2.outIdx = -1
        e = self.m_ActiveEdges
        while (e is not None):
            if (e.outIdx == ObsoleteIdx):
                e.outIdx = OKIdx
                e.side = side
                break
            e = e.nextInAEL
        outRec2.idx = outRec1.idx

    def ReversePolyPtLinks(self,pp):
        if (pp is None):
            return
        pp2 = None
        pp1 = pp
        while True:
            pp2 = pp1.next
            pp1.next = pp1.prev
            pp1.prev = pp2
            pp1 = pp2
            if (not ((pp1 != pp))):
                break

    def SwapSides(self,edge1,edge2):
        side = edge1.side
        edge1.side = edge2.side
        edge2.side = side

    def SwapPolyIndexes(self,edge1,edge2):
        outIdx = edge1.outIdx
        edge1.outIdx = edge2.outIdx
        edge2.outIdx = outIdx

    def IntersectEdges(self,e1,e2,pt):
        e1Contributing = (e1.outIdx >= 0)
        e2Contributing = (e2.outIdx >= 0)
        if (e1.polyType == e2.polyType):
            if ((self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd) if ((e1.polyType == hxd_clipper_PolyType.Subject)) else (self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)):
                oldE1WindCnt = e1.windCnt
                e1.windCnt = e2.windCnt
                e2.windCnt = oldE1WindCnt
            else:
                if ((e1.windCnt + e2.windDelta) == 0):
                    e1.windCnt = -e1.windCnt
                else:
                    e1.windCnt = (e1.windCnt + e2.windDelta)
                if ((e2.windCnt - e1.windDelta) == 0):
                    e2.windCnt = -e2.windCnt
                else:
                    e2.windCnt = (e2.windCnt - e1.windDelta)
        else:
            if (not (((self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd) if ((e2.polyType == hxd_clipper_PolyType.Subject)) else (self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)))):
                e1.windCnt2 = (e1.windCnt2 + e2.windDelta)
            else:
                e1.windCnt2 = (1 if ((e1.windCnt2 == 0)) else 0)
            if (not (((self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd) if ((e1.polyType == hxd_clipper_PolyType.Subject)) else (self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)))):
                e2.windCnt2 = (e2.windCnt2 - e1.windDelta)
            else:
                e2.windCnt2 = (1 if ((e2.windCnt2 == 0)) else 0)
        e1FillType = None
        e2FillType = None
        e1FillType2 = None
        e2FillType2 = None
        if (e1.polyType == hxd_clipper_PolyType.Subject):
            e1FillType = self.m_SubjFillType
            e1FillType2 = self.m_ClipFillType
        else:
            e1FillType = self.m_ClipFillType
            e1FillType2 = self.m_SubjFillType
        if (e2.polyType == hxd_clipper_PolyType.Subject):
            e2FillType = self.m_SubjFillType
            e2FillType2 = self.m_ClipFillType
        else:
            e2FillType = self.m_ClipFillType
            e2FillType2 = self.m_SubjFillType
        e1Wc = None
        e2Wc = None
        tmp = e1FillType.index
        if (tmp == 2):
            e1Wc = e1.windCnt
        elif (tmp == 3):
            e1Wc = -e1.windCnt
        else:
            i = e1.windCnt
            e1Wc = (-i if ((i < 0)) else i)
        tmp = e2FillType.index
        if (tmp == 2):
            e2Wc = e2.windCnt
        elif (tmp == 3):
            e2Wc = -e2.windCnt
        else:
            i = e2.windCnt
            e2Wc = (-i if ((i < 0)) else i)
        if (e1Contributing and e2Contributing):
            if ((((e1Wc != 0) and ((e1Wc != 1))) or (((e2Wc != 0) and ((e2Wc != 1))))) or (((e1.polyType != e2.polyType) and ((self.m_ClipType != hxd_clipper_ClipType.Xor))))):
                self.AddLocalMaxPoly(e1,e2,pt)
            else:
                self.AddOutPt(e1,pt)
                self.AddOutPt(e2,pt)
                side = e1.side
                e1.side = e2.side
                e2.side = side
                self.SwapPolyIndexes(e1,e2)
        elif e1Contributing:
            if ((e2Wc == 0) or ((e2Wc == 1))):
                self.AddOutPt(e1,pt)
                side = e1.side
                e1.side = e2.side
                e2.side = side
                self.SwapPolyIndexes(e1,e2)
        elif e2Contributing:
            if ((e1Wc == 0) or ((e1Wc == 1))):
                self.AddOutPt(e2,pt)
                side = e1.side
                e1.side = e2.side
                e2.side = side
                self.SwapPolyIndexes(e1,e2)
        elif ((((e1Wc == 0) or ((e1Wc == 1)))) and (((e2Wc == 0) or ((e2Wc == 1))))):
            e1Wc2 = None
            e2Wc2 = None
            tmp = e1FillType2.index
            if (tmp == 2):
                e1Wc2 = e1.windCnt2
            elif (tmp == 3):
                e1Wc2 = -e1.windCnt2
            else:
                i = e1.windCnt2
                e1Wc2 = (-i if ((i < 0)) else i)
            tmp = e2FillType2.index
            if (tmp == 2):
                e2Wc2 = e2.windCnt2
            elif (tmp == 3):
                e2Wc2 = -e2.windCnt2
            else:
                i = e2.windCnt2
                e2Wc2 = (-i if ((i < 0)) else i)
            if (e1.polyType != e2.polyType):
                self.AddLocalMinPoly(e1,e2,pt)
            elif ((e1Wc == 1) and ((e2Wc == 1))):
                tmp = self.m_ClipType.index
                if (tmp == 0):
                    if ((e1Wc2 > 0) and ((e2Wc2 > 0))):
                        self.AddLocalMinPoly(e1,e2,pt)
                elif (tmp == 1):
                    if ((e1Wc2 <= 0) and ((e2Wc2 <= 0))):
                        self.AddLocalMinPoly(e1,e2,pt)
                elif (tmp == 2):
                    if ((((e1.polyType == hxd_clipper_PolyType.Clip) and ((e1Wc2 > 0))) and ((e2Wc2 > 0))) or ((((e1.polyType == hxd_clipper_PolyType.Subject) and ((e1Wc2 <= 0))) and ((e2Wc2 <= 0))))):
                        self.AddLocalMinPoly(e1,e2,pt)
                elif (tmp == 3):
                    self.AddLocalMinPoly(e1,e2,pt)
                else:
                    pass
            else:
                side = e1.side
                e1.side = e2.side
                e2.side = side

    def DeleteFromAEL(self,e):
        AelPrev = e.prevInAEL
        AelNext = e.nextInAEL
        if (((AelPrev is None) and ((AelNext is None))) and ((e != self.m_ActiveEdges))):
            return
        if (AelPrev is not None):
            AelPrev.nextInAEL = AelNext
        else:
            self.m_ActiveEdges = AelNext
        if (AelNext is not None):
            AelNext.prevInAEL = AelPrev
        e.nextInAEL = None
        e.prevInAEL = None

    def DeleteFromSEL(self,e):
        SelPrev = e.prevInSEL
        SelNext = e.nextInSEL
        if (((SelPrev is None) and ((SelNext is None))) and ((e != self.m_SortedEdges))):
            return
        if (SelPrev is not None):
            SelPrev.nextInSEL = SelNext
        else:
            self.m_SortedEdges = SelNext
        if (SelNext is not None):
            SelNext.prevInSEL = SelPrev
        e.nextInSEL = None
        e.prevInSEL = None

    def UpdateEdgeIntoAEL(self,e):
        if (e.nextInLML is None):
            raise haxe_Exception.thrown("UpdateEdgeIntoAEL: invalid call")
        AelPrev = e.prevInAEL
        AelNext = e.nextInAEL
        e.nextInLML.outIdx = e.outIdx
        if (AelPrev is not None):
            AelPrev.nextInAEL = e.nextInLML
        else:
            self.m_ActiveEdges = e.nextInLML
        if (AelNext is not None):
            AelNext.prevInAEL = e.nextInLML
        e.nextInLML.side = e.side
        e.nextInLML.windDelta = e.windDelta
        e.nextInLML.windCnt = e.windCnt
        e.nextInLML.windCnt2 = e.windCnt2
        e = e.nextInLML
        e.currX = e.botX
        e.currY = e.botY
        e.prevInAEL = AelPrev
        e.nextInAEL = AelNext
        if (e.deltaY != 0):
            self.InsertScanbeam(e.topY)
        return e

    def GetHorzDirection(self,HorzEdge):
        if (HorzEdge.botX < HorzEdge.topX):
            return _hx_AnonObject({'left': HorzEdge.botX, 'right': HorzEdge.topX, 'dir': hxd_clipper__Clipper_Direction.LeftToRight})
        else:
            return _hx_AnonObject({'left': HorzEdge.topX, 'right': HorzEdge.botX, 'dir': hxd_clipper__Clipper_Direction.RightToLeft})

    def ProcessHorizontals(self,isTopOfScanbeam):
        horzEdge = self.m_SortedEdges
        while (horzEdge is not None):
            self.DeleteFromSEL(horzEdge)
            self.ProcessHorizontal(horzEdge,isTopOfScanbeam)
            horzEdge = self.m_SortedEdges

    def ProcessHorizontal(self,horzEdge,isTopOfScanbeam):
        res = self.GetHorzDirection(horzEdge)
        dir = res.dir
        horzLeft = res.left
        horzRight = res.right
        eLastHorz = horzEdge
        eMaxPair = None
        while ((eLastHorz.nextInLML is not None) and ((eLastHorz.nextInLML.deltaY == 0))):
            eLastHorz = eLastHorz.nextInLML
        if (eLastHorz.nextInLML is None):
            eMaxPair = self.GetMaximaPair(eLastHorz)
        while True:
            IsLastHorz = (horzEdge == eLastHorz)
            e = (horzEdge.nextInAEL if ((dir == hxd_clipper__Clipper_Direction.LeftToRight)) else horzEdge.prevInAEL)
            while (e is not None):
                if (((e.currX == horzEdge.topX) and ((horzEdge.nextInLML is not None))) and ((e.dx < horzEdge.nextInLML.dx))):
                    break
                eNext = (e.nextInAEL if ((dir == hxd_clipper__Clipper_Direction.LeftToRight)) else e.prevInAEL)
                if (((dir == hxd_clipper__Clipper_Direction.LeftToRight) and ((e.currX <= horzRight))) or (((dir == hxd_clipper__Clipper_Direction.RightToLeft) and ((e.currX >= horzLeft))))):
                    if ((e == eMaxPair) and IsLastHorz):
                        if (horzEdge.outIdx >= 0):
                            op1 = self.AddOutPt(horzEdge,h2d_col_IPoint(horzEdge.topX,horzEdge.topY))
                            eNextHorz = self.m_SortedEdges
                            while (eNextHorz is not None):
                                if ((eNextHorz.outIdx >= 0) and self.HorzSegmentsOverlap(horzEdge.botX,horzEdge.topX,eNextHorz.botX,eNextHorz.topX)):
                                    op2 = self.AddOutPt(eNextHorz,h2d_col_IPoint(eNextHorz.botX,eNextHorz.botY))
                                    self.AddJoin(op2,op1,h2d_col_IPoint(eNextHorz.topX,eNextHorz.topY))
                                eNextHorz = eNextHorz.nextInSEL
                            self.AddGhostJoin(op1,h2d_col_IPoint(horzEdge.botX,horzEdge.botY))
                            self.AddLocalMaxPoly(horzEdge,eMaxPair,h2d_col_IPoint(horzEdge.topX,horzEdge.topY))
                        self.DeleteFromAEL(horzEdge)
                        self.DeleteFromAEL(eMaxPair)
                        return
                    elif (dir == hxd_clipper__Clipper_Direction.LeftToRight):
                        Pt = h2d_col_IPoint(e.currX,horzEdge.currY)
                        self.IntersectEdges(horzEdge,e,Pt)
                    else:
                        Pt1 = h2d_col_IPoint(e.currX,horzEdge.currY)
                        self.IntersectEdges(e,horzEdge,Pt1)
                    self.SwapPositionsInAEL(horzEdge,e)
                elif (((dir == hxd_clipper__Clipper_Direction.LeftToRight) and ((e.currX >= horzRight))) or (((dir == hxd_clipper__Clipper_Direction.RightToLeft) and ((e.currX <= horzLeft))))):
                    break
                e = eNext
            if ((horzEdge.nextInLML is not None) and ((horzEdge.nextInLML.deltaY == 0))):
                horzEdge = self.UpdateEdgeIntoAEL(horzEdge)
                if (horzEdge.outIdx >= 0):
                    self.AddOutPt(horzEdge,h2d_col_IPoint(horzEdge.botX,horzEdge.botY))
                out = self.GetHorzDirection(horzEdge)
                dir = out.dir
                horzLeft = out.left
                horzRight = out.right
            else:
                break
        if (horzEdge.nextInLML is not None):
            if (horzEdge.outIdx >= 0):
                op1 = self.AddOutPt(horzEdge,h2d_col_IPoint(horzEdge.topX,horzEdge.topY))
                if isTopOfScanbeam:
                    self.AddGhostJoin(op1,h2d_col_IPoint(horzEdge.botX,horzEdge.botY))
                horzEdge = self.UpdateEdgeIntoAEL(horzEdge)
                if (horzEdge.windDelta == 0):
                    return
                ePrev = horzEdge.prevInAEL
                eNext = horzEdge.nextInAEL
                if (((((ePrev is not None) and ((ePrev.currX == horzEdge.botX))) and ((ePrev.currY == horzEdge.botY))) and ((ePrev.windDelta != 0))) and ((((ePrev.outIdx >= 0) and ((ePrev.currY > ePrev.topY))) and (((horzEdge.deltaY * ePrev.deltaX) == ((horzEdge.deltaX * ePrev.deltaY))))))):
                    op2 = self.AddOutPt(ePrev,h2d_col_IPoint(horzEdge.botX,horzEdge.botY))
                    self.AddJoin(op1,op2,h2d_col_IPoint(horzEdge.topX,horzEdge.topY))
                elif (((((((eNext is not None) and ((eNext.currX == horzEdge.botX))) and ((eNext.currY == horzEdge.botY))) and ((eNext.windDelta != 0))) and ((eNext.outIdx >= 0))) and ((eNext.currY > eNext.topY))) and (((horzEdge.deltaY * eNext.deltaX) == ((horzEdge.deltaX * eNext.deltaY))))):
                    op2 = self.AddOutPt(eNext,h2d_col_IPoint(horzEdge.botX,horzEdge.botY))
                    self.AddJoin(op1,op2,h2d_col_IPoint(horzEdge.topX,horzEdge.topY))
            else:
                horzEdge = self.UpdateEdgeIntoAEL(horzEdge)
        else:
            if (horzEdge.outIdx >= 0):
                self.AddOutPt(horzEdge,h2d_col_IPoint(horzEdge.topX,horzEdge.topY))
            self.DeleteFromAEL(horzEdge)

    def GetNextInAEL(self,e,dir):
        if (dir == hxd_clipper__Clipper_Direction.LeftToRight):
            return e.nextInAEL
        else:
            return e.prevInAEL

    def IsMinima(self,e):
        if ((e is not None) and ((e.prev.nextInLML != e))):
            return (e.next.nextInLML != e)
        else:
            return False

    def IsMaxima(self,e,y):
        if ((e is not None) and ((e.topY == y))):
            return (e.nextInLML is None)
        else:
            return False

    def IsIntermediate(self,e,y):
        if (e.topY == y):
            return (e.nextInLML is not None)
        else:
            return False

    def GetMaximaPair(self,e):
        result = None
        if (((e.next.topX == e.topX) and ((e.next.topY == e.topY))) and ((e.next.nextInLML is None))):
            result = e.next
        elif (((e.prev.topX == e.topX) and ((e.prev.topY == e.topY))) and ((e.prev.nextInLML is None))):
            result = e.prev
        if ((result is not None) and (((result.outIdx == -2) or (((result.nextInAEL == result.prevInAEL) and ((result.deltaY != 0))))))):
            return None
        return result

    def ProcessIntersections(self,topY):
        if (self.m_ActiveEdges is None):
            return True
        self.BuildIntersectList(topY)
        if (len(self.m_IntersectList) == 0):
            return True
        if ((len(self.m_IntersectList) == 1) or self.FixupIntersectionOrder()):
            self.ProcessIntersectList()
        else:
            return False
        self.m_SortedEdges = None
        return True

    def BuildIntersectList(self,topY):
        if (self.m_ActiveEdges is None):
            return
        e = self.m_ActiveEdges
        self.m_SortedEdges = e
        while (e is not None):
            e.prevInSEL = e.prevInAEL
            e.nextInSEL = e.nextInAEL
            tmp = None
            if (topY == e.topY):
                tmp = e.topX
            else:
                e1 = e.botX
                value = (e.dx * ((topY - e.botY)))
                tmp1 = None
                if (value < 0):
                    tmp2 = None
                    try:
                        tmp2 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        tmp2 = None
                    tmp1 = tmp2
                else:
                    tmp3 = None
                    try:
                        tmp3 = int((value + 0.5))
                    except BaseException as _g1:
                        None
                        tmp3 = None
                    tmp1 = tmp3
                tmp = (e1 + tmp1)
            e.currX = tmp
            e = e.nextInAEL
        isModified = True
        while (isModified and ((self.m_SortedEdges is not None))):
            isModified = False
            e = self.m_SortedEdges
            while (e.nextInSEL is not None):
                eNext = e.nextInSEL
                pt = None
                if (e.currX > eNext.currX):
                    ipx = None
                    ipy = None
                    b1 = None
                    b2 = None
                    if (e.dx == eNext.dx):
                        ipy = e.currY
                        if (ipy == e.topY):
                            ipx = e.topX
                        else:
                            e1 = e.botX
                            value = (e.dx * ((ipy - e.botY)))
                            ipx1 = None
                            if (value < 0):
                                ipx2 = None
                                try:
                                    ipx2 = int((value - 0.5))
                                except BaseException as _g:
                                    None
                                    ipx2 = None
                                ipx1 = ipx2
                            else:
                                ipx3 = None
                                try:
                                    ipx3 = int((value + 0.5))
                                except BaseException as _g1:
                                    None
                                    ipx3 = None
                                ipx1 = ipx3
                            ipx = (e1 + ipx1)
                        pt = h2d_col_IPoint(ipx,ipy)
                    else:
                        if (e.deltaX == 0):
                            ipx = e.botX
                            if (eNext.deltaY == 0):
                                ipy = eNext.botY
                            else:
                                b2 = (eNext.botY - ((eNext.botX / eNext.dx)))
                                value1 = ((ipx / eNext.dx) + b2)
                                if (value1 < 0):
                                    ipy1 = None
                                    try:
                                        ipy1 = int((value1 - 0.5))
                                    except BaseException as _g2:
                                        None
                                        ipy1 = None
                                    ipy = ipy1
                                else:
                                    ipy2 = None
                                    try:
                                        ipy2 = int((value1 + 0.5))
                                    except BaseException as _g3:
                                        None
                                        ipy2 = None
                                    ipy = ipy2
                        elif (eNext.deltaX == 0):
                            ipx = eNext.botX
                            if (e.deltaY == 0):
                                ipy = e.botY
                            else:
                                b1 = (e.botY - ((e.botX / e.dx)))
                                value2 = ((ipx / e.dx) + b1)
                                if (value2 < 0):
                                    ipy3 = None
                                    try:
                                        ipy3 = int((value2 - 0.5))
                                    except BaseException as _g4:
                                        None
                                        ipy3 = None
                                    ipy = ipy3
                                else:
                                    ipy4 = None
                                    try:
                                        ipy4 = int((value2 + 0.5))
                                    except BaseException as _g5:
                                        None
                                        ipy4 = None
                                    ipy = ipy4
                        else:
                            b1 = (e.botX - ((e.botY * e.dx)))
                            b2 = (eNext.botX - ((eNext.botY * eNext.dx)))
                            q = (((b2 - b1)) / ((e.dx - eNext.dx)))
                            if (q < 0):
                                ipy5 = None
                                try:
                                    ipy5 = int((q - 0.5))
                                except BaseException as _g6:
                                    None
                                    ipy5 = None
                                ipy = ipy5
                            else:
                                ipy6 = None
                                try:
                                    ipy6 = int((q + 0.5))
                                except BaseException as _g7:
                                    None
                                    ipy6 = None
                                ipy = ipy6
                            f = e.dx
                            f1 = eNext.dx
                            if (((-f if ((f < 0)) else f)) < ((-f1 if ((f1 < 0)) else f1))):
                                value3 = ((e.dx * q) + b1)
                                if (value3 < 0):
                                    ipx4 = None
                                    try:
                                        ipx4 = int((value3 - 0.5))
                                    except BaseException as _g8:
                                        None
                                        ipx4 = None
                                    ipx = ipx4
                                else:
                                    ipx5 = None
                                    try:
                                        ipx5 = int((value3 + 0.5))
                                    except BaseException as _g9:
                                        None
                                        ipx5 = None
                                    ipx = ipx5
                            else:
                                value4 = ((eNext.dx * q) + b2)
                                if (value4 < 0):
                                    ipx6 = None
                                    try:
                                        ipx6 = int((value4 - 0.5))
                                    except BaseException as _g10:
                                        None
                                        ipx6 = None
                                    ipx = ipx6
                                else:
                                    ipx7 = None
                                    try:
                                        ipx7 = int((value4 + 0.5))
                                    except BaseException as _g11:
                                        None
                                        ipx7 = None
                                    ipx = ipx7
                        if ((ipy < e.topY) or ((ipy < eNext.topY))):
                            if (e.topY > eNext.topY):
                                ipy = e.topY
                            else:
                                ipy = eNext.topY
                            f2 = e.dx
                            f3 = eNext.dx
                            if (((-f2 if ((f2 < 0)) else f2)) < ((-f3 if ((f3 < 0)) else f3))):
                                if (ipy == e.topY):
                                    ipx = e.topX
                                else:
                                    e2 = e.botX
                                    value5 = (e.dx * ((ipy - e.botY)))
                                    ipx8 = None
                                    if (value5 < 0):
                                        ipx9 = None
                                        try:
                                            ipx9 = int((value5 - 0.5))
                                        except BaseException as _g12:
                                            None
                                            ipx9 = None
                                        ipx8 = ipx9
                                    else:
                                        ipx10 = None
                                        try:
                                            ipx10 = int((value5 + 0.5))
                                        except BaseException as _g13:
                                            None
                                            ipx10 = None
                                        ipx8 = ipx10
                                    ipx = (e2 + ipx8)
                            elif (ipy == eNext.topY):
                                ipx = eNext.topX
                            else:
                                eNext1 = eNext.botX
                                value6 = (eNext.dx * ((ipy - eNext.botY)))
                                ipx11 = None
                                if (value6 < 0):
                                    ipx12 = None
                                    try:
                                        ipx12 = int((value6 - 0.5))
                                    except BaseException as _g14:
                                        None
                                        ipx12 = None
                                    ipx11 = ipx12
                                else:
                                    ipx13 = None
                                    try:
                                        ipx13 = int((value6 + 0.5))
                                    except BaseException as _g15:
                                        None
                                        ipx13 = None
                                    ipx11 = ipx13
                                ipx = (eNext1 + ipx11)
                        if (ipy > e.currY):
                            ipy = e.currY
                            f4 = e.dx
                            f5 = eNext.dx
                            if (((-f4 if ((f4 < 0)) else f4)) > ((-f5 if ((f5 < 0)) else f5))):
                                if (ipy == eNext.topY):
                                    ipx = eNext.topX
                                else:
                                    eNext2 = eNext.botX
                                    value7 = (eNext.dx * ((ipy - eNext.botY)))
                                    ipx14 = None
                                    if (value7 < 0):
                                        ipx15 = None
                                        try:
                                            ipx15 = int((value7 - 0.5))
                                        except BaseException as _g16:
                                            None
                                            ipx15 = None
                                        ipx14 = ipx15
                                    else:
                                        ipx16 = None
                                        try:
                                            ipx16 = int((value7 + 0.5))
                                        except BaseException as _g17:
                                            None
                                            ipx16 = None
                                        ipx14 = ipx16
                                    ipx = (eNext2 + ipx14)
                            elif (ipy == e.topY):
                                ipx = e.topX
                            else:
                                e3 = e.botX
                                value8 = (e.dx * ((ipy - e.botY)))
                                ipx17 = None
                                if (value8 < 0):
                                    ipx18 = None
                                    try:
                                        ipx18 = int((value8 - 0.5))
                                    except BaseException as _g18:
                                        None
                                        ipx18 = None
                                    ipx17 = ipx18
                                else:
                                    ipx19 = None
                                    try:
                                        ipx19 = int((value8 + 0.5))
                                    except BaseException as _g19:
                                        None
                                        ipx19 = None
                                    ipx17 = ipx19
                                ipx = (e3 + ipx17)
                        pt = h2d_col_IPoint(ipx,ipy)
                    newNode = hxd_clipper__Clipper_IntersectNode()
                    newNode.edge1 = e
                    newNode.edge2 = eNext
                    newNode.pt = pt
                    _this = self.m_IntersectList
                    _this.append(newNode)
                    self.SwapPositionsInSEL(e,eNext)
                    isModified = True
                else:
                    e = eNext
            if (e.prevInSEL is not None):
                e.prevInSEL.nextInSEL = None
            else:
                break
        self.m_SortedEdges = None

    def EdgesAdjacent(self,inode):
        if (inode.edge1.nextInSEL != inode.edge2):
            return (inode.edge1.prevInSEL == inode.edge2)
        else:
            return True

    def IntersectNodeSort(self,node1,node2):
        x = (node2.pt.y - node1.pt.y)
        try:
            return int(x)
        except BaseException as _g:
            None
            return None

    def FixupIntersectionOrder(self):
        self.m_IntersectList.sort(key= python_lib_Functools.cmp_to_key(hxd_clipper_Clipper.compareY))
        e = self.m_ActiveEdges
        self.m_SortedEdges = e
        while (e is not None):
            e.prevInSEL = e.prevInAEL
            e.nextInSEL = e.nextInAEL
            e = e.nextInAEL
        cnt = len(self.m_IntersectList)
        _g = 0
        _g1 = cnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            inode = (self.m_IntersectList[i] if i >= 0 and i < len(self.m_IntersectList) else None)
            if (not (((inode.edge1.nextInSEL == inode.edge2) or ((inode.edge1.prevInSEL == inode.edge2))))):
                j = (i + 1)
                while True:
                    tmp = None
                    if (j < cnt):
                        inode1 = (self.m_IntersectList[j] if j >= 0 and j < len(self.m_IntersectList) else None)
                        tmp = (not (((inode1.edge1.nextInSEL == inode1.edge2) or ((inode1.edge1.prevInSEL == inode1.edge2)))))
                    else:
                        tmp = False
                    if (not tmp):
                        break
                    j = (j + 1)
                if (j == cnt):
                    return False
                tmp1 = (self.m_IntersectList[i] if i >= 0 and i < len(self.m_IntersectList) else None)
                python_internal_ArrayImpl._set(self.m_IntersectList, i, (self.m_IntersectList[j] if j >= 0 and j < len(self.m_IntersectList) else None))
                python_internal_ArrayImpl._set(self.m_IntersectList, j, tmp1)
            self.SwapPositionsInSEL((self.m_IntersectList[i] if i >= 0 and i < len(self.m_IntersectList) else None).edge1,(self.m_IntersectList[i] if i >= 0 and i < len(self.m_IntersectList) else None).edge2)
        return True

    def ProcessIntersectList(self):
        _g = 0
        _g1 = len(self.m_IntersectList)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            iNode = (self.m_IntersectList[i] if i >= 0 and i < len(self.m_IntersectList) else None)
            self.IntersectEdges(iNode.edge1,iNode.edge2,iNode.pt)
            self.SwapPositionsInAEL(iNode.edge1,iNode.edge2)
        self.m_IntersectList = []

    def Round(self,value):
        if (value < 0):
            tmp = None
            try:
                tmp = int((value - 0.5))
            except BaseException as _g:
                None
                tmp = None
            return tmp
        else:
            tmp = None
            try:
                tmp = int((value + 0.5))
            except BaseException as _g:
                None
                tmp = None
            return tmp

    def TopX(self,edge,currentY):
        if (currentY == edge.topY):
            return edge.topX
        edge1 = edge.botX
        value = (edge.dx * ((currentY - edge.botY)))
        tmp = None
        if (value < 0):
            tmp1 = None
            try:
                tmp1 = int((value - 0.5))
            except BaseException as _g:
                None
                tmp1 = None
            tmp = tmp1
        else:
            tmp1 = None
            try:
                tmp1 = int((value + 0.5))
            except BaseException as _g:
                None
                tmp1 = None
            tmp = tmp1
        return (edge1 + tmp)

    def IntersectPoint(self,edge1,edge2):
        ipx = None
        ipy = None
        b1 = None
        b2 = None
        if (edge1.dx == edge2.dx):
            ipy = edge1.currY
            if (ipy == edge1.topY):
                ipx = edge1.topX
            else:
                edge11 = edge1.botX
                value = (edge1.dx * ((ipy - edge1.botY)))
                ipx1 = None
                if (value < 0):
                    ipx2 = None
                    try:
                        ipx2 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipx2 = None
                    ipx1 = ipx2
                else:
                    ipx2 = None
                    try:
                        ipx2 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipx2 = None
                    ipx1 = ipx2
                ipx = (edge11 + ipx1)
            return h2d_col_IPoint(ipx,ipy)
        if (edge1.deltaX == 0):
            ipx = edge1.botX
            if (edge2.deltaY == 0):
                ipy = edge2.botY
            else:
                b2 = (edge2.botY - ((edge2.botX / edge2.dx)))
                value = ((ipx / edge2.dx) + b2)
                if (value < 0):
                    ipy1 = None
                    try:
                        ipy1 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipy1 = None
                    ipy = ipy1
                else:
                    ipy1 = None
                    try:
                        ipy1 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipy1 = None
                    ipy = ipy1
        elif (edge2.deltaX == 0):
            ipx = edge2.botX
            if (edge1.deltaY == 0):
                ipy = edge1.botY
            else:
                b1 = (edge1.botY - ((edge1.botX / edge1.dx)))
                value = ((ipx / edge1.dx) + b1)
                if (value < 0):
                    ipy1 = None
                    try:
                        ipy1 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipy1 = None
                    ipy = ipy1
                else:
                    ipy1 = None
                    try:
                        ipy1 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipy1 = None
                    ipy = ipy1
        else:
            b1 = (edge1.botX - ((edge1.botY * edge1.dx)))
            b2 = (edge2.botX - ((edge2.botY * edge2.dx)))
            q = (((b2 - b1)) / ((edge1.dx - edge2.dx)))
            if (q < 0):
                ipy1 = None
                try:
                    ipy1 = int((q - 0.5))
                except BaseException as _g:
                    None
                    ipy1 = None
                ipy = ipy1
            else:
                ipy1 = None
                try:
                    ipy1 = int((q + 0.5))
                except BaseException as _g:
                    None
                    ipy1 = None
                ipy = ipy1
            f = edge1.dx
            f1 = edge2.dx
            if (((-f if ((f < 0)) else f)) < ((-f1 if ((f1 < 0)) else f1))):
                value = ((edge1.dx * q) + b1)
                if (value < 0):
                    ipx1 = None
                    try:
                        ipx1 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipx1 = None
                    ipx = ipx1
                else:
                    ipx1 = None
                    try:
                        ipx1 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipx1 = None
                    ipx = ipx1
            else:
                value = ((edge2.dx * q) + b2)
                if (value < 0):
                    ipx1 = None
                    try:
                        ipx1 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipx1 = None
                    ipx = ipx1
                else:
                    ipx1 = None
                    try:
                        ipx1 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipx1 = None
                    ipx = ipx1
        if ((ipy < edge1.topY) or ((ipy < edge2.topY))):
            if (edge1.topY > edge2.topY):
                ipy = edge1.topY
            else:
                ipy = edge2.topY
            f = edge1.dx
            f1 = edge2.dx
            if (((-f if ((f < 0)) else f)) < ((-f1 if ((f1 < 0)) else f1))):
                if (ipy == edge1.topY):
                    ipx = edge1.topX
                else:
                    edge11 = edge1.botX
                    value = (edge1.dx * ((ipy - edge1.botY)))
                    ipx1 = None
                    if (value < 0):
                        ipx2 = None
                        try:
                            ipx2 = int((value - 0.5))
                        except BaseException as _g:
                            None
                            ipx2 = None
                        ipx1 = ipx2
                    else:
                        ipx2 = None
                        try:
                            ipx2 = int((value + 0.5))
                        except BaseException as _g:
                            None
                            ipx2 = None
                        ipx1 = ipx2
                    ipx = (edge11 + ipx1)
            elif (ipy == edge2.topY):
                ipx = edge2.topX
            else:
                edge21 = edge2.botX
                value = (edge2.dx * ((ipy - edge2.botY)))
                ipx1 = None
                if (value < 0):
                    ipx2 = None
                    try:
                        ipx2 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipx2 = None
                    ipx1 = ipx2
                else:
                    ipx2 = None
                    try:
                        ipx2 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipx2 = None
                    ipx1 = ipx2
                ipx = (edge21 + ipx1)
        if (ipy > edge1.currY):
            ipy = edge1.currY
            f = edge1.dx
            f1 = edge2.dx
            if (((-f if ((f < 0)) else f)) > ((-f1 if ((f1 < 0)) else f1))):
                if (ipy == edge2.topY):
                    ipx = edge2.topX
                else:
                    edge21 = edge2.botX
                    value = (edge2.dx * ((ipy - edge2.botY)))
                    ipx1 = None
                    if (value < 0):
                        ipx2 = None
                        try:
                            ipx2 = int((value - 0.5))
                        except BaseException as _g:
                            None
                            ipx2 = None
                        ipx1 = ipx2
                    else:
                        ipx2 = None
                        try:
                            ipx2 = int((value + 0.5))
                        except BaseException as _g:
                            None
                            ipx2 = None
                        ipx1 = ipx2
                    ipx = (edge21 + ipx1)
            elif (ipy == edge1.topY):
                ipx = edge1.topX
            else:
                edge11 = edge1.botX
                value = (edge1.dx * ((ipy - edge1.botY)))
                ipx1 = None
                if (value < 0):
                    ipx2 = None
                    try:
                        ipx2 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipx2 = None
                    ipx1 = ipx2
                else:
                    ipx2 = None
                    try:
                        ipx2 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipx2 = None
                    ipx1 = ipx2
                ipx = (edge11 + ipx1)
        return h2d_col_IPoint(ipx,ipy)

    def ProcessEdgesAtTopOfScanbeam(self,topY):
        e = self.m_ActiveEdges
        while (e is not None):
            IsMaximaEdge = (((e is not None) and ((e.topY == topY))) and ((e.nextInLML is None)))
            if IsMaximaEdge:
                eMaxPair = self.GetMaximaPair(e)
                IsMaximaEdge = ((eMaxPair is None) or ((eMaxPair.deltaY != 0)))
            if IsMaximaEdge:
                ePrev = e.prevInAEL
                self.DoMaxima(e)
                if (ePrev is None):
                    e = self.m_ActiveEdges
                else:
                    e = ePrev.nextInAEL
            else:
                if (((e.topY == topY) and ((e.nextInLML is not None))) and ((e.nextInLML.deltaY == 0))):
                    e = self.UpdateEdgeIntoAEL(e)
                    if (e.outIdx >= 0):
                        self.AddOutPt(e,h2d_col_IPoint(e.botX,e.botY))
                    self.AddEdgeToSEL(e)
                else:
                    tmp = None
                    if (topY == e.topY):
                        tmp = e.topX
                    else:
                        e1 = e.botX
                        value = (e.dx * ((topY - e.botY)))
                        tmp1 = None
                        if (value < 0):
                            tmp2 = None
                            try:
                                tmp2 = int((value - 0.5))
                            except BaseException as _g:
                                None
                                tmp2 = None
                            tmp1 = tmp2
                        else:
                            tmp3 = None
                            try:
                                tmp3 = int((value + 0.5))
                            except BaseException as _g1:
                                None
                                tmp3 = None
                            tmp1 = tmp3
                        tmp = (e1 + tmp1)
                    e.currX = tmp
                    e.currY = topY
                if self.strictlySimple:
                    ePrev1 = e.prevInAEL
                    if ((((((e.outIdx >= 0) and ((e.windDelta != 0))) and ((ePrev1 is not None))) and ((ePrev1.outIdx >= 0))) and ((ePrev1.currX == e.currX))) and ((ePrev1.windDelta != 0))):
                        ip = h2d_col_IPoint(e.currX,e.currY)
                        op = self.AddOutPt(ePrev1,ip)
                        op2 = self.AddOutPt(e,ip)
                        self.AddJoin(op,op2,ip)
                e = e.nextInAEL
        self.ProcessHorizontals(True)
        e = self.m_ActiveEdges
        while (e is not None):
            if ((e.topY == topY) and ((e.nextInLML is not None))):
                op = None
                if (e.outIdx >= 0):
                    op = self.AddOutPt(e,h2d_col_IPoint(e.topX,e.topY))
                e = self.UpdateEdgeIntoAEL(e)
                ePrev = e.prevInAEL
                eNext = e.nextInAEL
                if (((((((((ePrev is not None) and ((ePrev.currX == e.botX))) and ((ePrev.currY == e.botY))) and ((op is not None))) and ((ePrev.outIdx >= 0))) and ((ePrev.currY > ePrev.topY))) and (((e.deltaY * ePrev.deltaX) == ((e.deltaX * ePrev.deltaY))))) and ((e.windDelta != 0))) and ((ePrev.windDelta != 0))):
                    op2 = self.AddOutPt(ePrev,h2d_col_IPoint(e.botX,e.botY))
                    self.AddJoin(op,op2,h2d_col_IPoint(e.topX,e.topY))
                elif (((((((((eNext is not None) and ((eNext.currX == e.botX))) and ((eNext.currY == e.botY))) and ((op is not None))) and ((eNext.outIdx >= 0))) and ((eNext.currY > eNext.topY))) and (((e.deltaY * eNext.deltaX) == ((e.deltaX * eNext.deltaY))))) and ((e.windDelta != 0))) and ((eNext.windDelta != 0))):
                    op21 = self.AddOutPt(eNext,h2d_col_IPoint(e.botX,e.botY))
                    self.AddJoin(op,op21,h2d_col_IPoint(e.topX,e.topY))
            e = e.nextInAEL

    def DoMaxima(self,e):
        eMaxPair = self.GetMaximaPair(e)
        if (eMaxPair is None):
            if (e.outIdx >= 0):
                self.AddOutPt(e,h2d_col_IPoint(e.topX,e.topY))
            self.DeleteFromAEL(e)
            return
        eNext = e.nextInAEL
        while ((eNext is not None) and ((eNext != eMaxPair))):
            self.IntersectEdges(e,eNext,h2d_col_IPoint(e.topX,e.topY))
            self.SwapPositionsInAEL(e,eNext)
            eNext = e.nextInAEL
        if ((e.outIdx == -1) and ((eMaxPair.outIdx == -1))):
            self.DeleteFromAEL(e)
            self.DeleteFromAEL(eMaxPair)
        elif ((e.outIdx >= 0) and ((eMaxPair.outIdx >= 0))):
            if (e.outIdx >= 0):
                self.AddLocalMaxPoly(e,eMaxPair,h2d_col_IPoint(e.topX,e.topY))
            self.DeleteFromAEL(e)
            self.DeleteFromAEL(eMaxPair)
        else:
            raise haxe_Exception.thrown("DoMaxima error")

    def reversePolygons(self,polys):
        _g_i = 0
        _g_a = polys
        _g_l = len(_g_a)
        while (_g_i < _g_l):
            p = _g_i
            _g_i = (_g_i + 1)
            p1 = (_g_a[p] if p >= 0 and p < len(_g_a) else None)
            h2d_col__IPolygon_IPolygon_Impl_.reverse(p1)

    def PointCount(self,pts):
        if (pts is None):
            return 0
        result = 0
        p = pts
        while True:
            result = (result + 1)
            p = p.next
            if (not ((p != pts))):
                break
        return result

    def BuildResult(self):
        solution = []
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (outRec.pts is None):
                continue
            if ((self.resultKind == hxd_clipper_ResultKind.NoHoles) and outRec.isHole):
                continue
            if ((self.resultKind == hxd_clipper_ResultKind.HolesOnly) and (not outRec.isHole)):
                continue
            p = outRec.pts.prev
            cnt = self.PointCount(p)
            if (cnt < 2):
                continue
            points = None
            this1 = ([] if ((points is None)) else points)
            pg = this1
            _g2 = 0
            _g3 = cnt
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                x = p.pt
                pg.append(x)
                p = p.prev
            solution.append(pg)
        return solution

    def BuildResult2(self,polytree):
        polytree.clear()
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            cnt = self.PointCount(outRec.pts)
            if (cnt < 3):
                continue
            self.FixHoleLinkage(outRec)
            pn = hxd_clipper__Clipper_PolyNode()
            _this = polytree.allPolys
            _this.append(pn)
            outRec.polyNode = pn
            op = outRec.pts.prev
            _g2 = 0
            _g3 = cnt
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                _this1 = pn.polygon
                x = op.pt
                _this1.append(x)
                op = op.prev
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (outRec.polyNode is None):
                continue
            elif ((outRec.firstLeft is not None) and ((outRec.firstLeft.polyNode is not None))):
                outRec.firstLeft.polyNode.addChild(outRec.polyNode)
            else:
                polytree.addChild(outRec.polyNode)

    def FixupOutPolygon(self,outRec):
        lastOK = None
        outRec.bottomPt = None
        pp = outRec.pts
        while True:
            if ((pp.prev == pp) or ((pp.prev == pp.next))):
                outRec.pts = None
                return
            tmp = None
            tmp1 = None
            pt1 = pp.pt
            pt2 = pp.next.pt
            if (not (((pt1.x == pt2.x) and ((pt1.y == pt2.y))))):
                pt11 = pp.pt
                pt21 = pp.prev.pt
                tmp1 = ((pt11.x == pt21.x) and ((pt11.y == pt21.y)))
            else:
                tmp1 = True
            if (not tmp1):
                pt12 = pp.prev.pt
                pt22 = pp.pt
                pt3 = pp.next.pt
                tmp = ((((((pt12.y - pt22.y)) * ((pt22.x - pt3.x))) - ((((pt12.x - pt22.x)) * ((pt22.y - pt3.y))))) == 0) and (((not self.preserveCollinear) or (not self.Pt2IsBetweenPt1AndPt3(pp.prev.pt,pp.pt,pp.next.pt)))))
            else:
                tmp = True
            if tmp:
                lastOK = None
                tmp2 = pp
                pp.prev.next = pp.next
                pp.next.prev = pp.prev
                pp = pp.prev
                tmp2 = None
            elif (pp == lastOK):
                break
            else:
                if (lastOK is None):
                    lastOK = pp
                pp = pp.next
        outRec.pts = pp

    def DupOutPt(self,outPt,InsertAfter):
        result = hxd_clipper__Clipper_OutPt()
        result.pt = outPt.pt
        result.idx = outPt.idx
        if InsertAfter:
            result.next = outPt.next
            result.prev = outPt
            outPt.next.prev = result
            outPt.next = result
        else:
            result.prev = outPt.prev
            result.next = outPt
            outPt.prev.next = result
            outPt.prev = result
        return result

    def GetOverlap(self,a1,a2,b1,b2):
        Left = None
        Right = None
        if (a1 < a2):
            if (b1 < b2):
                Left = (b1 if ((a1 < b1)) else a1)
                Right = (b2 if ((a2 > b2)) else a2)
            else:
                Left = (b2 if ((a1 < b2)) else a1)
                Right = (b1 if ((a2 > b1)) else a2)
        elif (b1 < b2):
            Left = (b1 if ((a2 < b1)) else a2)
            Right = (b2 if ((a1 > b2)) else a1)
        else:
            Left = (b2 if ((a2 < b2)) else a2)
            Right = (b1 if ((a1 > b1)) else a1)
        return _hx_AnonObject({'left': Left, 'right': Right, 'done': (Left < Right)})

    def JoinHorz(self,op1,op1b,op2,op2b,pt,DiscardLeft):
        Dir1 = (hxd_clipper__Clipper_Direction.RightToLeft if ((op1.pt.x > op1b.pt.x)) else hxd_clipper__Clipper_Direction.LeftToRight)
        Dir2 = (hxd_clipper__Clipper_Direction.RightToLeft if ((op2.pt.x > op2b.pt.x)) else hxd_clipper__Clipper_Direction.LeftToRight)
        if (Dir1 == Dir2):
            return False
        if (Dir1 == hxd_clipper__Clipper_Direction.LeftToRight):
            while (((op1.next.pt.x <= pt.x) and ((op1.next.pt.x >= op1.pt.x))) and ((op1.next.pt.y == pt.y))):
                op1 = op1.next
            if (DiscardLeft and ((op1.pt.x != pt.x))):
                op1 = op1.next
            op1b = self.DupOutPt(op1,(not DiscardLeft))
            if (op1b.pt != pt):
                op1 = op1b
                op1.pt = pt
                op1b = self.DupOutPt(op1,(not DiscardLeft))
        else:
            while (((op1.next.pt.x >= pt.x) and ((op1.next.pt.x <= op1.pt.x))) and ((op1.next.pt.y == pt.y))):
                op1 = op1.next
            if ((not DiscardLeft) and ((op1.pt.x != pt.x))):
                op1 = op1.next
            op1b = self.DupOutPt(op1,DiscardLeft)
            if (op1b.pt != pt):
                op1 = op1b
                op1.pt = pt
                op1b = self.DupOutPt(op1,DiscardLeft)
        if (Dir2 == hxd_clipper__Clipper_Direction.LeftToRight):
            while (((op2.next.pt.x <= pt.x) and ((op2.next.pt.x >= op2.pt.x))) and ((op2.next.pt.y == pt.y))):
                op2 = op2.next
            if (DiscardLeft and ((op2.pt.x != pt.x))):
                op2 = op2.next
            op2b = self.DupOutPt(op2,(not DiscardLeft))
            if (op2b.pt != pt):
                op2 = op2b
                op2.pt = pt
                op2b = self.DupOutPt(op2,(not DiscardLeft))
        else:
            while (((op2.next.pt.x >= pt.x) and ((op2.next.pt.x <= op2.pt.x))) and ((op2.next.pt.y == pt.y))):
                op2 = op2.next
            if ((not DiscardLeft) and ((op2.pt.x != pt.x))):
                op2 = op2.next
            op2b = self.DupOutPt(op2,DiscardLeft)
            if (op2b.pt != pt):
                op2 = op2b
                op2.pt = pt
                op2b = self.DupOutPt(op2,DiscardLeft)
        if ((Dir1 == hxd_clipper__Clipper_Direction.LeftToRight) == DiscardLeft):
            op1.prev = op2
            op2.next = op1
            op1b.next = op2b
            op2b.prev = op1b
        else:
            op1.next = op2
            op2.prev = op1
            op1b.prev = op2b
            op2b.next = op1b
        return True

    def JoinPoints(self,j,outRec1,outRec2):
        op1 = j.outPt1
        op1b = None
        op2 = j.outPt2
        op2b = None
        isHorizontal = (j.outPt1.pt.y == j.offPt.y)
        tmp = None
        tmp1 = None
        if isHorizontal:
            pt1 = j.offPt
            pt2 = j.outPt1.pt
            tmp1 = ((pt1.x == pt2.x) and ((pt1.y == pt2.y)))
        else:
            tmp1 = False
        if tmp1:
            pt1 = j.offPt
            pt2 = j.outPt2.pt
            tmp = ((pt1.x == pt2.x) and ((pt1.y == pt2.y)))
        else:
            tmp = False
        if tmp:
            if (outRec1 != outRec2):
                return False
            op1b = j.outPt1.next
            while True:
                tmp = None
                if (op1b != op1):
                    pt1 = op1b.pt
                    pt2 = j.offPt
                    tmp = ((pt1.x == pt2.x) and ((pt1.y == pt2.y)))
                else:
                    tmp = False
                if (not tmp):
                    break
                op1b = op1b.next
            reverse1 = (op1b.pt.y > j.offPt.y)
            op2b = j.outPt2.next
            while True:
                tmp = None
                if (op2b != op2):
                    pt1 = op2b.pt
                    pt2 = j.offPt
                    tmp = ((pt1.x == pt2.x) and ((pt1.y == pt2.y)))
                else:
                    tmp = False
                if (not tmp):
                    break
                op2b = op2b.next
            reverse2 = (op2b.pt.y > j.offPt.y)
            if (reverse1 == reverse2):
                return False
            if reverse1:
                op1b = self.DupOutPt(op1,False)
                op2b = self.DupOutPt(op2,True)
                op1.prev = op2
                op2.next = op1
                op1b.next = op2b
                op2b.prev = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return True
            else:
                op1b = self.DupOutPt(op1,True)
                op2b = self.DupOutPt(op2,False)
                op1.next = op2
                op2.prev = op1
                op1b.prev = op2b
                op2b.next = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return True
        elif isHorizontal:
            op1b = op1
            while (((op1.prev.pt.y == op1.pt.y) and ((op1.prev != op1b))) and ((op1.prev != op2))):
                op1 = op1.prev
            while (((op1b.next.pt.y == op1b.pt.y) and ((op1b.next != op1))) and ((op1b.next != op2))):
                op1b = op1b.next
            if ((op1b.next == op1) or ((op1b.next == op2))):
                return False
            op2b = op2
            while (((op2.prev.pt.y == op2.pt.y) and ((op2.prev != op2b))) and ((op2.prev != op1b))):
                op2 = op2.prev
            while (((op2b.next.pt.y == op2b.pt.y) and ((op2b.next != op2))) and ((op2b.next != op1))):
                op2b = op2b.next
            if ((op2b.next == op2) or ((op2b.next == op1))):
                return False
            out = self.GetOverlap(op1.pt.x,op1b.pt.x,op2.pt.x,op2b.pt.x)
            if (not out.done):
                return False
            Left = out.left
            Right = out.right
            Pt = None
            DiscardLeftSide = None
            if ((op1.pt.x >= Left) and ((op1.pt.x <= Right))):
                Pt = op1.pt
                DiscardLeftSide = (op1.pt.x > op1b.pt.x)
            elif ((op2.pt.x >= Left) and ((op2.pt.x <= Right))):
                Pt = op2.pt
                DiscardLeftSide = (op2.pt.x > op2b.pt.x)
            elif ((op1b.pt.x >= Left) and ((op1b.pt.x <= Right))):
                Pt = op1b.pt
                DiscardLeftSide = (op1b.pt.x > op1.pt.x)
            else:
                Pt = op2b.pt
                DiscardLeftSide = (op2b.pt.x > op2.pt.x)
            j.outPt1 = op1
            j.outPt2 = op2
            return self.JoinHorz(op1,op1b,op2,op2b,Pt,DiscardLeftSide)
        else:
            op1b = op1.next
            while True:
                pt1 = op1b.pt
                pt2 = op1.pt
                if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((op1b != op1))))):
                    break
                op1b = op1b.next
            Reverse1 = None
            if (op1b.pt.y <= op1.pt.y):
                pt1 = op1.pt
                pt2 = op1b.pt
                pt3 = j.offPt
                Reverse1 = (((((pt1.y - pt2.y)) * ((pt2.x - pt3.x))) - ((((pt1.x - pt2.x)) * ((pt2.y - pt3.y))))) != 0)
            else:
                Reverse1 = True
            if Reverse1:
                op1b = op1.prev
                while True:
                    pt1 = op1b.pt
                    pt2 = op1.pt
                    if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((op1b != op1))))):
                        break
                    op1b = op1b.prev
                tmp = None
                if (op1b.pt.y <= op1.pt.y):
                    pt1 = op1.pt
                    pt2 = op1b.pt
                    pt3 = j.offPt
                    tmp = (((((pt1.y - pt2.y)) * ((pt2.x - pt3.x))) - ((((pt1.x - pt2.x)) * ((pt2.y - pt3.y))))) != 0)
                else:
                    tmp = True
                if tmp:
                    return False
            op2b = op2.next
            while True:
                pt1 = op2b.pt
                pt2 = op2.pt
                if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((op2b != op2))))):
                    break
                op2b = op2b.next
            Reverse2 = None
            if (op2b.pt.y <= op2.pt.y):
                pt1 = op2.pt
                pt2 = op2b.pt
                pt3 = j.offPt
                Reverse2 = (((((pt1.y - pt2.y)) * ((pt2.x - pt3.x))) - ((((pt1.x - pt2.x)) * ((pt2.y - pt3.y))))) != 0)
            else:
                Reverse2 = True
            if Reverse2:
                op2b = op2.prev
                while True:
                    pt1 = op2b.pt
                    pt2 = op2.pt
                    if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((op2b != op2))))):
                        break
                    op2b = op2b.prev
                tmp = None
                if (op2b.pt.y <= op2.pt.y):
                    pt1 = op2.pt
                    pt2 = op2b.pt
                    pt3 = j.offPt
                    tmp = (((((pt1.y - pt2.y)) * ((pt2.x - pt3.x))) - ((((pt1.x - pt2.x)) * ((pt2.y - pt3.y))))) != 0)
                else:
                    tmp = True
                if tmp:
                    return False
            if ((((op1b == op1) or ((op2b == op2))) or ((op1b == op2b))) or (((outRec1 == outRec2) and ((Reverse1 == Reverse2))))):
                return False
            if Reverse1:
                op1b = self.DupOutPt(op1,False)
                op2b = self.DupOutPt(op2,True)
                op1.prev = op2
                op2.next = op1
                op1b.next = op2b
                op2b.prev = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return True
            else:
                op1b = self.DupOutPt(op1,True)
                op2b = self.DupOutPt(op2,False)
                op1.next = op2
                op2.prev = op1
                op1b.prev = op2b
                op2b.next = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return True

    def PointInPolygon(self,pt,pol):
        result = 0
        cnt = len(pol)
        if (cnt < 3):
            return 0
        ip = (pol[0] if 0 < len(pol) else None)
        _g = 1
        _g1 = (cnt + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            ipNext = ((pol[0] if 0 < len(pol) else None) if ((i == cnt)) else (pol[i] if i >= 0 and i < len(pol) else None))
            if (ipNext.y == pt.y):
                if ((ipNext.x == pt.x) or (((ip.y == pt.y) and (((ipNext.x > pt.x) == ((ip.x < pt.x))))))):
                    return -1
            if ((ip.y < pt.y) != ((ipNext.y < pt.y))):
                if (ip.x >= pt.x):
                    if (ipNext.x > pt.x):
                        result = (1 - result)
                    else:
                        d = ((((ip.x - pt.x)) * ((ipNext.y - pt.y))) - ((((ipNext.x - pt.x)) * ((ip.y - pt.y)))))
                        if (d == 0):
                            return -1
                        elif ((d > 0) == ((ipNext.y > ip.y))):
                            result = (1 - result)
                elif (ipNext.x > pt.x):
                    d1 = ((((ip.x - pt.x)) * ((ipNext.y - pt.y))) - ((((ipNext.x - pt.x)) * ((ip.y - pt.y)))))
                    if (d1 == 0):
                        return -1
                    elif ((d1 > 0) == ((ipNext.y > ip.y))):
                        result = (1 - result)
            ip = ipNext
        return result

    def PointInPolygon2(self,pt,op):
        result = 0
        startOp = op
        ptx = pt.x
        pty = pt.y
        poly0x = op.pt.x
        poly0y = op.pt.y
        while True:
            op = op.next
            poly1x = op.pt.x
            poly1y = op.pt.y
            if (poly1y == pty):
                if ((poly1x == ptx) or (((poly0y == pty) and (((poly1x > ptx) == ((poly0x < ptx))))))):
                    return -1
            if ((poly0y < pty) != ((poly1y < pty))):
                if (poly0x >= ptx):
                    if (poly1x > ptx):
                        result = (1 - result)
                    else:
                        d = ((((poly0x - ptx)) * ((poly1y - pty))) - ((((poly1x - ptx)) * ((poly0y - pty)))))
                        if (d == 0):
                            return -1
                        if ((d > 0) == ((poly1y > poly0y))):
                            result = (1 - result)
                elif (poly1x > ptx):
                    d1 = ((((poly0x - ptx)) * ((poly1y - pty))) - ((((poly1x - ptx)) * ((poly0y - pty)))))
                    if (d1 == 0):
                        return -1
                    if ((d1 > 0) == ((poly1y > poly0y))):
                        result = (1 - result)
            poly0x = poly1x
            poly0y = poly1y
            if (not ((startOp != op))):
                break
        return result

    def Poly2ContainsPoly1(self,outPt1,outPt2):
        op = outPt1
        while True:
            res = self.PointInPolygon2(op.pt,outPt2)
            if (res >= 0):
                return (res > 0)
            op = op.next
            if (not ((op != outPt1))):
                break
        return True

    def FixupFirstLefts1(self,OldOutRec,NewOutRec):
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((outRec.pts is None) or ((outRec.firstLeft is None))):
                continue
            firstLeft = self.ParseFirstLeft(outRec.firstLeft)
            if (firstLeft == OldOutRec):
                if self.Poly2ContainsPoly1(outRec.pts,NewOutRec.pts):
                    outRec.firstLeft = NewOutRec

    def FixupFirstLefts2(self,OldOutRec,NewOutRec):
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (outRec.firstLeft == OldOutRec):
                outRec.firstLeft = NewOutRec

    def ParseFirstLeft(self,FirstLeft):
        while ((FirstLeft is not None) and ((FirstLeft.pts is None))):
            FirstLeft = FirstLeft.firstLeft
        return FirstLeft

    def JoinCommonEdges(self):
        _g = 0
        _g1 = len(self.m_Joins)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            join = (self.m_Joins[i] if i >= 0 and i < len(self.m_Joins) else None)
            outRec1 = self.GetOutRec(join.outPt1.idx)
            outRec2 = self.GetOutRec(join.outPt2.idx)
            if ((outRec1.pts is None) or ((outRec2.pts is None))):
                continue
            holeStateRec = None
            if (outRec1 == outRec2):
                holeStateRec = outRec1
            elif self.Param1RightOfParam2(outRec1,outRec2):
                holeStateRec = outRec2
            elif self.Param1RightOfParam2(outRec2,outRec1):
                holeStateRec = outRec1
            else:
                holeStateRec = self.GetLowermostRec(outRec1,outRec2)
            if (not self.JoinPoints(join,outRec1,outRec2)):
                continue
            if (outRec1 == outRec2):
                outRec1.pts = join.outPt1
                outRec1.bottomPt = None
                outRec2 = self.CreateOutRec()
                outRec2.pts = join.outPt2
                self.UpdateOutPtIdxs(outRec2)
                if self.m_UsingPolyTree:
                    _g2 = 0
                    _g3 = (len(self.m_PolyOuts) - 1)
                    while (_g2 < _g3):
                        j = _g2
                        _g2 = (_g2 + 1)
                        oRec = (self.m_PolyOuts[j] if j >= 0 and j < len(self.m_PolyOuts) else None)
                        if (((oRec.pts is None) or ((self.ParseFirstLeft(oRec.firstLeft) != outRec1))) or ((oRec.isHole == outRec1.isHole))):
                            continue
                        if self.Poly2ContainsPoly1(oRec.pts,join.outPt2):
                            oRec.firstLeft = outRec2
                if self.Poly2ContainsPoly1(outRec2.pts,outRec1.pts):
                    outRec2.isHole = (not outRec1.isHole)
                    outRec2.firstLeft = outRec1
                    if self.m_UsingPolyTree:
                        self.FixupFirstLefts2(outRec2,outRec1)
                    b = self.reverseSolution
                    if ((((not b) if (outRec2.isHole) else b)) == ((self.Area(outRec2) > 0))):
                        self.ReversePolyPtLinks(outRec2.pts)
                elif self.Poly2ContainsPoly1(outRec1.pts,outRec2.pts):
                    outRec2.isHole = outRec1.isHole
                    outRec1.isHole = (not outRec2.isHole)
                    outRec2.firstLeft = outRec1.firstLeft
                    outRec1.firstLeft = outRec2
                    if self.m_UsingPolyTree:
                        self.FixupFirstLefts2(outRec1,outRec2)
                    b1 = self.reverseSolution
                    if ((((not b1) if (outRec1.isHole) else b1)) == ((self.Area(outRec1) > 0))):
                        self.ReversePolyPtLinks(outRec1.pts)
                else:
                    outRec2.isHole = outRec1.isHole
                    outRec2.firstLeft = outRec1.firstLeft
                    if self.m_UsingPolyTree:
                        self.FixupFirstLefts1(outRec1,outRec2)
            else:
                outRec2.pts = None
                outRec2.bottomPt = None
                outRec2.idx = outRec1.idx
                outRec1.isHole = holeStateRec.isHole
                if (holeStateRec == outRec2):
                    outRec1.firstLeft = outRec2.firstLeft
                outRec2.firstLeft = outRec1
                if self.m_UsingPolyTree:
                    self.FixupFirstLefts2(outRec2,outRec1)

    def UpdateOutPtIdxs(self,outrec):
        op = outrec.pts
        while True:
            op.idx = outrec.idx
            op = op.prev
            if (not ((op != outrec.pts))):
                break

    def DoSimplePolygons(self):
        i = 0
        while (i < len(self.m_PolyOuts)):
            outrec = i
            i = (i + 1)
            outrec1 = (self.m_PolyOuts[outrec] if outrec >= 0 and outrec < len(self.m_PolyOuts) else None)
            op = outrec1.pts
            if (op is None):
                continue
            while True:
                op2 = op.next
                while (op2 != outrec1.pts):
                    pt1 = op.pt
                    pt2 = op2.pt
                    if ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((op2.next != op))) and ((op2.prev != op))):
                        op3 = op.prev
                        op4 = op2.prev
                        op.prev = op4
                        op4.next = op
                        op2.prev = op3
                        op3.next = op2
                        outrec1.pts = op
                        outrec2 = self.CreateOutRec()
                        outrec2.pts = op2
                        self.UpdateOutPtIdxs(outrec2)
                        if self.Poly2ContainsPoly1(outrec2.pts,outrec1.pts):
                            outrec2.isHole = (not outrec1.isHole)
                            outrec2.firstLeft = outrec1
                        elif self.Poly2ContainsPoly1(outrec1.pts,outrec2.pts):
                            outrec2.isHole = outrec1.isHole
                            outrec1.isHole = (not outrec2.isHole)
                            outrec2.firstLeft = outrec1.firstLeft
                            outrec1.firstLeft = outrec2
                        else:
                            outrec2.isHole = outrec1.isHole
                            outrec2.firstLeft = outrec1.firstLeft
                        op2 = op
                    op2 = op2.next
                op = op.next
                if (not ((op != outrec1.pts))):
                    break

    def Area(self,outRec):
        op = outRec.pts
        if (op is None):
            return 0.
        a = 0
        while True:
            a = (a + ((((op.pt.x + op.prev.pt.x)) * ((op.prev.pt.y - op.pt.y)))))
            op = op.next
            if (not ((op != outRec.pts))):
                break
        return (a / 2)

    def DistanceFromLineSqrd(self,pt,ln1,ln2):
        A = (ln1.y - ln2.y)
        B = (ln2.x - ln1.x)
        C = ((A * ln1.x) + ((B * ln1.y)))
        C = (((A * pt.x) + ((B * pt.y))) - C)
        return ((C * C) / (((A * A) + ((B * B)))))

    def SlopesNearCollinear(self,pt1,pt2,pt3,distSqrd):
        f = (pt1.x - pt2.x)
        f1 = (pt1.y - pt2.y)
        if (((-f if ((f < 0)) else f)) > ((-f1 if ((f1 < 0)) else f1))):
            if ((pt1.x > pt2.x) == ((pt1.x < pt3.x))):
                return (self.DistanceFromLineSqrd(pt1,pt2,pt3) < distSqrd)
            elif ((pt2.x > pt1.x) == ((pt2.x < pt3.x))):
                return (self.DistanceFromLineSqrd(pt2,pt1,pt3) < distSqrd)
            else:
                return (self.DistanceFromLineSqrd(pt3,pt1,pt2) < distSqrd)
        elif ((pt1.y > pt2.y) == ((pt1.y < pt3.y))):
            return (self.DistanceFromLineSqrd(pt1,pt2,pt3) < distSqrd)
        elif ((pt2.y > pt1.y) == ((pt2.y < pt3.y))):
            return (self.DistanceFromLineSqrd(pt2,pt1,pt3) < distSqrd)
        else:
            return (self.DistanceFromLineSqrd(pt3,pt1,pt2) < distSqrd)

    def PointsAreClose(self,pt1,pt2,distSqrd):
        dx = (pt1.x - pt2.x)
        dy = (pt1.y - pt2.y)
        return (((dx * dx) + ((dy * dy))) <= distSqrd)

    def ExcludeOp(self,op):
        result = op.prev
        result.next = op.next
        op.next.prev = result
        result.idx = 0
        return result

    def CleanPolygon(self,path,distance = None):
        if (distance is None):
            distance = 1.415
        cnt = len(path)
        if (cnt == 0):
            points = None
            this1 = ([] if ((points is None)) else points)
            return this1
        outPts = []
        _g = 0
        _g1 = cnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(outPts, i, hxd_clipper__Clipper_OutPt())
            (outPts[i] if i >= 0 and i < len(outPts) else None).pt = (path[i] if i >= 0 and i < len(path) else None)
            (outPts[i] if i >= 0 and i < len(outPts) else None).next = python_internal_ArrayImpl._get(outPts, HxOverrides.mod(((i + 1)), cnt))
            (outPts[i] if i >= 0 and i < len(outPts) else None).next.prev = (outPts[i] if i >= 0 and i < len(outPts) else None)
            (outPts[i] if i >= 0 and i < len(outPts) else None).idx = 0
        distSqrd = (distance * distance)
        op = (outPts[0] if 0 < len(outPts) else None)
        while ((op.idx == 0) and ((op.next != op.prev))):
            if self.PointsAreClose(op.pt,op.prev.pt,distSqrd):
                op = self.ExcludeOp(op)
                cnt = (cnt - 1)
            elif self.PointsAreClose(op.prev.pt,op.next.pt,distSqrd):
                self.ExcludeOp(op.next)
                op = self.ExcludeOp(op)
                cnt = (cnt - 2)
            elif self.SlopesNearCollinear(op.prev.pt,op.pt,op.next.pt,distSqrd):
                op = self.ExcludeOp(op)
                cnt = (cnt - 1)
            else:
                op.idx = 1
                op = op.next
        if (cnt < 3):
            cnt = 0
        points = None
        this1 = ([] if ((points is None)) else points)
        result = this1
        _g = 0
        _g1 = cnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = op.pt
            result.append(x)
            op = op.next
        outPts = None
        return result

    def CleanPolygons(self,polys,distance = None):
        if (distance is None):
            distance = 1.415
        polygons = None
        this1 = ([] if ((polygons is None)) else polygons)
        result = this1
        _g = 0
        _g1 = len(polys)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = self.CleanPolygon((polys[i] if i >= 0 and i < len(polys) else None),distance)
            result.append(x)
        return result

    def Minkowski(self,pattern,path,IsSum):
        polyCnt = len(pattern)
        pathCnt = len(path)
        polygons = None
        this1 = ([] if ((polygons is None)) else polygons)
        result = this1
        _g = 0
        _g1 = pathCnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            points = None
            this1 = ([] if ((points is None)) else points)
            p = this1
            _g_i = 0
            _g_a = pattern
            _g_l = len(_g_a)
            while (_g_i < _g_l):
                ip = _g_i
                _g_i = (_g_i + 1)
                ip1 = (_g_a[ip] if ip >= 0 and ip < len(_g_a) else None)
                if IsSum:
                    x = h2d_col_IPoint(((path[i] if i >= 0 and i < len(path) else None).x + ip1.x),((path[i] if i >= 0 and i < len(path) else None).y + ip1.y))
                    p.append(x)
                else:
                    x1 = h2d_col_IPoint(((path[i] if i >= 0 and i < len(path) else None).x - ip1.x),((path[i] if i >= 0 and i < len(path) else None).y - ip1.y))
                    p.append(x1)
            result.append(p)
        polygons = None
        this1 = ([] if ((polygons is None)) else polygons)
        quads = this1
        _g = 0
        _g1 = pathCnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = polyCnt
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                points = None
                this1 = ([] if ((points is None)) else points)
                quad = this1
                quad.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(result, HxOverrides.mod(i, pathCnt)), HxOverrides.mod(j, polyCnt)))
                quad.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(result, HxOverrides.mod(((i + 1)), pathCnt)), HxOverrides.mod(j, polyCnt)))
                quad.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(result, HxOverrides.mod(((i + 1)), pathCnt)), HxOverrides.mod(((j + 1)), polyCnt)))
                quad.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(result, HxOverrides.mod(i, pathCnt)), HxOverrides.mod(((j + 1)), polyCnt)))
                if (not ((hxd_clipper_Clipper.polArea(quad) >= 0))):
                    h2d_col__IPolygon_IPolygon_Impl_.reverse(quad)
                quads.append(quad)
        return quads

    def MinkowskiSum(self,pattern,pol,kind = None):
        paths = self.Minkowski(pattern,pol,True)
        c = hxd_clipper_Clipper()
        c.resultKind = (hxd_clipper_ResultKind.All if ((kind is None)) else kind)
        c.addPolygons(paths,hxd_clipper_PolyType.Subject)
        return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    def TranslatePath(self,path,delta):
        points = None
        this1 = ([] if ((points is None)) else points)
        outPath = this1
        _g = 0
        _g1 = len(path)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = h2d_col_IPoint(((path[i] if i >= 0 and i < len(path) else None).x + delta.x),((path[i] if i >= 0 and i < len(path) else None).y + delta.y))
            outPath.append(x)
        return outPath

    def PolyTreeToPaths(self,polytree):
        polygons = None
        this1 = ([] if ((polygons is None)) else polygons)
        result = this1
        self.AddPolyNodeToPaths(polytree,hxd_clipper_NodeType.Any,result)
        return result

    def AddPolyNodeToPaths(self,polynode,nt,paths):
        match = True
        if (nt.index == 1):
            return
        if ((len(polynode.polygon) > 0) and match):
            x = polynode.polygon
            paths.append(x)
        _g = 0
        _g1 = polynode.childs
        while (_g < len(_g1)):
            pn = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.AddPolyNodeToPaths(pn,nt,paths)

    @staticmethod
    def compareY(n1,n2):
        if ((n2.pt.y - n1.pt.y) >= 0):
            return 1
        else:
            return -1

    @staticmethod
    def Orientation(poly):
        return (hxd_clipper_Clipper.polArea(poly) >= 0)

    @staticmethod
    def polArea(poly):
        cnt = len(poly)
        if (cnt < 3):
            return 0.
        a = 0.
        j = (cnt - 1)
        _g = 0
        _g1 = cnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            a = (a + (((((poly[j] if j >= 0 and j < len(poly) else None).x + (poly[i] if i >= 0 and i < len(poly) else None).x)) * (((poly[j] if j >= 0 and j < len(poly) else None).y - (poly[i] if i >= 0 and i < len(poly) else None).y)))))
            j = i
        return (-a * 0.5)

    @staticmethod
    def SimplifyPolygon(poly,fillType = None):
        if (fillType is None):
            fillType = hxd_clipper_PolyFillType.EvenOdd
        c = hxd_clipper_Clipper()
        c.strictlySimple = True
        c.addPolygon(poly,hxd_clipper_PolyType.Subject)
        return c.execute(hxd_clipper_ClipType.Union,fillType,fillType)

    @staticmethod
    def SimplifyPolygons(polys,fillType = None):
        if (fillType is None):
            fillType = hxd_clipper_PolyFillType.EvenOdd
        c = hxd_clipper_Clipper()
        c.strictlySimple = True
        c.addPolygons(polys,hxd_clipper_PolyType.Subject)
        return c.execute(hxd_clipper_ClipType.Union,fillType,fillType)

    @staticmethod
    def MinkowskiSums(pattern,pols,kind = None):
        c = hxd_clipper_Clipper()
        c.resultKind = (hxd_clipper_ResultKind.All if ((kind is None)) else kind)
        _g = 0
        _g1 = len(pols)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            tmp = c.Minkowski(pattern,(pols[i] if i >= 0 and i < len(pols) else None),True)
            c.addPolygons(tmp,hxd_clipper_PolyType.Subject)
            path = c.TranslatePath((pols[i] if i >= 0 and i < len(pols) else None),(pattern[0] if 0 < len(pattern) else None))
            c.addPolygon(path,hxd_clipper_PolyType.Clip)
        return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    @staticmethod
    def MinkowskiDiff(pattern,pol,kind = None):
        c = hxd_clipper_Clipper()
        paths = c.Minkowski(pattern,pol,False)
        c.resultKind = (hxd_clipper_ResultKind.All if ((kind is None)) else kind)
        c.addPolygons(paths,hxd_clipper_PolyType.Subject)
        return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.strictlySimple = None
        _hx_o.reverseSolution = None
        _hx_o.resultKind = None
        _hx_o.m_PolyOuts = None
        _hx_o.m_ClipType = None
        _hx_o.m_Scanbeam = None
        _hx_o.m_ActiveEdges = None
        _hx_o.m_SortedEdges = None
        _hx_o.m_IntersectList = None
        _hx_o.m_ExecuteLocked = None
        _hx_o.m_ClipFillType = None
        _hx_o.m_SubjFillType = None
        _hx_o.m_Joins = None
        _hx_o.m_GhostJoins = None
        _hx_o.m_UsingPolyTree = None
hxd_clipper_Clipper._hx_class = hxd_clipper_Clipper
_hx_classes["hxd.clipper.Clipper"] = hxd_clipper_Clipper


class hxd_clipper_ClipperOffset:
    _hx_class_name = "hxd.clipper.ClipperOffset"
    _hx_is_interface = "False"
    __slots__ = ("m_destPolys", "m_srcPoly", "m_destPoly", "m_normals", "m_delta", "m_sinA", "m_sin", "m_cos", "m_miterLim", "m_StepsPerRad", "m_lowest", "m_polyNodes", "ArcTolerance", "MiterLimit", "resultKind", "def_arc_tolerance", "two_pi")
    _hx_fields = ["m_destPolys", "m_srcPoly", "m_destPoly", "m_normals", "m_delta", "m_sinA", "m_sin", "m_cos", "m_miterLim", "m_StepsPerRad", "m_lowest", "m_polyNodes", "ArcTolerance", "MiterLimit", "resultKind", "def_arc_tolerance", "two_pi"]
    _hx_methods = ["clear", "addPolygon", "addPolygons", "fixOrientations", "getUnitNormal", "doOffset", "execute", "offsetPoint", "doSquare", "doMiter", "doRound"]

    def __init__(self,miterLimit = None,arcTolerance = None):
        if (miterLimit is None):
            miterLimit = 2.0
        if (arcTolerance is None):
            arcTolerance = 0.25
        self.m_StepsPerRad = None
        self.m_miterLim = None
        self.m_cos = None
        self.m_sin = None
        self.m_sinA = None
        self.m_delta = None
        self.m_destPoly = None
        self.m_srcPoly = None
        self.m_destPolys = None
        self.two_pi = 6.28318530717958623
        self.def_arc_tolerance = 0.25
        self.MiterLimit = miterLimit
        self.ArcTolerance = arcTolerance
        self.m_lowest = h2d_col_IPoint(-1,0)
        self.m_normals = []
        self.m_polyNodes = hxd_clipper__Clipper_PolyNode()
        self.resultKind = hxd_clipper_ResultKind.All

    def clear(self):
        self.m_polyNodes = hxd_clipper__Clipper_PolyNode()
        self.m_lowest = h2d_col_IPoint(-1,0)

    def addPolygon(self,pol,joinType,endType):
        highI = (len(pol) - 1)
        if (highI < 0):
            return
        newNode = hxd_clipper__Clipper_PolyNode()
        newNode.jointype = joinType
        newNode.endtype = endType
        if ((endType == hxd_clipper_EndType.ClosedLine) or ((endType == hxd_clipper_EndType.ClosedPol))):
            while ((highI > 0) and (((pol[0] if 0 < len(pol) else None) == (pol[highI] if highI >= 0 and highI < len(pol) else None)))):
                highI = (highI - 1)
        _this = newNode.polygon
        _this.append((pol[0] if 0 < len(pol) else None))
        j = 0
        k = 0
        _g = 1
        _g1 = (highI + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((newNode.polygon[j] if j >= 0 and j < len(newNode.polygon) else None) != (pol[i] if i >= 0 and i < len(pol) else None)):
                j = (j + 1)
                _this = newNode.polygon
                _this.append((pol[i] if i >= 0 and i < len(pol) else None))
                if (((pol[i] if i >= 0 and i < len(pol) else None).y > (newNode.polygon[k] if k >= 0 and k < len(newNode.polygon) else None).y) or ((((pol[i] if i >= 0 and i < len(pol) else None).y == (newNode.polygon[k] if k >= 0 and k < len(newNode.polygon) else None).y) and (((pol[i] if i >= 0 and i < len(pol) else None).x < (newNode.polygon[k] if k >= 0 and k < len(newNode.polygon) else None).x))))):
                    k = j
        if ((endType == hxd_clipper_EndType.ClosedPol) and ((j < 2))):
            return
        self.m_polyNodes.addChild(newNode)
        if (endType != hxd_clipper_EndType.ClosedPol):
            return
        if (self.m_lowest.x < 0):
            self.m_lowest = h2d_col_IPoint((len(self.m_polyNodes.childs) - 1),k)
        else:
            ip = python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(self.m_polyNodes.childs, self.m_lowest.x).polygon, self.m_lowest.y)
            if (((newNode.polygon[k] if k >= 0 and k < len(newNode.polygon) else None).y > ip.y) or ((((newNode.polygon[k] if k >= 0 and k < len(newNode.polygon) else None).y == ip.y) and (((newNode.polygon[k] if k >= 0 and k < len(newNode.polygon) else None).x < ip.x))))):
                self.m_lowest = h2d_col_IPoint((len(self.m_polyNodes.childs) - 1),k)

    def addPolygons(self,pols,joinType,endType):
        _g_i = 0
        _g_a = pols
        _g_l = len(_g_a)
        while (_g_i < _g_l):
            p = _g_i
            _g_i = (_g_i + 1)
            p1 = (_g_a[p] if p >= 0 and p < len(_g_a) else None)
            self.addPolygon(p1,joinType,endType)

    def fixOrientations(self):
        if ((self.m_lowest.x >= 0) and (not ((hxd_clipper_Clipper.polArea(python_internal_ArrayImpl._get(self.m_polyNodes.childs, self.m_lowest.x).polygon) >= 0)))):
            _g = 0
            _g1 = self.m_polyNodes.childs
            while (_g < len(_g1)):
                node = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if ((node.endtype == hxd_clipper_EndType.ClosedPol) or (((node.endtype == hxd_clipper_EndType.ClosedLine) and ((hxd_clipper_Clipper.polArea(node.polygon) >= 0))))):
                    h2d_col__IPolygon_IPolygon_Impl_.reverse(node.polygon)
        else:
            _g = 0
            _g1 = self.m_polyNodes.childs
            while (_g < len(_g1)):
                node = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if ((node.endtype == hxd_clipper_EndType.ClosedLine) and (not ((hxd_clipper_Clipper.polArea(node.polygon) >= 0)))):
                    h2d_col__IPolygon_IPolygon_Impl_.reverse(node.polygon)

    def getUnitNormal(self,pt1,pt2):
        dx = (pt2.x - pt1.x)
        dy = (pt2.y - pt1.y)
        if ((dx == 0) and ((dy == 0))):
            return h2d_col_Point()
        dz = 0.
        if (dz is None):
            dz = 0.
        f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
        f1 = (1 / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        dx = (dx * f1)
        dy = (dy * f1)
        return h2d_col_Point(dy,-dx)

    def doOffset(self,delta):
        polygons = None
        this1 = ([] if ((polygons is None)) else polygons)
        self.m_destPolys = this1
        self.m_delta = delta
        if ((delta > -1e-20) and ((delta < 1E-20))):
            _g = 0
            _g1 = self.m_polyNodes.childs
            while (_g < len(_g1)):
                node = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (node.endtype == hxd_clipper_EndType.ClosedPol):
                    _this = self.m_destPolys
                    x = node.polygon
                    _this.append(x)
            return
        if (self.MiterLimit > 2):
            self.m_miterLim = (2 / ((self.MiterLimit * self.MiterLimit)))
        else:
            self.m_miterLim = 0.5
        y = None
        if (self.ArcTolerance <= 0.0):
            y = self.def_arc_tolerance
        elif (self.ArcTolerance > ((((-delta if ((delta < 0)) else delta)) * self.def_arc_tolerance))):
            y = (((-delta if ((delta < 0)) else delta)) * self.def_arc_tolerance)
        else:
            y = self.ArcTolerance
        x = (3.14159265358979323 / Math.acos((1 - ((y / ((-delta if ((delta < 0)) else delta)))))))
        steps = None
        try:
            steps = int(x)
        except BaseException as _g:
            None
            steps = None
        f = (self.two_pi / steps)
        self.m_sin = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        f = (self.two_pi / steps)
        self.m_cos = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        self.m_StepsPerRad = (steps / self.two_pi)
        if (delta < 0.):
            self.m_sin = -self.m_sin
        _g = 0
        _g1 = self.m_polyNodes.childs
        while (_g < len(_g1)):
            node = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.m_srcPoly = node.polygon
            _hx_len = len(self.m_srcPoly)
            if ((_hx_len == 0) or (((delta <= 0) and (((_hx_len < 3) or ((node.endtype != hxd_clipper_EndType.ClosedPol))))))):
                continue
            points = None
            this1 = ([] if ((points is None)) else points)
            self.m_destPoly = this1
            if (_hx_len == 1):
                if (node.jointype == hxd_clipper_JoinType.Round):
                    X = 1.
                    Y = 0.
                    _g2 = 1
                    _g3 = (steps + 1)
                    while (_g2 < _g3):
                        j = _g2
                        _g2 = (_g2 + 1)
                        _this = self.m_destPoly
                        x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((X * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((Y * delta))) + 0.5)))
                        _this.append(x)
                        X2 = X
                        X = ((X * self.m_cos) - ((self.m_sin * Y)))
                        Y = ((X2 * self.m_sin) + ((Y * self.m_cos)))
                else:
                    X1 = -1.
                    Y1 = -1.
                    _this1 = self.m_destPoly
                    x1 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((X1 * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((Y1 * delta))) + 0.5)))
                    _this1.append(x1)
                    if (X1 < 0):
                        X1 = 1
                    elif (Y1 < 0):
                        Y1 = 1
                    else:
                        X1 = -1
                    _this2 = self.m_destPoly
                    x2 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((X1 * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((Y1 * delta))) + 0.5)))
                    _this2.append(x2)
                    if (X1 < 0):
                        X1 = 1
                    elif (Y1 < 0):
                        Y1 = 1
                    else:
                        X1 = -1
                    _this3 = self.m_destPoly
                    x3 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((X1 * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((Y1 * delta))) + 0.5)))
                    _this3.append(x3)
                    if (X1 < 0):
                        X1 = 1
                    elif (Y1 < 0):
                        Y1 = 1
                    else:
                        X1 = -1
                    _this4 = self.m_destPoly
                    x4 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((X1 * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((Y1 * delta))) + 0.5)))
                    _this4.append(x4)
                    if (X1 < 0):
                        X1 = 1
                    elif (Y1 < 0):
                        Y1 = 1
                    else:
                        X1 = -1
                _this5 = self.m_destPolys
                x5 = self.m_destPoly
                _this5.append(x5)
                continue
            self.m_normals = []
            _g4 = 0
            _g5 = (_hx_len - 1)
            while (_g4 < _g5):
                j1 = _g4
                _g4 = (_g4 + 1)
                _this6 = self.m_normals
                x6 = self.getUnitNormal((self.m_srcPoly[j1] if j1 >= 0 and j1 < len(self.m_srcPoly) else None),python_internal_ArrayImpl._get(self.m_srcPoly, (j1 + 1)))
                _this6.append(x6)
            if ((node.endtype == hxd_clipper_EndType.ClosedLine) or ((node.endtype == hxd_clipper_EndType.ClosedPol))):
                _this7 = self.m_normals
                x7 = self.getUnitNormal(python_internal_ArrayImpl._get(self.m_srcPoly, (_hx_len - 1)),(self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None))
                _this7.append(x7)
            else:
                _this8 = self.m_normals
                x8 = python_internal_ArrayImpl._get(self.m_normals, (_hx_len - 2))
                _this8.append(x8)
            if (node.endtype == hxd_clipper_EndType.ClosedPol):
                k = (_hx_len - 1)
                _g6 = 0
                _g7 = _hx_len
                while (_g6 < _g7):
                    j2 = _g6
                    _g6 = (_g6 + 1)
                    k = self.offsetPoint(j2,k,node.jointype)
                _this9 = self.m_destPolys
                x9 = self.m_destPoly
                _this9.append(x9)
            elif (node.endtype == hxd_clipper_EndType.ClosedLine):
                k1 = (_hx_len - 1)
                _g8 = 0
                _g9 = _hx_len
                while (_g8 < _g9):
                    j3 = _g8
                    _g8 = (_g8 + 1)
                    k1 = self.offsetPoint(j3,k1,node.jointype)
                _this10 = self.m_destPolys
                x10 = self.m_destPoly
                _this10.append(x10)
                points1 = None
                this2 = ([] if ((points1 is None)) else points1)
                self.m_destPoly = this2
                n = python_internal_ArrayImpl._get(self.m_normals, (_hx_len - 1))
                j4 = (_hx_len - 1)
                while (j4 > 0):
                    python_internal_ArrayImpl._set(self.m_normals, j4, h2d_col_Point(-python_internal_ArrayImpl._get(self.m_normals, (j4 - 1)).x,-python_internal_ArrayImpl._get(self.m_normals, (j4 - 1)).y))
                    j4 = (j4 - 1)
                python_internal_ArrayImpl._set(self.m_normals, 0, h2d_col_Point(-n.x,-n.y))
                k1 = 0
                j5 = (_hx_len - 1)
                while (j5 > 0):
                    k1 = self.offsetPoint(j5,k1,node.jointype)
                    j5 = (j5 - 1)
                _this11 = self.m_destPolys
                x11 = self.m_destPoly
                _this11.append(x11)
            else:
                k2 = 0
                _g10 = 1
                _g11 = (_hx_len - 1)
                while (_g10 < _g11):
                    j6 = _g10
                    _g10 = (_g10 + 1)
                    k2 = self.offsetPoint(j6,k2,node.jointype)
                pt1 = None
                if (node.endtype == hxd_clipper_EndType.OpenButt):
                    j7 = (_hx_len - 1)
                    pt1 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j7] if j7 >= 0 and j7 < len(self.m_srcPoly) else None).x + (((self.m_normals[j7] if j7 >= 0 and j7 < len(self.m_normals) else None).x * delta))) + 0.5)),Math.floor((((self.m_srcPoly[j7] if j7 >= 0 and j7 < len(self.m_srcPoly) else None).y + (((self.m_normals[j7] if j7 >= 0 and j7 < len(self.m_normals) else None).y * delta))) + 0.5)))
                    _this12 = self.m_destPoly
                    _this12.append(pt1)
                    pt1 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j7] if j7 >= 0 and j7 < len(self.m_srcPoly) else None).x - (((self.m_normals[j7] if j7 >= 0 and j7 < len(self.m_normals) else None).x * delta))) + 0.5)),Math.floor((((self.m_srcPoly[j7] if j7 >= 0 and j7 < len(self.m_srcPoly) else None).y - (((self.m_normals[j7] if j7 >= 0 and j7 < len(self.m_normals) else None).y * delta))) + 0.5)))
                    _this13 = self.m_destPoly
                    _this13.append(pt1)
                else:
                    j8 = (_hx_len - 1)
                    k2 = (_hx_len - 2)
                    self.m_sinA = 0
                    python_internal_ArrayImpl._set(self.m_normals, j8, h2d_col_Point(-(self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).x,-(self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).y))
                    if (node.endtype == hxd_clipper_EndType.OpenSquare):
                        dx = Math.tan((Math.atan2(self.m_sinA,(((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).x * (self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).x) + (((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).y * (self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).y)))) * 0.25))
                        _this14 = self.m_destPoly
                        x12 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).x - (((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).y + (((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).x * dx))))))) + 0.5)))
                        _this14.append(x12)
                        _this15 = self.m_destPoly
                        x13 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).x + (((self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).y - (((self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).x * dx))))))) + 0.5)))
                        _this15.append(x13)
                    else:
                        a = Math.atan2(self.m_sinA,(((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).x * (self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).x) + (((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).y * (self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).y))))
                        a1 = Math.floor(((self.m_StepsPerRad * ((-a if ((a < 0)) else a))) + 0.5))
                        steps1 = (1 if ((a1 < 1)) else a1)
                        X3 = (self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).x
                        Y2 = (self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).y
                        X21 = None
                        _g12 = 0
                        _g13 = steps1
                        while (_g12 < _g13):
                            i = _g12
                            _g12 = (_g12 + 1)
                            _this16 = self.m_destPoly
                            x14 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).x + ((X3 * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).y + ((Y2 * self.m_delta))) + 0.5)))
                            _this16.append(x14)
                            X21 = X3
                            X3 = ((X3 * self.m_cos) - ((self.m_sin * Y2)))
                            Y2 = ((X21 * self.m_sin) + ((Y2 * self.m_cos)))
                        _this17 = self.m_destPoly
                        x15 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).x + (((self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).y + (((self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
                        _this17.append(x15)
                j9 = (_hx_len - 1)
                while (j9 > 0):
                    python_internal_ArrayImpl._set(self.m_normals, j9, h2d_col_Point(-python_internal_ArrayImpl._get(self.m_normals, (j9 - 1)).x,-python_internal_ArrayImpl._get(self.m_normals, (j9 - 1)).y))
                    j9 = (j9 - 1)
                python_internal_ArrayImpl._set(self.m_normals, 0, h2d_col_Point(-(self.m_normals[1] if 1 < len(self.m_normals) else None).x,-(self.m_normals[1] if 1 < len(self.m_normals) else None).y))
                k2 = (_hx_len - 1)
                j10 = (k2 - 1)
                while (j10 > 0):
                    k2 = self.offsetPoint(j10,k2,node.jointype)
                    j10 = (j10 - 1)
                if (node.endtype == hxd_clipper_EndType.OpenButt):
                    pt1 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x - (((self.m_normals[0] if 0 < len(self.m_normals) else None).x * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y - (((self.m_normals[0] if 0 < len(self.m_normals) else None).y * delta))) + 0.5)))
                    _this18 = self.m_destPoly
                    _this18.append(pt1)
                    pt1 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + (((self.m_normals[0] if 0 < len(self.m_normals) else None).x * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + (((self.m_normals[0] if 0 < len(self.m_normals) else None).y * delta))) + 0.5)))
                    _this19 = self.m_destPoly
                    _this19.append(pt1)
                else:
                    k2 = 1
                    self.m_sinA = 0
                    if (node.endtype == hxd_clipper_EndType.OpenSquare):
                        dx1 = Math.tan((Math.atan2(self.m_sinA,(((self.m_normals[1] if 1 < len(self.m_normals) else None).x * (self.m_normals[0] if 0 < len(self.m_normals) else None).x) + (((self.m_normals[1] if 1 < len(self.m_normals) else None).y * (self.m_normals[0] if 0 < len(self.m_normals) else None).y)))) * 0.25))
                        _this20 = self.m_destPoly
                        x16 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[1] if 1 < len(self.m_normals) else None).x - (((self.m_normals[1] if 1 < len(self.m_normals) else None).y * dx1))))))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[1] if 1 < len(self.m_normals) else None).y + (((self.m_normals[1] if 1 < len(self.m_normals) else None).x * dx1))))))) + 0.5)))
                        _this20.append(x16)
                        _this21 = self.m_destPoly
                        x17 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[0] if 0 < len(self.m_normals) else None).x + (((self.m_normals[0] if 0 < len(self.m_normals) else None).y * dx1))))))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[0] if 0 < len(self.m_normals) else None).y - (((self.m_normals[0] if 0 < len(self.m_normals) else None).x * dx1))))))) + 0.5)))
                        _this21.append(x17)
                    else:
                        a2 = Math.atan2(self.m_sinA,(((self.m_normals[1] if 1 < len(self.m_normals) else None).x * (self.m_normals[0] if 0 < len(self.m_normals) else None).x) + (((self.m_normals[1] if 1 < len(self.m_normals) else None).y * (self.m_normals[0] if 0 < len(self.m_normals) else None).y))))
                        a3 = Math.floor(((self.m_StepsPerRad * ((-a2 if ((a2 < 0)) else a2))) + 0.5))
                        steps2 = (1 if ((a3 < 1)) else a3)
                        X4 = (self.m_normals[1] if 1 < len(self.m_normals) else None).x
                        Y3 = (self.m_normals[1] if 1 < len(self.m_normals) else None).y
                        X22 = None
                        _g14 = 0
                        _g15 = steps2
                        while (_g14 < _g15):
                            i1 = _g14
                            _g14 = (_g14 + 1)
                            _this22 = self.m_destPoly
                            x18 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((X4 * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((Y3 * self.m_delta))) + 0.5)))
                            _this22.append(x18)
                            X22 = X4
                            X4 = ((X4 * self.m_cos) - ((self.m_sin * Y3)))
                            Y3 = ((X22 * self.m_sin) + ((Y3 * self.m_cos)))
                        _this23 = self.m_destPoly
                        x19 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + (((self.m_normals[0] if 0 < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + (((self.m_normals[0] if 0 < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
                        _this23.append(x19)
                _this24 = self.m_destPolys
                x20 = self.m_destPoly
                _this24.append(x20)

    def execute(self,delta):
        self.fixOrientations()
        self.doOffset(delta)
        clpr = hxd_clipper_Clipper()
        clpr.resultKind = self.resultKind
        clpr.addPolygons(self.m_destPolys,hxd_clipper_PolyType.Subject)
        if (delta > 0):
            return clpr.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.Positive,hxd_clipper_PolyFillType.Positive)
        else:
            r = hxd_clipper__Clipper_ClipperBase.getBounds(self.m_destPolys)
            points = None
            this1 = ([] if ((points is None)) else points)
            outer = this1
            x = h2d_col_IPoint((r.left - 10),(r.bottom + 10))
            outer.append(x)
            x = h2d_col_IPoint((r.right + 10),(r.bottom + 10))
            outer.append(x)
            x = h2d_col_IPoint((r.right + 10),(r.top - 10))
            outer.append(x)
            x = h2d_col_IPoint((r.left - 10),(r.top - 10))
            outer.append(x)
            clpr.addPolygon(outer,hxd_clipper_PolyType.Subject)
            clpr.reverseSolution = True
            out = clpr.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.Negative,hxd_clipper_PolyFillType.Negative)
            if (len(out) > 0):
                if (len(out) != 0):
                    out.pop(0)
            return out

    def offsetPoint(self,j,k,jointype):
        self.m_sinA = (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y) - (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y)))
        f = (self.m_sinA * self.m_delta)
        if (((-f if ((f < 0)) else f)) < 1.0):
            cosA = (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x) + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y)))
            if (cosA > 0):
                _this = self.m_destPoly
                x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
                _this.append(x)
                return k
        elif (self.m_sinA > 1.0):
            self.m_sinA = 1.0
        elif (self.m_sinA < -1.0):
            self.m_sinA = -1.0
        if ((self.m_sinA * self.m_delta) < 0):
            p1 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
            p2 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
            _this = self.m_destPoly
            _this.append(p1)
            dx = (p1.x - p2.x)
            dy = (p1.y - p2.y)
            if (((dx * dx) + ((dy * dy))) > 1):
                _this = self.m_destPoly
                x = (self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None)
                _this.append(x)
                _this = self.m_destPoly
                _this.append(p2)
        else:
            tmp = jointype.index
            if (tmp == 0):
                dx = Math.tan((Math.atan2(self.m_sinA,(((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x) + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y)))) * 0.25))
                _this = self.m_destPoly
                x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x - (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * dx))))))) + 0.5)))
                _this.append(x)
                _this = self.m_destPoly
                x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y - (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * dx))))))) + 0.5)))
                _this.append(x)
            elif (tmp == 1):
                a = Math.atan2(self.m_sinA,(((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x) + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y))))
                a1 = Math.floor(((self.m_StepsPerRad * ((-a if ((a < 0)) else a))) + 0.5))
                steps = (1 if ((a1 < 1)) else a1)
                X = (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x
                Y = (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y
                X2 = None
                _g = 0
                _g1 = steps
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    _this = self.m_destPoly
                    x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((X * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((Y * self.m_delta))) + 0.5)))
                    _this.append(x)
                    X2 = X
                    X = ((X * self.m_cos) - ((self.m_sin * Y)))
                    Y = ((X2 * self.m_sin) + ((Y * self.m_cos)))
                _this = self.m_destPoly
                x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
                _this.append(x)
            elif (tmp == 2):
                r = (1 + ((((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x) + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y)))))
                if (r >= self.m_miterLim):
                    q = (self.m_delta / r)
                    _this = self.m_destPoly
                    x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x + (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x)) * q))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y + (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y)) * q))) + 0.5)))
                    _this.append(x)
                else:
                    dx = Math.tan((Math.atan2(self.m_sinA,(((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x) + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y)))) * 0.25))
                    _this = self.m_destPoly
                    x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x - (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * dx))))))) + 0.5)))
                    _this.append(x)
                    _this = self.m_destPoly
                    x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y - (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * dx))))))) + 0.5)))
                    _this.append(x)
            else:
                pass
        return j

    def doSquare(self,j,k):
        dx = Math.tan((Math.atan2(self.m_sinA,(((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x) + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y)))) * 0.25))
        _this = self.m_destPoly
        x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x - (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * dx))))))) + 0.5)))
        _this.append(x)
        _this = self.m_destPoly
        x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y - (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * dx))))))) + 0.5)))
        _this.append(x)

    def doMiter(self,j,k,r):
        q = (self.m_delta / r)
        _this = self.m_destPoly
        x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x + (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x)) * q))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y + (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y)) * q))) + 0.5)))
        _this.append(x)

    def doRound(self,j,k):
        a = Math.atan2(self.m_sinA,(((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x) + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y))))
        a1 = Math.floor(((self.m_StepsPerRad * ((-a if ((a < 0)) else a))) + 0.5))
        steps = (1 if ((a1 < 1)) else a1)
        X = (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x
        Y = (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y
        X2 = None
        _g = 0
        _g1 = steps
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this = self.m_destPoly
            x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((X * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((Y * self.m_delta))) + 0.5)))
            _this.append(x)
            X2 = X
            X = ((X * self.m_cos) - ((self.m_sin * Y)))
            Y = ((X2 * self.m_sin) + ((Y * self.m_cos)))
        _this = self.m_destPoly
        x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
        _this.append(x)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.m_destPolys = None
        _hx_o.m_srcPoly = None
        _hx_o.m_destPoly = None
        _hx_o.m_normals = None
        _hx_o.m_delta = None
        _hx_o.m_sinA = None
        _hx_o.m_sin = None
        _hx_o.m_cos = None
        _hx_o.m_miterLim = None
        _hx_o.m_StepsPerRad = None
        _hx_o.m_lowest = None
        _hx_o.m_polyNodes = None
        _hx_o.ArcTolerance = None
        _hx_o.MiterLimit = None
        _hx_o.resultKind = None
        _hx_o.def_arc_tolerance = None
        _hx_o.two_pi = None
hxd_clipper_ClipperOffset._hx_class = hxd_clipper_ClipperOffset
_hx_classes["hxd.clipper.ClipperOffset"] = hxd_clipper_ClipperOffset

class hxd_clipper_EndType(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.EndType"
    _hx_constructs = ["ClosedPol", "ClosedLine", "OpenButt", "OpenSquare", "OpenRound"]
hxd_clipper_EndType.ClosedPol = hxd_clipper_EndType("ClosedPol", 0, ())
hxd_clipper_EndType.ClosedLine = hxd_clipper_EndType("ClosedLine", 1, ())
hxd_clipper_EndType.OpenButt = hxd_clipper_EndType("OpenButt", 2, ())
hxd_clipper_EndType.OpenSquare = hxd_clipper_EndType("OpenSquare", 3, ())
hxd_clipper_EndType.OpenRound = hxd_clipper_EndType("OpenRound", 4, ())
hxd_clipper_EndType._hx_class = hxd_clipper_EndType
_hx_classes["hxd.clipper.EndType"] = hxd_clipper_EndType

class hxd_clipper_JoinType(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.JoinType"
    _hx_constructs = ["Square", "Round", "Miter"]
hxd_clipper_JoinType.Square = hxd_clipper_JoinType("Square", 0, ())
hxd_clipper_JoinType.Round = hxd_clipper_JoinType("Round", 1, ())
hxd_clipper_JoinType.Miter = hxd_clipper_JoinType("Miter", 2, ())
hxd_clipper_JoinType._hx_class = hxd_clipper_JoinType
_hx_classes["hxd.clipper.JoinType"] = hxd_clipper_JoinType

class hxd_clipper_PolyFillType(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.PolyFillType"
    _hx_constructs = ["EvenOdd", "NonZero", "Positive", "Negative"]
hxd_clipper_PolyFillType.EvenOdd = hxd_clipper_PolyFillType("EvenOdd", 0, ())
hxd_clipper_PolyFillType.NonZero = hxd_clipper_PolyFillType("NonZero", 1, ())
hxd_clipper_PolyFillType.Positive = hxd_clipper_PolyFillType("Positive", 2, ())
hxd_clipper_PolyFillType.Negative = hxd_clipper_PolyFillType("Negative", 3, ())
hxd_clipper_PolyFillType._hx_class = hxd_clipper_PolyFillType
_hx_classes["hxd.clipper.PolyFillType"] = hxd_clipper_PolyFillType

class hxd_clipper_PolyType(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.PolyType"
    _hx_constructs = ["Subject", "Clip"]
hxd_clipper_PolyType.Subject = hxd_clipper_PolyType("Subject", 0, ())
hxd_clipper_PolyType.Clip = hxd_clipper_PolyType("Clip", 1, ())
hxd_clipper_PolyType._hx_class = hxd_clipper_PolyType
_hx_classes["hxd.clipper.PolyType"] = hxd_clipper_PolyType


class hxd_clipper_Rect:
    _hx_class_name = "hxd.clipper.Rect"
    _hx_is_interface = "False"
    __slots__ = ("left", "top", "right", "bottom")
    _hx_fields = ["left", "top", "right", "bottom"]

    def __init__(self,l = None,t = None,r = None,b = None):
        if (l is None):
            l = 0
        if (t is None):
            t = 0
        if (r is None):
            r = 0
        if (b is None):
            b = 0
        self.left = l
        self.top = t
        self.right = r
        self.bottom = b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.left = None
        _hx_o.top = None
        _hx_o.right = None
        _hx_o.bottom = None
hxd_clipper_Rect._hx_class = hxd_clipper_Rect
_hx_classes["hxd.clipper.Rect"] = hxd_clipper_Rect


class hxd_earcut_EarNode:
    _hx_class_name = "hxd.earcut.EarNode"
    _hx_is_interface = "False"
    __slots__ = ("next", "prev", "nextZ", "prevZ", "allocNext", "x", "y", "i", "z", "steiner")
    _hx_fields = ["next", "prev", "nextZ", "prevZ", "allocNext", "x", "y", "i", "z", "steiner"]

    def __init__(self):
        self.steiner = None
        self.z = None
        self.i = None
        self.y = None
        self.x = None
        self.allocNext = None
        self.prevZ = None
        self.nextZ = None
        self.prev = None
        self.next = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.prev = None
        _hx_o.nextZ = None
        _hx_o.prevZ = None
        _hx_o.allocNext = None
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.i = None
        _hx_o.z = None
        _hx_o.steiner = None
hxd_earcut_EarNode._hx_class = hxd_earcut_EarNode
_hx_classes["hxd.earcut.EarNode"] = hxd_earcut_EarNode


class hxd_earcut_Earcut:
    _hx_class_name = "hxd.earcut.Earcut"
    _hx_is_interface = "False"
    __slots__ = ("triangles", "cache", "allocated", "minX", "minY", "size", "hasSize")
    _hx_fields = ["triangles", "cache", "allocated", "minX", "minY", "size", "hasSize"]
    _hx_methods = ["triangulate_h2d_col_Point", "eliminateHoles_triangulate_T", "setLinkedList_eliminateHoles_T", "setLinkedList_triangulate_T", "triangulateNode", "eliminateHole", "findHoleBridge", "getLeftmost", "compareX", "equals", "area", "intersects", "locallyInside", "filterPoints", "removeNode", "allocNode", "earcutLinked", "isEar", "isEarHashed", "cureLocalIntersections", "splitEarcut", "splitPolygon", "pointInTriangle", "isValidDiagonal", "middleInside", "intersectsPolygon", "zOrder", "indexCurve", "sortLinked"]

    def __init__(self):
        self.hasSize = None
        self.size = None
        self.minY = None
        self.minX = None
        self.allocated = None
        self.cache = None
        self.triangles = None

    def triangulate_h2d_col_Point(self,points,holes = None):
        hasHoles = ((holes is not None) and ((len(holes) > 0)))
        outerLen = ((holes[0] if 0 < len(holes) else None) if hasHoles else len(points))
        if (outerLen < 3):
            return []
        root = self.setLinkedList_triangulate_T(points,0,outerLen,True)
        if (holes is not None):
            root = self.eliminateHoles_triangulate_T(points,holes,root)
        return self.triangulateNode(root,(len(points) > 80))

    def eliminateHoles_triangulate_T(self,points,holes,root):
        queue = []
        _g = 0
        _g1 = len(holes)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            s = (holes[i] if i >= 0 and i < len(holes) else None)
            e = (len(points) if ((i == ((len(holes) - 1)))) else python_internal_ArrayImpl._get(holes, (i + 1)))
            node = self.setLinkedList_eliminateHoles_T(points,s,e,False)
            if (node == node.next):
                node.steiner = True
            x = self.getLeftmost(node)
            queue.append(x)
        queue.sort(key= python_lib_Functools.cmp_to_key(self.compareX))
        _g = 0
        while (_g < len(queue)):
            q = (queue[_g] if _g >= 0 and _g < len(queue) else None)
            _g = (_g + 1)
            self.eliminateHole(q,root)
            root = self.filterPoints(root,root.next)
        return root

    def setLinkedList_eliminateHoles_T(self,points,start,end,clockwise):
        sum = 0.
        j = (end - 1)
        _g = start
        _g1 = end
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            sum = (sum + (((((points[j] if j >= 0 and j < len(points) else None).x - (points[i] if i >= 0 and i < len(points) else None).x)) * (((points[i] if i >= 0 and i < len(points) else None).y + (points[j] if j >= 0 and j < len(points) else None).y)))))
            j = i
        last = None
        n = self.cache
        if (n is None):
            n = hxd_earcut_EarNode()
            n.allocNext = self.allocated
            self.allocated = n
        else:
            self.cache = n.next
        n.i = -1
        n.z = -1
        n.x = 0
        n.y = 0
        n.next = None
        n.prev = last
        n.steiner = False
        n.prevZ = None
        n.nextZ = None
        if (last is not None):
            last.next = n
        node = n
        first = node
        if (clockwise == ((sum > 0))):
            _g = start
            _g1 = end
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p = (points[i] if i >= 0 and i < len(points) else None)
                x = p.x
                y = p.y
                n = self.cache
                if (n is None):
                    n = hxd_earcut_EarNode()
                    n.allocNext = self.allocated
                    self.allocated = n
                else:
                    self.cache = n.next
                n.i = i
                n.z = -1
                n.x = x
                n.y = y
                n.next = None
                n.prev = node
                n.steiner = False
                n.prevZ = None
                n.nextZ = None
                if (node is not None):
                    node.next = n
                node = n
        else:
            i = (end - 1)
            while (i >= start):
                p = (points[i] if i >= 0 and i < len(points) else None)
                x = p.x
                y = p.y
                n = self.cache
                if (n is None):
                    n = hxd_earcut_EarNode()
                    n.allocNext = self.allocated
                    self.allocated = n
                else:
                    self.cache = n.next
                n.i = i
                n.z = -1
                n.x = x
                n.y = y
                n.next = None
                n.prev = node
                n.steiner = False
                n.prevZ = None
                n.nextZ = None
                if (node is not None):
                    node.next = n
                node = n
                i = (i - 1)
        node.next = first.next
        node.next.prev = node
        return node

    def setLinkedList_triangulate_T(self,points,start,end,clockwise):
        sum = 0.
        j = (end - 1)
        _g = start
        _g1 = end
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            sum = (sum + (((((points[j] if j >= 0 and j < len(points) else None).x - (points[i] if i >= 0 and i < len(points) else None).x)) * (((points[i] if i >= 0 and i < len(points) else None).y + (points[j] if j >= 0 and j < len(points) else None).y)))))
            j = i
        last = None
        n = self.cache
        if (n is None):
            n = hxd_earcut_EarNode()
            n.allocNext = self.allocated
            self.allocated = n
        else:
            self.cache = n.next
        n.i = -1
        n.z = -1
        n.x = 0
        n.y = 0
        n.next = None
        n.prev = last
        n.steiner = False
        n.prevZ = None
        n.nextZ = None
        if (last is not None):
            last.next = n
        node = n
        first = node
        if (clockwise == ((sum > 0))):
            _g = start
            _g1 = end
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p = (points[i] if i >= 0 and i < len(points) else None)
                x = p.x
                y = p.y
                n = self.cache
                if (n is None):
                    n = hxd_earcut_EarNode()
                    n.allocNext = self.allocated
                    self.allocated = n
                else:
                    self.cache = n.next
                n.i = i
                n.z = -1
                n.x = x
                n.y = y
                n.next = None
                n.prev = node
                n.steiner = False
                n.prevZ = None
                n.nextZ = None
                if (node is not None):
                    node.next = n
                node = n
        else:
            i = (end - 1)
            while (i >= start):
                p = (points[i] if i >= 0 and i < len(points) else None)
                x = p.x
                y = p.y
                n = self.cache
                if (n is None):
                    n = hxd_earcut_EarNode()
                    n.allocNext = self.allocated
                    self.allocated = n
                else:
                    self.cache = n.next
                n.i = i
                n.z = -1
                n.x = x
                n.y = y
                n.next = None
                n.prev = node
                n.steiner = False
                n.prevZ = None
                n.nextZ = None
                if (node is not None):
                    node.next = n
                node = n
                i = (i - 1)
        node.next = first.next
        node.next.prev = node
        return node

    def triangulateNode(self,root,useZOrder):
        self.triangles = []
        root = self.filterPoints(root)
        if (useZOrder and ((root is not None))):
            maxX = root.x
            self.minX = maxX
            maxY = root.y
            self.minY = maxY
            p = root.next
            while (p != root):
                x = p.x
                y = p.y
                if (x < self.minX):
                    self.minX = x
                if (y < self.minY):
                    self.minY = y
                if (x > maxX):
                    maxX = x
                if (y > maxY):
                    maxY = y
                p = p.next
            a = (maxX - self.minX)
            b = (maxY - self.minY)
            self.size = (b if ((a < b)) else a)
            self.hasSize = True
        else:
            self.hasSize = False
        self.earcutLinked(root)
        result = self.triangles
        self.triangles = None
        n = self.allocated
        if (self.cache is not None):
            while (n != self.cache):
                n = n.allocNext
            n = n.allocNext
        while (n is not None):
            n.next = self.cache
            self.cache = n
            n = n.allocNext
        return result

    def eliminateHole(self,hole,root):
        root = self.findHoleBridge(hole,root)
        if (root is not None):
            b = self.splitPolygon(root,hole)
            self.filterPoints(b,b.next)

    def findHoleBridge(self,hole,root):
        p = root
        hx = hole.x
        hy = hole.y
        qx = Math.NEGATIVE_INFINITY
        m = None
        while True:
            if ((hy <= p.y) and ((hy >= p.next.y))):
                x = (p.x + (((((hy - p.y)) * ((p.next.x - p.x))) / ((p.next.y - p.y)))))
                if ((x <= hx) and ((x > qx))):
                    qx = x
                    m = (p if ((p.x < p.next.x)) else p.next)
            p = p.next
            if (not ((p != root))):
                break
        if (m is None):
            return None
        stop = m
        tanMin = Math.POSITIVE_INFINITY
        tan = None
        p = m.next
        while (p != stop):
            tmp = None
            if ((hx >= p.x) and ((p.x >= m.x))):
                ax = (hx if ((hy < m.y)) else qx)
                bx = m.x
                by = m.y
                cx = (qx if ((hy < m.y)) else hx)
                px = p.x
                py = p.y
                tmp = (((((((cx - px)) * ((hy - py))) - ((((ax - px)) * ((hy - py))))) >= 0) and ((((((ax - px)) * ((by - py))) - ((((bx - px)) * ((hy - py))))) >= 0))) and ((((((bx - px)) * ((hy - py))) - ((((cx - px)) * ((by - py))))) >= 0)))
            else:
                tmp = False
            if tmp:
                f = (hy - p.y)
                tan = (((-f if ((f < 0)) else f)) / ((hx - p.x)))
                tmp1 = None
                if ((tan < tanMin) or (((tan == tanMin) and ((p.x > m.x))))):
                    p1 = p.prev
                    r = p.next
                    if (((((p.y - p1.y)) * ((r.x - p.x))) - ((((p.x - p1.x)) * ((r.y - p.y))))) < 0):
                        r1 = p.next
                        if (((((hole.y - p.y)) * ((r1.x - hole.x))) - ((((hole.x - p.x)) * ((r1.y - hole.y))))) >= 0):
                            q = p.prev
                            tmp1 = (((((q.y - p.y)) * ((hole.x - q.x))) - ((((q.x - p.x)) * ((hole.y - q.y))))) >= 0)
                        else:
                            tmp1 = False
                    else:
                        r2 = p.prev
                        if (not ((((((hole.y - p.y)) * ((r2.x - hole.x))) - ((((hole.x - p.x)) * ((r2.y - hole.y))))) < 0))):
                            q1 = p.next
                            tmp1 = (((((q1.y - p.y)) * ((hole.x - q1.x))) - ((((q1.x - p.x)) * ((hole.y - q1.y))))) < 0)
                        else:
                            tmp1 = True
                else:
                    tmp1 = False
                if tmp1:
                    m = p
                    tanMin = tan
            p = p.next
        return m

    def getLeftmost(self,node):
        p = node
        leftmost = node
        while True:
            if (p.x < leftmost.x):
                leftmost = p
            p = p.next
            if (not ((p != node))):
                break
        return leftmost

    def compareX(self,a,b):
        if ((a.x - b.x) > 0):
            return 1
        else:
            return -1

    def equals(self,p1,p2):
        if (p1.x == p2.x):
            return (p1.y == p2.y)
        else:
            return False

    def area(self,p,q,r):
        return ((((q.y - p.y)) * ((r.x - q.x))) - ((((q.x - p.x)) * ((r.y - q.y)))))

    def intersects(self,p1,q1,p2,q2):
        if ((((((q1.y - p1.y)) * ((p2.x - q1.x))) - ((((q1.x - p1.x)) * ((p2.y - q1.y))))) > 0) != ((((((q1.y - p1.y)) * ((q2.x - q1.x))) - ((((q1.x - p1.x)) * ((q2.y - q1.y))))) > 0))):
            return ((((((q2.y - p2.y)) * ((p1.x - q2.x))) - ((((q2.x - p2.x)) * ((p1.y - q2.y))))) > 0) != ((((((q2.y - p2.y)) * ((q1.x - q2.x))) - ((((q2.x - p2.x)) * ((q1.y - q2.y))))) > 0)))
        else:
            return False

    def locallyInside(self,a,b):
        p = a.prev
        r = a.next
        if (((((a.y - p.y)) * ((r.x - a.x))) - ((((a.x - p.x)) * ((r.y - a.y))))) < 0):
            r = a.next
            if (((((b.y - a.y)) * ((r.x - b.x))) - ((((b.x - a.x)) * ((r.y - b.y))))) >= 0):
                q = a.prev
                return (((((q.y - a.y)) * ((b.x - q.x))) - ((((q.x - a.x)) * ((b.y - q.y))))) >= 0)
            else:
                return False
        else:
            r = a.prev
            if (not ((((((b.y - a.y)) * ((r.x - b.x))) - ((((b.x - a.x)) * ((r.y - b.y))))) < 0))):
                q = a.next
                return (((((q.y - a.y)) * ((b.x - q.x))) - ((((q.x - a.x)) * ((b.y - q.y))))) < 0)
            else:
                return True

    def filterPoints(self,start,end = None):
        if (start is None):
            return start
        if (end is None):
            end = start
        p = start
        again = None
        while True:
            again = False
            tmp = None
            if (not p.steiner):
                p2 = p.next
                if (not (((p.x == p2.x) and ((p.y == p2.y))))):
                    p1 = p.prev
                    r = p.next
                    tmp = (((((p.y - p1.y)) * ((r.x - p.x))) - ((((p.x - p1.x)) * ((r.y - p.y))))) == 0)
                else:
                    tmp = True
            else:
                tmp = False
            if tmp:
                p.next.prev = p.prev
                p.prev.next = p.next
                if (p.prevZ is not None):
                    p.prevZ.nextZ = p.nextZ
                if (p.nextZ is not None):
                    p.nextZ.prevZ = p.prevZ
                end = p.prev
                p = end
                if (p == p.next):
                    return None
                again = True
            else:
                p = p.next
            if (not ((again or ((p != end))))):
                break
        return end

    def removeNode(self,p):
        p.next.prev = p.prev
        p.prev.next = p.next
        if (p.prevZ is not None):
            p.prevZ.nextZ = p.nextZ
        if (p.nextZ is not None):
            p.nextZ.prevZ = p.prevZ

    def allocNode(self,i,x,y,last = None):
        n = self.cache
        if (n is None):
            n = hxd_earcut_EarNode()
            n.allocNext = self.allocated
            self.allocated = n
        else:
            self.cache = n.next
        n.i = i
        n.z = -1
        n.x = x
        n.y = y
        n.next = None
        n.prev = last
        n.steiner = False
        n.prevZ = None
        n.nextZ = None
        if (last is not None):
            last.next = n
        return n

    def earcutLinked(self,ear,_hx_pass = None):
        if (_hx_pass is None):
            _hx_pass = 0
        if (ear is None):
            return
        if ((_hx_pass == 0) and self.hasSize):
            self.indexCurve(ear)
        stop = ear
        prev = None
        next = None
        while (ear.prev != ear.next):
            prev = ear.prev
            next = ear.next
            if (self.isEarHashed(ear) if (self.hasSize) else self.isEar(ear)):
                _this = self.triangles
                x = prev.i
                _this.append(x)
                _this1 = self.triangles
                x1 = ear.i
                _this1.append(x1)
                _this2 = self.triangles
                x2 = next.i
                _this2.append(x2)
                ear.next.prev = ear.prev
                ear.prev.next = ear.next
                if (ear.prevZ is not None):
                    ear.prevZ.nextZ = ear.nextZ
                if (ear.nextZ is not None):
                    ear.nextZ.prevZ = ear.prevZ
                ear = next.next
                stop = next.next
                continue
            ear = next
            if (ear == stop):
                pass1 = _hx_pass
                if (pass1 == 0):
                    self.earcutLinked(self.filterPoints(ear),1)
                elif (pass1 == 1):
                    ear = self.cureLocalIntersections(ear)
                    self.earcutLinked(ear,2)
                elif (pass1 == 2):
                    self.splitEarcut(ear)
                else:
                    pass
                break

    def isEar(self,ear):
        a = ear.prev
        b = ear
        c = ear.next
        if (((((b.y - a.y)) * ((c.x - b.x))) - ((((b.x - a.x)) * ((c.y - b.y))))) >= 0):
            return False
        p = ear.next.next
        while (p != ear.prev):
            tmp = None
            ax = a.x
            ay = a.y
            bx = b.x
            by = b.y
            cx = c.x
            cy = c.y
            px = p.x
            py = p.y
            if (((((((cx - px)) * ((ay - py))) - ((((ax - px)) * ((cy - py))))) >= 0) and ((((((ax - px)) * ((by - py))) - ((((bx - px)) * ((ay - py))))) >= 0))) and ((((((bx - px)) * ((cy - py))) - ((((cx - px)) * ((by - py))))) >= 0))):
                p1 = p.prev
                r = p.next
                tmp = (((((p.y - p1.y)) * ((r.x - p.x))) - ((((p.x - p1.x)) * ((r.y - p.y))))) >= 0)
            else:
                tmp = False
            if tmp:
                return False
            p = p.next
        return True

    def isEarHashed(self,ear):
        a = ear.prev
        b = ear
        c = ear.next
        if (((((b.y - a.y)) * ((c.x - b.x))) - ((((b.x - a.x)) * ((c.y - b.y))))) >= 0):
            return False
        minTX = ((a.x if ((a.x < c.x)) else c.x) if ((a.x < b.x)) else (b.x if ((b.x < c.x)) else c.x))
        minTY = ((a.y if ((a.y < c.y)) else c.y) if ((a.y < b.y)) else (b.y if ((b.y < c.y)) else c.y))
        maxTX = ((a.x if ((a.x > c.x)) else c.x) if ((a.x > b.x)) else (b.x if ((b.x > c.x)) else c.x))
        maxTY = ((a.y if ((a.y > c.y)) else c.y) if ((a.y > b.y)) else (b.y if ((b.y > c.y)) else c.y))
        x = ((32767 * ((minTX - self.minX))) / self.size)
        x1 = None
        try:
            x1 = int(x)
        except BaseException as _g:
            None
            x1 = None
        x = ((32767 * ((minTY - self.minY))) / self.size)
        y = None
        try:
            y = int(x)
        except BaseException as _g:
            None
            y = None
        x1 = (((x1 | ((x1 << 8)))) & 16711935)
        x1 = (((x1 | ((x1 << 4)))) & 252645135)
        x1 = (((x1 | ((x1 << 2)))) & 858993459)
        x1 = (((x1 | ((x1 << 1)))) & 1431655765)
        y = (((y | ((y << 8)))) & 16711935)
        y = (((y | ((y << 4)))) & 252645135)
        y = (((y | ((y << 2)))) & 858993459)
        y = (((y | ((y << 1)))) & 1431655765)
        minZ = (x1 | ((y << 1)))
        x = ((32767 * ((maxTX - self.minX))) / self.size)
        x1 = None
        try:
            x1 = int(x)
        except BaseException as _g:
            None
            x1 = None
        x = ((32767 * ((maxTY - self.minY))) / self.size)
        y = None
        try:
            y = int(x)
        except BaseException as _g:
            None
            y = None
        x1 = (((x1 | ((x1 << 8)))) & 16711935)
        x1 = (((x1 | ((x1 << 4)))) & 252645135)
        x1 = (((x1 | ((x1 << 2)))) & 858993459)
        x1 = (((x1 | ((x1 << 1)))) & 1431655765)
        y = (((y | ((y << 8)))) & 16711935)
        y = (((y | ((y << 4)))) & 252645135)
        y = (((y | ((y << 2)))) & 858993459)
        y = (((y | ((y << 1)))) & 1431655765)
        maxZ = (x1 | ((y << 1)))
        p = ear.nextZ
        while ((p is not None) and ((p.z <= maxZ))):
            tmp = None
            tmp1 = None
            if ((p != ear.prev) and ((p != ear.next))):
                ax = a.x
                ay = a.y
                bx = b.x
                by = b.y
                cx = c.x
                cy = c.y
                px = p.x
                py = p.y
                tmp1 = (((((((cx - px)) * ((ay - py))) - ((((ax - px)) * ((cy - py))))) >= 0) and ((((((ax - px)) * ((by - py))) - ((((bx - px)) * ((ay - py))))) >= 0))) and ((((((bx - px)) * ((cy - py))) - ((((cx - px)) * ((by - py))))) >= 0)))
            else:
                tmp1 = False
            if tmp1:
                p1 = p.prev
                r = p.next
                tmp = (((((p.y - p1.y)) * ((r.x - p.x))) - ((((p.x - p1.x)) * ((r.y - p.y))))) >= 0)
            else:
                tmp = False
            if tmp:
                return False
            p = p.nextZ
        p = ear.prevZ
        while ((p is not None) and ((p.z >= minZ))):
            tmp = None
            tmp1 = None
            if ((p != ear.prev) and ((p != ear.next))):
                ax = a.x
                ay = a.y
                bx = b.x
                by = b.y
                cx = c.x
                cy = c.y
                px = p.x
                py = p.y
                tmp1 = (((((((cx - px)) * ((ay - py))) - ((((ax - px)) * ((cy - py))))) >= 0) and ((((((ax - px)) * ((by - py))) - ((((bx - px)) * ((ay - py))))) >= 0))) and ((((((bx - px)) * ((cy - py))) - ((((cx - px)) * ((by - py))))) >= 0)))
            else:
                tmp1 = False
            if tmp1:
                p1 = p.prev
                r = p.next
                tmp = (((((p.y - p1.y)) * ((r.x - p.x))) - ((((p.x - p1.x)) * ((r.y - p.y))))) >= 0)
            else:
                tmp = False
            if tmp:
                return False
            p = p.prevZ
        return True

    def cureLocalIntersections(self,start):
        p = start
        while True:
            a = p.prev
            b = p.next.next
            tmp = None
            tmp1 = None
            p2 = p.next
            if (((((((p.y - a.y)) * ((p2.x - p.x))) - ((((p.x - a.x)) * ((p2.y - p.y))))) > 0) != ((((((p.y - a.y)) * ((b.x - p.x))) - ((((p.x - a.x)) * ((b.y - p.y))))) > 0))) and (((((((b.y - p2.y)) * ((a.x - b.x))) - ((((b.x - p2.x)) * ((a.y - b.y))))) > 0) != ((((((b.y - p2.y)) * ((p.x - b.x))) - ((((b.x - p2.x)) * ((p.y - b.y))))) > 0))))):
                p1 = a.prev
                r = a.next
                if (((((a.y - p1.y)) * ((r.x - a.x))) - ((((a.x - p1.x)) * ((r.y - a.y))))) < 0):
                    r1 = a.next
                    if (((((b.y - a.y)) * ((r1.x - b.x))) - ((((b.x - a.x)) * ((r1.y - b.y))))) >= 0):
                        q = a.prev
                        tmp1 = (((((q.y - a.y)) * ((b.x - q.x))) - ((((q.x - a.x)) * ((b.y - q.y))))) >= 0)
                    else:
                        tmp1 = False
                else:
                    r2 = a.prev
                    if (not ((((((b.y - a.y)) * ((r2.x - b.x))) - ((((b.x - a.x)) * ((r2.y - b.y))))) < 0))):
                        q1 = a.next
                        tmp1 = (((((q1.y - a.y)) * ((b.x - q1.x))) - ((((q1.x - a.x)) * ((b.y - q1.y))))) < 0)
                    else:
                        tmp1 = True
            else:
                tmp1 = False
            if tmp1:
                p3 = b.prev
                r3 = b.next
                if (((((b.y - p3.y)) * ((r3.x - b.x))) - ((((b.x - p3.x)) * ((r3.y - b.y))))) < 0):
                    r4 = b.next
                    if (((((a.y - b.y)) * ((r4.x - a.x))) - ((((a.x - b.x)) * ((r4.y - a.y))))) >= 0):
                        q2 = b.prev
                        tmp = (((((q2.y - b.y)) * ((a.x - q2.x))) - ((((q2.x - b.x)) * ((a.y - q2.y))))) >= 0)
                    else:
                        tmp = False
                else:
                    r5 = b.prev
                    if (not ((((((a.y - b.y)) * ((r5.x - a.x))) - ((((a.x - b.x)) * ((r5.y - a.y))))) < 0))):
                        q3 = b.next
                        tmp = (((((q3.y - b.y)) * ((a.x - q3.x))) - ((((q3.x - b.x)) * ((a.y - q3.y))))) < 0)
                    else:
                        tmp = True
            else:
                tmp = False
            if tmp:
                _this = self.triangles
                x = a.i
                _this.append(x)
                _this1 = self.triangles
                x1 = p.i
                _this1.append(x1)
                _this2 = self.triangles
                x2 = b.i
                _this2.append(x2)
                p.next.prev = p.prev
                p.prev.next = p.next
                if (p.prevZ is not None):
                    p.prevZ.nextZ = p.nextZ
                if (p.nextZ is not None):
                    p.nextZ.prevZ = p.prevZ
                p4 = p.next
                p4.next.prev = p4.prev
                p4.prev.next = p4.next
                if (p4.prevZ is not None):
                    p4.prevZ.nextZ = p4.nextZ
                if (p4.nextZ is not None):
                    p4.nextZ.prevZ = p4.prevZ
                start = b
                p = start
            p = p.next
            if (not ((p != start))):
                break
        return p

    def splitEarcut(self,start):
        a = start
        while True:
            b = a.next.next
            while (b != a.prev):
                if ((a.i != b.i) and self.isValidDiagonal(a,b)):
                    c = self.splitPolygon(a,b)
                    a = self.filterPoints(a,a.next)
                    c = self.filterPoints(c,c.next)
                    self.earcutLinked(a)
                    self.earcutLinked(c)
                    return
                b = b.next
            a = a.next
            if (not ((a != start))):
                break

    def splitPolygon(self,a,b):
        i = a.i
        x = a.x
        y = a.y
        last = None
        n = self.cache
        if (n is None):
            n = hxd_earcut_EarNode()
            n.allocNext = self.allocated
            self.allocated = n
        else:
            self.cache = n.next
        n.i = i
        n.z = -1
        n.x = x
        n.y = y
        n.next = None
        n.prev = last
        n.steiner = False
        n.prevZ = None
        n.nextZ = None
        if (last is not None):
            last.next = n
        a2 = n
        i = b.i
        x = b.x
        y = b.y
        last = None
        n = self.cache
        if (n is None):
            n = hxd_earcut_EarNode()
            n.allocNext = self.allocated
            self.allocated = n
        else:
            self.cache = n.next
        n.i = i
        n.z = -1
        n.x = x
        n.y = y
        n.next = None
        n.prev = last
        n.steiner = False
        n.prevZ = None
        n.nextZ = None
        if (last is not None):
            last.next = n
        b2 = n
        an = a.next
        bp = b.prev
        a.next = b
        b.prev = a
        a2.next = an
        an.prev = a2
        b2.next = a2
        a2.prev = b2
        bp.next = b2
        b2.prev = bp
        return b2

    def pointInTriangle(self,ax,ay,bx,by,cx,cy,px,py):
        if ((((((cx - px)) * ((ay - py))) - ((((ax - px)) * ((cy - py))))) >= 0) and ((((((ax - px)) * ((by - py))) - ((((bx - px)) * ((ay - py))))) >= 0))):
            return (((((bx - px)) * ((cy - py))) - ((((cx - px)) * ((by - py))))) >= 0)
        else:
            return False

    def isValidDiagonal(self,a,b):
        if (not (((a.x == b.x) and ((a.y == b.y))))):
            tmp = None
            tmp1 = None
            if (((a.next.i != b.i) and ((a.prev.i != b.i))) and (not self.intersectsPolygon(a,b))):
                p = a.prev
                r = a.next
                if (((((a.y - p.y)) * ((r.x - a.x))) - ((((a.x - p.x)) * ((r.y - a.y))))) < 0):
                    r = a.next
                    if (((((b.y - a.y)) * ((r.x - b.x))) - ((((b.x - a.x)) * ((r.y - b.y))))) >= 0):
                        q = a.prev
                        tmp1 = (((((q.y - a.y)) * ((b.x - q.x))) - ((((q.x - a.x)) * ((b.y - q.y))))) >= 0)
                    else:
                        tmp1 = False
                else:
                    r = a.prev
                    if (not ((((((b.y - a.y)) * ((r.x - b.x))) - ((((b.x - a.x)) * ((r.y - b.y))))) < 0))):
                        q = a.next
                        tmp1 = (((((q.y - a.y)) * ((b.x - q.x))) - ((((q.x - a.x)) * ((b.y - q.y))))) < 0)
                    else:
                        tmp1 = True
            else:
                tmp1 = False
            if tmp1:
                p = b.prev
                r = b.next
                if (((((b.y - p.y)) * ((r.x - b.x))) - ((((b.x - p.x)) * ((r.y - b.y))))) < 0):
                    r = b.next
                    if (((((a.y - b.y)) * ((r.x - a.x))) - ((((a.x - b.x)) * ((r.y - a.y))))) >= 0):
                        q = b.prev
                        tmp = (((((q.y - b.y)) * ((a.x - q.x))) - ((((q.x - b.x)) * ((a.y - q.y))))) >= 0)
                    else:
                        tmp = False
                else:
                    r = b.prev
                    if (not ((((((a.y - b.y)) * ((r.x - a.x))) - ((((a.x - b.x)) * ((r.y - a.y))))) < 0))):
                        q = b.next
                        tmp = (((((q.y - b.y)) * ((a.x - q.x))) - ((((q.x - b.x)) * ((a.y - q.y))))) < 0)
                    else:
                        tmp = True
            else:
                tmp = False
            if tmp:
                return self.middleInside(a,b)
            else:
                return False
        else:
            return True

    def middleInside(self,a,b):
        p = a
        inside = False
        px = (((a.x + b.x)) / 2)
        py = (((a.y + b.y)) / 2)
        while True:
            if (((p.y > py) != ((p.next.y > py))) and ((px < ((((((p.next.x - p.x)) * ((py - p.y))) / ((p.next.y - p.y))) + p.x))))):
                inside = (not inside)
            p = p.next
            if (not ((p != a))):
                break
        return inside

    def intersectsPolygon(self,a,b):
        p = a
        while True:
            tmp = None
            if ((((p.i != a.i) and ((p.next.i != a.i))) and ((p.i != b.i))) and ((p.next.i != b.i))):
                q1 = p.next
                tmp = (((((((q1.y - p.y)) * ((a.x - q1.x))) - ((((q1.x - p.x)) * ((a.y - q1.y))))) > 0) != ((((((q1.y - p.y)) * ((b.x - q1.x))) - ((((q1.x - p.x)) * ((b.y - q1.y))))) > 0))) and (((((((b.y - a.y)) * ((p.x - b.x))) - ((((b.x - a.x)) * ((p.y - b.y))))) > 0) != ((((((b.y - a.y)) * ((q1.x - b.x))) - ((((b.x - a.x)) * ((q1.y - b.y))))) > 0)))))
            else:
                tmp = False
            if tmp:
                return True
            p = p.next
            if (not ((p != a))):
                break
        return False

    def zOrder(self,px,py):
        x = ((32767 * ((px - self.minX))) / self.size)
        x1 = None
        try:
            x1 = int(x)
        except BaseException as _g:
            None
            x1 = None
        x = ((32767 * ((py - self.minY))) / self.size)
        y = None
        try:
            y = int(x)
        except BaseException as _g:
            None
            y = None
        x1 = (((x1 | ((x1 << 8)))) & 16711935)
        x1 = (((x1 | ((x1 << 4)))) & 252645135)
        x1 = (((x1 | ((x1 << 2)))) & 858993459)
        x1 = (((x1 | ((x1 << 1)))) & 1431655765)
        y = (((y | ((y << 8)))) & 16711935)
        y = (((y | ((y << 4)))) & 252645135)
        y = (((y | ((y << 2)))) & 858993459)
        y = (((y | ((y << 1)))) & 1431655765)
        return (x1 | ((y << 1)))

    def indexCurve(self,start):
        p = start
        while True:
            if (p.z < 0):
                py = p.y
                x = ((32767 * ((p.x - self.minX))) / self.size)
                x1 = None
                try:
                    x1 = int(x)
                except BaseException as _g:
                    None
                    x1 = None
                x2 = ((32767 * ((py - self.minY))) / self.size)
                y = None
                try:
                    y = int(x2)
                except BaseException as _g1:
                    None
                    y = None
                x1 = (((x1 | ((x1 << 8)))) & 16711935)
                x1 = (((x1 | ((x1 << 4)))) & 252645135)
                x1 = (((x1 | ((x1 << 2)))) & 858993459)
                x1 = (((x1 | ((x1 << 1)))) & 1431655765)
                y = (((y | ((y << 8)))) & 16711935)
                y = (((y | ((y << 4)))) & 252645135)
                y = (((y | ((y << 2)))) & 858993459)
                y = (((y | ((y << 1)))) & 1431655765)
                p.z = (x1 | ((y << 1)))
            p.prevZ = p.prev
            p.nextZ = p.next
            p = p.next
            if (not ((p != start))):
                break
        p.prevZ.nextZ = None
        p.prevZ = None
        self.sortLinked(p)

    def sortLinked(self,_hx_list):
        p = None
        q = None
        e = None
        tail = None
        numMerges = None
        pSize = None
        qSize = None
        inSize = 1
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            numMerges = 0
            while (p is not None):
                numMerges = (numMerges + 1)
                q = p
                pSize = 0
                _g = 0
                _g1 = inSize
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    pSize = (pSize + 1)
                    q = q.nextZ
                    if (q is None):
                        break
                qSize = inSize
                while ((pSize > 0) or (((qSize > 0) and ((q is not None))))):
                    if (pSize == 0):
                        e = q
                        q = q.nextZ
                        qSize = (qSize - 1)
                    elif ((qSize == 0) or ((q is None))):
                        e = p
                        p = p.nextZ
                        pSize = (pSize - 1)
                    elif (p.z <= q.z):
                        e = p
                        p = p.nextZ
                        pSize = (pSize - 1)
                    else:
                        e = q
                        q = q.nextZ
                        qSize = (qSize - 1)
                    if (tail is not None):
                        tail.nextZ = e
                    else:
                        _hx_list = e
                    e.prevZ = tail
                    tail = e
                p = q
            tail.nextZ = None
            inSize = (inSize * 2)
            if (not ((numMerges > 1))):
                break
        return _hx_list

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.triangles = None
        _hx_o.cache = None
        _hx_o.allocated = None
        _hx_o.minX = None
        _hx_o.minY = None
        _hx_o.size = None
        _hx_o.hasSize = None
hxd_earcut_Earcut._hx_class = hxd_earcut_Earcut
_hx_classes["hxd.earcut.Earcut"] = hxd_earcut_Earcut


class hxd_fmt_bfnt_FontParser:
    _hx_class_name = "hxd.fmt.bfnt.FontParser"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["parse"]

    @staticmethod
    def parse(_hx_bytes,path,resolveTile):
        tile = None
        font = h2d_Font(None,0)
        glyphs = font.glyphs
        font.baseLine = 0
        v = (((_hx_bytes.b[0] | ((_hx_bytes.b[1] << 8))) | ((_hx_bytes.b[2] << 16))) | ((_hx_bytes.b[3] << 24)))
        _g = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _g1 = _g
        if (_g1 == 54938946):
            bytes1 = haxe_io_BytesInput(_hx_bytes)
            bytes1.set_position((bytes1.pos + 4))
            pageCount = 0
            while (bytes1.pos < bytes1.totlen):
                id = bytes1.readByte()
                length = bytes1.readInt32()
                pos = bytes1.pos
                id1 = id
                if (id1 == 1):
                    def _hx_local_0():
                        font.initSize = bytes1.readInt16()
                        return font.initSize
                    font.size = _hx_local_0()
                    bytes1.set_position((bytes1.pos + 12))
                    font.name = bytes1.readUntil(0)
                elif (id1 == 2):
                    font.lineHeight = bytes1.readUInt16()
                    font.baseLine = bytes1.readUInt16()
                    bytes1.set_position((bytes1.pos + 4))
                    pageCount = bytes1.readUInt16()
                    if (pageCount != 1):
                        haxe_Log.trace("Warning: BMF format only supports one page at the moment.",_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 224, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                elif (id1 == 3):
                    name = bytes1.readUntil(0)
                    try:
                        font.tilePath = name
                        tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path), name]))
                    except BaseException as _g1:
                        None
                        haxe_Log.trace((("Warning: Could not find referenced font texture at \"" + ("null" if name is None else name)) + "\", trying to resolve same name as fnt!"),_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 30, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                        font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                        tile = resolveTile(haxe_io_Path.withExtension(path,"png"))
                elif (id1 == 4):
                    count = None
                    try:
                        count = int((length / 20))
                    except BaseException as _g2:
                        None
                        count = None
                    count1 = count
                    while (count1 > 0):
                        cid = bytes1.readInt32()
                        t = tile.sub(bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readInt16(),bytes1.readInt16())
                        fc = h2d_FontChar(t,bytes1.readInt16())
                        glyphs.set(cid,fc)
                        bytes1.set_position((bytes1.pos + 2))
                        count1 = (count1 - 1)
                elif (id1 == 5):
                    count2 = None
                    try:
                        count2 = int((length / 10))
                    except BaseException as _g3:
                        None
                        count2 = None
                    count3 = count2
                    while (count3 > 0):
                        first = bytes1.readInt32()
                        key = bytes1.readInt32()
                        fc1 = glyphs.h.get(key,None)
                        if (fc1 is not None):
                            fc1.addKerning(first,bytes1.readInt16())
                        else:
                            bytes1.set_position((bytes1.pos + 2))
                        count3 = (count3 - 1)
                else:
                    pass
                bytes1.set_position((pos + length))
        elif (_g1 == 1414415938):
            def _hx_local_4():
                def _hx_local_3(tp):
                    nonlocal tile
                    nonlocal tile
                    try:
                        font.tilePath = tp
                        tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path), tp]))
                    except BaseException as _g:
                        None
                        haxe_Log.trace((("Warning: Could not find referenced font texture at \"" + ("null" if tp is None else tp)) + "\", trying to resolve same name as fnt!"),_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 30, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                        font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                        tile = resolveTile(haxe_io_Path.withExtension(path,"png"))
                    return tile
                return hxd_fmt_bfnt_Reader(haxe_io_BytesInput(_hx_bytes)).read(_hx_local_3)
            return _hx_local_4()
        elif ((_g1 == 1852794428) or ((_g1 == 1836597052))):
            xml = Xml.parse(_hx_bytes.toString())
            x = xml.firstElement()
            if ((x.nodeType != Xml.Document) and ((x.nodeType != Xml.Element))):
                raise haxe_Exception.thrown(("Invalid nodeType " + HxOverrides.stringOrNull((("null" if ((x.nodeType is None)) else _Xml_XmlType_Impl_.toString(x.nodeType))))))
            this1 = x
            xml = this1
            if haxe_xml__Access_HasNodeAccess_Impl_.resolve(xml,"info"):
                tmp = haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"info")
                font.name = haxe_xml__Access_AttribAccess_Impl_.resolve(tmp,"face")
                tmp = haxe_xml__Access_AttribAccess_Impl_.resolve(haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"info"),"size")
                def _hx_local_5():
                    font.initSize = Std.parseInt(tmp)
                    return font.initSize
                font.size = _hx_local_5()
                tmp = haxe_xml__Access_AttribAccess_Impl_.resolve(haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"common"),"lineHeight")
                font.lineHeight = Std.parseInt(tmp)
                tmp = haxe_xml__Access_AttribAccess_Impl_.resolve(haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"common"),"base")
                font.baseLine = Std.parseInt(tmp)
                p = haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"pages").elements()
                while p.hasNext():
                    p1 = p.next()
                    if (haxe_xml__Access_AttribAccess_Impl_.resolve(p1,"id") == "0"):
                        tilePath = haxe_xml__Access_AttribAccess_Impl_.resolve(p1,"file")
                        try:
                            font.tilePath = tilePath
                            tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path), tilePath]))
                        except BaseException as _g1:
                            None
                            haxe_Log.trace((("Warning: Could not find referenced font texture at \"" + ("null" if tilePath is None else tilePath)) + "\", trying to resolve same name as fnt!"),_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 30, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                            font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                            tile = resolveTile(haxe_io_Path.withExtension(path,"png"))
                    else:
                        haxe_Log.trace("Warning: BMF format only supports one page at the moment.",_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 66, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                chars = haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"chars").elements()
                c = chars
                while c.hasNext():
                    c1 = c.next()
                    t = tile.sub(Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"x")),Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"y")),Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"width")),Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"height")),Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"xoffset")),Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"yoffset")))
                    fc = h2d_FontChar(t,Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"xadvance")))
                    kerns = haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"kernings").elements()
                    k = kerns
                    while k.hasNext():
                        k1 = k.next()
                        if (haxe_xml__Access_AttribAccess_Impl_.resolve(k1,"second") == haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"id")):
                            fc.addKerning(Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(k1,"first")),Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(k1,"amount")))
                    glyphs.set(Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"id")),fc)
            else:
                font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                tile = resolveTile(haxe_io_Path.withExtension(path,"png"))
                font.name = haxe_xml__Access_AttribAccess_Impl_.resolve(xml,"family")
                tmp = haxe_xml__Access_AttribAccess_Impl_.resolve(xml,"size")
                def _hx_local_6():
                    font.initSize = Std.parseInt(tmp)
                    return font.initSize
                font.size = _hx_local_6()
                tmp = haxe_xml__Access_AttribAccess_Impl_.resolve(xml,"height")
                font.lineHeight = Std.parseInt(tmp)
                kernings = []
                c = xml.elements()
                while c.hasNext():
                    c1 = c.next()
                    _this = haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"rect")
                    r = _this.split(" ")
                    _this1 = haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"offset")
                    o = _this1.split(" ")
                    t = tile.sub(Std.parseInt((r[0] if 0 < len(r) else None)),Std.parseInt((r[1] if 1 < len(r) else None)),Std.parseInt((r[2] if 2 < len(r) else None)),Std.parseInt((r[3] if 3 < len(r) else None)),Std.parseInt((o[0] if 0 < len(o) else None)),Std.parseInt((o[1] if 1 < len(o) else None)))
                    fc = h2d_FontChar(t,Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"width")))
                    code = haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"code")
                    code1 = (Std.parseInt(HxString.substr(code,2,(len(code) - 3))) if (code.startswith("&#")) else HxString.charCodeAt(code,0))
                    k = c1.elements()
                    while k.hasNext():
                        k1 = k.next()
                        code2 = haxe_xml__Access_AttribAccess_Impl_.resolve(k1,"id")
                        next = (Std.parseInt(HxString.substr(code2,2,(len(code2) - 3))) if (code2.startswith("&#")) else HxString.charCodeAt(code2,0))
                        adv = Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(k1,"advance"))
                        if (next in glyphs.h):
                            glyphs.h.get(next,None).addKerning(code1,adv)
                        else:
                            kernings.append(_hx_AnonObject({'prev': code1, 'next': next, 'adv': adv}))
                    glyphs.set(code1,fc)
                _g1 = 0
                while (_g1 < len(kernings)):
                    k = (kernings[_g1] if _g1 >= 0 and _g1 < len(kernings) else None)
                    _g1 = (_g1 + 1)
                    g = glyphs.h.get(k.next,None)
                    if (g is None):
                        continue
                    g.addKerning(k.prev,k.adv)
        elif (_g1 == 1868983913):
            _this = _hx_bytes.toString()
            lines = _this.split("\n")
            reg = EReg(" *?([0-9a-zA-Z]+)=(\"[^\"]+\"|.+?)(?:[ \r]|$)","")
            idx = None
            pageCount = 0
            _g1 = 0
            while (_g1 < len(lines)):
                line = (lines[_g1] if _g1 >= 0 and _g1 < len(lines) else None)
                _g1 = (_g1 + 1)
                startIndex = None
                idx = (line.find(" ") if ((startIndex is None)) else HxString.indexOfImpl(line," ",startIndex))
                _g2 = HxString.substr(line,0,idx)
                _hx_local_9 = len(_g2)
                if (_hx_local_9 == 4):
                    if (_g2 == "char"):
                        id = 0
                        x = 0
                        y = 0
                        width = 0
                        height = 0
                        xoffset = 0
                        yoffset = 0
                        xadvance = 0
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            _g3 = reg.matchObj.group(1)
                            _hx_local_10 = len(_g3)
                            if (_hx_local_10 == 1):
                                if (_g3 == "x"):
                                    v3 = reg.matchObj.group(2)
                                    x = Std.parseInt((HxString.substring(v3,1,(len(v3) - 1)) if ((HxString.charCodeAt(v3,0) == 34)) else v3))
                                elif (_g3 == "y"):
                                    v6 = reg.matchObj.group(2)
                                    y = Std.parseInt((HxString.substring(v6,1,(len(v6) - 1)) if ((HxString.charCodeAt(v6,0) == 34)) else v6))
                            elif (_hx_local_10 == 5):
                                if (_g3 == "width"):
                                    v2 = reg.matchObj.group(2)
                                    width = Std.parseInt((HxString.substring(v2,1,(len(v2) - 1)) if ((HxString.charCodeAt(v2,0) == 34)) else v2))
                            elif (_hx_local_10 == 7):
                                if (_g3 == "xoffset"):
                                    v5 = reg.matchObj.group(2)
                                    xoffset = Std.parseInt((HxString.substring(v5,1,(len(v5) - 1)) if ((HxString.charCodeAt(v5,0) == 34)) else v5))
                                elif (_g3 == "yoffset"):
                                    v7 = reg.matchObj.group(2)
                                    yoffset = Std.parseInt((HxString.substring(v7,1,(len(v7) - 1)) if ((HxString.charCodeAt(v7,0) == 34)) else v7))
                            elif (_hx_local_10 == 8):
                                if (_g3 == "xadvance"):
                                    v4 = reg.matchObj.group(2)
                                    xadvance = Std.parseInt((HxString.substring(v4,1,(len(v4) - 1)) if ((HxString.charCodeAt(v4,0) == 34)) else v4))
                            elif (_hx_local_10 == 6):
                                if (_g3 == "height"):
                                    v = reg.matchObj.group(2)
                                    height = Std.parseInt((HxString.substring(v,1,(len(v) - 1)) if ((HxString.charCodeAt(v,0) == 34)) else v))
                            elif (_hx_local_10 == 2):
                                if (_g3 == "id"):
                                    v1 = reg.matchObj.group(2)
                                    id = Std.parseInt((HxString.substring(v1,1,(len(v1) - 1)) if ((HxString.charCodeAt(v1,0) == 34)) else v1))
                            else:
                                pass
                            pos_pos = reg.matchObj.start()
                            pos_len = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos + pos_len)
                        t = tile.sub(x,y,width,height,xoffset,yoffset)
                        fc = h2d_FontChar(t,xadvance)
                        glyphs.set(id,fc)
                    elif (_g2 == "info"):
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            _g5 = reg.matchObj.group(1)
                            if (_g5 == "face"):
                                v11 = reg.matchObj.group(2)
                                tmp2 = (HxString.substring(v11,1,(len(v11) - 1)) if ((HxString.charCodeAt(v11,0) == 34)) else v11)
                                font.name = tmp2
                            elif (_g5 == "size"):
                                v12 = reg.matchObj.group(2)
                                tmp3 = (HxString.substring(v12,1,(len(v12) - 1)) if ((HxString.charCodeAt(v12,0) == 34)) else v12)
                                def _hx_local_11():
                                    font.initSize = Std.parseInt(tmp3)
                                    return font.initSize
                                font.size = _hx_local_11()
                            else:
                                pass
                            pos_pos2 = reg.matchObj.start()
                            pos_len2 = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos2 + pos_len2)
                    elif (_g2 == "page"):
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            if (reg.matchObj.group(1) == "file"):
                                v16 = reg.matchObj.group(2)
                                tilePath = (HxString.substring(v16,1,(len(v16) - 1)) if ((HxString.charCodeAt(v16,0) == 34)) else v16)
                                try:
                                    font.tilePath = tilePath
                                    tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path), tilePath]))
                                except BaseException as _g7:
                                    None
                                    haxe_Log.trace((("Warning: Could not find referenced font texture at \"" + ("null" if tilePath is None else tilePath)) + "\", trying to resolve same name as fnt!"),_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 30, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                                    font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                                    tile = resolveTile(haxe_io_Path.withExtension(path,"png"))
                            pos_pos4 = reg.matchObj.start()
                            pos_len4 = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos4 + pos_len4)
                elif (_hx_local_9 == 7):
                    if (_g2 == "kerning"):
                        first = 0
                        second = 0
                        advance = 0
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            _g6 = reg.matchObj.group(1)
                            _hx_local_12 = len(_g6)
                            if (_hx_local_12 == 5):
                                if (_g6 == "first"):
                                    v14 = reg.matchObj.group(2)
                                    first = Std.parseInt((HxString.substring(v14,1,(len(v14) - 1)) if ((HxString.charCodeAt(v14,0) == 34)) else v14))
                            elif (_hx_local_12 == 6):
                                if (_g6 == "amount"):
                                    v13 = reg.matchObj.group(2)
                                    advance = Std.parseInt((HxString.substring(v13,1,(len(v13) - 1)) if ((HxString.charCodeAt(v13,0) == 34)) else v13))
                                elif (_g6 == "second"):
                                    v15 = reg.matchObj.group(2)
                                    second = Std.parseInt((HxString.substring(v15,1,(len(v15) - 1)) if ((HxString.charCodeAt(v15,0) == 34)) else v15))
                            else:
                                pass
                            pos_pos3 = reg.matchObj.start()
                            pos_len3 = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos3 + pos_len3)
                        fc1 = glyphs.h.get(second,None)
                        if (fc1 is not None):
                            fc1.addKerning(first,advance)
                elif (_hx_local_9 == 6):
                    if (_g2 == "common"):
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            _g4 = reg.matchObj.group(1)
                            _hx_local_13 = len(_g4)
                            if (_hx_local_13 == 10):
                                if (_g4 == "lineHeight"):
                                    v9 = reg.matchObj.group(2)
                                    tmp1 = (HxString.substring(v9,1,(len(v9) - 1)) if ((HxString.charCodeAt(v9,0) == 34)) else v9)
                                    font.lineHeight = Std.parseInt(tmp1)
                            elif (_hx_local_13 == 4):
                                if (_g4 == "base"):
                                    v8 = reg.matchObj.group(2)
                                    tmp = (HxString.substring(v8,1,(len(v8) - 1)) if ((HxString.charCodeAt(v8,0) == 34)) else v8)
                                    font.baseLine = Std.parseInt(tmp)
                            elif (_hx_local_13 == 5):
                                if (_g4 == "pages"):
                                    v10 = reg.matchObj.group(2)
                                    pageCount = Std.parseInt((HxString.substring(v10,1,(len(v10) - 1)) if ((HxString.charCodeAt(v10,0) == 34)) else v10))
                                    if (pageCount != 1):
                                        haxe_Log.trace("Warning: BMF format only supports one page at the moment.",_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 157, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                            else:
                                pass
                            pos_pos1 = reg.matchObj.start()
                            pos_len1 = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos1 + pos_len1)
                else:
                    pass
        else:
            sign = _g
            raise haxe_Exception.thrown(("Unknown font signature " + HxOverrides.stringOrNull(StringTools.hex(sign,8))))
        if (glyphs.h.get(32,None) is None):
            glyphs.set(32,h2d_FontChar(tile.sub(0,0,0,0),(font.size >> 1)))
        font.tile = tile
        if (font.baseLine == 0):
            padding = 0
            space = glyphs.h.get(32,None)
            if (space is not None):
                padding = (space.t.height * .5)
            a = glyphs.h.get(65,None)
            if (a is None):
                a = glyphs.h.get(97,None)
            if (a is None):
                a = glyphs.h.get(48,None)
            if (a is None):
                font.baseLine = ((font.lineHeight - 2) - padding)
            else:
                font.baseLine = ((a.t.dy + a.t.height) - padding)
        fallback = glyphs.h.get(65533,None)
        if (fallback is None):
            fallback = glyphs.h.get(9633,None)
        if (fallback is None):
            fallback = glyphs.h.get(63,None)
        if (fallback is not None):
            font.defaultChar = fallback
        return font
hxd_fmt_bfnt_FontParser._hx_class = hxd_fmt_bfnt_FontParser
_hx_classes["hxd.fmt.bfnt.FontParser"] = hxd_fmt_bfnt_FontParser


class hxd_fmt_bfnt_Reader:
    _hx_class_name = "hxd.fmt.bfnt.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i",)
    _hx_fields = ["i"]
    _hx_methods = ["read"]
    _hx_statics = ["parse"]

    def __init__(self,i):
        self.i = i

    def read(self,resolveTile):
        if ((self.i.readString(4) != "BFNT") or ((self.i.readByte() != 0))):
            raise haxe_Exception.thrown("Not a BFNT file!")
        font = None
        _g = self.i.readByte()
        if (_g == 1):
            font = h2d_Font(self.i.readString(self.i.readUInt16()),self.i.readInt16())
            font.tilePath = self.i.readString(self.i.readUInt16())
            def _hx_local_0():
                font.tile = resolveTile(font.tilePath)
                return font.tile
            tile = _hx_local_0()
            font.lineHeight = self.i.readInt16()
            font.baseLine = self.i.readInt16()
            defaultChar = self.i.readInt32()
            id = None
            while True:
                id = self.i.readInt32()
                if (not ((id != 0))):
                    break
                t = tile.sub(self.i.readUInt16(),self.i.readUInt16(),self.i.readUInt16(),self.i.readUInt16(),self.i.readInt16(),self.i.readInt16())
                glyph = h2d_FontChar(t,self.i.readInt16())
                font.glyphs.set(id,glyph)
                if (id == defaultChar):
                    font.defaultChar = glyph
                prevChar = None
                while True:
                    prevChar = self.i.readInt32()
                    if (not ((prevChar != 0))):
                        break
                    glyph.addKerning(prevChar,self.i.readInt16())
        else:
            ver = _g
            raise haxe_Exception.thrown(("Unknown BFNT version: " + Std.string(ver)))
        return font

    @staticmethod
    def parse(_hx_bytes,resolveTile):
        return hxd_fmt_bfnt_Reader(haxe_io_BytesInput(_hx_bytes)).read(resolveTile)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
hxd_fmt_bfnt_Reader._hx_class = hxd_fmt_bfnt_Reader
_hx_classes["hxd.fmt.bfnt.Reader"] = hxd_fmt_bfnt_Reader


class hxd_fmt_bfnt_Writer:
    _hx_class_name = "hxd.fmt.bfnt.Writer"
    _hx_is_interface = "False"
    __slots__ = ("out",)
    _hx_fields = ["out"]
    _hx_methods = ["write", "writeString"]
    _hx_statics = ["VERSION"]

    def __init__(self,out):
        self.out = out

    def write(self,font):
        self.out.writeString("BFNT")
        self.out.writeByte(0)
        self.out.writeByte(1)
        s = font.name
        if (s is None):
            s = ""
        _hx_bytes = haxe_io_Bytes.ofString(s)
        if (_hx_bytes.length > 65535):
            raise haxe_Exception.thrown("Invalid string: Size over 0xFFFF")
        self.out.writeUInt16(_hx_bytes.length)
        self.out.write(_hx_bytes)
        self.out.writeInt16(font.size)
        s = font.tilePath
        if (s is None):
            s = ""
        _hx_bytes = haxe_io_Bytes.ofString(s)
        if (_hx_bytes.length > 65535):
            raise haxe_Exception.thrown("Invalid string: Size over 0xFFFF")
        self.out.writeUInt16(_hx_bytes.length)
        self.out.write(_hx_bytes)
        tmp = self.out
        x = font.lineHeight
        tmp1 = None
        try:
            tmp1 = int(x)
        except BaseException as _g:
            None
            tmp1 = None
        tmp.writeInt16(tmp1)
        tmp = self.out
        x = font.baseLine
        tmp1 = None
        try:
            tmp1 = int(x)
        except BaseException as _g:
            None
            tmp1 = None
        tmp.writeInt16(tmp1)
        if (font.defaultChar != font.nullChar):
            found = False
            k = font.glyphs.keys()
            while k.hasNext():
                k1 = k.next()
                if (font.glyphs.h.get(k1,None) == font.defaultChar):
                    self.out.writeInt32(k1)
                    found = True
                    break
            if (not found):
                self.out.writeInt32(0)
        else:
            self.out.writeInt32(0)
        id = font.glyphs.keys()
        while id.hasNext():
            id1 = id.next()
            if (id1 == 0):
                continue
            glyph = font.glyphs.h.get(id1,None)
            t = glyph.t
            self.out.writeInt32(id1)
            tmp = self.out
            x = t.x
            tmp1 = None
            try:
                tmp1 = int(x)
            except BaseException as _g:
                None
                tmp1 = None
            tmp.writeUInt16(tmp1)
            tmp2 = self.out
            x1 = t.y
            tmp3 = None
            try:
                tmp3 = int(x1)
            except BaseException as _g1:
                None
                tmp3 = None
            tmp2.writeUInt16(tmp3)
            tmp4 = self.out
            x2 = t.width
            tmp5 = None
            try:
                tmp5 = int(x2)
            except BaseException as _g2:
                None
                tmp5 = None
            tmp4.writeUInt16(tmp5)
            tmp6 = self.out
            x3 = t.height
            tmp7 = None
            try:
                tmp7 = int(x3)
            except BaseException as _g3:
                None
                tmp7 = None
            tmp6.writeUInt16(tmp7)
            tmp8 = self.out
            x4 = t.dx
            tmp9 = None
            try:
                tmp9 = int(x4)
            except BaseException as _g4:
                None
                tmp9 = None
            tmp8.writeInt16(tmp9)
            tmp10 = self.out
            x5 = t.dy
            tmp11 = None
            try:
                tmp11 = int(x5)
            except BaseException as _g5:
                None
                tmp11 = None
            tmp10.writeInt16(tmp11)
            tmp12 = self.out
            x6 = glyph.width
            tmp13 = None
            try:
                tmp13 = int(x6)
            except BaseException as _g6:
                None
                tmp13 = None
            tmp12.writeInt16(tmp13)
            kern = glyph.kerning
            while (kern is not None):
                if (kern.prevChar != 0):
                    self.out.writeInt32(kern.prevChar)
                    tmp14 = self.out
                    x7 = kern.offset
                    tmp15 = None
                    try:
                        tmp15 = int(x7)
                    except BaseException as _g7:
                        None
                        tmp15 = None
                    tmp14.writeInt16(tmp15)
                kern = kern.next
            self.out.writeInt32(0)
        self.out.writeInt32(0)

    def writeString(self,s):
        if (s is None):
            s = ""
        _hx_bytes = haxe_io_Bytes.ofString(s)
        if (_hx_bytes.length > 65535):
            raise haxe_Exception.thrown("Invalid string: Size over 0xFFFF")
        self.out.writeUInt16(_hx_bytes.length)
        self.out.write(_hx_bytes)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.out = None
hxd_fmt_bfnt_Writer._hx_class = hxd_fmt_bfnt_Writer
_hx_classes["hxd.fmt.bfnt.Writer"] = hxd_fmt_bfnt_Writer


class hxd_fmt_fbx_TmpObject:
    _hx_class_name = "hxd.fmt.fbx.TmpObject"
    _hx_is_interface = "False"
    __slots__ = ("index", "model", "parent", "isJoint", "isMesh", "childs", "obj", "joint", "skin")
    _hx_fields = ["index", "model", "parent", "isJoint", "isMesh", "childs", "obj", "joint", "skin"]

    def __init__(self):
        self.skin = None
        self.joint = None
        self.obj = None
        self.isMesh = None
        self.isJoint = None
        self.parent = None
        self.model = None
        self.index = None
        self.childs = []

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.model = None
        _hx_o.parent = None
        _hx_o.isJoint = None
        _hx_o.isMesh = None
        _hx_o.childs = None
        _hx_o.obj = None
        _hx_o.joint = None
        _hx_o.skin = None
hxd_fmt_fbx_TmpObject._hx_class = hxd_fmt_fbx_TmpObject
_hx_classes["hxd.fmt.fbx.TmpObject"] = hxd_fmt_fbx_TmpObject


class hxd_fmt_fbx__BaseLibrary_AnimCurve:
    _hx_class_name = "hxd.fmt.fbx._BaseLibrary.AnimCurve"
    _hx_is_interface = "False"
    __slots__ = ("_hx_def", "object", "t", "r", "s", "a", "fov", "roll", "uv")
    _hx_fields = ["def", "object", "t", "r", "s", "a", "fov", "roll", "uv"]

    def __init__(self,_hx_def,object):
        self.uv = None
        self.roll = None
        self.fov = None
        self.a = None
        self.s = None
        self.r = None
        self.t = None
        self._hx_def = _hx_def
        self.object = object

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx_def = None
        _hx_o.object = None
        _hx_o.t = None
        _hx_o.r = None
        _hx_o.s = None
        _hx_o.a = None
        _hx_o.fov = None
        _hx_o.roll = None
        _hx_o.uv = None
hxd_fmt_fbx__BaseLibrary_AnimCurve._hx_class = hxd_fmt_fbx__BaseLibrary_AnimCurve
_hx_classes["hxd.fmt.fbx._BaseLibrary.AnimCurve"] = hxd_fmt_fbx__BaseLibrary_AnimCurve


class hxd_fmt_fbx_DefaultMatrixes:
    _hx_class_name = "hxd.fmt.fbx.DefaultMatrixes"
    _hx_is_interface = "False"
    __slots__ = ("trans", "scale", "rotate", "preRot", "wasRemoved", "transPos")
    _hx_fields = ["trans", "scale", "rotate", "preRot", "wasRemoved", "transPos"]
    _hx_methods = ["toMatrix", "toQuaternion"]
    _hx_statics = ["rightHandToLeft"]

    def __init__(self):
        self.transPos = None
        self.wasRemoved = None
        self.preRot = None
        self.rotate = None
        self.scale = None
        self.trans = None

    def toMatrix(self,leftHand):
        m = h3d_Matrix()
        m.identity()
        if (self.scale is not None):
            m.scale(self.scale.x,self.scale.y,self.scale.z)
        if (self.rotate is not None):
            m.rotate(self.rotate.x,self.rotate.y,self.rotate.z)
        if (self.preRot is not None):
            m.rotate(self.preRot.x,self.preRot.y,self.preRot.z)
        if (self.trans is not None):
            m.translate(self.trans.x,self.trans.y,self.trans.z)
        if leftHand:
            m._12 = -m._12
            m._13 = -m._13
            m._21 = -m._21
            m._31 = -m._31
            m._41 = -m._41
        return m

    def toQuaternion(self,leftHand):
        m = h3d_Matrix()
        m.identity()
        if (self.rotate is not None):
            m.rotate(self.rotate.x,self.rotate.y,self.rotate.z)
        if (self.preRot is not None):
            m.rotate(self.preRot.x,self.preRot.y,self.preRot.z)
        if leftHand:
            m._12 = -m._12
            m._13 = -m._13
            m._21 = -m._21
            m._31 = -m._31
            m._41 = -m._41
        q = h3d_Quat()
        q.initRotateMatrix(m)
        return q

    @staticmethod
    def rightHandToLeft(m):
        m._12 = -m._12
        m._13 = -m._13
        m._21 = -m._21
        m._31 = -m._31
        m._41 = -m._41

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.trans = None
        _hx_o.scale = None
        _hx_o.rotate = None
        _hx_o.preRot = None
        _hx_o.wasRemoved = None
        _hx_o.transPos = None
hxd_fmt_fbx_DefaultMatrixes._hx_class = hxd_fmt_fbx_DefaultMatrixes
_hx_classes["hxd.fmt.fbx.DefaultMatrixes"] = hxd_fmt_fbx_DefaultMatrixes


class hxd_fmt_fbx_BaseLibrary:
    _hx_class_name = "hxd.fmt.fbx.BaseLibrary"
    _hx_is_interface = "False"
    __slots__ = ("root", "ids", "connect", "namedConnect", "invConnect", "leftHand", "defaultModelMatrixes", "uvAnims", "animationEvents", "isMaya", "fileName", "version", "keepJoints", "skipObjects", "bonesPerVertex", "unskinnedJointsAsObjects", "allowVertexColor", "normalizeScaleOrient")
    _hx_fields = ["root", "ids", "connect", "namedConnect", "invConnect", "leftHand", "defaultModelMatrixes", "uvAnims", "animationEvents", "isMaya", "fileName", "version", "keepJoints", "skipObjects", "bonesPerVertex", "unskinnedJointsAsObjects", "allowVertexColor", "normalizeScaleOrient"]
    _hx_methods = ["reset", "loadFile", "load", "toFloats", "getAllModels", "getRootModels", "isRootModel", "updateModelScale", "convertYupToZup", "convertPoints", "leftHandConvert", "init", "getGeometry", "getParent", "getChild", "getSpecChild", "getChilds", "getParents", "getRoot", "ignoreMissingObject", "buildHierarchy", "getObjectCurve", "mergeModels", "addLink", "removeLink", "checkData", "roundValues", "getAnimationNames", "loadAnimation", "sortDistinctFloats", "isNullJoint", "getModelPath", "autoMerge", "keepJoint", "createSkin", "round", "updateDefaultMatrix", "getDefaultMatrixes"]
    _hx_statics = ["maxBonesPerSkin"]

    def __init__(self,fileName):
        self.unskinnedJointsAsObjects = None
        self.isMaya = None
        self.animationEvents = None
        self.uvAnims = None
        self.defaultModelMatrixes = None
        self.leftHand = None
        self.invConnect = None
        self.namedConnect = None
        self.connect = None
        self.ids = None
        self.normalizeScaleOrient = True
        self.allowVertexColor = True
        self.bonesPerVertex = 3
        self.version = 0.
        self.fileName = fileName
        self.root = _hx_AnonObject({'name': "Root", 'props': [], 'childs': []})
        self.keepJoints = haxe_ds_StringMap()
        self.skipObjects = haxe_ds_StringMap()
        self.reset()

    def reset(self):
        self.ids = haxe_ds_IntMap()
        self.connect = haxe_ds_IntMap()
        self.namedConnect = haxe_ds_IntMap()
        self.invConnect = haxe_ds_IntMap()
        self.defaultModelMatrixes = haxe_ds_IntMap()

    def loadFile(self,data):
        self.load(hxd_fmt_fbx_Parser.parse(data))

    def load(self,root):
        self.reset()
        self.root = root
        self.version = (hxd_fmt_fbx_FbxTools.toInt(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(root,"FBXHeaderExtension.FBXVersion").props, 0)) / 1000)
        x = self.version
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        if (tmp != 7):
            raise haxe_Exception.thrown("FBX Version 7.x required : use FBX 2010 export")
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(root,"FBXHeaderExtension.SceneInfo.Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None)) == "Original|ApplicationName"):
                _this = hxd_fmt_fbx_FbxTools.toString((p.props[4] if 4 < len(p.props) else None)).lower()
                startIndex = None
                self.isMaya = (((_this.find("maya") if ((startIndex is None)) else HxString.indexOfImpl(_this,"maya",startIndex))) >= 0)
                break
        _g = 0
        _g1 = root.childs
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.init(c)
        if self.normalizeScaleOrient:
            self.updateModelScale()
        _g = 0
        _g1 = self.getAllModels()
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = 0
            _g3 = hxd_fmt_fbx_FbxTools.getAll(m,"Properties70.P")
            while (_g2 < len(_g3)):
                p = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                _g4 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
                _hx_local_4 = len(_g4)
                if (_hx_local_4 == 9):
                    if (_g4 == "UDP3DSMAX"):
                        _this = hxd_fmt_fbx_FbxTools.toString((p.props[4] if 4 < len(p.props) else None))
                        userProps = _this.split("&cr;&lf;")
                        _g5 = 0
                        while (_g5 < len(userProps)):
                            p1 = (userProps[_g5] if _g5 >= 0 and _g5 < len(userProps) else None)
                            _g5 = (_g5 + 1)
                            pl = p1.split("=")
                            pname = StringTools.trim((None if ((len(pl) == 0)) else pl.pop(0)))
                            pval = StringTools.trim("=".join([python_Boot.toString1(x1,'') for x1 in pl]))
                            pname1 = pname
                            _hx_local_6 = len(pname1)
                            if (_hx_local_6 == 6):
                                if (pname1 == "Events"):
                                    xml = None
                                    try:
                                        xml = Xml.parse(pval)
                                    except BaseException as _g6:
                                        None
                                        raise haxe_Exception.thrown(("Invalid Events data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                    _g7 = []
                                    x = xml.firstElement()
                                    if ((x.nodeType != Xml.Document) and ((x.nodeType != Xml.Element))):
                                        raise haxe_Exception.thrown(("Invalid nodeType " + HxOverrides.stringOrNull((("null" if ((x.nodeType is None)) else _Xml_XmlType_Impl_.toString(x.nodeType))))))
                                    this1 = x
                                    f = this1.elements()
                                    while f.hasNext():
                                        f1 = f.next()
                                        _this1 = haxe_xml__Access_Access_Impl_.get_innerData(f1)
                                        f2 = _this1.split(" ")
                                        x1 = _hx_AnonObject({'frame': Std.parseInt((None if ((len(f2) == 0)) else f2.pop(0))), 'data': StringTools.trim(" ".join([python_Boot.toString1(x1,'') for x1 in f2]))})
                                        _g7.append(x1)
                                    self.animationEvents = _g7
                                else:
                                    pass
                            elif (_hx_local_6 == 2):
                                if (pname1 == "UV"):
                                    if (pval != ""):
                                        xml1 = None
                                        try:
                                            xml1 = Xml.parse(pval)
                                        except BaseException as _g8:
                                            None
                                            raise haxe_Exception.thrown(("Invalid UV data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                        _g9 = []
                                        x2 = xml1.firstElement()
                                        if ((x2.nodeType != Xml.Document) and ((x2.nodeType != Xml.Element))):
                                            raise haxe_Exception.thrown(("Invalid nodeType " + HxOverrides.stringOrNull((("null" if ((x2.nodeType is None)) else _Xml_XmlType_Impl_.toString(x2.nodeType))))))
                                        this2 = x2
                                        f3 = this2.elements()
                                        while f3.hasNext():
                                            f4 = f3.next()
                                            _this2 = haxe_xml__Access_Access_Impl_.get_innerData(f4)
                                            f5 = _this2.split(" ")
                                            x3 = _hx_AnonObject({'t': (Std.parseFloat((f5[0] if 0 < len(f5) else None)) * 9622116.25), 'u': Std.parseFloat((f5[1] if 1 < len(f5) else None)), 'v': Std.parseFloat((f5[2] if 2 < len(f5) else None))})
                                            _g9.append(x3)
                                        frames = _g9
                                        if (self.uvAnims is None):
                                            self.uvAnims = haxe_ds_StringMap()
                                        this3 = self.uvAnims
                                        key = hxd_fmt_fbx_FbxTools.getName(m)
                                        this3.h[key] = frames
                                else:
                                    pass
                            else:
                                pass
                    else:
                        pass
                elif (_hx_local_4 == 6):
                    if (_g4 == "Events"):
                        _this = hxd_fmt_fbx_FbxTools.toString((p.props[4] if 4 < len(p.props) else None))
                        userProps = _this.split("&cr;&lf;")
                        _g5 = 0
                        while (_g5 < len(userProps)):
                            p1 = (userProps[_g5] if _g5 >= 0 and _g5 < len(userProps) else None)
                            _g5 = (_g5 + 1)
                            pl = p1.split("=")
                            pname = StringTools.trim((None if ((len(pl) == 0)) else pl.pop(0)))
                            pval = StringTools.trim("=".join([python_Boot.toString1(x1,'') for x1 in pl]))
                            pname1 = pname
                            _hx_local_8 = len(pname1)
                            if (_hx_local_8 == 6):
                                if (pname1 == "Events"):
                                    xml = None
                                    try:
                                        xml = Xml.parse(pval)
                                    except BaseException as _g6:
                                        None
                                        raise haxe_Exception.thrown(("Invalid Events data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                    _g7 = []
                                    x = xml.firstElement()
                                    if ((x.nodeType != Xml.Document) and ((x.nodeType != Xml.Element))):
                                        raise haxe_Exception.thrown(("Invalid nodeType " + HxOverrides.stringOrNull((("null" if ((x.nodeType is None)) else _Xml_XmlType_Impl_.toString(x.nodeType))))))
                                    this1 = x
                                    f = this1.elements()
                                    while f.hasNext():
                                        f1 = f.next()
                                        _this1 = haxe_xml__Access_Access_Impl_.get_innerData(f1)
                                        f2 = _this1.split(" ")
                                        x1 = _hx_AnonObject({'frame': Std.parseInt((None if ((len(f2) == 0)) else f2.pop(0))), 'data': StringTools.trim(" ".join([python_Boot.toString1(x1,'') for x1 in f2]))})
                                        _g7.append(x1)
                                    self.animationEvents = _g7
                                else:
                                    pass
                            elif (_hx_local_8 == 2):
                                if (pname1 == "UV"):
                                    if (pval != ""):
                                        xml1 = None
                                        try:
                                            xml1 = Xml.parse(pval)
                                        except BaseException as _g8:
                                            None
                                            raise haxe_Exception.thrown(("Invalid UV data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                        _g9 = []
                                        x2 = xml1.firstElement()
                                        if ((x2.nodeType != Xml.Document) and ((x2.nodeType != Xml.Element))):
                                            raise haxe_Exception.thrown(("Invalid nodeType " + HxOverrides.stringOrNull((("null" if ((x2.nodeType is None)) else _Xml_XmlType_Impl_.toString(x2.nodeType))))))
                                        this2 = x2
                                        f3 = this2.elements()
                                        while f3.hasNext():
                                            f4 = f3.next()
                                            _this2 = haxe_xml__Access_Access_Impl_.get_innerData(f4)
                                            f5 = _this2.split(" ")
                                            x3 = _hx_AnonObject({'t': (Std.parseFloat((f5[0] if 0 < len(f5) else None)) * 9622116.25), 'u': Std.parseFloat((f5[1] if 1 < len(f5) else None)), 'v': Std.parseFloat((f5[2] if 2 < len(f5) else None))})
                                            _g9.append(x3)
                                        frames = _g9
                                        if (self.uvAnims is None):
                                            self.uvAnims = haxe_ds_StringMap()
                                        this3 = self.uvAnims
                                        key = hxd_fmt_fbx_FbxTools.getName(m)
                                        this3.h[key] = frames
                                else:
                                    pass
                            else:
                                pass
                    else:
                        pass
                else:
                    pass

    def toFloats(self,n):
        _g = (n.props[0] if 0 < len(n.props) else None)
        tmp = _g.index
        if (tmp == 4):
            vl = _g.params[0]
            _g1 = []
            _g2 = 0
            while (_g2 < len(vl)):
                v = (vl[_g2] if _g2 >= 0 and _g2 < len(vl) else None)
                _g2 = (_g2 + 1)
                _g1.append(v)
            vl = _g1
            python_internal_ArrayImpl._set(n.props, 0, hxd_fmt_fbx_FbxProp.PFloats(vl))
            return vl
        elif (tmp == 5):
            vl = _g.params[0]
            return vl
        else:
            raise haxe_Exception.thrown((Std.string((n.props[0] if 0 < len(n.props) else None)) + " should be floats "))

    def getAllModels(self):
        return hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Model")

    def getRootModels(self):
        _g = []
        _g1 = 0
        _g2 = self.getAllModels()
        while (_g1 < len(_g2)):
            m = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            if self.isRootModel(m):
                _g.append(m)
        return _g

    def isRootModel(self,m):
        return (self.getParent(m,"Model",True) is None)

    def updateModelScale(self):
        unitScale = 1
        originScale = 1
        upAxis = 1
        originalUpAxis = 2
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"GlobalSettings.Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
            _hx_local_1 = len(_g2)
            if (_hx_local_1 == 15):
                if (_g2 == "UnitScaleFactor"):
                    unitScale = hxd_fmt_fbx_FbxTools.toInt((p.props[4] if 4 < len(p.props) else None))
                else:
                    pass
            elif (_hx_local_1 == 23):
                if (_g2 == "OriginalUnitScaleFactor"):
                    originScale = hxd_fmt_fbx_FbxTools.toInt((p.props[4] if 4 < len(p.props) else None))
                else:
                    pass
            elif (_hx_local_1 == 14):
                if (_g2 == "OriginalUpAxis"):
                    originalUpAxis = hxd_fmt_fbx_FbxTools.toInt((p.props[4] if 4 < len(p.props) else None))
                else:
                    pass
            elif (_hx_local_1 == 6):
                if (_g2 == "UpAxis"):
                    upAxis = hxd_fmt_fbx_FbxTools.toInt((p.props[4] if 4 < len(p.props) else None))
                else:
                    pass
            else:
                pass
        scaleFactor = (100 if (((unitScale == 100) and ((originScale == 1)))) else 1)
        geometryScaleFactor = scaleFactor
        if (upAxis == 1):
            self.convertYupToZup(originalUpAxis)
        app = ""
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"FBXHeaderExtension.SceneInfo.Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None)) == "LastSaved|ApplicationName"):
                app = hxd_fmt_fbx_FbxTools.toString((p.props[4] if 4 < len(p.props) else None))
        startIndex = None
        if ((((app.find("Blender") if ((startIndex is None)) else HxString.indexOfImpl(app,"Blender",startIndex))) >= 0) and ((unitScale == originScale))):
            scaleFactor = (unitScale / 100)
        if ((scaleFactor == 1) and ((geometryScaleFactor == 1))):
            return
        if (geometryScaleFactor != 1):
            _g = 0
            _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry.Vertices")
            while (_g < len(_g1)):
                g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                v = self.toFloats(g)
                _g2 = 0
                _g3 = len(v)
                while (_g2 < _g3):
                    i = _g2
                    _g2 = (_g2 + 1)
                    python_internal_ArrayImpl._set(v, i, ((v[i] if i >= 0 and i < len(v) else None) / geometryScaleFactor))
        if (scaleFactor == 1):
            return
        _g = 0
        _g1 = self.getAllModels()
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            isRoot = self.isRootModel(m)
            _g2 = 0
            _g3 = hxd_fmt_fbx_FbxTools.getAll(m,"Properties70.P")
            while (_g2 < len(_g3)):
                p = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                _g4 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
                _hx_local_7 = len(_g4)
                if (_hx_local_7 == 15):
                    if (_g4 == "Lcl Translation"):
                        if (not isRoot):
                            idx = 4
                            v = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx] if idx >= 0 and idx < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx, hxd_fmt_fbx_FbxProp.PFloat((v / scaleFactor)))
                            idx1 = 5
                            v1 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx1] if idx1 >= 0 and idx1 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx1, hxd_fmt_fbx_FbxProp.PFloat((v1 / scaleFactor)))
                            idx2 = 6
                            v2 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx2] if idx2 >= 0 and idx2 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx2, hxd_fmt_fbx_FbxProp.PFloat((v2 / scaleFactor)))
                    else:
                        pass
                elif (_hx_local_7 == 11):
                    if (_g4 == "Lcl Scaling"):
                        if isRoot:
                            idx3 = 4
                            v3 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx3] if idx3 >= 0 and idx3 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx3, hxd_fmt_fbx_FbxProp.PFloat((v3 * scaleFactor)))
                            idx4 = 5
                            v4 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx4] if idx4 >= 0 and idx4 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx4, hxd_fmt_fbx_FbxProp.PFloat((v4 * scaleFactor)))
                            idx5 = 6
                            v5 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx5] if idx5 >= 0 and idx5 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx5, hxd_fmt_fbx_FbxProp.PFloat((v5 * scaleFactor)))
                    else:
                        pass
                elif (_hx_local_7 == 20):
                    if (_g4 == "GeometricTranslation"):
                        if (not isRoot):
                            idx = 4
                            v = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx] if idx >= 0 and idx < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx, hxd_fmt_fbx_FbxProp.PFloat((v / scaleFactor)))
                            idx1 = 5
                            v1 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx1] if idx1 >= 0 and idx1 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx1, hxd_fmt_fbx_FbxProp.PFloat((v1 / scaleFactor)))
                            idx2 = 6
                            v2 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx2] if idx2 >= 0 and idx2 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx2, hxd_fmt_fbx_FbxProp.PFloat((v2 / scaleFactor)))
                    else:
                        pass
                else:
                    pass
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Deformer.Transform")
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            m = self.toFloats(t)
            _hx_local_9 = m
            _hx_local_10 = 12
            _hx_local_11 = (_hx_local_9[_hx_local_10] if _hx_local_10 >= 0 and _hx_local_10 < len(_hx_local_9) else None)
            python_internal_ArrayImpl._set(_hx_local_9, _hx_local_10, (_hx_local_11 / scaleFactor))
            (_hx_local_9[_hx_local_10] if _hx_local_10 >= 0 and _hx_local_10 < len(_hx_local_9) else None)
            _hx_local_12 = m
            _hx_local_13 = 13
            _hx_local_14 = (_hx_local_12[_hx_local_13] if _hx_local_13 >= 0 and _hx_local_13 < len(_hx_local_12) else None)
            python_internal_ArrayImpl._set(_hx_local_12, _hx_local_13, (_hx_local_14 / scaleFactor))
            (_hx_local_12[_hx_local_13] if _hx_local_13 >= 0 and _hx_local_13 < len(_hx_local_12) else None)
            _hx_local_15 = m
            _hx_local_16 = 14
            _hx_local_17 = (_hx_local_15[_hx_local_16] if _hx_local_16 >= 0 and _hx_local_16 < len(_hx_local_15) else None)
            python_internal_ArrayImpl._set(_hx_local_15, _hx_local_16, (_hx_local_17 / scaleFactor))
            (_hx_local_15[_hx_local_16] if _hx_local_16 >= 0 and _hx_local_16 < len(_hx_local_15) else None)
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.AnimationCurveNode")
        while (_g < len(_g1)):
            n = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            name = hxd_fmt_fbx_FbxTools.getName(n)
            model = self.getParent(n,"Model",True)
            isRoot = ((model is not None) and ((self.getParent(model,"Model",True) is None)))
            _g2 = 0
            _g3 = hxd_fmt_fbx_FbxTools.getAll(n,"Properties70.P")
            while (_g2 < len(_g3)):
                p = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                _g4 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
                if (((_g4 == "d|Z") or ((_g4 == "d|Y"))) or ((_g4 == "d|X"))):
                    if ((name == "T") and (not isRoot)):
                        python_internal_ArrayImpl._set(p.props, 4, hxd_fmt_fbx_FbxProp.PFloat((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) / scaleFactor)))
                    elif ((name == "S") and isRoot):
                        python_internal_ArrayImpl._set(p.props, 4, hxd_fmt_fbx_FbxProp.PFloat((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * scaleFactor)))
                else:
                    pass
            _g5 = 0
            _g6 = self.getChilds(n,"AnimationCurve")
            while (_g5 < len(_g6)):
                c = (_g6[_g5] if _g5 >= 0 and _g5 < len(_g6) else None)
                _g5 = (_g5 + 1)
                vl = self.toFloats(hxd_fmt_fbx_FbxTools.get(c,"KeyValueFloat"))
                if (name is not None):
                    name1 = name
                    if (name1 == "S"):
                        if isRoot:
                            _g7 = 0
                            _g8 = len(vl)
                            while (_g7 < _g8):
                                i = _g7
                                _g7 = (_g7 + 1)
                                python_internal_ArrayImpl._set(vl, i, ((vl[i] if i >= 0 and i < len(vl) else None) * scaleFactor))
                    elif (name1 == "T"):
                        if (not isRoot):
                            _g9 = 0
                            _g10 = len(vl)
                            while (_g9 < _g10):
                                i1 = _g9
                                _g9 = (_g9 + 1)
                                python_internal_ArrayImpl._set(vl, i1, ((vl[i1] if i1 >= 0 and i1 < len(vl) else None) / scaleFactor))
                    else:
                        pass

    def convertYupToZup(self,originalUpAxis):
        originalUpAxis1 = originalUpAxis
        if ((originalUpAxis1 == 1) or ((originalUpAxis1 == -1))):
            _g = 0
            _g1 = self.getRootModels()
            while (_g < len(_g1)):
                m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                needPreRot = True
                _g2 = 0
                _g3 = hxd_fmt_fbx_FbxTools.getAll(self.root,"GlobalSettings.Properties70.P")
                while (_g2 < len(_g3)):
                    c = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if ((((hxd_fmt_fbx_FbxTools.toString((c.props[0] if 0 < len(c.props) else None)) == "PreRotation") and ((hxd_fmt_fbx_FbxTools.toFloat((c.props[4] if 4 < len(c.props) else None)) == 90))) and ((hxd_fmt_fbx_FbxTools.toFloat((c.props[5] if 5 < len(c.props) else None)) == 0))) and ((hxd_fmt_fbx_FbxTools.toFloat((c.props[6] if 6 < len(c.props) else None)) == 0))):
                        needPreRot = False
                        break
                if needPreRot:
                    preRotProp = _hx_AnonObject({'name': "P", 'props': [hxd_fmt_fbx_FbxProp.PString("PreRotation"), hxd_fmt_fbx_FbxProp.PString("Vector3D"), hxd_fmt_fbx_FbxProp.PString("Vector"), hxd_fmt_fbx_FbxProp.PString(""), hxd_fmt_fbx_FbxProp.PFloat(90), hxd_fmt_fbx_FbxProp.PFloat(0), hxd_fmt_fbx_FbxProp.PFloat(0)], 'childs': []})
                    hxd_fmt_fbx_FbxTools.get(m,"Properties70").childs.insert(0, preRotProp)
        elif (originalUpAxis1 == 2):
            _g = 0
            _g1 = self.getRootModels()
            while (_g < len(_g1)):
                rootObject = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                props = hxd_fmt_fbx_FbxTools.get(rootObject,"Properties70")
                _g2 = 0
                _g3 = props.childs
                while (_g2 < len(_g3)):
                    c = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if ((((hxd_fmt_fbx_FbxTools.toString((c.props[0] if 0 < len(c.props) else None)) == "PreRotation") and ((hxd_fmt_fbx_FbxTools.toFloat((c.props[4] if 4 < len(c.props) else None)) == -90))) and ((hxd_fmt_fbx_FbxTools.toFloat((c.props[5] if 5 < len(c.props) else None)) == 0))) and ((hxd_fmt_fbx_FbxTools.toFloat((c.props[6] if 6 < len(c.props) else None)) == 0))):
                        python_internal_ArrayImpl.remove(props.childs,c)
                        break
        else:
            raise haxe_Exception.thrown((("From Y-up to Z-up with orginalUpAxis = " + Std.string(originalUpAxis)) + " not implemented."))

    def convertPoints(self,a):
        p = 0
        _g = 0
        x = (len(a) / 3)
        _g1 = None
        try:
            _g1 = int(x)
        except BaseException as _g2:
            None
            _g1 = None
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(a, p, -(a[p] if p >= 0 and p < len(a) else None))
            p = (p + 3)

    def leftHandConvert(self):
        if self.leftHand:
            return
        self.leftHand = True
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry")
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = 0
            _g3 = hxd_fmt_fbx_FbxTools.getAll(g,"Vertices")
            while (_g2 < len(_g3)):
                v = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v))
            _g4 = 0
            _g5 = hxd_fmt_fbx_FbxTools.getAll(g,"LayerElementNormal.Normals")
            while (_g4 < len(_g5)):
                v1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v1))
            _g6 = 0
            _g7 = hxd_fmt_fbx_FbxTools.getAll(g,"LayerElementTangent.Tangents")
            while (_g6 < len(_g7)):
                v2 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                _g6 = (_g6 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v2))
            _g8 = 0
            _g9 = hxd_fmt_fbx_FbxTools.getAll(g,"LayerElementBinormal.Binormals")
            while (_g8 < len(_g9)):
                v3 = (_g9[_g8] if _g8 >= 0 and _g8 < len(_g9) else None)
                _g8 = (_g8 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v3))

    def init(self,n):
        _g = n.name
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 11):
            if (_g == "Connections"):
                _g = 0
                _g1 = n.childs
                while (_g < len(_g1)):
                    c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    if (c.name != "C"):
                        continue
                    child = hxd_fmt_fbx_FbxTools.toInt((c.props[1] if 1 < len(c.props) else None))
                    parent = hxd_fmt_fbx_FbxTools.toInt((c.props[2] if 2 < len(c.props) else None))
                    if ((self.ids.h.get(child,None) is None) or ((self.ids.h.get(parent,None) is None))):
                        continue
                    name = (c.props[3] if 3 < len(c.props) else None)
                    if (name is not None):
                        name1 = hxd_fmt_fbx_FbxTools.toString(name)
                        nc = self.namedConnect.h.get(parent,None)
                        if (nc is None):
                            nc = haxe_ds_StringMap()
                            self.namedConnect.set(parent,nc)
                        nc.h[name1] = child
                        if (name1 == "LookAtProperty"):
                            continue
                    c1 = self.connect.h.get(parent,None)
                    if (c1 is None):
                        c1 = []
                        self.connect.set(parent,c1)
                    c1.append(child)
                    if (parent == 0):
                        continue
                    c2 = self.invConnect.h.get(child,None)
                    if (c2 is None):
                        c2 = []
                        self.invConnect.set(child,c2)
                    c2.append(parent)
            else:
                pass
        elif (_hx_local_0 == 7):
            if (_g == "Objects"):
                _g = 0
                _g1 = n.childs
                while (_g < len(_g1)):
                    c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    self.ids.set(hxd_fmt_fbx_FbxTools.getId(c),c)
            else:
                pass
        else:
            pass

    def getGeometry(self,name = None):
        if (name is None):
            name = ""
        geom = None
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry")
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if hxd_fmt_fbx_FbxTools.hasProp(g,hxd_fmt_fbx_FbxProp.PString(("Geometry::" + ("null" if name is None else name)))):
                geom = g
                break
        if (geom is None):
            raise haxe_Exception.thrown((("Geometry " + ("null" if name is None else name)) + " not found"))
        return hxd_fmt_fbx_Geometry(self,geom)

    def getParent(self,node,nodeName,opt = None):
        p = self.getParents(node,nodeName)
        if (len(p) > 1):
            tmp = (((((HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node)) + " has ") + Std.string(len(p))) + " ") + ("null" if nodeName is None else nodeName)) + " parents ")
            _g = []
            _g1 = 0
            while (_g1 < len(p)):
                o = (p[_g1] if _g1 >= 0 and _g1 < len(p) else None)
                _g1 = (_g1 + 1)
                x = hxd_fmt_fbx_FbxTools.getName(o)
                _g.append(x)
            raise haxe_Exception.thrown((("null" if tmp is None else tmp) + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))))
        if ((len(p) == 0) and (not opt)):
            raise haxe_Exception.thrown((((("Missing " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node))) + " ") + ("null" if nodeName is None else nodeName)) + " parent"))
        return (p[0] if 0 < len(p) else None)

    def getChild(self,node,nodeName,opt = None):
        c = self.getChilds(node,nodeName)
        if (len(c) > 1):
            tmp = (((((HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node)) + " has ") + Std.string(len(c))) + " ") + ("null" if nodeName is None else nodeName)) + " childs ")
            _g = []
            _g1 = 0
            while (_g1 < len(c)):
                o = (c[_g1] if _g1 >= 0 and _g1 < len(c) else None)
                _g1 = (_g1 + 1)
                x = hxd_fmt_fbx_FbxTools.getName(o)
                _g.append(x)
            raise haxe_Exception.thrown((("null" if tmp is None else tmp) + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))))
        if ((len(c) == 0) and (not opt)):
            raise haxe_Exception.thrown((((("Missing " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node))) + " ") + ("null" if nodeName is None else nodeName)) + " child"))
        return (c[0] if 0 < len(c) else None)

    def getSpecChild(self,node,name):
        this1 = self.namedConnect
        key = hxd_fmt_fbx_FbxTools.getId(node)
        nc = this1.h.get(key,None)
        if (nc is None):
            return None
        id = nc.h.get(name,None)
        if (id is None):
            return None
        return self.ids.h.get(id,None)

    def getChilds(self,node,nodeName = None):
        this1 = self.connect
        key = hxd_fmt_fbx_FbxTools.getId(node)
        c = this1.h.get(key,None)
        subs = []
        if (c is not None):
            _g = 0
            while (_g < len(c)):
                id = (c[_g] if _g >= 0 and _g < len(c) else None)
                _g = (_g + 1)
                n = self.ids.h.get(id,None)
                if (n is None):
                    raise haxe_Exception.thrown((Std.string(id) + " not found"))
                if ((nodeName is not None) and ((n.name != nodeName))):
                    continue
                subs.append(n)
        return subs

    def getParents(self,node,nodeName = None):
        this1 = self.invConnect
        key = hxd_fmt_fbx_FbxTools.getId(node)
        c = this1.h.get(key,None)
        pl = []
        if (c is not None):
            _g = 0
            while (_g < len(c)):
                id = (c[_g] if _g >= 0 and _g < len(c) else None)
                _g = (_g + 1)
                n = self.ids.h.get(id,None)
                if (n is None):
                    raise haxe_Exception.thrown((Std.string(id) + " not found"))
                if ((nodeName is not None) and ((n.name != nodeName))):
                    continue
                pl.append(n)
        return pl

    def getRoot(self):
        return self.root

    def ignoreMissingObject(self,id):
        _hx_def = self.defaultModelMatrixes.h.get(id,None)
        if (_hx_def is None):
            _hx_def = hxd_fmt_fbx_DefaultMatrixes()
            _hx_def.wasRemoved = -2
            self.defaultModelMatrixes.set(id,_hx_def)

    def buildHierarchy(self):
        oroot = hxd_fmt_fbx_TmpObject()
        objects = list()
        hobjects = haxe_ds_IntMap()
        hobjects.set(0,oroot)
        _g = 0
        _g1 = self.getAllModels()
        while (_g < len(_g1)):
            model = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            this1 = self.skipObjects
            key = hxd_fmt_fbx_FbxTools.getName(model)
            if this1.h.get(key,None):
                continue
            mtype = hxd_fmt_fbx_FbxTools.getType(model)
            isJoint = ((mtype == "LimbNode") and (((not self.unskinnedJointsAsObjects) or (not self.isNullJoint(model)))))
            o = hxd_fmt_fbx_TmpObject()
            o.model = model
            o.isJoint = isJoint
            o.isMesh = (mtype == "Mesh")
            hobjects.set(hxd_fmt_fbx_FbxTools.getId(model),o)
            objects.append(o)
        _g = 0
        while (_g < len(objects)):
            o = (objects[_g] if _g >= 0 and _g < len(objects) else None)
            _g = (_g + 1)
            p = self.getParent(o.model,"Model",True)
            pid = (0 if ((p is None)) else hxd_fmt_fbx_FbxTools.getId(p))
            op = hobjects.h.get(pid,None)
            if (op is None):
                op = oroot
            _this = op.childs
            _this.append(o)
            o.parent = op
        _g = 0
        while (_g < len(objects)):
            o = (objects[_g] if _g >= 0 and _g < len(objects) else None)
            _g = (_g + 1)
            if (not o.isMesh):
                continue
            g = self.getChild(o.model,"Geometry")
            _hx_def = self.getChild(g,"Deformer",True)
            if (_hx_def is None):
                continue
            _g1 = []
            _g2 = 0
            _g3 = self.getChilds(_hx_def,"Deformer")
            while (_g2 < len(_g3)):
                d = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                key = hxd_fmt_fbx_FbxTools.getId(self.getChild(d,"Model"))
                x = hobjects.h.get(key,None)
                _g1.append(x)
            bones = _g1
            if (len(bones) == 0):
                continue
            o1 = (bones[0] if 0 < len(bones) else None)
            k = 0
            while (o1 != oroot):
                o1 = o1.parent
                k = (k + 1)
            minDepth = k
            _g4 = 1
            _g5 = len(bones)
            while (_g4 < _g5):
                i = _g4
                _g4 = (_g4 + 1)
                o2 = (bones[i] if i >= 0 and i < len(bones) else None)
                k1 = 0
                while (o2 != oroot):
                    o2 = o2.parent
                    k1 = (k1 + 1)
                d1 = k1
                if (d1 < minDepth):
                    minDepth = d1
            out = []
            _g6 = 0
            _g7 = len(bones)
            while (_g6 < _g7):
                i1 = _g6
                _g6 = (_g6 + 1)
                b = (bones[i1] if i1 >= 0 and i1 < len(bones) else None)
                o3 = b
                k2 = 0
                while (o3 != oroot):
                    o3 = o3.parent
                    k2 = (k2 + 1)
                n = (k2 - minDepth)
                _g8 = 0
                _g9 = n
                while (_g8 < _g9):
                    i2 = _g8
                    _g8 = (_g8 + 1)
                    b.isJoint = True
                    b = b.parent
                python_internal_ArrayImpl.remove(out,b)
                out.append(b)
            bones = out
            while (len(bones) > 1):
                _g10 = 0
                while (_g10 < len(bones)):
                    b1 = (bones[_g10] if _g10 >= 0 and _g10 < len(bones) else None)
                    _g10 = (_g10 + 1)
                    b1.isJoint = True
                parents = []
                _g11 = 0
                while (_g11 < len(bones)):
                    b2 = (bones[_g11] if _g11 >= 0 and _g11 < len(bones) else None)
                    _g11 = (_g11 + 1)
                    if ((b2.parent == oroot) or b2.parent.isMesh):
                        continue
                    python_internal_ArrayImpl.remove(parents,b2.parent)
                    x1 = b2.parent
                    parents.append(x1)
                bones = parents
        changed = True
        while changed:
            changed = False
            _g = 0
            while (_g < len(objects)):
                o = (objects[_g] if _g >= 0 and _g < len(objects) else None)
                _g = (_g + 1)
                if (o.isJoint or o.isMesh):
                    continue
                if o.parent.isJoint:
                    o.isJoint = True
                    changed = True
                    continue
                hasJoint = False
                _g1 = 0
                _g2 = o.childs
                while (_g1 < len(_g2)):
                    c = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                    _g1 = (_g1 + 1)
                    if c.isJoint:
                        hasJoint = True
                        break
                if hasJoint:
                    _g3 = 0
                    _g4 = o.parent.childs
                    while (_g3 < len(_g4)):
                        c1 = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                        _g3 = (_g3 + 1)
                        if c1.isJoint:
                            o.isJoint = True
                            changed = True
                            break
        return _hx_AnonObject({'root': oroot, 'objects': objects})

    def getObjectCurve(self,curves,model,curveName,animName):
        key = hxd_fmt_fbx_FbxTools.getId(model)
        c = curves.h.get(key,None)
        if (c is not None):
            return c
        name = hxd_fmt_fbx_FbxTools.getName(model)
        if self.skipObjects.h.get(name,None):
            return None
        _hx_def = self.getDefaultMatrixes(model)
        if (_hx_def is None):
            return None
        isMove = ((curveName != "Visibility") and ((curveName != "UV")))
        if ((_hx_def.wasRemoved is not None) and ((isMove or ((_hx_def.wasRemoved == -1))))):
            return None
        if ((_hx_def.wasRemoved is not None) and ((_hx_def.wasRemoved != -2))):
            model = self.ids.h.get(_hx_def.wasRemoved,None)
            name = hxd_fmt_fbx_FbxTools.getName(model)
            c = curves.h.get(_hx_def.wasRemoved,None)
            _hx_def = self.getDefaultMatrixes(model)
            if (_hx_def is None):
                raise haxe_Exception.thrown("assert")
        if (c is None):
            c = hxd_fmt_fbx__BaseLibrary_AnimCurve(_hx_def,name)
            curves.set(hxd_fmt_fbx_FbxTools.getId(model),c)
        return c

    def mergeModels(self,modelNames):
        if (len(modelNames) <= 1):
            return
        models = self.getAllModels()
        def _hx_local_1(name):
            _g = 0
            while (_g < len(models)):
                m = (models[_g] if _g >= 0 and _g < len(models) else None)
                _g = (_g + 1)
                if (hxd_fmt_fbx_FbxTools.getName(m) == name):
                    return m
            raise haxe_Exception.thrown(("Model not found " + ("null" if name is None else name)))
        getModel = _hx_local_1
        m = getModel((modelNames[0] if 0 < len(modelNames) else None))
        geom = hxd_fmt_fbx_Geometry(self,self.getChild(m,"Geometry"))
        _hx_def = self.getChild(geom.getRoot(),"Deformer",True)
        subDefs = self.getChilds(_hx_def,"Deformer")
        _g = 1
        _g1 = len(modelNames)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            name = (modelNames[i] if i >= 0 and i < len(modelNames) else None)
            m2 = getModel(name)
            geom2 = hxd_fmt_fbx_Geometry(self,self.getChild(m2,"Geometry"))
            x = (len(geom.getVertices()) / 3)
            vcount = None
            try:
                vcount = int(x)
            except BaseException as _g2:
                None
                vcount = None
            self.skipObjects.h[name] = True
            mindex = []
            materials = self.getChilds(m,"Material")
            _g3 = 0
            _g4 = self.getChilds(m2,"Material")
            while (_g3 < len(_g4)):
                mat = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                _g3 = (_g3 + 1)
                idx = python_internal_ArrayImpl.indexOf(materials,mat,None)
                if (idx < 0):
                    idx = len(materials)
                    materials.append(mat)
                    self.addLink(m,mat)
                mindex.append(idx)
            geom.merge(geom2,mindex)
            def2 = self.getChild(geom2.getRoot(),"Deformer",True)
            if (def2 is not None):
                if (_hx_def is None):
                    raise haxe_Exception.thrown((((HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m)) + " does not have a deformer but ") + ("null" if name is None else name)) + " has one"))
                _g5 = 0
                _g6 = self.getChilds(def2,"Deformer")
                while (_g5 < len(_g6)):
                    subDef = (_g6[_g5] if _g5 >= 0 and _g5 < len(_g6) else None)
                    _g5 = (_g5 + 1)
                    subModel = self.getChild(subDef,"Model")
                    prevDef = None
                    _g7 = 0
                    while (_g7 < len(subDefs)):
                        s = (subDefs[_g7] if _g7 >= 0 and _g7 < len(subDefs) else None)
                        _g7 = (_g7 + 1)
                        if (self.getChild(s,"Model") == subModel):
                            prevDef = s
                            break
                    if (prevDef is not None):
                        self.removeLink(subDef,subModel)
                    idx1 = hxd_fmt_fbx_FbxTools.get(subDef,"Indexes",True)
                    if (idx1 is None):
                        continue
                    if (prevDef is None):
                        self.addLink(_hx_def,subDef)
                        self.removeLink(def2,subDef)
                        subDefs.append(subDef)
                        idx2 = hxd_fmt_fbx_FbxTools.getInts(idx1)
                        _g8 = 0
                        _g9 = len(idx2)
                        while (_g8 < _g9):
                            i1 = _g8
                            _g8 = (_g8 + 1)
                            python_internal_ArrayImpl._set(idx2, i1, ((idx2[i1] if i1 >= 0 and i1 < len(idx2) else None) + vcount))
                    else:
                        pidx = hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(prevDef,"Indexes"))
                        _g10 = 0
                        _g11 = hxd_fmt_fbx_FbxTools.getInts(idx1)
                        while (_g10 < len(_g11)):
                            i2 = (_g11[_g10] if _g10 >= 0 and _g10 < len(_g11) else None)
                            _g10 = (_g10 + 1)
                            pidx.append((i2 + vcount))
                        weights = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(prevDef,"Weights"))
                        _g12 = 0
                        _g13 = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(subDef,"Weights"))
                        while (_g12 < len(_g13)):
                            w = (_g13[_g12] if _g12 >= 0 and _g12 < len(_g13) else None)
                            _g12 = (_g12 + 1)
                            weights.append(w)

    def addLink(self,parent,child):
        pid = hxd_fmt_fbx_FbxTools.getId(parent)
        nid = hxd_fmt_fbx_FbxTools.getId(child)
        _this = self.connect.h.get(pid,None)
        _this.append(nid)
        _this = self.invConnect.h.get(nid,None)
        _this.append(pid)

    def removeLink(self,parent,child):
        pid = hxd_fmt_fbx_FbxTools.getId(parent)
        nid = hxd_fmt_fbx_FbxTools.getId(child)
        python_internal_ArrayImpl.remove(self.connect.h.get(pid,None),nid)
        python_internal_ArrayImpl.remove(self.invConnect.h.get(nid,None),pid)

    def checkData(self,t):
        if (t is None):
            return True
        if (t.x is not None):
            v = (t.x[0] if 0 < len(t.x) else None)
            _g = 0
            _g1 = t.x
            while (_g < len(_g1)):
                v2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v != v2):
                    return False
        if (t.y is not None):
            v = (t.y[0] if 0 < len(t.y) else None)
            _g = 0
            _g1 = t.y
            while (_g < len(_g1)):
                v2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v != v2):
                    return False
        if (t.z is not None):
            v = (t.z[0] if 0 < len(t.z) else None)
            _g = 0
            _g1 = t.z
            while (_g < len(_g1)):
                v2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v != v2):
                    return False
        return True

    def roundValues(self,data,_hx_def,mult = None):
        if (mult is None):
            mult = 1.
        hasValue = False
        _g = 0
        _g1 = len(data)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            v = ((data[i] if i >= 0 and i < len(data) else None) * mult)
            f = (v - _hx_def)
            if (((-f if ((f < 0)) else f)) > 1e-3):
                hasValue = True
            else:
                v = _hx_def
            python_internal_ArrayImpl._set(data, i, self.round(v))
        return hasValue

    def getAnimationNames(self):
        names = []
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.AnimationStack")
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (len(self.getChilds(a,"AnimationLayer")) > 0):
                x = hxd_fmt_fbx_FbxTools.getName(a)
                names.append(x)
        return names

    def loadAnimation(self,animName = None,root = None,lib = None):
        if (lib is not None):
            lib.defaultModelMatrixes = self.defaultModelMatrixes
            return lib.loadAnimation(animName)
        if (root is not None):
            l = hxd_fmt_fbx_BaseLibrary(self.fileName)
            l.normalizeScaleOrient = self.normalizeScaleOrient
            l.load(root)
            if self.leftHand:
                l.leftHandConvert()
            l.defaultModelMatrixes = self.defaultModelMatrixes
            return l.loadAnimation(animName)
        defNode = None
        animNodes = []
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.AnimationStack")
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((animName is None) or ((hxd_fmt_fbx_FbxTools.getName(a) == animName))):
                _g2 = 0
                _g3 = self.getChilds(a,"AnimationLayer")
                while (_g2 < len(_g3)):
                    n = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    defNode = n
                    if (len(self.getChilds(n,"AnimationCurveNode")) > 0):
                        animNodes.append(n)
        animNode = None
        _g = len(animNodes)
        if (_g == 0):
            animNode = defNode
        elif (_g == 1):
            animNode = (animNodes[0] if 0 < len(animNodes) else None)
        else:
            haxe_Log.trace("Multiple animation layers curves are currently not supported",_hx_AnonObject({'fileName': "hxd/fmt/fbx/BaseLibrary.hx", 'lineNumber': 827, 'className': "hxd.fmt.fbx.BaseLibrary", 'methodName': "loadAnimation"}))
            animNode = (animNodes[0] if 0 < len(animNodes) else None)
        if (animNode is None):
            if (animName is not None):
                raise haxe_Exception.thrown(("Animation not found " + ("null" if animName is None else animName)))
            if (self.uvAnims is None):
                return None
        if (animName is None):
            animName = hxd_fmt_fbx_FbxTools.getName(self.getParent(animNode,"AnimationStack"))
        curves = haxe_ds_IntMap()
        P0 = h3d_col_Point()
        P1 = h3d_col_Point(1,1,1)
        F = 0.0174532925199432955
        allTimes = haxe_ds_IntMap()
        if (animNode is not None):
            _g = 0
            _g1 = self.getChilds(animNode,"AnimationCurveNode")
            while (_g < len(_g1)):
                cn = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                model = self.getParent(cn,"Model",True)
                if (model is None):
                    _g2 = hxd_fmt_fbx_FbxTools.getName(cn)
                    if (_g2 is None):
                        continue
                    else:
                        _g3 = _g2
                        _hx_local_3 = len(_g3)
                        if (_hx_local_3 == 11):
                            if (_g3 == "FieldOfView"):
                                nattr = self.getParent(cn,"NodeAttribute",True)
                                model = (None if ((nattr is None)) else self.getParent(nattr,"Model",True))
                                if (model is None):
                                    continue
                            else:
                                continue
                        elif (_hx_local_3 == 4):
                            if (_g3 == "Roll"):
                                nattr = self.getParent(cn,"NodeAttribute",True)
                                model = (None if ((nattr is None)) else self.getParent(nattr,"Model",True))
                                if (model is None):
                                    continue
                            else:
                                continue
                        else:
                            continue
                c = self.getObjectCurve(curves,model,hxd_fmt_fbx_FbxTools.getName(cn),animName)
                if (c is None):
                    continue
                dataCurves = self.getChilds(cn,"AnimationCurve")
                if (len(dataCurves) == 0):
                    continue
                cname = hxd_fmt_fbx_FbxTools.getName(cn)
                times = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get((dataCurves[0] if 0 < len(dataCurves) else None),"KeyTime"))
                _g4 = 0
                _g5 = len(times)
                while (_g4 < _g5):
                    i = _g4
                    _g4 = (_g4 + 1)
                    t = (times[i] if i >= 0 and i < len(times) else None)
                    if (HxOverrides.modf(t, 100) != 0):
                        t = (t + ((100 - (HxOverrides.modf(t, 100)))))
                        python_internal_ArrayImpl._set(times, i, t)
                    it = None
                    try:
                        it = int((t / 200000))
                    except BaseException as _g6:
                        None
                        it = None
                    it1 = it
                    allTimes.set(it1,t)
                if (len(dataCurves) != 3):
                    values = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get((dataCurves[0] if 0 < len(dataCurves) else None),"KeyValueFloat"))
                    if (cname is not None):
                        cname1 = cname
                        _hx_local_5 = len(cname1)
                        if (_hx_local_5 == 10):
                            if (cname1 == "Visibility"):
                                if (not self.roundValues(values,1)):
                                    continue
                                c.a = _hx_AnonObject({'v': values, 't': times})
                                continue
                            else:
                                pass
                        elif (_hx_local_5 == 11):
                            if (cname1 == "FieldOfView"):
                                ratio = 1.77777777777777768
                                fov = 45.
                                _g7 = 0
                                _g8 = hxd_fmt_fbx_FbxTools.getAll(self.getChild(model,"NodeAttribute"),"Properties70.P")
                                while (_g7 < len(_g8)):
                                    p = (_g8[_g7] if _g7 >= 0 and _g7 < len(_g8) else None)
                                    _g7 = (_g7 + 1)
                                    _g9 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
                                    _hx_local_7 = len(_g9)
                                    if (_hx_local_7 == 15):
                                        if (_g9 == "FilmAspectRatio"):
                                            ratio = hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))
                                        else:
                                            pass
                                    elif (_hx_local_7 == 11):
                                        if (_g9 == "FieldOfView"):
                                            fov = hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))
                                        else:
                                            pass
                                    else:
                                        pass
                                _g10 = 0
                                _g11 = len(values)
                                while (_g10 < _g11):
                                    i1 = _g10
                                    _g10 = (_g10 + 1)
                                    python_internal_ArrayImpl._set(values, i1, (((2 * Math.atan((Math.tan(((((values[i1] if i1 >= 0 and i1 < len(values) else None) * 0.5) * 3.14159265358979323) / 180)) / ratio))) * 180) / 3.14159265358979323))
                                if (not self.roundValues(values,(((2 * Math.atan((Math.tan((((fov * 0.5) * 3.14159265358979323) / 180)) / ratio))) * 180) / 3.14159265358979323))):
                                    continue
                                c.fov = _hx_AnonObject({'v': values, 't': times})
                                continue
                            else:
                                pass
                        elif (_hx_local_5 == 4):
                            if (cname1 == "Roll"):
                                if (not self.roundValues(values,0)):
                                    continue
                                c.roll = _hx_AnonObject({'v': values, 't': times})
                                continue
                            else:
                                pass
                        else:
                            pass
                data = _hx_AnonObject({'x': None, 'y': None, 'z': None, 't': times})
                this1 = self.namedConnect
                key = hxd_fmt_fbx_FbxTools.getId(cn)
                curves1 = this1.h.get(key,None)
                cname2 = curves1.keys()
                while cname2.hasNext():
                    cname3 = cname2.next()
                    this2 = self.ids
                    key1 = curves1.h.get(cname3,None)
                    values1 = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(this2.h.get(key1,None),"KeyValueFloat"))
                    cname4 = cname3
                    if (cname4 == "d|X"):
                        data.x = values1
                    elif (cname4 == "d|Y"):
                        data.y = values1
                    elif (cname4 == "d|Z"):
                        data.z = values1
                    else:
                        haxe_Log.trace(("Unsupported key name " + ("null" if cname3 is None else cname3)),_hx_AnonObject({'fileName': "hxd/fmt/fbx/BaseLibrary.hx", 'lineNumber': 942, 'className': "hxd.fmt.fbx.BaseLibrary", 'methodName': "loadAnimation"}))
                M = 1.0
                _hx_def = None
                if (cname is None):
                    haxe_Log.trace(((("Unknown curve " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(model))) + ".") + ("null" if cname is None else cname)),_hx_AnonObject({'fileName': "hxd/fmt/fbx/BaseLibrary.hx", 'lineNumber': 969, 'className': "hxd.fmt.fbx.BaseLibrary", 'methodName': "loadAnimation"}))
                    continue
                else:
                    cname5 = cname
                    if (cname5 == "R"):
                        M = F
                        if ((c._hx_def.rotate is None) and ((c._hx_def.preRot is None))):
                            _hx_def = P0
                        elif (c._hx_def.rotate is None):
                            _hx_def = c._hx_def.preRot
                        elif (c._hx_def.preRot is None):
                            _hx_def = c._hx_def.rotate
                        else:
                            q = h3d_Quat()
                            q2 = h3d_Quat()
                            q2.initRotation(c._hx_def.preRot.x,c._hx_def.preRot.y,c._hx_def.preRot.z)
                            q.initRotation(c._hx_def.rotate.x,c._hx_def.rotate.y,c._hx_def.rotate.z)
                            q.multiply(q2,q)
                            _this = q.toEuler()
                            _hx_def = h3d_col_Point(_this.x,_this.y,_this.z)
                    elif (cname5 == "S"):
                        _hx_def = (P1 if ((c._hx_def.scale is None)) else c._hx_def.scale)
                    elif (cname5 == "T"):
                        _hx_def = (P0 if ((c._hx_def.trans is None)) else c._hx_def.trans)
                    else:
                        haxe_Log.trace(((("Unknown curve " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(model))) + ".") + ("null" if cname is None else cname)),_hx_AnonObject({'fileName': "hxd/fmt/fbx/BaseLibrary.hx", 'lineNumber': 969, 'className': "hxd.fmt.fbx.BaseLibrary", 'methodName': "loadAnimation"}))
                        continue
                hasValue = False
                if ((data.x is not None) and self.roundValues(data.x,_hx_def.x,M)):
                    hasValue = True
                if ((data.y is not None) and self.roundValues(data.y,_hx_def.y,M)):
                    hasValue = True
                if ((data.z is not None) and self.roundValues(data.z,_hx_def.z,M)):
                    hasValue = True
                if (not hasValue):
                    continue
                keyCount = 0
                if (data.x is not None):
                    keyCount = len(data.x)
                if (data.y is not None):
                    keyCount = len(data.y)
                if (data.z is not None):
                    keyCount = len(data.z)
                if (data.x is None):
                    _g12 = []
                    _g13 = 0
                    _g14 = keyCount
                    while (_g13 < _g14):
                        i2 = _g13
                        _g13 = (_g13 + 1)
                        x = _hx_def.x
                        _g12.append(x)
                    data.x = _g12
                if (data.y is None):
                    _g15 = []
                    _g16 = 0
                    _g17 = keyCount
                    while (_g16 < _g17):
                        i3 = _g16
                        _g16 = (_g16 + 1)
                        x1 = _hx_def.y
                        _g15.append(x1)
                    data.y = _g15
                if (data.z is None):
                    _g18 = []
                    _g19 = 0
                    _g20 = keyCount
                    while (_g19 < _g20):
                        i4 = _g19
                        _g19 = (_g19 + 1)
                        x2 = _hx_def.z
                        _g18.append(x2)
                    data.z = _g18
                if (cname is None):
                    raise haxe_Exception.thrown("assert")
                else:
                    cname6 = cname
                    if (cname6 == "R"):
                        c.r = data
                    elif (cname6 == "S"):
                        c.s = data
                    elif (cname6 == "T"):
                        c.t = data
                    else:
                        raise haxe_Exception.thrown("assert")
        if (self.uvAnims is not None):
            modelByName = haxe_ds_StringMap()
            _g = 0
            _g1 = self.getAllModels()
            while (_g < len(_g1)):
                obj = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                key = hxd_fmt_fbx_FbxTools.getName(obj)
                modelByName.h[key] = obj
            obj = self.uvAnims.keys()
            while obj.hasNext():
                obj1 = obj.next()
                frames = self.uvAnims.h.get(obj1,None)
                model = modelByName.h.get(obj1,None)
                if (model is None):
                    raise haxe_Exception.thrown((("Missing model '" + ("null" if obj1 is None else obj1)) + "' required by UV animation"))
                c = self.getObjectCurve(curves,model,"UV",animName)
                if (c is None):
                    continue
                c.uv = frames
                _g = 0
                while (_g < len(frames)):
                    f = (frames[_g] if _g >= 0 and _g < len(frames) else None)
                    _g = (_g + 1)
                    x = (f.t / 200000)
                    key = None
                    try:
                        key = int(x)
                    except BaseException as _g1:
                        None
                        key = None
                    allTimes.set(key,f.t)
        _g = []
        a = allTimes.iterator()
        while a.hasNext():
            a1 = a.next()
            _g.append(a1)
        allTimes = _g
        if (len(allTimes) == 0):
            return None
        allTimes.sort(key= python_lib_Functools.cmp_to_key(self.sortDistinctFloats))
        maxTime = python_internal_ArrayImpl._get(allTimes, (len(allTimes) - 1))
        minDT = maxTime
        curT = (allTimes[0] if 0 < len(allTimes) else None)
        _g = 1
        _g1 = len(allTimes)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            t = (allTimes[i] if i >= 0 and i < len(allTimes) else None)
            dt = (t - curT)
            if (dt < minDT):
                minDT = dt
            curT = t
        numFrames = None
        if (maxTime == 0):
            numFrames = 1
        else:
            numFrames1 = None
            try:
                numFrames1 = int((((maxTime - (allTimes[0] if 0 < len(allTimes) else None))) / minDT))
            except BaseException as _g:
                None
                numFrames1 = None
            numFrames = (1 + numFrames1)
        sampling = (15.0 / ((minDT / 3079077200)))
        if (len(allTimes) < numFrames):
            t = (allTimes[0] if 0 < len(allTimes) else None)
            while (t < maxTime):
                if (python_internal_ArrayImpl.indexOf(allTimes,t,None) < 0):
                    allTimes.append(t)
                t = (t + minDT)
            allTimes.sort(key= python_lib_Functools.cmp_to_key(Reflect.compare))
            if (len(allTimes) > numFrames):
                tmp = (((("Animation " + ("null" if animName is None else animName)) + "(") + HxOverrides.stringOrNull(self.fileName)) + ") is not baked on a fixed framerate (detected ")
                tmp1 = None
                try:
                    tmp1 = int(sampling)
                except BaseException as _g:
                    None
                    tmp1 = None
                raise haxe_Exception.thrown(((("null" if tmp is None else tmp) + Std.string(tmp1)) + ")"))
            if (len(allTimes) < numFrames):
                raise haxe_Exception.thrown("assert")
        anim = h3d_anim_LinearAnimation(animName,numFrames,sampling)
        q = h3d_Quat()
        q2 = h3d_Quat()
        _g = []
        c = curves.iterator()
        while c.hasNext():
            c1 = c.next()
            _g.append(c1)
        sortedCurves = _g
        def _hx_local_11(c):
            if (c.roll is not None):
                return "roll"
            elif (c.fov is not None):
                return "fov"
            elif (c.uv is not None):
                return "uv"
            else:
                return "position"
        curveName = _hx_local_11
        def _hx_local_12(c1,c2):
            r = Reflect.compare(c1.object,c2.object)
            if (r != 0):
                return r
            return Reflect.compare(curveName(c1),curveName(c2))
        sortedCurves.sort(key= python_lib_Functools.cmp_to_key(_hx_local_12))
        _g = 0
        while (_g < len(sortedCurves)):
            c = (sortedCurves[_g] if _g >= 0 and _g < len(sortedCurves) else None)
            _g = (_g + 1)
            numFrames1 = numFrames
            sameData = True
            if (((((((c.t is None) and ((c.r is None))) and ((c.s is None))) and ((c.a is None))) and ((c.uv is None))) and ((c.roll is None))) and ((c.fov is None))):
                numFrames1 = 1
            else:
                if sameData:
                    sameData = self.checkData(c.t)
                if sameData:
                    sameData = self.checkData(c.r)
                if sameData:
                    sameData = self.checkData(c.s)
            this1 = [None]*(1 if sameData else numFrames1)
            frames = this1
            alpha = None
            if (c.a is None):
                alpha = None
            else:
                this2 = [None]*numFrames1
                alpha = this2
            uvs = None
            if (c.uv is None):
                uvs = None
            else:
                this3 = [None]*(numFrames1 * 2)
                uvs = this3
            roll = None
            if (c.roll is None):
                roll = None
            else:
                this4 = [None]*numFrames1
                roll = this4
            fov = None
            if (c.fov is None):
                fov = None
            else:
                this5 = [None]*numFrames1
                fov = this5
            if (((((frames is None) and ((alpha is None))) and ((uvs is None))) and ((roll is None))) and ((fov is None))):
                continue
            ctx = (None if ((c.t is None)) else c.t.x)
            cty = (None if ((c.t is None)) else c.t.y)
            ctz = (None if ((c.t is None)) else c.t.z)
            ctt = ([-1.] if ((c.t is None)) else c.t.t)
            crx = (None if ((c.r is None)) else c.r.x)
            cry = (None if ((c.r is None)) else c.r.y)
            crz = (None if ((c.r is None)) else c.r.z)
            crt = ([-1.] if ((c.r is None)) else c.r.t)
            csx = (None if ((c.s is None)) else c.s.x)
            csy = (None if ((c.s is None)) else c.s.y)
            csz = (None if ((c.s is None)) else c.s.z)
            cst = ([-1.] if ((c.s is None)) else c.s.t)
            cav = (None if ((c.a is None)) else c.a.v)
            cat = (None if ((c.a is None)) else c.a.t)
            cuv = c.uv
            _hx_def = c._hx_def
            tp = 0
            rp = 0
            sp = 0
            ap = 0
            uvp = 0
            fovp = 0
            rollp = 0
            curFrame = None
            _g1 = 0
            _g2 = numFrames1
            while (_g1 < _g2):
                f = _g1
                _g1 = (_g1 + 1)
                changed = (curFrame is None)
                if ((allTimes[f] if f >= 0 and f < len(allTimes) else None) == (ctt[tp] if tp >= 0 and tp < len(ctt) else None)):
                    changed = True
                    tp = (tp + 1)
                if ((allTimes[f] if f >= 0 and f < len(allTimes) else None) == (crt[rp] if rp >= 0 and rp < len(crt) else None)):
                    changed = True
                    rp = (rp + 1)
                if ((allTimes[f] if f >= 0 and f < len(allTimes) else None) == (cst[sp] if sp >= 0 and sp < len(cst) else None)):
                    changed = True
                    sp = (sp + 1)
                if changed:
                    f1 = h3d_anim_LinearFrame()
                    if ((c.s is None) or ((sp == 0))):
                        if (_hx_def.scale is not None):
                            f1.sx = _hx_def.scale.x
                            f1.sy = _hx_def.scale.y
                            f1.sz = _hx_def.scale.z
                        else:
                            f1.sx = 1
                            f1.sy = 1
                            f1.sz = 1
                    else:
                        f1.sx = python_internal_ArrayImpl._get(csx, (sp - 1))
                        f1.sy = python_internal_ArrayImpl._get(csy, (sp - 1))
                        f1.sz = python_internal_ArrayImpl._get(csz, (sp - 1))
                    if ((c.r is None) or ((rp == 0))):
                        if (_hx_def.rotate is not None):
                            q.initRotation(_hx_def.rotate.x,_hx_def.rotate.y,_hx_def.rotate.z)
                        else:
                            def _hx_local_18():
                                def _hx_local_17():
                                    q.z = 0
                                    return q.z
                                q.y = _hx_local_17()
                                return q.y
                            q.x = _hx_local_18()
                            q.w = 1
                    else:
                        q.initRotation(python_internal_ArrayImpl._get(crx, (rp - 1)),python_internal_ArrayImpl._get(cry, (rp - 1)),python_internal_ArrayImpl._get(crz, (rp - 1)))
                    if (_hx_def.preRot is not None):
                        q2.initRotation(_hx_def.preRot.x,_hx_def.preRot.y,_hx_def.preRot.z)
                        q.multiply(q2,q)
                    f1.qx = q.x
                    f1.qy = q.y
                    f1.qz = q.z
                    f1.qw = q.w
                    if ((c.t is None) or ((tp == 0))):
                        if (_hx_def.trans is not None):
                            f1.tx = _hx_def.trans.x
                            f1.ty = _hx_def.trans.y
                            f1.tz = _hx_def.trans.z
                        else:
                            f1.tx = 0
                            f1.ty = 0
                            f1.tz = 0
                    else:
                        f1.tx = python_internal_ArrayImpl._get(ctx, (tp - 1))
                        f1.ty = python_internal_ArrayImpl._get(cty, (tp - 1))
                        f1.tz = python_internal_ArrayImpl._get(ctz, (tp - 1))
                    if self.leftHand:
                        f1.tx = -f1.tx
                        f1.qy = -f1.qy
                        f1.qz = -f1.qz
                    curFrame = f1
                if ((frames is not None) and ((f < len(frames)))):
                    frames[f] = curFrame
                if (alpha is not None):
                    if ((allTimes[f] if f >= 0 and f < len(allTimes) else None) == (cat[ap] if ap >= 0 and ap < len(cat) else None)):
                        ap = (ap + 1)
                    val = python_internal_ArrayImpl._get(cav, (ap - 1))
                    alpha[f] = val
                if (uvs is not None):
                    if ((uvp < len(cuv)) and (((allTimes[f] if f >= 0 and f < len(allTimes) else None) == (cuv[uvp] if uvp >= 0 and uvp < len(cuv) else None).t))):
                        uvp = (uvp + 1)
                    val1 = python_internal_ArrayImpl._get(cuv, (uvp - 1)).u
                    uvs[(f << 1)] = val1
                    val2 = python_internal_ArrayImpl._get(cuv, (uvp - 1)).v
                    uvs[((f << 1) | 1)] = val2
                if (roll is not None):
                    if ((allTimes[f] if f >= 0 and f < len(allTimes) else None) == python_internal_ArrayImpl._get(c.roll.t, rollp)):
                        rollp = (rollp + 1)
                    val3 = python_internal_ArrayImpl._get(c.roll.v, (rollp - 1))
                    roll[f] = val3
                if (fov is not None):
                    if ((allTimes[f] if f >= 0 and f < len(allTimes) else None) == python_internal_ArrayImpl._get(c.fov.t, fovp)):
                        fovp = (fovp + 1)
                    val4 = python_internal_ArrayImpl._get(c.fov.v, (fovp - 1))
                    fov[f] = val4
            if (frames is not None):
                hasTrans = (c.t is not None)
                hasRot = (((c.r is not None) or ((_hx_def.rotate is not None))) or ((_hx_def.preRot is not None)))
                hasScale = ((c.s is not None) or ((_hx_def.scale is not None)))
                if ((not hasTrans) and ((_hx_def.transPos is None))):
                    hasTrans = True
                anim.addCurve(c.object,frames,hasTrans,hasRot,hasScale)
            if (alpha is not None):
                anim.addAlphaCurve(c.object,alpha)
            if (uvs is not None):
                anim.addUVCurve(c.object,uvs)
            if (roll is not None):
                anim.addPropCurve(c.object,"Roll",roll)
            if (fov is not None):
                anim.addPropCurve(c.object,"FOVY",fov)
        return anim

    def sortDistinctFloats(self,a,b):
        if (a > b):
            return 1
        else:
            return -1

    def isNullJoint(self,model):
        if (len(self.getParents(model,"Deformer")) > 0):
            return False
        parent = self.getParent(model,"Model",True)
        if (parent is None):
            return True
        t = hxd_fmt_fbx_FbxTools.getType(parent)
        if ((t == "LimbNode") or ((t == "Root"))):
            return False
        return True

    def getModelPath(self,model):
        parent = self.getParent(model,"Model",True)
        name = hxd_fmt_fbx_FbxTools.getName(model)
        if (parent is None):
            return name
        return ((HxOverrides.stringOrNull(self.getModelPath(parent)) + ".") + ("null" if name is None else name))

    def autoMerge(self):
        toMerge = []
        mergeGroups = haxe_ds_IntMap()
        _g = 0
        _g1 = self.getAllModels()
        while (_g < len(_g1)):
            model = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            this1 = self.skipObjects
            key = hxd_fmt_fbx_FbxTools.getName(model)
            if this1.h.get(key,None):
                continue
            mtype = hxd_fmt_fbx_FbxTools.getType(model)
            isJoint = ((mtype == "LimbNode") and (((not self.unskinnedJointsAsObjects) or (not self.isNullJoint(model)))))
            if (not isJoint):
                continue
            deformers = self.getParents(model,"Deformer")
            if (len(deformers) <= 1):
                continue
            group = []
            _g2 = 0
            while (_g2 < len(deformers)):
                d = (deformers[_g2] if _g2 >= 0 and _g2 < len(deformers) else None)
                _g2 = (_g2 + 1)
                _hx_def = self.getParent(d,"Deformer")
                if (_hx_def is None):
                    continue
                geom = self.getParent(_hx_def,"Geometry")
                if (geom is None):
                    continue
                model2 = self.getParent(geom,"Model")
                if (model2 is None):
                    continue
                id = hxd_fmt_fbx_FbxTools.getId(model2)
                g = mergeGroups.h.get(id,None)
                if (g is not None):
                    _g3 = 0
                    while (_g3 < len(g)):
                        g1 = (g[_g3] if _g3 >= 0 and _g3 < len(g) else None)
                        _g3 = (_g3 + 1)
                        python_internal_ArrayImpl.remove(group,g1)
                        group.append(g1)
                    python_internal_ArrayImpl.remove(toMerge,g)
                python_internal_ArrayImpl.remove(group,model2)
                group.append(model2)
                mergeGroups.set(id,group)
            toMerge.append(group)
        _g = 0
        while (_g < len(toMerge)):
            group = (toMerge[_g] if _g >= 0 and _g < len(toMerge) else None)
            _g = (_g + 1)
            def _hx_local_4(m1,m2):
                return Reflect.compare(hxd_fmt_fbx_FbxTools.getName(m1),hxd_fmt_fbx_FbxTools.getName(m2))
            group.sort(key= python_lib_Functools.cmp_to_key(_hx_local_4))
            _g1 = 0
            while (_g1 < len(toMerge)):
                g = (toMerge[_g1] if _g1 >= 0 and _g1 < len(toMerge) else None)
                _g1 = (_g1 + 1)
                if (g is not group):
                    found = False
                    _g2 = 0
                    while (_g2 < len(group)):
                        m = (group[_g2] if _g2 >= 0 and _g2 < len(group) else None)
                        _g2 = (_g2 + 1)
                        if python_internal_ArrayImpl.remove(g,m):
                            found = True
                    if found:
                        g.append((group[0] if 0 < len(group) else None))
            _g3 = []
            _g4 = 0
            while (_g4 < len(group)):
                g1 = (group[_g4] if _g4 >= 0 and _g4 < len(group) else None)
                _g4 = (_g4 + 1)
                x = hxd_fmt_fbx_FbxTools.getName(g1)
                _g3.append(x)
            self.mergeModels(_g3)

    def keepJoint(self,j):
        return self.keepJoints.h.get(j.name,None)

    def createSkin(self,hskins,hgeom,rootJoints,bonesPerVertex):
        allJoints = []
        collectJoints = None
        def _hx_local_1(j):
            _g = 0
            _g1 = j.subs
            while (_g < len(_g1)):
                j1 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                collectJoints(j1)
            allJoints.append(j)
        collectJoints = _hx_local_1
        _g = 0
        while (_g < len(rootJoints)):
            j = (rootJoints[_g] if _g >= 0 and _g < len(rootJoints) else None)
            _g = (_g + 1)
            collectJoints(j)
        skin = None
        geomTrans = None
        iterJoints = list(allJoints)
        _g = 0
        while (_g < len(iterJoints)):
            j = (iterJoints[_g] if _g >= 0 and _g < len(iterJoints) else None)
            _g = (_g + 1)
            jModel = self.ids.h.get(j.index,None)
            subDef = self.getParent(jModel,"Deformer",True)
            this1 = self.defaultModelMatrixes
            key = hxd_fmt_fbx_FbxTools.getId(jModel)
            defMat = this1.h.get(key,None)
            j.defMat = defMat.toMatrix(self.leftHand)
            if (subDef is None):
                if ((len(j.subs) > 0) or self.keepJoint(j)):
                    continue
                if (j.parent is None):
                    python_internal_ArrayImpl.remove(rootJoints,j)
                else:
                    python_internal_ArrayImpl.remove(j.parent.subs,j)
                python_internal_ArrayImpl.remove(allJoints,j)
                defMat.wasRemoved = -1
                continue
            if (skin is None):
                _hx_def = self.getParent(subDef,"Deformer")
                key1 = hxd_fmt_fbx_FbxTools.getId(_hx_def)
                skin = hskins.h.get(key1,None)
                if (skin is not None):
                    return skin
                key2 = hxd_fmt_fbx_FbxTools.getId(self.getParent(_hx_def,"Geometry"))
                geom = hgeom.h.get(key2,None)
                skin = h3d_anim_Skin(None,geom.vertexCount(),bonesPerVertex)
                geom.setSkin(skin)
                hskins.set(hxd_fmt_fbx_FbxTools.getId(_hx_def),skin)
            j.transPos = defMat.transPos
            weights = hxd_fmt_fbx_FbxTools.getAll(subDef,"Weights")
            if (len(weights) > 0):
                weights1 = hxd_fmt_fbx_FbxTools.getFloats((weights[0] if 0 < len(weights) else None))
                vertex = hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(subDef,"Indexes"))
                _g1 = 0
                _g2 = len(vertex)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    w = (weights1[i] if i >= 0 and i < len(weights1) else None)
                    if (w < 0.01):
                        continue
                    vid = (vertex[i] if i >= 0 and i < len(vertex) else None)
                    il = (skin.envelop[vid] if vid >= 0 and vid < len(skin.envelop) else None)
                    if (il is None):
                        def _hx_local_4():
                            python_internal_ArrayImpl._set(skin.envelop, vid, [])
                            return (skin.envelop[vid] if vid >= 0 and vid < len(skin.envelop) else None)
                        il = _hx_local_4()
                    x = h3d_anim__Skin_Influence(j,w)
                    il.append(x)
        if (skin is None):
            _g = []
            _g1 = 0
            while (_g1 < len(iterJoints)):
                j = (iterJoints[_g1] if _g1 >= 0 and _g1 < len(iterJoints) else None)
                _g1 = (_g1 + 1)
                x = j.name
                _g.append(x)
            raise haxe_Exception.thrown((("No joint is skinned (" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))) + ")"))
        allJoints.reverse()
        _g = 0
        _g1 = len(allJoints)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            (allJoints[i] if i >= 0 and i < len(allJoints) else None).index = i
        skin.setJoints(allJoints,rootJoints)
        skin.initWeights()
        return skin

    def round(self,v):
        if (v != v):
            raise haxe_Exception.thrown("NaN found")
        v1 = (v * 131072)
        return (((v1 if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v1)) else Math.floor((v1 + 0.5))))) / 131072)

    def updateDefaultMatrix(self,model,d):
        subDef = self.getParent(model,"Deformer",True)
        if (subDef is None):
            return
        transPos = h3d_Matrix.L(hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(subDef,"Transform")))
        if self.leftHand:
            transPos._12 = -transPos._12
            transPos._13 = -transPos._13
            transPos._21 = -transPos._21
            transPos._31 = -transPos._31
            transPos._41 = -transPos._41
        d.transPos = transPos

    def getDefaultMatrixes(self,model):
        id = hxd_fmt_fbx_FbxTools.getId(model)
        d = self.defaultModelMatrixes.h.get(id,None)
        if (d is not None):
            return d
        d = hxd_fmt_fbx_DefaultMatrixes()
        F = 0.0174532925199432955
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(model,"Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
            _hx_local_1 = len(_g2)
            if (_hx_local_1 == 15):
                if (_g2 == "Lcl Translation"):
                    d.trans = h3d_col_Point(self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None))))
                    if (((d.trans.x == 0) and ((d.trans.y == 0))) and ((d.trans.z == 0))):
                        d.trans = None
                else:
                    pass
            elif (_hx_local_1 == 11):
                if (_g2 == "Lcl Scaling"):
                    d.scale = h3d_col_Point(self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None))))
                    if (((d.scale.x == 1) and ((d.scale.y == 1))) and ((d.scale.z == 1))):
                        d.scale = None
                elif (_g2 == "PreRotation"):
                    d.preRot = h3d_col_Point(self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * F)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)) * F)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)) * F)))
                    if (((d.preRot.x == 0) and ((d.preRot.y == 0))) and ((d.preRot.z == 0))):
                        d.preRot = None
                else:
                    pass
            elif (_hx_local_1 == 12):
                if (_g2 == "Lcl Rotation"):
                    d.rotate = h3d_col_Point(self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * F)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)) * F)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)) * F)))
                    if (((d.rotate.x == 0) and ((d.rotate.y == 0))) and ((d.rotate.z == 0))):
                        d.rotate = None
                else:
                    pass
            elif (_hx_local_1 == 20):
                if (_g2 == "GeometricTranslation"):
                    pass
                else:
                    pass
            else:
                pass
        if (hxd_fmt_fbx_FbxTools.getType(model) == "LimbNode"):
            self.updateDefaultMatrix(model,d)
        self.defaultModelMatrixes.set(id,d)
        return d

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
        _hx_o.ids = None
        _hx_o.connect = None
        _hx_o.namedConnect = None
        _hx_o.invConnect = None
        _hx_o.leftHand = None
        _hx_o.defaultModelMatrixes = None
        _hx_o.uvAnims = None
        _hx_o.animationEvents = None
        _hx_o.isMaya = None
        _hx_o.fileName = None
        _hx_o.version = None
        _hx_o.keepJoints = None
        _hx_o.skipObjects = None
        _hx_o.bonesPerVertex = None
        _hx_o.unskinnedJointsAsObjects = None
        _hx_o.allowVertexColor = None
        _hx_o.normalizeScaleOrient = None
hxd_fmt_fbx_BaseLibrary._hx_class = hxd_fmt_fbx_BaseLibrary
_hx_classes["hxd.fmt.fbx.BaseLibrary"] = hxd_fmt_fbx_BaseLibrary

class hxd_fmt_fbx_FbxProp(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.fbx.FbxProp"
    _hx_constructs = ["PInt", "PFloat", "PString", "PIdent", "PInts", "PFloats", "PBinary"]

    @staticmethod
    def PInt(v):
        return hxd_fmt_fbx_FbxProp("PInt", 0, (v,))

    @staticmethod
    def PFloat(v):
        return hxd_fmt_fbx_FbxProp("PFloat", 1, (v,))

    @staticmethod
    def PString(v):
        return hxd_fmt_fbx_FbxProp("PString", 2, (v,))

    @staticmethod
    def PIdent(i):
        return hxd_fmt_fbx_FbxProp("PIdent", 3, (i,))

    @staticmethod
    def PInts(v):
        return hxd_fmt_fbx_FbxProp("PInts", 4, (v,))

    @staticmethod
    def PFloats(v):
        return hxd_fmt_fbx_FbxProp("PFloats", 5, (v,))

    @staticmethod
    def PBinary(v):
        return hxd_fmt_fbx_FbxProp("PBinary", 6, (v,))
hxd_fmt_fbx_FbxProp._hx_class = hxd_fmt_fbx_FbxProp
_hx_classes["hxd.fmt.fbx.FbxProp"] = hxd_fmt_fbx_FbxProp


class hxd_fmt_fbx_FbxTools:
    _hx_class_name = "hxd.fmt.fbx.FbxTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get", "getAll", "getInts", "getFloats", "hasProp", "idToInt", "toInt", "toFloat", "toString", "toBinary", "getId", "getName", "getType"]

    @staticmethod
    def get(n,path,opt = None):
        if (opt is None):
            opt = False
        parts = path.split(".")
        cur = n
        _g = 0
        while (_g < len(parts)):
            p = (parts[_g] if _g >= 0 and _g < len(parts) else None)
            _g = (_g + 1)
            found = False
            _g1 = 0
            _g2 = cur.childs
            while (_g1 < len(_g2)):
                c = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                if (c.name == p):
                    cur = c
                    found = True
                    break
            if (not found):
                if opt:
                    return None
                raise haxe_Exception.thrown((((((HxOverrides.stringOrNull(n.name) + " does not have ") + ("null" if path is None else path)) + " (") + ("null" if p is None else p)) + " not found)"))
        return cur

    @staticmethod
    def getAll(n,path):
        parts = path.split(".")
        cur = [n]
        _g = 0
        while (_g < len(parts)):
            p = (parts[_g] if _g >= 0 and _g < len(parts) else None)
            _g = (_g + 1)
            out = []
            _g1 = 0
            while (_g1 < len(cur)):
                n = (cur[_g1] if _g1 >= 0 and _g1 < len(cur) else None)
                _g1 = (_g1 + 1)
                _g2 = 0
                _g3 = n.childs
                while (_g2 < len(_g3)):
                    c = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if (c.name == p):
                        out.append(c)
            cur = out
            if (len(cur) == 0):
                return cur
        return cur

    @staticmethod
    def getInts(n):
        if (len(n.props) != 1):
            raise haxe_Exception.thrown((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))
        _g = (n.props[0] if 0 < len(n.props) else None)
        if (_g.index == 4):
            v = _g.params[0]
            return v
        else:
            raise haxe_Exception.thrown((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))

    @staticmethod
    def getFloats(n):
        if (len(n.props) != 1):
            raise haxe_Exception.thrown((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))
        _g = (n.props[0] if 0 < len(n.props) else None)
        tmp = _g.index
        if (tmp == 4):
            i = _g.params[0]
            fl = list()
            _g1 = 0
            while (_g1 < len(i)):
                x = (i[_g1] if _g1 >= 0 and _g1 < len(i) else None)
                _g1 = (_g1 + 1)
                fl.append(x)
            python_internal_ArrayImpl._set(n.props, 0, hxd_fmt_fbx_FbxProp.PFloats(fl))
            return fl
        elif (tmp == 5):
            v = _g.params[0]
            return v
        else:
            raise haxe_Exception.thrown((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))

    @staticmethod
    def hasProp(n,p):
        _g = 0
        _g1 = n.props
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if Type.enumEq(p,p2):
                return True
        return False

    @staticmethod
    def idToInt(f):
        f = HxOverrides.modf(f, 4294967296.)
        if (f >= 2147483648.):
            f = (f - 4294967296.)
        elif (f < -2147483648.):
            f = (f + 4294967296.)
        tmp = None
        try:
            tmp = int(f)
        except BaseException as _g:
            None
            tmp = None
        return tmp

    @staticmethod
    def toInt(n):
        if (n is None):
            raise haxe_Exception.thrown("null prop")
        tmp = n.index
        if (tmp == 0):
            v = n.params[0]
            return v
        elif (tmp == 1):
            f = n.params[0]
            return hxd_fmt_fbx_FbxTools.idToInt(f)
        else:
            raise haxe_Exception.thrown(("Invalid prop " + Std.string(n)))

    @staticmethod
    def toFloat(n):
        if (n is None):
            raise haxe_Exception.thrown("null prop")
        tmp = n.index
        if (tmp == 0):
            v = n.params[0]
            return (v * 1.0)
        elif (tmp == 1):
            v = n.params[0]
            return v
        else:
            raise haxe_Exception.thrown(("Invalid prop " + Std.string(n)))

    @staticmethod
    def toString(n):
        if (n is None):
            raise haxe_Exception.thrown("null prop")
        if (n.index == 2):
            v = n.params[0]
            return v
        else:
            raise haxe_Exception.thrown(("Invalid prop " + Std.string(n)))

    @staticmethod
    def toBinary(n):
        if (n is None):
            raise haxe_Exception.thrown("null prop")
        if (n.index == 6):
            v = n.params[0]
            return v
        else:
            raise haxe_Exception.thrown(("Invalid prop " + Std.string(n)))

    @staticmethod
    def getId(n):
        if (len(n.props) != 3):
            raise haxe_Exception.thrown((HxOverrides.stringOrNull(n.name) + " is not an object"))
        _g = (n.props[0] if 0 < len(n.props) else None)
        tmp = _g.index
        if (tmp == 0):
            id = _g.params[0]
            return id
        elif (tmp == 1):
            id = _g.params[0]
            return hxd_fmt_fbx_FbxTools.idToInt(id)
        else:
            raise haxe_Exception.thrown(((HxOverrides.stringOrNull(n.name) + " is not an object ") + Std.string(n.props)))

    @staticmethod
    def getName(n):
        if (len(n.props) != 3):
            raise haxe_Exception.thrown((HxOverrides.stringOrNull(n.name) + " is not an object"))
        _g = (n.props[1] if 1 < len(n.props) else None)
        if (_g.index == 2):
            n1 = _g.params[0]
            _this = n1.split("::")
            return (None if ((len(_this) == 0)) else _this.pop())
        else:
            raise haxe_Exception.thrown((HxOverrides.stringOrNull(n.name) + " is not an object"))

    @staticmethod
    def getType(n):
        if (len(n.props) != 3):
            raise haxe_Exception.thrown((HxOverrides.stringOrNull(n.name) + " is not an object"))
        _g = (n.props[2] if 2 < len(n.props) else None)
        if (_g.index == 2):
            n1 = _g.params[0]
            return n1
        else:
            raise haxe_Exception.thrown((HxOverrides.stringOrNull(n.name) + " is not an object"))
hxd_fmt_fbx_FbxTools._hx_class = hxd_fmt_fbx_FbxTools
_hx_classes["hxd.fmt.fbx.FbxTools"] = hxd_fmt_fbx_FbxTools


class hxd_fmt_fbx_Geometry:
    _hx_class_name = "hxd.fmt.fbx.Geometry"
    _hx_is_interface = "False"
    __slots__ = ("lib", "root")
    _hx_fields = ["lib", "root"]
    _hx_methods = ["getRoot", "getVertices", "getPolygons", "getMaterials", "getMaterialByTriangle", "merge", "getIndexes", "getNormals", "getTangents", "getBinormals", "processVectors", "getColors", "getUVs", "getGeomMatrix"]

    def __init__(self,l,root):
        self.lib = l
        self.root = root

    def getRoot(self):
        return self.root

    def getVertices(self):
        return hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(self.root,"Vertices"))

    def getPolygons(self):
        return hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(self.root,"PolygonVertexIndex"))

    def getMaterials(self):
        mats = hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementMaterial",True)
        if (mats is None):
            return None
        else:
            return hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(mats,"Materials"))

    def getMaterialByTriangle(self):
        mids = self.getMaterials()
        pos = 0
        count = 0
        mats = []
        _g = 0
        _g1 = self.getPolygons()
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            count = (count + 1)
            if (p >= 0):
                continue
            m = pos
            pos = (pos + 1)
            m1 = (mids[m] if m >= 0 and m < len(mids) else None)
            _g2 = 0
            _g3 = (count - 2)
            while (_g2 < _g3):
                i = _g2
                _g2 = (_g2 + 1)
                mats.append(m1)
            count = 0
        return mats

    def merge(self,g,materials):
        vl = self.getVertices()
        x = (len(vl) / 3)
        vcount = None
        try:
            vcount = int(x)
        except BaseException as _g:
            None
            vcount = None
        if ((g.getGeomMatrix() is not None) or ((self.getGeomMatrix() is not None))):
            raise haxe_Exception.thrown("Cannot merge models with geometric transform")
        _g = 0
        _g1 = g.getVertices()
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            vl.append(v)
        poly = self.getPolygons()
        mats = self.getMaterials()
        if ((len(mats) == 1) and ((hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementMaterial.MappingInformationType").props, 0)) == "AllSame"))):
            polyCount = 0
            _g = 0
            while (_g < len(poly)):
                p = (poly[_g] if _g >= 0 and _g < len(poly) else None)
                _g = (_g + 1)
                if (p < 0):
                    polyCount = (polyCount + 1)
            m0 = (mats[0] if 0 < len(mats) else None)
            _g = 1
            _g1 = polyCount
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                mats.append(m0)
        polyCount = 0
        _g = 0
        _g1 = g.getPolygons()
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p1 = p
            if (p1 < 0):
                polyCount = (polyCount + 1)
                p1 = (p1 - vcount)
            else:
                p1 = (p1 + vcount)
            poly.append(p1)
        normals = self.getNormals()
        _g = 0
        _g1 = g.getNormals()
        while (_g < len(_g1)):
            n = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            normals.append(n)
        uv = self.getUVs()
        uv2 = g.getUVs()
        if (len(uv) != len(uv2)):
            raise haxe_Exception.thrown((((("Different UV layer (" + Std.string(len(uv2))) + " should be ") + Std.string(len(uv))) + ")"))
        _g = 0
        _g1 = len(uv)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            uv1 = (uv[i] if i >= 0 and i < len(uv) else None)
            uv21 = (uv2[i] if i >= 0 and i < len(uv2) else None)
            count = (len(uv1.values) >> 1)
            _g2 = 0
            _g3 = uv21.values
            while (_g2 < len(_g3)):
                v = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                _this = uv1.values
                _this.append(v)
            _g4 = 0
            _g5 = uv21.index
            while (_g4 < len(_g5)):
                i1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                _this1 = uv1.index
                _this1.append((i1 + count))
        colors = self.getColors()
        colors2 = g.getColors()
        if (colors is not None):
            if (colors2 is not None):
                count = (len(colors.values) >> 2)
                _g = 0
                _g1 = colors2.values
                while (_g < len(_g1)):
                    v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    _this = colors.values
                    _this.append(v)
                _g = 0
                _g1 = colors2.index
                while (_g < len(_g1)):
                    i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    _this = colors.index
                    _this.append((i + count))
            else:
                count = (len(colors.values) >> 2)
                x = (len(g.getNormals()) / 3)
                count2 = None
                try:
                    count2 = int(x)
                except BaseException as _g:
                    None
                    count2 = None
                _this = colors.values
                _this.append(1)
                _this = colors.values
                _this.append(1)
                _this = colors.values
                _this.append(1)
                _this = colors.values
                _this.append(1)
                _g = 0
                _g1 = count2
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    _this = colors.index
                    _this.append(count)
        else:
            tmp = (colors2 is not None)
        m2 = g.getMaterials()
        if (m2 is None):
            mid = (materials[0] if 0 < len(materials) else None)
            _g = 0
            _g1 = polyCount
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                mats.append(mid)
        elif ((polyCount > 1) and ((len(m2) == 1))):
            m = (m2[0] if 0 < len(m2) else None)
            _g = 0
            _g1 = polyCount
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                mats.append((materials[m] if m >= 0 and m < len(materials) else None))
        else:
            _g = 0
            while (_g < len(m2)):
                m = (m2[_g] if _g >= 0 and _g < len(m2) else None)
                _g = (_g + 1)
                mats.append((materials[m] if m >= 0 and m < len(materials) else None))

    def getIndexes(self):
        count = 0
        pos = 0
        index = self.getPolygons()
        vout = []
        iout = []
        _g = 0
        while (_g < len(index)):
            i = (index[_g] if _g >= 0 and _g < len(index) else None)
            _g = (_g + 1)
            count = (count + 1)
            if (i < 0):
                python_internal_ArrayImpl._set(index, pos, (-i - 1))
                start = ((pos - count) + 1)
                _g1 = 0
                _g2 = count
                while (_g1 < _g2):
                    n = _g1
                    _g1 = (_g1 + 1)
                    vout.append(python_internal_ArrayImpl._get(index, (n + start)))
                _g3 = 0
                _g4 = (count - 2)
                while (_g3 < _g4):
                    n1 = _g3
                    _g3 = (_g3 + 1)
                    iout.append((start + n1))
                    iout.append(((start + count) - 1))
                    iout.append(((start + n1) + 1))
                python_internal_ArrayImpl._set(index, pos, i)
                count = 0
            pos = (pos + 1)
        return _hx_AnonObject({'vidx': vout, 'idx': iout})

    def getNormals(self):
        return self.processVectors("LayerElementNormal","Normals")

    def getTangents(self,opt = None):
        if (opt is None):
            opt = False
        return self.processVectors("LayerElementTangent","Tangents",opt)

    def getBinormals(self,opt = None):
        if (opt is None):
            opt = False
        return self.processVectors("LayerElementBinormal","Binormals",opt)

    def processVectors(self,layer,name,opt = None):
        if (opt is None):
            opt = False
        vect = hxd_fmt_fbx_FbxTools.get(self.root,((("null" if layer is None else layer) + ".") + ("null" if name is None else name)),opt)
        if (vect is None):
            return None
        nrm = hxd_fmt_fbx_FbxTools.getFloats(vect)
        if (hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(self.root,(("null" if layer is None else layer) + ".MappingInformationType")).props, 0)) == "ByVertice"):
            nout = []
            _g = 0
            _g1 = self.getPolygons()
            while (_g < len(_g1)):
                i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                vid = i
                if (vid < 0):
                    vid = (-vid - 1)
                nout.append(python_internal_ArrayImpl._get(nrm, (vid * 3)))
                nout.append(python_internal_ArrayImpl._get(nrm, ((vid * 3) + 1)))
                nout.append(python_internal_ArrayImpl._get(nrm, ((vid * 3) + 2)))
            nrm = nout
        return nrm

    def getColors(self):
        color = hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementColor",True)
        if (color is None):
            return None
        index = hxd_fmt_fbx_FbxTools.get(color,"ColorIndex",True)
        if (index is None):
            return None
        return _hx_AnonObject({'values': hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(color,"Colors")), 'index': hxd_fmt_fbx_FbxTools.getInts(index)})

    def getUVs(self):
        uvs = []
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"LayerElementUV")
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            index = hxd_fmt_fbx_FbxTools.get(v,"UVIndex",True)
            values = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(v,"UV"))
            index1 = None
            if (index is None):
                _g2 = []
                _g3 = 0
                _g4 = self.getPolygons()
                while (_g3 < len(_g4)):
                    i = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                    _g3 = (_g3 + 1)
                    if (i < 0):
                        _g2.append((-i - 1))
                    else:
                        _g2.append(i)
                index1 = _g2
            else:
                index1 = hxd_fmt_fbx_FbxTools.getInts(index)
            uvs.append(_hx_AnonObject({'values': values, 'index': index1}))
        return uvs

    def getGeomMatrix(self):
        rot = None
        trans = None
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.lib.getParent(self.root,"Model"),"Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
            _hx_local_1 = len(_g2)
            if (_hx_local_1 == 17):
                if (_g2 == "GeometricRotation"):
                    rot = h3d_col_Point(((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * 3.14159265358979323) / 180),((hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)) * 3.14159265358979323) / 180),((hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)) * 3.14159265358979323) / 180))
                else:
                    pass
            elif (_hx_local_1 == 20):
                if (_g2 == "GeometricTranslation"):
                    trans = h3d_col_Point((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * ((-1 if (self.lib.leftHand) else 1))),hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)),hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)))
                else:
                    pass
            else:
                pass
        if ((rot is None) and ((trans is None))):
            return None
        m = h3d_Matrix()
        if (rot is None):
            m.identity()
        else:
            m.initRotation(rot.x,rot.y,rot.z)
        if (trans is not None):
            m._41 = (m._41 + trans.x)
            m._42 = (m._42 + trans.y)
            m._43 = (m._43 + trans.z)
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lib = None
        _hx_o.root = None
hxd_fmt_fbx_Geometry._hx_class = hxd_fmt_fbx_Geometry
_hx_classes["hxd.fmt.fbx.Geometry"] = hxd_fmt_fbx_Geometry


class hxd_fmt_fbx_HMDOut(hxd_fmt_fbx_BaseLibrary):
    _hx_class_name = "hxd.fmt.fbx.HMDOut"
    _hx_is_interface = "False"
    __slots__ = ("d", "dataOut", "filePath", "tmp", "absoluteTexturePath", "optimizeSkin", "floatSkinIndexes")
    _hx_fields = ["d", "dataOut", "filePath", "tmp", "absoluteTexturePath", "optimizeSkin", "floatSkinIndexes"]
    _hx_methods = ["int32tof", "keepJoint", "buildTangents", "buildGeom", "addModels", "makeTexturePath", "makeSkin", "makePosition", "writeFloat", "writeFrame", "makeAnimation", "toHMD"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fmt_fbx_BaseLibrary


    def __init__(self,fileName):
        self.absoluteTexturePath = None
        self.filePath = None
        self.dataOut = None
        self.d = None
        self.floatSkinIndexes = False
        self.optimizeSkin = True
        self.tmp = haxe_io_Bytes.alloc(4)
        super().__init__(fileName)

    def int32tof(self,v):
        self.tmp.b[0] = ((v & 255) & 255)
        self.tmp.b[1] = (((v >> 8) & 255) & 255)
        self.tmp.b[2] = (((v >> 16) & 255) & 255)
        self.tmp.b[3] = (HxOverrides.rshift(v, 24) & 255)
        return self.tmp.getFloat(0)

    def keepJoint(self,j):
        if (not self.optimizeSkin):
            return True
        tmp = None
        _this = EReg("^Bip00[0-9] ","")
        _this.matchObj = python_lib_Re.search(_this.pattern,j.name)
        if (_this.matchObj is None):
            _this = EReg("^Bone[0-9][0-9][0-9]$","")
            _this.matchObj = python_lib_Re.search(_this.pattern,j.name)
            tmp = (_this.matchObj is not None)
        else:
            tmp = True
        if tmp:
            return False
        return True

    def buildTangents(self,geom):
        verts = geom.getVertices()
        normals = geom.getNormals()
        uvs = geom.getUVs()
        index = geom.getIndexes()
        tmp = Sys.getEnv("TMPDIR")
        if (tmp is None):
            tmp = Sys.getEnv("TMP")
        if (tmp is None):
            tmp = Sys.getEnv("TEMP")
        if (tmp is None):
            tmp = "."
        fileName = (((((("null" if tmp is None else tmp) + "/mikktspace_data") + Std.string((Date.now().date.timestamp() * 1000))) + "_") + Std.string(int((python_lib_Random.random() * 16777216)))) + ".bin")
        outFile = (("null" if fileName is None else fileName) + ".out")
        outputData = haxe_io_BytesBuffer()
        outputData.addInt32(len(index.vidx))
        outputData.addInt32(8)
        outputData.addInt32(0)
        outputData.addInt32(3)
        outputData.addInt32(6)
        _g = 0
        _g1 = len(index.vidx)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            vidx = (index.vidx[i] if i >= 0 and i < len(index.vidx) else None)
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(verts, (vidx * 3))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(verts, ((vidx * 3) + 1))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(verts, ((vidx * 3) + 2))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(normals, (i * 3))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(normals, ((i * 3) + 1))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(normals, ((i * 3) + 2))))
            uidx = python_internal_ArrayImpl._get((uvs[0] if 0 < len(uvs) else None).index, i)
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get((uvs[0] if 0 < len(uvs) else None).values, (uidx * 2))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get((uvs[0] if 0 < len(uvs) else None).values, ((uidx * 2) + 1))))
        outputData.addInt32(len(index.vidx))
        _g = 0
        _g1 = len(index.vidx)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            outputData.addInt32(i)
        sys_io_File.saveBytes(fileName,outputData.getBytes())
        ret = None
        try:
            ret = Sys.command("mikktspace",[fileName, outFile])
        except BaseException as _g:
            None
            ret = -1
        if (ret != 0):
            sys_FileSystem.deleteFile(fileName)
            raise haxe_Exception.thrown("Failed to call 'mikktspace' executable required to generate tangent data. Please ensure it's in your PATH")
        _hx_bytes = sys_io_File.getBytes(outFile)
        arr = []
        _g = 0
        _g1 = (len(index.vidx) * 4)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(arr, i, _hx_bytes.getFloat((i << 2)))
        sys_FileSystem.deleteFile(fileName)
        sys_FileSystem.deleteFile(outFile)
        return arr

    def buildGeom(self,geom,skin,dataOut,genTangents):
        g = hxd_fmt_hmd_Geometry()
        verts = geom.getVertices()
        normals = geom.getNormals()
        uvs = geom.getUVs()
        colors = geom.getColors()
        mats = geom.getMaterials()
        if (colors is not None):
            hasData = False
            _g = 0
            _g1 = colors.values
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v < 0.99):
                    hasData = True
                    break
            if (not hasData):
                colors = None
        tangents = (self.buildTangents(geom) if genTangents else None)
        g.vertexFormat = [hxd_fmt_hmd_GeometryFormat("position",3)]
        if (normals is not None):
            _this = g.vertexFormat
            x = hxd_fmt_hmd_GeometryFormat("normal",3)
            _this.append(x)
        if (tangents is not None):
            _this = g.vertexFormat
            x = hxd_fmt_hmd_GeometryFormat("tangent",3)
            _this.append(x)
        _g = 0
        _g1 = len(uvs)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this = g.vertexFormat
            x = hxd_fmt_hmd_GeometryFormat(("uv" + HxOverrides.stringOrNull((("" if ((i == 0)) else ("" + Std.string(((i + 1)))))))),2)
            _this.append(x)
        if (colors is not None):
            _this = g.vertexFormat
            x = hxd_fmt_hmd_GeometryFormat("color",3)
            _this.append(x)
        if (skin is not None):
            if ((self.bonesPerVertex <= 0) or ((self.bonesPerVertex > 4))):
                raise haxe_Exception.thrown("assert")
            _this = g.vertexFormat
            x = hxd_fmt_hmd_GeometryFormat("weights",python_internal_ArrayImpl._get([1, 2, 3, 4], (self.bonesPerVertex - 1)))
            _this.append(x)
            _this = g.vertexFormat
            x = hxd_fmt_hmd_GeometryFormat("indexes",(python_internal_ArrayImpl._get([1, 2, 3, 4], (self.bonesPerVertex - 1)) if (self.floatSkinIndexes) else 9))
            _this.append(x)
        stride = 0
        _g = 0
        _g1 = g.vertexFormat
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            stride = (stride + ((f.format & 7)))
        g.vertexStride = stride
        g.vertexCount = 0
        gm = geom.getGeomMatrix()
        this1 = list()
        vbuf = this1
        ibufs = []
        if ((skin is not None) and ((skin.splitJoints is not None))):
            _g = 0
            _g1 = skin.splitJoints
            while (_g < len(_g1)):
                _ = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                ibufs.append([])
        g.bounds = h3d_col_Bounds()
        this1 = [None]*stride
        tmpBuf = this1
        vertexRemap = list()
        index = geom.getPolygons()
        count = 0
        matPos = 0
        stri = 0
        lookup = haxe_ds_IntMap()
        tmp_x = 0.
        tmp_y = 0.
        tmp_z = 0.
        _g = 0
        _g1 = len(index)
        while (_g < _g1):
            pos = _g
            _g = (_g + 1)
            i = (index[pos] if pos >= 0 and pos < len(index) else None)
            count = (count + 1)
            if (i >= 0):
                continue
            python_internal_ArrayImpl._set(index, pos, (-i - 1))
            start = ((pos - count) + 1)
            _g2 = 0
            _g3 = count
            while (_g2 < _g3):
                n = _g2
                _g2 = (_g2 + 1)
                k = (n + start)
                vidx = (index[k] if k >= 0 and k < len(index) else None)
                p = 0
                x = python_internal_ArrayImpl._get(verts, (vidx * 3))
                y = python_internal_ArrayImpl._get(verts, ((vidx * 3) + 1))
                z = python_internal_ArrayImpl._get(verts, ((vidx * 3) + 2))
                if (gm is not None):
                    x1 = x
                    y1 = y
                    z1 = z
                    if (z1 is None):
                        z1 = 0.
                    if (y1 is None):
                        y1 = 0.
                    if (x1 is None):
                        x1 = 0.
                    tmp_x = x1
                    tmp_y = y1
                    tmp_z = z1
                    px = ((((tmp_x * gm._11) + ((tmp_y * gm._21))) + ((tmp_z * gm._31))) + gm._41)
                    py = ((((tmp_x * gm._12) + ((tmp_y * gm._22))) + ((tmp_z * gm._32))) + gm._42)
                    pz = ((((tmp_x * gm._13) + ((tmp_y * gm._23))) + ((tmp_z * gm._33))) + gm._43)
                    tmp_x = px
                    tmp_y = py
                    tmp_z = pz
                    x = tmp_x
                    y = tmp_y
                    z = tmp_z
                index1 = p
                p = (p + 1)
                tmpBuf[index1] = x
                index2 = p
                p = (p + 1)
                tmpBuf[index2] = y
                index3 = p
                p = (p + 1)
                tmpBuf[index3] = z
                _this = g.bounds
                if (x < _this.xMin):
                    _this.xMin = x
                if (x > _this.xMax):
                    _this.xMax = x
                if (y < _this.yMin):
                    _this.yMin = y
                if (y > _this.yMax):
                    _this.yMax = y
                if (z < _this.zMin):
                    _this.zMin = z
                if (z > _this.zMax):
                    _this.zMax = z
                if (normals is not None):
                    nx = python_internal_ArrayImpl._get(normals, (k * 3))
                    ny = python_internal_ArrayImpl._get(normals, ((k * 3) + 1))
                    nz = python_internal_ArrayImpl._get(normals, ((k * 3) + 2))
                    index4 = p
                    p = (p + 1)
                    tmpBuf[index4] = nx
                    index5 = p
                    p = (p + 1)
                    tmpBuf[index5] = ny
                    index6 = p
                    p = (p + 1)
                    tmpBuf[index6] = nz
                if (tangents is not None):
                    index7 = p
                    p = (p + 1)
                    val = self.round(python_internal_ArrayImpl._get(tangents, (k * 4)))
                    tmpBuf[index7] = val
                    index8 = p
                    p = (p + 1)
                    val1 = self.round(python_internal_ArrayImpl._get(tangents, ((k * 4) + 1)))
                    tmpBuf[index8] = val1
                    index9 = p
                    p = (p + 1)
                    val2 = self.round(python_internal_ArrayImpl._get(tangents, ((k * 4) + 2)))
                    tmpBuf[index9] = val2
                    if (python_internal_ArrayImpl._get(tangents, ((k * 4) + 3)) < 0):
                        _g4 = (p - 3)
                        _g5 = tmpBuf
                        val3 = (_g5[_g4] * 0.5)
                        _g5[_g4] = val3
                        _g6 = (p - 2)
                        _g7 = tmpBuf
                        val4 = (_g7[_g6] * 0.5)
                        _g7[_g6] = val4
                        _g8 = (p - 1)
                        _g9 = tmpBuf
                        val5 = (_g9[_g8] * 0.5)
                        _g9[_g8] = val5
                _g10 = 0
                while (_g10 < len(uvs)):
                    tuvs = (uvs[_g10] if _g10 >= 0 and _g10 < len(uvs) else None)
                    _g10 = (_g10 + 1)
                    iuv = (tuvs.index[k] if k >= 0 and k < len(tuvs.index) else None)
                    index10 = p
                    p = (p + 1)
                    val6 = python_internal_ArrayImpl._get(tuvs.values, (iuv * 2))
                    tmpBuf[index10] = val6
                    index11 = p
                    p = (p + 1)
                    val7 = (1 - python_internal_ArrayImpl._get(tuvs.values, ((iuv * 2) + 1)))
                    tmpBuf[index11] = val7
                if (colors is not None):
                    icol = (colors.index[k] if k >= 0 and k < len(colors.index) else None)
                    index12 = p
                    p = (p + 1)
                    val8 = python_internal_ArrayImpl._get(colors.values, (icol * 4))
                    tmpBuf[index12] = val8
                    index13 = p
                    p = (p + 1)
                    val9 = python_internal_ArrayImpl._get(colors.values, ((icol * 4) + 1))
                    tmpBuf[index13] = val9
                    index14 = p
                    p = (p + 1)
                    val10 = python_internal_ArrayImpl._get(colors.values, ((icol * 4) + 2))
                    tmpBuf[index14] = val10
                if (skin is not None):
                    k1 = (vidx * skin.bonesPerVertex)
                    idx = 0
                    _g11 = 0
                    _g12 = skin.bonesPerVertex
                    while (_g11 < _g12):
                        i1 = _g11
                        _g11 = (_g11 + 1)
                        index15 = p
                        p = (p + 1)
                        val11 = skin.vertexWeights[(k1 + i1)]
                        tmpBuf[index15] = val11
                        idx = ((skin.vertexJoints[(k1 + i1)] << ((8 * i1))) | idx)
                    if self.floatSkinIndexes:
                        _g13 = 0
                        _g14 = skin.bonesPerVertex
                        while (_g13 < _g14):
                            i2 = _g13
                            _g13 = (_g13 + 1)
                            index16 = p
                            p = (p + 1)
                            val12 = (skin.vertexJoints[(k1 + i2)] * 3)
                            tmpBuf[index16] = val12
                    else:
                        index17 = p
                        p = (p + 1)
                        val13 = self.int32tof(idx)
                        tmpBuf[index17] = val13
                total = 0.
                _g15 = 0
                _g16 = stride
                while (_g15 < _g16):
                    i3 = _g15
                    _g15 = (_g15 + 1)
                    total = (total + tmpBuf[i3])
                itotal = None
                try:
                    itotal = int(HxOverrides.modf((total * 100), 268435455))
                except BaseException as _g17:
                    None
                    itotal = None
                itotal1 = itotal
                found = None
                vids = lookup.h.get(itotal1,None)
                if (vids is None):
                    vids = []
                    lookup.set(itotal1,vids)
                _g18 = 0
                while (_g18 < len(vids)):
                    vid = (vids[_g18] if _g18 >= 0 and _g18 < len(vids) else None)
                    _g18 = (_g18 + 1)
                    same = True
                    p1 = (vid * stride)
                    _g19 = 0
                    _g20 = stride
                    while (_g19 < _g20):
                        i4 = _g19
                        _g19 = (_g19 + 1)
                        key = p1
                        p1 = (p1 + 1)
                        if (python_internal_ArrayImpl._get(vbuf, key) != tmpBuf[i4]):
                            same = False
                            break
                    if same:
                        found = vid
                        break
                if (found is None):
                    found = g.vertexCount
                    g.vertexCount = (g.vertexCount + 1)
                    _g21 = 0
                    _g22 = stride
                    while (_g21 < _g22):
                        i5 = _g21
                        _g21 = (_g21 + 1)
                        v = tmpBuf[i5]
                        vbuf.append(v)
                    vids.append(found)
                vertexRemap.append(found)
            if ((skin is not None) and ((skin.splitJoints is not None))):
                _g23 = 0
                _g24 = (count - 2)
                while (_g23 < _g24):
                    n1 = _g23
                    _g23 = (_g23 + 1)
                    index18 = stri
                    stri = (stri + 1)
                    idx1 = python_internal_ArrayImpl._get(ibufs, skin.triangleGroups[index18])
                    idx1.append(python_internal_ArrayImpl._get(vertexRemap, (start + n1)))
                    idx1.append(python_internal_ArrayImpl._get(vertexRemap, ((start + count) - 1)))
                    idx1.append(python_internal_ArrayImpl._get(vertexRemap, ((start + n1) + 1)))
            else:
                mid = None
                if (mats is None):
                    mid = 0
                else:
                    mid = (mats[matPos] if matPos >= 0 and matPos < len(mats) else None)
                    if (len(mats) > 1):
                        matPos = (matPos + 1)
                idx2 = (ibufs[mid] if mid >= 0 and mid < len(ibufs) else None)
                if (idx2 is None):
                    idx2 = []
                    python_internal_ArrayImpl._set(ibufs, mid, idx2)
                _g25 = 0
                _g26 = (count - 2)
                while (_g25 < _g26):
                    n2 = _g25
                    _g25 = (_g25 + 1)
                    idx2.append(python_internal_ArrayImpl._get(vertexRemap, (start + n2)))
                    idx2.append(python_internal_ArrayImpl._get(vertexRemap, ((start + count) - 1)))
                    idx2.append(python_internal_ArrayImpl._get(vertexRemap, ((start + n2) + 1)))
            python_internal_ArrayImpl._set(index, pos, i)
            count = 0
        g.vertexPosition = len(dataOut.b.b)
        _g = 0
        _g1 = len(vbuf)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            f = python_internal_ArrayImpl._get(vbuf, i)
            self.dataOut.writeFloat((0 if ((f == 0)) else f))
        g.indexPosition = len(dataOut.b.b)
        g.indexCounts = []
        matMap = []
        matCount = 0
        is32 = (g.vertexCount > 65536)
        _g = 0
        while (_g < len(ibufs)):
            idx = (ibufs[_g] if _g >= 0 and _g < len(ibufs) else None)
            _g = (_g + 1)
            if (idx is None):
                matCount = (matCount + 1)
                continue
            x = matCount
            matCount = (matCount + 1)
            matMap.append(x)
            _this = g.indexCounts
            x1 = len(idx)
            _this.append(x1)
            if is32:
                _g1 = 0
                while (_g1 < len(idx)):
                    i = (idx[_g1] if _g1 >= 0 and _g1 < len(idx) else None)
                    _g1 = (_g1 + 1)
                    dataOut.writeInt32(i)
            else:
                _g2 = 0
                while (_g2 < len(idx)):
                    i1 = (idx[_g2] if _g2 >= 0 and _g2 < len(idx) else None)
                    _g2 = (_g2 + 1)
                    dataOut.writeUInt16(i1)
        if ((skin is not None) and ((skin.splitJoints is not None))):
            matMap = None
        return _hx_AnonObject({'g': g, 'materials': matMap})

    def addModels(self,includeGeometry):
        _gthis = self
        root = self.buildHierarchy().root
        objects = []
        joints = []
        skins = []
        foundSkin = None
        uid = 0
        indexRec = None
        def _hx_local_2(t):
            if t.isJoint:
                joints.append(t)
            else:
                isSkin = False
                if (foundSkin is None):
                    _g = 0
                    _g1 = t.childs
                    while (_g < len(_g1)):
                        c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                        _g = (_g + 1)
                        if c.isJoint:
                            isSkin = True
                            break
                else:
                    isSkin = (python_internal_ArrayImpl.indexOf(foundSkin,t,None) >= 0)
                if isSkin:
                    skins.append(t)
                else:
                    objects.append(t)
            _g = 0
            _g1 = t.childs
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                indexRec(c)
        indexRec = _hx_local_2
        indexRec(root)
        _g = 0
        while (_g < len(joints)):
            o = (joints[_g] if _g >= 0 and _g < len(joints) else None)
            _g = (_g + 1)
            if o.isMesh:
                raise haxe_Exception.thrown("assert")
            j = h3d_anim_Joint()
            self.getDefaultMatrixes(o.model)
            j.index = hxd_fmt_fbx_FbxTools.getId(o.model)
            j.name = hxd_fmt_fbx_FbxTools.getName(o.model)
            o.joint = j
            if (o.parent is not None):
                j.parent = o.parent.joint
                if o.parent.isJoint:
                    _this = o.parent.joint.subs
                    _this.append(j)
        foundSkin = []
        _g = 0
        while (_g < len(skins)):
            o = (skins[_g] if _g >= 0 and _g < len(skins) else None)
            _g = (_g + 1)
            loopRec = [None]
            def _hx_local_7(loopRec):
                def _hx_local_5(o):
                    _g = 0
                    _g1 = o.childs
                    while (_g < len(_g1)):
                        j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                        _g = (_g + 1)
                        if (not j.isJoint):
                            continue
                        s = _gthis.getParent(j.model,"Deformer",True)
                        if (s is not None):
                            return s
                        s = (loopRec[0] if 0 < len(loopRec) else None)(j)
                        if (s is not None):
                            return s
                    return None
                return _hx_local_5
            python_internal_ArrayImpl._set(loopRec, 0, _hx_local_7(loopRec))
            subDef = (loopRec[0] if 0 < len(loopRec) else None)(o)
            if (subDef is None):
                continue
            _hx_def = self.getParent(subDef,"Deformer")
            geoms = self.getParents(_hx_def,"Geometry")
            if (len(geoms) == 0):
                continue
            if (len(geoms) > 1):
                raise haxe_Exception.thrown("Single skin applied to multiple geometries not supported")
            models = self.getParents((geoms[0] if 0 < len(geoms) else None),"Model")
            if (len(models) == 0):
                continue
            if (len(models) > 1):
                raise haxe_Exception.thrown("Single skin applied to multiple models not supported")
            m = (models[0] if 0 < len(models) else None)
            _g1 = 0
            while (_g1 < len(objects)):
                o2 = (objects[_g1] if _g1 >= 0 and _g1 < len(objects) else None)
                _g1 = (_g1 + 1)
                if (o2.model == m):
                    foundSkin.append(o)
                    o2.skin = o
                    if (o.model is None):
                        o.model = m
                    self.ignoreMissingObject(hxd_fmt_fbx_FbxTools.getId(m))
                    p = o.parent
                    if (p != o2):
                        python_internal_ArrayImpl.remove(o2.parent.childs,o2)
                        o2.parent = p
                        if (p is not None):
                            _this = p.childs
                            _this.append(o2)
                        else:
                            root = o2
                    if (p is not None):
                        python_internal_ArrayImpl.remove(p.childs,o)
                    _g2 = 0
                    _g3 = list(o.childs)
                    while (_g2 < len(_g3)):
                        c = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                        _g2 = (_g2 + 1)
                        if (not c.isJoint):
                            python_internal_ArrayImpl.remove(o.childs,c)
                            _this1 = o2.childs
                            _this1.append(c)
                            c.parent = o2
                    break
        if (not includeGeometry):
            return
        objects = []
        if ((len(root.childs) <= 1) and ((root.model is None))):
            root = (root.childs[0] if 0 < len(root.childs) else None)
            root.parent = None
        if (root is not None):
            indexRec(root)
        hskins = haxe_ds_IntMap()
        tmpGeom = haxe_ds_IntMap()
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry")
        while (_g < len(_g1)):
            g = [(_g1[_g] if _g >= 0 and _g < len(_g1) else None)]
            _g = (_g + 1)
            def _hx_local_12():
                def _hx_local_11(_):
                    pass
                return _hx_local_11
            def _hx_local_14(g):
                def _hx_local_13():
                    x = (len(hxd_fmt_fbx_Geometry(_gthis,(g[0] if 0 < len(g) else None)).getVertices()) / 3)
                    try:
                        return int(x)
                    except BaseException as _g:
                        None
                        return None
                return _hx_local_13
            tmpGeom.set(hxd_fmt_fbx_FbxTools.getId((g[0] if 0 < len(g) else None)),_hx_AnonObject({'setSkin': _hx_local_12(), 'vertexCount': _hx_local_14(g)}))
        hgeom = haxe_ds_IntMap()
        hmat = haxe_ds_IntMap()
        index = 0
        _g = 0
        while (_g < len(objects)):
            o = (objects[_g] if _g >= 0 and _g < len(objects) else None)
            _g = (_g + 1)
            tmp = index
            index = (index + 1)
            o.index = tmp
            model = hxd_fmt_hmd_Model()
            ref = (o if ((o.skin is None)) else o.skin)
            model.name = (None if ((o.model is None)) else hxd_fmt_fbx_FbxTools.getName(o.model))
            model.parent = (-1 if (((o.parent is None) or o.parent.isJoint)) else o.parent.index)
            model.follow = (hxd_fmt_fbx_FbxTools.getName(o.parent.model) if (((o.parent is not None) and o.parent.isJoint)) else None)
            m = (hxd_fmt_fbx_DefaultMatrixes() if ((ref.model is None)) else self.getDefaultMatrixes(ref.model))
            p = hxd_fmt_hmd_Position()
            p.x = (0 if ((m.trans is None)) else -m.trans.x)
            p.y = (0 if ((m.trans is None)) else m.trans.y)
            p.z = (0 if ((m.trans is None)) else m.trans.z)
            p.sx = (1 if ((m.scale is None)) else m.scale.x)
            p.sy = (1 if ((m.scale is None)) else m.scale.y)
            p.sz = (1 if ((m.scale is None)) else m.scale.z)
            if ((o.model is not None) and ((hxd_fmt_fbx_FbxTools.getType(o.model) == "Camera"))):
                props = self.getChild(o.model,"NodeAttribute")
                fov = 45.
                ratio = 1.77777777777777768
                _g1 = 0
                _g2 = hxd_fmt_fbx_FbxTools.getAll(props,"Properties70.P")
                while (_g1 < len(_g2)):
                    p1 = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                    _g1 = (_g1 + 1)
                    _g3 = hxd_fmt_fbx_FbxTools.toString((p1.props[0] if 0 < len(p1.props) else None))
                    _hx_local_17 = len(_g3)
                    if (_hx_local_17 == 15):
                        if (_g3 == "FilmAspectRatio"):
                            ratio = hxd_fmt_fbx_FbxTools.toFloat((p1.props[4] if 4 < len(p1.props) else None))
                        else:
                            pass
                    elif (_hx_local_17 == 11):
                        if (_g3 == "FieldOfView"):
                            fov = hxd_fmt_fbx_FbxTools.toFloat((p1.props[4] if 4 < len(p1.props) else None))
                        else:
                            pass
                    else:
                        pass
                fovY = (((2 * Math.atan((Math.tan((((fov * 0.5) * 3.14159265358979323) / 180)) / ratio))) * 180) / 3.14159265358979323)
                if (model.props is None):
                    model.props = []
                _this = model.props
                _this.append(hxd_fmt_hmd_Property.CameraFOVY(fovY))
            q = m.toQuaternion(True)
            q.normalize()
            if (q.w < 0):
                q.x = -q.x
                q.y = -q.y
                q.z = -q.z
                q.w = -q.w
            p.qx = q.x
            p.qy = q.y
            p.qz = q.z
            model.position = p
            model.geometry = -1
            _this1 = self.d.models
            _this1.append(model)
            if (not o.isMesh):
                continue
            mids = []
            hasNormalMap = False
            _g4 = 0
            _g5 = self.getChilds(o.model,"Material")
            while (_g4 < len(_g5)):
                m1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                key = hxd_fmt_fbx_FbxTools.getId(m1)
                mid = hmat.h.get(key,None)
                if (mid is not None):
                    mids.append(mid)
                    m2 = python_internal_ArrayImpl._get(self.d.materials, mid)
                    hasNormalMap = (m2.normalMap is not None)
                    continue
                mat = hxd_fmt_hmd_Material()
                mid = len(self.d.materials)
                mids.append(mid)
                hmat.set(hxd_fmt_fbx_FbxTools.getId(m1),mid)
                _this2 = self.d.materials
                _this2.append(mat)
                mat.name = hxd_fmt_fbx_FbxTools.getName(m1)
                mat.blendMode = None
                _g6 = 0
                _g7 = hxd_fmt_fbx_FbxTools.getAll(m1,"Properties70.P")
                while (_g6 < len(_g7)):
                    p2 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                    _g6 = (_g6 + 1)
                    pval = (p2.props[4] if 4 < len(p2.props) else None)
                    if (hxd_fmt_fbx_FbxTools.toString((p2.props[0] if 0 < len(p2.props) else None)) == "Opacity"):
                        v = hxd_fmt_fbx_FbxTools.toFloat(pval)
                        if (((v < 1) and ((v > 0.98))) and ((mat.blendMode is None))):
                            mat.blendMode = h2d_BlendMode.Add
                texture = self.getSpecChild(m1,"DiffuseColor")
                if (texture is not None):
                    path = self.makeTexturePath(texture)
                    if (path is not None):
                        mat.diffuseTexture = path
                mat.normalMap = self.makeTexturePath(self.getSpecChild(m1,"NormalMap"))
                if (mat.normalMap is not None):
                    hasNormalMap = True
                spec = self.getSpecChild(m1,"SpecularFactor")
                if (spec is None):
                    spec = self.getSpecChild(m1,"SpecularColor")
                mat.specularTexture = self.makeTexturePath(spec)
                if ((mat.normalMap is not None) or ((mat.specularTexture is not None))):
                    if (mat.props is None):
                        mat.props = []
                    _this3 = mat.props
                    _this3.append(hxd_fmt_hmd_Property.HasExtraTextures)
                transp = self.getSpecChild(m1,"TransparentColor")
                if (transp is not None):
                    path1 = hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(transp,"FileName").props, 0))
                    if (path1 != ""):
                        path1 = path1.lower()
                        _this4 = path1.split(".")
                        ext = (None if ((len(_this4) == 0)) else _this4.pop())
                        if ((texture is not None) and ((path1 == hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(texture,"FileName").props, 0)).lower()))):
                            if (((mat.blendMode is None) and ((ext != "jpg"))) and ((ext != "jpeg"))):
                                mat.blendMode = h2d_BlendMode.Alpha
                        else:
                            raise haxe_Exception.thrown("Alpha texture that is different from diffuse is not supported in HMD")
                if (mat.blendMode is None):
                    mat.blendMode = h2d_BlendMode._hx_None
            g1 = self.getChild(o.model,"Geometry")
            skin = None
            if (o.skin is not None):
                rootJoints = []
                _g8 = 0
                _g9 = o.skin.childs
                while (_g8 < len(_g9)):
                    c = (_g9[_g8] if _g8 >= 0 and _g8 < len(_g9) else None)
                    _g8 = (_g8 + 1)
                    if c.isJoint:
                        x = c.joint
                        rootJoints.append(x)
                skin = self.createSkin(hskins,tmpGeom,rootJoints,self.bonesPerVertex)
                if (len(skin.boundJoints) > hxd_fmt_fbx_BaseLibrary.maxBonesPerSkin):
                    g2 = hxd_fmt_fbx_Geometry(self,g1)
                    idx = g2.getIndexes()
                    tmp1 = hxd_fmt_fbx_BaseLibrary.maxBonesPerSkin
                    _g10 = []
                    _g11 = 0
                    _g12 = idx.idx
                    while (_g11 < len(_g12)):
                        i = (_g12[_g11] if _g11 >= 0 and _g11 < len(_g12) else None)
                        _g11 = (_g11 + 1)
                        x1 = (idx.vidx[i] if i >= 0 and i < len(idx.vidx) else None)
                        _g10.append(x1)
                    skin.split(tmp1,_g10,(g2.getMaterialByTriangle() if ((len(mids) > 1)) else None))
                model.skin = self.makeSkin(skin,o.skin)
            key1 = hxd_fmt_fbx_FbxTools.getId(g1)
            gdata = hgeom.h.get(key1,None)
            if (gdata is None):
                geom = self.buildGeom(hxd_fmt_fbx_Geometry(self,g1),skin,self.dataOut,hasNormalMap)
                gdata = _hx_AnonObject({'gid': len(self.d.geometries), 'materials': geom.materials})
                _this5 = self.d.geometries
                x2 = geom.g
                _this5.append(x2)
                hgeom.set(hxd_fmt_fbx_FbxTools.getId(g1),gdata)
            model.geometry = gdata.gid
            if (len(mids) == 0):
                mat1 = hxd_fmt_hmd_Material()
                mat1.blendMode = h2d_BlendMode._hx_None
                mat1.name = "default"
                mid1 = len(self.d.materials)
                _this6 = self.d.materials
                _this6.append(mat1)
                mids = [mid1]
            if (gdata.materials is None):
                model.materials = mids
            else:
                _g13 = []
                _g14 = 0
                _g15 = gdata.materials
                while (_g14 < len(_g15)):
                    id = (_g15[_g14] if _g14 >= 0 and _g14 < len(_g15) else None)
                    _g14 = (_g14 + 1)
                    _g13.append((mids[id] if id >= 0 and id < len(mids) else None))
                model.materials = _g13

    def makeTexturePath(self,tex):
        if (tex is None):
            return None
        path = hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(tex,"FileName").props, 0))
        if (path == ""):
            return None
        _this = path.split("\\")
        path = "/".join([python_Boot.toString1(x1,'') for x1 in _this])
        if (not self.absoluteTexturePath):
            tmp = None
            if (self.filePath is not None):
                s = path.lower()
                start = self.filePath
                tmp = s.startswith(start)
            else:
                tmp = False
            if tmp:
                path = HxString.substr(path,len(self.filePath),None)
            else:
                k = path.split("/res/")
                if (len(k) > 1):
                    if (len(k) != 0):
                        k.pop(0)
                    path = "/res/".join([python_Boot.toString1(x1,'') for x1 in k])
        return path

    def makeSkin(self,skin,obj):
        s = hxd_fmt_hmd_Skin()
        s.name = hxd_fmt_fbx_FbxTools.getName(obj.model)
        s.joints = []
        _g = 0
        _g1 = skin.allJoints
        while (_g < len(_g1)):
            jo = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            j = hxd_fmt_hmd_SkinJoint()
            j.name = jo.name
            j.parent = (-1 if ((jo.parent is None)) else jo.parent.index)
            j.bind = jo.bindIndex
            j.position = self.makePosition(jo.defMat)
            if (jo.transPos is not None):
                j.transpos = self.makePosition(jo.transPos)
                if (((j.transpos.sx != 1) or ((j.transpos.sy != 1))) or ((j.transpos.sz != 1))):
                    tmp = jo.transPos.clone()
                    tmp.transpose()
                    v = None
                    if (v is None):
                        v = h3d_Vector()
                    f = (((tmp._11 * tmp._11) + ((tmp._12 * tmp._12))) + ((tmp._13 * tmp._13)))
                    v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
                    f1 = (((tmp._21 * tmp._21) + ((tmp._22 * tmp._22))) + ((tmp._23 * tmp._23)))
                    v.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
                    f2 = (((tmp._31 * tmp._31) + ((tmp._32 * tmp._32))) + ((tmp._33 * tmp._33)))
                    v.z = (Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))
                    if ((((tmp._11 * (((tmp._22 * tmp._33) - ((tmp._23 * tmp._32))))) + ((tmp._12 * (((tmp._23 * tmp._31) - ((tmp._21 * tmp._33))))))) + ((tmp._13 * (((tmp._21 * tmp._32) - ((tmp._22 * tmp._31))))))) < 0):
                        v.x = (v.x * -1)
                        v.y = (v.y * -1)
                        v.z = (v.z * -1)
                    s1 = v
                    tmp.prependScale((1 / s1.x),(1 / s1.y),(1 / s1.z))
                    tmp.transpose()
                    j.transpos = self.makePosition(tmp)
                    j.transpos.sx = self.round(s1.x)
                    j.transpos.sy = self.round(s1.y)
                    j.transpos.sz = self.round(s1.z)
            _this = s.joints
            _this.append(j)
        if (skin.splitJoints is not None):
            s.split = []
            _g = 0
            _g1 = skin.splitJoints
            while (_g < len(_g1)):
                sp = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                ss = hxd_fmt_hmd_SkinSplit()
                ss.materialIndex = sp.material
                _g2 = []
                _g3 = 0
                _g4 = sp.joints
                while (_g3 < len(_g4)):
                    j = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                    _g3 = (_g3 + 1)
                    x = j.index
                    _g2.append(x)
                ss.joints = _g2
                _this = s.split
                _this.append(ss)
        return s

    def makePosition(self,m):
        p = hxd_fmt_hmd_Position()
        v = None
        if (v is None):
            v = h3d_Vector()
        f = (((m._11 * m._11) + ((m._12 * m._12))) + ((m._13 * m._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((m._21 * m._21) + ((m._22 * m._22))) + ((m._23 * m._23)))
        v.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((m._31 * m._31) + ((m._32 * m._32))) + ((m._33 * m._33)))
        v.z = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if ((((m._11 * (((m._22 * m._33) - ((m._23 * m._32))))) + ((m._12 * (((m._23 * m._31) - ((m._21 * m._33))))))) + ((m._13 * (((m._21 * m._32) - ((m._22 * m._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        s = v
        q = h3d_Quat()
        q.initRotateMatrix(m)
        q.normalize()
        if (q.w < 0):
            q.x = -q.x
            q.y = -q.y
            q.z = -q.z
            q.w = -q.w
        p.sx = self.round(s.x)
        p.sy = self.round(s.y)
        p.sz = self.round(s.z)
        p.qx = self.round(q.x)
        p.qy = self.round(q.y)
        p.qz = self.round(q.z)
        p.x = self.round(m._41)
        p.y = self.round(m._42)
        p.z = self.round(m._43)
        return p

    def writeFloat(self,f):
        self.dataOut.writeFloat((0 if ((f == 0)) else f))

    def writeFrame(self,o,fid):
        if (self.d.version < 3):
            return
        if (o.frames is not None):
            f = o.frames[fid]
            if o.hasPosition:
                f1 = f.tx
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                f1 = f.ty
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                f1 = f.tz
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
            if o.hasRotation:
                f1 = ((((f.qx * f.qx) + ((f.qy * f.qy))) + ((f.qz * f.qz))) + ((f.qw * f.qw)))
                ql = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
                if ((ql * f.qw) < 0):
                    ql = -ql
                f1 = self.round((f.qx / ql))
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                f1 = self.round((f.qy / ql))
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                f1 = self.round((f.qz / ql))
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
            if o.hasScale:
                f1 = f.sx
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                f1 = f.sy
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                f1 = f.sz
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
        if (o.uvs is not None):
            f = o.uvs[(fid << 1)]
            self.dataOut.writeFloat((0 if ((f == 0)) else f))
            f = o.uvs[(((fid << 1)) + 1)]
            self.dataOut.writeFloat((0 if ((f == 0)) else f))
        if (o.alphas is not None):
            f = o.alphas[fid]
            self.dataOut.writeFloat((0 if ((f == 0)) else f))
        if (o.propValues is not None):
            f = o.propValues[fid]
            self.dataOut.writeFloat((0 if ((f == 0)) else f))

    def makeAnimation(self,anim):
        a = hxd_fmt_hmd_Animation()
        a.name = anim.name
        a.loop = True
        a.speed = 1
        a.sampling = anim.sampling
        a.frames = anim.frameCount
        a.objects = []
        a.dataPosition = len(self.dataOut.b.b)
        if (self.animationEvents is not None):
            _g = []
            _g1 = 0
            _g2 = self.animationEvents
            while (_g1 < len(_g2)):
                a1 = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                e = hxd_fmt_hmd_AnimationEvent()
                e.frame = a1.frame
                e.data = a1.data
                _g.append(e)
            a.events = _g
        objects = anim.objects
        def _hx_local_1(o1,o2):
            return Reflect.compare(o1.objectName,o2.objectName)
        objects.sort(key= python_lib_Functools.cmp_to_key(_hx_local_1))
        animatedObjects = []
        _g = 0
        while (_g < len(objects)):
            obj = (objects[_g] if _g >= 0 and _g < len(objects) else None)
            _g = (_g + 1)
            o = hxd_fmt_hmd_AnimationObject()
            count = 0
            o.name = obj.objectName
            this1 = 0
            o.flags = this1
            o.props = []
            if (obj.frames is not None):
                count = len(obj.frames)
                if (obj.hasPosition or ((self.d.version < 3))):
                    o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))
                if obj.hasRotation:
                    o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))
                if obj.hasScale:
                    o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))
                if (self.d.version < 3):
                    _g1 = 0
                    _g2 = obj.frames
                    while (_g1 < len(_g2)):
                        f = _g2[_g1]
                        _g1 = (_g1 + 1)
                        if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))) != 0):
                            f1 = f.tx
                            self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                            f2 = f.ty
                            self.dataOut.writeFloat((0 if ((f2 == 0)) else f2))
                            f3 = f.tz
                            self.dataOut.writeFloat((0 if ((f3 == 0)) else f3))
                        if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))) != 0):
                            f4 = ((((f.qx * f.qx) + ((f.qy * f.qy))) + ((f.qz * f.qz))) + ((f.qw * f.qw)))
                            ql = (Math.NaN if ((f4 < 0)) else python_lib_Math.sqrt(f4))
                            if (f.qw < 0):
                                ql = -ql
                            f5 = self.round((f.qx / ql))
                            self.dataOut.writeFloat((0 if ((f5 == 0)) else f5))
                            f6 = self.round((f.qy / ql))
                            self.dataOut.writeFloat((0 if ((f6 == 0)) else f6))
                            f7 = self.round((f.qz / ql))
                            self.dataOut.writeFloat((0 if ((f7 == 0)) else f7))
                        if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))) != 0):
                            f8 = f.sx
                            self.dataOut.writeFloat((0 if ((f8 == 0)) else f8))
                            f9 = f.sy
                            self.dataOut.writeFloat((0 if ((f9 == 0)) else f9))
                            f10 = f.sz
                            self.dataOut.writeFloat((0 if ((f10 == 0)) else f10))
            if (obj.uvs is not None):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasUV.index)))
                if (count == 0):
                    count = (len(obj.uvs) >> 1)
                elif (count != ((len(obj.uvs) >> 1))):
                    raise haxe_Exception.thrown("assert")
                if (self.d.version < 3):
                    _g3 = 0
                    _g4 = obj.uvs
                    while (_g3 < len(_g4)):
                        f11 = _g4[_g3]
                        _g3 = (_g3 + 1)
                        self.dataOut.writeFloat((0 if ((f11 == 0)) else f11))
            if (obj.alphas is not None):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasAlpha.index)))
                if (count == 0):
                    count = len(obj.alphas)
                elif (count != len(obj.alphas)):
                    raise haxe_Exception.thrown("assert")
                if (self.d.version < 3):
                    _g5 = 0
                    _g6 = obj.alphas
                    while (_g5 < len(_g6)):
                        f12 = _g6[_g5]
                        _g5 = (_g5 + 1)
                        self.dataOut.writeFloat((0 if ((f12 == 0)) else f12))
            if (obj.propValues is not None):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))
                _this = o.props
                x = obj.propName
                _this.append(x)
                if (count == 0):
                    count = len(obj.propValues)
                elif (count != len(obj.propValues)):
                    raise haxe_Exception.thrown("assert")
                if (self.d.version < 3):
                    _g7 = 0
                    _g8 = obj.propValues
                    while (_g7 < len(_g8)):
                        f13 = _g8[_g7]
                        _g7 = (_g7 + 1)
                        self.dataOut.writeFloat((0 if ((f13 == 0)) else f13))
            if (count == 0):
                raise haxe_Exception.thrown("assert")
            if (count == 1):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.SingleFrame.index)))
                self.writeFrame(obj,0)
            else:
                if (count != anim.frameCount):
                    raise haxe_Exception.thrown("assert")
                animatedObjects.append(obj)
            _this1 = a.objects
            _this1.append(o)
        _g = 0
        _g1 = anim.frameCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            while (_g2 < len(animatedObjects)):
                obj = (animatedObjects[_g2] if _g2 >= 0 and _g2 < len(animatedObjects) else None)
                _g2 = (_g2 + 1)
                self.writeFrame(obj,i)
        return a

    def toHMD(self,filePath,includeGeometry):
        if (not includeGeometry):
            self.optimizeSkin = False
        self.leftHandConvert()
        self.autoMerge()
        if (filePath is not None):
            _this = filePath.split("\\")
            filePath = "/".join([python_Boot.toString1(x1,'') for x1 in _this]).lower()
            if (not filePath.endswith("/")):
                filePath = (("null" if filePath is None else filePath) + "/")
        self.filePath = filePath
        self.d = hxd_fmt_hmd_Data()
        self.d.version = 3
        self.d.geometries = []
        self.d.materials = []
        self.d.models = []
        self.d.animations = []
        self.dataOut = haxe_io_BytesOutput()
        self.addModels(includeGeometry)
        names = self.getAnimationNames()
        _g = 0
        while (_g < len(names)):
            animName = (names[_g] if _g >= 0 and _g < len(names) else None)
            _g = (_g + 1)
            anim = self.loadAnimation(animName)
            if (anim is not None):
                _this = self.d.animations
                x = self.makeAnimation(anim)
                _this.append(x)
        self.d.data = self.dataOut.getBytes()
        return self.d

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.d = None
        _hx_o.dataOut = None
        _hx_o.filePath = None
        _hx_o.tmp = None
        _hx_o.absoluteTexturePath = None
        _hx_o.optimizeSkin = None
        _hx_o.floatSkinIndexes = None
hxd_fmt_fbx_HMDOut._hx_class = hxd_fmt_fbx_HMDOut
_hx_classes["hxd.fmt.fbx.HMDOut"] = hxd_fmt_fbx_HMDOut

class hxd_fmt_fbx__Parser_Token(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.fbx._Parser.Token"
    _hx_constructs = ["TIdent", "TNode", "TInt", "TFloat", "TString", "TLength", "TBraceOpen", "TBraceClose", "TColon", "TEof"]

    @staticmethod
    def TIdent(s):
        return hxd_fmt_fbx__Parser_Token("TIdent", 0, (s,))

    @staticmethod
    def TNode(s):
        return hxd_fmt_fbx__Parser_Token("TNode", 1, (s,))

    @staticmethod
    def TInt(s):
        return hxd_fmt_fbx__Parser_Token("TInt", 2, (s,))

    @staticmethod
    def TFloat(s):
        return hxd_fmt_fbx__Parser_Token("TFloat", 3, (s,))

    @staticmethod
    def TString(s):
        return hxd_fmt_fbx__Parser_Token("TString", 4, (s,))

    @staticmethod
    def TLength(v):
        return hxd_fmt_fbx__Parser_Token("TLength", 5, (v,))
hxd_fmt_fbx__Parser_Token.TBraceOpen = hxd_fmt_fbx__Parser_Token("TBraceOpen", 6, ())
hxd_fmt_fbx__Parser_Token.TBraceClose = hxd_fmt_fbx__Parser_Token("TBraceClose", 7, ())
hxd_fmt_fbx__Parser_Token.TColon = hxd_fmt_fbx__Parser_Token("TColon", 8, ())
hxd_fmt_fbx__Parser_Token.TEof = hxd_fmt_fbx__Parser_Token("TEof", 9, ())
hxd_fmt_fbx__Parser_Token._hx_class = hxd_fmt_fbx__Parser_Token
_hx_classes["hxd.fmt.fbx._Parser.Token"] = hxd_fmt_fbx__Parser_Token


class hxd_fmt_fbx_Parser:
    _hx_class_name = "hxd.fmt.fbx.Parser"
    _hx_is_interface = "False"
    __slots__ = ("line", "buf", "bytes", "pos", "token", "binary", "fbxVersion")
    _hx_fields = ["line", "buf", "bytes", "pos", "token", "binary", "fbxVersion"]
    _hx_methods = ["parseText", "parseBytes", "parseNodes", "parseNode", "parseBinaryNodes", "readBinaryString", "parseBinaryNode", "readBinaryProperty", "except", "peek", "next", "error", "unexpected", "tokenStr", "nextChar", "getVersionedInt32", "getInt32", "getInt16", "getFloat", "getDouble", "i64ToFloat", "getByte", "getBuf", "isIdentChar", "nextToken"]
    _hx_statics = ["parse"]

    def __init__(self):
        self.fbxVersion = None
        self.binary = None
        self.token = None
        self.pos = None
        self.bytes = None
        self.buf = None
        self.line = None

    def parseText(self,_hx_str):
        self.buf = _hx_str
        self.pos = 0
        self.line = 1
        self.binary = False
        self.token = None
        return _hx_AnonObject({'name': "Root", 'props': [hxd_fmt_fbx_FbxProp.PInt(0), hxd_fmt_fbx_FbxProp.PString("Root"), hxd_fmt_fbx_FbxProp.PString("Root")], 'childs': self.parseNodes()})

    def parseBytes(self,_hx_bytes):
        self.bytes = _hx_bytes
        self.pos = 0
        self.line = 0
        self.binary = ((_hx_bytes.getString(0,20) == "Kaydara FBX Binary  ") and ((_hx_bytes.b[20] == 0)))
        self.token = None
        if self.binary:
            v = (((_hx_bytes.b[23] | ((_hx_bytes.b[24] << 8))) | ((_hx_bytes.b[25] << 16))) | ((_hx_bytes.b[26] << 24)))
            self.fbxVersion = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            self.pos = 27
            _this = self.bytes
            pos = self.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + (8 if ((self.fbxVersion >= 7500)) else 4))
            _hx_local_0.pos
            firstNode = self.parseBinaryNode(i)
            if (firstNode.name != ""):
                nodes = [firstNode]
                _this = self.bytes
                pos = self.pos
                v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
                i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.pos
                _hx_local_2.pos = (_hx_local_3 + (8 if ((self.fbxVersion >= 7500)) else 4))
                _hx_local_2.pos
                size = i
                while (size != 0):
                    x = self.parseBinaryNode(size)
                    nodes.append(x)
                    _this = self.bytes
                    pos = self.pos
                    v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
                    i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.pos
                    _hx_local_4.pos = (_hx_local_5 + (8 if ((self.fbxVersion >= 7500)) else 4))
                    _hx_local_4.pos
                    size = i
                return _hx_AnonObject({'name': "Root", 'props': [hxd_fmt_fbx_FbxProp.PInt(0), hxd_fmt_fbx_FbxProp.PString("Root"), hxd_fmt_fbx_FbxProp.PString("Root")], 'childs': nodes})
            else:
                return firstNode
        return _hx_AnonObject({'name': "Root", 'props': [hxd_fmt_fbx_FbxProp.PInt(0), hxd_fmt_fbx_FbxProp.PString("Root"), hxd_fmt_fbx_FbxProp.PString("Root")], 'childs': self.parseNodes()})

    def parseNodes(self):
        nodes = []
        while True:
            _g = self.peek()
            if (_g is not None):
                tmp = _g.index
                if ((tmp == 9) or ((tmp == 7))):
                    return nodes
                else:
                    pass
            x = self.parseNode()
            nodes.append(x)

    def parseNode(self):
        t = self.next()
        name = None
        if (t.index == 1):
            n = t.params[0]
            name = n
        else:
            name = self.unexpected(t)
        props = []
        childs = None
        while True:
            t = self.next()
            tmp = t.index
            if (tmp == 0):
                s = t.params[0]
                props.append(hxd_fmt_fbx_FbxProp.PIdent(s))
            elif (tmp == 1):
                _g = t.params[0]
                self.token = t
            elif (tmp == 2):
                s1 = t.params[0]
                x = hxd_fmt_fbx_FbxProp.PInt(Std.parseInt(s1))
                props.append(x)
            elif (tmp == 3):
                s2 = t.params[0]
                x1 = hxd_fmt_fbx_FbxProp.PFloat(Std.parseFloat(s2))
                props.append(x1)
            elif (tmp == 4):
                s3 = t.params[0]
                props.append(hxd_fmt_fbx_FbxProp.PString(s3))
            elif (tmp == 5):
                v = t.params[0]
                self._hx_except(hxd_fmt_fbx__Parser_Token.TBraceOpen)
                self._hx_except(hxd_fmt_fbx__Parser_Token.TNode("a"))
                ints = []
                floats = None
                i = 0
                while (i < v):
                    t = self.next()
                    tmp1 = t.index
                    if (tmp1 == 2):
                        s4 = t.params[0]
                        i = (i + 1)
                        if (floats is None):
                            x2 = Std.parseInt(s4)
                            ints.append(x2)
                        else:
                            x3 = Std.parseInt(s4)
                            floats.append(x3)
                    elif (tmp1 == 3):
                        s5 = t.params[0]
                        i = (i + 1)
                        if (floats is None):
                            floats = []
                            _g1 = 0
                            while (_g1 < len(ints)):
                                i1 = (ints[_g1] if _g1 >= 0 and _g1 < len(ints) else None)
                                _g1 = (_g1 + 1)
                                floats.append(i1)
                            ints = None
                        x4 = Std.parseFloat(s5)
                        floats.append(x4)
                    elif (tmp1 == 8):
                        continue
                    else:
                        self.unexpected(t)
                props.append((hxd_fmt_fbx_FbxProp.PInts(ints) if ((floats is None)) else hxd_fmt_fbx_FbxProp.PFloats(floats)))
                if (self.peek() == hxd_fmt_fbx__Parser_Token.TColon):
                    self._hx_except(hxd_fmt_fbx__Parser_Token.TColon)
                self._hx_except(hxd_fmt_fbx__Parser_Token.TBraceClose)
                break
            elif ((tmp == 7) or ((tmp == 6))):
                self.token = t
            else:
                self.unexpected(t)
            t = self.next()
            tmp2 = t.index
            if (tmp2 == 1):
                _g2 = t.params[0]
                self.token = t
                break
            elif (tmp2 == 6):
                childs = self.parseNodes()
                self._hx_except(hxd_fmt_fbx__Parser_Token.TBraceClose)
                break
            elif (tmp2 == 7):
                self.token = t
                break
            elif (tmp2 == 8):
                pass
            else:
                self.unexpected(t)
        if (childs is None):
            childs = []
        return _hx_AnonObject({'name': name, 'props': props, 'childs': childs})

    def parseBinaryNodes(self,output):
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + (8 if ((self.fbxVersion >= 7500)) else 4))
        _hx_local_0.pos
        size = i
        while (size != 0):
            x = self.parseBinaryNode(size)
            output.append(x)
            _this = self.bytes
            pos = self.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + (8 if ((self.fbxVersion >= 7500)) else 4))
            _hx_local_2.pos
            size = i

    def readBinaryString(self,length):
        if (length == 0):
            return ""
        _hx_str = self.bytes.getString(self.pos,length)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + length)
        _hx_local_0.pos
        _hx_len = len(_hx_str)
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (HxString.charCodeAt(_hx_str,i) == 0):
                return HxString.substr(_hx_str,0,i)
        return _hx_str

    def parseBinaryNode(self,nextRecord):
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + (8 if ((self.fbxVersion >= 7500)) else 4))
        _hx_local_0.pos
        numProperties = i
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.pos
        _hx_local_2.pos = (_hx_local_3 + (8 if ((self.fbxVersion >= 7500)) else 4))
        _hx_local_2.pos
        propertyListLength = i
        pos = self.pos
        self.pos = (self.pos + 1)
        name = self.readBinaryString(self.bytes.b[pos])
        props = list()
        childs = list()
        propStart = self.pos
        _g = 0
        _g1 = numProperties
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = self.readBinaryProperty()
            props.append(x)
        self.pos = (propStart + propertyListLength)
        if (self.pos < nextRecord):
            self.parseBinaryNodes(childs)
        self.pos = nextRecord
        return _hx_AnonObject({'name': name, 'props': props, 'childs': childs})

    def readBinaryProperty(self):
        _gthis = self
        arrayLen = 0
        arrayEncoding = None
        arrayCompressedLen = None
        arrayBytes = None
        arrayBytesPos = 0
        pos = self.pos
        self.pos = (self.pos + 1)
        _hx_type = self.bytes.b[pos]
        type1 = _hx_type
        if (type1 == 67):
            pos = self.pos
            self.pos = (self.pos + 1)
            return hxd_fmt_fbx_FbxProp.PInt(self.bytes.b[pos])
        elif (type1 == 68):
            d = self.bytes.getDouble(self.pos)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 8)
            _hx_local_0.pos
            return hxd_fmt_fbx_FbxProp.PFloat(d)
        elif (type1 == 70):
            f = self.bytes.getFloat(self.pos)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 4)
            _hx_local_2.pos
            return hxd_fmt_fbx_FbxProp.PFloat(f)
        elif (type1 == 73):
            _this = self.bytes
            pos = self.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.pos
            _hx_local_4.pos = (_hx_local_5 + 4)
            _hx_local_4.pos
            return hxd_fmt_fbx_FbxProp.PInt(i)
        elif (type1 == 76):
            _this = self.bytes
            pos = self.pos
            pos1 = (pos + 4)
            v = (((_this.b[pos1] | ((_this.b[(pos1 + 1)] << 8))) | ((_this.b[(pos1 + 2)] << 16))) | ((_this.b[(pos1 + 3)] << 24)))
            v1 = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i64_high = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            i64_low = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 8)
            _hx_local_6.pos
            return hxd_fmt_fbx_FbxProp.PFloat(((i64_high * 4294967296) + (((((i64_low & 2147483647)) + 2147483648) if ((((i64_low & -2147483648)) != 0)) else i64_low))))
        elif (type1 == 82):
            _this = self.bytes
            pos = self.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.pos
            _hx_local_8.pos = (_hx_local_9 + 4)
            _hx_local_8.pos
            _hx_len = i
            data = haxe_io_Bytes.alloc(_hx_len)
            data.blit(0,self.bytes,self.pos,_hx_len)
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.pos
            _hx_local_10.pos = (_hx_local_11 + _hx_len)
            _hx_local_10.pos
            return hxd_fmt_fbx_FbxProp.PBinary(data)
        elif (type1 == 83):
            _this = self.bytes
            pos = self.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + 4)
            _hx_local_12.pos
            return hxd_fmt_fbx_FbxProp.PString(self.readBinaryString(i))
        elif (type1 == 89):
            i = (self.bytes.b[self.pos] | ((self.bytes.b[(self.pos + 1)] << 8)))
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.pos
            _hx_local_14.pos = (_hx_local_15 + 2)
            _hx_local_14.pos
            return hxd_fmt_fbx_FbxProp.PInt(i)
        elif (type1 == 98):
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i
            arrayEncoding1 = arrayEncoding
            if (arrayEncoding1 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + arrayLen)
            elif (arrayEncoding1 == 1):
                arrayBytesPos = 0
                buf = _gthis.bytes.sub(_gthis.pos,arrayCompressedLen)
                arrayBytes = haxe_zip_Uncompress.run(buf)
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            bools = list()
            while (arrayLen > 0):
                pos = arrayBytesPos
                arrayBytesPos = (arrayBytesPos + 1)
                x = arrayBytes.b[pos]
                bools.append(x)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PInts(bools)
        elif (type1 == 100):
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i
            arrayEncoding1 = arrayEncoding
            if (arrayEncoding1 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + ((arrayLen * 8)))
            elif (arrayEncoding1 == 1):
                arrayBytesPos = 0
                buf = _gthis.bytes.sub(_gthis.pos,arrayCompressedLen)
                arrayBytes = haxe_zip_Uncompress.run(buf)
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            doubles = list()
            while (arrayLen > 0):
                x = arrayBytes.getDouble(arrayBytesPos)
                doubles.append(x)
                arrayBytesPos = (arrayBytesPos + 8)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PFloats(doubles)
        elif (type1 == 102):
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i
            arrayEncoding1 = arrayEncoding
            if (arrayEncoding1 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + ((arrayLen * 4)))
            elif (arrayEncoding1 == 1):
                arrayBytesPos = 0
                buf = _gthis.bytes.sub(_gthis.pos,arrayCompressedLen)
                arrayBytes = haxe_zip_Uncompress.run(buf)
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            floats = list()
            while (arrayLen > 0):
                x = arrayBytes.getFloat(arrayBytesPos)
                floats.append(x)
                arrayBytesPos = (arrayBytesPos + 4)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PFloats(floats)
        elif (type1 == 105):
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i
            arrayEncoding1 = arrayEncoding
            if (arrayEncoding1 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + ((arrayLen * 4)))
            elif (arrayEncoding1 == 1):
                arrayBytesPos = 0
                buf = _gthis.bytes.sub(_gthis.pos,arrayCompressedLen)
                arrayBytes = haxe_zip_Uncompress.run(buf)
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            ints = list()
            while (arrayLen > 0):
                v = (((arrayBytes.b[arrayBytesPos] | ((arrayBytes.b[(arrayBytesPos + 1)] << 8))) | ((arrayBytes.b[(arrayBytesPos + 2)] << 16))) | ((arrayBytes.b[(arrayBytesPos + 3)] << 24)))
                ints.append(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v))
                arrayBytesPos = (arrayBytesPos + 4)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PInts(ints)
        elif (type1 == 108):
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i
            arrayEncoding1 = arrayEncoding
            if (arrayEncoding1 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + ((arrayLen * 8)))
            elif (arrayEncoding1 == 1):
                arrayBytesPos = 0
                buf = _gthis.bytes.sub(_gthis.pos,arrayCompressedLen)
                arrayBytes = haxe_zip_Uncompress.run(buf)
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            i64s = list()
            while (arrayLen > 0):
                pos = (arrayBytesPos + 4)
                v = (((arrayBytes.b[pos] | ((arrayBytes.b[(pos + 1)] << 8))) | ((arrayBytes.b[(pos + 2)] << 16))) | ((arrayBytes.b[(pos + 3)] << 24)))
                v1 = (((arrayBytes.b[arrayBytesPos] | ((arrayBytes.b[(arrayBytesPos + 1)] << 8))) | ((arrayBytes.b[(arrayBytesPos + 2)] << 16))) | ((arrayBytes.b[(arrayBytesPos + 3)] << 24)))
                i64_high = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                i64_low = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
                i64s.append(((i64_high * 4294967296) + (((((i64_low & 2147483647)) + 2147483648) if ((((i64_low & -2147483648)) != 0)) else i64_low))))
                arrayBytesPos = (arrayBytesPos + 8)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PFloats(i64s)
        else:
            return self.error(((("Unknown property type: " + Std.string(_hx_type)) + "/") + HxOverrides.stringOrNull("".join(map(chr,[_hx_type])))))

    def _hx_except(self,_hx_except):
        t = self.next()
        if (not Type.enumEq(t,_hx_except)):
            self.error((((("Unexpected '" + HxOverrides.stringOrNull(self.tokenStr(t))) + "' (") + HxOverrides.stringOrNull(self.tokenStr(_hx_except))) + " expected)"))

    def peek(self):
        if (self.token is None):
            self.token = self.nextToken()
        return self.token

    def next(self):
        if (self.token is None):
            return self.nextToken()
        tmp = self.token
        self.token = None
        return tmp

    def error(self,msg):
        raise haxe_Exception.thrown((((("null" if msg is None else msg) + " (line ") + Std.string(self.line)) + ")"))

    def unexpected(self,t):
        return self.error(("Unexpected " + HxOverrides.stringOrNull(self.tokenStr(t))))

    def tokenStr(self,t):
        tmp = t.index
        if (tmp == 0):
            i = t.params[0]
            return i
        elif (tmp == 1):
            i = t.params[0]
            return (("null" if i is None else i) + ":")
        elif (tmp == 2):
            i = t.params[0]
            return i
        elif (tmp == 3):
            f = t.params[0]
            return f
        elif (tmp == 4):
            s = t.params[0]
            return (("\"" + ("null" if s is None else s)) + "\"")
        elif (tmp == 5):
            l = t.params[0]
            return ("*" + Std.string(l))
        elif (tmp == 6):
            return "{"
        elif (tmp == 7):
            return "}"
        elif (tmp == 8):
            return ","
        elif (tmp == 9):
            return "<eof>"
        else:
            pass

    def nextChar(self):
        s = self.buf
        index = self.pos
        self.pos = (self.pos + 1)
        if (index >= len(s)):
            return -1
        else:
            return ord(s[index])

    def getVersionedInt32(self):
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + (8 if ((self.fbxVersion >= 7500)) else 4))
        _hx_local_0.pos
        return i

    def getInt32(self):
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 4)
        _hx_local_0.pos
        return i

    def getInt16(self):
        i = (self.bytes.b[self.pos] | ((self.bytes.b[(self.pos + 1)] << 8)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        return i

    def getFloat(self):
        f = self.bytes.getFloat(self.pos)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 4)
        _hx_local_0.pos
        return f

    def getDouble(self):
        d = self.bytes.getDouble(self.pos)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 8)
        _hx_local_0.pos
        return d

    def i64ToFloat(self,i64):
        return ((i64.high * 4294967296) + (((((i64.low & 2147483647)) + 2147483648) if ((((i64.low & -2147483648)) != 0)) else i64.low)))

    def getByte(self):
        pos = self.pos
        self.pos = (self.pos + 1)
        return self.bytes.b[pos]

    def getBuf(self,pos,_hx_len):
        return HxString.substr(self.buf,pos,_hx_len)

    def isIdentChar(self,c):
        if (not ((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 95))))):
            return (c == 45)
        else:
            return True

    def nextToken(self):
        start = self.pos
        while True:
            s = self.buf
            index = self.pos
            self.pos = (self.pos + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            c1 = c
            if (c1 == 10):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.line
                _hx_local_0.line = (_hx_local_1 + 1)
                _hx_local_1
                start = (start + 1)
            elif (((c1 == 32) or ((c1 == 13))) or ((c1 == 9))):
                start = (start + 1)
            elif (c1 == 34):
                start = self.pos
                while True:
                    s1 = self.buf
                    index1 = self.pos
                    self.pos = (self.pos + 1)
                    c = (-1 if ((index1 >= len(s1))) else ord(s1[index1]))
                    if (c == 34):
                        break
                    if ((c == -1) or ((c == 10))):
                        self.error("Unclosed string")
                return hxd_fmt_fbx__Parser_Token.TString(HxString.substr(self.buf,start,((self.pos - start) - 1)))
            elif (c1 == 42):
                start = self.pos
                while True:
                    s2 = self.buf
                    index2 = self.pos
                    self.pos = (self.pos + 1)
                    c = (-1 if ((index2 >= len(s2))) else ord(s2[index2]))
                    if (not (((c >= 48) and ((c <= 57))))):
                        break
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.pos
                _hx_local_4.pos = (_hx_local_5 - 1)
                _hx_local_5
                return hxd_fmt_fbx__Parser_Token.TLength(Std.parseInt(HxString.substr(self.buf,start,(self.pos - start))))
            elif (c1 == 44):
                return hxd_fmt_fbx__Parser_Token.TColon
            elif (c1 == 59):
                while True:
                    s3 = self.buf
                    index3 = self.pos
                    self.pos = (self.pos + 1)
                    c2 = (-1 if ((index3 >= len(s3))) else ord(s3[index3]))
                    if ((c2 == -1) or ((c2 == 10))):
                        _hx_local_6 = self
                        _hx_local_7 = _hx_local_6.pos
                        _hx_local_6.pos = (_hx_local_7 - 1)
                        _hx_local_7
                        break
                start = self.pos
            elif (c1 == 123):
                return hxd_fmt_fbx__Parser_Token.TBraceOpen
            elif (c1 == 125):
                return hxd_fmt_fbx__Parser_Token.TBraceClose
            else:
                if ((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or ((c == 95))):
                    while True:
                        s4 = self.buf
                        index4 = self.pos
                        self.pos = (self.pos + 1)
                        c = (-1 if ((index4 >= len(s4))) else ord(s4[index4]))
                        if (not (((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 95))) or ((c == 45))))):
                            break
                    if (c == 58):
                        return hxd_fmt_fbx__Parser_Token.TNode(HxString.substr(self.buf,start,((self.pos - start) - 1)))
                    _hx_local_8 = self
                    _hx_local_9 = _hx_local_8.pos
                    _hx_local_8.pos = (_hx_local_9 - 1)
                    _hx_local_9
                    return hxd_fmt_fbx__Parser_Token.TIdent(HxString.substr(self.buf,start,(self.pos - start)))
                if (((c >= 48) and ((c <= 57))) or ((c == 45))):
                    while True:
                        s5 = self.buf
                        index5 = self.pos
                        self.pos = (self.pos + 1)
                        c = (-1 if ((index5 >= len(s5))) else ord(s5[index5]))
                        if (not (((c >= 48) and ((c <= 57))))):
                            break
                    if ((((c != 46) and ((c != 69))) and ((c != 101))) and (((self.pos - start) < 10))):
                        _hx_local_10 = self
                        _hx_local_11 = _hx_local_10.pos
                        _hx_local_10.pos = (_hx_local_11 - 1)
                        _hx_local_11
                        return hxd_fmt_fbx__Parser_Token.TInt(HxString.substr(self.buf,start,(self.pos - start)))
                    if (c == 46):
                        while True:
                            s6 = self.buf
                            index6 = self.pos
                            self.pos = (self.pos + 1)
                            c = (-1 if ((index6 >= len(s6))) else ord(s6[index6]))
                            if (not (((c >= 48) and ((c <= 57))))):
                                break
                    if ((c == 101) or ((c == 69))):
                        s7 = self.buf
                        index7 = self.pos
                        self.pos = (self.pos + 1)
                        c = (-1 if ((index7 >= len(s7))) else ord(s7[index7]))
                        if ((c != 45) and ((c != 43))):
                            _hx_local_12 = self
                            _hx_local_13 = _hx_local_12.pos
                            _hx_local_12.pos = (_hx_local_13 - 1)
                            _hx_local_13
                        while True:
                            s8 = self.buf
                            index8 = self.pos
                            self.pos = (self.pos + 1)
                            c = (-1 if ((index8 >= len(s8))) else ord(s8[index8]))
                            if (not (((c >= 48) and ((c <= 57))))):
                                break
                    _hx_local_14 = self
                    _hx_local_15 = _hx_local_14.pos
                    _hx_local_14.pos = (_hx_local_15 - 1)
                    _hx_local_15
                    return hxd_fmt_fbx__Parser_Token.TFloat(HxString.substr(self.buf,start,(self.pos - start)))
                if (c == -1):
                    _hx_local_16 = self
                    _hx_local_17 = _hx_local_16.pos
                    _hx_local_16.pos = (_hx_local_17 - 1)
                    _hx_local_17
                    return hxd_fmt_fbx__Parser_Token.TEof
                self.error((("Unexpected char '" + HxOverrides.stringOrNull("".join(map(chr,[c])))) + "'"))

    @staticmethod
    def parse(data):
        if ((data.length > 20) and ((data.getString(0,20) == "Kaydara FBX Binary  "))):
            return hxd_fmt_fbx_Parser().parseBytes(data)
        return hxd_fmt_fbx_Parser().parseText(data.toString())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.line = None
        _hx_o.buf = None
        _hx_o.bytes = None
        _hx_o.pos = None
        _hx_o.token = None
        _hx_o.binary = None
        _hx_o.fbxVersion = None
hxd_fmt_fbx_Parser._hx_class = hxd_fmt_fbx_Parser
_hx_classes["hxd.fmt.fbx.Parser"] = hxd_fmt_fbx_Parser


class hxd_fmt_hdr_Reader:
    _hx_class_name = "hxd.fmt.hdr.Reader"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["decode"]

    @staticmethod
    def decode(_hx_bytes,sRGB):
        f = haxe_io_BytesInput(_hx_bytes)
        width = 0
        height = 0
        keys = haxe_ds_StringMap()
        while True:
            line = f.readLine()
            if (line == ""):
                break
            if (HxString.charCodeAt(line,0) == 35):
                continue
            nameValue = line.split("=")
            if (len(nameValue) > 1):
                key = (None if ((len(nameValue) == 0)) else nameValue.pop(0))
                value = "=".join([python_Boot.toString1(x1,'') for x1 in nameValue])
                keys.h[key] = value
        _this = f.readLine()
        parts = _this.split(" ")
        height = Std.parseInt((parts[1] if 1 < len(parts) else None))
        width = Std.parseInt((parts[3] if 3 < len(parts) else None))
        gamma = (keys.h.get("GAMMA",None) == "1")
        data = haxe_io_Bytes.alloc((((width * height) * 4) * 4))
        exposure = 1.0
        exp = keys.h.get("EXPOSURE",None)
        if (exp is not None):
            exp1 = Std.parseFloat(exp)
            if ((exp1 < 1e-12) or ((exp1 < 1e12))):
                exposure = exp1
        gammaCorrect = (1 if sRGB else 0.45454545454545453)
        _g = []
        _g1 = 0
        while (_g1 < 256):
            e = _g1
            _g1 = (_g1 + 1)
            x = Math.pow(e,gammaCorrect)
            _g.append(x)
        gammaVals = _g
        _g = []
        _g1 = 0
        while (_g1 < 256):
            e = _g1
            _g1 = (_g1 + 1)
            x = Math.pow((Math.pow(2,(e - 128)) / ((256 * exposure))),gammaCorrect)
            _g.append(x)
        exps = _g
        _g = keys.h.get("FORMAT",None)
        if (_g is None):
            fmt = _g
            raise haxe_Exception.thrown(("Unsupported HDR format " + ("null" if fmt is None else fmt)))
        elif (_g == "32-bit_rle_rgbe"):
            dataPos = f.pos
            scanLen = (width * 4)
            scanLine = haxe_io_Bytes.alloc(scanLen)
            widthBE = ((width >> 8) | ((((width & 255)) << 8)))
            _g1 = 0
            _g2 = height
            while (_g1 < _g2):
                y = _g1
                _g1 = (_g1 + 1)
                v = (((_hx_bytes.b[dataPos] | ((_hx_bytes.b[(dataPos + 1)] << 8))) | ((_hx_bytes.b[(dataPos + 2)] << 16))) | ((_hx_bytes.b[(dataPos + 3)] << 24)))
                h = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                if ((((h & 65535)) != 514) or ((HxOverrides.rshift(h, 16) != widthBE))):
                    scanLine.blit(0,_hx_bytes,dataPos,(width * 4))
                    dataPos = (dataPos + ((width * 4)))
                else:
                    dataPos = (dataPos + 4)
                    p = 0
                    end = (width * 4)
                    while (p < end):
                        pos = dataPos
                        dataPos = (dataPos + 1)
                        _hx_len = _hx_bytes.b[pos]
                        if (_hx_len > 128):
                            _hx_len = (_hx_len - 128)
                            pos1 = dataPos
                            dataPos = (dataPos + 1)
                            scanLine.fill(p,_hx_len,_hx_bytes.b[pos1])
                        else:
                            scanLine.blit(p,_hx_bytes,dataPos,_hx_len)
                            dataPos = (dataPos + _hx_len)
                        p = (p + _hx_len)
                pos2 = ((y * width) * 16)
                _g3 = 0
                _g4 = width
                while (_g3 < _g4):
                    x = _g3
                    _g3 = (_g3 + 1)
                    e = python_internal_ArrayImpl._get(exps, scanLine.b[(x + ((width * 3)))])
                    data.setFloat(pos2,(python_internal_ArrayImpl._get(gammaVals, scanLine.b[x]) * e))
                    pos2 = (pos2 + 4)
                    data.setFloat(pos2,(python_internal_ArrayImpl._get(gammaVals, scanLine.b[(x + width)]) * e))
                    pos2 = (pos2 + 4)
                    data.setFloat(pos2,(python_internal_ArrayImpl._get(gammaVals, scanLine.b[(x + ((width << 1)))]) * e))
                    pos2 = (pos2 + 4)
                    data.setFloat(pos2,1.0)
                    pos2 = (pos2 + 4)
        else:
            fmt = _g
            raise haxe_Exception.thrown(("Unsupported HDR format " + ("null" if fmt is None else fmt)))
        return _hx_AnonObject({'width': width, 'height': height, 'bytes': data, 'gamma': gamma})
hxd_fmt_hdr_Reader._hx_class = hxd_fmt_hdr_Reader
_hx_classes["hxd.fmt.hdr.Reader"] = hxd_fmt_hdr_Reader


class hxd_fmt_hmd__Data_GeometryDataFormat_Impl_:
    _hx_class_name = "hxd.fmt.hmd._Data.GeometryDataFormat_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["DFloat", "DVec2", "DVec3", "DVec4", "DBytes4", "_new", "getSize", "toInt", "toString", "fromInt"]

    @staticmethod
    def _new(v):
        this1 = v
        return this1

    @staticmethod
    def getSize(this1):
        return (this1 & 7)

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def toString(this1):
        this2 = this1
        _g = this2
        if (_g == 1):
            return "DFloat"
        elif (_g == 2):
            return "DVec2"
        elif (_g == 3):
            return "DVec3"
        elif (_g == 4):
            return "DVec4"
        elif (_g == 9):
            return "DBytes4"
        else:
            pass

    @staticmethod
    def fromInt(v):
        this1 = v
        return this1
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_._hx_class = hxd_fmt_hmd__Data_GeometryDataFormat_Impl_
_hx_classes["hxd.fmt.hmd._Data.GeometryDataFormat_Impl_"] = hxd_fmt_hmd__Data_GeometryDataFormat_Impl_

class hxd_fmt_hmd_Property(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.hmd.Property"
    _hx_constructs = ["CameraFOVY", "Unused_HasMaterialFlags", "HasExtraTextures"]

    @staticmethod
    def CameraFOVY(v):
        return hxd_fmt_hmd_Property("CameraFOVY", 0, (v,))
hxd_fmt_hmd_Property.Unused_HasMaterialFlags = hxd_fmt_hmd_Property("Unused_HasMaterialFlags", 1, ())
hxd_fmt_hmd_Property.HasExtraTextures = hxd_fmt_hmd_Property("HasExtraTextures", 2, ())
hxd_fmt_hmd_Property._hx_class = hxd_fmt_hmd_Property
_hx_classes["hxd.fmt.hmd.Property"] = hxd_fmt_hmd_Property


class hxd_fmt_hmd_Position:
    _hx_class_name = "hxd.fmt.hmd.Position"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "qx", "qy", "qz", "sx", "sy", "sz")
    _hx_fields = ["x", "y", "z", "qx", "qy", "qz", "sx", "sy", "sz"]
    _hx_methods = ["loadQuaternion", "get_qw", "toMatrix"]
    _hx_statics = ["QTMP"]

    def __init__(self):
        self.sz = None
        self.sy = None
        self.sx = None
        self.qz = None
        self.qy = None
        self.qx = None
        self.z = None
        self.y = None
        self.x = None

    def loadQuaternion(self,q):
        q.x = self.qx
        q.y = self.qy
        q.z = self.qz
        q.w = self.get_qw()

    def get_qw(self):
        qw = (1 - ((((self.qx * self.qx) + ((self.qy * self.qy))) + ((self.qz * self.qz)))))
        if (qw < 0):
            f = -qw
            return -((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f)))
        elif (qw < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(qw)

    def toMatrix(self,postScale = None):
        if (postScale is None):
            postScale = False
        m = h3d_Matrix()
        q = hxd_fmt_hmd_Position.QTMP
        q.x = self.qx
        q.y = self.qy
        q.z = self.qz
        q.w = self.get_qw()
        q.toMatrix(m)
        if postScale:
            m.translate(self.x,self.y,self.z)
            m.scale(self.sx,self.sy,self.sz)
        else:
            m._11 = (m._11 * self.sx)
            m._12 = (m._12 * self.sx)
            m._13 = (m._13 * self.sx)
            m._21 = (m._21 * self.sy)
            m._22 = (m._22 * self.sy)
            m._23 = (m._23 * self.sy)
            m._31 = (m._31 * self.sz)
            m._32 = (m._32 * self.sz)
            m._33 = (m._33 * self.sz)
            m.translate(self.x,self.y,self.z)
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.qx = None
        _hx_o.qy = None
        _hx_o.qz = None
        _hx_o.sx = None
        _hx_o.sy = None
        _hx_o.sz = None
hxd_fmt_hmd_Position._hx_class = hxd_fmt_hmd_Position
_hx_classes["hxd.fmt.hmd.Position"] = hxd_fmt_hmd_Position


class hxd_fmt_hmd_GeometryFormat:
    _hx_class_name = "hxd.fmt.hmd.GeometryFormat"
    _hx_is_interface = "False"
    __slots__ = ("name", "format")
    _hx_fields = ["name", "format"]

    def __init__(self,name,format):
        self.name = name
        self.format = format

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.format = None
hxd_fmt_hmd_GeometryFormat._hx_class = hxd_fmt_hmd_GeometryFormat
_hx_classes["hxd.fmt.hmd.GeometryFormat"] = hxd_fmt_hmd_GeometryFormat


class hxd_fmt_hmd_Geometry:
    _hx_class_name = "hxd.fmt.hmd.Geometry"
    _hx_is_interface = "False"
    __slots__ = ("props", "vertexCount", "vertexStride", "vertexFormat", "vertexPosition", "indexCounts", "indexPosition", "bounds")
    _hx_fields = ["props", "vertexCount", "vertexStride", "vertexFormat", "vertexPosition", "indexCounts", "indexPosition", "bounds"]
    _hx_methods = ["get_indexCount"]

    def __init__(self):
        self.bounds = None
        self.indexPosition = None
        self.indexCounts = None
        self.vertexPosition = None
        self.vertexFormat = None
        self.vertexStride = None
        self.vertexCount = None
        self.props = None

    def get_indexCount(self):
        k = 0
        _g = 0
        _g1 = self.indexCounts
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            k = (k + i)
        return k

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.props = None
        _hx_o.vertexCount = None
        _hx_o.vertexStride = None
        _hx_o.vertexFormat = None
        _hx_o.vertexPosition = None
        _hx_o.indexCounts = None
        _hx_o.indexPosition = None
        _hx_o.bounds = None
hxd_fmt_hmd_Geometry._hx_class = hxd_fmt_hmd_Geometry
_hx_classes["hxd.fmt.hmd.Geometry"] = hxd_fmt_hmd_Geometry


class hxd_fmt_hmd_Material:
    _hx_class_name = "hxd.fmt.hmd.Material"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "diffuseTexture", "specularTexture", "normalMap", "blendMode")
    _hx_fields = ["name", "props", "diffuseTexture", "specularTexture", "normalMap", "blendMode"]

    def __init__(self):
        self.blendMode = None
        self.normalMap = None
        self.specularTexture = None
        self.diffuseTexture = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.diffuseTexture = None
        _hx_o.specularTexture = None
        _hx_o.normalMap = None
        _hx_o.blendMode = None
hxd_fmt_hmd_Material._hx_class = hxd_fmt_hmd_Material
_hx_classes["hxd.fmt.hmd.Material"] = hxd_fmt_hmd_Material


class hxd_fmt_hmd_SkinJoint:
    _hx_class_name = "hxd.fmt.hmd.SkinJoint"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "parent", "position", "bind", "transpos")
    _hx_fields = ["name", "props", "parent", "position", "bind", "transpos"]

    def __init__(self):
        self.transpos = None
        self.bind = None
        self.position = None
        self.parent = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.parent = None
        _hx_o.position = None
        _hx_o.bind = None
        _hx_o.transpos = None
hxd_fmt_hmd_SkinJoint._hx_class = hxd_fmt_hmd_SkinJoint
_hx_classes["hxd.fmt.hmd.SkinJoint"] = hxd_fmt_hmd_SkinJoint


class hxd_fmt_hmd_SkinSplit:
    _hx_class_name = "hxd.fmt.hmd.SkinSplit"
    _hx_is_interface = "False"
    __slots__ = ("materialIndex", "joints")
    _hx_fields = ["materialIndex", "joints"]

    def __init__(self):
        self.joints = None
        self.materialIndex = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.materialIndex = None
        _hx_o.joints = None
hxd_fmt_hmd_SkinSplit._hx_class = hxd_fmt_hmd_SkinSplit
_hx_classes["hxd.fmt.hmd.SkinSplit"] = hxd_fmt_hmd_SkinSplit


class hxd_fmt_hmd_Skin:
    _hx_class_name = "hxd.fmt.hmd.Skin"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "joints", "split")
    _hx_fields = ["name", "props", "joints", "split"]

    def __init__(self):
        self.split = None
        self.joints = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.joints = None
        _hx_o.split = None
hxd_fmt_hmd_Skin._hx_class = hxd_fmt_hmd_Skin
_hx_classes["hxd.fmt.hmd.Skin"] = hxd_fmt_hmd_Skin


class hxd_fmt_hmd_Model:
    _hx_class_name = "hxd.fmt.hmd.Model"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "parent", "follow", "position", "geometry", "materials", "skin")
    _hx_fields = ["name", "props", "parent", "follow", "position", "geometry", "materials", "skin"]

    def __init__(self):
        self.skin = None
        self.materials = None
        self.geometry = None
        self.position = None
        self.follow = None
        self.parent = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.parent = None
        _hx_o.follow = None
        _hx_o.position = None
        _hx_o.geometry = None
        _hx_o.materials = None
        _hx_o.skin = None
hxd_fmt_hmd_Model._hx_class = hxd_fmt_hmd_Model
_hx_classes["hxd.fmt.hmd.Model"] = hxd_fmt_hmd_Model

class hxd_fmt_hmd_AnimationFlag(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.hmd.AnimationFlag"
    _hx_constructs = ["HasPosition", "HasRotation", "HasScale", "HasUV", "HasAlpha", "SingleFrame", "HasProps", "Reserved"]
hxd_fmt_hmd_AnimationFlag.HasPosition = hxd_fmt_hmd_AnimationFlag("HasPosition", 0, ())
hxd_fmt_hmd_AnimationFlag.HasRotation = hxd_fmt_hmd_AnimationFlag("HasRotation", 1, ())
hxd_fmt_hmd_AnimationFlag.HasScale = hxd_fmt_hmd_AnimationFlag("HasScale", 2, ())
hxd_fmt_hmd_AnimationFlag.HasUV = hxd_fmt_hmd_AnimationFlag("HasUV", 3, ())
hxd_fmt_hmd_AnimationFlag.HasAlpha = hxd_fmt_hmd_AnimationFlag("HasAlpha", 4, ())
hxd_fmt_hmd_AnimationFlag.SingleFrame = hxd_fmt_hmd_AnimationFlag("SingleFrame", 5, ())
hxd_fmt_hmd_AnimationFlag.HasProps = hxd_fmt_hmd_AnimationFlag("HasProps", 6, ())
hxd_fmt_hmd_AnimationFlag.Reserved = hxd_fmt_hmd_AnimationFlag("Reserved", 7, ())
hxd_fmt_hmd_AnimationFlag._hx_class = hxd_fmt_hmd_AnimationFlag
_hx_classes["hxd.fmt.hmd.AnimationFlag"] = hxd_fmt_hmd_AnimationFlag


class hxd_fmt_hmd_AnimationObject:
    _hx_class_name = "hxd.fmt.hmd.AnimationObject"
    _hx_is_interface = "False"
    __slots__ = ("name", "flags", "props")
    _hx_fields = ["name", "flags", "props"]
    _hx_methods = ["getStride"]

    def __init__(self):
        self.props = None
        self.flags = None
        self.name = None

    def getStride(self):
        stride = 0
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))) != 0):
            stride = (stride + 3)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))) != 0):
            stride = (stride + 3)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))) != 0):
            stride = (stride + 3)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasUV.index)))) != 0):
            stride = (stride + 2)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasAlpha.index)))) != 0):
            stride = (stride + 1)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
            stride = (stride + len(self.props))
        return stride

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.flags = None
        _hx_o.props = None
hxd_fmt_hmd_AnimationObject._hx_class = hxd_fmt_hmd_AnimationObject
_hx_classes["hxd.fmt.hmd.AnimationObject"] = hxd_fmt_hmd_AnimationObject


class hxd_fmt_hmd_AnimationEvent:
    _hx_class_name = "hxd.fmt.hmd.AnimationEvent"
    _hx_is_interface = "False"
    __slots__ = ("frame", "data")
    _hx_fields = ["frame", "data"]

    def __init__(self):
        self.data = None
        self.frame = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.frame = None
        _hx_o.data = None
hxd_fmt_hmd_AnimationEvent._hx_class = hxd_fmt_hmd_AnimationEvent
_hx_classes["hxd.fmt.hmd.AnimationEvent"] = hxd_fmt_hmd_AnimationEvent


class hxd_fmt_hmd_Animation:
    _hx_class_name = "hxd.fmt.hmd.Animation"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "frames", "sampling", "speed", "loop", "objects", "events", "dataPosition")
    _hx_fields = ["name", "props", "frames", "sampling", "speed", "loop", "objects", "events", "dataPosition"]

    def __init__(self):
        self.dataPosition = None
        self.events = None
        self.objects = None
        self.loop = None
        self.speed = None
        self.sampling = None
        self.frames = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.frames = None
        _hx_o.sampling = None
        _hx_o.speed = None
        _hx_o.loop = None
        _hx_o.objects = None
        _hx_o.events = None
        _hx_o.dataPosition = None
hxd_fmt_hmd_Animation._hx_class = hxd_fmt_hmd_Animation
_hx_classes["hxd.fmt.hmd.Animation"] = hxd_fmt_hmd_Animation


class hxd_fmt_hmd_Data:
    _hx_class_name = "hxd.fmt.hmd.Data"
    _hx_is_interface = "False"
    __slots__ = ("version", "props", "geometries", "materials", "models", "animations", "dataPosition", "data")
    _hx_fields = ["version", "props", "geometries", "materials", "models", "animations", "dataPosition", "data"]
    _hx_statics = ["CURRENT_VERSION"]

    def __init__(self):
        self.data = None
        self.dataPosition = None
        self.animations = None
        self.models = None
        self.materials = None
        self.geometries = None
        self.props = None
        self.version = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.version = None
        _hx_o.props = None
        _hx_o.geometries = None
        _hx_o.materials = None
        _hx_o.models = None
        _hx_o.animations = None
        _hx_o.dataPosition = None
        _hx_o.data = None
hxd_fmt_hmd_Data._hx_class = hxd_fmt_hmd_Data
_hx_classes["hxd.fmt.hmd.Data"] = hxd_fmt_hmd_Data


class hxd_fmt_hmd__Library_FormatMap:
    _hx_class_name = "hxd.fmt.hmd._Library.FormatMap"
    _hx_is_interface = "False"
    __slots__ = ("size", "offset", "_hx_def", "next")
    _hx_fields = ["size", "offset", "def", "next"]

    def __init__(self,size,offset,_hx_def,next):
        self.size = size
        self.offset = offset
        self._hx_def = _hx_def
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.size = None
        _hx_o.offset = None
        _hx_o._hx_def = None
        _hx_o.next = None
hxd_fmt_hmd__Library_FormatMap._hx_class = hxd_fmt_hmd__Library_FormatMap
_hx_classes["hxd.fmt.hmd._Library.FormatMap"] = hxd_fmt_hmd__Library_FormatMap


class hxd_fmt_hmd_GeometryBuffer:
    _hx_class_name = "hxd.fmt.hmd.GeometryBuffer"
    _hx_is_interface = "False"
    __slots__ = ("vertexes", "indexes")
    _hx_fields = ["vertexes", "indexes"]

    def __init__(self):
        self.indexes = None
        self.vertexes = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vertexes = None
        _hx_o.indexes = None
hxd_fmt_hmd_GeometryBuffer._hx_class = hxd_fmt_hmd_GeometryBuffer
_hx_classes["hxd.fmt.hmd.GeometryBuffer"] = hxd_fmt_hmd_GeometryBuffer


class hxd_fmt_hmd_Library:
    _hx_class_name = "hxd.fmt.hmd.Library"
    _hx_is_interface = "False"
    __slots__ = ("resource", "header", "cachedPrimitives", "cachedAnimations", "cachedSkin")
    _hx_fields = ["resource", "header", "cachedPrimitives", "cachedAnimations", "cachedSkin"]
    _hx_methods = ["getData", "getDefaultFormat", "load", "getBuffers", "makePrimitive", "makeMaterial", "makeSkin", "getModelProperty", "makeObject", "loadAnimation", "makeAnimation", "makeLinearAnimation", "loadSkin"]

    def __init__(self,res,header):
        self.resource = res
        self.header = header
        self.cachedPrimitives = []
        self.cachedAnimations = haxe_ds_StringMap()
        self.cachedSkin = haxe_ds_StringMap()

    def getData(self):
        entry = self.resource.entry
        b = haxe_io_Bytes.alloc((entry.get_size() - self.header.dataPosition))
        entry.open()
        entry.skip(self.header.dataPosition)
        entry.read(b,0,b.length)
        entry.close()
        return b

    def getDefaultFormat(self,stride):
        format = [hxd_fmt_hmd_GeometryFormat("position",3)]
        defs = [None]
        if (stride > 3):
            x = hxd_fmt_hmd_GeometryFormat("normal",3)
            format.append(x)
            defs.append(None)
        if (stride > 6):
            x = hxd_fmt_hmd_GeometryFormat("uv",2)
            format.append(x)
            defs.append(None)
        if (stride > 8):
            x = hxd_fmt_hmd_GeometryFormat("color",3)
            format.append(x)
            x = h3d_Vector(1,1,1)
            defs.append(x)
        if (stride > 11):
            raise haxe_Exception.thrown("Unsupported stride")
        return _hx_AnonObject({'format': format, 'defs': defs})

    def load(self,format,defaults = None,modelIndex = None):
        if (modelIndex is None):
            modelIndex = -1
        vtmp_x = 0.
        vtmp_y = 0.
        vtmp_z = 0.
        vtmp_w = 1.
        models = (self.header.models if ((modelIndex < 0)) else [python_internal_ArrayImpl._get(self.header.models, modelIndex)])
        this1 = list()
        outVertex = this1
        this1 = list()
        outIndex = this1
        stride = 0
        mid = -1
        _g = 0
        while (_g < len(format)):
            f = (format[_g] if _g >= 0 and _g < len(format) else None)
            _g = (_g + 1)
            stride = (stride + ((f.format & 7)))
        _g = 0
        while (_g < len(models)):
            m = (models[_g] if _g >= 0 and _g < len(models) else None)
            _g = (_g + 1)
            geom = python_internal_ArrayImpl._get(self.header.geometries, m.geometry)
            if (geom is None):
                continue
            _g1 = 0
            _g2 = m.materials
            while (_g1 < len(_g2)):
                mat = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                if (mid < 0):
                    mid = mat
                if (mid != mat):
                    raise haxe_Exception.thrown("Models have several materials")
            pos = m.position.toMatrix()
            data = self.getBuffers(geom,format,defaults)
            x = (len(outVertex) / stride)
            start = None
            try:
                start = int(x)
            except BaseException as _g3:
                None
                start = None
            _g4 = 0
            x1 = (len(data.vertexes) / stride)
            _g5 = None
            try:
                _g5 = int(x1)
            except BaseException as _g6:
                None
                _g5 = None
            while (_g4 < _g5):
                i = _g4
                _g4 = (_g4 + 1)
                p = (i * stride)
                index = p
                p = (p + 1)
                vtmp_x = data.vertexes[index]
                index1 = p
                p = (p + 1)
                vtmp_y = data.vertexes[index1]
                index2 = p
                p = (p + 1)
                vtmp_z = data.vertexes[index2]
                px = ((((vtmp_x * pos._11) + ((vtmp_y * pos._21))) + ((vtmp_z * pos._31))) + ((vtmp_w * pos._41)))
                py = ((((vtmp_x * pos._12) + ((vtmp_y * pos._22))) + ((vtmp_z * pos._32))) + ((vtmp_w * pos._42)))
                pz = ((((vtmp_x * pos._13) + ((vtmp_y * pos._23))) + ((vtmp_z * pos._33))) + ((vtmp_w * pos._43)))
                vtmp_x = px
                vtmp_y = py
                vtmp_z = pz
                outVertex.append(vtmp_x)
                outVertex.append(vtmp_y)
                outVertex.append(vtmp_z)
                _g7 = 0
                _g8 = (stride - 3)
                while (_g7 < _g8):
                    j = _g7
                    _g7 = (_g7 + 1)
                    index3 = p
                    p = (p + 1)
                    v = data.vertexes[index3]
                    outVertex.append(v)
            _g9 = 0
            _g10 = data.indexes
            while (_g9 < len(_g10)):
                idx = _g10[_g9]
                _g9 = (_g9 + 1)
                outIndex.append((idx + start))
        return _hx_AnonObject({'vertex': outVertex, 'index': outIndex})

    def getBuffers(self,geom,format,defaults = None,material = None):
        if ((material == 0) and ((len(geom.indexCounts) == 1))):
            material = None
        _hx_map = None
        stride = 0
        _g = 0
        _g1 = len(format)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            i1 = ((len(format) - 1) - i)
            f = (format[i1] if i1 >= 0 and i1 < len(format) else None)
            size = (f.format & 7)
            offset = 0
            found = False
            _g2 = 0
            _g3 = geom.vertexFormat
            while (_g2 < len(_g3)):
                f2 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                if (f2.name == f.name):
                    if (((f2.format & 7)) < size):
                        raise haxe_Exception.thrown(((((("Requested " + HxOverrides.stringOrNull(f.name)) + " data has only ") + Std.string(((f2.format & 7)))) + " regs instead of ") + Std.string(size)))
                    found = True
                    break
                offset = (offset + ((f2.format & 7)))
            if found:
                _hx_map = hxd_fmt_hmd__Library_FormatMap(size,offset,None,_hx_map)
            else:
                _hx_def = (None if ((defaults is None)) else (defaults[i1] if i1 >= 0 and i1 < len(defaults) else None))
                if (_hx_def is None):
                    raise haxe_Exception.thrown(("Missing required " + HxOverrides.stringOrNull(f.name)))
                _hx_map = hxd_fmt_hmd__Library_FormatMap(size,0,_hx_def,_hx_map)
            stride = (stride + size)
        vsize = ((geom.vertexCount * geom.vertexStride) * 4)
        vbuf = haxe_io_Bytes.alloc(vsize)
        entry = self.resource.entry
        entry.open()
        entry.skip((self.header.dataPosition + geom.vertexPosition))
        entry.read(vbuf,0,vsize)
        entry.skip((geom.indexPosition - ((geom.vertexPosition + vsize))))
        isSmall = (geom.vertexCount <= 65536)
        imult = (2 if isSmall else 4)
        isize = None
        if (material is None):
            isize = (geom.get_indexCount() * imult)
        else:
            ipos = 0
            _g = 0
            _g1 = material
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                ipos = (ipos + (geom.indexCounts[i] if i >= 0 and i < len(geom.indexCounts) else None))
            entry.skip((ipos * imult))
            isize = ((geom.indexCounts[material] if material >= 0 and material < len(geom.indexCounts) else None) * imult)
        ibuf = haxe_io_Bytes.alloc(isize)
        entry.read(ibuf,0,isize)
        buf = hxd_fmt_hmd_GeometryBuffer()
        if (material is None):
            this1 = [None]*(stride * geom.vertexCount)
            buf.vertexes = this1
            this1 = [None]*geom.get_indexCount()
            buf.indexes = this1
            w = 0
            _g = 0
            _g1 = geom.vertexCount
            while (_g < _g1):
                vid = _g
                _g = (_g + 1)
                m = _hx_map
                while (m is not None):
                    if (m._hx_def is None):
                        r = (vid * geom.vertexStride)
                        _g2 = 0
                        _g3 = m.size
                        while (_g2 < _g3):
                            i = _g2
                            _g2 = (_g2 + 1)
                            this1 = buf.vertexes
                            index = w
                            w = (w + 1)
                            val = vbuf.getFloat((((r + m.offset) + i) << 2))
                            this1[index] = val
                    else:
                        _g4 = m.size
                        if (_g4 == 1):
                            index1 = w
                            w = (w + 1)
                            val1 = m._hx_def.x
                            buf.vertexes[index1] = val1
                        elif (_g4 == 2):
                            index2 = w
                            w = (w + 1)
                            val2 = m._hx_def.x
                            buf.vertexes[index2] = val2
                            index3 = w
                            w = (w + 1)
                            val3 = m._hx_def.y
                            buf.vertexes[index3] = val3
                        elif (_g4 == 3):
                            index4 = w
                            w = (w + 1)
                            val4 = m._hx_def.x
                            buf.vertexes[index4] = val4
                            index5 = w
                            w = (w + 1)
                            val5 = m._hx_def.y
                            buf.vertexes[index5] = val5
                            index6 = w
                            w = (w + 1)
                            val6 = m._hx_def.z
                            buf.vertexes[index6] = val6
                        else:
                            index7 = w
                            w = (w + 1)
                            val7 = m._hx_def.x
                            buf.vertexes[index7] = val7
                            index8 = w
                            w = (w + 1)
                            val8 = m._hx_def.y
                            buf.vertexes[index8] = val8
                            index9 = w
                            w = (w + 1)
                            val9 = m._hx_def.z
                            buf.vertexes[index9] = val9
                            index10 = w
                            w = (w + 1)
                            val10 = m._hx_def.w
                            buf.vertexes[index10] = val10
                    m = m.next
            if isSmall:
                r = 0
                _g = 0
                _g1 = len(buf.indexes)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    this1 = buf.indexes
                    pos = r
                    r = (r + 1)
                    pos1 = r
                    r = (r + 1)
                    val = (ibuf.b[pos] | ((ibuf.b[pos1] << 8)))
                    this1[i] = val
            else:
                _g = 0
                _g1 = len(buf.indexes)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    this1 = buf.indexes
                    pos = (i << 2)
                    v = (((ibuf.b[pos] | ((ibuf.b[(pos + 1)] << 8))) | ((ibuf.b[(pos + 2)] << 16))) | ((ibuf.b[(pos + 3)] << 24)))
                    val = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                    this1[i] = val
        else:
            icount = (geom.indexCounts[material] if material >= 0 and material < len(geom.indexCounts) else None)
            this1 = [None]*geom.vertexCount
            vmap = this1
            this1 = list()
            vertexes = this1
            this1 = [None]*icount
            buf.indexes = this1
            r = 0
            vcount = 0
            _g = 0
            _g1 = len(buf.indexes)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                vid = None
                if isSmall:
                    pos = r
                    r = (r + 1)
                    pos1 = r
                    r = (r + 1)
                    vid = (ibuf.b[pos] | ((ibuf.b[pos1] << 8)))
                else:
                    pos2 = (i << 2)
                    v = (((ibuf.b[pos2] | ((ibuf.b[(pos2 + 1)] << 8))) | ((ibuf.b[(pos2 + 2)] << 16))) | ((ibuf.b[(pos2 + 3)] << 24)))
                    vid = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                rid = vmap[vid]
                if (rid == 0):
                    vcount = (vcount + 1)
                    rid = vcount
                    vmap[vid] = rid
                    m = _hx_map
                    while (m is not None):
                        if (m._hx_def is None):
                            r1 = (vid * geom.vertexStride)
                            _g2 = 0
                            _g3 = m.size
                            while (_g2 < _g3):
                                i1 = _g2
                                _g2 = (_g2 + 1)
                                v1 = vbuf.getFloat((((r1 + m.offset) + i1) << 2))
                                vertexes.append(v1)
                        else:
                            _g4 = m.size
                            if (_g4 == 1):
                                v2 = m._hx_def.x
                                vertexes.append(v2)
                            elif (_g4 == 2):
                                v3 = m._hx_def.x
                                vertexes.append(v3)
                                v4 = m._hx_def.y
                                vertexes.append(v4)
                            elif (_g4 == 3):
                                v5 = m._hx_def.x
                                vertexes.append(v5)
                                v6 = m._hx_def.y
                                vertexes.append(v6)
                                v7 = m._hx_def.z
                                vertexes.append(v7)
                            else:
                                v8 = m._hx_def.x
                                vertexes.append(v8)
                                v9 = m._hx_def.y
                                vertexes.append(v9)
                                v10 = m._hx_def.z
                                vertexes.append(v10)
                                v11 = m._hx_def.w
                                vertexes.append(v11)
                        m = m.next
                val = (rid - 1)
                buf.indexes[i] = val
            buf.vertexes = vertexes
        entry.close()
        return buf

    def makePrimitive(self,id):
        p = (self.cachedPrimitives[id] if id >= 0 and id < len(self.cachedPrimitives) else None)
        if (p is not None):
            return p
        p = h3d_prim_HMDModel(python_internal_ArrayImpl._get(self.header.geometries, id),self.header.dataPosition,self)
        p.incref()
        python_internal_ArrayImpl._set(self.cachedPrimitives, id, p)
        return p

    def makeMaterial(self,model,mid,loadTexture):
        m = python_internal_ArrayImpl._get(self.header.materials, mid)
        mat = h3d_mat_MaterialSetup.current.createMaterial()
        mat.name = m.name
        if (m.diffuseTexture is not None):
            mat.set_texture(loadTexture(m.diffuseTexture))
            if (mat.get_texture() is None):
                mat.set_texture(h3d_mat_Texture.fromColor(16711935))
        if (m.specularTexture is not None):
            mat.set_specularTexture(loadTexture(m.specularTexture))
        if (m.normalMap is not None):
            mat.set_normalMap(loadTexture(m.normalMap))
        mat.set_blendMode(m.blendMode)
        mat.model = self.resource
        props = h3d_mat_MaterialSetup.current.loadMaterialProps(mat)
        if (props is None):
            props = mat.getDefaultModelProps()
        mat.set_props(props)
        return mat

    def makeSkin(self,skin):
        s = self.cachedSkin.h.get(skin.name,None)
        if (s is not None):
            return s
        s = h3d_anim_Skin(skin.name,0,3)
        s.namedJoints = haxe_ds_StringMap()
        s.allJoints = []
        s.boundJoints = []
        s.rootJoints = []
        _g = 0
        _g1 = skin.joints
        while (_g < len(_g1)):
            joint = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            j = h3d_anim_Joint()
            j.name = joint.name
            j.index = len(s.allJoints)
            j.defMat = joint.position.toMatrix()
            if (joint.bind >= 0):
                j.bindIndex = joint.bind
                j.transPos = joint.transpos.toMatrix(True)
                python_internal_ArrayImpl._set(s.boundJoints, j.bindIndex, j)
            if (joint.parent >= 0):
                p = python_internal_ArrayImpl._get(s.allJoints, joint.parent)
                _this = p.subs
                _this.append(j)
                j.parent = p
            else:
                _this1 = s.rootJoints
                _this1.append(j)
            _this2 = s.allJoints
            _this2.append(j)
            s.namedJoints.h[j.name] = j
        if (skin.split is not None):
            s.splitJoints = []
            _g = 0
            _g1 = skin.split
            while (_g < len(_g1)):
                ss = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _this = s.splitJoints
                ss1 = ss.materialIndex
                _g2 = []
                _g3 = 0
                _g4 = ss.joints
                while (_g3 < len(_g4)):
                    j = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                    _g3 = (_g3 + 1)
                    x = (s.allJoints[j] if j >= 0 and j < len(s.allJoints) else None)
                    _g2.append(x)
                _this.append(_hx_AnonObject({'material': ss1, 'joints': _g2}))
        self.cachedSkin.h[skin.name] = s
        return s

    def getModelProperty(self,objName,p,_hx_def = None):
        _g = 0
        _g1 = self.header.models
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (m.name == objName):
                if (m.props is not None):
                    _g2 = 0
                    _g3 = m.props
                    while (_g2 < len(_g3)):
                        pr = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                        _g2 = (_g2 + 1)
                        if (pr.index == p.index):
                            return python_internal_ArrayImpl._get(list(pr.params), 0)
                return _hx_def
        if (_hx_def is None):
            raise haxe_Exception.thrown((("Model " + ("null" if objName is None else objName)) + " not found"))
        return _hx_def

    def makeObject(self,loadTexture = None):
        if (loadTexture is None):
            def _hx_local_0(_):
                return h3d_mat_Texture.fromColor(16711935)
            loadTexture = _hx_local_0
        if (len(self.header.models) == 0):
            raise haxe_Exception.thrown("This file does not contain any model")
        objs = []
        _g = 0
        _g1 = self.header.models
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            obj = None
            if (m.geometry < 0):
                obj = h3d_scene_Object()
            else:
                prim = self.makePrimitive(m.geometry)
                if (m.skin is not None):
                    skinData = self.makeSkin(m.skin)
                    skinData.primitive = prim
                    _g2 = []
                    _g3 = 0
                    _g4 = m.materials
                    while (_g3 < len(_g4)):
                        mat = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                        _g3 = (_g3 + 1)
                        x = self.makeMaterial(m,mat,loadTexture)
                        _g2.append(x)
                    obj = h3d_scene_Skin(skinData,_g2)
                elif (len(m.materials) == 1):
                    obj = h3d_scene_Mesh(prim,self.makeMaterial(m,(m.materials[0] if 0 < len(m.materials) else None),loadTexture))
                else:
                    _g5 = []
                    _g6 = 0
                    _g7 = m.materials
                    while (_g6 < len(_g7)):
                        mat1 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                        _g6 = (_g6 + 1)
                        x1 = self.makeMaterial(m,mat1,loadTexture)
                        _g5.append(x1)
                    obj = h3d_scene_MultiMaterial(prim,_g5)
            obj.name = m.name
            v = m.position.toMatrix()
            obj.defaultTransform = v
            f = 1
            b = True
            if b:
                obj.flags = (obj.flags | f)
            else:
                obj.flags = (obj.flags & ~f)
            objs.append(obj)
            p = python_internal_ArrayImpl._get(objs, m.parent)
            if (p is not None):
                p.addChild(obj)
        return (objs[0] if 0 < len(objs) else None)

    def loadAnimation(self,name = None):
        a = self.cachedAnimations.h.get(("" if ((name is None)) else name),None)
        if (a is not None):
            return a
        a = None
        if (name is None):
            if (len(self.header.animations) == 0):
                return None
            a = python_internal_ArrayImpl._get(self.header.animations, 0)
        else:
            _g = 0
            _g1 = self.header.animations
            while (_g < len(_g1)):
                a2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (a2.name == name):
                    a = a2
                    break
            if (a is None):
                raise haxe_Exception.thrown((("Animation " + ("null" if name is None else name)) + " not found !"))
        l = (self.makeLinearAnimation(a) if ((self.header.version <= 2)) else self.makeAnimation(a))
        l.speed = a.speed
        l.loop = a.loop
        if (a.events is not None):
            l.setEvents(a.events)
        l.resourcePath = self.resource.entry.get_path()
        self.cachedAnimations.h[a.name] = l
        if (name is None):
            self.cachedAnimations.h[""] = l
        return l

    def makeAnimation(self,a):
        b = h3d_anim_BufferAnimation(a.name,a.frames,a.sampling)
        stride = 0
        singleFrames = []
        otherFrames = []
        _g = 0
        _g1 = a.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c = b.addObject(o.name,0)
            sm = 1
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.SingleFrame.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.SingleFrame.index)))
                singleFrames.append(c)
                sm = 0
            else:
                otherFrames.append(c)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.Position.index)))
                stride = (stride + ((3 * sm)))
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.Rotation.index)))
                stride = (stride + ((3 * sm)))
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.Scale.index)))
                stride = (stride + ((3 * sm)))
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasUV.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.UV.index)))
                stride = (stride + ((2 * sm)))
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasAlpha.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.Alpha.index)))
                stride = (stride + sm)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                _g2 = 0
                _g3 = len(o.props)
                while (_g2 < _g3):
                    i = _g2
                    _g2 = (_g2 + 1)
                    c1 = c
                    if (i > 0):
                        c1 = b.addObject(o.name,0)
                        if (sm == 0):
                            singleFrames.append(c1)
                        else:
                            otherFrames.append(c1)
                    c1.layout = (c1.layout | ((1 << h3d_anim_DataLayout.Property.index)))
                    c1.propName = (o.props[i] if i >= 0 and i < len(o.props) else None)
                    stride = (stride + sm)
        pos = 0
        _g = 0
        while (_g < len(singleFrames)):
            b1 = (singleFrames[_g] if _g >= 0 and _g < len(singleFrames) else None)
            _g = (_g + 1)
            b1.dataOffset = pos
            pos = (pos + b1.getStride())
        singleStride = pos
        _g = 0
        while (_g < len(otherFrames)):
            b1 = (otherFrames[_g] if _g >= 0 and _g < len(otherFrames) else None)
            _g = (_g + 1)
            b1.dataOffset = pos
            pos = (pos + b1.getStride())
        entry = self.resource.entry
        entry.open()
        entry.skip((self.header.dataPosition + a.dataPosition))
        count = ((stride * a.frames) + singleStride)
        data = haxe_io_Bytes.alloc((count * 4))
        entry.read(data,0,data.length)
        entry.close()
        this1 = [None]*count
        v = this1
        _g = 0
        _g1 = count
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            val = data.getFloat((i << 2))
            v[i] = val
        b.setData(v,stride)
        return b

    def makeLinearAnimation(self,a):
        l = h3d_anim_LinearAnimation(a.name,a.frames,a.sampling)
        entry = self.resource.entry
        entry.open()
        entry.skip((self.header.dataPosition + a.dataPosition))
        _g = 0
        _g1 = a.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            pos = (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))) != 0)
            rot = (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))) != 0)
            scale = (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))) != 0)
            if ((pos or rot) or scale):
                frameCount = a.frames
                if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.SingleFrame.index)))) != 0):
                    frameCount = 1
                this1 = [None]*frameCount
                fl = this1
                size = (((((((3 if pos else 0)) + ((3 if rot else 0))) + ((3 if scale else 0)))) * 4) * frameCount)
                data = haxe_io_Bytes.alloc(size)
                entry.read(data,0,size)
                p = 0
                _g2 = 0
                _g3 = frameCount
                while (_g2 < _g3):
                    i = _g2
                    _g2 = (_g2 + 1)
                    f = h3d_anim_LinearFrame()
                    if pos:
                        f.tx = data.getFloat(p)
                        p = (p + 4)
                        f.ty = data.getFloat(p)
                        p = (p + 4)
                        f.tz = data.getFloat(p)
                        p = (p + 4)
                    else:
                        f.tx = 0
                        f.ty = 0
                        f.tz = 0
                    if rot:
                        f.qx = data.getFloat(p)
                        p = (p + 4)
                        f.qy = data.getFloat(p)
                        p = (p + 4)
                        f.qz = data.getFloat(p)
                        p = (p + 4)
                        qw = (1 - ((((f.qx * f.qx) + ((f.qy * f.qy))) + ((f.qz * f.qz)))))
                        tmp = None
                        if (qw < 0):
                            f1 = -qw
                            tmp = -((Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1)))
                        else:
                            tmp = (Math.NaN if ((qw < 0)) else python_lib_Math.sqrt(qw))
                        f.qw = tmp
                    else:
                        f.qx = 0
                        f.qy = 0
                        f.qz = 0
                        f.qw = 1
                    if scale:
                        f.sx = data.getFloat(p)
                        p = (p + 4)
                        f.sy = data.getFloat(p)
                        p = (p + 4)
                        f.sz = data.getFloat(p)
                        p = (p + 4)
                    else:
                        f.sx = 1
                        f.sy = 1
                        f.sz = 1
                    fl[i] = f
                l.addCurve(o.name,fl,True,rot,scale)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasUV.index)))) != 0):
                this2 = [None]*(a.frames * 2)
                fl1 = this2
                size1 = (8 * a.frames)
                data1 = haxe_io_Bytes.alloc(size1)
                entry.read(data1,0,size1)
                _g4 = 0
                _g5 = len(fl1)
                while (_g4 < _g5):
                    i1 = _g4
                    _g4 = (_g4 + 1)
                    val = data1.getFloat((i1 * 4))
                    fl1[i1] = val
                l.addUVCurve(o.name,fl1)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasAlpha.index)))) != 0):
                this3 = [None]*a.frames
                fl2 = this3
                size2 = (4 * a.frames)
                data2 = haxe_io_Bytes.alloc(size2)
                entry.read(data2,0,size2)
                _g6 = 0
                _g7 = len(fl2)
                while (_g6 < _g7):
                    i2 = _g6
                    _g6 = (_g6 + 1)
                    val1 = data2.getFloat((i2 * 4))
                    fl2[i2] = val1
                l.addAlphaCurve(o.name,fl2)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                _g8 = 0
                _g9 = o.props
                while (_g8 < len(_g9)):
                    p1 = (_g9[_g8] if _g8 >= 0 and _g8 < len(_g9) else None)
                    _g8 = (_g8 + 1)
                    this4 = [None]*a.frames
                    fl3 = this4
                    size3 = (4 * a.frames)
                    data3 = haxe_io_Bytes.alloc(size3)
                    entry.read(data3,0,size3)
                    _g10 = 0
                    _g11 = len(fl3)
                    while (_g10 < _g11):
                        i3 = _g10
                        _g10 = (_g10 + 1)
                        val2 = data3.getFloat((i3 * 4))
                        fl3[i3] = val2
                    l.addPropCurve(o.name,p1,fl3)
        entry.close()
        return l

    def loadSkin(self,geom,skin,optimize = None):
        if (optimize is None):
            optimize = True
        if (skin.vertexWeights is not None):
            return
        if (skin.bonesPerVertex != 3):
            raise haxe_Exception.thrown("assert")
        skin.vertexCount = geom.vertexCount
        data = self.getBuffers(geom,[hxd_fmt_hmd_GeometryFormat("position",3), hxd_fmt_hmd_GeometryFormat("weights",3), hxd_fmt_hmd_GeometryFormat("indexes",9)])
        this1 = [None]*(skin.vertexCount * skin.bonesPerVertex)
        skin.vertexWeights = this1
        this1 = [None]*(skin.vertexCount * skin.bonesPerVertex)
        skin.vertexJoints = this1
        _g = 0
        _g1 = skin.boundJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            j.offsets = h3d_col_Bounds()
        vbuf = data.vertexes
        idx = 0
        bounds_xMin = 1e20
        bounds_xMax = -1e20
        bounds_yMin = 1e20
        bounds_yMax = -1e20
        bounds_zMin = 1e20
        bounds_zMax = -1e20
        out = Math.NaN
        ranges = None
        if (skin.splitJoints is None):
            jointsByBind = []
            _g = 0
            _g1 = skin.boundJoints
            while (_g < len(_g1)):
                j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                python_internal_ArrayImpl._set(jointsByBind, j.bindIndex, j)
            ranges = [_hx_AnonObject({'index': 0, 'pos': 0, 'count': len(data.indexes), 'joints': jointsByBind})]
        else:
            idx = 0
            triPos = []
            pos = 0
            _g = 0
            _g1 = geom.indexCounts
            while (_g < len(_g1)):
                n = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                triPos.append(pos)
                pos = (pos + n)
            _g = []
            _g1 = 0
            _g2 = skin.splitJoints
            while (_g1 < len(_g2)):
                j = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                idx1 = idx
                triPos1 = (triPos[idx] if idx >= 0 and idx < len(triPos) else None)
                geom1 = idx
                idx = (idx + 1)
                x = _hx_AnonObject({'index': idx1, 'pos': triPos1, 'count': (geom.indexCounts[geom1] if geom1 >= 0 and geom1 < len(geom.indexCounts) else None), 'joints': j.joints})
                _g.append(x)
            ranges = _g
        _g = 0
        while (_g < len(ranges)):
            r = (ranges[_g] if _g >= 0 and _g < len(ranges) else None)
            _g = (_g + 1)
            _g1 = r.pos
            _g2 = (r.pos + r.count)
            while (_g1 < _g2):
                idx = _g1
                _g1 = (_g1 + 1)
                vidx = data.indexes[idx]
                p = (vidx * 7)
                x = vbuf[p]
                if (x != x):
                    continue
                index = p
                p = (p + 1)
                vbuf[index] = out
                index1 = p
                p = (p + 1)
                y = vbuf[index1]
                index2 = p
                p = (p + 1)
                z = vbuf[index2]
                index3 = p
                p = (p + 1)
                w1 = vbuf[index3]
                index4 = p
                p = (p + 1)
                w2 = vbuf[index4]
                index5 = p
                p = (p + 1)
                w3 = vbuf[index5]
                vout = (vidx * 3)
                skin.vertexWeights[vout] = w1
                skin.vertexWeights[(vout + 1)] = w2
                skin.vertexWeights[(vout + 2)] = w3
                w = ((((1 if ((w1 == 0)) else 0)) | ((2 if ((w2 == 0)) else 0))) | ((4 if ((w3 == 0)) else 0)))
                index6 = p
                p = (p + 1)
                idx1 = haxe_io_FPHelper.floatToI32(vbuf[index6])
                if (x < bounds_xMin):
                    bounds_xMin = x
                if (x > bounds_xMax):
                    bounds_xMax = x
                if (y < bounds_yMin):
                    bounds_yMin = y
                if (y > bounds_yMax):
                    bounds_yMax = y
                if (z < bounds_zMin):
                    bounds_zMin = z
                if (z > bounds_zMax):
                    bounds_zMax = z
                _g3 = 0
                while (_g3 < 3):
                    i = _g3
                    _g3 = (_g3 + 1)
                    if (((w & ((1 << i)))) != 0):
                        index7 = vout
                        vout = (vout + 1)
                        skin.vertexJoints[index7] = -1
                        continue
                    idx2 = ((idx1 >> ((i << 3))) & 255)
                    j = (r.joints[idx2] if idx2 >= 0 and idx2 < len(r.joints) else None)
                    _this = j.offsets
                    if (x < _this.xMin):
                        _this.xMin = x
                    if (x > _this.xMax):
                        _this.xMax = x
                    if (y < _this.yMin):
                        _this.yMin = y
                    if (y > _this.yMax):
                        _this.yMax = y
                    if (z < _this.zMin):
                        _this.zMin = z
                    if (z > _this.zMax):
                        _this.zMax = z
                    index8 = vout
                    vout = (vout + 1)
                    val = j.bindIndex
                    skin.vertexJoints[index8] = val
        if optimize:
            idx = (len(skin.allJoints) - 1)
            optOut = 0
            refVolume = ((((bounds_xMax - bounds_xMin)) * ((bounds_yMax - bounds_yMin))) * ((bounds_zMax - bounds_zMin)))
            while (idx >= 0):
                j = idx
                idx = (idx - 1)
                j1 = (skin.allJoints[j] if j >= 0 and j < len(skin.allJoints) else None)
                if (((j1.offsets is None) or ((j1.parent is None))) or ((j1.parent.offsets is None))):
                    continue
                poff = j1.parent.offsets
                _this = j1.offsets
                dx = (_this.xMax - _this.xMin)
                dy = (_this.yMax - _this.yMin)
                dz = (_this.zMax - _this.zMin)
                x = (((_this.xMin + _this.xMax)) * 0.5)
                y = (((_this.yMin + _this.yMax)) * 0.5)
                z = (((_this.zMin + _this.zMax)) * 0.5)
                f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
                r = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 0.5)
                if (r is None):
                    r = 0.
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                sx = x
                sy = y
                sz = z
                sr = r
                if (sr is None):
                    sr = 0.
                if (sz is None):
                    sz = 0.
                if (sy is None):
                    sy = 0.
                if (sx is None):
                    sx = 0.
                sp_x = sx
                sp_y = sy
                sp_z = sz
                sp_r = sr
                if ((((((poff.xMin <= ((sp_x - sp_r))) and ((poff.yMin <= ((sp_y - sp_r))))) and ((poff.zMin <= ((sp_z - sp_r))))) and ((poff.xMax >= ((sp_x + sp_r))))) and ((poff.yMax >= ((sp_y + sp_r))))) and ((poff.zMax >= ((sp_z + sp_r))))):
                    j1.offsets = None
                    optOut = (optOut + 1)
                    continue
                b = h3d_col_Bounds()
                b.xMin = poff.xMin
                b.xMax = poff.xMax
                b.yMin = poff.yMin
                b.yMax = poff.yMax
                b.zMin = poff.zMin
                b.zMax = poff.zMax
                pext = b
                x1 = sp_x
                y1 = sp_y
                z1 = sp_z
                r1 = sp_r
                if ((x1 - r1) < pext.xMin):
                    pext.xMin = (x1 - r1)
                if ((x1 + r1) > pext.xMax):
                    pext.xMax = (x1 + r1)
                if ((y1 - r1) < pext.yMin):
                    pext.yMin = (y1 - r1)
                if ((y1 + r1) > pext.yMax):
                    pext.yMax = (y1 + r1)
                if ((z1 - r1) < pext.zMin):
                    pext.zMin = (z1 - r1)
                if ((z1 + r1) > pext.zMax):
                    pext.zMax = (z1 + r1)
                f1 = ((refVolume * 1.5) / (((((pext.xMax - pext.xMin)) * ((pext.yMax - pext.yMin))) * ((pext.zMax - pext.zMin)))))
                ratio = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
                k = (((((pext.xMax - pext.xMin)) * ((pext.yMax - pext.yMin))) * ((pext.zMax - pext.zMin))) / (((((poff.xMax - poff.xMin)) * ((poff.yMax - poff.yMin))) * ((poff.zMax - poff.zMin)))))
                if (k < ratio):
                    j1.parent.offsets = pext
                    j1.offsets = None
                    optOut = (optOut + 1)
                    continue
        _g = 0
        _g1 = skin.allJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (j.offsets is None):
                j.offsetRay = -1
                continue
            b = j.offsets
            pt1 = None
            pt2 = None
            x = (((b.xMin + b.xMax)) * 0.5)
            y = (((b.yMin + b.yMax)) * 0.5)
            z = (((b.zMin + b.zMax)) * 0.5)
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            off_x = x
            off_y = y
            off_z = z
            r = None
            if (((b.xMax - b.xMin) > ((b.yMax - b.yMin))) and (((b.xMax - b.xMin) > ((b.zMax - b.zMin))))):
                a = (b.yMax - b.yMin)
                b1 = (b.zMax - b.zMin)
                r = (((b1 if ((a < b1)) else a)) * 0.5)
                pt1 = h3d_col_Point((b.xMin + r),off_y,off_z)
                pt2 = h3d_col_Point((b.xMax - r),off_y,off_z)
            elif ((b.yMax - b.yMin) > ((b.zMax - b.zMin))):
                a1 = (b.xMax - b.xMin)
                b2 = (b.zMax - b.zMin)
                r = (((b2 if ((a1 < b2)) else a1)) * 0.5)
                pt1 = h3d_col_Point(off_x,(b.yMin + r),off_z)
                pt2 = h3d_col_Point(off_x,(b.yMax - r),off_z)
            else:
                a2 = (b.xMax - b.xMin)
                b3 = (b.yMax - b.yMin)
                r = (((b3 if ((a2 < b3)) else a2)) * 0.5)
                pt1 = h3d_col_Point(off_x,off_y,(b.zMin + r))
                pt2 = h3d_col_Point(off_x,off_y,(b.zMax - r))
            b.xMin = pt1.x
            b.yMin = pt1.y
            b.zMin = pt1.z
            b.xMax = pt2.x
            b.yMax = pt2.y
            b.zMax = pt2.z
            j.offsetRay = r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.resource = None
        _hx_o.header = None
        _hx_o.cachedPrimitives = None
        _hx_o.cachedAnimations = None
        _hx_o.cachedSkin = None
hxd_fmt_hmd_Library._hx_class = hxd_fmt_hmd_Library
_hx_classes["hxd.fmt.hmd.Library"] = hxd_fmt_hmd_Library


class hxd_fmt_hmd_Reader:
    _hx_class_name = "hxd.fmt.hmd.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i", "version")
    _hx_fields = ["i", "version"]
    _hx_methods = ["readProperty", "readProps", "readName", "readCachedName", "readPosition", "readBounds", "readSkin", "readHeader", "read"]
    _hx_statics = ["BLEND", "CULLING", "HMD_STRINGS"]

    def __init__(self,i):
        self.version = None
        self.i = i

    def readProperty(self):
        _g = self.i.readByte()
        _g1 = _g
        if (_g1 == 0):
            return hxd_fmt_hmd_Property.CameraFOVY(self.i.readFloat())
        elif (_g1 == 1):
            raise haxe_Exception.thrown("Obsolete HasMaterialFlags")
        elif (_g1 == 2):
            return hxd_fmt_hmd_Property.HasExtraTextures
        else:
            unk = _g
            raise haxe_Exception.thrown(("Unknown property #" + Std.string(unk)))

    def readProps(self):
        if (self.version == 1):
            return None
        n = self.i.readByte()
        if (n == 0):
            return None
        _g = []
        _g1 = 0
        _g2 = n
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = self.readProperty()
            _g.append(x)
        return _g

    def readName(self):
        b = self.i.readByte()
        if (b == 255):
            return None
        return self.i.readString(b)

    def readCachedName(self):
        name = self.readName()
        if (name is None):
            return None
        if (hxd_fmt_hmd_Reader.HMD_STRINGS is None):
            hxd_fmt_hmd_Reader.HMD_STRINGS = haxe_ds_StringMap()
        n = hxd_fmt_hmd_Reader.HMD_STRINGS.h.get(name,None)
        if (n is not None):
            return n
        hxd_fmt_hmd_Reader.HMD_STRINGS.h[name] = name
        return name

    def readPosition(self,hasScale = None):
        if (hasScale is None):
            hasScale = True
        p = hxd_fmt_hmd_Position()
        p.x = self.i.readFloat()
        p.y = self.i.readFloat()
        p.z = self.i.readFloat()
        p.qx = self.i.readFloat()
        p.qy = self.i.readFloat()
        p.qz = self.i.readFloat()
        if hasScale:
            p.sx = self.i.readFloat()
            p.sy = self.i.readFloat()
            p.sz = self.i.readFloat()
        else:
            p.sx = 1
            p.sy = 1
            p.sz = 1
        return p

    def readBounds(self):
        b = h3d_col_Bounds()
        b.xMin = self.i.readFloat()
        b.yMin = self.i.readFloat()
        b.zMin = self.i.readFloat()
        b.xMax = self.i.readFloat()
        b.yMax = self.i.readFloat()
        b.zMax = self.i.readFloat()
        return b

    def readSkin(self):
        name = self.readCachedName()
        if (name is None):
            return None
        s = hxd_fmt_hmd_Skin()
        s.props = self.readProps()
        s.name = name
        s.joints = []
        _g = 0
        _g1 = self.i.readUInt16()
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            j = hxd_fmt_hmd_SkinJoint()
            j.props = self.readProps()
            j.name = self.readCachedName()
            pid = self.i.readUInt16()
            hasScale = (((pid & 32768)) != 0)
            if hasScale:
                pid = (pid & 32767)
            j.parent = (pid - 1)
            j.position = self.readPosition(hasScale)
            j.bind = (self.i.readUInt16() - 1)
            if (j.bind >= 0):
                j.transpos = self.readPosition(hasScale)
            _this = s.joints
            _this.append(j)
        count = self.i.readByte()
        if (count > 0):
            s.split = []
            _g = 0
            _g1 = count
            while (_g < _g1):
                k = _g
                _g = (_g + 1)
                ss = hxd_fmt_hmd_SkinSplit()
                ss.materialIndex = self.i.readByte()
                _g2 = []
                _g3 = 0
                _g4 = self.i.readByte()
                while (_g3 < _g4):
                    k1 = _g3
                    _g3 = (_g3 + 1)
                    x = self.i.readUInt16()
                    _g2.append(x)
                ss.joints = _g2
                _this = s.split
                _this.append(ss)
        return s

    def readHeader(self):
        d = hxd_fmt_hmd_Data()
        h = self.i.readString(3)
        if (h != "HMD"):
            if (HxString.charCodeAt(h,0) == 59):
                raise haxe_Exception.thrown("FBX was not converted to HMD")
            raise haxe_Exception.thrown(("Invalid HMD header " + HxOverrides.stringOrNull(python_lib_urllib_Parse.quote(h,""))))
        self.version = self.i.readByte()
        if (self.version > 3):
            raise haxe_Exception.thrown(("Can't read HMD v" + Std.string(self.version)))
        d.version = self.version
        d.geometries = []
        d.dataPosition = self.i.readInt32()
        d.props = self.readProps()
        _g = 0
        _g1 = self.i.readInt32()
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            g = hxd_fmt_hmd_Geometry()
            g.props = self.readProps()
            g.vertexCount = self.i.readInt32()
            g.vertexStride = self.i.readByte()
            _g2 = []
            _g3 = 0
            _g4 = self.i.readByte()
            while (_g3 < _g4):
                k1 = _g3
                _g3 = (_g3 + 1)
                x = self.readCachedName()
                this1 = self.i.readByte()
                x1 = hxd_fmt_hmd_GeometryFormat(x,this1)
                _g2.append(x1)
            g.vertexFormat = _g2
            g.vertexPosition = self.i.readInt32()
            _g5 = []
            _g6 = 0
            _g7 = self.i.readByte()
            while (_g6 < _g7):
                k2 = _g6
                _g6 = (_g6 + 1)
                x2 = self.i.readInt32()
                _g5.append(x2)
            g.indexCounts = _g5
            g.indexPosition = self.i.readInt32()
            g.bounds = self.readBounds()
            _this = d.geometries
            _this.append(g)
        d.materials = []
        _g = 0
        _g1 = self.i.readInt32()
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            m = hxd_fmt_hmd_Material()
            m.props = self.readProps()
            m.name = self.readName()
            m.diffuseTexture = self.readName()
            m.blendMode = python_internal_ArrayImpl._get(hxd_fmt_hmd_Reader.BLEND, self.i.readByte())
            self.i.readByte()
            self.i.readFloat()
            if ((m.props is not None) and ((python_internal_ArrayImpl.indexOf(m.props,hxd_fmt_hmd_Property.HasExtraTextures,None) >= 0))):
                m.specularTexture = self.readName()
                m.normalMap = self.readName()
            _this = d.materials
            _this.append(m)
        d.models = []
        _g = 0
        _g1 = self.i.readInt32()
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            m = hxd_fmt_hmd_Model()
            m.props = self.readProps()
            m.name = self.readCachedName()
            m.parent = (self.i.readInt32() - 1)
            m.follow = self.readCachedName()
            m.position = self.readPosition()
            m.geometry = (self.i.readInt32() - 1)
            _this = d.models
            _this.append(m)
            if (m.geometry < 0):
                continue
            m.materials = []
            _g2 = 0
            _g3 = self.i.readByte()
            while (_g2 < _g3):
                k1 = _g2
                _g2 = (_g2 + 1)
                _this1 = m.materials
                x = self.i.readInt32()
                _this1.append(x)
            m.skin = self.readSkin()
        d.animations = []
        _g = 0
        _g1 = self.i.readInt32()
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            a = hxd_fmt_hmd_Animation()
            a.props = self.readProps()
            a.name = self.readName()
            a.frames = self.i.readInt32()
            a.sampling = self.i.readFloat()
            a.speed = self.i.readFloat()
            flags = self.i.readByte()
            a.loop = (((flags & 1)) != 0)
            a.dataPosition = self.i.readInt32()
            a.objects = []
            _g2 = 0
            _g3 = self.i.readInt32()
            while (_g2 < _g3):
                k1 = _g2
                _g2 = (_g2 + 1)
                o = hxd_fmt_hmd_AnimationObject()
                o.name = self.readCachedName()
                i = self.i.readByte()
                if (i is None):
                    i = 0
                this1 = i
                o.flags = this1
                _this = a.objects
                _this.append(o)
                if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                    _g4 = []
                    _g5 = 0
                    _g6 = self.i.readByte()
                    while (_g5 < _g6):
                        i1 = _g5
                        _g5 = (_g5 + 1)
                        x = self.readName()
                        _g4.append(x)
                    o.props = _g4
            if (((flags & 2)) != 0):
                a.events = []
                _g7 = 0
                _g8 = self.i.readInt32()
                while (_g7 < _g8):
                    k2 = _g7
                    _g7 = (_g7 + 1)
                    e = hxd_fmt_hmd_AnimationEvent()
                    e.frame = self.i.readInt32()
                    e.data = self.readCachedName()
                    _this1 = a.events
                    _this1.append(e)
            _this2 = d.animations
            _this2.append(a)
        return d

    def read(self):
        h = self.readHeader()
        h.data = self.i.read(self.i.readInt32())
        return h
    HMD_STRINGS = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.version = None
hxd_fmt_hmd_Reader._hx_class = hxd_fmt_hmd_Reader
_hx_classes["hxd.fmt.hmd.Reader"] = hxd_fmt_hmd_Reader


class hxd_fmt_hmd_Writer:
    _hx_class_name = "hxd.fmt.hmd.Writer"
    _hx_is_interface = "False"
    __slots__ = ("out", "version")
    _hx_fields = ["out", "version"]
    _hx_methods = ["writeProperty", "writeProps", "writeName", "writeFloat", "writePosition", "writeBounds", "writeSkin", "write"]

    def __init__(self,out):
        self.version = None
        self.out = out

    def writeProperty(self,p):
        self.out.writeByte(p.index)
        tmp = p.index
        if (tmp == 0):
            v = p.params[0]
            self.out.writeFloat(v)
        elif (tmp == 1):
            pass
        elif (tmp == 2):
            pass
        else:
            pass

    def writeProps(self,props):
        if (props is None):
            if (self.version == 1):
                return
            self.out.writeByte(0)
            return
        if (self.version == 1):
            raise haxe_Exception.thrown("Properties not supported in HMDv1")
        self.out.writeByte(len(props))
        _g = 0
        while (_g < len(props)):
            p = (props[_g] if _g >= 0 and _g < len(props) else None)
            _g = (_g + 1)
            self.writeProperty(p)

    def writeName(self,name):
        if (name is None):
            self.out.writeByte(255)
            return
        self.out.writeByte(len(name))
        self.out.writeString(name)

    def writeFloat(self,f):
        self.out.writeFloat((0 if ((f == 0)) else f))

    def writePosition(self,p,hasScale = None):
        if (hasScale is None):
            hasScale = True
        f = p.x
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = p.y
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = p.z
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = p.qx
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = p.qy
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = p.qz
        self.out.writeFloat((0 if ((f == 0)) else f))
        if hasScale:
            f = p.sx
            self.out.writeFloat((0 if ((f == 0)) else f))
            f = p.sy
            self.out.writeFloat((0 if ((f == 0)) else f))
            f = p.sz
            self.out.writeFloat((0 if ((f == 0)) else f))

    def writeBounds(self,b):
        f = b.xMin
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = b.yMin
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = b.zMin
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = b.xMax
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = b.yMax
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = b.zMax
        self.out.writeFloat((0 if ((f == 0)) else f))

    def writeSkin(self,s):
        self.writeName(("" if ((s.name is None)) else s.name))
        self.writeProps(s.props)
        self.out.writeUInt16(len(s.joints))
        _g = 0
        _g1 = s.joints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(j.props)
            self.writeName(j.name)
            rot = ((((j.position.sx != 1) or ((j.position.sy != 1))) or ((j.position.sz != 1))) or (((j.transpos is not None) and ((((j.transpos.sx != 1) or ((j.transpos.sy != 1))) or ((j.transpos.sz != 1)))))))
            self.out.writeUInt16(((j.parent + 1) | ((32768 if rot else 0))))
            self.writePosition(j.position,rot)
            self.out.writeUInt16((j.bind + 1))
            if (j.bind >= 0):
                self.writePosition(j.transpos,rot)
        self.out.writeByte((0 if ((s.split is None)) else len(s.split)))
        if (s.split is not None):
            _g = 0
            _g1 = s.split
            while (_g < len(_g1)):
                ss = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.out.writeByte(ss.materialIndex)
                self.out.writeByte(len(ss.joints))
                _g2 = 0
                _g3 = ss.joints
                while (_g2 < len(_g3)):
                    i = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    self.out.writeUInt16(i)

    def write(self,d):
        old = self.out
        header = haxe_io_BytesOutput()
        self.out = header
        self.version = d.version
        if (self.version > 3):
            raise haxe_Exception.thrown(("Can't write HMD v" + Std.string(self.version)))
        self.writeProps(d.props)
        self.out.writeInt32(len(d.geometries))
        _g = 0
        _g1 = d.geometries
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(g.props)
            self.out.writeInt32(g.vertexCount)
            self.out.writeByte(g.vertexStride)
            self.out.writeByte(len(g.vertexFormat))
            _g2 = 0
            _g3 = g.vertexFormat
            while (_g2 < len(_g3)):
                f = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.writeName(f.name)
                self.out.writeByte(f.format)
            self.out.writeInt32(g.vertexPosition)
            self.out.writeByte(len(g.indexCounts))
            _g4 = 0
            _g5 = g.indexCounts
            while (_g4 < len(_g5)):
                i = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                self.out.writeInt32(i)
            self.out.writeInt32(g.indexPosition)
            self.writeBounds(g.bounds)
        self.out.writeInt32(len(d.materials))
        _g = 0
        _g1 = d.materials
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(m.props)
            self.writeName(m.name)
            self.writeName(m.diffuseTexture)
            self.out.writeByte(m.blendMode.index)
            self.out.writeByte(1)
            self.out.writeFloat(1)
            if ((m.props is not None) and ((python_internal_ArrayImpl.indexOf(m.props,hxd_fmt_hmd_Property.HasExtraTextures,None) >= 0))):
                self.writeName(m.specularTexture)
                self.writeName(m.normalMap)
        self.out.writeInt32(len(d.models))
        _g = 0
        _g1 = d.models
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(m.props)
            self.writeName(m.name)
            self.out.writeInt32((m.parent + 1))
            self.writeName(m.follow)
            self.writePosition(m.position)
            self.out.writeInt32((m.geometry + 1))
            if (m.geometry < 0):
                continue
            self.out.writeByte(len(m.materials))
            _g2 = 0
            _g3 = m.materials
            while (_g2 < len(_g3)):
                m1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.out.writeInt32(m1)
            if (m.skin is None):
                self.writeName(None)
            else:
                self.writeSkin(m.skin)
        self.out.writeInt32(len(d.animations))
        _g = 0
        _g1 = d.animations
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(a.props)
            self.writeName(a.name)
            self.out.writeInt32(a.frames)
            f = a.sampling
            self.out.writeFloat((0 if ((f == 0)) else f))
            f1 = a.speed
            self.out.writeFloat((0 if ((f1 == 0)) else f1))
            self.out.writeByte((((1 if (a.loop) else 0)) | ((2 if ((a.events is not None)) else 0))))
            self.out.writeInt32(a.dataPosition)
            self.out.writeInt32(len(a.objects))
            _g2 = 0
            _g3 = a.objects
            while (_g2 < len(_g3)):
                o = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.writeName(o.name)
                self.out.writeByte(o.flags)
                if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                    self.out.writeByte(len(o.props))
                    _g4 = 0
                    _g5 = o.props
                    while (_g4 < len(_g5)):
                        n = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                        _g4 = (_g4 + 1)
                        self.writeName(n)
            if (a.events is not None):
                self.out.writeInt32(len(a.events))
                _g6 = 0
                _g7 = a.events
                while (_g6 < len(_g7)):
                    e = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                    _g6 = (_g6 + 1)
                    self.out.writeInt32(e.frame)
                    self.writeName(e.data)
        _hx_bytes = header.getBytes()
        self.out = old
        self.out.writeString("HMD")
        self.out.writeByte(d.version)
        self.out.writeInt32((_hx_bytes.length + 12))
        self.out.write(_hx_bytes)
        self.out.writeInt32(d.data.length)
        self.out.write(d.data)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.out = None
        _hx_o.version = None
hxd_fmt_hmd_Writer._hx_class = hxd_fmt_hmd_Writer
_hx_classes["hxd.fmt.hmd.Writer"] = hxd_fmt_hmd_Writer


class hxd_fs_FileEntry:
    _hx_class_name = "hxd.fs.FileEntry"
    _hx_is_interface = "False"
    __slots__ = ("name",)
    _hx_fields = ["name"]
    _hx_methods = ["getSign", "getBytes", "getText", "open", "skip", "readByte", "read", "close", "load", "loadBitmap", "watch", "exists", "get", "iterator", "get_isAvailable", "get_isDirectory", "get_size", "get_path", "get_directory", "get_extension"]

    def getSign(self):
        return 0

    def getBytes(self):
        return None

    def getText(self):
        return self.getBytes().toString()

    def open(self):
        pass

    def skip(self,nbytes):
        pass

    def readByte(self):
        return 0

    def read(self,out,pos,size):
        pass

    def close(self):
        pass

    def load(self,onReady = None):
        if (not self.get_isAvailable()):
            raise haxe_Exception.thrown("load() not implemented")
        elif (onReady is not None):
            onReady()

    def loadBitmap(self,onLoaded):
        raise haxe_Exception.thrown("loadBitmap() not implemented")

    def watch(self,onChanged):
        pass

    def exists(self,name):
        return False

    def get(self,name):
        return None

    def iterator(self):
        return None

    def get_isAvailable(self):
        return True

    def get_isDirectory(self):
        return False

    def get_size(self):
        return 0

    def get_path(self):
        raise haxe_Exception.thrown("path() not implemented")

    def get_directory(self):
        _this = self.get_path()
        startIndex = None
        idx = None
        if (startIndex is None):
            idx = _this.rfind("/", 0, len(_this))
        else:
            i = _this.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = _this.find("/", startLeft, len(_this))
            idx = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (idx < 0):
            return ""
        return HxString.substr(self.get_path(),0,idx)

    def get_extension(self):
        _this = self.name
        startIndex = None
        idx = None
        if (startIndex is None):
            idx = _this.rfind(".", 0, len(_this))
        else:
            i = _this.rfind(".", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("."))) if ((i == -1)) else (i + 1))
            check = _this.find(".", startLeft, len(_this))
            idx = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (idx < 0):
            return ""
        return HxString.substr(self.name,(idx + 1),None).lower()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
hxd_fs_FileEntry._hx_class = hxd_fs_FileEntry
_hx_classes["hxd.fs.FileEntry"] = hxd_fs_FileEntry


class hxd_fs_BytesFileEntry(hxd_fs_FileEntry):
    _hx_class_name = "hxd.fs.BytesFileEntry"
    _hx_is_interface = "False"
    __slots__ = ("fullPath", "bytes", "pos")
    _hx_fields = ["fullPath", "bytes", "pos"]
    _hx_methods = ["get_path", "getSign", "getBytes", "open", "skip", "readByte", "read", "close", "load", "loadBitmap", "exists", "get", "iterator", "get_size"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fs_FileEntry


    def __init__(self,path,_hx_bytes):
        self.pos = None
        self.fullPath = path
        _this = path.split("/")
        self.name = (None if ((len(_this) == 0)) else _this.pop())
        self.bytes = _hx_bytes

    def get_path(self):
        return self.fullPath

    def getSign(self):
        return (((self.bytes.b[0] | ((self.bytes.b[1] << 8))) | ((self.bytes.b[2] << 16))) | ((self.bytes.b[3] << 24)))

    def getBytes(self):
        return self.bytes

    def open(self):
        self.pos = 0

    def skip(self,nbytes):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + nbytes)
        _hx_local_0.pos

    def readByte(self):
        pos = self.pos
        self.pos = (self.pos + 1)
        return self.bytes.b[pos]

    def read(self,out,pos,size):
        out.blit(pos,self.bytes,self.pos,size)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + size)
        _hx_local_0.pos

    def close(self):
        pass

    def load(self,onReady = None):
        haxe_Timer.delay(onReady,1)

    def loadBitmap(self,onLoaded):
        raise haxe_Exception.thrown("Not implemented")

    def exists(self,name):
        return False

    def get(self,name):
        return None

    def iterator(self):
        return hxd_impl_ArrayIterator_hxd_fs_FileEntry(list())

    def get_size(self):
        return self.bytes.length

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fullPath = None
        _hx_o.bytes = None
        _hx_o.pos = None
hxd_fs_BytesFileEntry._hx_class = hxd_fs_BytesFileEntry
_hx_classes["hxd.fs.BytesFileEntry"] = hxd_fs_BytesFileEntry


class hxd_fs_FileSystem:
    _hx_class_name = "hxd.fs.FileSystem"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["getRoot", "get", "exists", "dispose", "dir"]
hxd_fs_FileSystem._hx_class = hxd_fs_FileSystem
_hx_classes["hxd.fs.FileSystem"] = hxd_fs_FileSystem


class hxd_fs_BytesFileSystem:
    _hx_class_name = "hxd.fs.BytesFileSystem"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["getRoot", "getBytes", "exists", "get", "dispose", "dir"]
    _hx_interfaces = [hxd_fs_FileSystem]

    def __init__(self):
        pass

    def getRoot(self):
        raise haxe_Exception.thrown("Not implemented")

    def getBytes(self,path):
        raise haxe_Exception.thrown("Not implemented")

    def exists(self,path):
        return (self.getBytes(path) is not None)

    def get(self,path):
        _hx_bytes = self.getBytes(path)
        if (_hx_bytes is None):
            raise haxe_Exception.thrown((("Resource not found '" + ("null" if path is None else path)) + "'"))
        return hxd_fs_BytesFileEntry(path,_hx_bytes)

    def dispose(self):
        pass

    def dir(self,path):
        raise haxe_Exception.thrown("Not implemented")

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_BytesFileSystem._hx_class = hxd_fs_BytesFileSystem
_hx_classes["hxd.fs.BytesFileSystem"] = hxd_fs_BytesFileSystem


class hxd_fs_Convert:
    _hx_class_name = "hxd.fs.Convert"
    _hx_is_interface = "False"
    __slots__ = ("sourceExts", "destExt", "version", "params", "srcPath", "dstPath", "originalFilename", "srcBytes")
    _hx_fields = ["sourceExts", "destExt", "version", "params", "srcPath", "dstPath", "originalFilename", "srcBytes"]
    _hx_methods = ["convert", "hasParam", "getParam", "save", "command"]
    _hx_statics = ["converts", "register"]

    def __init__(self,sourceExts,destExt):
        self.srcBytes = None
        self.originalFilename = None
        self.dstPath = None
        self.srcPath = None
        self.params = None
        self.sourceExts = (None if ((sourceExts is None)) else HxOverrides.split(sourceExts, ","))
        self.destExt = destExt
        self.version = 0

    def convert(self):
        raise haxe_Exception.thrown("Not implemented")

    def hasParam(self,name):
        f = Reflect.field(self.params,name)
        if (f is not None):
            return (f != False)
        else:
            return False

    def getParam(self,name):
        f = Reflect.field(self.params,name)
        if (f is None):
            raise haxe_Exception.thrown(((((("Missing required parameter '" + ("null" if name is None else name)) + "' for converting ") + HxOverrides.stringOrNull(self.srcPath)) + " to ") + HxOverrides.stringOrNull(self.dstPath)))
        return f

    def save(self,_hx_bytes):
        hxd_File.saveBytes(self.dstPath,_hx_bytes)

    def command(self,cmd,args):
        code = Sys.command(cmd,args)
        if (code != 0):
            raise haxe_Exception.thrown((((("Command '" + ("null" if cmd is None else cmd)) + HxOverrides.stringOrNull((("" if ((len(args) == 0)) else (" " + HxOverrides.stringOrNull(" ".join([python_Boot.toString1(x1,'') for x1 in args]))))))) + "' failed with exit code ") + Std.string(code)))

    @staticmethod
    def register(c):
        dest = hxd_fs_Convert.converts.h.get(c.destExt,None)
        if (dest is None):
            dest = []
            hxd_fs_Convert.converts.h[c.destExt] = dest
        dest.insert(0, c)
        return 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.sourceExts = None
        _hx_o.destExt = None
        _hx_o.version = None
        _hx_o.params = None
        _hx_o.srcPath = None
        _hx_o.dstPath = None
        _hx_o.originalFilename = None
        _hx_o.srcBytes = None
hxd_fs_Convert._hx_class = hxd_fs_Convert
_hx_classes["hxd.fs.Convert"] = hxd_fs_Convert


class hxd_fs_ConvertFBX2HMD(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertFBX2HMD"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        super().__init__("fbx","hmd")

    def convert(self):
        fbx = None
        try:
            fbx = hxd_fmt_fbx_Parser.parse(self.srcBytes)
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            raise haxe_Exception.thrown(((Std.string(e) + " in ") + HxOverrides.stringOrNull(self.srcPath)))
        hmdout = hxd_fmt_fbx_HMDOut(self.srcPath)
        hmdout.load(fbx)
        isAnim = None
        if (not self.originalFilename.startswith("Anim_")):
            _this = self.originalFilename.lower()
            startIndex = None
            isAnim = (((_this.find("_anim_") if ((startIndex is None)) else HxString.indexOfImpl(_this,"_anim_",startIndex))) > 0)
        else:
            isAnim = True
        hmd = hmdout.toHMD(None,(not isAnim))
        out = haxe_io_BytesOutput()
        hxd_fmt_hmd_Writer(out).write(hmd)
        self.save(out.getBytes())

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_ConvertFBX2HMD._hx_class = hxd_fs_ConvertFBX2HMD
_hx_classes["hxd.fs.ConvertFBX2HMD"] = hxd_fs_ConvertFBX2HMD


class hxd_fs_Command(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.Command"
    _hx_is_interface = "False"
    __slots__ = ("cmd", "args")
    _hx_fields = ["cmd", "args"]
    _hx_methods = ["convert"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self,fr,to,cmd,args):
        self.args = None
        self.cmd = None
        super().__init__(fr,to)
        self.cmd = cmd
        self.args = args

    def convert(self):
        tmp = self.cmd
        _g = []
        _g1 = 0
        _g2 = self.args
        while (_g1 < len(_g2)):
            a = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            if (a == "%SRC"):
                x = self.srcPath
                _g.append(x)
            elif (a == "%DST"):
                x1 = self.dstPath
                _g.append(x1)
            else:
                _g.append(a)
        self.command(tmp,_g)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cmd = None
        _hx_o.args = None
hxd_fs_Command._hx_class = hxd_fs_Command
_hx_classes["hxd.fs.Command"] = hxd_fs_Command


class hxd_fs_ConvertWAV2MP3(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertWAV2MP3"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        super().__init__("wav","mp3")

    def convert(self):
        self.command("lame",["--resample", "44100", "--silent", "-h", self.srcPath, self.dstPath])

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_ConvertWAV2MP3._hx_class = hxd_fs_ConvertWAV2MP3
_hx_classes["hxd.fs.ConvertWAV2MP3"] = hxd_fs_ConvertWAV2MP3


class hxd_fs_ConvertWAV2OGG(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertWAV2OGG"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        super().__init__("wav","ogg")

    def convert(self):
        cmd = "oggenc"
        args = ["--resample", "44100", "-Q", self.srcPath, "-o", self.dstPath]
        if (Sys.systemName() == "Windows"):
            cmd = "oggenc2"
        if self.hasParam("mono"):
            f = sys_io_File.read(self.srcPath)
            wav = format_wav_Reader(f).read()
            f.close()
            if (wav.header.channels >= 2):
                args.append("--downmix")
        self.command(cmd,args)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_ConvertWAV2OGG._hx_class = hxd_fs_ConvertWAV2OGG
_hx_classes["hxd.fs.ConvertWAV2OGG"] = hxd_fs_ConvertWAV2OGG


class hxd_fs_ConvertTGA2PNG(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertTGA2PNG"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        super().__init__("tga","png")

    def convert(self):
        input = haxe_io_BytesInput(sys_io_File.getBytes(self.srcPath))
        r = format_tga_Reader(input).read()
        if ((r.header.imageType != format_tga_ImageType.UncompressedTrueColor) or ((r.header.bitsPerPixel != 32))):
            raise haxe_Exception.thrown(((("Not supported " + Std.string(r.header.imageType)) + "/") + Std.string(r.header.bitsPerPixel)))
        w = r.header.width
        h = r.header.height
        pix = hxd_Pixels.alloc(w,h,hxd_PixelFormat.ARGB)
        access = hxd__Pixels_PixelsARGB_Impl_.fromPixels(pix)
        p = 0
        _g = 0
        _g1 = h
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = w
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                c = r.imageData[(x + ((y * w)))]
                _this = access.bytes
                pos = ((((x + ((y * access.width))) << 2)) + access.offset)
                v = (((HxOverrides.rshift(c, 24) | (((c >> 8) & 65280))) | (((c << 8) & 16711680))) | ((c << 24)))
                _this.b[pos] = (v & 255)
                _this.b[(pos + 1)] = ((v >> 8) & 255)
                _this.b[(pos + 2)] = ((v >> 16) & 255)
                _this.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        tmp = r.header.imageOrigin.index
        if (tmp == 0):
            pix.flags = (pix.flags | ((1 << hxd_Flags.FlipY.index)))
        elif (tmp == 2):
            pass
        else:
            raise haxe_Exception.thrown(("Not supported " + Std.string(r.header.imageOrigin)))
        sys_io_File.saveBytes(self.dstPath,pix.toPNG())

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_ConvertTGA2PNG._hx_class = hxd_fs_ConvertTGA2PNG
_hx_classes["hxd.fs.ConvertTGA2PNG"] = hxd_fs_ConvertTGA2PNG


class hxd_fs_ConvertFNT2BFNT(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertFNT2BFNT"
    _hx_is_interface = "False"
    __slots__ = ("emptyTile",)
    _hx_fields = ["emptyTile"]
    _hx_methods = ["convert", "resolveTile"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        self.emptyTile = h2d_Tile(None,0,0,0,0,0,0)
        super().__init__("fnt","bfnt")
        self.version = 1

    def convert(self):
        font = hxd_fmt_bfnt_FontParser.parse(self.srcBytes,self.srcPath,self.resolveTile)
        out = haxe_io_BytesOutput()
        hxd_fmt_bfnt_Writer(out).write(font)
        self.save(out.getBytes())

    def resolveTile(self,path):
        if (not sys_FileSystem.exists(path)):
            raise haxe_Exception.thrown(("Could not resolve BitmapFont texture reference at path: " + ("null" if path is None else path)))
        return self.emptyTile

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.emptyTile = None
hxd_fs_ConvertFNT2BFNT._hx_class = hxd_fs_ConvertFNT2BFNT
_hx_classes["hxd.fs.ConvertFNT2BFNT"] = hxd_fs_ConvertFNT2BFNT


class hxd_fs_CompressIMG(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.CompressIMG"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["TEXCONV_FMT", "_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self,sourceExts,destExt):
        super().__init__(sourceExts,destExt)

    def convert(self):
        format = self.getParam("format")
        mips = (self.hasParam("mips") and ((self.getParam("mips") == True)))
        tcFmt = hxd_fs_CompressIMG.TEXCONV_FMT.h.get(format,None)
        if (tcFmt is not None):
            tmpPath = haxe_io_Path(self.dstPath)
            tmpPath.ext = ("tmp." + HxOverrides.stringOrNull(haxe_io_Path(self.srcPath).ext))
            tmpFile = tmpPath.toString()
            try:
                sys_FileSystem.deleteFile(tmpFile)
            except BaseException as _g:
                None
            try:
                sys_FileSystem.deleteFile(self.dstPath)
            except BaseException as _g:
                None
            sys_io_File.copy(self.srcPath,tmpFile)
            args = ["-f", tcFmt, "-y", "-nologo", tmpFile]
            if (not mips):
                args = (["-m", "1"] + args)
            self.command("texconv",args)
            sys_FileSystem.deleteFile(tmpFile)
            tmpPath.ext = "tmp.DDS"
            sys_FileSystem.rename(tmpPath.toString(),self.dstPath)
            return
        args = ["-silent"]
        if mips:
            args.append("-miplevels")
            args.append("20")
        if (self.hasParam("alpha") and ((format == "BC1"))):
            args = (args + ["-DXT1UseAlpha", "1", "-AlphaThreshold", ("" + Std.string(self.getParam("alpha")))])
        args = (args + ["-fd", ("" + Std.string(self.getParam("format"))), self.srcPath, self.dstPath])
        self.command("CompressonatorCLI",args)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_CompressIMG._hx_class = hxd_fs_CompressIMG
_hx_classes["hxd.fs.CompressIMG"] = hxd_fs_CompressIMG


class hxd_fs_DummyConvert(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.DummyConvert"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self,sourceExts,destExt):
        super().__init__(sourceExts,destExt)

    def convert(self):
        self.save(haxe_io_Bytes.alloc(0))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_DummyConvert._hx_class = hxd_fs_DummyConvert
_hx_classes["hxd.fs.DummyConvert"] = hxd_fs_DummyConvert

class hxd_fs_ConvertPattern(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fs.ConvertPattern"
    _hx_constructs = ["Filename", "Regexp", "Ext", "Exts", "Wildcard"]

    @staticmethod
    def Filename(name):
        return hxd_fs_ConvertPattern("Filename", 0, (name,))

    @staticmethod
    def Regexp(r):
        return hxd_fs_ConvertPattern("Regexp", 1, (r,))

    @staticmethod
    def Ext(e):
        return hxd_fs_ConvertPattern("Ext", 2, (e,))

    @staticmethod
    def Exts(e):
        return hxd_fs_ConvertPattern("Exts", 3, (e,))
hxd_fs_ConvertPattern.Wildcard = hxd_fs_ConvertPattern("Wildcard", 4, ())
hxd_fs_ConvertPattern._hx_class = hxd_fs_ConvertPattern
_hx_classes["hxd.fs.ConvertPattern"] = hxd_fs_ConvertPattern


class hxd_fs_FileConverter:
    _hx_class_name = "hxd.fs.FileConverter"
    _hx_is_interface = "False"
    _hx_fields = ["configuration", "baseDir", "tmpDir", "configs", "defaultConfig", "cache"]
    _hx_methods = ["onConvert", "makeConfig", "loadConvert", "makeCommmand", "mergeRec", "getFileTime", "loadConfig", "getConvertRule", "run", "runConvert", "convertAndCache"]
    _hx_statics = ["extraConfigs", "addConfig", "sortByRulePiority"]

    def __init__(self,baseDir,configuration):
        self.cache = None
        self.defaultConfig = None
        self.configs = haxe_ds_StringMap()
        self.baseDir = baseDir
        self.configuration = configuration
        self.tmpDir = ".tmp/"
        defaultCfg = _hx_AnonObject({'fs.convert': _hx_AnonObject({'fbx': _hx_AnonObject({'convert': "hmd", 'priority': -1}), 'fnt': _hx_AnonObject({'convert': "bfnt", 'priority': -1})})})
        _g = 0
        _g1 = hxd_fs_FileConverter.extraConfigs
        while (_g < len(_g1)):
            conf = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            defaultCfg = self.mergeRec(defaultCfg,conf)
        self.defaultConfig = self.makeConfig(defaultCfg)

    def onConvert(self,c):
        pass

    def makeConfig(self,obj):
        cfg = _hx_AnonObject({'obj': obj, 'rules': []})
        _hx_def = Reflect.field(obj,"fs.convert")
        conf = Reflect.field(obj,("fs.convert." + HxOverrides.stringOrNull(self.configuration)))
        merge = self.mergeRec(_hx_def,conf)
        _g = 0
        _g1 = python_Boot.fields(merge)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            cmd = self.makeCommmand(Reflect.field(merge,f))
            pt = None
            if (HxString.charCodeAt(f,0) == 94):
                pt = hxd_fs_ConvertPattern.Regexp(EReg(f,""))
            else:
                _this = EReg("^[a-zA-Z0-9,]+$","")
                _this.matchObj = python_lib_Re.search(_this.pattern,f)
                if (_this.matchObj is not None):
                    _this1 = f.lower()
                    el = _this1.split(",")
                    pt = (hxd_fs_ConvertPattern.Ext((el[0] if 0 < len(el) else None)) if ((len(el) == 1)) else hxd_fs_ConvertPattern.Exts(el))
                else:
                    pt = (hxd_fs_ConvertPattern.Wildcard if ((f == "*")) else hxd_fs_ConvertPattern.Filename(f))
            _this2 = cfg.rules
            x = _hx_AnonObject({'pt': pt, 'cmd': cmd.cmd, 'priority': cmd.priority})
            _this2.append(x)
        cfg.rules.sort(key= python_lib_Functools.cmp_to_key(hxd_fs_FileConverter.sortByRulePiority))
        return cfg

    def loadConvert(self,name):
        if (name == "none"):
            return None
        c = hxd_fs_Convert.converts.h.get(name,None)
        if (c is None):
            raise haxe_Exception.thrown((("No convert has been registered with name/extension '" + ("null" if name is None else name)) + "'"))
        return c

    def makeCommmand(self,obj):
        if Std.isOfType(obj,str):
            return _hx_AnonObject({'cmd': _hx_AnonObject({'conv': self.loadConvert(obj)}), 'priority': 0})
        if (Reflect.field(obj,"convert") is None):
            raise haxe_Exception.thrown(("Missing 'convert' in " + Std.string(obj)))
        cmd = _hx_AnonObject({'conv': self.loadConvert(Reflect.field(obj,"convert"))})
        priority = 0
        _g = 0
        _g1 = python_Boot.fields(obj)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            value = Reflect.field(obj,f)
            f1 = f
            _hx_local_1 = len(f1)
            if (_hx_local_1 == 4):
                if (f1 == "then"):
                    Reflect.setField(cmd,"then",self.makeCommmand(value).cmd)
                else:
                    if (Reflect.field(cmd,"params") is None):
                        Reflect.setField(cmd,"params",_hx_AnonObject({}))
                    if (Reflect.isObject(value) and (not Std.isOfType(value,str))):
                        raise haxe_Exception.thrown(((("Invalid parameter value " + ("null" if f is None else f)) + "=") + Std.string(value)))
                    setattr(Reflect.field(cmd,"params"),(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
            elif (_hx_local_1 == 7):
                if (f1 == "convert"):
                    pass
                else:
                    if (Reflect.field(cmd,"params") is None):
                        Reflect.setField(cmd,"params",_hx_AnonObject({}))
                    if (Reflect.isObject(value) and (not Std.isOfType(value,str))):
                        raise haxe_Exception.thrown(((("Invalid parameter value " + ("null" if f is None else f)) + "=") + Std.string(value)))
                    setattr(Reflect.field(cmd,"params"),(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
            elif (_hx_local_1 == 8):
                if (f1 == "priority"):
                    priority = value
                else:
                    if (Reflect.field(cmd,"params") is None):
                        Reflect.setField(cmd,"params",_hx_AnonObject({}))
                    if (Reflect.isObject(value) and (not Std.isOfType(value,str))):
                        raise haxe_Exception.thrown(((("Invalid parameter value " + ("null" if f is None else f)) + "=") + Std.string(value)))
                    setattr(Reflect.field(cmd,"params"),(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
            else:
                if (Reflect.field(cmd,"params") is None):
                    Reflect.setField(cmd,"params",_hx_AnonObject({}))
                if (Reflect.isObject(value) and (not Std.isOfType(value,str))):
                    raise haxe_Exception.thrown(((("Invalid parameter value " + ("null" if f is None else f)) + "=") + Std.string(value)))
                setattr(Reflect.field(cmd,"params"),(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
        if (Reflect.field(cmd,"params") is not None):
            fl = python_Boot.fields(Reflect.field(cmd,"params"))
            fl.sort(key= python_lib_Functools.cmp_to_key(Reflect.compare))
            _g = []
            _g1 = 0
            while (_g1 < len(fl)):
                f = (fl[_g1] if _g1 >= 0 and _g1 < len(fl) else None)
                _g1 = (_g1 + 1)
                x = ((("null" if f is None else f) + "_") + Std.string(Reflect.field(Reflect.field(cmd,"params"),f)))
                _g.append(x)
            Reflect.setField(cmd,"paramsStr","_".join([python_Boot.toString1(x1,'') for x1 in _g]))
        return _hx_AnonObject({'cmd': cmd, 'priority': priority})

    def mergeRec(self,a,b):
        if (b is None):
            return a
        if (a is None):
            return b
        cp = _hx_AnonObject({})
        _g = 0
        _g1 = python_Boot.fields(a)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            va = Reflect.field(a,f)
            if python_Boot.hasField(b,f):
                vb = Reflect.field(b,f)
                if ((Type.typeof(vb) == ValueType.TObject) and ((Type.typeof(va) == ValueType.TObject))):
                    vb = self.mergeRec(va,vb)
                setattr(cp,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),vb)
                continue
            setattr(cp,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),va)
        _g = 0
        _g1 = python_Boot.fields(b)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (not python_Boot.hasField(cp,f)):
                value = Reflect.field(b,f)
                setattr(cp,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
        return cp

    def getFileTime(self,filePath):
        return (sys_FileSystem.stat(filePath).mtime.date.timestamp() * 1000)

    def loadConfig(self,dir):
        c = self.configs.h.get(dir,None)
        if (c is not None):
            return c
        startIndex = None
        dirPos = None
        if (startIndex is None):
            dirPos = dir.rfind("/", 0, len(dir))
        else:
            i = dir.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = dir.find("/", startLeft, len(dir))
            dirPos = (check if (((check > i) and ((check <= startIndex)))) else i)
        parent = (self.defaultConfig if ((dir == "")) else self.loadConfig(("" if ((dirPos < 0)) else HxString.substr(dir,0,dirPos))))
        propsFile = (HxOverrides.stringOrNull(((self.baseDir if ((dir == "")) else ((HxOverrides.stringOrNull(self.baseDir) + ("null" if dir is None else dir)) + "/")))) + "props.json")
        if (not sys_FileSystem.exists(propsFile)):
            c = parent
        else:
            content = sys_io_File.getContent(propsFile)
            obj = None
            try:
                obj = python_lib_Json.loads(content,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
            except BaseException as _g:
                None
                e = haxe_Exception.caught(_g).unwrap()
                raise haxe_Exception.thrown((((("Failed to parse " + ("null" if propsFile is None else propsFile)) + "(") + Std.string(e)) + ")"))
            fullObj = self.mergeRec(parent.obj,obj)
            c = self.makeConfig(fullObj)
        self.configs.h[dir] = c
        return c

    def getConvertRule(self,path):
        startIndex = None
        dirPos = None
        if (startIndex is None):
            dirPos = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            dirPos = (check if (((check > i) and ((check <= startIndex)))) else i)
        cfg = self.loadConfig(("" if ((dirPos < 0)) else HxString.substr(path,0,dirPos)))
        name = (path if ((dirPos < 0)) else HxString.substr(path,(dirPos + 1),None))
        _this = name.split(".")
        ext = (None if ((len(_this) == 0)) else _this.pop()).lower()
        _g = 0
        _g1 = cfg.rules
        while (_g < len(_g1)):
            r = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = r.pt
            tmp = _g2.index
            if (tmp == 0):
                f = _g2.params[0]
                if ((name == f) or ((path == f))):
                    return r
            elif (tmp == 1):
                reg = _g2.params[0]
                tmp1 = None
                reg.matchObj = python_lib_Re.search(reg.pattern,name)
                if (reg.matchObj is None):
                    reg.matchObj = python_lib_Re.search(reg.pattern,path)
                    tmp1 = (reg.matchObj is not None)
                else:
                    tmp1 = True
                if tmp1:
                    return r
            elif (tmp == 2):
                e = _g2.params[0]
                if (ext == e):
                    return r
            elif (tmp == 3):
                el = _g2.params[0]
                if (python_internal_ArrayImpl.indexOf(el,ext,None) >= 0):
                    return r
            elif (tmp == 4):
                return r
            else:
                pass
        return None

    def run(self,e):
        rule = self.getConvertRule(e.get_path())
        if (e.originalFile is None):
            e.originalFile = e.file
        else:
            e.file = e.originalFile
        if ((rule is None) or ((rule.cmd.conv is None))):
            return
        e.file = HxString.substr(e.file,len(self.baseDir),None)
        _g = rule.pt
        tmp = None
        if (_g.index == 2):
            _g1 = _g.params[0]
            tmp = True
        else:
            tmp = False
        self.runConvert(e,rule.cmd,tmp)

    def runConvert(self,e,cmd,replaceExt = None):
        if (replaceExt is None):
            replaceExt = False
        outFile = self.tmpDir
        ext = e.get_extension()
        if ((replaceExt and ((Reflect.field(cmd,"paramsStr") is None))) and ((Reflect.field(cmd,"then") is None))):
            outFile = (("null" if outFile is None else outFile) + HxOverrides.stringOrNull(HxString.substr(e.get_path(),0,-((len(ext) + 1)))))
        else:
            outFile = (("null" if outFile is None else outFile) + HxOverrides.stringOrNull(e.get_path()))
        if (Reflect.field(cmd,"paramsStr") is not None):
            outFile = (("null" if outFile is None else outFile) + HxOverrides.stringOrNull((("." + HxOverrides.stringOrNull(Reflect.field(cmd,"paramsStr"))))))
        conv = None
        _g = 0
        _g1 = cmd.conv
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((c.sourceExts is None) or ((python_internal_ArrayImpl.indexOf(c.sourceExts,ext,None) >= 0))):
                conv = c
                break
        if (conv is None):
            raise haxe_Exception.thrown(((("No converter is registered that can convert " + HxOverrides.stringOrNull(e.get_path())) + " to ") + HxOverrides.stringOrNull((cmd.conv[0] if 0 < len(cmd.conv) else None).destExt)))
        if (conv.destExt == "dummy"):
            e.file = ((HxOverrides.stringOrNull(self.baseDir) + HxOverrides.stringOrNull(self.tmpDir)) + ".dummy")
            if (not sys_FileSystem.exists(e.file)):
                sys_io_File.saveContent(e.file,"")
            return
        if (conv.destExt == "remove"):
            e.file = None
            return
        outFile = (("null" if outFile is None else outFile) + HxOverrides.stringOrNull((("." + HxOverrides.stringOrNull(conv.destExt)))))
        self.convertAndCache(e,outFile,conv,Reflect.field(cmd,"params"))
        if (Reflect.field(cmd,"then") is not None):
            e.file = outFile
            self.runConvert(e,Reflect.field(cmd,"then"))
        e.file = (HxOverrides.stringOrNull(self.baseDir) + ("null" if outFile is None else outFile))

    def convertAndCache(self,e,outFile,conv,params):
        _gthis = self
        if (self.cache is None):
            tmp = None
            try:
                tmp = haxe_Unserializer.run(sys_io_File.getContent(((HxOverrides.stringOrNull(self.baseDir) + HxOverrides.stringOrNull(self.tmpDir)) + "cache.dat")))
            except BaseException as _g:
                None
                tmp = haxe_ds_StringMap()
            self.cache = tmp
        entry = self.cache.h.get(e.file,None)
        needInsert = False
        if (entry is None):
            entry = []
            needInsert = True
        def _hx_local_0():
            if needInsert:
                _gthis.cache.h[e.file] = entry
            sys_FileSystem.createDirectory((HxOverrides.stringOrNull(_gthis.baseDir) + HxOverrides.stringOrNull(_gthis.tmpDir)))
            sys_io_File.saveContent(((HxOverrides.stringOrNull(_gthis.baseDir) + HxOverrides.stringOrNull(_gthis.tmpDir)) + "cache.dat"),haxe_Serializer.run(_gthis.cache))
        saveCache = _hx_local_0
        match = None
        _g = 0
        while (_g < len(entry)):
            e1 = (entry[_g] if _g >= 0 and _g < len(entry) else None)
            _g = (_g + 1)
            if (e1.out == outFile):
                match = e1
                if (match.ver is None):
                    match.ver = 0
                break
        if (match is None):
            match = _hx_AnonObject({'out': outFile, 'time': 0, 'hash': "", 'ver': conv.version})
            entry.append(match)
        fullPath = (HxOverrides.stringOrNull(self.baseDir) + HxOverrides.stringOrNull(e.file))
        fullOutPath = (HxOverrides.stringOrNull(self.baseDir) + ("null" if outFile is None else outFile))
        if (not sys_FileSystem.exists(fullPath)):
            raise haxe_Exception.thrown(("Missing " + ("null" if fullPath is None else fullPath)))
        time = Math.floor((self.getFileTime(fullPath) / 1000))
        alreadyGen = (sys_FileSystem.exists(fullOutPath) and ((match.ver == conv.version)))
        if (alreadyGen and ((match.time == time))):
            return
        content = hxd_File.getBytes(fullPath)
        hash = haxe_crypto_Sha1.make(content).toHex()
        if (alreadyGen and ((match.hash == hash))):
            match.time = time
            saveCache()
            return
        startIndex = None
        _hx_len = None
        if (startIndex is None):
            _hx_len = fullOutPath.rfind("/", 0, len(fullOutPath))
        else:
            i = fullOutPath.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = fullOutPath.find("/", startLeft, len(fullOutPath))
            _hx_len = (check if (((check > i) and ((check <= startIndex)))) else i)
        sys_FileSystem.createDirectory(HxString.substr(fullOutPath,0,_hx_len))
        conv.srcPath = fullPath
        conv.dstPath = fullOutPath
        conv.srcBytes = content
        conv.originalFilename = e.name
        conv.params = params
        self.onConvert(conv)
        conv.convert()
        conv.srcPath = None
        conv.dstPath = None
        conv.srcBytes = None
        conv.originalFilename = None
        hxd_System.timeoutTick()
        if (not sys_FileSystem.exists(fullOutPath)):
            raise haxe_Exception.thrown((("Converted output file " + ("null" if fullOutPath is None else fullOutPath)) + " was not created"))
        match.ver = conv.version
        match.time = time
        match.hash = hash
        saveCache()

    @staticmethod
    def addConfig(conf):
        _this = hxd_fs_FileConverter.extraConfigs
        _this.append(conf)
        return conf

    @staticmethod
    def sortByRulePiority(r1,r2):
        if (r1.priority != r2.priority):
            return (r2.priority - r1.priority)
        return (r1.pt.index - r2.pt.index)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.configuration = None
        _hx_o.baseDir = None
        _hx_o.tmpDir = None
        _hx_o.configs = None
        _hx_o.defaultConfig = None
        _hx_o.cache = None
hxd_fs_FileConverter._hx_class = hxd_fs_FileConverter
_hx_classes["hxd.fs.FileConverter"] = hxd_fs_FileConverter


class hxd_fs_FileInput(haxe_io_Input):
    _hx_class_name = "hxd.fs.FileInput"
    _hx_is_interface = "False"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["skip", "readByte", "readBytes", "close"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,f):
        self.f = f
        f.open()

    def skip(self,nbytes):
        self.f.skip(nbytes)

    def readByte(self):
        return self.f.readByte()

    def readBytes(self,b,pos,_hx_len):
        self.f.read(b,pos,_hx_len)
        return _hx_len

    def close(self):
        self.f.close()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
hxd_fs_FileInput._hx_class = hxd_fs_FileInput
_hx_classes["hxd.fs.FileInput"] = hxd_fs_FileInput


class hxd_fs__LoadedBitmap_LoadedBitmap_Impl_:
    _hx_class_name = "hxd.fs._LoadedBitmap.LoadedBitmap_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toBitmap", "toNative"]

    @staticmethod
    def _new(data):
        this1 = data
        return this1

    @staticmethod
    def toBitmap(this1):
        return this1

    @staticmethod
    def toNative(this1):
        return this1
hxd_fs__LoadedBitmap_LoadedBitmap_Impl_._hx_class = hxd_fs__LoadedBitmap_LoadedBitmap_Impl_
_hx_classes["hxd.fs._LoadedBitmap.LoadedBitmap_Impl_"] = hxd_fs__LoadedBitmap_LoadedBitmap_Impl_


class hxd_fs_LocalEntry(hxd_fs_FileEntry):
    _hx_class_name = "hxd.fs.LocalEntry"
    _hx_is_interface = "False"
    __slots__ = ("fs", "relPath", "file", "originalFile", "fread", "isDirCached", "watchCallback", "watchTime")
    _hx_fields = ["fs", "relPath", "file", "originalFile", "fread", "isDirCached", "watchCallback", "watchTime"]
    _hx_methods = ["getSign", "getBytes", "open", "skip", "readByte", "read", "close", "get_isDirectory", "load", "loadBitmap", "get_path", "exists", "get", "get_size", "iterator", "getModifTime", "watch"]
    _hx_statics = ["WATCH_INDEX", "WATCH_LIST", "tmpDir", "checkFiles", "checkNext"]
    _hx_interfaces = []
    _hx_super = hxd_fs_FileEntry


    def __init__(self,fs,name,relPath,file):
        self.watchTime = None
        self.watchCallback = None
        self.isDirCached = None
        self.fread = None
        self.originalFile = None
        self.fs = fs
        self.name = name
        self.relPath = relPath
        self.file = file

    def getSign(self):
        old = (-1 if ((self.fread is None)) else self.fread.tell())
        self.open()
        i = self.fread.readInt32()
        if (old < 0):
            self.close()
        else:
            self.fread.seek(old,sys_io_FileSeek.SeekBegin)
        return i

    def getBytes(self):
        return sys_io_File.getBytes(self.file)

    def open(self):
        if (self.fread is not None):
            self.fread.seek(0,sys_io_FileSeek.SeekBegin)
        else:
            self.fread = sys_io_File.read(self.file)

    def skip(self,nbytes):
        self.fread.seek(nbytes,sys_io_FileSeek.SeekCur)

    def readByte(self):
        return self.fread.readByte()

    def read(self,out,pos,size):
        self.fread.readFullBytes(out,pos,size)

    def close(self):
        if (self.fread is not None):
            self.fread.close()
            self.fread = None

    def get_isDirectory(self):
        if (self.isDirCached is not None):
            return self.isDirCached
        def _hx_local_1():
            def _hx_local_0():
                self.isDirCached = sys_FileSystem.isDirectory(self.file)
                return self.isDirCached
            return _hx_local_0()
        return _hx_local_1()

    def load(self,onReady = None):
        if (onReady is not None):
            haxe_Timer.delay(onReady,1)

    def loadBitmap(self,onLoaded):
        bmp = hxd_res_Image(self).toBitmap()
        this1 = bmp
        onLoaded(this1)

    def get_path(self):
        if (self.relPath is None):
            return "<root>"
        else:
            return self.relPath

    def exists(self,name):
        return self.fs.exists((name if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if name is None else name))))

    def get(self,name):
        return self.fs.get((name if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if name is None else name))))

    def get_size(self):
        return sys_FileSystem.stat(self.file).size

    def iterator(self):
        arr = list()
        _g = 0
        _g1 = sys_FileSystem.readDirectory(self.file)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f1 = f
            if ((f1 == ".svn") or ((f1 == ".git"))):
                if sys_FileSystem.isDirectory(((HxOverrides.stringOrNull(self.file) + "/") + ("null" if f is None else f))):
                    continue
                else:
                    x = self.fs.open((f if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if f is None else f))),False)
                    arr.append(x)
            elif (f1 == ".tmp"):
                if (self == self.fs.root):
                    continue
                else:
                    x1 = self.fs.open((f if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if f is None else f))),False)
                    arr.append(x1)
            else:
                x2 = self.fs.open((f if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if f is None else f))),False)
                arr.append(x2)
        return hxd_impl_ArrayIterator_hxd_fs_FileEntry(arr)

    def getModifTime(self):
        return (sys_FileSystem.stat((self.originalFile if ((self.originalFile is not None)) else self.file)).mtime.date.timestamp() * 1000)

    def watch(self,onChanged):
        _gthis = self
        if (onChanged is None):
            if (self.watchCallback is not None):
                python_internal_ArrayImpl.remove(hxd_fs_LocalEntry.WATCH_LIST,self)
                self.watchCallback = None
            return
        if (self.watchCallback is None):
            if (hxd_fs_LocalEntry.WATCH_LIST is None):
                hxd_fs_LocalEntry.WATCH_LIST = []
                haxe_MainLoop.add(hxd_fs_LocalEntry.checkFiles)
            path = self.get_path()
            _g = 0
            _g1 = hxd_fs_LocalEntry.WATCH_LIST
            while (_g < len(_g1)):
                w = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (w.get_path() == path):
                    w.watchCallback = None
                    python_internal_ArrayImpl.remove(hxd_fs_LocalEntry.WATCH_LIST,w)
            _this = hxd_fs_LocalEntry.WATCH_LIST
            _this.append(self)
        self.watchTime = (sys_FileSystem.stat((self.originalFile if ((self.originalFile is not None)) else self.file)).mtime.date.timestamp() * 1000)
        def _hx_local_1():
            _gthis.fs.convert.run(_gthis)
            onChanged()
        self.watchCallback = _hx_local_1

    @staticmethod
    def checkFiles():
        filesToCheck = Math.ceil((len(hxd_fs_LocalEntry.WATCH_LIST) / 60))
        if (filesToCheck > hxd_fs_LocalFileSystem.FILES_CHECK_MAX):
            filesToCheck = hxd_fs_LocalFileSystem.FILES_CHECK_MAX
        _g = 0
        _g1 = filesToCheck
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            hxd_fs_LocalEntry.checkNext()

    @staticmethod
    def checkNext():
        def _hx_local_2():
            _hx_local_0 = hxd_fs_LocalEntry
            _hx_local_1 = _hx_local_0.WATCH_INDEX
            _hx_local_0.WATCH_INDEX = (_hx_local_1 + 1)
            return _hx_local_1
        w = python_internal_ArrayImpl._get(hxd_fs_LocalEntry.WATCH_LIST, _hx_local_2())
        if (w is None):
            hxd_fs_LocalEntry.WATCH_INDEX = 0
            return
        t = None
        try:
            t = (sys_FileSystem.stat((w.originalFile if ((w.originalFile is not None)) else w.file)).mtime.date.timestamp() * 1000)
        except BaseException as _g:
            None
            return
        if (t == w.watchTime):
            return
        if (hxd_fs_LocalEntry.tmpDir is None):
            hxd_fs_LocalEntry.tmpDir = Sys.getEnv("TEMP")
            if (hxd_fs_LocalEntry.tmpDir is None):
                hxd_fs_LocalEntry.tmpDir = Sys.getEnv("TMPDIR")
            if (hxd_fs_LocalEntry.tmpDir is None):
                hxd_fs_LocalEntry.tmpDir = Sys.getEnv("TMP")
        lockFile = (HxOverrides.stringOrNull(hxd_fs_LocalEntry.tmpDir) + "/")
        _this = w.file
        _this1 = _this.split("/")
        lockFile1 = ((("null" if lockFile is None else lockFile) + HxOverrides.stringOrNull(((None if ((len(_this1) == 0)) else _this1.pop())))) + ".lock")
        if sys_FileSystem.exists(lockFile1):
            return
        if (not w.get_isDirectory()):
            try:
                pass
            except BaseException as _g:
                None
                return
        w.watchTime = t
        w.watchCallback()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fs = None
        _hx_o.relPath = None
        _hx_o.file = None
        _hx_o.originalFile = None
        _hx_o.fread = None
        _hx_o.isDirCached = None
        _hx_o.watchCallback = None
        _hx_o.watchTime = None
hxd_fs_LocalEntry._hx_class = hxd_fs_LocalEntry
_hx_classes["hxd.fs.LocalEntry"] = hxd_fs_LocalEntry


class hxd_fs_LocalFileSystem:
    _hx_class_name = "hxd.fs.LocalFileSystem"
    _hx_is_interface = "False"
    __slots__ = ("root", "fileCache", "baseDir", "convert", "directoryCache")
    _hx_fields = ["root", "fileCache", "baseDir", "convert", "directoryCache"]
    _hx_methods = ["getAbsolutePath", "getRoot", "checkPath", "open", "clearCache", "exists", "get", "dispose", "dir"]
    _hx_statics = ["isWindows", "FILES_CHECK_MAX"]
    _hx_interfaces = [hxd_fs_FileSystem]

    def __init__(self,dir,configuration):
        self.convert = None
        self.root = None
        self.directoryCache = haxe_ds_StringMap()
        self.fileCache = haxe_ds_StringMap()
        self.baseDir = dir
        if (configuration is None):
            configuration = "default"
        pr = Sys.programPath()
        exePath = None
        if (pr is None):
            exePath = None
        else:
            _this = pr.split("\\")
            _this1 = "/".join([python_Boot.toString1(x1,'') for x1 in _this])
            exePath = _this1.split("/")
        if (exePath is not None):
            if (len(exePath) != 0):
                exePath.pop()
        froot = (self.baseDir if ((exePath is None)) else sys_FileSystem.fullPath(((HxOverrides.stringOrNull("/".join([python_Boot.toString1(x1,'') for x1 in exePath])) + "/") + HxOverrides.stringOrNull(self.baseDir))))
        if (((froot is None) or (not sys_FileSystem.exists(froot))) or (not sys_FileSystem.isDirectory(froot))):
            froot = sys_FileSystem.fullPath(self.baseDir)
            if (((froot is None) or (not sys_FileSystem.exists(froot))) or (not sys_FileSystem.isDirectory(froot))):
                raise haxe_Exception.thrown(("Could not find dir " + ("null" if dir is None else dir)))
        _this = froot.split("\\")
        self.baseDir = "/".join([python_Boot.toString1(x1,'') for x1 in _this])
        if (not self.baseDir.endswith("/")):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.baseDir
            _hx_local_0.baseDir = (("null" if _hx_local_1 is None else _hx_local_1) + "/")
            _hx_local_0.baseDir
        self.convert = hxd_fs_FileConverter(self.baseDir,configuration)
        self.root = hxd_fs_LocalEntry(self,"root",None,self.baseDir)

    def getAbsolutePath(self,f):
        def _hx_local_1():
            _hx_local_0 = f
            if (Std.isOfType(_hx_local_0,hxd_fs_LocalEntry) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise "Class cast error"
            return _hx_local_0
        f1 = _hx_local_1()
        return f1.file

    def getRoot(self):
        return self.root

    def checkPath(self,path):
        baseDir = haxe_io_Path(path).dir
        c = self.directoryCache.h.get(baseDir,None)
        isNew = False
        if (c is None):
            isNew = True
            c = haxe_ds_StringMap()
            _g = 0
            _g1 = None
            try:
                _g1 = sys_FileSystem.readDirectory(baseDir)
            except BaseException as _g2:
                None
                _g1 = []
            while (_g < len(_g1)):
                f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.h[f] = True
            self.directoryCache.h[baseDir] = c
        if (not (HxString.substr(path,(len(baseDir) + 1),None) in c.h)):
            if (not isNew):
                self.directoryCache.remove(baseDir)
                return self.checkPath(path)
            return False
        return True

    def open(self,path,check = None):
        if (check is None):
            check = True
        r = self.fileCache.h.get(path,None)
        if (r is not None):
            return r.r
        e = None
        f = sys_FileSystem.fullPath((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path)))
        if (f is None):
            return None
        _this = f.split("\\")
        f = "/".join([python_Boot.toString1(x1,'') for x1 in _this])
        if ((not check) or ((((((not hxd_fs_LocalFileSystem.isWindows) or ((hxd_fs_LocalFileSystem.isWindows and ((f == ((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path))))))))) and sys_FileSystem.exists(f)) and self.checkPath(f)))):
            _this = path.split("/")
            e = hxd_fs_LocalEntry(self,(None if ((len(_this) == 0)) else _this.pop()),path,f)
            self.convert.run(e)
            if (e.file is None):
                e = None
        self.fileCache.h[path] = _hx_AnonObject({'r': e})
        return e

    def clearCache(self):
        path = self.fileCache.keys()
        while path.hasNext():
            path1 = path.next()
            r = self.fileCache.h.get(path1,None)
            if (r.r is None):
                self.fileCache.remove(path1)

    def exists(self,path):
        f = self.open(path)
        return (f is not None)

    def get(self,path):
        f = self.open(path)
        if (f is None):
            raise haxe_Exception.thrown(hxd_fs_NotFound(path))
        return f

    def dispose(self):
        self.fileCache = haxe_ds_StringMap()

    def dir(self,path):
        if ((not sys_FileSystem.exists((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path)))) or (not sys_FileSystem.isDirectory((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path))))):
            raise haxe_Exception.thrown(hxd_fs_NotFound((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path))))
        files = sys_FileSystem.readDirectory((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path)))
        r = []
        _g = 0
        while (_g < len(files)):
            f = (files[_g] if _g >= 0 and _g < len(files) else None)
            _g = (_g + 1)
            x = self.open(((("null" if path is None else path) + "/") + ("null" if f is None else f)),False)
            r.append(x)
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
        _hx_o.fileCache = None
        _hx_o.baseDir = None
        _hx_o.convert = None
        _hx_o.directoryCache = None
hxd_fs_LocalFileSystem._hx_class = hxd_fs_LocalFileSystem
_hx_classes["hxd.fs.LocalFileSystem"] = hxd_fs_LocalFileSystem


class hxd_fs_NotFound:
    _hx_class_name = "hxd.fs.NotFound"
    _hx_is_interface = "False"
    __slots__ = ("path",)
    _hx_fields = ["path"]
    _hx_methods = ["toString"]

    def __init__(self,path):
        self.path = path

    def toString(self):
        return (("Resource file not found '" + HxOverrides.stringOrNull(self.path)) + "'")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.path = None
hxd_fs_NotFound._hx_class = hxd_fs_NotFound
_hx_classes["hxd.fs.NotFound"] = hxd_fs_NotFound


class hxd_impl__Allocator_BufferFlags_Impl_:
    _hx_class_name = "hxd.impl._Allocator.BufferFlags_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["Dynamic", "UniformDynamic", "RawFormat", "RawQuads", "toInt"]

    @staticmethod
    def toInt(this1):
        return this1
hxd_impl__Allocator_BufferFlags_Impl_._hx_class = hxd_impl__Allocator_BufferFlags_Impl_
_hx_classes["hxd.impl._Allocator.BufferFlags_Impl_"] = hxd_impl__Allocator_BufferFlags_Impl_


class hxd_impl_Allocator:
    _hx_class_name = "hxd.impl.Allocator"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["allocBuffer", "ofFloats", "disposeBuffer", "allocIndexBuffer", "ofIndexes", "disposeIndexBuffer", "onContextLost", "allocFloats", "disposeFloats", "allocIndexes", "disposeIndexes"]
    _hx_statics = ["inst", "set", "get"]

    def __init__(self):
        pass

    def allocBuffer(self,vertices,stride,flags):
        tmp = None
        flags1 = flags
        if (flags1 == 0):
            tmp = [h3d_BufferFlag.Dynamic]
        elif (flags1 == 1):
            tmp = [h3d_BufferFlag.UniformBuffer, h3d_BufferFlag.Dynamic]
        elif (flags1 == 2):
            tmp = [h3d_BufferFlag.RawFormat]
        elif (flags1 == 3):
            tmp = [h3d_BufferFlag.Quads, h3d_BufferFlag.RawFormat]
        else:
            pass
        return h3d_Buffer(vertices,stride,tmp)

    def ofFloats(self,v,stride,flags):
        x = (len(v) / stride)
        nvert = None
        try:
            nvert = int(x)
        except BaseException as _g:
            None
            nvert = None
        b = self.allocBuffer(nvert,stride,flags)
        b.uploadVector(v,0,nvert)
        return b

    def disposeBuffer(self,b):
        b.dispose()

    def allocIndexBuffer(self,count):
        return h3d_Indexes(count)

    def ofIndexes(self,ib,length = None):
        if (length is None):
            length = -1
        if ((length < 0) and ((ib is not None))):
            length = len(ib)
        idx = self.allocIndexBuffer(length)
        idx.upload(ib,0,length)
        return idx

    def disposeIndexBuffer(self,i):
        i.dispose()

    def onContextLost(self):
        pass

    def allocFloats(self,count):
        length = count
        if (length is None):
            length = 0
        this1 = list()
        if (length > 0):
            if (length > len(this1)):
                python_internal_ArrayImpl._set(this1, (length - 1), 0.)
        return this1

    def disposeFloats(self,f):
        pass

    def allocIndexes(self,count):
        length = count
        if (length is None):
            length = 0
        this1 = list()
        if (length > 0):
            if (length > len(this1)):
                python_internal_ArrayImpl._set(this1, (length - 1), 0)
        return this1

    def disposeIndexes(self,i):
        pass
    inst = None

    @staticmethod
    def set(a):
        hxd_impl_Allocator.inst = a

    @staticmethod
    def get():
        if (hxd_impl_Allocator.inst is None):
            hxd_impl_Allocator.inst = hxd_impl_Allocator()
        return hxd_impl_Allocator.inst

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_impl_Allocator._hx_class = hxd_impl_Allocator
_hx_classes["hxd.impl.Allocator"] = hxd_impl_Allocator


class hxd_impl_Api:
    _hx_class_name = "hxd.impl.Api"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["downcast", "isOfType"]

    @staticmethod
    def downcast(value,c):
        return Std.downcast(value,c)

    @staticmethod
    def isOfType(v,t):
        return Std.isOfType(v,t)
hxd_impl_Api._hx_class = hxd_impl_Api
_hx_classes["hxd.impl.Api"] = hxd_impl_Api


class hxd_impl_ArrayIterator:
    _hx_class_name = "hxd.impl.ArrayIterator"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator._hx_class = hxd_impl_ArrayIterator
_hx_classes["hxd.impl.ArrayIterator"] = hxd_impl_ArrayIterator


class hxd_impl_ArrayIterator_h2d_Object:
    _hx_class_name = "hxd.impl.ArrayIterator_h2d_Object"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h2d_Object._hx_class = hxd_impl_ArrayIterator_h2d_Object
_hx_classes["hxd.impl.ArrayIterator_h2d_Object"] = hxd_impl_ArrayIterator_h2d_Object


class hxd_impl_ArrayIterator_h2d_col_IPoint:
    _hx_class_name = "hxd.impl.ArrayIterator_h2d_col_IPoint"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h2d_col_IPoint._hx_class = hxd_impl_ArrayIterator_h2d_col_IPoint
_hx_classes["hxd.impl.ArrayIterator_h2d_col_IPoint"] = hxd_impl_ArrayIterator_h2d_col_IPoint


class hxd_impl_ArrayIterator_h2d_col_IPolygon:
    _hx_class_name = "hxd.impl.ArrayIterator_h2d_col_IPolygon"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h2d_col_IPolygon._hx_class = hxd_impl_ArrayIterator_h2d_col_IPolygon
_hx_classes["hxd.impl.ArrayIterator_h2d_col_IPolygon"] = hxd_impl_ArrayIterator_h2d_col_IPolygon


class hxd_impl_ArrayIterator_h2d_col_Point:
    _hx_class_name = "hxd.impl.ArrayIterator_h2d_col_Point"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h2d_col_Point._hx_class = hxd_impl_ArrayIterator_h2d_col_Point
_hx_classes["hxd.impl.ArrayIterator_h2d_col_Point"] = hxd_impl_ArrayIterator_h2d_col_Point


class hxd_impl_ArrayIterator_h2d_col_Polygon:
    _hx_class_name = "hxd.impl.ArrayIterator_h2d_col_Polygon"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h2d_col_Polygon._hx_class = hxd_impl_ArrayIterator_h2d_col_Polygon
_hx_classes["hxd.impl.ArrayIterator_h2d_col_Polygon"] = hxd_impl_ArrayIterator_h2d_col_Polygon


class hxd_impl_ArrayIterator_h2d_col_Segment:
    _hx_class_name = "hxd.impl.ArrayIterator_h2d_col_Segment"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h2d_col_Segment._hx_class = hxd_impl_ArrayIterator_h2d_col_Segment
_hx_classes["hxd.impl.ArrayIterator_h2d_col_Segment"] = hxd_impl_ArrayIterator_h2d_col_Segment


class hxd_impl_ArrayIterator_h3d_scene_Object:
    _hx_class_name = "hxd.impl.ArrayIterator_h3d_scene_Object"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h3d_scene_Object._hx_class = hxd_impl_ArrayIterator_h3d_scene_Object
_hx_classes["hxd.impl.ArrayIterator_h3d_scene_Object"] = hxd_impl_ArrayIterator_h3d_scene_Object


class hxd_impl_ArrayIterator_hxd_fs_FileEntry:
    _hx_class_name = "hxd.impl.ArrayIterator_hxd_fs_FileEntry"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_hxd_fs_FileEntry._hx_class = hxd_impl_ArrayIterator_hxd_fs_FileEntry
_hx_classes["hxd.impl.ArrayIterator_hxd_fs_FileEntry"] = hxd_impl_ArrayIterator_hxd_fs_FileEntry


class hxd_impl_ArrayIterator_hxd_res_Any:
    _hx_class_name = "hxd.impl.ArrayIterator_hxd_res_Any"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_hxd_res_Any._hx_class = hxd_impl_ArrayIterator_hxd_res_Any
_hx_classes["hxd.impl.ArrayIterator_hxd_res_Any"] = hxd_impl_ArrayIterator_hxd_res_Any


class hxd_impl_ArrayIterator_hxd_snd_Channel:
    _hx_class_name = "hxd.impl.ArrayIterator_hxd_snd_Channel"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_hxd_snd_Channel._hx_class = hxd_impl_ArrayIterator_hxd_snd_Channel
_hx_classes["hxd.impl.ArrayIterator_hxd_snd_Channel"] = hxd_impl_ArrayIterator_hxd_snd_Channel


class hxd_impl__UncheckedBytes_UncheckedBytes_Impl_:
    _hx_class_name = "hxd.impl._UncheckedBytes.UncheckedBytes_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get", "set", "fromBytes"]

    @staticmethod
    def _new(v):
        this1 = v
        return this1

    @staticmethod
    def get(this1,i):
        return this1[i]

    @staticmethod
    def set(this1,i,v):
        this1[i] = v
        return v

    @staticmethod
    def fromBytes(b):
        this1 = b.b
        return this1
hxd_impl__UncheckedBytes_UncheckedBytes_Impl_._hx_class = hxd_impl__UncheckedBytes_UncheckedBytes_Impl_
_hx_classes["hxd.impl._UncheckedBytes.UncheckedBytes_Impl_"] = hxd_impl__UncheckedBytes_UncheckedBytes_Impl_


class hxd_res__Any_SingleFileSystem(hxd_fs_BytesFileSystem):
    _hx_class_name = "hxd.res._Any.SingleFileSystem"
    _hx_is_interface = "False"
    __slots__ = ("path", "bytes")
    _hx_fields = ["path", "bytes"]
    _hx_methods = ["getBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fs_BytesFileSystem


    def __init__(self,path,_hx_bytes):
        self.bytes = None
        self.path = None
        super().__init__()
        self.path = path
        self.bytes = _hx_bytes

    def getBytes(self,p):
        if (p == self.path):
            return self.bytes
        else:
            return None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.path = None
        _hx_o.bytes = None
hxd_res__Any_SingleFileSystem._hx_class = hxd_res__Any_SingleFileSystem
_hx_classes["hxd.res._Any.SingleFileSystem"] = hxd_res__Any_SingleFileSystem


class hxd_res_Resource:
    _hx_class_name = "hxd.res.Resource"
    _hx_is_interface = "False"
    __slots__ = ("entry",)
    _hx_fields = ["entry"]
    _hx_methods = ["get_name", "toString", "watch"]
    _hx_statics = ["LIVE_UPDATE"]

    def __init__(self,entry):
        self.entry = entry

    def get_name(self):
        return self.entry.name

    def toString(self):
        return self.entry.get_path()

    def watch(self,onChanged):
        if hxd_res_Resource.LIVE_UPDATE:
            self.entry.watch(onChanged)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.entry = None
hxd_res_Resource._hx_class = hxd_res_Resource
_hx_classes["hxd.res.Resource"] = hxd_res_Resource


class hxd_res_Any(hxd_res_Resource):
    _hx_class_name = "hxd.res.Any"
    _hx_is_interface = "False"
    __slots__ = ("loader",)
    _hx_fields = ["loader"]
    _hx_methods = ["toModel", "toTexture", "toTile", "toText", "toImage", "toSound", "toPrefab", "to", "iterator"]
    _hx_statics = ["fromBytes"]
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,loader,entry):
        self.loader = None
        super().__init__(entry)
        self.loader = loader

    def toModel(self):
        return self.loader.loadCache(self.entry.get_path(),hxd_res_Model)

    def toTexture(self):
        return self.toImage().toTexture()

    def toTile(self):
        return self.toImage().toTile()

    def toText(self):
        return self.entry.getBytes().toString()

    def toImage(self):
        return self.loader.loadCache(self.entry.get_path(),hxd_res_Image)

    def toSound(self):
        return self.loader.loadCache(self.entry.get_path(),hxd_res_Sound)

    def toPrefab(self):
        return self.loader.loadCache(self.entry.get_path(),hxd_res_Resource)

    def to(self,c):
        return self.loader.loadCache(self.entry.get_path(),c)

    def iterator(self):
        _g = []
        _g1 = self.entry.iterator()
        while (_g1.i < _g1.l):
            def _hx_local_1():
                _hx_local_0 = _g1.i
                _g1.i = (_g1.i + 1)
                return _hx_local_0
            f = python_internal_ArrayImpl._get(_g1.a, _hx_local_1())
            x = hxd_res_Any(self.loader,f)
            _g.append(x)
        return hxd_impl_ArrayIterator_hxd_res_Any(_g)

    @staticmethod
    def fromBytes(path,_hx_bytes):
        fs = hxd_res__Any_SingleFileSystem(path,_hx_bytes)
        return hxd_res_Loader(fs).load(path)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.loader = None
hxd_res_Any._hx_class = hxd_res_Any
_hx_classes["hxd.res.Any"] = hxd_res_Any


class hxd_res_BitmapFont(hxd_res_Resource):
    _hx_class_name = "hxd.res.BitmapFont"
    _hx_is_interface = "False"
    __slots__ = ("loader", "font", "sdfFonts")
    _hx_fields = ["loader", "font", "sdfFonts"]
    _hx_methods = ["toFont", "toSdfFont", "resolveSdfTile", "resolveTile"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,entry):
        self.sdfFonts = None
        self.font = None
        self.loader = None
        super().__init__(entry)
        self.loader = hxd_res_Loader.currentInstance

    def toFont(self):
        if (self.font is None):
            self.font = hxd_fmt_bfnt_FontParser.parse(self.entry.getBytes(),self.entry.get_path(),self.resolveTile)
        return self.font

    def toSdfFont(self,size = None,channel = None,alphaCutoff = None,smoothing = None):
        if (channel is None):
            channel = 0
        if (alphaCutoff is None):
            alphaCutoff = 0.5
        if (smoothing is None):
            smoothing = 0.03125
        if (self.sdfFonts is None):
            self.sdfFonts = list()
        if (size is None):
            size = self.toFont().size
        _g = 0
        _g1 = self.sdfFonts
        while (_g < len(_g1)):
            font = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = font.type
            if (_g2.index == 1):
                fchannel = _g2.params[0]
                falphaCutoff = _g2.params[1]
                fsmoothing = _g2.params[2]
                if ((((font.size == size) and ((fchannel == channel))) and ((falphaCutoff == alphaCutoff))) and ((fsmoothing == smoothing))):
                    return font
        font = hxd_fmt_bfnt_FontParser.parse(self.entry.getBytes(),self.entry.get_path(),self.resolveSdfTile)
        font.type = h2d_FontType.SignedDistanceField(channel,alphaCutoff,smoothing)
        font.resizeTo(size)
        _this = self.sdfFonts
        _this.append(font)
        return font

    def resolveSdfTile(self,path):
        tex = self.loader.load(path).toTexture()
        tex.set_filter(h3d_mat_Filter.Linear)
        return h2d_Tile.fromTexture(tex)

    def resolveTile(self,path):
        return self.loader.load(path).toTile()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.loader = None
        _hx_o.font = None
        _hx_o.sdfFonts = None
hxd_res_BitmapFont._hx_class = hxd_res_BitmapFont
_hx_classes["hxd.res.BitmapFont"] = hxd_res_BitmapFont


class hxd_res_Font(hxd_res_Resource):
    _hx_class_name = "hxd.res.Font"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["build"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,entry):
        super().__init__(entry)

    def build(self,size,options = None):
        raise haxe_Exception.thrown("Not implemented for this platform")

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_res_Font._hx_class = hxd_res_Font
_hx_classes["hxd.res.Font"] = hxd_res_Font


class hxd_res__Image_ImageFormat_Impl_:
    _hx_class_name = "hxd.res._Image.ImageFormat_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["Jpg", "Png", "Gif", "Tga", "Dds", "Raw", "Hdr", "get_useAsyncDecode", "toInt"]
    useAsyncDecode = None

    @staticmethod
    def get_useAsyncDecode(this1):
        return (this1 == 0)

    @staticmethod
    def toInt(this1):
        return this1
hxd_res__Image_ImageFormat_Impl_._hx_class = hxd_res__Image_ImageFormat_Impl_
_hx_classes["hxd.res._Image.ImageFormat_Impl_"] = hxd_res__Image_ImageFormat_Impl_

class hxd_res_ImageInfoFlag(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.res.ImageInfoFlag"
    _hx_constructs = ["IsCube", "Dxt10Header"]
hxd_res_ImageInfoFlag.IsCube = hxd_res_ImageInfoFlag("IsCube", 0, ())
hxd_res_ImageInfoFlag.Dxt10Header = hxd_res_ImageInfoFlag("Dxt10Header", 1, ())
hxd_res_ImageInfoFlag._hx_class = hxd_res_ImageInfoFlag
_hx_classes["hxd.res.ImageInfoFlag"] = hxd_res_ImageInfoFlag


class hxd_res_ImageInfo:
    _hx_class_name = "hxd.res.ImageInfo"
    _hx_is_interface = "False"
    __slots__ = ("width", "height", "mipLevels", "flags", "dataFormat", "pixelFormat")
    _hx_fields = ["width", "height", "mipLevels", "flags", "dataFormat", "pixelFormat"]

    def __init__(self):
        self.pixelFormat = None
        self.dataFormat = None
        self.mipLevels = 1
        self.height = 0
        self.width = 0
        this1 = 0
        self.flags = this1

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.mipLevels = None
        _hx_o.flags = None
        _hx_o.dataFormat = None
        _hx_o.pixelFormat = None
hxd_res_ImageInfo._hx_class = hxd_res_ImageInfo
_hx_classes["hxd.res.ImageInfo"] = hxd_res_ImageInfo


class hxd_res_Image(hxd_res_Resource):
    _hx_class_name = "hxd.res.Image"
    _hx_is_interface = "False"
    __slots__ = ("tex", "inf")
    _hx_fields = ["tex", "inf"]
    _hx_methods = ["getFormat", "getPixelFormat", "getSize", "getInfo", "getPixels", "toBitmap", "watchCallb", "loadTexture", "toTexture", "toTile"]
    _hx_statics = ["DEFAULT_FILTER", "DEFAULT_ASYNC", "ENABLE_AUTO_WATCH", "setupTextureFlags"]
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,entry):
        self.inf = None
        self.tex = None
        super().__init__(entry)

    def getFormat(self):
        return self.getInfo().dataFormat

    def getPixelFormat(self):
        return self.getInfo().pixelFormat

    def getSize(self):
        return self.getInfo()

    def getInfo(self):
        if (self.inf is not None):
            return self.inf
        self.inf = hxd_res_ImageInfo()
        f = hxd_fs_FileInput(self.entry)
        head = None
        try:
            head = f.readUInt16()
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof):
                head = 0
            else:
                raise _g
        head1 = head
        if (head1 == 16163):
            self.inf.dataFormat = 6
            while (f.readLine() != ""):
                pass
            _this = f.readLine()
            parts = _this.split(" ")
            self.inf.pixelFormat = hxd_PixelFormat.RGBA32F
            self.inf.height = Std.parseInt((parts[1] if 1 < len(parts) else None))
            self.inf.width = Std.parseInt((parts[3] if 3 < len(parts) else None))
        elif (head1 == 17476):
            self.inf.dataFormat = 4
            f.skip(10)
            self.inf.height = f.readInt32()
            self.inf.width = f.readInt32()
            f.skip(8)
            self.inf.mipLevels = f.readInt32()
            f.skip(48)
            caps = f.readInt32()
            fourCC = f.readInt32()
            bpp = f.readInt32()
            rMask = f.readInt32()
            gMask = f.readInt32()
            bMask = f.readInt32()
            aMask = f.readInt32()
            caps2 = f.readInt32()
            cubes = f.readInt32()
            if (((cubes & 65024)) == 65024):
                _hx_local_0 = self.inf
                _hx_local_1 = _hx_local_0.flags
                _hx_local_0.flags = (_hx_local_1 | ((1 << hxd_res_ImageInfoFlag.IsCube.index)))
                _hx_local_0.flags
            _g = (fourCC & 16777215)
            if (_g == 0):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_2 = self.inf
                    _hx_local_3 = _hx_local_2.flags
                    _hx_local_2.flags = (_hx_local_3 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_2.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                elif (((caps & 64)) != 0):
                    if (bpp == 32):
                        rMask1 = rMask
                        if (rMask1 == 255):
                            if (gMask == 65280):
                                if (bMask == 16711680):
                                    if (aMask == -16777216):
                                        self.inf.pixelFormat = hxd_PixelFormat.RGBA
                                    else:
                                        raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                                else:
                                    raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                            else:
                                raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                        elif (rMask1 == 16711680):
                            if (gMask == 65280):
                                if (bMask == 255):
                                    if (aMask == -16777216):
                                        self.inf.pixelFormat = hxd_PixelFormat.BGRA
                                    else:
                                        raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                                else:
                                    raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                            else:
                                raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                        else:
                            raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                    else:
                        raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
            elif (_g == 111):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_4 = self.inf
                    _hx_local_5 = _hx_local_4.flags
                    _hx_local_4.flags = (_hx_local_5 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_4.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                else:
                    self.inf.pixelFormat = hxd_PixelFormat.R16F
            elif (_g == 112):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_6 = self.inf
                    _hx_local_7 = _hx_local_6.flags
                    _hx_local_6.flags = (_hx_local_7 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_6.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                else:
                    self.inf.pixelFormat = hxd_PixelFormat.RG16F
            elif (_g == 113):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_8 = self.inf
                    _hx_local_9 = _hx_local_8.flags
                    _hx_local_8.flags = (_hx_local_9 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_8.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                else:
                    self.inf.pixelFormat = hxd_PixelFormat.RGBA16F
            elif (_g == 114):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_10 = self.inf
                    _hx_local_11 = _hx_local_10.flags
                    _hx_local_10.flags = (_hx_local_11 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_10.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                else:
                    self.inf.pixelFormat = hxd_PixelFormat.R32F
            elif (_g == 115):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_12 = self.inf
                    _hx_local_13 = _hx_local_12.flags
                    _hx_local_12.flags = (_hx_local_13 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_12.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                else:
                    self.inf.pixelFormat = hxd_PixelFormat.RG32F
            elif (_g == 116):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_14 = self.inf
                    _hx_local_15 = _hx_local_14.flags
                    _hx_local_14.flags = (_hx_local_15 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_14.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                else:
                    self.inf.pixelFormat = hxd_PixelFormat.RGBA32F
            elif (_g == 4805697):
                v = ((HxOverrides.rshift(fourCC, 24)) - 48)
                tmp = None
                v1 = v
                if (v1 == 1):
                    tmp = hxd_PixelFormat.S3TC(4)
                elif (v1 == 2):
                    tmp = hxd_PixelFormat.S3TC(5)
                else:
                    tmp = None
                self.inf.pixelFormat = tmp
            elif (_g == 5527620):
                dxt = ((HxOverrides.rshift(fourCC, 24)) - 48)
                tmp = None
                dxt1 = dxt
                if (dxt1 == 1):
                    tmp = hxd_PixelFormat.S3TC(1)
                elif ((dxt1 == 3) or ((dxt1 == 2))):
                    tmp = hxd_PixelFormat.S3TC(2)
                elif ((dxt1 == 5) or ((dxt1 == 4))):
                    tmp = hxd_PixelFormat.S3TC(3)
                else:
                    tmp = None
                self.inf.pixelFormat = tmp
            elif (fourCC == 808540228):
                f.skip(12)
                _hx_local_16 = self.inf
                _hx_local_17 = _hx_local_16.flags
                _hx_local_16.flags = (_hx_local_17 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                _hx_local_16.flags
                dxgi = f.readInt32()
                tmp = None
                dxgi1 = dxgi
                if (dxgi1 == 95):
                    tmp = hxd_PixelFormat.S3TC(6)
                elif (dxgi1 == 98):
                    tmp = hxd_PixelFormat.S3TC(7)
                else:
                    raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                self.inf.pixelFormat = tmp
            if (self.inf.pixelFormat is None):
                fid = (((HxOverrides.stringOrNull("".join(map(chr,[(fourCC & 255)]))) + HxOverrides.stringOrNull("".join(map(chr,[((fourCC >> 8) & 255)])))) + HxOverrides.stringOrNull("".join(map(chr,[((fourCC >> 16) & 255)])))) + HxOverrides.stringOrNull("".join(map(chr,[HxOverrides.rshift(fourCC, 24)]))))
                if (((fourCC & 255)) == fourCC):
                    fid = ("0x" + Std.string(fourCC))
                raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported 4CC ") + ("null" if fid is None else fid)))
        elif (head1 == 18759):
            self.inf.dataFormat = 2
            self.inf.pixelFormat = hxd_PixelFormat.BGRA
            f.readInt32()
            self.inf.width = f.readUInt16()
            self.inf.height = f.readUInt16()
        elif (head1 == 20617):
            self.inf.dataFormat = 1
            f.set_bigEndian(True)
            f.skip(6)
            while True:
                dataLen = f.readInt32()
                if (f.readInt32() == 1229472850):
                    self.inf.width = f.readInt32()
                    self.inf.height = f.readInt32()
                    colbits = f.readByte()
                    tmp = None
                    colbits1 = colbits
                    if (colbits1 == 8):
                        tmp = hxd_PixelFormat.BGRA
                    elif (colbits1 == 16):
                        tmp = hxd_PixelFormat.R16U
                    elif (colbits1 == 48):
                        tmp = hxd_PixelFormat.RGB16U
                    elif (colbits1 == 64):
                        tmp = hxd_PixelFormat.RGBA16U
                    else:
                        raise haxe_Exception.thrown((((("Unsupported png format " + Std.string(colbits)) + "(") + HxOverrides.stringOrNull(self.entry.get_path())) + ")"))
                    self.inf.pixelFormat = tmp
                    break
                f.skip((dataLen + 4))
        elif (head1 == 55551):
            self.inf.dataFormat = 0
            self.inf.pixelFormat = hxd_PixelFormat.BGRA
            f.set_bigEndian(True)
            while True:
                _g = f.readUInt16()
                if (((_g == 65474) or ((_g == 65473))) or ((_g == 65472))):
                    _hx_len = f.readUInt16()
                    prec = f.readByte()
                    self.inf.height = f.readUInt16()
                    self.inf.width = f.readUInt16()
                    break
                else:
                    f.skip((f.readUInt16() - 2))
        elif (self.entry.get_extension() == "tga"):
            self.inf.dataFormat = 3
            self.inf.pixelFormat = hxd_PixelFormat.ARGB
            f.skip(10)
            self.inf.width = f.readUInt16()
            self.inf.height = f.readUInt16()
        elif (self.entry.get_extension() == "raw"):
            self.inf.dataFormat = 5
            self.inf.pixelFormat = hxd_PixelFormat.R32F
            f1 = (self.entry.get_size() >> 2)
            x = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
            size = None
            try:
                size = int(x)
            except BaseException as _g:
                None
                size = None
            if (self.entry.get_size() != (((size * size) * 4))):
                f1 = (self.entry.get_size() >> 1)
                x = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
                size2 = None
                try:
                    size2 = int(x)
                except BaseException as _g:
                    None
                    size2 = None
                if (self.entry.get_size() == (((size2 * size2) * 2))):
                    self.inf.pixelFormat = hxd_PixelFormat.R16F
                    size = size2
                else:
                    raise haxe_Exception.thrown(((("RAW format does not match 32 bit per components on " + Std.string(size)) + "x") + Std.string(size)))
            def _hx_local_18():
                self.inf.height = size
                return self.inf.height
            self.inf.width = _hx_local_18()
        else:
            raise haxe_Exception.thrown(("Unsupported texture format " + HxOverrides.stringOrNull(self.entry.get_path())))
        f.close()
        if (self.inf.pixelFormat is None):
            raise haxe_Exception.thrown((("Unsupported internal format (" + HxOverrides.stringOrNull(self.entry.get_path())) + ")"))
        return self.inf

    def getPixels(self,fmt = None,flipY = None,index = None):
        pixels = None
        if (index is None):
            index = 0
        _g = self.getInfo().dataFormat
        if (_g == 0):
            _hx_bytes = self.entry.getBytes()
            if (self.inf.pixelFormat != hxd_PixelFormat.BGRA):
                raise haxe_Exception.thrown((((("No support to decode " + Std.string(self.inf.pixelFormat)) + " on this platform (") + HxOverrides.stringOrNull(self.entry.get_path())) + ")"))
            p = None
            try:
                p = hxd_res_NanoJpeg.decode(_hx_bytes)
            except BaseException as _g:
                None
                e = haxe_Exception.caught(_g).unwrap()
                raise haxe_Exception.thrown((((("Failed to decode JPG " + HxOverrides.stringOrNull(self.entry.get_path())) + " (") + Std.string(e)) + ")"))
            pixels = hxd_Pixels(p.width,p.height,p.pixels,hxd_PixelFormat.BGRA)
        elif (_g == 1):
            _hx_bytes = self.entry.getBytes()
            if (self.inf.pixelFormat != hxd_PixelFormat.BGRA):
                raise haxe_Exception.thrown((((("No support to decode " + Std.string(self.inf.pixelFormat)) + " on this platform (") + HxOverrides.stringOrNull(self.entry.get_path())) + ")"))
            png = format_png_Reader(haxe_io_BytesInput(_hx_bytes))
            png.checkCRC = False
            pixels = hxd_Pixels.alloc(self.inf.width,self.inf.height,hxd_PixelFormat.BGRA)
            pdata = png.read()
            format_png_Tools.extract32(pdata,pixels.bytes,flipY)
            if flipY:
                pixels.flags = (pixels.flags | ((1 << hxd_Flags.FlipY.index)))
        elif (_g == 2):
            _hx_bytes = self.entry.getBytes()
            gif = format_gif_Reader(haxe_io_BytesInput(_hx_bytes)).read()
            if (fmt == hxd_PixelFormat.RGBA):
                pixels = hxd_Pixels(self.inf.width,self.inf.height,format_gif_Tools.extractFullRGBA(gif,0),hxd_PixelFormat.RGBA)
            else:
                pixels = hxd_Pixels(self.inf.width,self.inf.height,format_gif_Tools.extractFullBGRA(gif,0),hxd_PixelFormat.BGRA)
        elif (_g == 3):
            _hx_bytes = self.entry.getBytes()
            r = format_tga_Reader(haxe_io_BytesInput(_hx_bytes)).read()
            if ((r.header.imageType != format_tga_ImageType.UncompressedTrueColor) or ((r.header.bitsPerPixel != 32))):
                raise haxe_Exception.thrown(((("Not supported TGA " + Std.string(r.header.imageType)) + "/") + Std.string(r.header.bitsPerPixel)))
            w = r.header.width
            h = r.header.height
            pixels = hxd_Pixels.alloc(w,h,hxd_PixelFormat.ARGB)
            access = hxd__Pixels_PixelsARGB_Impl_.fromPixels(pixels)
            p = 0
            _g = 0
            _g1 = h
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                _g2 = 0
                _g3 = w
                while (_g2 < _g3):
                    x = _g2
                    _g2 = (_g2 + 1)
                    c = r.imageData[(x + ((y * w)))]
                    _this = access.bytes
                    pos = ((((x + ((y * access.width))) << 2)) + access.offset)
                    v = (((HxOverrides.rshift(c, 24) | (((c >> 8) & 65280))) | (((c << 8) & 16711680))) | ((c << 24)))
                    _this.b[pos] = (v & 255)
                    _this.b[(pos + 1)] = ((v >> 8) & 255)
                    _this.b[(pos + 2)] = ((v >> 16) & 255)
                    _this.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)
            tmp = r.header.imageOrigin.index
            if (tmp == 0):
                pixels.flags = (pixels.flags | ((1 << hxd_Flags.FlipY.index)))
            elif (tmp == 2):
                pass
            else:
                raise haxe_Exception.thrown(("Not supported " + Std.string(r.header.imageOrigin)))
        elif (_g == 4):
            pos = 128
            mipLevel = 0
            if (((self.inf.flags & ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))) != 0):
                pos = (pos + 20)
            if (index > 0):
                bpp = hxd_Pixels.calcStride(1,self.inf.pixelFormat)
                x = (index / self.inf.mipLevels)
                layer = None
                try:
                    layer = int(x)
                except BaseException as _g:
                    None
                    layer = None
                mipLevel = HxOverrides.mod(index, self.inf.mipLevels)
                totSize = 0
                _g = 0
                _g1 = self.inf.mipLevels
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    w = (self.inf.width >> i)
                    h = (self.inf.height >> i)
                    if (w == 0):
                        w = 1
                    if (h == 0):
                        h = 1
                    size = hxd_Pixels.calcDataSize(w,h,self.inf.pixelFormat)
                    totSize = (totSize + size)
                    if (i < mipLevel):
                        pos = (pos + size)
                    elif (layer == 0):
                        break
                pos = (pos + ((totSize * layer)))
            _hx_bytes = None
            w = (self.inf.width >> mipLevel)
            h = (self.inf.height >> mipLevel)
            if (w == 0):
                w = 1
            if (h == 0):
                h = 1
            if ((self.inf.mipLevels == 1) and ((((self.inf.flags & ((1 << hxd_res_ImageInfoFlag.IsCube.index)))) == 0))):
                _hx_bytes = self.entry.getBytes()
            else:
                size = hxd_Pixels.calcDataSize(w,h,self.inf.pixelFormat)
                self.entry.open()
                self.entry.skip(pos)
                _hx_bytes = haxe_io_Bytes.alloc(size)
                self.entry.read(_hx_bytes,0,size)
                self.entry.close()
                pos = 0
            pixels = hxd_Pixels(w,h,_hx_bytes,self.inf.pixelFormat,pos)
        elif (_g == 5):
            _hx_bytes = self.entry.getBytes()
            pixels = hxd_Pixels(self.inf.width,self.inf.height,_hx_bytes,self.inf.pixelFormat)
        elif (_g == 6):
            data = hxd_fmt_hdr_Reader.decode(self.entry.getBytes(),False)
            pixels = hxd_Pixels(data.width,data.height,data.bytes,self.inf.pixelFormat)
        else:
            pass
        if (fmt is not None):
            pixels.convert(fmt)
        if (flipY is not None):
            pixels.setFlip(flipY)
        return pixels

    def toBitmap(self):
        self.getInfo()
        bmp = hxd_BitmapData(self.inf.width,self.inf.height)
        pixels = self.getPixels()
        bmp.setPixels(pixels)
        pixels.dispose()
        return bmp

    def watchCallb(self):
        w = self.inf.width
        h = self.inf.height
        self.inf = None
        s = self.getInfo()
        if ((w != s.width) or ((h != s.height))):
            self.tex.resize(s.width,s.height)
        self.tex.realloc = None
        self.loadTexture()

    def loadTexture(self):
        _gthis = self
        if ((self.getInfo().dataFormat != 0) and (not hxd_res_Image.DEFAULT_ASYNC)):
            def _hx_local_0():
                _gthis.tex.alloc()
                _g = 0
                _g1 = _gthis.tex.get_layerCount()
                while (_g < _g1):
                    layer = _g
                    _g = (_g + 1)
                    _g2 = 0
                    _g3 = _gthis.inf.mipLevels
                    while (_g2 < _g3):
                        mip = _g2
                        _g2 = (_g2 + 1)
                        pixels = _gthis.getPixels(_gthis.tex.format,None,((layer * _gthis.inf.mipLevels) + mip))
                        _gthis.tex.uploadPixels(pixels,mip,layer)
                        pixels.dispose()
                _gthis.tex.realloc = _gthis.loadTexture
                if hxd_res_Image.ENABLE_AUTO_WATCH:
                    _gthis.watch(_gthis.watchCallb)
            load = _hx_local_0
            if self.entry.get_isAvailable():
                load()
            else:
                self.entry.load(load)
        else:
            _hx_local_1 = self.tex
            _hx_local_2 = _hx_local_1.flags
            _hx_local_1.flags = (_hx_local_2 | ((1 << h3d_mat_TextureFlags.Loading.index)))
            _hx_local_1.flags
            def _hx_local_6(bmp):
                bmp1 = hxd_fs__LoadedBitmap_LoadedBitmap_Impl_.toBitmap(bmp)
                _gthis.tex.alloc()
                _gthis.tex.uploadBitmap(bmp1)
                bmp1.data = None
                _gthis.tex.realloc = _gthis.loadTexture
                _hx_local_3 = _gthis.tex
                _hx_local_4 = _hx_local_3.flags
                _hx_local_3.flags = (_hx_local_4 & ((-1 - ((1 << h3d_mat_TextureFlags.Loading.index)))))
                _hx_local_3.flags
                if (_gthis.tex.waitLoads is not None):
                    arr = _gthis.tex.waitLoads
                    _gthis.tex.waitLoads = None
                    _g = 0
                    while (_g < len(arr)):
                        f = (arr[_g] if _g >= 0 and _g < len(arr) else None)
                        _g = (_g + 1)
                        f()
                if hxd_res_Image.ENABLE_AUTO_WATCH:
                    _gthis.watch(_gthis.watchCallb)
            self.entry.loadBitmap(_hx_local_6)

    def toTexture(self):
        if (self.tex is not None):
            return self.tex
        self.getInfo()
        flags = [h3d_mat_TextureFlags.NoAlloc]
        fmt = self.inf.pixelFormat
        if (((fmt == hxd_PixelFormat.BGRA) or ((fmt == hxd_PixelFormat.ARGB))) or ((fmt == hxd_PixelFormat.RGBA))):
            fmt = h3d_mat_Texture.nativeFormat
        if (((self.inf.flags & ((1 << hxd_res_ImageInfoFlag.IsCube.index)))) != 0):
            flags.append(h3d_mat_TextureFlags.Cube)
        if (self.inf.mipLevels > 1):
            flags.append(h3d_mat_TextureFlags.MipMapped)
            flags.append(h3d_mat_TextureFlags.ManualMipMapGen)
        if (fmt == hxd_PixelFormat.R16U):
            raise haxe_Exception.thrown(((("Unsupported texture format " + Std.string(fmt)) + " for ") + HxOverrides.stringOrNull(self.entry.get_path())))
        self.tex = h3d_mat_Texture(self.inf.width,self.inf.height,flags,fmt)
        if (hxd_res_Image.DEFAULT_FILTER != h3d_mat_Filter.Linear):
            self.tex.set_filter(hxd_res_Image.DEFAULT_FILTER)
        self.tex.setName(self.entry.get_path())
        hxd_res_Image.setupTextureFlags(self.tex)
        self.loadTexture()
        return self.tex

    def toTile(self):
        self.getInfo()
        return h2d_Tile.fromTexture(self.toTexture()).sub(0,0,self.inf.width,self.inf.height)

    @staticmethod
    def setupTextureFlags(tex):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tex = None
        _hx_o.inf = None
hxd_res_Image._hx_class = hxd_res_Image
_hx_classes["hxd.res.Image"] = hxd_res_Image


class hxd_res_Loader:
    _hx_class_name = "hxd.res.Loader"
    _hx_is_interface = "False"
    __slots__ = ("fs", "cache")
    _hx_fields = ["fs", "cache"]
    _hx_methods = ["cleanCache", "dir", "exists", "load", "loadCache", "dispose"]
    _hx_statics = ["currentInstance"]

    def __init__(self,fs):
        self.fs = fs
        self.cache = haxe_ds_StringMap()

    def cleanCache(self):
        self.cache = haxe_ds_StringMap()

    def dir(self,path):
        r = []
        entries = self.fs.dir(path)
        _g = 0
        while (_g < len(entries)):
            e = (entries[_g] if _g >= 0 and _g < len(entries) else None)
            _g = (_g + 1)
            x = hxd_res_Any(self,e)
            r.append(x)
        return r

    def exists(self,path):
        return self.fs.exists(path)

    def load(self,path):
        return hxd_res_Any(self,self.fs.get(path))

    def loadCache(self,path,c):
        res = self.cache.h.get(path,None)
        if (res is None):
            entry = self.fs.get(path)
            old = hxd_res_Loader.currentInstance
            hxd_res_Loader.currentInstance = self
            res = c(*[entry])
            hxd_res_Loader.currentInstance = old
            self.cache.h[path] = res
        elif (Std.downcast(res,c) is None):
            raise haxe_Exception.thrown(((((("null" if path is None else path) + " has been reintrepreted from ") + Std.string(Type.getClass(res))) + " to ") + Std.string(c)))
        return res

    def dispose(self):
        self.cleanCache()
        self.fs.dispose()
    currentInstance = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fs = None
        _hx_o.cache = None
hxd_res_Loader._hx_class = hxd_res_Loader
_hx_classes["hxd.res.Loader"] = hxd_res_Loader


class hxd_res_Model(hxd_res_Resource):
    _hx_class_name = "hxd.res.Model"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["toHmd"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,entry):
        super().__init__(entry)

    def toHmd(self):
        fs = hxd_fs_FileInput(self.entry)
        hmd = hxd_fmt_hmd_Reader(fs).readHeader()
        fs.close()
        return hxd_fmt_hmd_Library(self,hmd)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_res_Model._hx_class = hxd_res_Model
_hx_classes["hxd.res.Model"] = hxd_res_Model

class hxd_res_Filter(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.res.Filter"
    _hx_constructs = ["Fast", "Chromatic"]
hxd_res_Filter.Fast = hxd_res_Filter("Fast", 0, ())
hxd_res_Filter.Chromatic = hxd_res_Filter("Chromatic", 1, ())
hxd_res_Filter._hx_class = hxd_res_Filter
_hx_classes["hxd.res.Filter"] = hxd_res_Filter


class hxd_res__NanoJpeg_FastBytes_Impl_:
    _hx_class_name = "hxd.res._NanoJpeg.FastBytes_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get", "set"]

    @staticmethod
    def _new(b):
        this1 = b
        return this1

    @staticmethod
    def get(this1,i):
        return this1.b[i]

    @staticmethod
    def set(this1,i,v):
        this1.b[i] = (v & 255)
hxd_res__NanoJpeg_FastBytes_Impl_._hx_class = hxd_res__NanoJpeg_FastBytes_Impl_
_hx_classes["hxd.res._NanoJpeg.FastBytes_Impl_"] = hxd_res__NanoJpeg_FastBytes_Impl_


class hxd_res__NanoJpeg_Component:
    _hx_class_name = "hxd.res._NanoJpeg.Component"
    _hx_is_interface = "False"
    __slots__ = ("cid", "ssx", "ssy", "width", "height", "stride", "qtsel", "actabsel", "dctabsel", "dcpred", "pixels")
    _hx_fields = ["cid", "ssx", "ssy", "width", "height", "stride", "qtsel", "actabsel", "dctabsel", "dcpred", "pixels"]

    def __init__(self):
        self.pixels = None
        self.dcpred = None
        self.dctabsel = None
        self.actabsel = None
        self.qtsel = None
        self.stride = None
        self.height = None
        self.width = None
        self.ssy = None
        self.ssx = None
        self.cid = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cid = None
        _hx_o.ssx = None
        _hx_o.ssy = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.stride = None
        _hx_o.qtsel = None
        _hx_o.actabsel = None
        _hx_o.dctabsel = None
        _hx_o.dcpred = None
        _hx_o.pixels = None
hxd_res__NanoJpeg_Component._hx_class = hxd_res__NanoJpeg_Component
_hx_classes["hxd.res._NanoJpeg.Component"] = hxd_res__NanoJpeg_Component


class hxd_res_NanoJpeg:
    _hx_class_name = "hxd.res.NanoJpeg"
    _hx_is_interface = "False"
    __slots__ = ("bytes", "pos", "size", "length", "width", "height", "ncomp", "comps", "counts", "qtab", "qtused", "qtavail", "vlctab", "block", "njZZ", "progressive", "mbsizex", "mbsizey", "mbwidth", "mbheight", "rstinterval", "buf", "bufbits", "pixels", "filter", "vlcCode")
    _hx_fields = ["bytes", "pos", "size", "length", "width", "height", "ncomp", "comps", "counts", "qtab", "qtused", "qtavail", "vlctab", "block", "njZZ", "progressive", "mbsizex", "mbsizey", "mbwidth", "mbheight", "rstinterval", "buf", "bufbits", "pixels", "filter", "vlcCode"]
    _hx_methods = ["alloc", "free", "njInit", "cleanup", "njSkip", "syntax", "get", "njDecode16", "njByteAlign", "njShowBits", "njSkipBits", "njGetBits", "njDecodeLength", "njSkipMarker", "njDecodeSOF", "njDecodeDQT", "njDecodeDHT", "njDecodeDRI", "njGetVLC", "njRowIDCT", "njColIDCT", "njDecodeBlock", "notSupported", "njDecodeScan", "njUpsampleH", "njUpsampleV", "njUpsample", "njConvert", "njDecode"]
    _hx_statics = ["BLOCKSIZE", "W1", "W2", "W3", "W5", "W6", "W7", "CF4A", "CF4B", "CF4C", "CF4D", "CF3A", "CF3B", "CF3C", "CF3X", "CF3Y", "CF3Z", "CF2A", "CF2B", "CF", "njClip", "inst", "decode"]

    def __init__(self):
        self.vlcCode = None
        self.filter = None
        self.pixels = None
        self.bufbits = None
        self.buf = None
        self.rstinterval = None
        self.mbheight = None
        self.mbwidth = None
        self.mbsizey = None
        self.mbsizex = None
        self.progressive = None
        self.qtavail = None
        self.qtused = None
        self.ncomp = None
        self.height = None
        self.width = None
        self.length = None
        self.size = None
        self.pos = None
        self.bytes = None
        self.comps = list([hxd_res__NanoJpeg_Component(), hxd_res__NanoJpeg_Component(), hxd_res__NanoJpeg_Component()])
        this1 = [None]*64
        this2 = [None]*64
        this3 = [None]*64
        this4 = [None]*64
        self.qtab = list([this1, this2, this3, this4])
        this1 = [None]*16
        self.counts = this1
        this1 = [None]*64
        self.block = this1
        self.njZZ = list([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63])
        self.vlctab = list([None, None, None, None, None, None, None, None])

    def alloc(self,nbytes):
        return haxe_io_Bytes.alloc(nbytes)

    def free(self,_hx_bytes):
        pass

    def njInit(self,_hx_bytes,pos,size,_hx_filter):
        self.bytes = _hx_bytes
        self.pos = pos
        self.filter = (hxd_res_Filter.Chromatic if ((_hx_filter is None)) else _hx_filter)
        if (size < 0):
            size = (_hx_bytes.length - pos)
        if (self.vlctab[0] is None):
            this1 = self.vlctab
            val = haxe_io_Bytes.alloc(131072)
            this1[0] = val
        if (self.vlctab[1] is None):
            this1 = self.vlctab
            val = haxe_io_Bytes.alloc(131072)
            this1[1] = val
        if (self.vlctab[2] is None):
            this1 = self.vlctab
            val = haxe_io_Bytes.alloc(131072)
            this1[2] = val
        if (self.vlctab[3] is None):
            this1 = self.vlctab
            val = haxe_io_Bytes.alloc(131072)
            this1[3] = val
        self.size = size
        self.qtused = 0
        self.qtavail = 0
        self.rstinterval = 0
        self.length = 0
        self.buf = 0
        self.bufbits = 0
        self.progressive = False
        self.comps[0].dcpred = 0
        self.comps[1].dcpred = 0
        self.comps[2].dcpred = 0

    def cleanup(self):
        self.bytes = None
        _g = 0
        _g1 = self.comps
        while (_g < len(_g1)):
            c = _g1[_g]
            _g = (_g + 1)
            if (c.pixels is not None):
                c.pixels = None
        if (self.vlctab[0] is not None):
            _hx_bytes = self.vlctab[0]
            val = None
            self.vlctab[0] = val
        if (self.vlctab[1] is not None):
            _hx_bytes = self.vlctab[1]
            val = None
            self.vlctab[1] = val
        if (self.vlctab[2] is not None):
            _hx_bytes = self.vlctab[2]
            val = None
            self.vlctab[2] = val
        if (self.vlctab[3] is not None):
            _hx_bytes = self.vlctab[3]
            val = None
            self.vlctab[3] = val
        if (self.vlctab[4] is not None):
            _hx_bytes = self.vlctab[4]
            val = None
            self.vlctab[4] = val
        if (self.vlctab[5] is not None):
            _hx_bytes = self.vlctab[5]
            val = None
            self.vlctab[5] = val
        if (self.vlctab[6] is not None):
            _hx_bytes = self.vlctab[6]
            val = None
            self.vlctab[6] = val
        if (self.vlctab[7] is not None):
            _hx_bytes = self.vlctab[7]
            val = None
            self.vlctab[7] = val

    def njSkip(self,count):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + count)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - count)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - count)
        _hx_local_4.length

    def syntax(self,flag):
        pass

    def get(self,p):
        return self.bytes.b[(self.pos + p)]

    def njDecode16(self,p):
        return ((self.bytes.b[(self.pos + p)] << 8) | self.bytes.b[(self.pos + ((p + 1)))])

    def njByteAlign(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 & 248)
        _hx_local_0.bufbits

    def njShowBits(self,bits):
        if (bits == 0):
            return 0
        while (self.bufbits < bits):
            if (self.size <= 0):
                self.buf = ((self.buf << 8) | 255)
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.bufbits
                _hx_local_0.bufbits = (_hx_local_1 + 8)
                _hx_local_0.bufbits
                continue
            newbyte = self.bytes.b[self.pos]
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 1)
            _hx_local_3
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.size
            _hx_local_4.size = (_hx_local_5 - 1)
            _hx_local_5
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.bufbits
            _hx_local_6.bufbits = (_hx_local_7 + 8)
            _hx_local_6.bufbits
            self.buf = ((self.buf << 8) | newbyte)
            if (newbyte == 255):
                marker = self.bytes.b[self.pos]
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.pos
                _hx_local_8.pos = (_hx_local_9 + 1)
                _hx_local_9
                _hx_local_10 = self
                _hx_local_11 = _hx_local_10.size
                _hx_local_10.size = (_hx_local_11 - 1)
                _hx_local_11
                marker1 = marker
                if (marker1 == 217):
                    self.size = 0
                elif ((marker1 == 255) or ((marker1 == 0))):
                    pass
                else:
                    self.buf = ((self.buf << 8) | marker)
                    _hx_local_12 = self
                    _hx_local_13 = _hx_local_12.bufbits
                    _hx_local_12.bufbits = (_hx_local_13 + 8)
                    _hx_local_12.bufbits
        return ((self.buf >> ((self.bufbits - bits))) & ((((1 << bits)) - 1)))

    def njSkipBits(self,bits):
        if (self.bufbits < bits):
            self.njShowBits(bits)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 - bits)
        _hx_local_0.bufbits

    def njGetBits(self,bits):
        r = self.njShowBits(bits)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 - bits)
        _hx_local_0.bufbits
        return r

    def njDecodeLength(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length

    def njSkipMarker(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        count = self.length
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.pos
        _hx_local_6.pos = (_hx_local_7 + count)
        _hx_local_6.pos
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.size
        _hx_local_8.size = (_hx_local_9 - count)
        _hx_local_8.size
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.length
        _hx_local_10.length = (_hx_local_11 - count)
        _hx_local_10.length

    def njDecodeSOF(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        if (self.bytes.b[self.pos] != 8):
            self.notSupported()
        self.height = ((self.bytes.b[(self.pos + 1)] << 8) | self.bytes.b[(self.pos + 2)])
        self.width = ((self.bytes.b[(self.pos + 3)] << 8) | self.bytes.b[(self.pos + 4)])
        self.ncomp = self.bytes.b[(self.pos + 5)]
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.pos
        _hx_local_6.pos = (_hx_local_7 + 6)
        _hx_local_6.pos
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.size
        _hx_local_8.size = (_hx_local_9 - 6)
        _hx_local_8.size
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.length
        _hx_local_10.length = (_hx_local_11 - 6)
        _hx_local_10.length
        _g = self.ncomp
        if ((_g == 3) or ((_g == 1))):
            pass
        else:
            self.notSupported()
        ssxmax = 0
        ssymax = 0
        _g = 0
        _g1 = self.ncomp
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.comps[i]
            c.cid = self.bytes.b[self.pos]
            c.ssx = (self.bytes.b[(self.pos + 1)] >> 4)
            if (((c.ssx & ((c.ssx - 1)))) != 0):
                self.notSupported()
            c.ssy = (self.bytes.b[(self.pos + 1)] & 15)
            if (((c.ssy & ((c.ssy - 1)))) != 0):
                self.notSupported()
            c.qtsel = self.bytes.b[(self.pos + 2)]
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + 3)
            _hx_local_12.pos
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.size
            _hx_local_14.size = (_hx_local_15 - 3)
            _hx_local_14.size
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.length
            _hx_local_16.length = (_hx_local_17 - 3)
            _hx_local_16.length
            _hx_local_18 = self
            _hx_local_19 = _hx_local_18.qtused
            _hx_local_18.qtused = (_hx_local_19 | ((1 << c.qtsel)))
            _hx_local_18.qtused
            if (c.ssx > ssxmax):
                ssxmax = c.ssx
            if (c.ssy > ssymax):
                ssymax = c.ssy
        if (self.ncomp == 1):
            c = self.comps[0]
            ssymax = 1
            ssxmax = ssymax
            def _hx_local_20():
                c.ssy = ssxmax
                return c.ssy
            c.ssx = _hx_local_20()
        self.mbsizex = (ssxmax << 3)
        self.mbsizey = (ssymax << 3)
        x = ((((self.width + self.mbsizex) - 1)) / self.mbsizex)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        self.mbwidth = tmp
        x = ((((self.height + self.mbsizey) - 1)) / self.mbsizey)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        self.mbheight = tmp
        _g = 0
        _g1 = self.ncomp
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.comps[i]
            x = (((((self.width * c.ssx) + ssxmax) - 1)) / ssxmax)
            tmp = None
            try:
                tmp = int(x)
            except BaseException as _g2:
                None
                tmp = None
            c.width = tmp
            c.stride = ((c.width + 7) & 2147483640)
            x1 = (((((self.height * c.ssy) + ssymax) - 1)) / ssymax)
            tmp1 = None
            try:
                tmp1 = int(x1)
            except BaseException as _g3:
                None
                tmp1 = None
            c.height = tmp1
            x2 = (((self.mbwidth * self.mbsizex) * c.ssx) / ssxmax)
            tmp2 = None
            try:
                tmp2 = int(x2)
            except BaseException as _g4:
                None
                tmp2 = None
            c.stride = tmp2
            if (((c.width < 3) and ((c.ssx != ssxmax))) or (((c.height < 3) and ((c.ssy != ssymax))))):
                self.notSupported()
            c1 = c.stride
            x3 = (((self.mbheight * self.mbsizey) * c.ssy) / ssymax)
            nbytes = None
            try:
                nbytes = int(x3)
            except BaseException as _g5:
                None
                nbytes = None
            c.pixels = haxe_io_Bytes.alloc((c1 * nbytes))
        count = self.length
        _hx_local_21 = self
        _hx_local_22 = _hx_local_21.pos
        _hx_local_21.pos = (_hx_local_22 + count)
        _hx_local_21.pos
        _hx_local_23 = self
        _hx_local_24 = _hx_local_23.size
        _hx_local_23.size = (_hx_local_24 - count)
        _hx_local_23.size
        _hx_local_25 = self
        _hx_local_26 = _hx_local_25.length
        _hx_local_25.length = (_hx_local_26 - count)
        _hx_local_25.length

    def njDecodeDQT(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        while (self.length >= 65):
            i = self.bytes.b[self.pos]
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.qtavail
            _hx_local_6.qtavail = (_hx_local_7 | ((1 << i)))
            _hx_local_6.qtavail
            t = self.qtab[i]
            _g = 0
            while (_g < 64):
                k = _g
                _g = (_g + 1)
                val = self.bytes.b[(self.pos + ((k + 1)))]
                t[k] = val
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.pos
            _hx_local_8.pos = (_hx_local_9 + 65)
            _hx_local_8.pos
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.size
            _hx_local_10.size = (_hx_local_11 - 65)
            _hx_local_10.size
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.length
            _hx_local_12.length = (_hx_local_13 - 65)
            _hx_local_12.length

    def njDecodeDHT(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        while (self.length >= 17):
            i = self.bytes.b[self.pos]
            i = (((i >> 4) & 1) | ((((i & 3)) << 1)))
            this1 = self.counts
            val = self.bytes.b[(self.pos + 1)]
            this1[0] = val
            this2 = self.counts
            val1 = self.bytes.b[(self.pos + 2)]
            this2[1] = val1
            this3 = self.counts
            val2 = self.bytes.b[(self.pos + 3)]
            this3[2] = val2
            this4 = self.counts
            val3 = self.bytes.b[(self.pos + 4)]
            this4[3] = val3
            this5 = self.counts
            val4 = self.bytes.b[(self.pos + 5)]
            this5[4] = val4
            this6 = self.counts
            val5 = self.bytes.b[(self.pos + 6)]
            this6[5] = val5
            this7 = self.counts
            val6 = self.bytes.b[(self.pos + 7)]
            this7[6] = val6
            this8 = self.counts
            val7 = self.bytes.b[(self.pos + 8)]
            this8[7] = val7
            this9 = self.counts
            val8 = self.bytes.b[(self.pos + 9)]
            this9[8] = val8
            this10 = self.counts
            val9 = self.bytes.b[(self.pos + 10)]
            this10[9] = val9
            this11 = self.counts
            val10 = self.bytes.b[(self.pos + 11)]
            this11[10] = val10
            this12 = self.counts
            val11 = self.bytes.b[(self.pos + 12)]
            this12[11] = val11
            this13 = self.counts
            val12 = self.bytes.b[(self.pos + 13)]
            this13[12] = val12
            this14 = self.counts
            val13 = self.bytes.b[(self.pos + 14)]
            this14[13] = val13
            this15 = self.counts
            val14 = self.bytes.b[(self.pos + 15)]
            this15[14] = val14
            this16 = self.counts
            val15 = self.bytes.b[(self.pos + 16)]
            this16[15] = val15
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 17)
            _hx_local_6.pos
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.size
            _hx_local_8.size = (_hx_local_9 - 17)
            _hx_local_8.size
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.length
            _hx_local_10.length = (_hx_local_11 - 17)
            _hx_local_10.length
            vlc = self.vlctab[i]
            vpos = 0
            remain = 65536
            spread = 65536
            _g = 1
            while (_g < 17):
                codelen = _g
                _g = (_g + 1)
                spread = (spread >> 1)
                currcnt = self.counts[(codelen - 1)]
                if (currcnt == 0):
                    continue
                remain = (remain - ((currcnt << ((16 - codelen)))))
                _g1 = 0
                _g2 = currcnt
                while (_g1 < _g2):
                    i1 = _g1
                    _g1 = (_g1 + 1)
                    code = self.bytes.b[(self.pos + i1)]
                    _g3 = 0
                    _g4 = spread
                    while (_g3 < _g4):
                        j = _g3
                        _g3 = (_g3 + 1)
                        pos = vpos
                        vpos = (vpos + 1)
                        vlc.b[pos] = (codelen & 255)
                        pos1 = vpos
                        vpos = (vpos + 1)
                        vlc.b[pos1] = (code & 255)
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.pos
                _hx_local_14.pos = (_hx_local_15 + currcnt)
                _hx_local_14.pos
                _hx_local_16 = self
                _hx_local_17 = _hx_local_16.size
                _hx_local_16.size = (_hx_local_17 - currcnt)
                _hx_local_16.size
                _hx_local_18 = self
                _hx_local_19 = _hx_local_18.length
                _hx_local_18.length = (_hx_local_19 - currcnt)
                _hx_local_18.length
            while True:
                tmp = remain
                remain = (remain - 1)
                if (not ((tmp != 0))):
                    break
                vlc.b[vpos] = 0
                vpos = (vpos + 2)

    def njDecodeDRI(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        self.rstinterval = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        count = self.length
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.pos
        _hx_local_6.pos = (_hx_local_7 + count)
        _hx_local_6.pos
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.size
        _hx_local_8.size = (_hx_local_9 - count)
        _hx_local_8.size
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.length
        _hx_local_10.length = (_hx_local_11 - count)
        _hx_local_10.length

    def njGetVLC(self,vlc):
        value = self.njShowBits(16)
        bits = vlc.b[(value << 1)]
        if (self.bufbits < bits):
            self.njShowBits(bits)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 - bits)
        _hx_local_0.bufbits
        value = vlc.b[((value << 1) | 1)]
        self.vlcCode = value
        bits = (value & 15)
        if (bits == 0):
            return 0
        r = self.njShowBits(bits)
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.bufbits
        _hx_local_2.bufbits = (_hx_local_3 - bits)
        _hx_local_2.bufbits
        value = r
        if (value < ((1 << ((bits - 1))))):
            value = (value + ((((-1 << bits)) + 1)))
        return value

    def njRowIDCT(self,bp):
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
            return
        x0 = (((self.block[bp] << 11)) + 128)
        x8 = (565 * ((x4 + x5)))
        x4 = (x8 + ((2276 * x4)))
        x5 = (x8 - ((3406 * x5)))
        x8 = (2408 * ((x6 + x7)))
        x6 = (x8 - ((799 * x6)))
        x7 = (x8 - ((4017 * x7)))
        x8 = (x0 + x1)
        x0 = (x0 - x1)
        x1 = (1108 * ((x3 + x2)))
        x2 = (x1 - ((3784 * x2)))
        x3 = (x1 + ((1568 * x3)))
        x1 = (x4 + x6)
        x4 = (x4 - x6)
        x6 = (x5 + x7)
        x5 = (x5 - x7)
        x7 = (x8 + x3)
        x8 = (x8 - x3)
        x3 = (x0 + x2)
        x0 = (x0 - x2)
        x2 = (((181 * ((x4 + x5))) + 128) >> 8)
        x4 = (((181 * ((x4 - x5))) + 128) >> 8)
        val = ((x7 + x1) >> 8)
        self.block[bp] = val
        val = ((x3 + x2) >> 8)
        self.block[(bp + 1)] = val
        val = ((x0 + x4) >> 8)
        self.block[(bp + 2)] = val
        val = ((x8 + x6) >> 8)
        self.block[(bp + 3)] = val
        val = ((x8 - x6) >> 8)
        self.block[(bp + 4)] = val
        val = ((x0 - x4) >> 8)
        self.block[(bp + 5)] = val
        val = ((x3 - x2) >> 8)
        self.block[(bp + 6)] = val
        val = ((x7 - x1) >> 8)
        self.block[(bp + 7)] = val

    def njColIDCT(self,bp,out,po,stride):
        x1 = (self.block[(bp + 32)] << 8)
        x2 = self.block[(bp + 48)]
        x3 = self.block[(bp + 16)]
        x4 = self.block[(bp + 8)]
        x5 = self.block[(bp + 56)]
        x6 = self.block[(bp + 40)]
        x7 = self.block[(bp + 24)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[bp] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            return
        x0 = (((self.block[bp] << 8)) + 8192)
        x8 = ((565 * ((x4 + x5))) + 4)
        x4 = ((x8 + ((2276 * x4))) >> 3)
        x5 = ((x8 - ((3406 * x5))) >> 3)
        x8 = ((2408 * ((x6 + x7))) + 4)
        x6 = ((x8 - ((799 * x6))) >> 3)
        x7 = ((x8 - ((4017 * x7))) >> 3)
        x8 = (x0 + x1)
        x0 = (x0 - x1)
        x1 = ((1108 * ((x3 + x2))) + 4)
        x2 = ((x1 - ((3784 * x2))) >> 3)
        x3 = ((x1 + ((1568 * x3))) >> 3)
        x1 = (x4 + x6)
        x4 = (x4 - x6)
        x6 = (x5 + x7)
        x5 = (x5 - x7)
        x7 = (x8 + x3)
        x8 = (x8 - x3)
        x3 = (x0 + x2)
        x0 = (x0 - x2)
        x2 = (((181 * ((x4 + x5))) + 128) >> 8)
        x4 = (((181 * ((x4 - x5))) + 128) >> 8)
        x = ((((x7 + x1) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x3 + x2) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x0 + x4) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x8 + x6) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x8 - x6) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x0 - x4) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x3 - x2) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x7 - x1) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)

    def njDecodeBlock(self,c,po):
        this1 = c.pixels
        out = this1
        value = None
        coef = 0
        _g = 0
        while (_g < 64):
            i = _g
            _g = (_g + 1)
            self.block[i] = 0
        c1 = c
        c2 = c1.dcpred
        vlc = self.vlctab[c.dctabsel]
        value1 = self.njShowBits(16)
        bits = vlc.b[(value1 << 1)]
        if (self.bufbits < bits):
            self.njShowBits(bits)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 - bits)
        _hx_local_0.bufbits
        value1 = vlc.b[((value1 << 1) | 1)]
        self.vlcCode = value1
        bits = (value1 & 15)
        tmp = None
        if (bits == 0):
            tmp = 0
        else:
            r = self.njShowBits(bits)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.bufbits
            _hx_local_2.bufbits = (_hx_local_3 - bits)
            _hx_local_2.bufbits
            value1 = r
            if (value1 < ((1 << ((bits - 1))))):
                value1 = (value1 + ((((-1 << bits)) + 1)))
            tmp = value1
        c1.dcpred = (c2 + tmp)
        qt = self.qtab[c.qtsel]
        at = self.vlctab[c.actabsel]
        this1 = self.block
        val = (c.dcpred * qt[0])
        this1[0] = val
        while True:
            value1 = self.njShowBits(16)
            bits = at.b[(value1 << 1)]
            if (self.bufbits < bits):
                self.njShowBits(bits)
            _hx_local_5 = self
            _hx_local_6 = _hx_local_5.bufbits
            _hx_local_5.bufbits = (_hx_local_6 - bits)
            _hx_local_5.bufbits
            value1 = at.b[((value1 << 1) | 1)]
            self.vlcCode = value1
            bits = (value1 & 15)
            if (bits == 0):
                value = 0
            else:
                r = self.njShowBits(bits)
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.bufbits
                _hx_local_7.bufbits = (_hx_local_8 - bits)
                _hx_local_7.bufbits
                value1 = r
                if (value1 < ((1 << ((bits - 1))))):
                    value1 = (value1 + ((((-1 << bits)) + 1)))
                value = value1
            if (self.vlcCode == 0):
                break
            coef = (coef + ((((self.vlcCode >> 4)) + 1)))
            this1 = self.block
            index = self.njZZ[coef]
            val = (value * qt[coef])
            this1[index] = val
            if (not ((coef < 63))):
                break
        bp = 0
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 8
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 16
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 24
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 32
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 40
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 48
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 56
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        po1 = po
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[32] << 8)
        x2 = self.block[48]
        x3 = self.block[16]
        x4 = self.block[8]
        x5 = self.block[56]
        x6 = self.block[40]
        x7 = self.block[24]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[0] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[0] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (1 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[33] << 8)
        x2 = self.block[49]
        x3 = self.block[17]
        x4 = self.block[9]
        x5 = self.block[57]
        x6 = self.block[41]
        x7 = self.block[25]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[1] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[1] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (2 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[34] << 8)
        x2 = self.block[50]
        x3 = self.block[18]
        x4 = self.block[10]
        x5 = self.block[58]
        x6 = self.block[42]
        x7 = self.block[26]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[2] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[2] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (3 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[35] << 8)
        x2 = self.block[51]
        x3 = self.block[19]
        x4 = self.block[11]
        x5 = self.block[59]
        x6 = self.block[43]
        x7 = self.block[27]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[3] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[3] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (4 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[36] << 8)
        x2 = self.block[52]
        x3 = self.block[20]
        x4 = self.block[12]
        x5 = self.block[60]
        x6 = self.block[44]
        x7 = self.block[28]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[4] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[4] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (5 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[37] << 8)
        x2 = self.block[53]
        x3 = self.block[21]
        x4 = self.block[13]
        x5 = self.block[61]
        x6 = self.block[45]
        x7 = self.block[29]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[5] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[5] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (6 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[38] << 8)
        x2 = self.block[54]
        x3 = self.block[22]
        x4 = self.block[14]
        x5 = self.block[62]
        x6 = self.block[46]
        x7 = self.block[30]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[6] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[6] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (7 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[39] << 8)
        x2 = self.block[55]
        x3 = self.block[23]
        x4 = self.block[15]
        x5 = self.block[63]
        x6 = self.block[47]
        x7 = self.block[31]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[7] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[7] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)

    def notSupported(self):
        raise haxe_Exception.thrown("This JPG file is not supported")

    def njDecodeScan(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        if (self.bytes.b[self.pos] != self.ncomp):
            self.notSupported()
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.pos
        _hx_local_6.pos = (_hx_local_7 + 1)
        _hx_local_6.pos
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.size
        _hx_local_8.size = (_hx_local_9 - 1)
        _hx_local_8.size
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.length
        _hx_local_10.length = (_hx_local_11 - 1)
        _hx_local_10.length
        _g = 0
        _g1 = self.ncomp
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.comps[i]
            flag = (self.bytes.b[self.pos] != c.cid)
            flag1 = (((self.bytes.b[(self.pos + 1)] & 236)) != 0)
            c.dctabsel = ((self.bytes.b[(self.pos + 1)] >> 4) << 1)
            c.actabsel = ((((self.bytes.b[(self.pos + 1)] & 3)) << 1) | 1)
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + 2)
            _hx_local_12.pos
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.size
            _hx_local_14.size = (_hx_local_15 - 2)
            _hx_local_14.size
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.length
            _hx_local_16.length = (_hx_local_17 - 2)
            _hx_local_16.length
        start = self.bytes.b[self.pos]
        count = self.bytes.b[(self.pos + 1)]
        other = self.bytes.b[(self.pos + 2)]
        if ((((not self.progressive) and ((start != 0))) or ((count != ((63 - start))))) or ((other != 0))):
            self.notSupported()
        count = self.length
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18.pos
        _hx_local_18.pos = (_hx_local_19 + count)
        _hx_local_18.pos
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20.size
        _hx_local_20.size = (_hx_local_21 - count)
        _hx_local_20.size
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22.length
        _hx_local_22.length = (_hx_local_23 - count)
        _hx_local_22.length
        mbx = 0
        mby = 0
        rstcount = self.rstinterval
        nextrst = 0
        while True:
            _g = 0
            _g1 = self.ncomp
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                c = self.comps[i]
                _g2 = 0
                _g3 = c.ssy
                while (_g2 < _g3):
                    sby = _g2
                    _g2 = (_g2 + 1)
                    _g4 = 0
                    _g5 = c.ssx
                    while (_g4 < _g5):
                        sbx = _g4
                        _g4 = (_g4 + 1)
                        self.njDecodeBlock(c,(((((((mby * c.ssy) + sby)) * c.stride) + ((mbx * c.ssx))) + sbx) << 3))
            mbx = (mbx + 1)
            tmp = mbx
            if (tmp >= self.mbwidth):
                mbx = 0
                mby = (mby + 1)
                tmp1 = mby
                if (tmp1 >= self.mbheight):
                    break
            tmp2 = None
            if (self.rstinterval != 0):
                rstcount = (rstcount - 1)
                tmp3 = rstcount
                tmp2 = (tmp3 == 0)
            else:
                tmp2 = False
            if tmp2:
                _hx_local_24 = self
                _hx_local_25 = _hx_local_24.bufbits
                _hx_local_24.bufbits = (_hx_local_25 & 248)
                _hx_local_24.bufbits
                r = self.njShowBits(16)
                _hx_local_26 = self
                _hx_local_27 = _hx_local_26.bufbits
                _hx_local_26.bufbits = (_hx_local_27 - 16)
                _hx_local_26.bufbits
                i1 = r
                nextrst = ((nextrst + 1) & 7)
                rstcount = self.rstinterval
                self.comps[0].dcpred = 0
                self.comps[1].dcpred = 0
                self.comps[2].dcpred = 0

    def njUpsampleH(self,c):
        xmax = (c.width - 3)
        cout = haxe_io_Bytes.alloc(((c.width * c.height) << 1))
        this1 = cout
        lout = this1
        this1 = c.pixels
        lin = this1
        pi = 0
        po = 0
        _g = 0
        _g1 = c.height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            x = ((((139 * lin.b[pi]) + ((-11 * lin.b[(pi + 1)]))) + 64) >> 7)
            lout.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            x1 = (((((104 * lin.b[pi]) + ((27 * lin.b[(pi + 1)]))) + ((-3 * lin.b[(pi + 2)]))) + 64) >> 7)
            lout.b[(po + 1)] = (((0 if ((x1 < 0)) else (255 if ((x1 > 255)) else x1))) & 255)
            x2 = (((((28 * lin.b[pi]) + ((109 * lin.b[(pi + 1)]))) + ((-9 * lin.b[(pi + 2)]))) + 64) >> 7)
            lout.b[(po + 2)] = (((0 if ((x2 < 0)) else (255 if ((x2 > 255)) else x2))) & 255)
            _g2 = 0
            _g3 = xmax
            while (_g2 < _g3):
                x3 = _g2
                _g2 = (_g2 + 1)
                x4 = ((((((-9 * lin.b[(pi + x3)]) + ((111 * lin.b[((pi + x3) + 1)]))) + ((29 * lin.b[((pi + x3) + 2)]))) + ((-3 * lin.b[((pi + x3) + 3)]))) + 64) >> 7)
                lout.b[((po + ((x3 << 1))) + 3)] = (((0 if ((x4 < 0)) else (255 if ((x4 > 255)) else x4))) & 255)
                x5 = ((((((-3 * lin.b[(pi + x3)]) + ((29 * lin.b[((pi + x3) + 1)]))) + ((111 * lin.b[((pi + x3) + 2)]))) + ((-9 * lin.b[((pi + x3) + 3)]))) + 64) >> 7)
                lout.b[((po + ((x3 << 1))) + 4)] = (((0 if ((x5 < 0)) else (255 if ((x5 > 255)) else x5))) & 255)
            pi = (pi + c.stride)
            po = (po + ((c.width << 1)))
            x6 = (((((28 * lin.b[(pi - 1)]) + ((109 * lin.b[(pi - 2)]))) + ((-9 * lin.b[(pi - 3)]))) + 64) >> 7)
            lout.b[(po - 3)] = (((0 if ((x6 < 0)) else (255 if ((x6 > 255)) else x6))) & 255)
            x7 = (((((104 * lin.b[(pi - 1)]) + ((27 * lin.b[(pi - 2)]))) + ((-3 * lin.b[(pi - 3)]))) + 64) >> 7)
            lout.b[(po - 2)] = (((0 if ((x7 < 0)) else (255 if ((x7 > 255)) else x7))) & 255)
            x8 = ((((139 * lin.b[(pi - 1)]) + ((-11 * lin.b[(pi - 2)]))) + 64) >> 7)
            lout.b[(po - 1)] = (((0 if ((x8 < 0)) else (255 if ((x8 > 255)) else x8))) & 255)
        c.width = (c.width << 1)
        c.stride = c.width
        c.pixels = cout

    def njUpsampleV(self,c):
        w = c.width
        s1 = c.stride
        s2 = (s1 + s1)
        out = haxe_io_Bytes.alloc(((c.width * c.height) << 1))
        pi = 0
        po = 0
        this1 = out
        cout = this1
        this1 = c.pixels
        cin = this1
        _g = 0
        _g1 = w
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            po = x
            pi = po
            x1 = ((((139 * cin.b[pi]) + ((-11 * cin.b[(pi + s1)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x1 < 0)) else (255 if ((x1 > 255)) else x1))) & 255)
            po = (po + w)
            x2 = (((((104 * cin.b[pi]) + ((27 * cin.b[(pi + s1)]))) + ((-3 * cin.b[(pi + s2)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x2 < 0)) else (255 if ((x2 > 255)) else x2))) & 255)
            po = (po + w)
            x3 = (((((28 * cin.b[pi]) + ((109 * cin.b[(pi + s1)]))) + ((-9 * cin.b[(pi + s2)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x3 < 0)) else (255 if ((x3 > 255)) else x3))) & 255)
            po = (po + w)
            pi = (pi + s1)
            _g2 = 0
            _g3 = (c.height - 2)
            while (_g2 < _g3):
                y = _g2
                _g2 = (_g2 + 1)
                x4 = ((((((-9 * cin.b[(pi - s1)]) + ((111 * cin.b[pi]))) + ((29 * cin.b[(pi + s1)]))) + ((-3 * cin.b[(pi + s2)]))) + 64) >> 7)
                cout.b[po] = (((0 if ((x4 < 0)) else (255 if ((x4 > 255)) else x4))) & 255)
                po = (po + w)
                x5 = ((((((-3 * cin.b[(pi - s1)]) + ((29 * cin.b[pi]))) + ((111 * cin.b[(pi + s1)]))) + ((-9 * cin.b[(pi + s2)]))) + 64) >> 7)
                cout.b[po] = (((0 if ((x5 < 0)) else (255 if ((x5 > 255)) else x5))) & 255)
                po = (po + w)
                pi = (pi + s1)
            pi = (pi + s1)
            x6 = (((((28 * cin.b[pi]) + ((109 * cin.b[(pi - s1)]))) + ((-9 * cin.b[(pi - s2)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x6 < 0)) else (255 if ((x6 > 255)) else x6))) & 255)
            po = (po + w)
            x7 = (((((104 * cin.b[pi]) + ((27 * cin.b[(pi - s1)]))) + ((-3 * cin.b[(pi - s2)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x7 < 0)) else (255 if ((x7 > 255)) else x7))) & 255)
            po = (po + w)
            x8 = ((((139 * cin.b[pi]) + ((-11 * cin.b[(pi - s1)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x8 < 0)) else (255 if ((x8 > 255)) else x8))) & 255)
        c.height = (c.height << 1)
        c.stride = c.width
        c.pixels = out

    def njUpsample(self,c):
        xshift = 0
        yshift = 0
        while (c.width < self.width):
            c.width = (c.width << 1)
            xshift = (xshift + 1)
        while (c.height < self.height):
            c.height = (c.height << 1)
            yshift = (yshift + 1)
        out = haxe_io_Bytes.alloc((c.width * c.height))
        this1 = c.pixels
        lin = this1
        pout = 0
        this1 = out
        lout = this1
        _g = 0
        _g1 = c.height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pin = (((y >> yshift)) * c.stride)
            _g2 = 0
            _g3 = c.width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                pos = pout
                pout = (pout + 1)
                v = lin.b[(((x >> xshift)) + pin)]
                lout.b[pos] = (v & 255)
        c.stride = c.width
        c.pixels = out

    def njConvert(self):
        _g = 0
        _g1 = self.ncomp
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.comps[i]
            tmp = self.filter.index
            if (tmp == 0):
                if ((c.width < self.width) or ((c.height < self.height))):
                    self.njUpsample(c)
            elif (tmp == 1):
                while ((c.width < self.width) or ((c.height < self.height))):
                    if (c.width < self.width):
                        self.njUpsampleH(c)
                    if (c.height < self.height):
                        self.njUpsampleV(c)
            else:
                pass
            if ((c.width < self.width) or ((c.height < self.height))):
                raise haxe_Exception.thrown("assert")
        pixels = haxe_io_Bytes.alloc(((self.width * self.height) * 4))
        if (self.ncomp == 3):
            this1 = self.comps[0].pixels
            py = this1
            this1 = self.comps[1].pixels
            pcb = this1
            this1 = self.comps[2].pixels
            pcr = this1
            this1 = pixels
            pix = this1
            k1 = 0
            k2 = 0
            k3 = 0
            out = 0
            _g = 0
            _g1 = self.height
            while (_g < _g1):
                yy = _g
                _g = (_g + 1)
                _g2 = 0
                _g3 = self.width
                while (_g2 < _g3):
                    x = _g2
                    _g2 = (_g2 + 1)
                    i = k1
                    k1 = (k1 + 1)
                    y = (py.b[i] << 8)
                    i1 = k2
                    k2 = (k2 + 1)
                    cb = (pcb.b[i1] - 128)
                    i2 = k3
                    k3 = (k3 + 1)
                    cr = (pcr.b[i2] - 128)
                    x1 = (((y + ((359 * cr))) + 128) >> 8)
                    r = (0 if ((x1 < 0)) else (255 if ((x1 > 255)) else x1))
                    x2 = ((((y - ((88 * cb))) - ((183 * cr))) + 128) >> 8)
                    g = (0 if ((x2 < 0)) else (255 if ((x2 > 255)) else x2))
                    x3 = (((y + ((454 * cb))) + 128) >> 8)
                    b = (0 if ((x3 < 0)) else (255 if ((x3 > 255)) else x3))
                    out1 = out
                    out = (out + 1)
                    pix.b[out1] = (b & 255)
                    out2 = out
                    out = (out + 1)
                    pix.b[out2] = (g & 255)
                    out3 = out
                    out = (out + 1)
                    pix.b[out3] = (r & 255)
                    out4 = out
                    out = (out + 1)
                    pix.b[out4] = 255
                k1 = (k1 + ((self.comps[0].stride - self.width)))
                k2 = (k2 + ((self.comps[1].stride - self.width)))
                k3 = (k3 + ((self.comps[2].stride - self.width)))
        else:
            raise haxe_Exception.thrown("TODO")
        return pixels

    def njDecode(self):
        if (((self.size < 2) or ((self.bytes.b[self.pos] != 255))) or ((self.bytes.b[(self.pos + 1)] != 216))):
            raise haxe_Exception.thrown("This file is not a JPEG")
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        while True:
            flag = ((self.size < 2) or ((self.bytes.b[self.pos] != 255)))
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 2)
            _hx_local_6.pos
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.size
            _hx_local_8.size = (_hx_local_9 - 2)
            _hx_local_8.size
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.length
            _hx_local_10.length = (_hx_local_11 - 2)
            _hx_local_10.length
            _g = self.bytes.b[(self.pos + (-1))]
            if (_g == 192):
                self.njDecodeSOF()
            elif (_g == 194):
                self.progressive = True
                if self.progressive:
                    raise haxe_Exception.thrown("Unsupported progressive JPG")
                if (self.vlctab[4] is None):
                    this1 = self.vlctab
                    val = haxe_io_Bytes.alloc(131072)
                    this1[4] = val
                if (self.vlctab[5] is None):
                    this2 = self.vlctab
                    val1 = haxe_io_Bytes.alloc(131072)
                    this2[5] = val1
                if (self.vlctab[6] is None):
                    this3 = self.vlctab
                    val2 = haxe_io_Bytes.alloc(131072)
                    this3[6] = val2
                if (self.vlctab[7] is None):
                    this4 = self.vlctab
                    val3 = haxe_io_Bytes.alloc(131072)
                    this4[7] = val3
                self.njDecodeSOF()
            elif (_g == 195):
                raise haxe_Exception.thrown("Unsupported lossless JPG")
            elif (_g == 196):
                self.njDecodeDHT()
            elif (_g == 218):
                self.njDecodeScan()
                break
            elif (_g == 219):
                self.njDecodeDQT()
            elif (_g == 221):
                self.njDecodeDRI()
            elif (_g == 254):
                self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
                _hx_local_12 = self
                _hx_local_13 = _hx_local_12.pos
                _hx_local_12.pos = (_hx_local_13 + 2)
                _hx_local_12.pos
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.size
                _hx_local_14.size = (_hx_local_15 - 2)
                _hx_local_14.size
                _hx_local_16 = self
                _hx_local_17 = _hx_local_16.length
                _hx_local_16.length = (_hx_local_17 - 2)
                _hx_local_16.length
                count = self.length
                _hx_local_18 = self
                _hx_local_19 = _hx_local_18.pos
                _hx_local_18.pos = (_hx_local_19 + count)
                _hx_local_18.pos
                _hx_local_20 = self
                _hx_local_21 = _hx_local_20.size
                _hx_local_20.size = (_hx_local_21 - count)
                _hx_local_20.size
                _hx_local_22 = self
                _hx_local_23 = _hx_local_22.length
                _hx_local_22.length = (_hx_local_23 - count)
                _hx_local_22.length
            else:
                _g1 = (self.bytes.b[(self.pos + (-1))] & 240)
                if (_g1 == 192):
                    raise haxe_Exception.thrown(("Unsupported jpeg type " + Std.string(((self.bytes.b[(self.pos + (-1))] & 15)))))
                elif (_g1 == 224):
                    self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
                    _hx_local_24 = self
                    _hx_local_25 = _hx_local_24.pos
                    _hx_local_24.pos = (_hx_local_25 + 2)
                    _hx_local_24.pos
                    _hx_local_26 = self
                    _hx_local_27 = _hx_local_26.size
                    _hx_local_26.size = (_hx_local_27 - 2)
                    _hx_local_26.size
                    _hx_local_28 = self
                    _hx_local_29 = _hx_local_28.length
                    _hx_local_28.length = (_hx_local_29 - 2)
                    _hx_local_28.length
                    count1 = self.length
                    _hx_local_30 = self
                    _hx_local_31 = _hx_local_30.pos
                    _hx_local_30.pos = (_hx_local_31 + count1)
                    _hx_local_30.pos
                    _hx_local_32 = self
                    _hx_local_33 = _hx_local_32.size
                    _hx_local_32.size = (_hx_local_33 - count1)
                    _hx_local_32.size
                    _hx_local_34 = self
                    _hx_local_35 = _hx_local_34.length
                    _hx_local_34.length = (_hx_local_35 - count1)
                    _hx_local_34.length
                else:
                    raise haxe_Exception.thrown(("Unsupported jpeg tag 0x" + HxOverrides.stringOrNull(StringTools.hex(self.bytes.b[(self.pos + (-1))],2))))
        pixels = self.njConvert()
        self.cleanup()
        return _hx_AnonObject({'pixels': pixels, 'width': self.width, 'height': self.height})

    @staticmethod
    def CF(x):
        x1 = ((x + 64) >> 7)
        if (x1 < 0):
            return 0
        elif (x1 > 255):
            return 255
        else:
            return x1

    @staticmethod
    def njClip(x):
        if (x < 0):
            return 0
        elif (x > 255):
            return 255
        else:
            return x

    @staticmethod
    def decode(_hx_bytes,_hx_filter = None,position = None,size = None):
        if (position is None):
            position = 0
        if (size is None):
            size = -1
        if (hxd_res_NanoJpeg.inst is None):
            hxd_res_NanoJpeg.inst = hxd_res_NanoJpeg()
        hxd_res_NanoJpeg.inst.njInit(_hx_bytes,position,size,_hx_filter)
        return hxd_res_NanoJpeg.inst.njDecode()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bytes = None
        _hx_o.pos = None
        _hx_o.size = None
        _hx_o.length = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.ncomp = None
        _hx_o.comps = None
        _hx_o.counts = None
        _hx_o.qtab = None
        _hx_o.qtused = None
        _hx_o.qtavail = None
        _hx_o.vlctab = None
        _hx_o.block = None
        _hx_o.njZZ = None
        _hx_o.progressive = None
        _hx_o.mbsizex = None
        _hx_o.mbsizey = None
        _hx_o.mbwidth = None
        _hx_o.mbheight = None
        _hx_o.rstinterval = None
        _hx_o.buf = None
        _hx_o.bufbits = None
        _hx_o.pixels = None
        _hx_o.filter = None
        _hx_o.vlcCode = None
hxd_res_NanoJpeg._hx_class = hxd_res_NanoJpeg
_hx_classes["hxd.res.NanoJpeg"] = hxd_res_NanoJpeg

class hxd_res_SoundFormat(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.res.SoundFormat"
    _hx_constructs = ["Wav", "Mp3", "OggVorbis"]
hxd_res_SoundFormat.Wav = hxd_res_SoundFormat("Wav", 0, ())
hxd_res_SoundFormat.Mp3 = hxd_res_SoundFormat("Mp3", 1, ())
hxd_res_SoundFormat.OggVorbis = hxd_res_SoundFormat("OggVorbis", 2, ())
hxd_res_SoundFormat._hx_class = hxd_res_SoundFormat
_hx_classes["hxd.res.SoundFormat"] = hxd_res_SoundFormat


class hxd_res_Sound(hxd_res_Resource):
    _hx_class_name = "hxd.res.Sound"
    _hx_is_interface = "False"
    __slots__ = ("data", "channel", "lastPlay")
    _hx_fields = ["data", "channel", "lastPlay"]
    _hx_methods = ["getData", "dispose", "stop", "play", "watchCallb"]
    _hx_statics = ["ENABLE_AUTO_WATCH", "supportedFormat", "startWorker"]
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,entry):
        self.channel = None
        self.data = None
        self.lastPlay = 0.
        super().__init__(entry)

    def getData(self):
        if (self.data is not None):
            return self.data
        _hx_bytes = self.entry.getBytes()
        _g = _hx_bytes.b[0]
        if ((_g == 255) or ((_g == 73))):
            self.data = hxd_snd_Mp3Data(_hx_bytes)
        elif (_g == 79):
            raise haxe_Exception.thrown((("OGG format requires -lib stb_ogg_sound (for " + HxOverrides.stringOrNull(self.entry.get_path())) + ")"))
        elif (_g == 82):
            self.data = hxd_snd_WavData(_hx_bytes)
        else:
            pass
        if (self.data is None):
            raise haxe_Exception.thrown(("Unsupported sound format " + HxOverrides.stringOrNull(self.entry.get_path())))
        if hxd_res_Sound.ENABLE_AUTO_WATCH:
            self.watch(self.watchCallb)
        return self.data

    def dispose(self):
        self.stop()
        self.data = None

    def stop(self):
        if (self.channel is not None):
            self.channel.stop()
            self.channel = None

    def play(self,loop = None,volume = None,channelGroup = None,soundGroup = None):
        if (loop is None):
            loop = False
        if (volume is None):
            volume = 1.
        self.lastPlay = python_lib_Timeit.default_timer()
        self.channel = hxd_snd_Manager.get().play(self,channelGroup,soundGroup)
        self.channel.loop = loop
        self.channel.set_volume(volume)
        return self.channel

    def watchCallb(self):
        old = self.data
        self.data = None
        data = self.getData()
        if (old is not None):
            if ((((old.channels != data.channels) or ((old.samples != data.samples))) or ((old.sampleFormat != data.sampleFormat))) or ((old.samplingRate != data.samplingRate))):
                manager = hxd_snd_Manager.get()
                ch = manager.getAll(self)
                while ch.hasNext():
                    ch1 = ch.next()
                    ch1.duration = data.get_duration()
                    ch1.set_position(ch1.position)

    @staticmethod
    def supportedFormat(fmt):
        tmp = fmt.index
        if ((tmp == 1) or ((tmp == 0))):
            return True
        elif (tmp == 2):
            return False
        else:
            pass

    @staticmethod
    def startWorker():
        return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
        _hx_o.channel = None
        _hx_o.lastPlay = None
hxd_res_Sound._hx_class = hxd_res_Sound
_hx_classes["hxd.res.Sound"] = hxd_res_Sound


class hxd_snd_ChannelBase:
    _hx_class_name = "hxd.snd.ChannelBase"
    _hx_is_interface = "False"
    __slots__ = ("priority", "mute", "effects", "bindedEffects", "volume", "currentFade", "currentVolume")
    _hx_fields = ["priority", "mute", "effects", "bindedEffects", "volume", "currentFade", "currentVolume"]
    _hx_methods = ["getEffect", "set_volume", "fadeTo", "updateCurrentVolume", "addEffect", "removeEffect"]

    def __init__(self):
        self.currentVolume = None
        self.currentFade = None
        self.volume = 1.
        self.bindedEffects = []
        self.effects = []
        self.mute = False
        self.priority = 0.

    def getEffect(self,etype):
        if (self.effects is None):
            return None
        _g = 0
        _g1 = self.effects
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            e1 = Std.downcast(e,etype)
            if (e1 is not None):
                return e1
        return None

    def set_volume(self,v):
        self.currentFade = None
        def _hx_local_1():
            def _hx_local_0():
                self.volume = v
                return self.volume
            return _hx_local_0()
        return _hx_local_1()

    def fadeTo(self,volume,time = None,onEnd = None):
        if (time is None):
            time = 1.
        self.currentFade = _hx_AnonObject({'start': python_lib_Timeit.default_timer(), 'duration': time, 'startVolume': self.volume, 'targetVolume': volume, 'onEnd': onEnd})

    def updateCurrentVolume(self,now):
        if (self.currentFade is not None):
            f = self.currentFade
            dt = (now - f.start)
            if (dt >= f.duration):
                self.set_volume(f.targetVolume)
                if (f.onEnd is not None):
                    f.onEnd()
            else:
                self.set_volume((f.startVolume + (((dt / f.duration) * ((f.targetVolume - f.startVolume))))))
                self.currentFade = f
        self.currentVolume = self.volume

    def addEffect(self,e):
        if (e is None):
            raise haxe_Exception.thrown("Can't add null effect")
        if (python_internal_ArrayImpl.indexOf(self.effects,e,None) >= 0):
            raise haxe_Exception.thrown("effect already added on this channel")
        _this = self.effects
        _this.append(e)
        return e

    def removeEffect(self,e):
        python_internal_ArrayImpl.remove(self.effects,e)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.priority = None
        _hx_o.mute = None
        _hx_o.effects = None
        _hx_o.bindedEffects = None
        _hx_o.volume = None
        _hx_o.currentFade = None
        _hx_o.currentVolume = None
hxd_snd_ChannelBase._hx_class = hxd_snd_ChannelBase
_hx_classes["hxd.snd.ChannelBase"] = hxd_snd_ChannelBase


class hxd_snd_Channel(hxd_snd_ChannelBase):
    _hx_class_name = "hxd.snd.Channel"
    _hx_is_interface = "False"
    _hx_fields = ["next", "manager", "source", "id", "sound", "duration", "soundGroup", "channelGroup", "position", "pause", "loop", "allowVirtual", "audibleVolume", "lastStamp", "isVirtual", "isLoading", "positionChanged", "queue"]
    _hx_methods = ["onEnd", "set_position", "set_pause", "updateCurrentVolume", "calcAudibleVolume", "queueSound", "stop", "isReleased"]
    _hx_statics = ["ID"]
    _hx_interfaces = []
    _hx_super = hxd_snd_ChannelBase


    def __init__(self):
        self.channelGroup = None
        self.soundGroup = None
        self.duration = None
        self.sound = None
        self.id = None
        self.source = None
        self.manager = None
        self.next = None
        self.queue = []
        self.positionChanged = False
        self.isLoading = False
        self.isVirtual = False
        self.lastStamp = 0.0
        self.audibleVolume = 1.0
        self.allowVirtual = True
        self.loop = False
        self.pause = False
        self.position = 0.0
        super().__init__()
        def _hx_local_2():
            _hx_local_0 = hxd_snd_Channel
            _hx_local_1 = _hx_local_0.ID
            _hx_local_0.ID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()

    def onEnd(self):
        pass

    def set_position(self,v):
        self.lastStamp = python_lib_Timeit.default_timer()
        self.positionChanged = True
        if (v > self.duration):
            v = self.duration
        elif (v < 0):
            v = 0
        def _hx_local_1():
            def _hx_local_0():
                self.position = v
                return self.position
            return _hx_local_0()
        return _hx_local_1()

    def set_pause(self,v):
        if (not v):
            self.lastStamp = python_lib_Timeit.default_timer()
        def _hx_local_1():
            def _hx_local_0():
                self.pause = v
                return self.pause
            return _hx_local_0()
        return _hx_local_1()

    def updateCurrentVolume(self,now):
        if (self.pause and ((self.currentFade is not None))):
            f = self.currentFade
            self.currentFade = None
            self.updateCurrentVolume(now)
            self.currentFade = f
        super().updateCurrentVolume(now)
        self.channelGroup.updateCurrentVolume(now)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.currentVolume
        _hx_local_0.currentVolume = (_hx_local_1 * ((self.channelGroup.currentVolume * self.soundGroup.volume)))
        _hx_local_0.currentVolume
        if (self.manager is not None):
            _g = 0
            _g1 = self.channelGroup.effects
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.currentVolume
                _hx_local_3.currentVolume = (_hx_local_4 * e.getVolumeModifier())
                _hx_local_3.currentVolume
            _g = 0
            _g1 = self.effects
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.currentVolume
                _hx_local_6.currentVolume = (_hx_local_7 * e.getVolumeModifier())
                _hx_local_6.currentVolume

    def calcAudibleVolume(self,now):
        self.updateCurrentVolume(now)
        self.audibleVolume = self.currentVolume
        if (self.manager is not None):
            _g = 0
            _g1 = self.channelGroup.effects
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.audibleVolume = e.applyAudibleVolumeModifier(self.audibleVolume)
            _g = 0
            _g1 = self.effects
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.audibleVolume = e.applyAudibleVolumeModifier(self.audibleVolume)

    def queueSound(self,sound):
        _this = self.queue
        _this.append(sound)

    def stop(self):
        if (self.manager is not None):
            self.manager.releaseChannel(self)

    def isReleased(self):
        return (self.manager is None)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.manager = None
        _hx_o.source = None
        _hx_o.id = None
        _hx_o.sound = None
        _hx_o.duration = None
        _hx_o.soundGroup = None
        _hx_o.channelGroup = None
        _hx_o.position = None
        _hx_o.pause = None
        _hx_o.loop = None
        _hx_o.allowVirtual = None
        _hx_o.audibleVolume = None
        _hx_o.lastStamp = None
        _hx_o.isVirtual = None
        _hx_o.isLoading = None
        _hx_o.positionChanged = None
        _hx_o.queue = None
hxd_snd_Channel._hx_class = hxd_snd_Channel
_hx_classes["hxd.snd.Channel"] = hxd_snd_Channel


class hxd_snd_ChannelGroup(hxd_snd_ChannelBase):
    _hx_class_name = "hxd.snd.ChannelGroup"
    _hx_is_interface = "False"
    __slots__ = ("name",)
    _hx_fields = ["name"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_snd_ChannelBase


    def __init__(self,name):
        self.name = None
        super().__init__()
        self.name = name

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
hxd_snd_ChannelGroup._hx_class = hxd_snd_ChannelGroup
_hx_classes["hxd.snd.ChannelGroup"] = hxd_snd_ChannelGroup

class hxd_snd_SampleFormat(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.snd.SampleFormat"
    _hx_constructs = ["UI8", "I16", "F32"]
hxd_snd_SampleFormat.UI8 = hxd_snd_SampleFormat("UI8", 0, ())
hxd_snd_SampleFormat.I16 = hxd_snd_SampleFormat("I16", 1, ())
hxd_snd_SampleFormat.F32 = hxd_snd_SampleFormat("F32", 2, ())
hxd_snd_SampleFormat._hx_class = hxd_snd_SampleFormat
_hx_classes["hxd.snd.SampleFormat"] = hxd_snd_SampleFormat


class hxd_snd_Data:
    _hx_class_name = "hxd.snd.Data"
    _hx_is_interface = "False"
    __slots__ = ("samples", "samplingRate", "sampleFormat", "channels")
    _hx_fields = ["samples", "samplingRate", "sampleFormat", "channels"]
    _hx_methods = ["isLoading", "decode", "resample", "resampleBuffer", "decodeBuffer", "getBytesPerSample", "load", "get_duration"]
    _hx_statics = ["formatBytes"]

    def isLoading(self):
        return False

    def decode(self,out,outPos,sampleStart,sampleCount):
        bpp = self.getBytesPerSample()
        if ((((sampleStart < 0) or ((sampleCount < 0))) or ((outPos < 0))) or (((outPos + ((sampleCount * bpp))) > out.length))):
            s = ("sampleStart = " + Std.string(sampleStart))
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" sampleCount = " + Std.string(sampleCount)))))
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" outPos = " + Std.string(outPos)))))
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" bpp = " + Std.string(bpp)))))
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" out.length = " + Std.string(out.length)))))
            raise haxe_Exception.thrown(s)
        if ((sampleStart + sampleCount) >= self.samples):
            count = 0
            if (sampleStart < self.samples):
                count = (self.samples - sampleStart)
                self.decodeBuffer(out,outPos,sampleStart,count)
            out.fill((outPos + ((count * bpp))),(((sampleCount - count)) * bpp),0)
            return
        self.decodeBuffer(out,outPos,sampleStart,sampleCount)

    def resample(self,rate,format,channels):
        if (((self.sampleFormat == format) and ((self.samplingRate == rate))) and ((self.channels == channels))):
            return self
        newSamples = Math.ceil((self.samples * ((rate / self.samplingRate))))
        bpp = self.getBytesPerSample()
        data = haxe_io_Bytes.alloc((bpp * self.samples))
        self.decodeBuffer(data,0,0,self.samples)
        out = (channels * newSamples)
        out1 = None
        out2 = format.index
        if (out2 == 0):
            out1 = 1
        elif (out2 == 1):
            out1 = 2
        elif (out2 == 2):
            out1 = 4
        else:
            pass
        out2 = haxe_io_Bytes.alloc((out * out1))
        self.resampleBuffer(out2,0,data,0,rate,format,channels,self.samples)
        data = hxd_snd_WavData(None)
        data.channels = channels
        data.samples = newSamples
        data.sampleFormat = format
        data.samplingRate = rate
        data.rawData = out2
        return data

    def resampleBuffer(self,out,outPos,input,inPos,rate,format,channels,samples):
        bpp = self.getBytesPerSample()
        newSamples = Math.ceil((samples * ((rate / self.samplingRate))))
        resample = (samples != newSamples)
        if (((((not resample) and ((self.sampleFormat == hxd_snd_SampleFormat.I16))) and ((format == hxd_snd_SampleFormat.I16))) and ((channels == 1))) and ((self.channels == 2))):
            r = inPos
            w = outPos
            _g = 0
            _g1 = samples
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                sl = (input.b[r] | ((input.b[(r + 1)] << 8)))
                r = (r + 2)
                sr = (input.b[r] | ((input.b[(r + 1)] << 8)))
                r = (r + 2)
                s = None
                if (((sl ^ sr)) >= 32768):
                    if (((sl & 32768)) != 0):
                        sl = (sl | -65536)
                    if (((sr & 32768)) != 0):
                        sr = (sr | -65536)
                    s = (((sl + sr) >> 1) & 65535)
                else:
                    s = ((sl + sr) >> 1)
                out.b[w] = (s & 255)
                out.b[(w + 1)] = ((s >> 8) & 255)
                w = (w + 2)
            return
        srcChannels = self.channels
        commonChannels = (channels if ((channels < srcChannels)) else srcChannels)
        extraChannels = (channels - commonChannels)
        sval = 0.
        ival = 0
        _g = 0
        _g1 = newSamples
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            targetSample = ((i / ((newSamples - 1))) * ((samples - 1)))
            isample = None
            try:
                isample = int(targetSample)
            except BaseException as _g2:
                None
                isample = None
            isample1 = isample
            offset = (targetSample - isample1)
            srcPos = (inPos + ((isample1 * bpp)))
            if (isample1 == ((samples - 1))):
                resample = False
            _g3 = 0
            _g4 = commonChannels
            while (_g3 < _g4):
                k = _g3
                _g3 = (_g3 + 1)
                sval1 = None
                sval2 = 0.
                tmp = self.sampleFormat.index
                if (tmp == 0):
                    sval1 = (input.b[srcPos] / 255)
                    if resample:
                        sval2 = (input.b[(srcPos + bpp)] / 255)
                    srcPos = (srcPos + 1)
                elif (tmp == 1):
                    v = (input.b[srcPos] | ((input.b[(srcPos + 1)] << 8)))
                    sval1 = (((v if ((((v & 32768)) == 0)) else (v | -65536))) / 32768)
                    if resample:
                        pos = (srcPos + bpp)
                        v1 = (input.b[pos] | ((input.b[(pos + 1)] << 8)))
                        sval2 = (((v1 if ((((v1 & 32768)) == 0)) else (v1 | -65536))) / 32768)
                    srcPos = (srcPos + 2)
                elif (tmp == 2):
                    sval1 = input.getFloat(srcPos)
                    if resample:
                        sval2 = input.getFloat((srcPos + bpp))
                    srcPos = (srcPos + 4)
                else:
                    pass
                sval = ((sval1 + ((offset * ((sval2 - sval1))))) if resample else sval1)
                tmp1 = format.index
                if (tmp1 == 0):
                    ival1 = None
                    try:
                        ival1 = int((((sval + 1)) * 128))
                    except BaseException as _g5:
                        None
                        ival1 = None
                    ival = ival1
                    if (ival > 255):
                        ival = 255
                    pos1 = outPos
                    outPos = (outPos + 1)
                    out.b[pos1] = (ival & 255)
                elif (tmp1 == 1):
                    ival2 = None
                    try:
                        ival2 = int((sval * 32768))
                    except BaseException as _g6:
                        None
                        ival2 = None
                    ival = ival2
                    if (ival > 32767):
                        ival = 32767
                    ival = (ival & 65535)
                    out.b[outPos] = (ival & 255)
                    out.b[(outPos + 1)] = ((ival >> 8) & 255)
                    outPos = (outPos + 2)
                elif (tmp1 == 2):
                    out.setFloat(outPos,sval)
                    outPos = (outPos + 4)
                else:
                    pass
            _g7 = 0
            _g8 = extraChannels
            while (_g7 < _g8):
                i1 = _g7
                _g7 = (_g7 + 1)
                tmp2 = format.index
                if (tmp2 == 0):
                    pos2 = outPos
                    outPos = (outPos + 1)
                    out.b[pos2] = (ival & 255)
                elif (tmp2 == 1):
                    out.b[outPos] = (ival & 255)
                    out.b[(outPos + 1)] = ((ival >> 8) & 255)
                    outPos = (outPos + 2)
                elif (tmp2 == 2):
                    out.setFloat(outPos,sval)
                    outPos = (outPos + 4)
                else:
                    pass

    def decodeBuffer(self,out,outPos,sampleStart,sampleCount):
        raise haxe_Exception.thrown("Not implemented")

    def getBytesPerSample(self):
        tmp = None
        tmp1 = self.sampleFormat.index
        if (tmp1 == 0):
            tmp = 1
        elif (tmp1 == 1):
            tmp = 2
        elif (tmp1 == 2):
            tmp = 4
        else:
            pass
        return (self.channels * tmp)

    def load(self,onEnd):
        onEnd()

    def get_duration(self):
        return (self.samples / self.samplingRate)

    @staticmethod
    def formatBytes(format):
        tmp = format.index
        if (tmp == 0):
            return 1
        elif (tmp == 1):
            return 2
        elif (tmp == 2):
            return 4
        else:
            pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.samples = None
        _hx_o.samplingRate = None
        _hx_o.sampleFormat = None
        _hx_o.channels = None
hxd_snd_Data._hx_class = hxd_snd_Data
_hx_classes["hxd.snd.Data"] = hxd_snd_Data


class hxd_snd_EffectDriver:
    _hx_class_name = "hxd.snd.EffectDriver"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["acquire", "release", "update", "bind", "apply", "unbind"]

    def __init__(self):
        pass

    def acquire(self):
        pass

    def release(self):
        pass

    def update(self,e):
        pass

    def bind(self,e,source):
        pass

    def apply(self,e,source):
        pass

    def unbind(self,e,source):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_snd_EffectDriver._hx_class = hxd_snd_EffectDriver
_hx_classes["hxd.snd.EffectDriver"] = hxd_snd_EffectDriver

class hxd_snd_DriverFeature(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.snd.DriverFeature"
    _hx_constructs = ["MasterVolume"]
hxd_snd_DriverFeature.MasterVolume = hxd_snd_DriverFeature("MasterVolume", 0, ())
hxd_snd_DriverFeature._hx_class = hxd_snd_DriverFeature
_hx_classes["hxd.snd.DriverFeature"] = hxd_snd_DriverFeature


class hxd_snd_Driver:
    _hx_class_name = "hxd.snd.Driver"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["hasFeature", "setMasterVolume", "setListenerParams", "createSource", "playSource", "stopSource", "setSourceVolume", "destroySource", "createBuffer", "setBufferData", "destroyBuffer", "queueBuffer", "unqueueBuffer", "getProcessedBuffers", "getPlayedSampleCount", "update", "dispose", "getEffectDriver"]
hxd_snd_Driver._hx_class = hxd_snd_Driver
_hx_classes["hxd.snd.Driver"] = hxd_snd_Driver


class hxd_snd_Effect:
    _hx_class_name = "hxd.snd.Effect"
    _hx_is_interface = "False"
    __slots__ = ("next", "refs", "retainTime", "lastStamp", "driver", "priority")
    _hx_fields = ["next", "refs", "retainTime", "lastStamp", "driver", "priority"]
    _hx_methods = ["applyAudibleVolumeModifier", "getVolumeModifier"]

    def __init__(self,_hx_type):
        self.driver = None
        self.next = None
        self.refs = 0
        self.priority = 0
        self.retainTime = 0.0
        self.lastStamp = 0.0
        managerDriver = hxd_snd_Manager.get().driver
        if (managerDriver is not None):
            self.driver = managerDriver.getEffectDriver(_hx_type)

    def applyAudibleVolumeModifier(self,v):
        return v

    def getVolumeModifier(self):
        return 1

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.refs = None
        _hx_o.retainTime = None
        _hx_o.lastStamp = None
        _hx_o.driver = None
        _hx_o.priority = None
hxd_snd_Effect._hx_class = hxd_snd_Effect
_hx_classes["hxd.snd.Effect"] = hxd_snd_Effect


class hxd_snd_Listener:
    _hx_class_name = "hxd.snd.Listener"
    _hx_is_interface = "False"
    __slots__ = ("position", "direction", "velocity", "up")
    _hx_fields = ["position", "direction", "velocity", "up"]
    _hx_methods = ["syncCamera"]

    def __init__(self):
        self.position = h3d_Vector()
        self.velocity = h3d_Vector()
        self.direction = h3d_Vector(1,0,0)
        self.up = h3d_Vector(0,0,1)

    def syncCamera(self,cam):
        _this = self.position
        v = cam.pos
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        _this = self.direction
        x = (cam.target.x - cam.pos.x)
        y = (cam.target.y - cam.pos.y)
        z = (cam.target.z - cam.pos.z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.direction
        k = (((_this.x * _this.x) + ((_this.y * _this.y))) + ((_this.z * _this.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _this.x = (_this.x * k)
        _this.y = (_this.y * k)
        _this.z = (_this.z * k)
        _this = self.up
        v = cam.up
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.position = None
        _hx_o.direction = None
        _hx_o.velocity = None
        _hx_o.up = None
hxd_snd_Listener._hx_class = hxd_snd_Listener
_hx_classes["hxd.snd.Listener"] = hxd_snd_Listener


class hxd_snd_Source:
    _hx_class_name = "hxd.snd.Source"
    _hx_is_interface = "False"
    __slots__ = ("id", "handle", "channel", "buffers", "volume", "playing", "start", "streamSound", "streamBuffer", "streamStart", "streamPos")
    _hx_fields = ["id", "handle", "channel", "buffers", "volume", "playing", "start", "streamSound", "streamBuffer", "streamStart", "streamPos"]
    _hx_methods = ["dispose"]
    _hx_statics = ["ID"]

    def __init__(self,driver):
        self.streamPos = None
        self.streamStart = None
        self.streamBuffer = None
        self.streamSound = None
        self.channel = None
        self.start = 0
        self.playing = False
        self.volume = -1.0
        def _hx_local_2():
            _hx_local_0 = hxd_snd_Source
            _hx_local_1 = _hx_local_0.ID
            _hx_local_0.ID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()
        self.handle = driver.createSource()
        self.buffers = []

    def dispose(self):
        hxd_snd_Manager.get().driver.destroySource(self.handle)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.handle = None
        _hx_o.channel = None
        _hx_o.buffers = None
        _hx_o.volume = None
        _hx_o.playing = None
        _hx_o.start = None
        _hx_o.streamSound = None
        _hx_o.streamBuffer = None
        _hx_o.streamStart = None
        _hx_o.streamPos = None
hxd_snd_Source._hx_class = hxd_snd_Source
_hx_classes["hxd.snd.Source"] = hxd_snd_Source


class hxd_snd_Buffer:
    _hx_class_name = "hxd.snd.Buffer"
    _hx_is_interface = "False"
    __slots__ = ("handle", "sound", "isEnd", "isStream", "refs", "lastStop", "start", "end", "samples", "sampleRate")
    _hx_fields = ["handle", "sound", "isEnd", "isStream", "refs", "lastStop", "start", "end", "samples", "sampleRate"]
    _hx_methods = ["dispose"]

    def __init__(self,driver):
        self.sampleRate = None
        self.samples = None
        self.start = None
        self.isStream = None
        self.isEnd = None
        self.sound = None
        self.end = 0
        self.handle = driver.createBuffer()
        self.refs = 0
        self.lastStop = python_lib_Timeit.default_timer()

    def dispose(self):
        hxd_snd_Manager.get().driver.destroyBuffer(self.handle)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.handle = None
        _hx_o.sound = None
        _hx_o.isEnd = None
        _hx_o.isStream = None
        _hx_o.refs = None
        _hx_o.lastStop = None
        _hx_o.start = None
        _hx_o.end = None
        _hx_o.samples = None
        _hx_o.sampleRate = None
hxd_snd_Buffer._hx_class = hxd_snd_Buffer
_hx_classes["hxd.snd.Buffer"] = hxd_snd_Buffer


class hxd_snd_Manager:
    _hx_class_name = "hxd.snd.Manager"
    _hx_is_interface = "False"
    __slots__ = ("masterVolume", "masterSoundGroup", "masterChannelGroup", "listener", "timeOffset", "updateEvent", "cachedBytes", "resampleBytes", "driver", "channels", "sources", "now", "soundBufferCount", "soundBufferMap", "soundBufferKeys", "freeStreamBuffers", "effectGC", "hasMasterVolume", "suspended", "targetRate", "targetFormat", "targetChannels")
    _hx_fields = ["masterVolume", "masterSoundGroup", "masterChannelGroup", "listener", "timeOffset", "updateEvent", "cachedBytes", "resampleBytes", "driver", "channels", "sources", "now", "soundBufferCount", "soundBufferMap", "soundBufferKeys", "freeStreamBuffers", "effectGC", "hasMasterVolume", "suspended", "targetRate", "targetFormat", "targetChannels"]
    _hx_methods = ["getTmpBytes", "getResampleBytes", "stopAll", "stopAllNotLooping", "stopByName", "getAll", "cleanCache", "dispose", "play", "updateVirtualChannels", "update", "progressiveDecodeBuffer", "queueBuffer", "unqueueBuffer", "bindEffect", "unbindEffect", "releaseSource", "checkTargetFormat", "getSoundBuffer", "fillSoundBuffer", "getStreamBuffer", "sortChannel", "sortEffect", "releaseChannel"]
    _hx_statics = ["STREAM_DURATION", "STREAM_BUFFER_SAMPLE_COUNT", "BUFFER_QUEUE_LENGTH", "MAX_SOURCES", "SOUND_BUFFER_CACHE_SIZE", "VIRTUAL_VOLUME_THRESHOLD", "BUFFER_STREAM_SPLIT", "instance", "get", "regEffect"]

    def __init__(self):
        self.targetChannels = None
        self.targetFormat = None
        self.targetRate = None
        self.hasMasterVolume = None
        self.effectGC = None
        self.freeStreamBuffers = None
        self.soundBufferKeys = None
        self.soundBufferMap = None
        self.soundBufferCount = None
        self.now = None
        self.sources = None
        self.channels = None
        self.resampleBytes = None
        self.cachedBytes = None
        self.updateEvent = None
        self.listener = None
        self.masterChannelGroup = None
        self.masterSoundGroup = None
        self.suspended = False
        self.timeOffset = 0.
        try:
            self.driver = hxd_snd_openal_Driver()
        except BaseException as _g:
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),str):
                self.driver = None
            else:
                raise _g
        self.masterVolume = 1.0
        self.hasMasterVolume = (True if ((self.driver is None)) else self.driver.hasFeature(hxd_snd_DriverFeature.MasterVolume))
        self.masterSoundGroup = hxd_snd_SoundGroup("master")
        self.masterChannelGroup = hxd_snd_ChannelGroup("master")
        self.listener = hxd_snd_Listener()
        self.soundBufferMap = haxe_ds_StringMap()
        self.soundBufferKeys = []
        self.freeStreamBuffers = []
        self.effectGC = []
        self.soundBufferCount = 0
        if (self.driver is not None):
            self.sources = []
            _g = 0
            _g1 = hxd_snd_Manager.MAX_SOURCES
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this = self.sources
                x = hxd_snd_Source(self.driver)
                _this.append(x)
        self.cachedBytes = haxe_io_Bytes.alloc(24)
        self.resampleBytes = haxe_io_Bytes.alloc((hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * 2))

    def getTmpBytes(self,size):
        if (self.cachedBytes.length < size):
            self.cachedBytes = haxe_io_Bytes.alloc(size)
        return self.cachedBytes

    def getResampleBytes(self,size):
        if (self.resampleBytes.length < size):
            self.resampleBytes = haxe_io_Bytes.alloc(size)
        return self.resampleBytes

    def stopAll(self):
        while (self.channels is not None):
            self.channels.stop()

    def stopAllNotLooping(self):
        c = self.channels
        while (c is not None):
            n = c.next
            if (not c.loop):
                c.stop()
            c = n

    def stopByName(self,name):
        c = self.channels
        while (c is not None):
            n = c.next
            if ((c.soundGroup is not None) and ((c.soundGroup.name == name))):
                c.stop()
            c = n

    def getAll(self,sound):
        ch = self.channels
        result = list()
        while (ch is not None):
            if (ch.sound == sound):
                result.append(ch)
            ch = ch.next
        return hxd_impl_ArrayIterator_hxd_snd_Channel(result)

    def cleanCache(self):
        i = 0
        while (i < len(self.soundBufferKeys)):
            k = (self.soundBufferKeys[i] if i >= 0 and i < len(self.soundBufferKeys) else None)
            b = self.soundBufferMap.h.get(k,None)
            i = (i + 1)
            if (b.refs > 0):
                continue
            self.soundBufferMap.remove(k)
            python_internal_ArrayImpl.remove(self.soundBufferKeys,k)
            i = (i - 1)
            b.dispose()
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.soundBufferCount
            _hx_local_2.soundBufferCount = (_hx_local_3 - 1)
            _hx_local_2.soundBufferCount

    def dispose(self):
        self.stopAll()
        if (self.driver is not None):
            _g = 0
            _g1 = self.sources
            while (_g < len(_g1)):
                s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                s.dispose()
            b = self.soundBufferMap.iterator()
            while b.hasNext():
                b1 = b.next()
                b1.dispose()
            _g = 0
            _g1 = self.freeStreamBuffers
            while (_g < len(_g1)):
                b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                b.dispose()
            _g = 0
            _g1 = self.effectGC
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                e.driver.release()
            self.driver.dispose()
        self.sources = None
        self.soundBufferMap = None
        self.soundBufferKeys = None
        self.freeStreamBuffers = None
        self.effectGC = None
        self.updateEvent.stop()
        hxd_snd_Manager.instance = None

    def play(self,sound,channelGroup = None,soundGroup = None):
        if (soundGroup is None):
            soundGroup = self.masterSoundGroup
        if (channelGroup is None):
            channelGroup = self.masterChannelGroup
        sdat = sound.getData()
        if (sdat.samples == 0):
            raise haxe_Exception.thrown((Std.string(sound) + " has no samples"))
        c = hxd_snd_Channel()
        c.sound = sound
        c.duration = sdat.get_duration()
        c.manager = self
        c.soundGroup = soundGroup
        c.channelGroup = channelGroup
        c.next = self.channels
        c.isLoading = sdat.isLoading()
        c.isVirtual = (self.driver is None)
        self.channels = c
        return c

    def updateVirtualChannels(self,now):
        c = self.channels
        while (c is not None):
            if ((c.pause or (not c.isVirtual)) or c.isLoading):
                c = c.next
                continue
            a = (now - c.lastStamp)
            c.set_position((c.position + ((0.0 if ((a < 0.0)) else a))))
            c.lastStamp = now
            next = c.next
            while (c.position >= c.duration):
                c.set_position((c.position - c.duration))
                c.onEnd()
                if ((next is not None) and ((next.manager is None))):
                    next = None
                if (len(c.queue) > 0):
                    _this = c.queue
                    c.sound = (None if ((len(_this) == 0)) else _this.pop(0))
                    c.duration = c.sound.getData().get_duration()
                elif (not c.loop):
                    self.releaseChannel(c)
                    break
            c = next

    def update(self):
        if (self.timeOffset != 0):
            c = self.channels
            while (c is not None):
                c.lastStamp = (c.lastStamp + self.timeOffset)
                if (c.currentFade is not None):
                    _hx_local_1 = c.currentFade
                    _hx_local_2 = _hx_local_1.start
                    _hx_local_1.start = (_hx_local_2 + self.timeOffset)
                    _hx_local_1.start
                c = c.next
            _g = 0
            _g1 = self.sources
            while (_g < len(_g1)):
                s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _g2 = 0
                _g3 = s.buffers
                while (_g2 < len(_g3)):
                    b = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    b.lastStop = (b.lastStop + self.timeOffset)
            self.timeOffset = 0
        self.now = python_lib_Timeit.default_timer()
        if (self.driver is None):
            self.updateVirtualChannels(self.now)
            return
        _g = 0
        _g1 = self.sources
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c = s.channel
            if (c is None):
                continue
            if c.positionChanged:
                self.releaseSource(s)
                continue
            lastBuffer = None
            count = self.driver.getProcessedBuffers(s.handle)
            _g2 = 0
            _g3 = count
            while (_g2 < _g3):
                i = _g2
                _g2 = (_g2 + 1)
                b = self.unqueueBuffer(s)
                if (b is None):
                    continue
                lastBuffer = b
                if b.isEnd:
                    c.sound = b.sound
                    c.duration = b.sound.getData().get_duration()
                    c.set_position(c.duration)
                    c.positionChanged = False
                    c.onEnd()
                    s.start = 0
            if (len(s.buffers) == 0):
                if (not lastBuffer.isEnd):
                    c.set_position((((lastBuffer.start + lastBuffer.samples)) / lastBuffer.sampleRate))
                    self.releaseSource(s)
                elif (len(c.queue) > 0):
                    _this = c.queue
                    c.sound = (None if ((len(_this) == 0)) else _this.pop(0))
                    c.duration = c.sound.getData().get_duration()
                    c.set_position(0)
                    self.releaseSource(s)
                elif c.loop:
                    c.set_position(0)
                    self.releaseSource(s)
                else:
                    self.releaseChannel(c)
                continue
            c.sound = (s.buffers[0] if 0 < len(s.buffers) else None).sound
            c.duration = c.sound.getData().get_duration()
            playedSamples = self.driver.getPlayedSampleCount(s.handle)
            if (playedSamples < 0):
                playedSamples = 0
            c.set_position((playedSamples / (s.buffers[0] if 0 < len(s.buffers) else None).sampleRate))
            c.positionChanged = False
            if (len(s.buffers) < hxd_snd_Manager.BUFFER_QUEUE_LENGTH):
                b1 = python_internal_ArrayImpl._get(s.buffers, (len(s.buffers) - 1))
                if (not b1.isEnd):
                    self.queueBuffer(s,b1.sound,(b1.start + b1.samples))
                elif (len(c.queue) > 0):
                    snd = (c.queue[0] if 0 < len(c.queue) else None)
                    if self.queueBuffer(s,snd,0):
                        _this1 = c.queue
                        if (len(_this1) != 0):
                            _this1.pop(0)
                elif c.loop:
                    self.queueBuffer(s,b1.sound,0)
        c = self.channels
        while (c is not None):
            c.calcAudibleVolume(self.now)
            if (c.isLoading and (not c.sound.getData().isLoading())):
                c.isLoading = False
            c.isVirtual = (((((self.suspended or c.pause) or c.mute) or c.channelGroup.mute) or ((c.allowVirtual and ((c.audibleVolume < hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD))))) or c.isLoading)
            c = c.next
        _hx_list = self.channels
        cmp = self.sortChannel
        tmp = None
        if (_hx_list is None):
            tmp = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p = None
            q = None
            e = None
            tail = None
            while True:
                p = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p is not None):
                    nmerges = (nmerges + 1)
                    q = p
                    psize = 0
                    _g = 0
                    _g1 = insize
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        elif (((qsize == 0) or ((q is None))) or ((cmp(p,q) <= 0))):
                            e = p
                            p = p.next
                            psize = (psize - 1)
                        else:
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            tmp = _hx_list
        self.channels = tmp
        audibleCount = 0
        c = self.channels
        while ((c is not None) and (not c.isVirtual)):
            audibleCount = (audibleCount + 1)
            tmp = audibleCount
            if (tmp > len(self.sources)):
                c.isVirtual = True
            elif (c.soundGroup.maxAudible >= 0):
                if (c.soundGroup.lastUpdate != self.now):
                    c.soundGroup.lastUpdate = self.now
                    c.soundGroup.numAudible = 0
                def _hx_local_15():
                    _hx_local_13 = c.soundGroup
                    _hx_local_14 = _hx_local_13.numAudible
                    _hx_local_13.numAudible = (_hx_local_14 + 1)
                    return _hx_local_13.numAudible
                tmp1 = _hx_local_15()
                if (tmp1 > c.soundGroup.maxAudible):
                    c.isVirtual = True
                    audibleCount = (audibleCount - 1)
            c = c.next
        _g = 0
        _g1 = self.sources
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((s.channel is None) or (not s.channel.isVirtual)):
                continue
            self.releaseSource(s)
        c = self.channels
        while (c is not None):
            if ((c.source is not None) or c.isVirtual):
                c = c.next
                continue
            s = None
            _g = 0
            _g1 = self.sources
            while (_g < len(_g1)):
                s2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (s2.channel is None):
                    s = s2
                    break
            if (s is None):
                raise haxe_Exception.thrown("could not get a source")
            s.channel = c
            c.source = s
            self.checkTargetFormat(c.sound.getData(),c.soundGroup.mono)
            s.start = Math.floor((c.position * self.targetRate))
            if (s.start < 0):
                s.start = 0
            self.queueBuffer(s,c.sound,s.start)
            c.positionChanged = False
            c = c.next
        usedEffects = None
        volume = (1. if (self.hasMasterVolume) else self.masterVolume)
        _g = 0
        _g1 = self.sources
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c = s.channel
            if (c is None):
                continue
            v = (c.currentVolume * volume)
            if (s.volume != v):
                if (v < 0):
                    v = 0
                s.volume = v
                self.driver.setSourceVolume(s.handle,v)
            if (not s.playing):
                self.driver.playSource(s.handle)
                s.playing = True
            i = len(c.bindedEffects)
            while True:
                i = (i - 1)
                tmp = i
                if (not ((tmp >= 0))):
                    break
                e = (c.bindedEffects[i] if i >= 0 and i < len(c.bindedEffects) else None)
                if ((python_internal_ArrayImpl.indexOf(c.effects,e,None) < 0) and ((python_internal_ArrayImpl.indexOf(c.channelGroup.effects,e,None) < 0))):
                    self.unbindEffect(c,s,e)
            _g2 = 0
            _g3 = c.channelGroup.effects
            while (_g2 < len(_g3)):
                e1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                if (python_internal_ArrayImpl.indexOf(c.bindedEffects,e1,None) < 0):
                    self.bindEffect(c,s,e1)
            _g4 = 0
            _g5 = c.effects
            while (_g4 < len(_g5)):
                e2 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                if (python_internal_ArrayImpl.indexOf(c.bindedEffects,e2,None) < 0):
                    self.bindEffect(c,s,e2)
            _g6 = 0
            _g7 = c.bindedEffects
            while (_g6 < len(_g7)):
                e3 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                _g6 = (_g6 + 1)
                usedEffects = hxd_snd_Manager.regEffect(usedEffects,e3)
        _hx_list = usedEffects
        cmp = self.sortEffect
        if (_hx_list is None):
            usedEffects = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p = None
            q = None
            e = None
            tail = None
            while True:
                p = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p is not None):
                    nmerges = (nmerges + 1)
                    q = p
                    psize = 0
                    _g = 0
                    _g1 = insize
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        elif (((qsize == 0) or ((q is None))) or ((cmp(p,q) <= 0))):
                            e = p
                            p = p.next
                            psize = (psize - 1)
                        else:
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            usedEffects = _hx_list
        e = usedEffects
        while (e is not None):
            e.driver.update(e)
            e = e.next
        _g = 0
        _g1 = self.sources
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c = s.channel
            if (c is None):
                continue
            _g2 = 0
            _g3 = c.bindedEffects
            while (_g2 < len(_g3)):
                e = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                e.driver.apply(e,s.handle)
        _g = 0
        _g1 = self.effectGC
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((self.now - e.lastStamp) > e.retainTime):
                e.driver.release()
                python_internal_ArrayImpl.remove(self.effectGC,e)
                break
        self.updateVirtualChannels(self.now)
        _this = self.listener.direction
        k = (((_this.x * _this.x) + ((_this.y * _this.y))) + ((_this.z * _this.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _this.x = (_this.x * k)
        _this.y = (_this.y * k)
        _this.z = (_this.z * k)
        _this = self.listener.up
        k = (((_this.x * _this.x) + ((_this.y * _this.y))) + ((_this.z * _this.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _this.x = (_this.x * k)
        _this.y = (_this.y * k)
        _this.z = (_this.z * k)
        if self.hasMasterVolume:
            self.driver.setMasterVolume(self.masterVolume)
        self.driver.setListenerParams(self.listener.position,self.listener.direction,self.listener.up,self.listener.velocity)
        self.driver.update()
        if (self.soundBufferCount >= hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE):
            now = python_lib_Timeit.default_timer()
            i = 0
            while (i < len(self.soundBufferKeys)):
                k = (self.soundBufferKeys[i] if i >= 0 and i < len(self.soundBufferKeys) else None)
                b = self.soundBufferMap.h.get(k,None)
                i = (i + 1)
                if ((b.refs > 0) or (((b.lastStop + 60.0) > now))):
                    continue
                self.soundBufferMap.remove(k)
                python_internal_ArrayImpl.remove(self.soundBufferKeys,k)
                i = (i - 1)
                b.dispose()
                _hx_local_40 = self
                _hx_local_41 = _hx_local_40.soundBufferCount
                _hx_local_40.soundBufferCount = (_hx_local_41 - 1)
                _hx_local_40.soundBufferCount

    def progressiveDecodeBuffer(self,s,snd,start):
        data = snd.getData()
        samples = Math.ceil((hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT / hxd_snd_Manager.BUFFER_STREAM_SPLIT))
        if ((s.streamStart != start) or ((s.streamSound != snd))):
            s.streamSound = snd
            s.streamStart = start
            s.streamPos = start
        end = (start + hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT)
        if (s.streamPos == end):
            return True
        bpp = data.getBytesPerSample()
        reqSize = (hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * bpp)
        if ((s.streamBuffer is None) or ((s.streamBuffer.length < reqSize))):
            s.streamBuffer = haxe_io_Bytes.alloc(reqSize)
            s.streamPos = start
        remain = (end - s.streamPos)
        if (remain > samples):
            remain = samples
        data.decode(s.streamBuffer,(((s.streamPos - start)) * bpp),s.streamPos,remain)
        s.streamPos = (s.streamPos + remain)
        return (s.streamPos == end)

    def queueBuffer(self,s,snd,start):
        data = snd.getData()
        sgroup = s.channel.soundGroup
        b = None
        if (data.get_duration() <= hxd_snd_Manager.STREAM_DURATION):
            b = self.getSoundBuffer(snd,sgroup)
            self.driver.queueBuffer(s.handle,b.handle,start,True)
        else:
            if (((len(s.buffers) > 0) and ((hxd_snd_Manager.BUFFER_STREAM_SPLIT > 1))) and (not self.progressiveDecodeBuffer(s,snd,start))):
                return False
            b = self.getStreamBuffer(s,snd,sgroup,start)
            self.driver.queueBuffer(s.handle,b.handle,0,b.isEnd)
        _this = s.buffers
        _this.append(b)
        return True

    def unqueueBuffer(self,s):
        _this = s.buffers
        b = (None if ((len(_this) == 0)) else _this.pop(0))
        if (b is None):
            return None
        self.driver.unqueueBuffer(s.handle,b.handle)
        if b.isStream:
            self.freeStreamBuffers.insert(0, b)
        else:
            def _hx_local_1():
                b.refs = (b.refs - 1)
                return b.refs
            tmp = (_hx_local_1() == 0)
            if tmp:
                b.lastStop = python_lib_Timeit.default_timer()
        return b

    def bindEffect(self,c,s,e):
        if ((e.refs == 0) and (not python_internal_ArrayImpl.remove(self.effectGC,e))):
            e.driver.acquire()
        e.refs = (e.refs + 1)
        e.driver.bind(e,s.handle)
        _this = c.bindedEffects
        _this.append(e)

    def unbindEffect(self,c,s,e):
        e.driver.unbind(e,s.handle)
        python_internal_ArrayImpl.remove(c.bindedEffects,e)
        def _hx_local_1():
            e.refs = (e.refs - 1)
            return e.refs
        tmp = (_hx_local_1() == 0)
        if tmp:
            e.lastStamp = self.now
            _this = self.effectGC
            _this.append(e)

    def releaseSource(self,s):
        if (s.channel is not None):
            _g = 0
            _g1 = list(s.channel.bindedEffects)
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.unbindEffect(s.channel,s,e)
            s.channel.bindedEffects = []
            s.channel.source = None
            s.channel = None
        if s.playing:
            s.playing = False
            self.driver.stopSource(s.handle)
            s.volume = -1.0
        while (len(s.buffers) > 0):
            self.unqueueBuffer(s)

    def checkTargetFormat(self,dat,forceMono = None):
        if (forceMono is None):
            forceMono = False
        self.targetRate = dat.samplingRate
        self.targetRate = hxd_snd_openal_Emulator.get_NATIVE_FREQ()
        self.targetChannels = (1 if ((forceMono or ((dat.channels == 1)))) else 2)
        tmp = None
        tmp1 = dat.sampleFormat.index
        if (tmp1 == 0):
            tmp = hxd_snd_SampleFormat.UI8
        elif (tmp1 == 1):
            tmp = hxd_snd_SampleFormat.I16
        elif (tmp1 == 2):
            tmp = hxd_snd_SampleFormat.I16
        else:
            pass
        self.targetFormat = tmp
        if ((self.targetChannels == dat.channels) and ((self.targetFormat == dat.sampleFormat))):
            return (self.targetRate == dat.samplingRate)
        else:
            return False

    def getSoundBuffer(self,snd,grp):
        _gthis = self
        data = snd.getData()
        mono = grp.mono
        key = snd.entry.get_path()
        if (mono and ((data.channels != 1))):
            key = (("null" if key is None else key) + "mono")
        b = self.soundBufferMap.h.get(key,None)
        if (b is None):
            b = hxd_snd_Buffer(self.driver)
            b.isStream = False
            b.isEnd = True
            b.sound = snd
            def _hx_local_1():
                _gthis.fillSoundBuffer(b,data,mono)
            data.load(_hx_local_1)
            self.soundBufferMap.h[key] = b
            _this = self.soundBufferKeys
            _this.append(key)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.soundBufferCount
            _hx_local_2.soundBufferCount = (_hx_local_3 + 1)
            _hx_local_2.soundBufferCount
        b.refs = (b.refs + 1)
        return b

    def fillSoundBuffer(self,buf,dat,forceMono = None):
        if (forceMono is None):
            forceMono = False
        if (not self.checkTargetFormat(dat,forceMono)):
            dat = dat.resample(self.targetRate,self.targetFormat,self.targetChannels)
        length = (dat.samples * dat.getBytesPerSample())
        _hx_bytes = self.getTmpBytes(length)
        dat.decode(_hx_bytes,0,0,dat.samples)
        self.driver.setBufferData(buf.handle,_hx_bytes,length,self.targetFormat,self.targetChannels,self.targetRate)
        buf.sampleRate = self.targetRate
        buf.samples = dat.samples

    def getStreamBuffer(self,src,snd,grp,start):
        data = snd.getData()
        _this = self.freeStreamBuffers
        b = (None if ((len(_this) == 0)) else _this.pop(0))
        if (b is None):
            b = hxd_snd_Buffer(self.driver)
            b.isStream = True
        samples = hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT
        if ((start + samples) >= data.samples):
            samples = (data.samples - start)
            b.isEnd = True
        else:
            b.isEnd = False
        b.sound = snd
        b.samples = samples
        b.start = start
        size = (samples * data.getBytesPerSample())
        _hx_bytes = None
        if ((src.streamSound == snd) and ((src.streamStart == start))):
            while (not self.progressiveDecodeBuffer(src,snd,start)):
                pass
            _hx_bytes = src.streamBuffer
        else:
            _hx_bytes = self.getTmpBytes(size)
            data.decode(_hx_bytes,0,start,samples)
        if (not self.checkTargetFormat(data,grp.mono)):
            size1 = (Math.ceil((samples * ((self.targetRate / data.samplingRate)))) * self.targetChannels)
            size2 = None
            size3 = self.targetFormat.index
            if (size3 == 0):
                size2 = 1
            elif (size3 == 1):
                size2 = 2
            elif (size3 == 2):
                size2 = 4
            else:
                pass
            size = (size1 * size2)
            resampleBytes = self.getResampleBytes(size)
            data.resampleBuffer(resampleBytes,0,_hx_bytes,0,self.targetRate,self.targetFormat,self.targetChannels,samples)
            _hx_bytes = resampleBytes
        self.driver.setBufferData(b.handle,_hx_bytes,size,self.targetFormat,self.targetChannels,self.targetRate)
        b.sampleRate = self.targetRate
        return b

    def sortChannel(self,a,b):
        if (a.isVirtual != b.isVirtual):
            if a.isVirtual:
                return 1
            else:
                return -1
        if (a.channelGroup.priority != b.channelGroup.priority):
            if (a.channelGroup.priority < b.channelGroup.priority):
                return 1
            else:
                return -1
        if (a.priority != b.priority):
            if (a.priority < b.priority):
                return 1
            else:
                return -1
        if (a.audibleVolume != b.audibleVolume):
            if (a.audibleVolume < b.audibleVolume):
                return 1
            else:
                return -1
        if (a.id < b.id):
            return 1
        else:
            return -1

    def sortEffect(self,a,b):
        return (b.priority - a.priority)

    def releaseChannel(self,c):
        if (c.manager is None):
            return
        if (self.channels == c):
            self.channels = c.next
        else:
            prev = self.channels
            while (prev.next != c):
                prev = prev.next
            prev.next = c.next
        _g = 0
        _g1 = c.effects
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.removeEffect(e)
        if (c.source is not None):
            self.releaseSource(c.source)
        c.next = None
        c.manager = None
        c.effects = None
        c.bindedEffects = None
        c.currentFade = None
        snd = c.sound
        if ((snd is not None) and ((snd.channel == c))):
            snd.channel = None
    instance = None

    @staticmethod
    def get():
        if (hxd_snd_Manager.instance is None):
            hxd_snd_Manager.instance = hxd_snd_Manager()
            hxd_snd_Manager.instance.updateEvent = haxe_MainLoop.add(hxd_snd_Manager.instance.update)
            hxd_snd_Manager.instance.updateEvent.isBlocking = False
        return hxd_snd_Manager.instance

    @staticmethod
    def regEffect(_hx_list,e):
        l = _hx_list
        while (l is not None):
            if (l == e):
                return _hx_list
            l = l.next
        e.next = _hx_list
        return e

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.masterVolume = None
        _hx_o.masterSoundGroup = None
        _hx_o.masterChannelGroup = None
        _hx_o.listener = None
        _hx_o.timeOffset = None
        _hx_o.updateEvent = None
        _hx_o.cachedBytes = None
        _hx_o.resampleBytes = None
        _hx_o.driver = None
        _hx_o.channels = None
        _hx_o.sources = None
        _hx_o.now = None
        _hx_o.soundBufferCount = None
        _hx_o.soundBufferMap = None
        _hx_o.soundBufferKeys = None
        _hx_o.freeStreamBuffers = None
        _hx_o.effectGC = None
        _hx_o.hasMasterVolume = None
        _hx_o.suspended = None
        _hx_o.targetRate = None
        _hx_o.targetFormat = None
        _hx_o.targetChannels = None
hxd_snd_Manager._hx_class = hxd_snd_Manager
_hx_classes["hxd.snd.Manager"] = hxd_snd_Manager


class hxd_snd_Mp3Data(hxd_snd_Data):
    _hx_class_name = "hxd.snd.Mp3Data"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["decodeBuffer"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_snd_Data


    def __init__(self,_hx_bytes):
        mp = format_mp3_Reader(haxe_io_BytesInput(_hx_bytes)).read()
        self.samples = mp.sampleCount
        frame = (mp.frames[0] if 0 < len(mp.frames) else None).data
        lame = -1
        _g = 0
        _g1 = (frame.length - 24)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((((frame.b[i] == 76) and ((frame.b[(i + 1)] == 65))) and ((frame.b[(i + 2)] == 77))) and ((frame.b[(i + 3)] == 69))):
                lame = i
                break
        if (lame >= 0):
            startEnd = (((frame.b[(lame + 21)] << 16) | ((frame.b[(lame + 22)] << 8))) | frame.b[(lame + 23)])
            start = (startEnd >> 12)
            end = (startEnd & 4095)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.samples
            _hx_local_0.samples = (_hx_local_1 - (((start + end) + 1152)))
            _hx_local_0.samples
        header = (mp.frames[0] if 0 < len(mp.frames) else None).header
        self.sampleFormat = hxd_snd_SampleFormat.F32
        self.samplingRate = format_mp3_MPEG.srEnum2Num(header.samplingRate)
        self.channels = (1 if ((header.channelMode == format_mp3_ChannelMode.Mono)) else 2)

    def decodeBuffer(self,out,outPos,sampleStart,sampleCount):
        raise haxe_Exception.thrown("MP3 decoding is not available for this platform")

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_snd_Mp3Data._hx_class = hxd_snd_Mp3Data
_hx_classes["hxd.snd.Mp3Data"] = hxd_snd_Mp3Data


class hxd_snd_NativeChannel:
    _hx_class_name = "hxd.snd.NativeChannel"
    _hx_is_interface = "False"
    __slots__ = ("bufferSamples",)
    _hx_fields = ["bufferSamples"]
    _hx_methods = ["onSample", "stop"]

    def __init__(self,bufferSamples):
        self.bufferSamples = bufferSamples

    def onSample(self,out):
        pass

    def stop(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bufferSamples = None
hxd_snd_NativeChannel._hx_class = hxd_snd_NativeChannel
_hx_classes["hxd.snd.NativeChannel"] = hxd_snd_NativeChannel


class hxd_snd_SoundGroup:
    _hx_class_name = "hxd.snd.SoundGroup"
    _hx_is_interface = "False"
    __slots__ = ("name", "volume", "maxAudible", "mono", "numAudible", "lastUpdate")
    _hx_fields = ["name", "volume", "maxAudible", "mono", "numAudible", "lastUpdate"]

    def __init__(self,name):
        self.lastUpdate = None
        self.numAudible = None
        self.name = name
        self.maxAudible = -1
        self.volume = 1
        self.mono = False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.volume = None
        _hx_o.maxAudible = None
        _hx_o.mono = None
        _hx_o.numAudible = None
        _hx_o.lastUpdate = None
hxd_snd_SoundGroup._hx_class = hxd_snd_SoundGroup
_hx_classes["hxd.snd.SoundGroup"] = hxd_snd_SoundGroup


class hxd_snd_WavData(hxd_snd_Data):
    _hx_class_name = "hxd.snd.WavData"
    _hx_is_interface = "False"
    __slots__ = ("rawData",)
    _hx_fields = ["rawData"]
    _hx_methods = ["init", "decodeBuffer"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_snd_Data


    def __init__(self,_hx_bytes):
        self.rawData = None
        if (_hx_bytes is not None):
            self.init(format_wav_Reader(haxe_io_BytesInput(_hx_bytes)).read())

    def init(self,d):
        h = d.header
        self.samplingRate = h.samplingRate
        self.channels = h.channels
        tmp = None
        _g = h.bitsPerSample
        if (_g == 8):
            tmp = hxd_snd_SampleFormat.UI8
        elif (_g == 16):
            tmp = hxd_snd_SampleFormat.I16
        else:
            raise haxe_Exception.thrown((("Unsupported WAV " + Std.string(h.bitsPerSample)) + " bits"))
        self.sampleFormat = tmp
        self.rawData = d.data
        x = (self.rawData.length / self.getBytesPerSample())
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        self.samples = tmp

    def decodeBuffer(self,out,outPos,sampleStart,sampleCount):
        bpp = self.getBytesPerSample()
        out.blit(outPos,self.rawData,(sampleStart * bpp),(sampleCount * bpp))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.rawData = None
hxd_snd_WavData._hx_class = hxd_snd_WavData
_hx_classes["hxd.snd.WavData"] = hxd_snd_WavData


class hxd_snd_openal_BufferHandle:
    _hx_class_name = "hxd.snd.openal.BufferHandle"
    _hx_is_interface = "False"
    __slots__ = ("inst", "isEnd")
    _hx_fields = ["inst", "isEnd"]

    def __init__(self):
        self.isEnd = None
        self.inst = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.inst = None
        _hx_o.isEnd = None
hxd_snd_openal_BufferHandle._hx_class = hxd_snd_openal_BufferHandle
_hx_classes["hxd.snd.openal.BufferHandle"] = hxd_snd_openal_BufferHandle


class hxd_snd_openal_SourceHandle:
    _hx_class_name = "hxd.snd.openal.SourceHandle"
    _hx_is_interface = "False"
    __slots__ = ("inst", "sampleOffset", "playing", "nextAuxiliarySend", "freeAuxiliarySends", "effectToAuxiliarySend")
    _hx_fields = ["inst", "sampleOffset", "playing", "nextAuxiliarySend", "freeAuxiliarySends", "effectToAuxiliarySend"]
    _hx_methods = ["acquireAuxiliarySend", "getAuxiliarySend", "releaseAuxiliarySend"]

    def __init__(self):
        self.playing = None
        self.inst = None
        self.sampleOffset = 0
        self.nextAuxiliarySend = 0
        self.freeAuxiliarySends = []
        self.effectToAuxiliarySend = haxe_ds_ObjectMap()

    def acquireAuxiliarySend(self,effect):
        send = None
        if (len(self.freeAuxiliarySends) > 0):
            _this = self.freeAuxiliarySends
            send = (None if ((len(_this) == 0)) else _this.pop(0))
        else:
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nextAuxiliarySend
                _hx_local_0.nextAuxiliarySend = (_hx_local_1 + 1)
                return _hx_local_1
            send = _hx_local_2()
        self.effectToAuxiliarySend.set(effect,send)
        return send

    def getAuxiliarySend(self,effect):
        return self.effectToAuxiliarySend.h.get(effect,None)

    def releaseAuxiliarySend(self,effect):
        send = self.effectToAuxiliarySend.h.get(effect,None)
        self.effectToAuxiliarySend.remove(effect)
        _this = self.freeAuxiliarySends
        _this.append(send)
        return send

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.inst = None
        _hx_o.sampleOffset = None
        _hx_o.playing = None
        _hx_o.nextAuxiliarySend = None
        _hx_o.freeAuxiliarySends = None
        _hx_o.effectToAuxiliarySend = None
hxd_snd_openal_SourceHandle._hx_class = hxd_snd_openal_SourceHandle
_hx_classes["hxd.snd.openal.SourceHandle"] = hxd_snd_openal_SourceHandle


class hxd_snd_openal_Driver:
    _hx_class_name = "hxd.snd.openal.Driver"
    _hx_is_interface = "False"
    __slots__ = ("device", "context", "maxAuxiliarySends", "tmpBytes")
    _hx_fields = ["device", "context", "maxAuxiliarySends", "tmpBytes"]
    _hx_methods = ["hasFeature", "getTmpBytes", "setMasterVolume", "setListenerParams", "createSource", "destroySource", "playSource", "stopSource", "setSourceVolume", "createBuffer", "destroyBuffer", "setBufferData", "getPlayedSampleCount", "getProcessedBuffers", "queueBuffer", "unqueueBuffer", "update", "dispose", "getEffectDriver"]
    _hx_interfaces = [hxd_snd_Driver]

    def __init__(self):
        self.maxAuxiliarySends = None
        self.context = None
        self.tmpBytes = haxe_io_Bytes.alloc(24)
        self.device = hxd_snd_openal_ALC.openDevice(None)
        self.context = hxd_snd_openal_ALC.createContext(self.device,None)
        hxd_snd_openal_ALC.makeContextCurrent(self.context)
        hxd_snd_openal_ALC.loadExtensions(self.device)
        hxd_snd_openal_Emulator.loadExtensions()
        _hx_bytes = self.getTmpBytes(4)
        hxd_snd_openal_ALC.getIntegerv(self.device,131075,1,_hx_bytes)
        v = (((_hx_bytes.b[0] | ((_hx_bytes.b[1] << 8))) | ((_hx_bytes.b[2] << 16))) | ((_hx_bytes.b[3] << 24)))
        self.maxAuxiliarySends = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        if (hxd_snd_openal_Emulator.getError() != 0):
            raise haxe_Exception.thrown("could not init openAL Driver")

    def hasFeature(self,f):
        return False

    def getTmpBytes(self,size):
        if (self.tmpBytes.length < size):
            self.tmpBytes = haxe_io_Bytes.alloc(size)
        return self.tmpBytes

    def setMasterVolume(self,value):
        hxd_snd_openal_Emulator.listenerf(4106,value)

    def setListenerParams(self,position,direction,up,velocity = None):
        hxd_snd_openal_Emulator.listener3f(4100,-position.x,position.y,position.z)
        _hx_bytes = self.getTmpBytes(24)
        _hx_bytes.setFloat(0,-direction.x)
        _hx_bytes.setFloat(4,direction.y)
        _hx_bytes.setFloat(8,direction.z)
        k = (((up.x * up.x) + ((up.y * up.y))) + ((up.z * up.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        up.x = (up.x * k)
        up.y = (up.y * k)
        up.z = (up.z * k)
        _hx_bytes.setFloat(12,-up.x)
        _hx_bytes.setFloat(16,up.y)
        _hx_bytes.setFloat(20,up.z)
        hxd_snd_openal_Emulator.listenerfv(4111,self.tmpBytes)
        if (velocity is not None):
            hxd_snd_openal_Emulator.listener3f(4102,-velocity.x,velocity.y,velocity.z)

    def createSource(self):
        source = hxd_snd_openal_SourceHandle()
        _hx_bytes = self.getTmpBytes(4)
        hxd_snd_openal_Emulator.genSources(1,_hx_bytes)
        if (hxd_snd_openal_Emulator.getError() != 0):
            raise haxe_Exception.thrown("could not create source")
        v = (((_hx_bytes.b[0] | ((_hx_bytes.b[1] << 8))) | ((_hx_bytes.b[2] << 16))) | ((_hx_bytes.b[3] << 24)))
        source.inst = hxd_snd_openal_Source.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None)
        hxd_snd_openal_Emulator.sourcei(source.inst,514,1)
        return source

    def destroySource(self,source):
        hxd_snd_openal_Emulator.sourcei(source.inst,131077,0)
        _hx_bytes = self.getTmpBytes(4)
        v = source.inst.id
        _hx_bytes.b[0] = (v & 255)
        _hx_bytes.b[1] = ((v >> 8) & 255)
        _hx_bytes.b[2] = ((v >> 16) & 255)
        _hx_bytes.b[3] = (HxOverrides.rshift(v, 24) & 255)
        hxd_snd_openal_Emulator.deleteSources(1,_hx_bytes)

    def playSource(self,source):
        hxd_snd_openal_Emulator.sourcePlay(source.inst)
        source.sampleOffset = 0
        source.playing = True

    def stopSource(self,source):
        hxd_snd_openal_Emulator.sourceStop(source.inst)
        source.playing = False

    def setSourceVolume(self,source,value):
        hxd_snd_openal_Emulator.sourcef(source.inst,4106,value)

    def createBuffer(self):
        buffer = hxd_snd_openal_BufferHandle()
        _hx_bytes = self.getTmpBytes(4)
        hxd_snd_openal_Emulator.genBuffers(1,_hx_bytes)
        v = (((_hx_bytes.b[0] | ((_hx_bytes.b[1] << 8))) | ((_hx_bytes.b[2] << 16))) | ((_hx_bytes.b[3] << 24)))
        buffer.inst = hxd_snd_openal_Buffer.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None)
        return buffer

    def destroyBuffer(self,buffer):
        _hx_bytes = self.getTmpBytes(4)
        v = buffer.inst.id
        _hx_bytes.b[0] = (v & 255)
        _hx_bytes.b[1] = ((v >> 8) & 255)
        _hx_bytes.b[2] = ((v >> 16) & 255)
        _hx_bytes.b[3] = (HxOverrides.rshift(v, 24) & 255)
        hxd_snd_openal_Emulator.deleteBuffers(1,_hx_bytes)

    def setBufferData(self,buffer,data,size,format,channelCount,samplingRate):
        alFormat = None
        alFormat1 = format.index
        if (alFormat1 == 0):
            alFormat = (4352 if ((channelCount == 1)) else 4354)
        elif (alFormat1 == 1):
            alFormat = (4353 if ((channelCount == 1)) else 4355)
        elif (alFormat1 == 2):
            alFormat = (4353 if ((channelCount == 1)) else 4355)
        else:
            pass
        hxd_snd_openal_Emulator.bufferData(buffer.inst,alFormat,data,size,samplingRate)

    def getPlayedSampleCount(self,source):
        v = (source.sampleOffset + hxd_snd_openal_Emulator.getSourcei(source.inst,4133))
        if (v < 0):
            v = 0
        return v

    def getProcessedBuffers(self,source):
        return hxd_snd_openal_Emulator.getSourcei(source.inst,4118)

    def queueBuffer(self,source,buffer,sampleStart,endOfStream):
        _hx_bytes = self.getTmpBytes(4)
        v = buffer.inst.id
        _hx_bytes.b[0] = (v & 255)
        _hx_bytes.b[1] = ((v >> 8) & 255)
        _hx_bytes.b[2] = ((v >> 16) & 255)
        _hx_bytes.b[3] = (HxOverrides.rshift(v, 24) & 255)
        hxd_snd_openal_Emulator.sourceQueueBuffers(source.inst,1,_hx_bytes)
        err = hxd_snd_openal_Emulator.getError()
        if (err != 0):
            raise haxe_Exception.thrown((((("Failed to queue buffers: " + HxOverrides.stringOrNull(StringTools.hex(err))) + " (") + Std.string(buffer.inst.id)) + ")"))
        if (hxd_snd_openal_Emulator.getSourcei(source.inst,4112) == 4116):
            if (sampleStart > 0):
                hxd_snd_openal_Emulator.sourcei(source.inst,4133,sampleStart)
            else:
                hxd_snd_openal_Emulator.sourcei(source.inst,4133,0)
            if source.playing:
                hxd_snd_openal_Emulator.sourcePlay(source.inst)
        buffer.isEnd = endOfStream

    def unqueueBuffer(self,source,buffer):
        _hx_bytes = self.getTmpBytes(4)
        v = buffer.inst.id
        _hx_bytes.b[0] = (v & 255)
        _hx_bytes.b[1] = ((v >> 8) & 255)
        _hx_bytes.b[2] = ((v >> 16) & 255)
        _hx_bytes.b[3] = (HxOverrides.rshift(v, 24) & 255)
        hxd_snd_openal_Emulator.sourceUnqueueBuffers(source.inst,1,_hx_bytes)
        size = hxd_snd_openal_Emulator.getBufferi(buffer.inst,8196)
        bps = ((hxd_snd_openal_Emulator.getBufferi(buffer.inst,8194) * hxd_snd_openal_Emulator.getBufferi(buffer.inst,8195)) / 8)
        samples = None
        try:
            samples = int((size / bps))
        except BaseException as _g:
            None
            samples = None
        samples1 = samples
        if buffer.isEnd:
            source.sampleOffset = 0
        else:
            source.sampleOffset = (source.sampleOffset + samples1)

    def update(self):
        pass

    def dispose(self):
        hxd_snd_openal_ALC.makeContextCurrent(None)
        hxd_snd_openal_ALC.destroyContext(self.context)
        hxd_snd_openal_ALC.closeDevice(self.device)

    def getEffectDriver(self,_hx_type):
        return hxd_snd_EffectDriver()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.device = None
        _hx_o.context = None
        _hx_o.maxAuxiliarySends = None
        _hx_o.tmpBytes = None
hxd_snd_openal_Driver._hx_class = hxd_snd_openal_Driver
_hx_classes["hxd.snd.openal.Driver"] = hxd_snd_openal_Driver


class hxd_snd_openal__Emulator_Channel(hxd_snd_NativeChannel):
    _hx_class_name = "hxd.snd.openal._Emulator.Channel"
    _hx_is_interface = "False"
    __slots__ = ("source", "startup")
    _hx_fields = ["source", "startup"]
    _hx_methods = ["onSample"]
    _hx_statics = ["FADE_START"]
    _hx_interfaces = []
    _hx_super = hxd_snd_NativeChannel


    def __init__(self,source,samples):
        self.startup = 0.
        self.source = source
        super().__init__(samples)

    def onSample(self,out):
        pos = 0
        count = ((out.byteLength >> 2) >> 1)
        if (self.source.duration > 0):
            volume = self.source.volume
            bufferIndex = 0
            baseSample = 0
            curSample = self.source.currentSample
            buffer = bufferIndex
            bufferIndex = (bufferIndex + 1)
            buffer1 = python_internal_ArrayImpl._get(self.source.buffers, buffer)
            while (count > 0):
                while ((buffer1 is not None) and ((curSample >= buffer1.samples))):
                    baseSample = (baseSample + buffer1.samples)
                    curSample = (curSample - buffer1.samples)
                    buffer = bufferIndex
                    bufferIndex = (bufferIndex + 1)
                    buffer1 = python_internal_ArrayImpl._get(self.source.buffers, buffer)
                if (buffer1 is None):
                    if self.source.loop:
                        curSample = 0
                        baseSample = 0
                        bufferIndex = 0
                        buffer2 = bufferIndex
                        bufferIndex = (bufferIndex + 1)
                        buffer1 = python_internal_ArrayImpl._get(self.source.buffers, buffer2)
                        continue
                    break
                scount = (buffer1.samples - curSample)
                if (scount > count):
                    scount = count
                read = (curSample << 1)
                data = buffer1.data
                if (self.startup < 1):
                    _g = 0
                    _g1 = scount
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        index = pos
                        pos = (pos + 1)
                        index1 = read
                        read = (read + 1)
                        value = ((data[index1] * volume) * self.startup)
                        if ((index >= 0) and ((index < ((out.byteLength >> 2))))):
                            out.bytes.setFloat((((index << 2)) + out.byteOffset),value)
                        index2 = pos
                        pos = (pos + 1)
                        index3 = read
                        read = (read + 1)
                        value1 = ((data[index3] * volume) * self.startup)
                        if ((index2 >= 0) and ((index2 < ((out.byteLength >> 2))))):
                            out.bytes.setFloat((((index2 << 2)) + out.byteOffset),value1)
                        if (self.startup < 1.):
                            _hx_local_2 = self
                            _hx_local_3 = _hx_local_2.startup
                            _hx_local_2.startup = (_hx_local_3 + 0.1)
                            _hx_local_2.startup
                            if (self.startup > 1):
                                self.startup = 1
                else:
                    _g2 = 0
                    _g3 = scount
                    while (_g2 < _g3):
                        i1 = _g2
                        _g2 = (_g2 + 1)
                        index4 = pos
                        pos = (pos + 1)
                        index5 = read
                        read = (read + 1)
                        value2 = (data[index5] * volume)
                        if ((index4 >= 0) and ((index4 < ((out.byteLength >> 2))))):
                            out.bytes.setFloat((((index4 << 2)) + out.byteOffset),value2)
                        index6 = pos
                        pos = (pos + 1)
                        index7 = read
                        read = (read + 1)
                        value3 = (data[index7] * volume)
                        if ((index6 >= 0) and ((index6 < ((out.byteLength >> 2))))):
                            out.bytes.setFloat((((index6 << 2)) + out.byteOffset),value3)
                count = (count - scount)
                curSample = (curSample + scount)
            self.source.currentSample = (baseSample + curSample)
            if (self.source.currentSample < 0):
                raise haxe_Exception.thrown(((Std.string(baseSample) + "/") + Std.string(curSample)))
        _g = 0
        _g1 = (count << 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            index = pos
            pos = (pos + 1)
            if ((index >= 0) and ((index < ((out.byteLength >> 2))))):
                out.bytes.setFloat((((index << 2)) + out.byteOffset),0.)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.source = None
        _hx_o.startup = None
hxd_snd_openal__Emulator_Channel._hx_class = hxd_snd_openal__Emulator_Channel
_hx_classes["hxd.snd.openal._Emulator.Channel"] = hxd_snd_openal__Emulator_Channel


class hxd_snd_openal_Source:
    _hx_class_name = "hxd.snd.openal.Source"
    _hx_is_interface = "False"
    __slots__ = ("id", "chan", "playedTime", "currentSample", "buffers", "loop", "volume", "duration", "frequency")
    _hx_fields = ["id", "chan", "playedTime", "currentSample", "buffers", "loop", "volume", "duration", "frequency"]
    _hx_methods = ["updateDuration", "get_playing", "play", "stop", "dispose", "toInt"]
    _hx_statics = ["STOP_DELAY", "CHANNEL_BUFSIZE", "ID", "all", "ofInt"]

    def __init__(self):
        self.frequency = None
        self.duration = None
        self.chan = None
        self.volume = 1.
        self.loop = False
        self.buffers = []
        self.currentSample = 0
        self.playedTime = 0.
        def _hx_local_2():
            _hx_local_0 = hxd_snd_openal_Source
            _hx_local_1 = _hx_local_0.ID
            _hx_local_0.ID = (_hx_local_1 + 1)
            return _hx_local_0.ID
        self.id = _hx_local_2()
        hxd_snd_openal_Source.all.set(self.id,self)

    def updateDuration(self):
        self.frequency = (1 if ((len(self.buffers) == 0)) else (self.buffers[0] if 0 < len(self.buffers) else None).frequency)
        self.duration = 0.
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.duration
            _hx_local_1.duration = (_hx_local_2 + ((b.samples / b.frequency)))
            _hx_local_1.duration

    def get_playing(self):
        return (self.chan is not None)

    def play(self):
        if (self.chan is None):
            self.playedTime = (python_lib_Timeit.default_timer() - ((self.currentSample / self.frequency)))
            self.chan = hxd_snd_openal__Emulator_Channel(self,hxd_snd_openal_Source.CHANNEL_BUFSIZE)

    def stop(self,immediate = None):
        if (immediate is None):
            immediate = False
        if (self.chan is not None):
            self.chan.stop()
            self.chan = None

    def dispose(self):
        self.stop()
        hxd_snd_openal_Source.all.remove(self.id)
        self.id = 0

    def toInt(self):
        return self.id

    @staticmethod
    def ofInt(i):
        return hxd_snd_openal_Source.all.h.get(i,None)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.chan = None
        _hx_o.playedTime = None
        _hx_o.currentSample = None
        _hx_o.buffers = None
        _hx_o.loop = None
        _hx_o.volume = None
        _hx_o.duration = None
        _hx_o.frequency = None
hxd_snd_openal_Source._hx_class = hxd_snd_openal_Source
_hx_classes["hxd.snd.openal.Source"] = hxd_snd_openal_Source


class hxd_snd_openal_Buffer:
    _hx_class_name = "hxd.snd.openal.Buffer"
    _hx_is_interface = "False"
    __slots__ = ("id", "data", "frequency", "samples")
    _hx_fields = ["id", "data", "frequency", "samples"]
    _hx_methods = ["dispose", "alloc", "toInt"]
    _hx_statics = ["ID", "all", "ofInt"]

    def __init__(self):
        self.data = None
        self.samples = 0
        self.frequency = 1
        def _hx_local_2():
            _hx_local_0 = hxd_snd_openal_Buffer
            _hx_local_1 = _hx_local_0.ID
            _hx_local_0.ID = (_hx_local_1 + 1)
            return _hx_local_0.ID
        self.id = _hx_local_2()
        hxd_snd_openal_Buffer.all.set(self.id,self)

    def dispose(self):
        self.data = None
        hxd_snd_openal_Buffer.all.remove(self.id)
        self.id = 0

    def alloc(self,size):
        if ((self.data is None) or ((len(self.data) != size))):
            this1 = [None]*size
            self.data = this1
        return self.data

    def toInt(self):
        return self.id

    @staticmethod
    def ofInt(i):
        return hxd_snd_openal_Buffer.all.h.get(i,None)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.data = None
        _hx_o.frequency = None
        _hx_o.samples = None
hxd_snd_openal_Buffer._hx_class = hxd_snd_openal_Buffer
_hx_classes["hxd.snd.openal.Buffer"] = hxd_snd_openal_Buffer


class hxd_snd_openal_Emulator:
    _hx_class_name = "hxd.snd.openal.Emulator"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["CACHED_FREQ", "get_NATIVE_FREQ", "dopplerFactor", "dopplerVelocity", "speedOfSound", "distanceModel", "enable", "disable", "isEnabled", "getBooleanv", "getIntegerv", "getFloatv", "getDoublev", "getString", "getBoolean", "getInteger", "getFloat", "getDouble", "getError", "loadExtensions", "isExtensionPresent", "getEnumValue", "listenerf", "listener3f", "listenerfv", "listeneri", "listener3i", "listeneriv", "getListenerf", "getListener3f", "getListenerfv", "getListeneri", "getListener3i", "getListeneriv", "genSources", "deleteSources", "isSource", "sourcef", "source3f", "sourcefv", "sourcei", "source3i", "sourceiv", "getSourcef", "getSourcei", "getSource3f", "getSourcefv", "getSource3i", "getSourceiv", "sourcePlayv", "sourceStopv", "sourceRewindv", "sourcePausev", "sourcePlay", "sourceStop", "sourceRewind", "sourcePause", "sourceQueueBuffers", "sourceUnqueueBuffers", "genBuffers", "deleteBuffers", "isBuffer", "bufferData", "bufferf", "buffer3f", "bufferfv", "bufferi", "buffer3i", "bufferiv", "getBufferf", "getBuffer3f", "getBufferfv", "getBufferi", "getBuffer3i", "getBufferiv", "FORMAT_MONOF32", "FORMAT_STEREOF32", "NONE", "FALSE", "TRUE", "SOURCE_RELATIVE", "CONE_INNER_ANGLE", "CONE_OUTER_ANGLE", "PITCH", "POSITION", "DIRECTION", "VELOCITY", "LOOPING", "BUFFER", "GAIN", "MIN_GAIN", "MAX_GAIN", "ORIENTATION", "SOURCE_STATE", "INITIAL", "PLAYING", "PAUSED", "STOPPED", "BUFFERS_QUEUED", "BUFFERS_PROCESSED", "REFERENCE_DISTANCE", "ROLLOFF_FACTOR", "CONE_OUTER_GAIN", "MAX_DISTANCE", "SEC_OFFSET", "SAMPLE_OFFSET", "BYTE_OFFSET", "SOURCE_TYPE", "STATIC", "STREAMING", "UNDETERMINED", "FORMAT_MONO8", "FORMAT_MONO16", "FORMAT_STEREO8", "FORMAT_STEREO16", "FREQUENCY", "BITS", "CHANNELS", "SIZE", "UNUSED", "PENDING", "PROCESSED", "NO_ERROR", "INVALID_NAME", "INVALID_ENUM", "INVALID_VALUE", "INVALID_OPERATION", "OUT_OF_MEMORY", "VENDOR", "VERSION", "RENDERER", "EXTENSIONS", "DOPPLER_FACTOR", "DOPPLER_VELOCITY", "SPEED_OF_SOUND", "DISTANCE_MODEL", "INVERSE_DISTANCE", "INVERSE_DISTANCE_CLAMPED", "LINEAR_DISTANCE", "LINEAR_DISTANCE_CLAMPED", "EXPONENT_DISTANCE", "EXPONENT_DISTANCE_CLAMPED"]
    NATIVE_FREQ = None
    CACHED_FREQ = None

    @staticmethod
    def get_NATIVE_FREQ():
        if (hxd_snd_openal_Emulator.CACHED_FREQ is None):
            hxd_snd_openal_Emulator.CACHED_FREQ = 44100
        return hxd_snd_openal_Emulator.CACHED_FREQ

    @staticmethod
    def dopplerFactor(value):
        pass

    @staticmethod
    def dopplerVelocity(value):
        pass

    @staticmethod
    def speedOfSound(value):
        pass

    @staticmethod
    def distanceModel(distanceModel):
        pass

    @staticmethod
    def enable(capability):
        pass

    @staticmethod
    def disable(capability):
        pass

    @staticmethod
    def isEnabled(capability):
        return False

    @staticmethod
    def getBooleanv(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getIntegerv(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getFloatv(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getDoublev(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getString(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getBoolean(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getInteger(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getFloat(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getDouble(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getError():
        return 0

    @staticmethod
    def loadExtensions():
        pass

    @staticmethod
    def isExtensionPresent(extname):
        return False

    @staticmethod
    def getEnumValue(ename):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def listenerf(param,value):
        pass

    @staticmethod
    def listener3f(param,value1,value2,value3):
        pass

    @staticmethod
    def listenerfv(param,values):
        pass

    @staticmethod
    def listeneri(param,value):
        pass

    @staticmethod
    def listener3i(param,value1,value2,value3):
        pass

    @staticmethod
    def listeneriv(param,values):
        pass

    @staticmethod
    def getListenerf(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getListener3f(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getListenerfv(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getListeneri(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getListener3i(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getListeneriv(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def genSources(n,sources):
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = hxd_snd_openal_Source().id
            sources.b[pos] = (v & 255)
            sources.b[(pos + 1)] = ((v >> 8) & 255)
            sources.b[(pos + 2)] = ((v >> 16) & 255)
            sources.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)

    @staticmethod
    def deleteSources(n,sources):
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = (((sources.b[pos] | ((sources.b[(pos + 1)] << 8))) | ((sources.b[(pos + 2)] << 16))) | ((sources.b[(pos + 3)] << 24)))
            hxd_snd_openal_Source.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None).dispose()

    @staticmethod
    def isSource(source):
        return (source is not None)

    @staticmethod
    def sourcef(source,param,value):
        param1 = param
        if (param1 == 4099):
            pass
        elif (param1 == 4106):
            source.volume = value
        elif (((param1 == 4131) or ((param1 == 4129))) or ((param1 == 4128))):
            pass
        elif (param1 == 4132):
            tmp = None
            if (len(source.buffers) == 0):
                tmp = 0
            else:
                x = (value * source.frequency)
                try:
                    tmp = int(x)
                except BaseException as _g:
                    None
                    tmp = None
            source.currentSample = tmp
            if (source.chan is not None):
                source.stop(True)
                source.play()
        else:
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def source3f(source,param,value1,value2,value3):
        param1 = param
        if (((param1 == 4102) or ((param1 == 4101))) or ((param1 == 4100))):
            pass
        else:
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def sourcefv(source,param,values):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def sourcei(source,param,value):
        param1 = param
        if (param1 == 514):
            pass
        elif (param1 == 4103):
            source.loop = (value != 0)
        elif (param1 == 4105):
            b = hxd_snd_openal_Buffer.all.h.get(value,None)
            source.buffers = ([] if ((b is None)) else [b])
            source.updateDuration()
            source.currentSample = 0
        elif (param1 == 4133):
            x = (hxd_snd_openal_Emulator.getSourcef(source,4132) / source.frequency)
            tmp = None
            try:
                tmp = int(x)
            except BaseException as _g:
                None
                tmp = None
            source.currentSample = tmp
            if (source.chan is not None):
                source.stop(True)
                source.play()
        elif (param1 == 131077):
            pass
        else:
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def source3i(source,param,value1,value2,value3):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def sourceiv(source,param,values):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getSourcef(source,param):
        if (param == 4132):
            if (len(source.buffers) == 0):
                return 0
            now = python_lib_Timeit.default_timer()
            t = (now - source.playedTime)
            maxT = source.duration
            if source.loop:
                while (t > maxT):
                    t = (t - maxT)
                    source.playedTime = (source.playedTime + maxT)
            elif (t > maxT):
                t = maxT
            return t
        else:
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getSourcei(source,param):
        param1 = param
        if (param1 == 4112):
            if (((source.chan is None) or ((len(source.buffers) == 0))) or (((not source.loop) and (((python_lib_Timeit.default_timer() - source.playedTime) >= source.duration))))):
                return 4116
            else:
                return 4114
        elif (param1 == 4118):
            if source.loop:
                return 0
            count = 0
            cur = source.currentSample
            _g = 0
            _g1 = source.buffers
            while (_g < len(_g1)):
                b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (cur >= b.samples):
                    cur = (cur - b.samples)
                    count = (count + 1)
                else:
                    break
            return count
        elif (param1 == 4133):
            x = (hxd_snd_openal_Emulator.getSourcef(source,4132) * source.frequency)
            try:
                return int(x)
            except BaseException as _g:
                None
                return None
        else:
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getSource3f(source,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getSourcefv(source,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getSource3i(source,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getSourceiv(source,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourcePlayv(n,sources):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourceStopv(n,sources):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourceRewindv(n,sources):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourcePausev(n,sources):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourcePlay(source):
        source.play()

    @staticmethod
    def sourceStop(source):
        source.stop()
        source.currentSample = 0

    @staticmethod
    def sourceRewind(source):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourcePause(source):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourceQueueBuffers(source,nb,buffers):
        _g = 0
        _g1 = nb
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i * 4)
            v = (((buffers.b[pos] | ((buffers.b[(pos + 1)] << 8))) | ((buffers.b[(pos + 2)] << 16))) | ((buffers.b[(pos + 3)] << 24)))
            b = hxd_snd_openal_Buffer.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None)
            if (b is None):
                raise haxe_Exception.thrown("assert")
            _this = source.buffers
            _this.append(b)
        source.updateDuration()

    @staticmethod
    def sourceUnqueueBuffers(source,nb,buffers):
        _g = 0
        _g1 = nb
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i * 4)
            v = (((buffers.b[pos] | ((buffers.b[(pos + 1)] << 8))) | ((buffers.b[(pos + 2)] << 16))) | ((buffers.b[(pos + 3)] << 24)))
            b = hxd_snd_openal_Buffer.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None)
            if (b != (source.buffers[0] if 0 < len(source.buffers) else None)):
                raise haxe_Exception.thrown("assert")
            if (source.chan is not None):
                if (source.currentSample < b.samples):
                    raise haxe_Exception.thrown("assert")
                _this = source.buffers
                if (len(_this) != 0):
                    _this.pop(0)
                source.currentSample = (source.currentSample - b.samples)
                source.playedTime = (source.playedTime + ((b.samples / b.frequency)))
            else:
                _this1 = source.buffers
                if (len(_this1) != 0):
                    _this1.pop(0)
            source.updateDuration()

    @staticmethod
    def genBuffers(n,buffers):
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = hxd_snd_openal_Buffer().id
            buffers.b[pos] = (v & 255)
            buffers.b[(pos + 1)] = ((v >> 8) & 255)
            buffers.b[(pos + 2)] = ((v >> 16) & 255)
            buffers.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)

    @staticmethod
    def deleteBuffers(n,buffers):
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = (((buffers.b[pos] | ((buffers.b[(pos + 1)] << 8))) | ((buffers.b[(pos + 2)] << 16))) | ((buffers.b[(pos + 3)] << 24)))
            hxd_snd_openal_Buffer.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None).dispose()

    @staticmethod
    def isBuffer(buffer):
        return (buffer is not None)

    @staticmethod
    def bufferData(buffer,format,data,size,freq):
        if (freq != hxd_snd_openal_Emulator.get_NATIVE_FREQ()):
            raise haxe_Exception.thrown(((("Unsupported frequency value: " + Std.string(freq)) + " should be ") + Std.string(hxd_snd_openal_Emulator.get_NATIVE_FREQ())))
        format1 = format
        if (format1 == 4352):
            bdata = buffer.alloc((size * 2))
            _g = 0
            _g1 = size
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                v = (data.b[i] / 255)
                bdata[(i << 1)] = v
                bdata[((i << 1) | 1)] = v
        elif (format1 == 4353):
            bdata = buffer.alloc(size)
            _g = 0
            _g1 = (size >> 1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                pos = (i << 1)
                v = (data.b[pos] | ((data.b[(pos + 1)] << 8)))
                v1 = (((v if ((((v & 32768)) == 0)) else (v | -65536))) / 32768)
                bdata[(i << 1)] = v1
                bdata[((i << 1) | 1)] = v1
        elif (format1 == 4354):
            bdata = buffer.alloc(size)
            _g = 0
            _g1 = size
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                v = (data.b[i] / 255)
                bdata[i] = v
        elif (format1 == 4355):
            bdata = buffer.alloc((size >> 1))
            _g = 0
            _g1 = (size >> 1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                pos = (i << 1)
                v = (data.b[pos] | ((data.b[(pos + 1)] << 8)))
                v1 = (((v if ((((v & 32768)) == 0)) else (v | -65536))) / 32768)
                bdata[i] = v1
        elif (format1 == 4368):
            bdata = buffer.alloc((size >> 1))
            _g = 0
            _g1 = (size >> 2)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                f = data.getFloat((i << 2))
                bdata[(i << 1)] = f
                bdata[((i << 1) | 1)] = f
        elif (format1 == 4369):
            bdata = buffer.alloc((size >> 2))
            _g = 0
            _g1 = (size >> 2)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                this1 = buffer.data
                val = data.getFloat((i << 2))
                this1[i] = val
        else:
            raise haxe_Exception.thrown(("Format not supported 0x" + HxOverrides.stringOrNull(StringTools.hex(format))))
        buffer.samples = (len(buffer.data) >> 1)
        buffer.frequency = freq

    @staticmethod
    def bufferf(buffer,param,value):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def buffer3f(buffer,param,value1,value2,value3):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def bufferfv(buffer,param,values):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def bufferi(buffer,param,value):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def buffer3i(buffer,param,value1,value2,value3):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def bufferiv(buffer,param,values):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getBufferf(buffer,param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getBuffer3f(buffer,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getBufferfv(buffer,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getBufferi(buffer,param):
        param1 = param
        if (param1 == 8194):
            return 32
        elif (param1 == 8195):
            return 2
        elif (param1 == 8196):
            return (len(buffer.data) * 4)
        else:
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getBuffer3i(buffer,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getBufferiv(buffer,param,values):
        raise haxe_Exception.thrown("TODO")
hxd_snd_openal_Emulator._hx_class = hxd_snd_openal_Emulator
_hx_classes["hxd.snd.openal.Emulator"] = hxd_snd_openal_Emulator


class hxd_snd_openal_Device:
    _hx_class_name = "hxd.snd.openal.Device"
    _hx_is_interface = "False"
    __slots__ = ()

    def __init__(self):
        pass
hxd_snd_openal_Device._hx_class = hxd_snd_openal_Device
_hx_classes["hxd.snd.openal.Device"] = hxd_snd_openal_Device


class hxd_snd_openal_Context:
    _hx_class_name = "hxd.snd.openal.Context"
    _hx_is_interface = "False"
    __slots__ = ("device",)
    _hx_fields = ["device"]

    def __init__(self,d):
        self.device = d

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.device = None
hxd_snd_openal_Context._hx_class = hxd_snd_openal_Context
_hx_classes["hxd.snd.openal.Context"] = hxd_snd_openal_Context


class hxd_snd_openal_ALC:
    _hx_class_name = "hxd.snd.openal.ALC"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ctx", "getError", "createContext", "makeContextCurrent", "processContext", "suspendContext", "destroyContext", "getCurrentContext", "getContextsDevice", "openDevice", "closeDevice", "loadExtensions", "isExtensionPresent", "getEnumValue", "getString", "getIntegerv", "FALSE", "TRUE", "FREQUENCY", "REFRESH", "SYNC", "MONO_SOURCES", "STEREO_SOURCES", "NO_ERROR", "INVALID_DEVICE", "INVALID_CONTEXT", "INVALID_ENUM", "INVALID_VALUE", "OUT_OF_MEMORY", "MAJOR_VERSION", "MINOR_VERSION", "ATTRIBUTES_SIZE", "ALL_ATTRIBUTES", "DEFAULT_DEVICE_SPECIFIER", "DEVICE_SPECIFIER", "EXTENSIONS", "EXT_CAPTURE", "CAPTURE_DEVICE_SPECIFIER", "CAPTURE_DEFAULT_DEVICE_SPECIFIER", "CAPTURE_SAMPLES", "ENUMERATE_ALL_EXT", "DEFAULT_ALL_DEVICES_SPECIFIER", "ALL_DEVICES_SPECIFIER"]

    @staticmethod
    def getError(device):
        return 0

    @staticmethod
    def createContext(device,attrlist):
        return hxd_snd_openal_Context(device)

    @staticmethod
    def makeContextCurrent(context):
        hxd_snd_openal_ALC.ctx = context
        return True

    @staticmethod
    def processContext(context):
        pass

    @staticmethod
    def suspendContext(context):
        pass

    @staticmethod
    def destroyContext(context):
        pass

    @staticmethod
    def getCurrentContext():
        return hxd_snd_openal_ALC.ctx

    @staticmethod
    def getContextsDevice(context):
        return hxd_snd_openal_ALC.ctx.device

    @staticmethod
    def openDevice(devicename):
        return hxd_snd_openal_Device()

    @staticmethod
    def closeDevice(device):
        return True

    @staticmethod
    def loadExtensions(alDevice):
        pass

    @staticmethod
    def isExtensionPresent(device,extname):
        return False

    @staticmethod
    def getEnumValue(device,enumname):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getString(device,param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getIntegerv(device,param,size,values):
        if (param != 131075):
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))
hxd_snd_openal_ALC._hx_class = hxd_snd_openal_ALC
_hx_classes["hxd.snd.openal.ALC"] = hxd_snd_openal_ALC


class hxd_snd_openal_EFX:
    _hx_class_name = "hxd.snd.openal.EFX"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["EFX_MAJOR_VERSION", "EFX_MINOR_VERSION", "MAX_AUXILIARY_SENDS", "METERS_PER_UNIT", "DIRECT_FILTER", "FILTER_NULL"]
hxd_snd_openal_EFX._hx_class = hxd_snd_openal_EFX
_hx_classes["hxd.snd.openal.EFX"] = hxd_snd_openal_EFX

class hxsl_Type(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Type"
    _hx_constructs = ["TVoid", "TInt", "TBool", "TFloat", "TString", "TVec", "TMat3", "TMat4", "TMat3x4", "TBytes", "TSampler2D", "TSampler2DArray", "TSamplerCube", "TStruct", "TFun", "TArray", "TBuffer", "TChannel", "TMat2"]

    @staticmethod
    def TVec(size,t):
        return hxsl_Type("TVec", 5, (size,t))

    @staticmethod
    def TBytes(size):
        return hxsl_Type("TBytes", 9, (size,))

    @staticmethod
    def TStruct(vl):
        return hxsl_Type("TStruct", 13, (vl,))

    @staticmethod
    def TFun(variants):
        return hxsl_Type("TFun", 14, (variants,))

    @staticmethod
    def TArray(t,size):
        return hxsl_Type("TArray", 15, (t,size))

    @staticmethod
    def TBuffer(t,size):
        return hxsl_Type("TBuffer", 16, (t,size))

    @staticmethod
    def TChannel(size):
        return hxsl_Type("TChannel", 17, (size,))
hxsl_Type.TVoid = hxsl_Type("TVoid", 0, ())
hxsl_Type.TInt = hxsl_Type("TInt", 1, ())
hxsl_Type.TBool = hxsl_Type("TBool", 2, ())
hxsl_Type.TFloat = hxsl_Type("TFloat", 3, ())
hxsl_Type.TString = hxsl_Type("TString", 4, ())
hxsl_Type.TMat3 = hxsl_Type("TMat3", 6, ())
hxsl_Type.TMat4 = hxsl_Type("TMat4", 7, ())
hxsl_Type.TMat3x4 = hxsl_Type("TMat3x4", 8, ())
hxsl_Type.TSampler2D = hxsl_Type("TSampler2D", 10, ())
hxsl_Type.TSampler2DArray = hxsl_Type("TSampler2DArray", 11, ())
hxsl_Type.TSamplerCube = hxsl_Type("TSamplerCube", 12, ())
hxsl_Type.TMat2 = hxsl_Type("TMat2", 18, ())
hxsl_Type._hx_class = hxsl_Type
_hx_classes["hxsl.Type"] = hxsl_Type

class hxsl_VecType(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.VecType"
    _hx_constructs = ["VInt", "VFloat", "VBool"]
hxsl_VecType.VInt = hxsl_VecType("VInt", 0, ())
hxsl_VecType.VFloat = hxsl_VecType("VFloat", 1, ())
hxsl_VecType.VBool = hxsl_VecType("VBool", 2, ())
hxsl_VecType._hx_class = hxsl_VecType
_hx_classes["hxsl.VecType"] = hxsl_VecType

class hxsl_SizeDecl(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.SizeDecl"
    _hx_constructs = ["SConst", "SVar"]

    @staticmethod
    def SConst(v):
        return hxsl_SizeDecl("SConst", 0, (v,))

    @staticmethod
    def SVar(v):
        return hxsl_SizeDecl("SVar", 1, (v,))
hxsl_SizeDecl._hx_class = hxsl_SizeDecl
_hx_classes["hxsl.SizeDecl"] = hxsl_SizeDecl


class hxsl_Error:
    _hx_class_name = "hxsl.Error"
    _hx_is_interface = "False"
    __slots__ = ("msg", "pos")
    _hx_fields = ["msg", "pos"]
    _hx_methods = ["toString"]
    _hx_statics = ["t"]

    def __init__(self,msg,pos):
        self.msg = msg
        self.pos = pos

    def toString(self):
        return ((("Error(" + HxOverrides.stringOrNull(self.msg)) + ")@") + Std.string(self.pos))

    @staticmethod
    def t(msg,pos):
        raise haxe_Exception.thrown(hxsl_Error(msg,pos))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.msg = None
        _hx_o.pos = None
hxsl_Error._hx_class = hxsl_Error
_hx_classes["hxsl.Error"] = hxsl_Error

class hxsl_VarKind(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.VarKind"
    _hx_constructs = ["Global", "Input", "Param", "Var", "Local", "Output", "Function"]
hxsl_VarKind.Global = hxsl_VarKind("Global", 0, ())
hxsl_VarKind.Input = hxsl_VarKind("Input", 1, ())
hxsl_VarKind.Param = hxsl_VarKind("Param", 2, ())
hxsl_VarKind.Var = hxsl_VarKind("Var", 3, ())
hxsl_VarKind.Local = hxsl_VarKind("Local", 4, ())
hxsl_VarKind.Output = hxsl_VarKind("Output", 5, ())
hxsl_VarKind.Function = hxsl_VarKind("Function", 6, ())
hxsl_VarKind._hx_class = hxsl_VarKind
_hx_classes["hxsl.VarKind"] = hxsl_VarKind

class hxsl_VarQualifier(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.VarQualifier"
    _hx_constructs = ["Const", "Private", "Nullable", "PerObject", "Name", "Shared", "Precision", "Range", "Ignore", "PerInstance", "Doc", "Borrow", "Sampler"]

    @staticmethod
    def Const(max = None):
        return hxsl_VarQualifier("Const", 0, (max,))

    @staticmethod
    def Name(n):
        return hxsl_VarQualifier("Name", 4, (n,))

    @staticmethod
    def Precision(p):
        return hxsl_VarQualifier("Precision", 6, (p,))

    @staticmethod
    def Range(min,max):
        return hxsl_VarQualifier("Range", 7, (min,max))

    @staticmethod
    def PerInstance(v):
        return hxsl_VarQualifier("PerInstance", 9, (v,))

    @staticmethod
    def Doc(s):
        return hxsl_VarQualifier("Doc", 10, (s,))

    @staticmethod
    def Borrow(source):
        return hxsl_VarQualifier("Borrow", 11, (source,))

    @staticmethod
    def Sampler(name):
        return hxsl_VarQualifier("Sampler", 12, (name,))
hxsl_VarQualifier.Private = hxsl_VarQualifier("Private", 1, ())
hxsl_VarQualifier.Nullable = hxsl_VarQualifier("Nullable", 2, ())
hxsl_VarQualifier.PerObject = hxsl_VarQualifier("PerObject", 3, ())
hxsl_VarQualifier.Shared = hxsl_VarQualifier("Shared", 5, ())
hxsl_VarQualifier.Ignore = hxsl_VarQualifier("Ignore", 8, ())
hxsl_VarQualifier._hx_class = hxsl_VarQualifier
_hx_classes["hxsl.VarQualifier"] = hxsl_VarQualifier

class hxsl_Prec(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Prec"
    _hx_constructs = ["Low", "Medium", "High"]
hxsl_Prec.Low = hxsl_Prec("Low", 0, ())
hxsl_Prec.Medium = hxsl_Prec("Medium", 1, ())
hxsl_Prec.High = hxsl_Prec("High", 2, ())
hxsl_Prec._hx_class = hxsl_Prec
_hx_classes["hxsl.Prec"] = hxsl_Prec

class hxsl_Const(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Const"
    _hx_constructs = ["CNull", "CBool", "CInt", "CFloat", "CString"]

    @staticmethod
    def CBool(b):
        return hxsl_Const("CBool", 1, (b,))

    @staticmethod
    def CInt(v):
        return hxsl_Const("CInt", 2, (v,))

    @staticmethod
    def CFloat(v):
        return hxsl_Const("CFloat", 3, (v,))

    @staticmethod
    def CString(v):
        return hxsl_Const("CString", 4, (v,))
hxsl_Const.CNull = hxsl_Const("CNull", 0, ())
hxsl_Const._hx_class = hxsl_Const
_hx_classes["hxsl.Const"] = hxsl_Const

class hxsl_ExprDef(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.ExprDef"
    _hx_constructs = ["EConst", "EIdent", "EParenthesis", "EField", "EBinop", "EUnop", "ECall", "EBlock", "EVars", "EFunction", "EIf", "EDiscard", "EFor", "EReturn", "EBreak", "EContinue", "EArray", "EArrayDecl", "ESwitch", "EWhile", "EMeta"]

    @staticmethod
    def EConst(c):
        return hxsl_ExprDef("EConst", 0, (c,))

    @staticmethod
    def EIdent(i):
        return hxsl_ExprDef("EIdent", 1, (i,))

    @staticmethod
    def EParenthesis(e):
        return hxsl_ExprDef("EParenthesis", 2, (e,))

    @staticmethod
    def EField(e,f):
        return hxsl_ExprDef("EField", 3, (e,f))

    @staticmethod
    def EBinop(op,e1,e2):
        return hxsl_ExprDef("EBinop", 4, (op,e1,e2))

    @staticmethod
    def EUnop(op,e1):
        return hxsl_ExprDef("EUnop", 5, (op,e1))

    @staticmethod
    def ECall(e,args):
        return hxsl_ExprDef("ECall", 6, (e,args))

    @staticmethod
    def EBlock(el):
        return hxsl_ExprDef("EBlock", 7, (el,))

    @staticmethod
    def EVars(v):
        return hxsl_ExprDef("EVars", 8, (v,))

    @staticmethod
    def EFunction(f):
        return hxsl_ExprDef("EFunction", 9, (f,))

    @staticmethod
    def EIf(econd,eif,eelse):
        return hxsl_ExprDef("EIf", 10, (econd,eif,eelse))

    @staticmethod
    def EFor(v,loop,block):
        return hxsl_ExprDef("EFor", 12, (v,loop,block))

    @staticmethod
    def EReturn(e = None):
        return hxsl_ExprDef("EReturn", 13, (e,))

    @staticmethod
    def EArray(e,eindex):
        return hxsl_ExprDef("EArray", 16, (e,eindex))

    @staticmethod
    def EArrayDecl(el):
        return hxsl_ExprDef("EArrayDecl", 17, (el,))

    @staticmethod
    def ESwitch(e,cases,_hx_def):
        return hxsl_ExprDef("ESwitch", 18, (e,cases,_hx_def))

    @staticmethod
    def EWhile(cond,loop,normalWhile):
        return hxsl_ExprDef("EWhile", 19, (cond,loop,normalWhile))

    @staticmethod
    def EMeta(name,args,e):
        return hxsl_ExprDef("EMeta", 20, (name,args,e))
hxsl_ExprDef.EDiscard = hxsl_ExprDef("EDiscard", 11, ())
hxsl_ExprDef.EBreak = hxsl_ExprDef("EBreak", 14, ())
hxsl_ExprDef.EContinue = hxsl_ExprDef("EContinue", 15, ())
hxsl_ExprDef._hx_class = hxsl_ExprDef
_hx_classes["hxsl.ExprDef"] = hxsl_ExprDef

class hxsl_FunctionKind(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.FunctionKind"
    _hx_constructs = ["Vertex", "Fragment", "Init", "Helper"]
hxsl_FunctionKind.Vertex = hxsl_FunctionKind("Vertex", 0, ())
hxsl_FunctionKind.Fragment = hxsl_FunctionKind("Fragment", 1, ())
hxsl_FunctionKind.Init = hxsl_FunctionKind("Init", 2, ())
hxsl_FunctionKind.Helper = hxsl_FunctionKind("Helper", 3, ())
hxsl_FunctionKind._hx_class = hxsl_FunctionKind
_hx_classes["hxsl.FunctionKind"] = hxsl_FunctionKind

class hxsl_TGlobal(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.TGlobal"
    _hx_constructs = ["Radians", "Degrees", "Sin", "Cos", "Tan", "Asin", "Acos", "Atan", "Pow", "Exp", "Log", "Exp2", "Log2", "Sqrt", "Inversesqrt", "Abs", "Sign", "Floor", "Ceil", "Fract", "Mod", "Min", "Max", "Clamp", "Mix", "Step", "Smoothstep", "Length", "Distance", "Dot", "Cross", "Normalize", "LReflect", "Texture", "TextureLod", "Texel", "TextureSize", "ToInt", "ToFloat", "ToBool", "Vec2", "Vec3", "Vec4", "IVec2", "IVec3", "IVec4", "BVec2", "BVec3", "BVec4", "Mat2", "Mat3", "Mat4", "Mat3x4", "Saturate", "Pack", "Unpack", "PackNormal", "UnpackNormal", "ScreenToUv", "UvToScreen", "DFdx", "DFdy", "Fwidth", "ChannelRead", "ChannelReadLod", "ChannelFetch", "ChannelTextureSize", "Trace", "VertexID", "InstanceID", "FragCoord", "FrontFacing"]
hxsl_TGlobal.Radians = hxsl_TGlobal("Radians", 0, ())
hxsl_TGlobal.Degrees = hxsl_TGlobal("Degrees", 1, ())
hxsl_TGlobal.Sin = hxsl_TGlobal("Sin", 2, ())
hxsl_TGlobal.Cos = hxsl_TGlobal("Cos", 3, ())
hxsl_TGlobal.Tan = hxsl_TGlobal("Tan", 4, ())
hxsl_TGlobal.Asin = hxsl_TGlobal("Asin", 5, ())
hxsl_TGlobal.Acos = hxsl_TGlobal("Acos", 6, ())
hxsl_TGlobal.Atan = hxsl_TGlobal("Atan", 7, ())
hxsl_TGlobal.Pow = hxsl_TGlobal("Pow", 8, ())
hxsl_TGlobal.Exp = hxsl_TGlobal("Exp", 9, ())
hxsl_TGlobal.Log = hxsl_TGlobal("Log", 10, ())
hxsl_TGlobal.Exp2 = hxsl_TGlobal("Exp2", 11, ())
hxsl_TGlobal.Log2 = hxsl_TGlobal("Log2", 12, ())
hxsl_TGlobal.Sqrt = hxsl_TGlobal("Sqrt", 13, ())
hxsl_TGlobal.Inversesqrt = hxsl_TGlobal("Inversesqrt", 14, ())
hxsl_TGlobal.Abs = hxsl_TGlobal("Abs", 15, ())
hxsl_TGlobal.Sign = hxsl_TGlobal("Sign", 16, ())
hxsl_TGlobal.Floor = hxsl_TGlobal("Floor", 17, ())
hxsl_TGlobal.Ceil = hxsl_TGlobal("Ceil", 18, ())
hxsl_TGlobal.Fract = hxsl_TGlobal("Fract", 19, ())
hxsl_TGlobal.Mod = hxsl_TGlobal("Mod", 20, ())
hxsl_TGlobal.Min = hxsl_TGlobal("Min", 21, ())
hxsl_TGlobal.Max = hxsl_TGlobal("Max", 22, ())
hxsl_TGlobal.Clamp = hxsl_TGlobal("Clamp", 23, ())
hxsl_TGlobal.Mix = hxsl_TGlobal("Mix", 24, ())
hxsl_TGlobal.Step = hxsl_TGlobal("Step", 25, ())
hxsl_TGlobal.Smoothstep = hxsl_TGlobal("Smoothstep", 26, ())
hxsl_TGlobal.Length = hxsl_TGlobal("Length", 27, ())
hxsl_TGlobal.Distance = hxsl_TGlobal("Distance", 28, ())
hxsl_TGlobal.Dot = hxsl_TGlobal("Dot", 29, ())
hxsl_TGlobal.Cross = hxsl_TGlobal("Cross", 30, ())
hxsl_TGlobal.Normalize = hxsl_TGlobal("Normalize", 31, ())
hxsl_TGlobal.LReflect = hxsl_TGlobal("LReflect", 32, ())
hxsl_TGlobal.Texture = hxsl_TGlobal("Texture", 33, ())
hxsl_TGlobal.TextureLod = hxsl_TGlobal("TextureLod", 34, ())
hxsl_TGlobal.Texel = hxsl_TGlobal("Texel", 35, ())
hxsl_TGlobal.TextureSize = hxsl_TGlobal("TextureSize", 36, ())
hxsl_TGlobal.ToInt = hxsl_TGlobal("ToInt", 37, ())
hxsl_TGlobal.ToFloat = hxsl_TGlobal("ToFloat", 38, ())
hxsl_TGlobal.ToBool = hxsl_TGlobal("ToBool", 39, ())
hxsl_TGlobal.Vec2 = hxsl_TGlobal("Vec2", 40, ())
hxsl_TGlobal.Vec3 = hxsl_TGlobal("Vec3", 41, ())
hxsl_TGlobal.Vec4 = hxsl_TGlobal("Vec4", 42, ())
hxsl_TGlobal.IVec2 = hxsl_TGlobal("IVec2", 43, ())
hxsl_TGlobal.IVec3 = hxsl_TGlobal("IVec3", 44, ())
hxsl_TGlobal.IVec4 = hxsl_TGlobal("IVec4", 45, ())
hxsl_TGlobal.BVec2 = hxsl_TGlobal("BVec2", 46, ())
hxsl_TGlobal.BVec3 = hxsl_TGlobal("BVec3", 47, ())
hxsl_TGlobal.BVec4 = hxsl_TGlobal("BVec4", 48, ())
hxsl_TGlobal.Mat2 = hxsl_TGlobal("Mat2", 49, ())
hxsl_TGlobal.Mat3 = hxsl_TGlobal("Mat3", 50, ())
hxsl_TGlobal.Mat4 = hxsl_TGlobal("Mat4", 51, ())
hxsl_TGlobal.Mat3x4 = hxsl_TGlobal("Mat3x4", 52, ())
hxsl_TGlobal.Saturate = hxsl_TGlobal("Saturate", 53, ())
hxsl_TGlobal.Pack = hxsl_TGlobal("Pack", 54, ())
hxsl_TGlobal.Unpack = hxsl_TGlobal("Unpack", 55, ())
hxsl_TGlobal.PackNormal = hxsl_TGlobal("PackNormal", 56, ())
hxsl_TGlobal.UnpackNormal = hxsl_TGlobal("UnpackNormal", 57, ())
hxsl_TGlobal.ScreenToUv = hxsl_TGlobal("ScreenToUv", 58, ())
hxsl_TGlobal.UvToScreen = hxsl_TGlobal("UvToScreen", 59, ())
hxsl_TGlobal.DFdx = hxsl_TGlobal("DFdx", 60, ())
hxsl_TGlobal.DFdy = hxsl_TGlobal("DFdy", 61, ())
hxsl_TGlobal.Fwidth = hxsl_TGlobal("Fwidth", 62, ())
hxsl_TGlobal.ChannelRead = hxsl_TGlobal("ChannelRead", 63, ())
hxsl_TGlobal.ChannelReadLod = hxsl_TGlobal("ChannelReadLod", 64, ())
hxsl_TGlobal.ChannelFetch = hxsl_TGlobal("ChannelFetch", 65, ())
hxsl_TGlobal.ChannelTextureSize = hxsl_TGlobal("ChannelTextureSize", 66, ())
hxsl_TGlobal.Trace = hxsl_TGlobal("Trace", 67, ())
hxsl_TGlobal.VertexID = hxsl_TGlobal("VertexID", 68, ())
hxsl_TGlobal.InstanceID = hxsl_TGlobal("InstanceID", 69, ())
hxsl_TGlobal.FragCoord = hxsl_TGlobal("FragCoord", 70, ())
hxsl_TGlobal.FrontFacing = hxsl_TGlobal("FrontFacing", 71, ())
hxsl_TGlobal._hx_class = hxsl_TGlobal
_hx_classes["hxsl.TGlobal"] = hxsl_TGlobal

class hxsl_Component(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Component"
    _hx_constructs = ["X", "Y", "Z", "W"]
hxsl_Component.X = hxsl_Component("X", 0, ())
hxsl_Component.Y = hxsl_Component("Y", 1, ())
hxsl_Component.Z = hxsl_Component("Z", 2, ())
hxsl_Component.W = hxsl_Component("W", 3, ())
hxsl_Component._hx_class = hxsl_Component
_hx_classes["hxsl.Component"] = hxsl_Component

class hxsl_TExprDef(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.TExprDef"
    _hx_constructs = ["TConst", "TVar", "TGlobal", "TParenthesis", "TBlock", "TBinop", "TUnop", "TVarDecl", "TCall", "TSwiz", "TIf", "TDiscard", "TReturn", "TFor", "TContinue", "TBreak", "TArray", "TArrayDecl", "TSwitch", "TWhile", "TMeta"]

    @staticmethod
    def TConst(c):
        return hxsl_TExprDef("TConst", 0, (c,))

    @staticmethod
    def TVar(v):
        return hxsl_TExprDef("TVar", 1, (v,))

    @staticmethod
    def TGlobal(g):
        return hxsl_TExprDef("TGlobal", 2, (g,))

    @staticmethod
    def TParenthesis(e):
        return hxsl_TExprDef("TParenthesis", 3, (e,))

    @staticmethod
    def TBlock(el):
        return hxsl_TExprDef("TBlock", 4, (el,))

    @staticmethod
    def TBinop(op,e1,e2):
        return hxsl_TExprDef("TBinop", 5, (op,e1,e2))

    @staticmethod
    def TUnop(op,e1):
        return hxsl_TExprDef("TUnop", 6, (op,e1))

    @staticmethod
    def TVarDecl(v,init = None):
        return hxsl_TExprDef("TVarDecl", 7, (v,init))

    @staticmethod
    def TCall(e,args):
        return hxsl_TExprDef("TCall", 8, (e,args))

    @staticmethod
    def TSwiz(e,regs):
        return hxsl_TExprDef("TSwiz", 9, (e,regs))

    @staticmethod
    def TIf(econd,eif,eelse):
        return hxsl_TExprDef("TIf", 10, (econd,eif,eelse))

    @staticmethod
    def TReturn(e = None):
        return hxsl_TExprDef("TReturn", 12, (e,))

    @staticmethod
    def TFor(v,it,loop):
        return hxsl_TExprDef("TFor", 13, (v,it,loop))

    @staticmethod
    def TArray(e,index):
        return hxsl_TExprDef("TArray", 16, (e,index))

    @staticmethod
    def TArrayDecl(el):
        return hxsl_TExprDef("TArrayDecl", 17, (el,))

    @staticmethod
    def TSwitch(e,cases,_hx_def):
        return hxsl_TExprDef("TSwitch", 18, (e,cases,_hx_def))

    @staticmethod
    def TWhile(e,loop,normalWhile):
        return hxsl_TExprDef("TWhile", 19, (e,loop,normalWhile))

    @staticmethod
    def TMeta(m,args,e):
        return hxsl_TExprDef("TMeta", 20, (m,args,e))
hxsl_TExprDef.TDiscard = hxsl_TExprDef("TDiscard", 11, ())
hxsl_TExprDef.TContinue = hxsl_TExprDef("TContinue", 14, ())
hxsl_TExprDef.TBreak = hxsl_TExprDef("TBreak", 15, ())
hxsl_TExprDef._hx_class = hxsl_TExprDef
_hx_classes["hxsl.TExprDef"] = hxsl_TExprDef


class hxsl_Tools:
    _hx_class_name = "hxsl.Tools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["UID", "SWIZ", "MAX_CHANNELS_BITS", "allocVarId", "getName", "getDoc", "getConstBits", "isConst", "isStruct", "isArray", "hasQualifier", "hasBorrowQualifier", "isSampler", "toString", "toType", "hasSideEffect", "iter", "map", "size", "evalConst"]

    @staticmethod
    def allocVarId():
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = hxsl_Tools
                _hx_local_1 = _hx_local_0.UID
                _hx_local_0.UID = (_hx_local_1 + 1)
                return _hx_local_0.UID
            return _hx_local_2()
        return _hx_local_3()

    @staticmethod
    def getName(v):
        if (Reflect.field(v,"qualifiers") is None):
            return v.name
        _g = 0
        _g1 = Reflect.field(v,"qualifiers")
        while (_g < len(_g1)):
            q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (q.index == 4):
                n = q.params[0]
                return n
        return v.name

    @staticmethod
    def getDoc(v):
        if (Reflect.field(v,"qualifiers") is None):
            return None
        _g = 0
        _g1 = Reflect.field(v,"qualifiers")
        while (_g < len(_g1)):
            q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (q.index == 10):
                s = q.params[0]
                return s
        return None

    @staticmethod
    def getConstBits(v):
        _g = v.type
        tmp = _g.index
        if (tmp == 1):
            _g1 = 0
            _g2 = Reflect.field(v,"qualifiers")
            while (_g1 < len(_g2)):
                q = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                if (q.index == 0):
                    n = q.params[0]
                    if (n is not None):
                        bits = 0
                        while (n >= ((1 << bits))):
                            bits = (bits + 1)
                        return bits
                    return 8
        elif (tmp == 2):
            return 1
        elif (tmp == 17):
            _g1 = _g.params[0]
            return (3 + hxsl_Tools.MAX_CHANNELS_BITS)
        else:
            pass
        return 0

    @staticmethod
    def isConst(v):
        _g = v.type
        tmp = None
        if (_g.index == 17):
            _g1 = _g.params[0]
            tmp = True
        else:
            tmp = False
        if tmp:
            return True
        if (Reflect.field(v,"qualifiers") is not None):
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (q.index == 0):
                    _g2 = q.params[0]
                    return True
        return False

    @staticmethod
    def isStruct(v):
        _g = v.type
        if (_g.index == 13):
            _g1 = _g.params[0]
            return True
        else:
            return False

    @staticmethod
    def isArray(v):
        _g = v.type
        if (_g.index == 15):
            _g1 = _g.params[0]
            _g1 = _g.params[1]
            return True
        else:
            return False

    @staticmethod
    def hasQualifier(v,q):
        if (Reflect.field(v,"qualifiers") is not None):
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (q2 == q):
                    return True
        return False

    @staticmethod
    def hasBorrowQualifier(v,path):
        if (Reflect.field(v,"qualifiers") is not None):
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (q.index == 11):
                    s = q.params[0]
                    return (path == s)
        return False

    @staticmethod
    def isSampler(t):
        tmp = t.index
        if (((tmp == 12) or ((tmp == 11))) or ((tmp == 10))):
            return True
        elif (tmp == 17):
            _g = t.params[0]
            return True
        else:
            return False

    @staticmethod
    def toString(t):
        tmp = t.index
        if (tmp == 5):
            size = t.params[0]
            t1 = t.params[1]
            prefix = None
            prefix1 = t1.index
            if (prefix1 == 0):
                prefix = "I"
            elif (prefix1 == 1):
                prefix = ""
            elif (prefix1 == 2):
                prefix = "B"
            else:
                pass
            return ((("null" if prefix is None else prefix) + "Vec") + Std.string(size))
        elif (tmp == 9):
            n = t.params[0]
            return ("Bytes" + Std.string(n))
        elif (tmp == 13):
            vl = t.params[0]
            _g = []
            _g1 = 0
            while (_g1 < len(vl)):
                v = (vl[_g1] if _g1 >= 0 and _g1 < len(vl) else None)
                _g1 = (_g1 + 1)
                x = ((HxOverrides.stringOrNull(v.name) + " : ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v.type)))
                _g.append(x)
            return (("{" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))) + "}")
        elif (tmp == 15):
            t1 = t.params[0]
            s = t.params[1]
            tmp = (HxOverrides.stringOrNull(hxsl_Tools.toString(t1)) + "[")
            tmp1 = None
            tmp2 = s.index
            if (tmp2 == 0):
                i = s.params[0]
                tmp1 = ("" + Std.string(i))
            elif (tmp2 == 1):
                v = s.params[0]
                tmp1 = v.name
            else:
                pass
            return ((("null" if tmp is None else tmp) + ("null" if tmp1 is None else tmp1)) + "]")
        elif (tmp == 16):
            t1 = t.params[0]
            s = t.params[1]
            tmp = (("buffer " + HxOverrides.stringOrNull(hxsl_Tools.toString(t1))) + "[")
            tmp1 = None
            tmp2 = s.index
            if (tmp2 == 0):
                i = s.params[0]
                tmp1 = ("" + Std.string(i))
            elif (tmp2 == 1):
                v = s.params[0]
                tmp1 = v.name
            else:
                pass
            return ((("null" if tmp is None else tmp) + ("null" if tmp1 is None else tmp1)) + "]")
        else:
            return HxString.substr(t.tag,1,None)

    @staticmethod
    def toType(t):
        tmp = t.index
        if (tmp == 0):
            return hxsl_Type.TInt
        elif (tmp == 1):
            return hxsl_Type.TFloat
        elif (tmp == 2):
            return hxsl_Type.TBool
        else:
            pass

    @staticmethod
    def hasSideEffect(e):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            _g1 = _g.params[0]
            return False
        elif (tmp == 1):
            _g1 = _g.params[0]
            return False
        elif (tmp == 2):
            _g1 = _g.params[0]
            return False
        elif (tmp == 3):
            e = _g.params[0]
            return hxsl_Tools.hasSideEffect(e)
        elif (tmp == 4):
            el = _g.params[0]
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                if hxsl_Tools.hasSideEffect(e):
                    return True
            return False
        elif (tmp == 5):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g.params[2]
            tmp = _g1.index
            if (tmp == 4):
                return True
            elif (tmp == 20):
                _g4 = _g1.params[0]
                return True
            else:
                e1 = _g2
                e2 = _g3
                if (not hxsl_Tools.hasSideEffect(e1)):
                    return hxsl_Tools.hasSideEffect(e2)
                else:
                    return True
        elif (tmp == 6):
            _g1 = _g.params[0]
            e1 = _g.params[1]
            return hxsl_Tools.hasSideEffect(e1)
        elif (tmp == 7):
            _g1 = _g.params[0]
            _g1 = _g.params[1]
            return True
        elif (tmp == 8):
            e = _g.params[0]
            pl = _g.params[1]
            _g1 = e.e
            tmp = None
            if (_g1.index == 2):
                _g2 = _g1.params[0]
                tmp = True
            else:
                tmp = False
            if (not tmp):
                return True
            _g1 = 0
            while (_g1 < len(pl)):
                p = (pl[_g1] if _g1 >= 0 and _g1 < len(pl) else None)
                _g1 = (_g1 + 1)
                if hxsl_Tools.hasSideEffect(p):
                    return True
            return False
        elif (tmp == 9):
            _g1 = _g.params[1]
            e = _g.params[0]
            return hxsl_Tools.hasSideEffect(e)
        elif (tmp == 10):
            econd = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            if (not ((hxsl_Tools.hasSideEffect(econd) or hxsl_Tools.hasSideEffect(eif)))):
                if (eelse is not None):
                    return hxsl_Tools.hasSideEffect(eelse)
                else:
                    return False
            else:
                return True
        elif (((tmp == 15) or ((tmp == 14))) or ((tmp == 11))):
            return True
        elif (tmp == 12):
            _g1 = _g.params[0]
            return True
        elif (tmp == 13):
            _g1 = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            if (not hxsl_Tools.hasSideEffect(it)):
                return hxsl_Tools.hasSideEffect(loop)
            else:
                return True
        elif (tmp == 16):
            e = _g.params[0]
            index = _g.params[1]
            if (not hxsl_Tools.hasSideEffect(e)):
                return hxsl_Tools.hasSideEffect(index)
            else:
                return True
        elif (tmp == 17):
            el = _g.params[0]
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                if hxsl_Tools.hasSideEffect(e):
                    return True
            return False
        elif (tmp == 18):
            e = _g.params[0]
            cases = _g.params[1]
            _hx_def = _g.params[2]
            _g1 = 0
            while (_g1 < len(cases)):
                c = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
                _g1 = (_g1 + 1)
                _g2 = 0
                _g3 = c.values
                while (_g2 < len(_g3)):
                    v = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if hxsl_Tools.hasSideEffect(v):
                        return True
                if hxsl_Tools.hasSideEffect(c.expr):
                    return True
            if (not hxsl_Tools.hasSideEffect(e)):
                if (_hx_def is not None):
                    return hxsl_Tools.hasSideEffect(_hx_def)
                else:
                    return False
            else:
                return True
        elif (tmp == 19):
            _g1 = _g.params[2]
            e = _g.params[0]
            loop = _g.params[1]
            if (not hxsl_Tools.hasSideEffect(e)):
                return hxsl_Tools.hasSideEffect(loop)
            else:
                return True
        elif (tmp == 20):
            _g1 = _g.params[0]
            _g1 = _g.params[1]
            e = _g.params[2]
            return hxsl_Tools.hasSideEffect(e)
        else:
            pass

    @staticmethod
    def iter(e,f):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            _g1 = _g.params[0]
        elif (tmp == 1):
            _g1 = _g.params[0]
        elif (tmp == 2):
            _g1 = _g.params[0]
        elif (tmp == 3):
            e = _g.params[0]
            f(e)
        elif (tmp == 4):
            el = _g.params[0]
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                f(e)
        elif (tmp == 5):
            _g1 = _g.params[0]
            e1 = _g.params[1]
            e2 = _g.params[2]
            f(e1)
            f(e2)
        elif (tmp == 6):
            _g1 = _g.params[0]
            e1 = _g.params[1]
            f(e1)
        elif (tmp == 7):
            _g1 = _g.params[0]
            init = _g.params[1]
            if (init is not None):
                f(init)
        elif (tmp == 8):
            e = _g.params[0]
            args = _g.params[1]
            f(e)
            _g1 = 0
            while (_g1 < len(args)):
                a = (args[_g1] if _g1 >= 0 and _g1 < len(args) else None)
                _g1 = (_g1 + 1)
                f(a)
        elif (tmp == 9):
            _g1 = _g.params[1]
            e = _g.params[0]
            f(e)
        elif (tmp == 10):
            econd = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            f(econd)
            f(eif)
            if (eelse is not None):
                f(eelse)
        elif (((tmp == 15) or ((tmp == 14))) or ((tmp == 11))):
            pass
        elif (tmp == 12):
            e = _g.params[0]
            if (e is not None):
                f(e)
        elif (tmp == 13):
            _g1 = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            f(it)
            f(loop)
        elif (tmp == 16):
            e = _g.params[0]
            index = _g.params[1]
            f(e)
            f(index)
        elif (tmp == 17):
            el = _g.params[0]
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                f(e)
        elif (tmp == 18):
            e = _g.params[0]
            cases = _g.params[1]
            _hx_def = _g.params[2]
            f(e)
            _g1 = 0
            while (_g1 < len(cases)):
                c = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
                _g1 = (_g1 + 1)
                _g2 = 0
                _g3 = c.values
                while (_g2 < len(_g3)):
                    v = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    f(v)
                f(c.expr)
            if (_hx_def is not None):
                f(_hx_def)
        elif (tmp == 19):
            _g1 = _g.params[2]
            e = _g.params[0]
            loop = _g.params[1]
            f(e)
            f(loop)
        elif (tmp == 20):
            _g1 = _g.params[0]
            _g1 = _g.params[1]
            e = _g.params[2]
            f(e)
        else:
            pass

    @staticmethod
    def map(e,f):
        ed = None
        _g = e.e
        ed1 = _g.index
        if (ed1 == 0):
            _g1 = _g.params[0]
            ed = e.e
        elif (ed1 == 1):
            _g1 = _g.params[0]
            ed = e.e
        elif (ed1 == 2):
            _g1 = _g.params[0]
            ed = e.e
        elif (ed1 == 3):
            e1 = _g.params[0]
            ed = hxsl_TExprDef.TParenthesis(f(e1))
        elif (ed1 == 4):
            el = _g.params[0]
            _g1 = []
            _g2 = 0
            while (_g2 < len(el)):
                e1 = (el[_g2] if _g2 >= 0 and _g2 < len(el) else None)
                _g2 = (_g2 + 1)
                x = f(e1)
                _g1.append(x)
            ed = hxsl_TExprDef.TBlock(_g1)
        elif (ed1 == 5):
            op = _g.params[0]
            e1 = _g.params[1]
            e2 = _g.params[2]
            ed = hxsl_TExprDef.TBinop(op,f(e1),f(e2))
        elif (ed1 == 6):
            op = _g.params[0]
            e1 = _g.params[1]
            ed = hxsl_TExprDef.TUnop(op,f(e1))
        elif (ed1 == 7):
            v = _g.params[0]
            init = _g.params[1]
            ed = hxsl_TExprDef.TVarDecl(v,(f(init) if ((init is not None)) else None))
        elif (ed1 == 8):
            e1 = _g.params[0]
            args = _g.params[1]
            ed1 = f(e1)
            _g1 = []
            _g2 = 0
            while (_g2 < len(args)):
                a = (args[_g2] if _g2 >= 0 and _g2 < len(args) else None)
                _g2 = (_g2 + 1)
                x = f(a)
                _g1.append(x)
            ed = hxsl_TExprDef.TCall(ed1,_g1)
        elif (ed1 == 9):
            e1 = _g.params[0]
            c = _g.params[1]
            ed = hxsl_TExprDef.TSwiz(f(e1),c)
        elif (ed1 == 10):
            econd = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            ed = hxsl_TExprDef.TIf(f(econd),f(eif),(f(eelse) if ((eelse is not None)) else None))
        elif (((ed1 == 15) or ((ed1 == 14))) or ((ed1 == 11))):
            ed = e.e
        elif (ed1 == 12):
            e1 = _g.params[0]
            ed = hxsl_TExprDef.TReturn((f(e1) if ((e1 is not None)) else None))
        elif (ed1 == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            ed = hxsl_TExprDef.TFor(v,f(it),f(loop))
        elif (ed1 == 16):
            e1 = _g.params[0]
            index = _g.params[1]
            ed = hxsl_TExprDef.TArray(f(e1),f(index))
        elif (ed1 == 17):
            el = _g.params[0]
            _g1 = []
            _g2 = 0
            while (_g2 < len(el)):
                e1 = (el[_g2] if _g2 >= 0 and _g2 < len(el) else None)
                _g2 = (_g2 + 1)
                x = f(e1)
                _g1.append(x)
            ed = hxsl_TExprDef.TArrayDecl(_g1)
        elif (ed1 == 18):
            e1 = _g.params[0]
            cases = _g.params[1]
            _hx_def = _g.params[2]
            ed1 = f(e1)
            _g1 = []
            _g2 = 0
            while (_g2 < len(cases)):
                c = (cases[_g2] if _g2 >= 0 and _g2 < len(cases) else None)
                _g2 = (_g2 + 1)
                _g3 = []
                _g4 = 0
                _g5 = c.values
                while (_g4 < len(_g5)):
                    v = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                    _g4 = (_g4 + 1)
                    x = f(v)
                    _g3.append(x)
                x1 = _hx_AnonObject({'values': _g3, 'expr': f(c.expr)})
                _g1.append(x1)
            ed = hxsl_TExprDef.TSwitch(ed1,_g1,(None if ((_hx_def is None)) else f(_hx_def)))
        elif (ed1 == 19):
            e1 = _g.params[0]
            loop = _g.params[1]
            normalWhile = _g.params[2]
            ed = hxsl_TExprDef.TWhile(f(e1),f(loop),normalWhile)
        elif (ed1 == 20):
            m = _g.params[0]
            args = _g.params[1]
            e1 = _g.params[2]
            ed = hxsl_TExprDef.TMeta(m,args,f(e1))
        else:
            pass
        return _hx_AnonObject({'e': ed, 't': e.t, 'p': e.p})

    @staticmethod
    def size(t):
        tmp = t.index
        if (tmp == 0):
            return 0
        elif ((tmp == 3) or ((tmp == 1))):
            return 1
        elif (((((tmp == 12) or ((tmp == 11))) or ((tmp == 10))) or ((tmp == 4))) or ((tmp == 2))):
            return 0
        elif (tmp == 5):
            _g = t.params[1]
            n = t.params[0]
            return n
        elif (tmp == 6):
            return 9
        elif (tmp == 7):
            return 16
        elif (tmp == 8):
            return 12
        elif (tmp == 9):
            s = t.params[0]
            return s
        elif (tmp == 13):
            vl = t.params[0]
            s = 0
            _g = 0
            while (_g < len(vl)):
                v = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                s = (s + hxsl_Tools.size(v.type))
            return s
        elif (tmp == 14):
            _g = t.params[0]
            return 0
        elif (tmp == 15):
            _g = t.params[0]
            _g1 = t.params[1]
            tmp = _g1.index
            if (tmp == 0):
                v = _g1.params[0]
                t1 = _g
                return (hxsl_Tools.size(t1) * v)
            elif (tmp == 1):
                _g = _g1.params[0]
                return 0
            else:
                pass
        elif (tmp == 16):
            _g = t.params[1]
            if (_g.index == 0):
                v = _g.params[0]
                t1 = t.params[0]
                return (hxsl_Tools.size(t1) * v)
            else:
                return 0
        elif (tmp == 17):
            n = t.params[0]
            return n
        elif (tmp == 18):
            return 4
        else:
            pass

    @staticmethod
    def evalConst(e):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            c = _g.params[0]
            tmp = c.index
            if (tmp == 0):
                return None
            elif (tmp == 1):
                b = c.params[0]
                return b
            elif (tmp == 2):
                i = c.params[0]
                return i
            elif (tmp == 3):
                f = c.params[0]
                return f
            elif (tmp == 4):
                s = c.params[0]
                return s
            else:
                pass
        elif (tmp == 8):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g = _g1.e
            _g3 = _g1.p
            _g3 = _g1.t
            if (_g.index == 2):
                tmp = _g.params[0].index
                if (((tmp == 42) or ((tmp == 41))) or ((tmp == 40))):
                    args = _g2
                    _g = []
                    _g1 = 0
                    while (_g1 < len(args)):
                        a = (args[_g1] if _g1 >= 0 and _g1 < len(args) else None)
                        _g1 = (_g1 + 1)
                        x = hxsl_Tools.evalConst(a)
                        _g.append(x)
                    vals = _g
                    if (len(vals) == 1):
                        return h3d_Vector((vals[0] if 0 < len(vals) else None),(vals[0] if 0 < len(vals) else None),(vals[0] if 0 < len(vals) else None),(vals[0] if 0 < len(vals) else None))
                    return h3d_Vector((vals[0] if 0 < len(vals) else None),(vals[1] if 1 < len(vals) else None),(vals[2] if 2 < len(vals) else None),(vals[3] if 3 < len(vals) else None))
                else:
                    raise haxe_Exception.thrown(("Unhandled constant init " + HxOverrides.stringOrNull(hxsl_Printer.toString(e))))
            else:
                raise haxe_Exception.thrown(("Unhandled constant init " + HxOverrides.stringOrNull(hxsl_Printer.toString(e))))
        else:
            raise haxe_Exception.thrown(("Unhandled constant init " + HxOverrides.stringOrNull(hxsl_Printer.toString(e))))
hxsl_Tools._hx_class = hxsl_Tools
_hx_classes["hxsl.Tools"] = hxsl_Tools


class hxsl_Tools2:
    _hx_class_name = "hxsl.Tools2"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(g):
        n = g.tag
        return (HxOverrides.stringOrNull(("" if ((0 >= len(n))) else n[0]).lower()) + HxOverrides.stringOrNull(HxString.substr(n,1,None)))
hxsl_Tools2._hx_class = hxsl_Tools2
_hx_classes["hxsl.Tools2"] = hxsl_Tools2


class hxsl_Tools3:
    _hx_class_name = "hxsl.Tools3"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(s):
        return hxsl_Printer.shaderToString(s)
hxsl_Tools3._hx_class = hxsl_Tools3
_hx_classes["hxsl.Tools3"] = hxsl_Tools3


class hxsl_Tools4:
    _hx_class_name = "hxsl.Tools4"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(e):
        return hxsl_Printer.toString(e)
hxsl_Tools4._hx_class = hxsl_Tools4
_hx_classes["hxsl.Tools4"] = hxsl_Tools4


class hxsl_BatchShader(hxsl_Shader):
    _hx_class_name = "hxsl.BatchShader"
    _hx_is_interface = "False"
    __slots__ = ("Batch_Count__", "Batch_Buffer__")
    _hx_fields = ["Batch_Count__", "Batch_Buffer__"]
    _hx_methods = ["get_Batch_Count", "set_Batch_Count", "get_Batch_Buffer", "set_Batch_Buffer", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.Batch_Buffer__ = None
        self.Batch_Count__ = 0
        super().__init__()

    def get_Batch_Count(self):
        return self.Batch_Count__

    def set_Batch_Count(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.Batch_Count__ = _v
                return self.Batch_Count__
            return _hx_local_0()
        return _hx_local_1()

    def get_Batch_Buffer(self):
        return self.Batch_Buffer__

    def set_Batch_Buffer(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.Batch_Buffer__ = _v
                return self.Batch_Buffer__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.Batch_Count__
        if (HxOverrides.rshift(v, 17) != 0):
            raise haxe_Exception.thrown((((("Batch_Count" + " is out of range ") + Std.string(v)) + ">") + Std.string(131071)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.Batch_Count__
        elif (index1 == 1):
            return self.Batch_Buffer__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(hxsl_BatchShader)
        s.shader = self.shader
        s.Batch_Count__ = self.Batch_Count__
        s.Batch_Buffer__ = self.Batch_Buffer__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.Batch_Count__ = None
        _hx_o.Batch_Buffer__ = None
hxsl_BatchShader._hx_class = hxsl_BatchShader
_hx_classes["hxsl.BatchShader"] = hxsl_BatchShader


class hxsl_SearchMap:
    _hx_class_name = "hxsl.SearchMap"
    _hx_is_interface = "False"
    __slots__ = ("linked", "next")
    _hx_fields = ["linked", "next"]

    def __init__(self):
        self.next = None
        self.linked = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.linked = None
        _hx_o.next = None
hxsl_SearchMap._hx_class = hxsl_SearchMap
_hx_classes["hxsl.SearchMap"] = hxsl_SearchMap


class hxsl_Cache:
    _hx_class_name = "hxsl.Cache"
    _hx_is_interface = "False"
    __slots__ = ("linkCache", "linkShaders", "batchShaders", "byID", "constsToGlobal")
    _hx_fields = ["linkCache", "linkShaders", "batchShaders", "byID", "constsToGlobal"]
    _hx_methods = ["getLinkShader", "link", "compileRuntimeShader", "buildRuntimeShader", "initGlobals", "getPath", "flattenShader", "makeBatchShader", "createBatchShader"]
    _hx_statics = ["INST", "get", "set", "clear"]

    def __init__(self):
        self.constsToGlobal = False
        self.linkCache = hxsl_SearchMap()
        self.linkShaders = haxe_ds_StringMap()
        self.batchShaders = haxe_ds_IntMap()
        self.byID = haxe_ds_StringMap()

    def getLinkShader(self,vars):
        _g = []
        _g1 = 0
        while (_g1 < len(vars)):
            v = (vars[_g1] if _g1 >= 0 and _g1 < len(vars) else None)
            _g1 = (_g1 + 1)
            x = Std.string(v)
            _g.append(x)
        key = ",".join([python_Boot.toString1(x1,'') for x1 in _g])
        shader = self.linkShaders.h.get(key,None)
        if (shader is not None):
            return shader
        s = hxsl_SharedShader("")
        id = HxString.substr(haxe_crypto_Md5.encode(key),0,8)
        s.data = _hx_AnonObject({'name': ("shaderLinker_" + ("null" if id is None else id)), 'vars': [], 'funs': []})
        pos = None
        outVars = haxe_ds_StringMap()
        outputCount = 0
        tvec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat)
        def _hx_local_2(g,size,args,makeOutExpr):
            out = []
            rem = size
            _g = 0
            _g1 = len(args)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                e = makeOutExpr(python_internal_ArrayImpl._get(args, ((len(args) - 1) - i)),(rem - (((len(args) - 1) - i))))
                rem = (rem - hxsl_Tools.size(e.t))
                out.insert(0, e)
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(g), 't': hxsl_Type.TVoid, 'p': pos}),out), 't': hxsl_Type.TVec(size,hxsl_VecType.VFloat), 'p': pos})
        makeVec = _hx_local_2
        def _hx_local_3(name,t,parent):
            path = (name if ((parent is None)) else ((HxOverrides.stringOrNull(hxsl_Tools.getName(parent)) + ".") + ("null" if name is None else name)))
            v = outVars.h.get(path,None)
            if (v is not None):
                return v
            v = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': name, 'type': t, 'kind': hxsl_VarKind.Var, 'parent': parent})
            if (parent is None):
                _this = s.data.vars
                _this.append(v)
            else:
                _g = parent.type
                if (_g.index == 13):
                    vl = _g.params[0]
                    vl.append(v)
                else:
                    raise haxe_Exception.thrown("assert")
            outVars.h[path] = v
            return v
        makeVar = _hx_local_3
        makeOutExpr = None
        def _hx_local_4(v,rem):
            makeOutExpr1 = v.index
            if (makeOutExpr1 == 0):
                v1 = v.params[0]
                return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CFloat(v1)), 't': hxsl_Type.TFloat, 'p': pos})
            elif (makeOutExpr1 == 1):
                vname = v.params[0]
                size = v.params[1]
                v1 = outVars.h.get(vname,None)
                if (v1 is not None):
                    return _hx_AnonObject({'e': hxsl_TExprDef.TVar(v1), 't': v1.type, 'p': pos})
                path = vname.split(".")
                parent = None
                while (len(path) > 1):
                    parent = makeVar((None if ((len(path) == 0)) else path.pop(0)),hxsl_Type.TStruct([]),parent)
                if (size is not None):
                    rem = size
                v1 = makeVar((None if ((len(path) == 0)) else path.pop(0)),(hxsl_Type.TFloat if ((rem == 1)) else hxsl_Type.TVec(rem,hxsl_VecType.VFloat)),parent)
                return _hx_AnonObject({'e': hxsl_TExprDef.TVar(v1), 't': v1.type, 'p': pos})
            elif (makeOutExpr1 == 2):
                v1 = v.params[0]
                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.PackNormal), 't': hxsl_Type.TVoid, 'p': pos}),[makeOutExpr(v1,3)]), 't': tvec4, 'p': pos})
            elif (makeOutExpr1 == 3):
                v1 = v.params[0]
                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Pack), 't': hxsl_Type.TVoid, 'p': pos}),[makeOutExpr(v1,1)]), 't': tvec4, 'p': pos})
            elif (makeOutExpr1 == 4):
                args = v.params[0]
                return makeVec(hxsl_TGlobal.Vec2,2,args,makeOutExpr)
            elif (makeOutExpr1 == 5):
                args = v.params[0]
                return makeVec(hxsl_TGlobal.Vec3,3,args,makeOutExpr)
            elif (makeOutExpr1 == 6):
                args = v.params[0]
                return makeVec(hxsl_TGlobal.Vec4,4,args,makeOutExpr)
            elif (makeOutExpr1 == 7):
                v1 = v.params[0]
                comps = v.params[1]
                return _hx_AnonObject({'e': hxsl_TExprDef.TSwiz(makeOutExpr(v1,4),comps), 't': hxsl_Type.TVec(len(comps),hxsl_VecType.VFloat), 'p': pos})
            else:
                pass
        makeOutExpr = _hx_local_4
        def _hx_local_6(v):
            nonlocal outputCount
            outputCount = (outputCount + 1)
            ov = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'type': tvec4, 'name': ("OUTPUT" + Std.string(((outputCount - 1)))), 'kind': hxsl_VarKind.Output})
            _this = s.data.vars
            _this.append(ov)
            return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,_hx_AnonObject({'e': hxsl_TExprDef.TVar(ov), 't': tvec4, 'p': pos}),makeOutExpr(v,4)), 't': hxsl_Type.TVoid, 'p': pos})
        makeOutput = _hx_local_6
        def _hx_local_8(kind,vars):
            fv = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'type': hxsl_Type.TFun([]), 'name': ("" + Std.string(kind)).lower(), 'kind': hxsl_VarKind.Function})
            _g = []
            _g1 = 0
            while (_g1 < len(vars)):
                v = (vars[_g1] if _g1 >= 0 and _g1 < len(vars) else None)
                _g1 = (_g1 + 1)
                x = makeOutput(v)
                _g.append(x)
            f = _hx_AnonObject({'kind': kind, 'ref': fv, 'args': [], 'ret': hxsl_Type.TVoid, 'expr': _hx_AnonObject({'e': hxsl_TExprDef.TBlock(_g), 'p': pos, 't': hxsl_Type.TVoid})})
            _this = s.data.funs
            _this.append(f)
        defineFun = _hx_local_8
        defineFun(hxsl_FunctionKind.Vertex,[hxsl_Output.Value("output.position")])
        defineFun(hxsl_FunctionKind.Fragment,vars)
        shader = Type.createEmptyInstance(hxsl_Shader)
        shader.shader = s
        self.linkShaders.h[key] = shader
        shader.updateConstantsFinal(None)
        return shader

    def link(self,shaders,batchMode):
        c = self.linkCache
        _g_l = shaders
        _g_last = None
        while (_g_l != _g_last):
            s = _g_l.s
            _g_l = _g_l.next
            s1 = s
            i = s1.instance
            if (c.next is None):
                c.next = haxe_ds_IntMap()
            cs = c.next.h.get(i.id,None)
            if (cs is None):
                cs = hxsl_SearchMap()
                c.next.set(i.id,cs)
            c = cs
        if (c.linked is None):
            c.linked = self.compileRuntimeShader(shaders,batchMode)
        return c.linked

    def compileRuntimeShader(self,shaders,batchMode):
        shaderDatas = []
        index = 0
        _g_l = shaders
        _g_last = None
        while (_g_l != _g_last):
            s = _g_l.s
            _g_l = _g_l.next
            s1 = s
            i = s1.instance
            x = index
            index = (index + 1)
            x1 = _hx_AnonObject({'inst': i, 'p': s1.priority, 'index': x})
            shaderDatas.append(x1)
        shaderDatas.reverse()
        def _hx_local_0(s1,s2):
            return (s2.p - s1.p)
        haxe_ds_ArraySort.sort(shaderDatas,_hx_local_0)
        linker = hxsl_Linker(batchMode)
        s = None
        try:
            _g = []
            _g1 = 0
            while (_g1 < len(shaderDatas)):
                s1 = (shaderDatas[_g1] if _g1 >= 0 and _g1 < len(shaderDatas) else None)
                _g1 = (_g1 + 1)
                x = s1.inst.shader
                _g.append(x)
            s = linker.link(_g)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,hxsl_Error):
                e = _g1
                _g1 = []
                _g2 = 0
                while (_g2 < len(shaderDatas)):
                    s1 = (shaderDatas[_g2] if _g2 >= 0 and _g2 < len(shaderDatas) else None)
                    _g2 = (_g2 + 1)
                    x = hxsl_Printer.shaderToString(s1.inst.shader)
                    _g1.append(x)
                shaders1 = _g1
                e.msg = (HxOverrides.stringOrNull(e.msg) + HxOverrides.stringOrNull((("\n\nin\n\n" + HxOverrides.stringOrNull("\n-----\n".join([python_Boot.toString1(x1,'') for x1 in shaders1]))))))
                raise haxe_Exception.thrown(e)
            else:
                raise _g
        if batchMode:
            checkRec = None
            def _hx_local_5(v):
                if ((Reflect.field(v,"qualifiers") is not None) and ((python_internal_ArrayImpl.indexOf(Reflect.field(v,"qualifiers"),hxsl_VarQualifier.PerObject,None) >= 0))):
                    if (len(Reflect.field(v,"qualifiers")) == 1):
                        Reflect.setField(v,"qualifiers",None)
                    else:
                        Reflect.setField(v,"qualifiers",list(Reflect.field(v,"qualifiers")))
                        python_internal_ArrayImpl.remove(Reflect.field(v,"qualifiers"),hxsl_VarQualifier.PerObject)
                    if (v.kind != hxsl_VarKind.Var):
                        v.kind = hxsl_VarKind.Local
                _g = v.type
                if (_g.index == 13):
                    vl = _g.params[0]
                    _g = 0
                    while (_g < len(vl)):
                        v = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                        _g = (_g + 1)
                        checkRec(v)
            checkRec = _hx_local_5
            _g = 0
            _g1 = s.vars
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                checkRec(v)
        paramVars = haxe_ds_IntMap()
        _g = 0
        _g1 = linker.allVars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (v.v.kind == hxsl_VarKind.Param):
                _g2 = v.v.type
                if (_g2.index == 13):
                    _g3 = _g2.params[0]
                    continue
                inf = python_internal_ArrayImpl._get(shaderDatas, v.instanceIndex)
                paramVars.set(v.id,_hx_AnonObject({'instance': inf.index, 'index': inf.inst.params.h.get((v.merged[0] if 0 < len(v.merged) else None).id,None)}))
        prev = s
        s1 = None
        try:
            s1 = hxsl_Splitter().split(s)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,hxsl_Error):
                e = _g1
                e.msg = (HxOverrides.stringOrNull(e.msg) + HxOverrides.stringOrNull((("\n\nin\n\n" + HxOverrides.stringOrNull(hxsl_Printer.shaderToString(s))))))
                raise haxe_Exception.thrown(e)
            else:
                raise _g
        prev = s1
        s = hxsl_Dce().dce(s1.vertex,s1.fragment)
        r = self.buildRuntimeShader(s.vertex,s.fragment,paramVars)
        _g = []
        _g4_l = shaders
        _g4_last = None
        while (_g4_l != _g4_last):
            s = _g4_l.s
            _g4_l = _g4_l.next
            s1 = s
            x = hxsl_ShaderInstanceDesc(s1.shader,s1.constBits)
            _g.append(x)
        r.spec = _hx_AnonObject({'instances': _g, 'signature': None})
        _g = 0
        _g1 = len(shaderDatas)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            s = python_internal_ArrayImpl._get(shaderDatas, ((len(shaderDatas) - 1) - i))
            python_internal_ArrayImpl._get(r.spec.instances, s.index).index = i
        _g = []
        _g1 = 0
        _g2 = r.spec.instances
        while (_g1 < len(_g2)):
            i = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = ((((HxOverrides.stringOrNull(i.shader.data.name) + "_") + Std.string(i.bits)) + "_") + Std.string(i.index))
            _g.append(x)
        signParts = _g
        tmp = ":".join
        tmp1 = [python_Boot.toString1(x1,'') for x1 in signParts]
        r.spec.signature = haxe_crypto_Md5.encode(tmp(tmp1))
        r.signature = haxe_crypto_Md5.encode((HxOverrides.stringOrNull(hxsl_Printer.shaderToString(r.vertex.data)) + HxOverrides.stringOrNull(hxsl_Printer.shaderToString(r.fragment.data))))
        r.batchMode = batchMode
        r2 = self.byID.h.get(r.signature,None)
        if (r2 is not None):
            r.id = r2.id
        else:
            self.byID.h[r.signature] = r
        return r

    def buildRuntimeShader(self,vertex,fragment,paramVars):
        r = hxsl_RuntimeShader()
        r.vertex = self.flattenShader(vertex,hxsl_FunctionKind.Vertex,paramVars)
        r.vertex.vertex = True
        r.fragment = self.flattenShader(fragment,hxsl_FunctionKind.Fragment,paramVars)
        r.globals = haxe_ds_IntMap()
        self.initGlobals(r,r.vertex)
        self.initGlobals(r,r.fragment)
        return r

    def initGlobals(self,r,s):
        p = s.globals
        while (p is not None):
            r.globals.set(p.gid,True)
            p = p.next
        p = s.params
        while (p is not None):
            if (p.perObjectGlobal is not None):
                r.globals.set(p.perObjectGlobal.gid,True)
            p = p.next

    def getPath(self,v):
        if (Reflect.field(v,"parent") is None):
            return v.name
        return ((HxOverrides.stringOrNull(self.getPath(Reflect.field(v,"parent"))) + ".") + HxOverrides.stringOrNull(v.name))

    def flattenShader(self,s,kind,params):
        flat = hxsl_Flatten()
        c = hxsl_RuntimeShaderData()
        data = flat.flatten(s,kind,self.constsToGlobal)
        textures = []
        c.consts = flat.consts
        c.texturesCount = 0
        g = flat.allocData.keys()
        while g.hasNext():
            g1 = g.next()
            alloc = flat.allocData.h.get(g1,None)
            tmp = g1.kind.index
            if (tmp == 0):
                _g = []
                _g1 = 0
                while (_g1 < len(alloc)):
                    a = (alloc[_g1] if _g1 >= 0 and _g1 < len(alloc) else None)
                    _g1 = (_g1 + 1)
                    if (a.v is not None):
                        x = hxsl_AllocGlobal(a.pos,self.getPath(a.v),a.v.type)
                        _g.append(x)
                out = _g
                _g2 = 0
                _g3 = (len(out) - 1)
                while (_g2 < _g3):
                    i = _g2
                    _g2 = (_g2 + 1)
                    (out[i] if i >= 0 and i < len(out) else None).next = python_internal_ArrayImpl._get(out, (i + 1))
                _g4 = g1.type
                if (_g4.index == 15):
                    _g5 = _g4.params[0]
                    _g6 = _g4.params[1]
                    if (_g5.index == 5):
                        if (_g5.params[0] == 4):
                            if (_g5.params[1].index == 1):
                                if (_g6.index == 0):
                                    size = _g6.params[0]
                                    c.globals = (out[0] if 0 < len(out) else None)
                                    c.globalsSize = size
                                else:
                                    raise haxe_Exception.thrown("assert")
                            else:
                                raise haxe_Exception.thrown("assert")
                        else:
                            raise haxe_Exception.thrown("assert")
                    else:
                        raise haxe_Exception.thrown("assert")
                else:
                    raise haxe_Exception.thrown("assert")
            elif (tmp == 2):
                out1 = []
                count = 0
                _g7 = 0
                while (_g7 < len(alloc)):
                    a1 = (alloc[_g7] if _g7 >= 0 and _g7 < len(alloc) else None)
                    _g7 = (_g7 + 1)
                    if (a1.v is None):
                        continue
                    p = params.h.get(a1.v.id,None)
                    if (p is None):
                        ap = hxsl_AllocParam(a1.v.name,a1.pos,-1,-1,a1.v.type)
                        ap.perObjectGlobal = hxsl_AllocGlobal(-1,self.getPath(a1.v),a1.v.type)
                        out1.append(ap)
                        count = (count + 1)
                        continue
                    ap1 = hxsl_AllocParam(a1.v.name,a1.pos,p.instance,p.index,a1.v.type)
                    _g8 = a1.v.type
                    if (_g8.index == 15):
                        _g9 = _g8.params[1]
                        t = _g8.params[0]
                        if hxsl_Tools.isSampler(t):
                            ap1.pos = -a1.size
                            count = (count + a1.size)
                        else:
                            count = (count + 1)
                    else:
                        count = (count + 1)
                    out1.append(ap1)
                _g10 = 0
                _g11 = (len(out1) - 1)
                while (_g10 < _g11):
                    i1 = _g10
                    _g10 = (_g10 + 1)
                    (out1[i1] if i1 >= 0 and i1 < len(out1) else None).next = python_internal_ArrayImpl._get(out1, (i1 + 1))
                _g12 = g1.type
                if (_g12.index == 15):
                    _g13 = _g12.params[0]
                    _g14 = _g12.params[1]
                    t1 = _g13
                    if hxsl_Tools.isSampler(t1):
                        textures.append(_hx_AnonObject({'t': t1, 'all': out1}))
                        c.texturesCount = (c.texturesCount + count)
                    else:
                        tmp1 = _g13.index
                        if (tmp1 == 5):
                            if (_g13.params[0] == 4):
                                if (_g13.params[1].index == 1):
                                    if (_g14.index == 0):
                                        size1 = _g14.params[0]
                                        c.params = (out1[0] if 0 < len(out1) else None)
                                        c.paramsSize = size1
                                    else:
                                        raise haxe_Exception.thrown("assert")
                                else:
                                    raise haxe_Exception.thrown("assert")
                            else:
                                raise haxe_Exception.thrown("assert")
                        elif (tmp1 == 16):
                            _g15 = _g13.params[0]
                            _g16 = _g13.params[1]
                            c.buffers = (out1[0] if 0 < len(out1) else None)
                            c.bufferCount = len(out1)
                        else:
                            raise haxe_Exception.thrown("assert")
                else:
                    raise haxe_Exception.thrown("assert")
            else:
                raise haxe_Exception.thrown("assert")
        if (len(textures) > 0):
            def _hx_local_7(t1,t2):
                return (t1.t.index - t2.t.index)
            textures.sort(key= python_lib_Functools.cmp_to_key(_hx_local_7))
            c.textures = python_internal_ArrayImpl._get((textures[0] if 0 < len(textures) else None).all, 0)
            _g = 1
            _g1 = len(textures)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prevAll = python_internal_ArrayImpl._get(textures, (i - 1)).all
                prev = python_internal_ArrayImpl._get(prevAll, (len(prevAll) - 1))
                prev.next = python_internal_ArrayImpl._get((textures[i] if i >= 0 and i < len(textures) else None).all, 0)
        if (c.globals is None):
            c.globalsSize = 0
        if (c.params is None):
            c.paramsSize = 0
        if (c.buffers is None):
            c.bufferCount = 0
        c.data = data
        return c

    def makeBatchShader(self,rt):
        sh = self.batchShaders.h.get(rt.id,None)
        if (sh is None):
            sh = self.createBatchShader(rt)
            self.batchShaders.set(rt.id,sh)
        shader = Type.createEmptyInstance(hxsl_BatchShader)
        shader.shader = sh
        return shader

    def createBatchShader(self,rt):
        s = hxsl_SharedShader("")
        id = HxString.substr(rt.spec.signature,0,8)
        def _hx_local_0(name,t,kind):
            return _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'type': t, 'name': name, 'kind': kind})
        declVar = _hx_local_0
        pos = None
        vcount = declVar("Batch_Count",hxsl_Type.TInt,hxsl_VarKind.Param)
        vbuffer = declVar("Batch_Buffer",hxsl_Type.TBuffer(hxsl_Type.TVec(4,hxsl_VecType.VFloat),hxsl_SizeDecl.SVar(vcount)),hxsl_VarKind.Param)
        voffset = declVar("Batch_Offset",hxsl_Type.TInt,hxsl_VarKind.Local)
        ebuffer = _hx_AnonObject({'e': hxsl_TExprDef.TVar(vbuffer), 'p': pos, 't': vbuffer.type})
        eoffset = _hx_AnonObject({'e': hxsl_TExprDef.TVar(voffset), 'p': pos, 't': voffset.type})
        tvec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat)
        countBits = 16
        Reflect.setField(vcount,"qualifiers",[hxsl_VarQualifier.Const((1 << countBits))])
        s.data = _hx_AnonObject({'name': ("batchShader_" + ("null" if id is None else id)), 'vars': [vcount, vbuffer, voffset], 'funs': []})
        stride = (rt.vertex.paramsSize + rt.fragment.paramsSize)
        parentVars = haxe_ds_ObjectMap()
        swiz = [[hxsl_Component.X], [hxsl_Component.Y], [hxsl_Component.Z], [hxsl_Component.W]]
        def _hx_local_1(index):
            return _hx_AnonObject({'e': hxsl_TExprDef.TArray(ebuffer,_hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,eoffset,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos})), 't': tvec4, 'p': pos})
        readOffset = _hx_local_1
        def _hx_local_2(v,offset):
            vreal = declVar(v.name,v.type,hxsl_VarKind.Local)
            if (v.perObjectGlobal is not None):
                _this = v.perObjectGlobal.path
                path = _this.split(".")
                if (len(path) != 0):
                    path.pop()
                cur = vreal
                while (len(path) > 0):
                    key = ".".join([python_Boot.toString1(x1,'') for x1 in path])
                    name = (None if ((len(path) == 0)) else path.pop())
                    vp = parentVars.h.get(path,None)
                    if (vp is None):
                        vp = declVar(name,hxsl_Type.TStruct([]),hxsl_VarKind.Local)
                        parentVars.set(path,vp)
                    _g = vp.type
                    if (_g.index == 13):
                        vl = _g.params[0]
                        vl.append(cur)
                    Reflect.setField(cur,"parent",vp)
                    cur = vp
            _this = s.data.vars
            _this.append(vreal)
            index = (((v.pos >> 2)) + offset)
            extract = None
            _g = v.type
            extract1 = _g.index
            if (extract1 == 3):
                extract = _hx_AnonObject({'p': pos, 't': v.type, 'e': hxsl_TExprDef.TSwiz(readOffset(index),python_internal_ArrayImpl._get(swiz, (v.pos & 3)))})
            elif (extract1 == 5):
                _g1 = _g.params[1]
                _g2 = _g.params[0]
                if (_g2 == 2):
                    if (_g1.index == 1):
                        swiz1 = None
                        _g = (v.pos & 3)
                        if (_g == 0):
                            swiz1 = [hxsl_Component.X, hxsl_Component.Y]
                        elif (_g == 1):
                            swiz1 = [hxsl_Component.Y, hxsl_Component.Z]
                        else:
                            swiz1 = [hxsl_Component.Z, hxsl_Component.W]
                        extract = _hx_AnonObject({'p': pos, 't': v.type, 'e': hxsl_TExprDef.TSwiz(readOffset(index),swiz1)})
                    else:
                        raise haxe_Exception.thrown(("Unsupported batch var type " + Std.string(v.type)))
                elif (_g2 == 3):
                    if (_g1.index == 1):
                        extract = _hx_AnonObject({'p': pos, 't': v.type, 'e': hxsl_TExprDef.TSwiz(readOffset(index),([hxsl_Component.X, hxsl_Component.Y, hxsl_Component.Z] if ((((v.pos & 3)) == 0)) else [hxsl_Component.Y, hxsl_Component.Z, hxsl_Component.W]))})
                    else:
                        raise haxe_Exception.thrown(("Unsupported batch var type " + Std.string(v.type)))
                elif (_g2 == 4):
                    if (_g1.index == 1):
                        extract = readOffset(index)
                    else:
                        raise haxe_Exception.thrown(("Unsupported batch var type " + Std.string(v.type)))
                else:
                    raise haxe_Exception.thrown(("Unsupported batch var type " + Std.string(v.type)))
            elif (extract1 == 7):
                extract = _hx_AnonObject({'p': pos, 't': v.type, 'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4), 't': hxsl_Type.TVoid, 'p': pos}),[readOffset(index), readOffset((index + 1)), readOffset((index + 2)), readOffset((index + 3))])})
            else:
                raise haxe_Exception.thrown(("Unsupported batch var type " + Std.string(v.type)))
            return _hx_AnonObject({'p': pos, 'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,_hx_AnonObject({'e': hxsl_TExprDef.TVar(vreal), 'p': pos, 't': v.type}),extract), 't': hxsl_Type.TVoid})
        extractVar = _hx_local_2
        exprs = []
        p = rt.vertex.params
        while (p is not None):
            x = extractVar(p,0)
            exprs.append(x)
            p = p.next
        p = rt.fragment.params
        while (p is not None):
            x = extractVar(p,rt.vertex.paramsSize)
            exprs.append(x)
            p = p.next
        x = _hx_AnonObject({'p': pos, 'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,eoffset,_hx_AnonObject({'p': pos, 't': hxsl_Type.TInt, 'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpMult,_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.InstanceID), 't': hxsl_Type.TInt, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(stride)), 'p': pos, 't': hxsl_Type.TInt}))})), 't': hxsl_Type.TVoid})
        exprs.insert(0, x)
        fv = declVar("init",hxsl_Type.TFun([]),hxsl_VarKind.Function)
        f = _hx_AnonObject({'kind': hxsl_FunctionKind.Init, 'ref': fv, 'args': [], 'ret': hxsl_Type.TVoid, 'expr': _hx_AnonObject({'e': hxsl_TExprDef.TBlock(exprs), 'p': pos, 't': hxsl_Type.TVoid})})
        _this = s.data.funs
        _this.append(f)
        s.consts = hxsl_ShaderConst(vcount,0,countBits)
        s.consts.globalId = 0
        return s
    INST = None

    @staticmethod
    def get():
        c = hxsl_Cache.INST
        if (c is None):
            c = hxsl_Cache()
            hxsl_Cache.INST = c
        return c

    @staticmethod
    def set(c):
        hxsl_Cache.INST = c

    @staticmethod
    def clear():
        hxsl_Cache.INST = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.linkCache = None
        _hx_o.linkShaders = None
        _hx_o.batchShaders = None
        _hx_o.byID = None
        _hx_o.constsToGlobal = None
hxsl_Cache._hx_class = hxsl_Cache
_hx_classes["hxsl.Cache"] = hxsl_Cache

class hxsl_Channel(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Channel"
    _hx_constructs = ["Unknown", "R", "G", "B", "A", "PackedFloat", "PackedNormal"]
hxsl_Channel.Unknown = hxsl_Channel("Unknown", 0, ())
hxsl_Channel.R = hxsl_Channel("R", 1, ())
hxsl_Channel.G = hxsl_Channel("G", 2, ())
hxsl_Channel.B = hxsl_Channel("B", 3, ())
hxsl_Channel.A = hxsl_Channel("A", 4, ())
hxsl_Channel.PackedFloat = hxsl_Channel("PackedFloat", 5, ())
hxsl_Channel.PackedNormal = hxsl_Channel("PackedNormal", 6, ())
hxsl_Channel._hx_class = hxsl_Channel
_hx_classes["hxsl.Channel"] = hxsl_Channel


class hxsl_Clone:
    _hx_class_name = "hxsl.Clone"
    _hx_is_interface = "False"
    __slots__ = ("varMap",)
    _hx_fields = ["varMap"]
    _hx_methods = ["tvar", "tfun", "ttype", "texpr", "shader"]
    _hx_statics = ["shaderData"]

    def __init__(self):
        self.varMap = haxe_ds_IntMap()

    def tvar(self,v):
        v2 = self.varMap.h.get(v.id,None)
        if (v2 is not None):
            return v2
        v2 = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'type': v.type, 'name': v.name, 'kind': v.kind})
        self.varMap.set(v.id,v2)
        if (Reflect.field(v,"parent") is not None):
            Reflect.setField(v2,"parent",self.tvar(Reflect.field(v,"parent")))
        if (Reflect.field(v,"qualifiers") is not None):
            Reflect.setField(v2,"qualifiers",list(Reflect.field(v,"qualifiers")))
        v2.type = self.ttype(v.type)
        return v2

    def tfun(self,f):
        tmp = self.ttype(f.ret)
        f1 = f.kind
        tmp1 = self.tvar(f.ref)
        _g = []
        _g1 = 0
        _g2 = f.args
        while (_g1 < len(_g2)):
            a = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = self.tvar(a)
            _g.append(x)
        return _hx_AnonObject({'ret': tmp, 'kind': f1, 'ref': tmp1, 'args': _g, 'expr': self.texpr(f.expr)})

    def ttype(self,t):
        tmp = t.index
        if (tmp == 13):
            vl = t.params[0]
            _g = []
            _g1 = 0
            while (_g1 < len(vl)):
                v = (vl[_g1] if _g1 >= 0 and _g1 < len(vl) else None)
                _g1 = (_g1 + 1)
                x = self.tvar(v)
                _g.append(x)
            return hxsl_Type.TStruct(_g)
        elif (tmp == 14):
            vars = t.params[0]
            return hxsl_Type.TFun(vars)
        elif (tmp == 15):
            t1 = t.params[0]
            size = t.params[1]
            tmp = self.ttype(t1)
            tmp1 = None
            tmp2 = size.index
            if (tmp2 == 0):
                _g = size.params[0]
                tmp1 = size
            elif (tmp2 == 1):
                v = size.params[0]
                tmp1 = hxsl_SizeDecl.SVar(self.tvar(v))
            else:
                pass
            return hxsl_Type.TArray(tmp,tmp1)
        else:
            return t

    def texpr(self,e):
        e2 = hxsl_Tools.map(e,self.texpr)
        e2.t = self.ttype(e.t)
        _g = e2.e
        tmp = None
        tmp1 = _g.index
        if (tmp1 == 1):
            v = _g.params[0]
            tmp = hxsl_TExprDef.TVar(self.tvar(v))
        elif (tmp1 == 7):
            v = _g.params[0]
            init = _g.params[1]
            tmp = hxsl_TExprDef.TVarDecl(self.tvar(v),init)
        elif (tmp1 == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            tmp = hxsl_TExprDef.TFor(self.tvar(v),it,loop)
        else:
            tmp = e2.e
        e2.e = tmp
        return e2

    def shader(self,s):
        s1 = s.name
        _g = []
        _g1 = 0
        _g2 = s.vars
        while (_g1 < len(_g2)):
            v = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = self.tvar(v)
            _g.append(x)
        tmp = _g
        _g = []
        _g1 = 0
        _g2 = s.funs
        while (_g1 < len(_g2)):
            f = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = self.tfun(f)
            _g.append(x)
        return _hx_AnonObject({'name': s1, 'vars': tmp, 'funs': _g})

    @staticmethod
    def shaderData(s):
        return hxsl_Clone().shader(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.varMap = None
hxsl_Clone._hx_class = hxsl_Clone
_hx_classes["hxsl.Clone"] = hxsl_Clone


class hxsl__Dce_Exit:
    _hx_class_name = "hxsl._Dce.Exit"
    _hx_is_interface = "False"
    __slots__ = ()

    def __init__(self):
        pass
hxsl__Dce_Exit._hx_class = hxsl__Dce_Exit
_hx_classes["hxsl._Dce.Exit"] = hxsl__Dce_Exit


class hxsl__Dce_VarDeps:
    _hx_class_name = "hxsl._Dce.VarDeps"
    _hx_is_interface = "False"
    __slots__ = ("v", "keep", "used", "deps")
    _hx_fields = ["v", "keep", "used", "deps"]

    def __init__(self,v):
        self.keep = None
        self.v = v
        self.used = False
        self.deps = haxe_ds_IntMap()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.v = None
        _hx_o.keep = None
        _hx_o.used = None
        _hx_o.deps = None
hxsl__Dce_VarDeps._hx_class = hxsl__Dce_VarDeps
_hx_classes["hxsl._Dce.VarDeps"] = hxsl__Dce_VarDeps


class hxsl_Dce:
    _hx_class_name = "hxsl.Dce"
    _hx_is_interface = "False"
    __slots__ = ("used", "channelVars", "markAsKeep")
    _hx_fields = ["used", "channelVars", "markAsKeep"]
    _hx_methods = ["debug", "dce", "get", "markRec", "link", "check", "checkBranches", "mapExpr"]

    def __init__(self):
        self.markAsKeep = None
        self.channelVars = None
        self.used = None

    def debug(self,msg,pos = None):
        pass

    def dce(self,vertex,fragment):
        self.used = haxe_ds_IntMap()
        self.channelVars = []
        inputs = []
        _g = 0
        _g1 = vertex.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            i = self.get(v)
            if (v.kind == hxsl_VarKind.Input):
                inputs.append(i)
            if (v.kind == hxsl_VarKind.Output):
                i.keep = True
        _g = 0
        _g1 = fragment.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            i = self.get(v)
            if (v.kind == hxsl_VarKind.Output):
                i.keep = True
        _g = 0
        _g1 = vertex.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.check(f.expr,[],[])
        _g = 0
        _g1 = fragment.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.check(f.expr,[],[])
        outExprs = []
        while True:
            v = self.used.iterator()
            while v.hasNext():
                v1 = v.next()
                if v1.keep:
                    self.markRec(v1)
            while ((len(inputs) > 1) and (not python_internal_ArrayImpl._get(inputs, (len(inputs) - 1)).used)):
                if (len(inputs) != 0):
                    inputs.pop()
            _g = 0
            while (_g < len(inputs)):
                v2 = (inputs[_g] if _g >= 0 and _g < len(inputs) else None)
                _g = (_g + 1)
                self.markRec(v2)
            outExprs = []
            _g1 = 0
            _g2 = vertex.funs
            while (_g1 < len(_g2)):
                f = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                x = self.mapExpr(f.expr,False)
                outExprs.append(x)
            _g3 = 0
            _g4 = fragment.funs
            while (_g3 < len(_g4)):
                f1 = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                _g3 = (_g3 + 1)
                x1 = self.mapExpr(f1.expr,False)
                outExprs.append(x1)
            self.markAsKeep = False
            _g5 = 0
            while (_g5 < len(outExprs)):
                e = (outExprs[_g5] if _g5 >= 0 and _g5 < len(outExprs) else None)
                _g5 = (_g5 + 1)
                self.checkBranches(e)
            if (not self.markAsKeep):
                break
        _g = 0
        _g1 = vertex.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f.expr = (None if ((len(outExprs) == 0)) else outExprs.pop(0))
        _g = 0
        _g1 = fragment.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f.expr = (None if ((len(outExprs) == 0)) else outExprs.pop(0))
        v = self.used.iterator()
        while v.hasNext():
            v1 = v.next()
            if v1.used:
                continue
            if (v1.v.kind == hxsl_VarKind.Input):
                continue
            python_internal_ArrayImpl.remove(vertex.vars,v1.v)
            python_internal_ArrayImpl.remove(fragment.vars,v1.v)
        return _hx_AnonObject({'fragment': fragment, 'vertex': vertex})

    def get(self,v):
        vd = self.used.h.get(v.id,None)
        if (vd is None):
            vd = hxsl__Dce_VarDeps(v)
            self.used.set(v.id,vd)
        return vd

    def markRec(self,v):
        if v.used:
            return
        v.used = True
        d = v.deps.iterator()
        while d.hasNext():
            d1 = d.next()
            self.markRec(d1)

    def link(self,v,writeTo):
        vd = self.get(v)
        _g = 0
        while (_g < len(writeTo)):
            w = (writeTo[_g] if _g >= 0 and _g < len(writeTo) else None)
            _g = (_g + 1)
            if (w is None):
                if (not vd.keep):
                    vd.keep = True
                    self.markAsKeep = True
                continue
            w.deps.set(v.id,vd)

    def check(self,e,writeTo,isAffected):
        _g = e.e
        tmp = _g.index
        if (tmp == 1):
            v = _g.params[0]
            self.link(v,writeTo)
        elif (tmp == 4):
            el = _g.params[0]
            noWrite = []
            _g1 = 0
            _g2 = len(el)
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                self.check((el[i] if i >= 0 and i < len(el) else None),(noWrite if ((i < ((len(el) - 1)))) else writeTo),isAffected)
        elif (tmp == 5):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g.params[2]
            tmp = _g1.index
            if (tmp == 4):
                _g4 = _g2.e
                _g5 = _g2.p
                _g5 = _g2.t
                tmp = _g4.index
                if (tmp == 1):
                    v = _g4.params[0]
                    e1 = _g3
                    v1 = self.get(v)
                    writeTo.append(v1)
                    self.check(e1,writeTo,isAffected)
                    if (len(writeTo) != 0):
                        writeTo.pop()
                    if (python_internal_ArrayImpl.indexOf(isAffected,v1,None) < 0):
                        isAffected.append(v1)
                elif (tmp == 9):
                    _g5 = _g4.params[0]
                    _g6 = _g4.params[1]
                    _g4 = _g5.e
                    _g6 = _g5.p
                    _g6 = _g5.t
                    if (_g4.index == 1):
                        v = _g4.params[0]
                        e1 = _g3
                        v1 = self.get(v)
                        writeTo.append(v1)
                        self.check(e1,writeTo,isAffected)
                        if (len(writeTo) != 0):
                            writeTo.pop()
                        if (python_internal_ArrayImpl.indexOf(isAffected,v1,None) < 0):
                            isAffected.append(v1)
                    else:
                        _g4 = self.check
                        writeTo1 = writeTo
                        isAffected1 = isAffected
                        def _hx_local_0(e):
                            _g4(e,writeTo1,isAffected1)
                        hxsl_Tools.iter(e,_hx_local_0)
                else:
                    _g5 = self.check
                    writeTo2 = writeTo
                    isAffected2 = isAffected
                    def _hx_local_1(e):
                        _g5(e,writeTo2,isAffected2)
                    hxsl_Tools.iter(e,_hx_local_1)
            elif (tmp == 20):
                _g6 = _g1.params[0]
                _g1 = _g2.e
                _g6 = _g2.p
                _g6 = _g2.t
                tmp = _g1.index
                if (tmp == 1):
                    v = _g1.params[0]
                    e1 = _g3
                    v1 = self.get(v)
                    writeTo.append(v1)
                    self.check(e1,writeTo,isAffected)
                    if (len(writeTo) != 0):
                        writeTo.pop()
                    if (python_internal_ArrayImpl.indexOf(isAffected,v1,None) < 0):
                        isAffected.append(v1)
                elif (tmp == 9):
                    _g2 = _g1.params[0]
                    _g6 = _g1.params[1]
                    _g1 = _g2.e
                    _g6 = _g2.p
                    _g6 = _g2.t
                    if (_g1.index == 1):
                        v = _g1.params[0]
                        e1 = _g3
                        v1 = self.get(v)
                        writeTo.append(v1)
                        self.check(e1,writeTo,isAffected)
                        if (len(writeTo) != 0):
                            writeTo.pop()
                        if (python_internal_ArrayImpl.indexOf(isAffected,v1,None) < 0):
                            isAffected.append(v1)
                    else:
                        _g1 = self.check
                        writeTo3 = writeTo
                        isAffected3 = isAffected
                        def _hx_local_2(e):
                            _g1(e,writeTo3,isAffected3)
                        hxsl_Tools.iter(e,_hx_local_2)
                else:
                    _g2 = self.check
                    writeTo4 = writeTo
                    isAffected4 = isAffected
                    def _hx_local_3(e):
                        _g2(e,writeTo4,isAffected4)
                    hxsl_Tools.iter(e,_hx_local_3)
            else:
                _g3 = self.check
                writeTo5 = writeTo
                isAffected5 = isAffected
                def _hx_local_4(e):
                    _g3(e,writeTo5,isAffected5)
                hxsl_Tools.iter(e,_hx_local_4)
        elif (tmp == 7):
            v = _g.params[0]
            init = _g.params[1]
            if (init is not None):
                x = self.get(v)
                writeTo.append(x)
                self.check(init,writeTo,isAffected)
                if (len(writeTo) != 0):
                    writeTo.pop()
            else:
                _g6 = self.check
                writeTo6 = writeTo
                isAffected6 = isAffected
                def _hx_local_5(e):
                    _g6(e,writeTo6,isAffected6)
                hxsl_Tools.iter(e,_hx_local_5)
        elif (tmp == 8):
            _g7 = _g.params[0]
            _g8 = _g.params[1]
            _g9 = _g7.e
            _g10 = _g7.p
            _g10 = _g7.t
            if (_g9.index == 2):
                tmp = _g9.params[0].index
                if (tmp == 63):
                    if (len(_g8) == 3):
                        _g7 = (_g8[0] if 0 < len(_g8) else None)
                        _g9 = (_g8[2] if 2 < len(_g8) else None)
                        _g10 = _g7.e
                        _g11 = _g7.p
                        _g11 = _g7.t
                        if (_g10.index == 1):
                            _g7 = _g9.e
                            _g11 = _g9.p
                            _g11 = _g9.t
                            if (_g7.index == 0):
                                _g9 = _g7.params[0]
                                if (_g9.index == 2):
                                    cid = _g9.params[0]
                                    uv = (_g8[1] if 1 < len(_g8) else None)
                                    c = _g10.params[0]
                                    self.check(uv,writeTo,isAffected)
                                    if ((self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None) is None):
                                        python_internal_ArrayImpl._set(self.channelVars, cid, c)
                                        self.link(c,writeTo)
                                    else:
                                        self.link((self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None),writeTo)
                                else:
                                    _g7 = self.check
                                    writeTo7 = writeTo
                                    isAffected7 = isAffected
                                    def _hx_local_6(e):
                                        _g7(e,writeTo7,isAffected7)
                                    hxsl_Tools.iter(e,_hx_local_6)
                            else:
                                _g9 = self.check
                                writeTo8 = writeTo
                                isAffected8 = isAffected
                                def _hx_local_7(e):
                                    _g9(e,writeTo8,isAffected8)
                                hxsl_Tools.iter(e,_hx_local_7)
                        else:
                            _g10 = self.check
                            writeTo9 = writeTo
                            isAffected9 = isAffected
                            def _hx_local_8(e):
                                _g10(e,writeTo9,isAffected9)
                            hxsl_Tools.iter(e,_hx_local_8)
                    else:
                        _g11 = self.check
                        writeTo10 = writeTo
                        isAffected10 = isAffected
                        def _hx_local_9(e):
                            _g11(e,writeTo10,isAffected10)
                        hxsl_Tools.iter(e,_hx_local_9)
                elif (tmp == 64):
                    if (len(_g8) == 4):
                        _g12 = (_g8[0] if 0 < len(_g8) else None)
                        _g13 = (_g8[3] if 3 < len(_g8) else None)
                        _g14 = _g12.e
                        _g15 = _g12.p
                        _g15 = _g12.t
                        if (_g14.index == 1):
                            _g12 = _g13.e
                            _g15 = _g13.p
                            _g15 = _g13.t
                            if (_g12.index == 0):
                                _g13 = _g12.params[0]
                                if (_g13.index == 2):
                                    cid = _g13.params[0]
                                    lod = (_g8[2] if 2 < len(_g8) else None)
                                    uv = (_g8[1] if 1 < len(_g8) else None)
                                    c = _g14.params[0]
                                    self.check(uv,writeTo,isAffected)
                                    self.check(lod,writeTo,isAffected)
                                    if ((self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None) is None):
                                        python_internal_ArrayImpl._set(self.channelVars, cid, c)
                                        self.link(c,writeTo)
                                    else:
                                        self.link((self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None),writeTo)
                                else:
                                    _g8 = self.check
                                    writeTo11 = writeTo
                                    isAffected11 = isAffected
                                    def _hx_local_10(e):
                                        _g8(e,writeTo11,isAffected11)
                                    hxsl_Tools.iter(e,_hx_local_10)
                            else:
                                _g12 = self.check
                                writeTo12 = writeTo
                                isAffected12 = isAffected
                                def _hx_local_11(e):
                                    _g12(e,writeTo12,isAffected12)
                                hxsl_Tools.iter(e,_hx_local_11)
                        else:
                            _g13 = self.check
                            writeTo13 = writeTo
                            isAffected13 = isAffected
                            def _hx_local_12(e):
                                _g13(e,writeTo13,isAffected13)
                            hxsl_Tools.iter(e,_hx_local_12)
                    else:
                        _g14 = self.check
                        writeTo14 = writeTo
                        isAffected14 = isAffected
                        def _hx_local_13(e):
                            _g14(e,writeTo14,isAffected14)
                        hxsl_Tools.iter(e,_hx_local_13)
                else:
                    _g15 = self.check
                    writeTo15 = writeTo
                    isAffected15 = isAffected
                    def _hx_local_14(e):
                        _g15(e,writeTo15,isAffected15)
                    hxsl_Tools.iter(e,_hx_local_14)
            else:
                _g16 = self.check
                writeTo16 = writeTo
                isAffected16 = isAffected
                def _hx_local_15(e):
                    _g16(e,writeTo16,isAffected16)
                hxsl_Tools.iter(e,_hx_local_15)
        elif (tmp == 10):
            e1 = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            affect = []
            self.check(eif,writeTo,affect)
            if (eelse is not None):
                self.check(eelse,writeTo,affect)
            _hx_len = len(affect)
            _g17 = 0
            while (_g17 < len(writeTo)):
                v = (writeTo[_g17] if _g17 >= 0 and _g17 < len(writeTo) else None)
                _g17 = (_g17 + 1)
                if (python_internal_ArrayImpl.indexOf(affect,v,None) < 0):
                    affect.append(v)
            self.check(e1,affect,isAffected)
            _g17 = 0
            _g18 = _hx_len
            while (_g17 < _g18):
                i = _g17
                _g17 = (_g17 + 1)
                v = (affect[i] if i >= 0 and i < len(affect) else None)
                if (python_internal_ArrayImpl.indexOf(isAffected,v,None) < 0):
                    isAffected.append(v)
        elif (tmp == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            affect = []
            self.check(loop,writeTo,affect)
            self.check(it,affect,isAffected)
            _g = 0
            while (_g < len(affect)):
                v = (affect[_g] if _g >= 0 and _g < len(affect) else None)
                _g = (_g + 1)
                if (python_internal_ArrayImpl.indexOf(isAffected,v,None) < 0):
                    isAffected.append(v)
        else:
            _g = self.check
            writeTo17 = writeTo
            isAffected17 = isAffected
            def _hx_local_18(e):
                _g(e,writeTo17,isAffected17)
            hxsl_Tools.iter(e,_hx_local_18)

    def checkBranches(self,e):
        _g = e.e
        if (_g.index == 10):
            _g1 = _g.params[1]
            _g1 = _g.params[2]
            cond = _g.params[0]
            writeTo = [None]
            self.check(cond,writeTo,[])
        hxsl_Tools.iter(e,self.checkBranches)

    def mapExpr(self,e,isVar):
        _gthis = self
        _g = e.e
        tmp = _g.index
        if (tmp == 4):
            el = _g.params[0]
            out = []
            count = 0
            _g1 = 0
            while (_g1 < len(el)):
                e1 = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                isVar1 = (isVar and ((count == ((len(el) - 1)))))
                e2 = self.mapExpr(e1,isVar1)
                if (hxsl_Tools.hasSideEffect(e2) or isVar1):
                    out.append(e2)
                count = (count + 1)
            return _hx_AnonObject({'e': hxsl_TExprDef.TBlock(out), 'p': e.p, 't': e.t})
        elif (tmp == 5):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g.params[2]
            tmp = _g1.index
            if (tmp == 4):
                _g3 = _g2.e
                _g4 = _g2.p
                _g4 = _g2.t
                tmp = _g3.index
                if (tmp == 1):
                    v = _g3.params[0]
                    if (not self.get(v).used):
                        return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
                    else:
                        def _hx_local_3():
                            def _hx_local_2(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_2)
                        return _hx_local_3()
                elif (tmp == 9):
                    _g4 = _g3.params[0]
                    _g5 = _g3.params[1]
                    _g3 = _g4.e
                    _g5 = _g4.p
                    _g5 = _g4.t
                    if (_g3.index == 1):
                        v = _g3.params[0]
                        if (not self.get(v).used):
                            return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
                        else:
                            def _hx_local_5():
                                def _hx_local_4(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_4)
                            return _hx_local_5()
                    else:
                        def _hx_local_7():
                            def _hx_local_6(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_6)
                        return _hx_local_7()
                else:
                    def _hx_local_9():
                        def _hx_local_8(e):
                            return _gthis.mapExpr(e,True)
                        return hxsl_Tools.map(e,_hx_local_8)
                    return _hx_local_9()
            elif (tmp == 20):
                _g3 = _g1.params[0]
                _g1 = _g2.e
                _g3 = _g2.p
                _g3 = _g2.t
                tmp = _g1.index
                if (tmp == 1):
                    v = _g1.params[0]
                    if (not self.get(v).used):
                        return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
                    else:
                        def _hx_local_11():
                            def _hx_local_10(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_10)
                        return _hx_local_11()
                elif (tmp == 9):
                    _g2 = _g1.params[0]
                    _g3 = _g1.params[1]
                    _g1 = _g2.e
                    _g3 = _g2.p
                    _g3 = _g2.t
                    if (_g1.index == 1):
                        v = _g1.params[0]
                        if (not self.get(v).used):
                            return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
                        else:
                            def _hx_local_13():
                                def _hx_local_12(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_12)
                            return _hx_local_13()
                    else:
                        def _hx_local_15():
                            def _hx_local_14(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_14)
                        return _hx_local_15()
                else:
                    def _hx_local_17():
                        def _hx_local_16(e):
                            return _gthis.mapExpr(e,True)
                        return hxsl_Tools.map(e,_hx_local_16)
                    return _hx_local_17()
            else:
                def _hx_local_19():
                    def _hx_local_18(e):
                        return _gthis.mapExpr(e,True)
                    return hxsl_Tools.map(e,_hx_local_18)
                return _hx_local_19()
        elif (tmp == 7):
            _g1 = _g.params[1]
            v = _g.params[0]
            if (not self.get(v).used):
                return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
            else:
                def _hx_local_21():
                    def _hx_local_20(e):
                        return _gthis.mapExpr(e,True)
                    return hxsl_Tools.map(e,_hx_local_20)
                return _hx_local_21()
        elif (tmp == 8):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g1.e
            _g4 = _g1.p
            _g4 = _g1.t
            if (_g3.index == 2):
                tmp = _g3.params[0].index
                if (tmp == 63):
                    if (len(_g2) == 3):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g1 = (_g2[2] if 2 < len(_g2) else None)
                        _g3 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g3.index == 0):
                            _g1 = _g3.params[0]
                            if (_g1.index == 2):
                                cid = _g1.params[0]
                                uv = (_g2[1] if 1 < len(_g2) else None)
                                c = (self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texture), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c), 't': c.type, 'p': e.p}), self.mapExpr(uv,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_23():
                                    def _hx_local_22(e):
                                        return _gthis.mapExpr(e,True)
                                    return hxsl_Tools.map(e,_hx_local_22)
                                return _hx_local_23()
                        else:
                            def _hx_local_25():
                                def _hx_local_24(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_24)
                            return _hx_local_25()
                    else:
                        def _hx_local_27():
                            def _hx_local_26(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_26)
                        return _hx_local_27()
                elif (tmp == 64):
                    if (len(_g2) == 4):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g1 = (_g2[3] if 3 < len(_g2) else None)
                        _g3 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g3.index == 0):
                            _g1 = _g3.params[0]
                            if (_g1.index == 2):
                                cid = _g1.params[0]
                                lod = (_g2[2] if 2 < len(_g2) else None)
                                uv = (_g2[1] if 1 < len(_g2) else None)
                                c = (self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureLod), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c), 't': c.type, 'p': e.p}), self.mapExpr(uv,True), self.mapExpr(lod,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_29():
                                    def _hx_local_28(e):
                                        return _gthis.mapExpr(e,True)
                                    return hxsl_Tools.map(e,_hx_local_28)
                                return _hx_local_29()
                        else:
                            def _hx_local_31():
                                def _hx_local_30(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_30)
                            return _hx_local_31()
                    else:
                        def _hx_local_33():
                            def _hx_local_32(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_32)
                        return _hx_local_33()
                elif (tmp == 65):
                    _g1 = len(_g2)
                    if (_g1 == 3):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g1 = (_g2[2] if 2 < len(_g2) else None)
                        _g3 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g3.index == 0):
                            _g1 = _g3.params[0]
                            if (_g1.index == 2):
                                cid = _g1.params[0]
                                pos = (_g2[1] if 1 < len(_g2) else None)
                                c = (self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c), 't': c.type, 'p': e.p}), self.mapExpr(pos,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_35():
                                    def _hx_local_34(e):
                                        return _gthis.mapExpr(e,True)
                                    return hxsl_Tools.map(e,_hx_local_34)
                                return _hx_local_35()
                        else:
                            def _hx_local_37():
                                def _hx_local_36(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_36)
                            return _hx_local_37()
                    elif (_g1 == 4):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g1 = (_g2[3] if 3 < len(_g2) else None)
                        _g3 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g3.index == 0):
                            _g1 = _g3.params[0]
                            if (_g1.index == 2):
                                cid = _g1.params[0]
                                lod = (_g2[2] if 2 < len(_g2) else None)
                                pos = (_g2[1] if 1 < len(_g2) else None)
                                c = (self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c), 't': c.type, 'p': e.p}), self.mapExpr(pos,True), self.mapExpr(lod,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_39():
                                    def _hx_local_38(e):
                                        return _gthis.mapExpr(e,True)
                                    return hxsl_Tools.map(e,_hx_local_38)
                                return _hx_local_39()
                        else:
                            def _hx_local_41():
                                def _hx_local_40(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_40)
                            return _hx_local_41()
                    else:
                        def _hx_local_43():
                            def _hx_local_42(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_42)
                        return _hx_local_43()
                elif (tmp == 66):
                    _g1 = len(_g2)
                    if (_g1 == 2):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g1 = (_g2[1] if 1 < len(_g2) else None)
                        _g3 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g3.index == 0):
                            _g1 = _g3.params[0]
                            if (_g1.index == 2):
                                cid = _g1.params[0]
                                c = (self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureSize), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c), 't': c.type, 'p': e.p})]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_45():
                                    def _hx_local_44(e):
                                        return _gthis.mapExpr(e,True)
                                    return hxsl_Tools.map(e,_hx_local_44)
                                return _hx_local_45()
                        else:
                            def _hx_local_47():
                                def _hx_local_46(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_46)
                            return _hx_local_47()
                    elif (_g1 == 3):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g1 = (_g2[2] if 2 < len(_g2) else None)
                        _g3 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g3.index == 0):
                            _g1 = _g3.params[0]
                            if (_g1.index == 2):
                                cid = _g1.params[0]
                                lod = (_g2[1] if 1 < len(_g2) else None)
                                c = (self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureSize), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c), 't': c.type, 'p': e.p}), self.mapExpr(lod,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_49():
                                    def _hx_local_48(e):
                                        return _gthis.mapExpr(e,True)
                                    return hxsl_Tools.map(e,_hx_local_48)
                                return _hx_local_49()
                        else:
                            def _hx_local_51():
                                def _hx_local_50(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_50)
                            return _hx_local_51()
                    else:
                        def _hx_local_53():
                            def _hx_local_52(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_52)
                        return _hx_local_53()
                else:
                    def _hx_local_55():
                        def _hx_local_54(e):
                            return _gthis.mapExpr(e,True)
                        return hxsl_Tools.map(e,_hx_local_54)
                    return _hx_local_55()
            else:
                def _hx_local_57():
                    def _hx_local_56(e):
                        return _gthis.mapExpr(e,True)
                    return hxsl_Tools.map(e,_hx_local_56)
                return _hx_local_57()
        elif (tmp == 10):
            e1 = _g.params[0]
            econd = _g.params[1]
            eelse = _g.params[2]
            e2 = self.mapExpr(e1,True)
            econd1 = self.mapExpr(econd,isVar)
            eelse1 = (None if ((eelse is None)) else self.mapExpr(eelse,isVar))
            if (((not isVar) and (not hxsl_Tools.hasSideEffect(econd1))) and (((eelse1 is None) or (not hxsl_Tools.hasSideEffect(eelse1))))):
                return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e2.t, 'p': e2.p})
            return _hx_AnonObject({'e': hxsl_TExprDef.TIf(e2,econd1,eelse1), 'p': e2.p, 't': e2.t})
        elif (tmp == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            it1 = self.mapExpr(it,True)
            loop1 = self.mapExpr(loop,False)
            if (not hxsl_Tools.hasSideEffect(loop1)):
                return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
            return _hx_AnonObject({'e': hxsl_TExprDef.TFor(v,it1,loop1), 'p': e.p, 't': e.t})
        else:
            def _hx_local_59():
                def _hx_local_58(e):
                    return _gthis.mapExpr(e,True)
                return hxsl_Tools.map(e,_hx_local_58)
            return _hx_local_59()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.used = None
        _hx_o.channelVars = None
        _hx_o.markAsKeep = None
hxsl_Dce._hx_class = hxsl_Dce
_hx_classes["hxsl.Dce"] = hxsl_Dce


class hxsl_Eval:
    _hx_class_name = "hxsl.Eval"
    _hx_is_interface = "False"
    __slots__ = ("varMap", "inlineCalls", "unrollLoops", "eliminateConditionals", "constants", "funMap", "curFun", "markReturn")
    _hx_fields = ["varMap", "inlineCalls", "unrollLoops", "eliminateConditionals", "constants", "funMap", "curFun", "markReturn"]
    _hx_methods = ["setConstant", "mapVar", "checkSamplerRec", "needsInline", "eval", "hasReturn", "hasReturnLoop", "handleReturn", "handleReturnDef", "evalCall", "constantsToString", "ifBlock", "evalExpr"]

    def __init__(self):
        self.markReturn = None
        self.curFun = None
        self.eliminateConditionals = None
        self.unrollLoops = None
        self.inlineCalls = None
        self.varMap = haxe_ds_ObjectMap()
        self.funMap = haxe_ds_ObjectMap()
        self.constants = haxe_ds_IntMap()

    def setConstant(self,v,c):
        self.constants.set(v.id,hxsl_TExprDef.TConst(c))

    def mapVar(self,v):
        v2 = self.varMap.h.get(v,None)
        if (v2 is not None):
            if (v == v2):
                return v2
            else:
                return self.mapVar(v2)
        if (Reflect.field(v,"parent") is not None):
            self.mapVar(Reflect.field(v,"parent"))
            v2 = self.varMap.h.get(v,None)
            if (v2 is not None):
                if (v == v2):
                    return v2
                else:
                    return self.mapVar(v2)
        _g = v.type
        v21 = None
        if (_g.index == 17):
            _g1 = _g.params[0]
            v21 = True
        else:
            v21 = False
        v2 = _hx_AnonObject({'id': (v.id if v21 else hxsl_Tools.allocVarId()), 'name': v.name, 'type': v.type, 'kind': v.kind})
        if (Reflect.field(v,"parent") is not None):
            Reflect.setField(v2,"parent",self.mapVar(Reflect.field(v,"parent")))
        if (Reflect.field(v,"qualifiers") is not None):
            Reflect.setField(v2,"qualifiers",list(Reflect.field(v,"qualifiers")))
        self.varMap.set(v,v2)
        self.varMap.set(v2,v2)
        _g = v2.type
        tmp = _g.index
        if (tmp == 13):
            vl = _g.params[0]
            _g1 = []
            _g2 = 0
            while (_g2 < len(vl)):
                v = (vl[_g2] if _g2 >= 0 and _g2 < len(vl) else None)
                _g2 = (_g2 + 1)
                x = self.mapVar(v)
                _g1.append(x)
            v2.type = hxsl_Type.TStruct(_g1)
        elif (tmp == 15):
            _g1 = _g.params[1]
            if (_g1.index == 1):
                vs = _g1.params[0]
                t = _g.params[0]
                c = self.constants.h.get(vs.id,None)
                if (c is not None):
                    if (c is None):
                        hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                    elif (c.index == 0):
                        _g1 = c.params[0]
                        if (_g1.index == 2):
                            v = _g1.params[0]
                            _g1 = v2.type
                            tmp = None
                            if (_g1.index == 15):
                                _g2 = _g1.params[0]
                                _g2 = _g1.params[1]
                                tmp = True
                            else:
                                tmp = False
                            v2.type = (hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(v)) if tmp else hxsl_Type.TBuffer(t,hxsl_SizeDecl.SConst(v)))
                        else:
                            hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                    else:
                        hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                else:
                    vs2 = self.mapVar(vs)
                    _g1 = v2.type
                    tmp = None
                    if (_g1.index == 15):
                        _g2 = _g1.params[0]
                        _g2 = _g1.params[1]
                        tmp = True
                    else:
                        tmp = False
                    v2.type = (hxsl_Type.TArray(t,hxsl_SizeDecl.SVar(vs2)) if tmp else hxsl_Type.TBuffer(t,hxsl_SizeDecl.SVar(vs2)))
        elif (tmp == 16):
            _g1 = _g.params[1]
            if (_g1.index == 1):
                vs = _g1.params[0]
                t = _g.params[0]
                c = self.constants.h.get(vs.id,None)
                if (c is not None):
                    if (c is None):
                        hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                    elif (c.index == 0):
                        _g = c.params[0]
                        if (_g.index == 2):
                            v = _g.params[0]
                            _g = v2.type
                            tmp = None
                            if (_g.index == 15):
                                _g1 = _g.params[0]
                                _g1 = _g.params[1]
                                tmp = True
                            else:
                                tmp = False
                            v2.type = (hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(v)) if tmp else hxsl_Type.TBuffer(t,hxsl_SizeDecl.SConst(v)))
                        else:
                            hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                    else:
                        hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                else:
                    vs2 = self.mapVar(vs)
                    _g = v2.type
                    tmp = None
                    if (_g.index == 15):
                        _g1 = _g.params[0]
                        _g1 = _g.params[1]
                        tmp = True
                    else:
                        tmp = False
                    v2.type = (hxsl_Type.TArray(t,hxsl_SizeDecl.SVar(vs2)) if tmp else hxsl_Type.TBuffer(t,hxsl_SizeDecl.SVar(vs2)))
        else:
            pass
        return v2

    def checkSamplerRec(self,t):
        if hxsl_Tools.isSampler(t):
            return True
        tmp = t.index
        if (tmp == 13):
            vl = t.params[0]
            _g = 0
            while (_g < len(vl)):
                v = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                if self.checkSamplerRec(v.type):
                    return True
            return False
        elif (tmp == 15):
            _g = t.params[1]
            t1 = t.params[0]
            return self.checkSamplerRec(t1)
        elif (tmp == 16):
            _g = t.params[0]
            size = t.params[1]
            return True
        else:
            pass
        return False

    def needsInline(self,f):
        _g = 0
        _g1 = f.args
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if self.checkSamplerRec(a.type):
                return True
        return False

    def eval(self,s):
        funs = []
        _g = 0
        _g1 = s.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f1 = f.kind
            f2 = self.mapVar(f.ref)
            _g2 = []
            _g3 = 0
            _g4 = f.args
            while (_g3 < len(_g4)):
                a = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                _g3 = (_g3 + 1)
                x = self.mapVar(a)
                _g2.append(x)
            f21 = _hx_AnonObject({'kind': f1, 'ref': f2, 'args': _g2, 'ret': f.ret, 'expr': f.expr})
            if (((f.kind == hxsl_FunctionKind.Helper) and self.inlineCalls) or self.needsInline(f21)):
                self.funMap.set(f21.ref,f)
            else:
                funs.append(f21)
        _g = 0
        _g1 = len(funs)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.curFun = (funs[i] if i >= 0 and i < len(funs) else None)
            self.curFun.expr = self.evalExpr(self.curFun.expr,False)
        s1 = s.name
        _g = []
        _g1 = 0
        _g2 = s.vars
        while (_g1 < len(_g2)):
            v = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = self.mapVar(v)
            _g.append(x)
        return _hx_AnonObject({'name': s1, 'vars': _g, 'funs': funs})

    def hasReturn(self,e):
        self.markReturn = False
        self.hasReturnLoop(e)
        return self.markReturn

    def hasReturnLoop(self,e):
        _g = e.e
        if (_g.index == 12):
            _g1 = _g.params[0]
            self.markReturn = True
        elif (not self.markReturn):
            hxsl_Tools.iter(e,self.hasReturnLoop)

    def handleReturn(self,e,isFinal = None):
        if (isFinal is None):
            isFinal = False
        _g = e.e
        tmp = _g.index
        if (tmp == 3):
            v = _g.params[0]
            v1 = self.handleReturn(v,isFinal)
            return _hx_AnonObject({'e': hxsl_TExprDef.TParenthesis(v1), 't': v1.t, 'p': e.p})
        elif (tmp == 4):
            el = _g.params[0]
            i = 0
            last = len(el)
            out = []
            while (i < last):
                e1 = i
                i = (i + 1)
                e2 = (el[e1] if e1 >= 0 and e1 < len(el) else None)
                if (i == last):
                    x = self.handleReturn(e2,isFinal)
                    out.append(x)
                else:
                    _g1 = e2.e
                    tmp = _g1.index
                    if (tmp == 10):
                        if (_g1.params[2] is None):
                            eif = _g1.params[1]
                            econd = _g1.params[0]
                            if (isFinal and self.hasReturn(eif)):
                                x1 = self.handleReturn(_hx_AnonObject({'e': hxsl_TExprDef.TIf(econd,eif,_hx_AnonObject({'e': hxsl_TExprDef.TBlock(el[i:None]), 't': e2.t, 'p': e2.p})), 't': e2.t, 'p': e2.p}))
                                out.append(x1)
                                break
                            else:
                                x2 = self.handleReturn(e2)
                                out.append(x2)
                        else:
                            x3 = self.handleReturn(e2)
                            out.append(x3)
                    elif (tmp == 12):
                        e3 = _g1.params[0]
                        x4 = self.handleReturn(e3,isFinal)
                        out.append(x4)
                        break
                    else:
                        x5 = self.handleReturn(e2)
                        out.append(x5)
            t = (python_internal_ArrayImpl._get(out, (len(out) - 1)).t if isFinal else e.t)
            return _hx_AnonObject({'e': hxsl_TExprDef.TBlock(out), 't': t, 'p': e.p})
        elif (tmp == 10):
            cond = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            if ((eelse is not None) and isFinal):
                cond1 = self.handleReturn(cond)
                eif1 = self.handleReturn(eif,isFinal)
                return _hx_AnonObject({'e': hxsl_TExprDef.TIf(cond1,eif1,self.handleReturn(eelse,isFinal)), 't': eif1.t, 'p': e.p})
            else:
                return hxsl_Tools.map(e,self.handleReturnDef)
        elif (tmp == 12):
            v = _g.params[0]
            if (not isFinal):
                hxsl_Error.t("Cannot inline not final return",e.p)
            if (v is None):
                return _hx_AnonObject({'e': hxsl_TExprDef.TBlock([]), 't': hxsl_Type.TVoid, 'p': e.p})
            return self.handleReturn(v,True)
        else:
            return hxsl_Tools.map(e,self.handleReturnDef)

    def handleReturnDef(self,e):
        return self.handleReturn(e)

    def evalCall(self,g,args,oldArgs,pos):
        tmp = g.index
        if (tmp == 38):
            if (len(args) == 1):
                _g = (args[0] if 0 < len(args) else None)
                _g1 = _g.e
                _g2 = _g.p
                _g2 = _g.t
                if (_g1.index == 0):
                    _g = _g1.params[0]
                    if (_g.index == 2):
                        i = _g.params[0]
                        return hxsl_TExprDef.TConst(hxsl_Const.CFloat(i))
                    else:
                        return None
                else:
                    return None
            else:
                return None
        elif ((tmp == 64) or ((tmp == 63))):
            i = None
            _g = (args[0] if 0 < len(args) else None).e
            if (_g.index == 0):
                _g1 = _g.params[0]
                if (_g1.index == 2):
                    i1 = _g1.params[0]
                    i = i1
                else:
                    hxsl_Error.t(((("Cannot eval complex channel " + HxOverrides.stringOrNull(hxsl_Printer.toString((args[0] if 0 < len(args) else None),True))) + " ") + HxOverrides.stringOrNull(self.constantsToString())),pos)
                    raise haxe_Exception.thrown("assert")
            else:
                hxsl_Error.t(((("Cannot eval complex channel " + HxOverrides.stringOrNull(hxsl_Printer.toString((args[0] if 0 < len(args) else None),True))) + " ") + HxOverrides.stringOrNull(self.constantsToString())),pos)
                raise haxe_Exception.thrown("assert")
            channel = (oldArgs[0] if 0 < len(oldArgs) else None)
            _g = channel.e
            channel1 = None
            if (_g.index == 1):
                v = _g.params[0]
                channel1 = hxsl_TExprDef.TVar(self.mapVar(v))
            else:
                raise haxe_Exception.thrown("assert")
            channel = _hx_AnonObject({'e': channel1, 't': channel.t, 'p': channel.p})
            count = None
            _g = channel.t
            if (_g.index == 17):
                i1 = _g.params[0]
                count = i1
            else:
                raise haxe_Exception.thrown("assert")
            channelMode = Type.createEnumIndex(hxsl_Channel,(i & 7),None)
            targs = [channel]
            _g = 1
            _g1 = len(args)
            while (_g < _g1):
                i1 = _g
                _g = (_g + 1)
                targs.append((args[i1] if i1 >= 0 and i1 < len(args) else None))
            targs.append(_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((i >> 3))), 't': hxsl_Type.TInt, 'p': pos}))
            tget = _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(g), 't': hxsl_Type.TVoid, 'p': pos}),targs), 't': hxsl_Type.TVoid, 'p': pos})
            tmp = channelMode.index
            if (tmp == 0):
                zero = _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CFloat(0.)), 't': hxsl_Type.TFloat, 'p': pos})
                if (count == 1):
                    return zero.e
                return hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(python_internal_ArrayImpl._get([hxsl_TGlobal.Vec2, hxsl_TGlobal.Vec3, hxsl_TGlobal.Vec4], (count - 2))), 't': hxsl_Type.TVoid, 'p': pos}),[zero])
            elif ((((tmp == 4) or ((tmp == 3))) or ((tmp == 2))) or ((tmp == 1))):
                tmp = None
                count1 = count
                if (count1 == 1):
                    tmp1 = channelMode.index
                    if (tmp1 == 1):
                        tmp = [hxsl_Component.X]
                    elif (tmp1 == 2):
                        tmp = [hxsl_Component.Y]
                    elif (tmp1 == 3):
                        tmp = [hxsl_Component.Z]
                    elif (tmp1 == 4):
                        tmp = [hxsl_Component.W]
                    else:
                        raise haxe_Exception.thrown((((("Invalid channel value " + Std.string(channelMode)) + " for ") + Std.string(count)) + " channels"))
                elif (count1 == 2):
                    tmp1 = channelMode.index
                    if (tmp1 == 1):
                        tmp = [hxsl_Component.X, hxsl_Component.Y]
                    elif (tmp1 == 2):
                        tmp = [hxsl_Component.Y, hxsl_Component.Z]
                    elif (tmp1 == 3):
                        tmp = [hxsl_Component.Z, hxsl_Component.W]
                    else:
                        raise haxe_Exception.thrown((((("Invalid channel value " + Std.string(channelMode)) + " for ") + Std.string(count)) + " channels"))
                elif (count1 == 3):
                    tmp1 = channelMode.index
                    if (tmp1 == 1):
                        tmp = [hxsl_Component.X, hxsl_Component.Y, hxsl_Component.Z]
                    elif (tmp1 == 2):
                        tmp = [hxsl_Component.Y, hxsl_Component.Z, hxsl_Component.W]
                    else:
                        raise haxe_Exception.thrown((((("Invalid channel value " + Std.string(channelMode)) + " for ") + Std.string(count)) + " channels"))
                else:
                    raise haxe_Exception.thrown((((("Invalid channel value " + Std.string(channelMode)) + " for ") + Std.string(count)) + " channels"))
                return hxsl_TExprDef.TSwiz(tget,tmp)
            elif (tmp == 5):
                return hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Unpack), 't': hxsl_Type.TVoid, 'p': pos}),[tget])
            elif (tmp == 6):
                return hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.UnpackNormal), 't': hxsl_Type.TVoid, 'p': pos}),[tget])
            else:
                pass
        elif (tmp == 67):
            args1 = args
            _g = 0
            while (_g < len(args1)):
                a = (args1[_g] if _g >= 0 and _g < len(args1) else None)
                _g = (_g + 1)
                haxe_Log.trace(hxsl_Printer.toString(a),_hx_AnonObject({'fileName': a.p.file, 'lineNumber': 0, 'className': None, 'methodName': None}))
            return hxsl_TExprDef.TBlock([])
        else:
            return None

    def constantsToString(self):
        _g = []
        c = self.constants.keys()
        while c.hasNext():
            c1 = c.next()
            x = ((Std.string(c1) + " => ") + HxOverrides.stringOrNull(hxsl_Printer.toString(_hx_AnonObject({'e': self.constants.h.get(c1,None), 't': hxsl_Type.TVoid, 'p': None}),True)))
            _g.append(x)
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))) + "]")

    def ifBlock(self,e):
        tmp = None
        if (e is not None):
            _g = e.e
            tmp1 = None
            if (_g.index == 10):
                _g1 = _g.params[0]
                _g1 = _g.params[1]
                _g1 = _g.params[2]
                tmp1 = True
            else:
                tmp1 = False
            tmp = (not tmp1)
        else:
            tmp = True
        if tmp:
            return e
        return _hx_AnonObject({'e': hxsl_TExprDef.TBlock([e]), 't': e.t, 'p': e.p})

    def evalExpr(self,e,isVal = None):
        if (isVal is None):
            isVal = True
        _gthis = self
        d = None
        _g = e.e
        d1 = _g.index
        if (d1 == 0):
            _g1 = _g.params[0]
            d = e.e
        elif (d1 == 1):
            v = _g.params[0]
            c = self.constants.h.get(v.id,None)
            if (c is not None):
                d = c
            else:
                v2 = self.mapVar(v)
                d = hxsl_TExprDef.TVar(v2)
        elif (d1 == 2):
            _g1 = _g.params[0]
            d = e.e
        elif (d1 == 3):
            e1 = _g.params[0]
            e2 = self.evalExpr(e1,isVal)
            _g1 = e2.e
            if (_g1.index == 0):
                _g2 = _g1.params[0]
                d = e2.e
            else:
                d = hxsl_TExprDef.TParenthesis(e2)
        elif (d1 == 4):
            el = _g.params[0]
            out = []
            last = (len(el) - 1)
            _g1 = 0
            _g2 = len(el)
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                isVal1 = (isVal and ((i == last)))
                e1 = self.evalExpr((el[i] if i >= 0 and i < len(el) else None),isVal1)
                _g3 = e1.e
                d1 = _g3.index
                if (d1 == 0):
                    _g4 = _g3.params[0]
                    if isVal1:
                        out.append(e1)
                elif (d1 == 1):
                    _g5 = _g3.params[0]
                    if isVal1:
                        out.append(e1)
                else:
                    out.append(e1)
            d = ((out[0] if 0 < len(out) else None).e if (((len(out) == 1) and ((self.curFun.kind != hxsl_FunctionKind.Init)))) else hxsl_TExprDef.TBlock(out))
        elif (d1 == 5):
            op = _g.params[0]
            e1 = _g.params[1]
            e2 = _g.params[2]
            e11 = self.evalExpr(e1)
            e21 = self.evalExpr(e2)
            d1 = op.index
            if (d1 == 0):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                x = (a + b)
                                d1 = None
                                try:
                                    d1 = int(x)
                                except BaseException as _g1:
                                    None
                                    d1 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d1))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 3):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat((a + b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 1):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                x = (a * b)
                                d1 = None
                                try:
                                    d1 = int(x)
                                except BaseException as _g1:
                                    None
                                    d1 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d1))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 3):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat((a * b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 2):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                x = (a / b)
                                d1 = None
                                try:
                                    d1 = int(x)
                                except BaseException as _g1:
                                    None
                                    d1 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d1))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 3):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat((a / b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 3):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                x = (a - b)
                                d1 = None
                                try:
                                    d1 = int(x)
                                except BaseException as _g1:
                                    None
                                    d1 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d1))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 3):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat((a - b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif ((d1 == 21) or ((d1 == 4))):
                d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 5):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(True)) if ((_g2.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(False))) if ((_g2.index == 0)) else hxsl_TExprDef.TBinop(op,e11,e21))
                    elif (d1 == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 1):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a == b)) else 1)) == 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 2):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 2):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a - b) == 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 3):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) == 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 4):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            d1 = _g3.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 4):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) == 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 6):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(False)) if ((_g2.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(True))) if ((_g2.index == 0)) else hxsl_TExprDef.TBinop(op,e11,e21))
                    elif (d1 == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 1):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a == b)) else 1)) != 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 2):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 2):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a - b) != 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 3):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) != 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 4):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            d1 = _g3.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 4):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) != 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 7):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(False)) if ((_g2.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(False))) if ((_g2.index == 0)) else hxsl_TExprDef.TBinop(op,e11,e21))
                    elif (d1 == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 1):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a == b)) else 1)) > 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 2):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 2):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a - b) > 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 3):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) > 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 4):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            d1 = _g3.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 4):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) > 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 8):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(True)) if ((_g2.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(False))) if ((_g2.index == 0)) else hxsl_TExprDef.TBinop(op,e11,e21))
                    elif (d1 == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 1):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a == b)) else 1)) >= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 2):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 2):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a - b) >= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 3):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) >= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 4):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            d1 = _g3.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 4):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) >= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 9):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(False)) if ((_g2.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(True))) if ((_g2.index == 0)) else hxsl_TExprDef.TBinop(op,e11,e21))
                    elif (d1 == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 1):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a == b)) else 1)) < 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 2):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 2):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a - b) < 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 3):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) < 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 4):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            d1 = _g3.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 4):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) < 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 10):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(True)) if ((_g2.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(True))) if ((_g2.index == 0)) else hxsl_TExprDef.TBinop(op,e11,e21))
                    elif (d1 == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 1):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a == b)) else 1)) <= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 2):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 2):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a - b) <= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 3):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) <= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 4):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            d1 = _g3.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 4):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) <= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 11):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a & b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 12):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a | b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 13):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a ^ b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 14):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            if (_g3.index == 1):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a and b)))
                            else:
                                a = _g1
                                d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == False)) else e21.e)
                        else:
                            a = _g1
                            d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == False)) else e21.e)
                    elif (_g2.index == 0):
                        _g1 = _g2.params[0]
                        if (_g1.index == 1):
                            a = _g1.params[0]
                            d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == False)) else e11.e)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                elif (_g2.index == 0):
                    _g1 = _g2.params[0]
                    if (_g1.index == 1):
                        a = _g1.params[0]
                        d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == False)) else e11.e)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 15):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            if (_g3.index == 1):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a or b)))
                            else:
                                a = _g1
                                d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == True)) else e21.e)
                        else:
                            a = _g1
                            d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == True)) else e21.e)
                    elif (_g2.index == 0):
                        _g1 = _g2.params[0]
                        if (_g1.index == 1):
                            a = _g1.params[0]
                            d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == True)) else e11.e)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                elif (_g2.index == 0):
                    _g1 = _g2.params[0]
                    if (_g1.index == 1):
                        a = _g1.params[0]
                        d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == True)) else e11.e)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 16):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a << b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 17):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a >> b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 18):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(HxOverrides.rshift(a, b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 19):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                x = HxOverrides.mod(a, b)
                                d1 = None
                                try:
                                    d1 = int(x)
                                except BaseException as _g1:
                                    None
                                    d1 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d1))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 3):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(HxOverrides.modf(a, b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 20):
                _g1 = op.params[0]
                d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 22):
                raise haxe_Exception.thrown("assert")
            elif (d1 == 23):
                raise haxe_Exception.thrown("assert")
            else:
                pass
        elif (d1 == 6):
            op = _g.params[0]
            e1 = _g.params[1]
            e2 = self.evalExpr(e1)
            _g1 = e2.e
            if (_g1.index == 0):
                c = _g1.params[0]
                d1 = op.index
                if (d1 == 2):
                    if (c.index == 1):
                        b = c.params[0]
                        d = hxsl_TExprDef.TConst(hxsl_Const.CBool((not b)))
                    else:
                        d = hxsl_TExprDef.TUnop(op,e2)
                elif (d1 == 3):
                    d1 = c.index
                    if (d1 == 2):
                        i = c.params[0]
                        d = hxsl_TExprDef.TConst(hxsl_Const.CInt(-i))
                    elif (d1 == 3):
                        f = c.params[0]
                        d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(-f))
                    else:
                        d = hxsl_TExprDef.TUnop(op,e2)
                else:
                    d = hxsl_TExprDef.TUnop(op,e2)
            else:
                d = hxsl_TExprDef.TUnop(op,e2)
        elif (d1 == 7):
            v = _g.params[0]
            init = _g.params[1]
            d = hxsl_TExprDef.TVarDecl(self.mapVar(v),(None if ((init is None)) else self.evalExpr(init)))
        elif (d1 == 8):
            c = _g.params[0]
            eargs = _g.params[1]
            c1 = self.evalExpr(c)
            _g1 = []
            _g2 = 0
            while (_g2 < len(eargs)):
                a = (eargs[_g2] if _g2 >= 0 and _g2 < len(eargs) else None)
                _g2 = (_g2 + 1)
                x = self.evalExpr(a)
                _g1.append(x)
            args = _g1
            _g1 = c1.e
            d1 = _g1.index
            if (d1 == 1):
                v = _g1.params[0]
                if (v in self.funMap.h):
                    f = self.funMap.h.get(v,None)
                    outExprs = []
                    undo = []
                    _g2 = 0
                    _g3 = len(f.args)
                    while (_g2 < _g3):
                        i = _g2
                        _g2 = (_g2 + 1)
                        v = [(f.args[i] if i >= 0 and i < len(f.args) else None)]
                        e1 = (args[i] if i >= 0 and i < len(args) else None)
                        _g4 = e1.e
                        d1 = _g4.index
                        if (d1 == 0):
                            _g5 = _g4.params[0]
                            old = [self.constants.h.get((v[0] if 0 < len(v) else None).id,None)]
                            def _hx_local_2(old,v):
                                def _hx_local_1():
                                    if ((old[0] if 0 < len(old) else None) is None):
                                        _gthis.constants.remove((v[0] if 0 < len(v) else None).id)
                                    else:
                                        _gthis.constants.set((v[0] if 0 < len(v) else None).id,(old[0] if 0 < len(old) else None))
                                return _hx_local_1
                            undo.append(_hx_local_2(old,v))
                            self.constants.set((v[0] if 0 < len(v) else None).id,e1.e)
                        elif (d1 == 1):
                            _g6 = _g4.params[0]
                            _g7 = _g6.id
                            _g8 = _g6.name
                            _g9 = Reflect.field(_g6,"parent")
                            _g10 = Reflect.field(_g6,"qualifiers")
                            _g11 = _g6.type
                            d2 = _g6.kind.index
                            if (((d2 == 2) or ((d2 == 1))) or ((d2 == 0))):
                                old1 = [self.constants.h.get((v[0] if 0 < len(v) else None).id,None)]
                                def _hx_local_4(old,v):
                                    def _hx_local_3():
                                        if ((old[0] if 0 < len(old) else None) is None):
                                            _gthis.constants.remove((v[0] if 0 < len(v) else None).id)
                                        else:
                                            _gthis.constants.set((v[0] if 0 < len(v) else None).id,(old[0] if 0 < len(old) else None))
                                    return _hx_local_3
                                undo.append(_hx_local_4(old1,v))
                                self.constants.set((v[0] if 0 < len(v) else None).id,e1.e)
                            else:
                                old2 = [self.varMap.h.get((v[0] if 0 < len(v) else None),None)]
                                if ((old2[0] if 0 < len(old2) else None) is None):
                                    def _hx_local_6(v):
                                        def _hx_local_5():
                                            _gthis.varMap.remove((v[0] if 0 < len(v) else None))
                                        return _hx_local_5
                                    undo.append(_hx_local_6(v))
                                else:
                                    self.varMap.remove((v[0] if 0 < len(v) else None))
                                    def _hx_local_8(old,v):
                                        def _hx_local_7():
                                            _gthis.varMap.set((v[0] if 0 < len(v) else None),(old[0] if 0 < len(old) else None))
                                        return _hx_local_7
                                    undo.append(_hx_local_8(old2,v))
                                v2 = self.mapVar((v[0] if 0 < len(v) else None))
                                x = _hx_AnonObject({'e': hxsl_TExprDef.TVarDecl(v2,e1), 't': hxsl_Type.TVoid, 'p': e1.p})
                                outExprs.append(x)
                        else:
                            old3 = [self.varMap.h.get((v[0] if 0 < len(v) else None),None)]
                            if ((old3[0] if 0 < len(old3) else None) is None):
                                def _hx_local_10(v):
                                    def _hx_local_9():
                                        _gthis.varMap.remove((v[0] if 0 < len(v) else None))
                                    return _hx_local_9
                                undo.append(_hx_local_10(v))
                            else:
                                self.varMap.remove((v[0] if 0 < len(v) else None))
                                def _hx_local_12(old,v):
                                    def _hx_local_11():
                                        _gthis.varMap.set((v[0] if 0 < len(v) else None),(old[0] if 0 < len(old) else None))
                                    return _hx_local_11
                                undo.append(_hx_local_12(old3,v))
                            v21 = self.mapVar((v[0] if 0 < len(v) else None))
                            x1 = _hx_AnonObject({'e': hxsl_TExprDef.TVarDecl(v21,e1), 't': hxsl_Type.TVoid, 'p': e1.p})
                            outExprs.append(x1)
                    e1 = self.handleReturn(self.evalExpr(f.expr,False),True)
                    _g2 = 0
                    while (_g2 < len(undo)):
                        u = (undo[_g2] if _g2 >= 0 and _g2 < len(undo) else None)
                        _g2 = (_g2 + 1)
                        u()
                    _g2 = e1.e
                    if (_g2.index == 4):
                        el = _g2.params[0]
                        _g2 = 0
                        while (_g2 < len(el)):
                            e2 = (el[_g2] if _g2 >= 0 and _g2 < len(el) else None)
                            _g2 = (_g2 + 1)
                            outExprs.append(e2)
                    else:
                        outExprs.append(e1)
                    d = hxsl_TExprDef.TBlock(outExprs)
                else:
                    d = hxsl_TExprDef.TCall(c1,args)
            elif (d1 == 2):
                g = _g1.params[0]
                v1 = self.evalCall(g,args,eargs,e.p)
                d = (v1 if ((v1 is not None)) else hxsl_TExprDef.TCall(c1,args))
            else:
                d = hxsl_Error.t((("Cannot eval non-static call expresssion '" + HxOverrides.stringOrNull(hxsl_Printer().exprString(c1))) + "'"),c1.p)
        elif (d1 == 9):
            e1 = _g.params[0]
            r = _g.params[1]
            d = hxsl_TExprDef.TSwiz(self.evalExpr(e1),list(r))
        elif (d1 == 10):
            econd = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            econd1 = self.evalExpr(econd)
            _g1 = econd1.e
            if (_g1.index == 0):
                _g2 = _g1.params[0]
                if (_g2.index == 1):
                    b = _g2.params[0]
                    d = (self.evalExpr(eif,isVal).e if b else (hxsl_TExprDef.TConst(hxsl_Const.CNull) if ((eelse is None)) else self.evalExpr(eelse,isVal).e))
                elif ((isVal and ((eelse is not None))) and self.eliminateConditionals):
                    d = hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), 't': e.t, 'p': e.p}),[self.evalExpr(eelse,True), self.evalExpr(eif,True), _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), 't': hxsl_Type.TFun([]), 'p': econd1.p}),[econd1]), 't': hxsl_Type.TFloat, 'p': e.p})])
                else:
                    eif = self.evalExpr(eif,isVal)
                    if (eelse is not None):
                        eelse = self.evalExpr(eelse,isVal)
                        _g1 = eelse.e
                        if ((_g1.index == 0) and ((_g1.params[0].index == 0))):
                            eelse = None
                    eif = self.ifBlock(eif)
                    eelse = self.ifBlock(eelse)
                    d = hxsl_TExprDef.TIf(econd1,eif,eelse)
            elif ((isVal and ((eelse is not None))) and self.eliminateConditionals):
                d = hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), 't': e.t, 'p': e.p}),[self.evalExpr(eelse,True), self.evalExpr(eif,True), _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), 't': hxsl_Type.TFun([]), 'p': econd1.p}),[econd1]), 't': hxsl_Type.TFloat, 'p': e.p})])
            else:
                eif = self.evalExpr(eif,isVal)
                if (eelse is not None):
                    eelse = self.evalExpr(eelse,isVal)
                    _g1 = eelse.e
                    if ((_g1.index == 0) and ((_g1.params[0].index == 0))):
                        eelse = None
                eif = self.ifBlock(eif)
                eelse = self.ifBlock(eelse)
                d = hxsl_TExprDef.TIf(econd1,eif,eelse)
        elif (d1 == 11):
            d = hxsl_TExprDef.TDiscard
        elif (d1 == 12):
            e1 = _g.params[0]
            d = hxsl_TExprDef.TReturn((None if ((e1 is None)) else self.evalExpr(e1)))
        elif (d1 == 13):
            v1 = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            v2 = self.mapVar(v1)
            it1 = self.evalExpr(it)
            e1 = None
            _g1 = it1.e
            if (_g1.index == 5):
                _g2 = _g1.params[1]
                _g3 = _g1.params[2]
                if (_g1.params[0].index == 21):
                    _g1 = _g2.e
                    _g4 = _g2.p
                    _g4 = _g2.t
                    if (_g1.index == 0):
                        _g2 = _g1.params[0]
                        if (_g2.index == 2):
                            _g1 = _g3.e
                            _g4 = _g3.p
                            _g4 = _g3.t
                            if (_g1.index == 0):
                                _g3 = _g1.params[0]
                                if (_g3.index == 2):
                                    _hx_len = _g3.params[0]
                                    start = _g2.params[0]
                                    if self.unrollLoops:
                                        out = []
                                        _g1 = start
                                        _g2 = _hx_len
                                        while (_g1 < _g2):
                                            i = _g1
                                            _g1 = (_g1 + 1)
                                            self.constants.set(v1.id,hxsl_TExprDef.TConst(hxsl_Const.CInt(i)))
                                            x = self.evalExpr(loop,False)
                                            out.append(x)
                                        self.constants.remove(v1.id)
                                        e1 = hxsl_TExprDef.TBlock(out)
                                    else:
                                        e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
                                else:
                                    e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
                            else:
                                e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
                        else:
                            e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
                    else:
                        e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
                else:
                    e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
            else:
                e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
            self.varMap.remove(v1)
            d = e1
        elif (d1 == 14):
            d = hxsl_TExprDef.TContinue
        elif (d1 == 15):
            d = hxsl_TExprDef.TBreak
        elif (d1 == 16):
            e1 = _g.params[0]
            e2 = _g.params[1]
            e11 = self.evalExpr(e1)
            e21 = self.evalExpr(e2)
            _g1 = e11.e
            _g2 = e21.e
            if (_g1.index == 17):
                if (_g2.index == 0):
                    _g3 = _g2.params[0]
                    if (_g3.index == 2):
                        i = _g3.params[0]
                        el = _g1.params[0]
                        d = ((el[i] if i >= 0 and i < len(el) else None).e if (((i >= 0) and ((i < len(el))))) else hxsl_TExprDef.TArray(e11,e21))
                    else:
                        d = hxsl_TExprDef.TArray(e11,e21)
                else:
                    d = hxsl_TExprDef.TArray(e11,e21)
            else:
                d = hxsl_TExprDef.TArray(e11,e21)
        elif (d1 == 17):
            el = _g.params[0]
            _g1 = []
            _g2 = 0
            while (_g2 < len(el)):
                e1 = (el[_g2] if _g2 >= 0 and _g2 < len(el) else None)
                _g2 = (_g2 + 1)
                x = self.evalExpr(e1)
                _g1.append(x)
            d = hxsl_TExprDef.TArrayDecl(_g1)
        elif (d1 == 18):
            e1 = _g.params[0]
            cases = _g.params[1]
            _hx_def = _g.params[2]
            e2 = self.evalExpr(e1)
            _g1 = []
            _g2 = 0
            while (_g2 < len(cases)):
                c = (cases[_g2] if _g2 >= 0 and _g2 < len(cases) else None)
                _g2 = (_g2 + 1)
                _g3 = []
                _g4 = 0
                _g5 = c.values
                while (_g4 < len(_g5)):
                    v1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                    _g4 = (_g4 + 1)
                    x = self.evalExpr(v1)
                    _g3.append(x)
                x1 = _hx_AnonObject({'values': _g3, 'expr': self.evalExpr(c.expr,isVal)})
                _g1.append(x1)
            cases = _g1
            def1 = (None if ((_hx_def is None)) else self.evalExpr(_hx_def,isVal))
            hasCase = False
            _g1 = e2.e
            if (_g1.index == 0):
                c = _g1.params[0]
                if (c.index == 2):
                    val = c.params[0]
                    _g1 = 0
                    while (_g1 < len(cases)):
                        c1 = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
                        _g1 = (_g1 + 1)
                        _g2 = 0
                        _g3 = c1.values
                        while (_g2 < len(_g3)):
                            v1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                            _g2 = (_g2 + 1)
                            _g4 = v1.e
                            if (_g4.index == 0):
                                cst = _g4.params[0]
                                d1 = cst.index
                                if (d1 == 2):
                                    k = cst.params[0]
                                    if (k == val):
                                        return c1.expr
                                elif (d1 == 3):
                                    k1 = cst.params[0]
                                    if (k1 == val):
                                        return c1.expr
                                else:
                                    pass
                            else:
                                hasCase = True
                else:
                    raise haxe_Exception.thrown(("Unsupported switch constant " + Std.string(c)))
            else:
                hasCase = True
            d = (hxsl_TExprDef.TSwitch(e2,cases,def1) if hasCase else (hxsl_TExprDef.TBlock([]) if ((def1 is None)) else def1.e))
        elif (d1 == 19):
            cond = _g.params[0]
            loop = _g.params[1]
            normalWhile = _g.params[2]
            cond1 = self.evalExpr(cond)
            loop1 = self.evalExpr(loop,False)
            d = hxsl_TExprDef.TWhile(cond1,self.ifBlock(loop1),normalWhile)
        elif (d1 == 20):
            name = _g.params[0]
            args = _g.params[1]
            e1 = _g.params[2]
            e2 = None
            if (name == "unroll"):
                old4 = self.unrollLoops
                self.unrollLoops = True
                e2 = self.evalExpr(e1,isVal)
                self.unrollLoops = False
            else:
                e2 = self.evalExpr(e1,isVal)
            d = hxsl_TExprDef.TMeta(name,args,e2)
        else:
            pass
        return _hx_AnonObject({'e': d, 't': e.t, 'p': e.p})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.varMap = None
        _hx_o.inlineCalls = None
        _hx_o.unrollLoops = None
        _hx_o.eliminateConditionals = None
        _hx_o.constants = None
        _hx_o.funMap = None
        _hx_o.curFun = None
        _hx_o.markReturn = None
hxsl_Eval._hx_class = hxsl_Eval
_hx_classes["hxsl.Eval"] = hxsl_Eval


class hxsl__Flatten_Alloc:
    _hx_class_name = "hxsl._Flatten.Alloc"
    _hx_is_interface = "False"
    __slots__ = ("t", "pos", "size", "g", "v")
    _hx_fields = ["t", "pos", "size", "g", "v"]

    def __init__(self,g,t,pos,size):
        self.v = None
        self.g = g
        self.t = t
        self.pos = pos
        self.size = size

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.t = None
        _hx_o.pos = None
        _hx_o.size = None
        _hx_o.g = None
        _hx_o.v = None
hxsl__Flatten_Alloc._hx_class = hxsl__Flatten_Alloc
_hx_classes["hxsl._Flatten.Alloc"] = hxsl__Flatten_Alloc

class hxsl_ARead(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.ARead"
    _hx_constructs = ["AIndex", "AOffset"]

    @staticmethod
    def AIndex(a):
        return hxsl_ARead("AIndex", 0, (a,))

    @staticmethod
    def AOffset(a,stride,delta):
        return hxsl_ARead("AOffset", 1, (a,stride,delta))
hxsl_ARead._hx_class = hxsl_ARead
_hx_classes["hxsl.ARead"] = hxsl_ARead


class hxsl_Flatten:
    _hx_class_name = "hxsl.Flatten"
    _hx_is_interface = "False"
    __slots__ = ("globals", "params", "outVars", "varMap", "econsts", "consts", "allocData")
    _hx_fields = ["globals", "params", "outVars", "varMap", "econsts", "consts", "allocData"]
    _hx_methods = ["flatten", "mapFun", "mapExpr", "mapConsts", "allocConst", "allocConsts", "mkInt", "readIndex", "readOffset", "access", "toInt", "optimize", "packTextures", "packBuffers", "pack", "varSize", "gatherVar"]

    def __init__(self):
        self.allocData = None
        self.consts = None
        self.econsts = None
        self.varMap = None
        self.outVars = None
        self.params = None
        self.globals = None

    def flatten(self,s,kind,constsToGlobal):
        self.globals = []
        self.params = []
        self.outVars = []
        if constsToGlobal:
            self.consts = []
            p = (s.funs[0] if 0 < len(s.funs) else None).expr.p
            gc = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': "__consts__", 'kind': hxsl_VarKind.Global, 'type': None})
            self.econsts = _hx_AnonObject({'e': hxsl_TExprDef.TVar(gc), 't': None, 'p': p})
            s1 = s.name
            s2 = list(s.vars)
            _g = []
            _g1 = 0
            _g2 = s.funs
            while (_g1 < len(_g2)):
                f = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                x = self.mapFun(f,self.mapConsts)
                _g.append(x)
            s = _hx_AnonObject({'name': s1, 'vars': s2, 'funs': _g})
            _g = 0
            _g1 = s.vars
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _g2 = v.type
                if (_g2.index == 9):
                    _g3 = _g2.params[0]
                    self.allocConst(255,p)
            if (len(self.consts) > 0):
                def _hx_local_2():
                    self.econsts.t = hxsl_Type.TArray(hxsl_Type.TFloat,hxsl_SizeDecl.SConst(len(self.consts)))
                    return self.econsts.t
                gc.type = _hx_local_2()
                _this = s.vars
                _this.append(gc)
        self.varMap = haxe_ds_ObjectMap()
        self.allocData = haxe_ds_ObjectMap()
        _g = 0
        _g1 = s.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.gatherVar(v)
        prefix = None
        prefix1 = kind.index
        if (prefix1 == 0):
            prefix = "vertex"
        elif (prefix1 == 1):
            prefix = "fragment"
        else:
            raise haxe_Exception.thrown("assert")
        self.pack((("null" if prefix is None else prefix) + "Globals"),hxsl_VarKind.Global,self.globals,hxsl_VecType.VFloat)
        self.pack((("null" if prefix is None else prefix) + "Params"),hxsl_VarKind.Param,self.params,hxsl_VecType.VFloat)
        allVars = (self.globals + self.params)
        textures = ((self.packTextures((("null" if prefix is None else prefix) + "Textures"),allVars,hxsl_Type.TSampler2D) + self.packTextures((("null" if prefix is None else prefix) + "TexturesCube"),allVars,hxsl_Type.TSamplerCube)) + self.packTextures((("null" if prefix is None else prefix) + "TexturesArray"),allVars,hxsl_Type.TSampler2DArray))
        self.packBuffers(allVars)
        _g = []
        _g1 = 0
        _g2 = s.funs
        while (_g1 < len(_g2)):
            f = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = self.mapFun(f,self.mapExpr)
            _g.append(x)
        funs = _g
        return _hx_AnonObject({'name': s.name, 'vars': self.outVars, 'funs': funs})

    def mapFun(self,f,mapExpr):
        return _hx_AnonObject({'kind': f.kind, 'ret': f.ret, 'args': f.args, 'ref': f.ref, 'expr': mapExpr(f.expr)})

    def mapExpr(self,e):
        _g = e.e
        e1 = _g.index
        if (e1 == 1):
            v = _g.params[0]
            a = self.varMap.h.get(v,None)
            if (a is not None):
                e = self.access(a,v.type,e.p,hxsl_ARead.AIndex(a))
        elif (e1 == 16):
            _g1 = _g.params[0]
            _g2 = _g1.e
            _g3 = _g1.t
            if (_g2.index == 1):
                v = _g2.params[0]
                vp = _g1.p
                eindex = _g.params[1]
                _g = eindex.e
                e1 = None
                if (_g.index == 0):
                    _g1 = _g.params[0]
                    if (_g1.index == 2):
                        _g = _g1.params[0]
                        e1 = True
                    else:
                        e1 = False
                else:
                    e1 = False
                if (not e1):
                    a = self.varMap.h.get(v,None)
                    if (a is not None):
                        _g = v.type
                        if (_g.index == 15):
                            _g1 = _g.params[0]
                            _g2 = _g.params[1]
                            t = _g1
                            if hxsl_Tools.isSampler(t):
                                eindex = self.toInt(self.mapExpr(eindex))
                                e = self.access(a,t,vp,hxsl_ARead.AOffset(a,1,eindex))
                            else:
                                t = _g1
                                stride = self.varSize(t,a.t)
                                if ((stride == 0) or ((((stride & 3)) != 0))):
                                    raise haxe_Exception.thrown(hxsl_Error("Dynamic access to an Array which size is not 4 components-aligned is not allowed",e.p))
                                stride = (stride >> 2)
                                eindex = self.toInt(self.mapExpr(eindex))
                                e = self.access(a,t,vp,hxsl_ARead.AOffset(a,stride,(eindex if ((stride == 1)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpMult,eindex,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(stride)), 't': hxsl_Type.TInt, 'p': vp})), 't': hxsl_Type.TInt, 'p': vp}))))
                        else:
                            raise haxe_Exception.thrown("assert")
                else:
                    e = hxsl_Tools.map(e,self.mapExpr)
            else:
                e = hxsl_Tools.map(e,self.mapExpr)
        else:
            e = hxsl_Tools.map(e,self.mapExpr)
        return self.optimize(e)

    def mapConsts(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            c = _g.params[0]
            tmp = c.index
            if (tmp == 2):
                v = c.params[0]
                return self.allocConst(v,e.p)
            elif (tmp == 3):
                v = c.params[0]
                return self.allocConst(v,e.p)
            else:
                return e
        elif (tmp == 2):
            g = _g.params[0]
            tmp = g.index
            if (tmp == 0):
                self.allocConst((Math.PI / 180),e.p)
            elif (tmp == 1):
                self.allocConst((180 / Math.PI),e.p)
            elif (tmp == 9):
                self.allocConst(1.4426950408889634,e.p)
            elif (tmp == 10):
                self.allocConst(0.6931471805599453,e.p)
            elif (tmp == 24):
                self.allocConst(1,e.p)
            elif (tmp == 26):
                self.allocConst(2.0,e.p)
                self.allocConst(3.0,e.p)
            elif (tmp == 54):
                self.allocConsts([1, 255, 65025, 16581375],e.p)
                self.allocConsts([0.00392156862745098, 0.00392156862745098, 0.00392156862745098, 0],e.p)
            elif (tmp == 55):
                self.allocConsts([1, 0.00392156862745098, 1.53787004998077679e-05, 6.03086294110108446e-08],e.p)
            elif (tmp == 56):
                self.allocConst(1,e.p)
                self.allocConst(0.5,e.p)
            elif (tmp == 57):
                self.allocConst(0.5,e.p)
            elif (tmp == 58):
                self.allocConsts([0.5, 0.5],e.p)
                self.allocConsts([0.5, -0.5],e.p)
            elif (tmp == 59):
                self.allocConsts([2, -2],e.p)
                self.allocConsts([-1, 1],e.p)
            else:
                pass
        elif (tmp == 5):
            _g1 = _g.params[1]
            _g1 = _g.params[2]
            if (_g.params[0].index == 1):
                _g2 = _g1.e
                _g2 = _g1.p
                if (_g1.t.index == 8):
                    self.allocConst(1,e.p)
        elif (tmp == 8):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g1.e
            _g4 = _g1.p
            _g4 = _g1.t
            if (_g3.index == 2):
                if (_g3.params[0].index == 42):
                    if (len(_g2) == 2):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g3 = (_g2[1] if 1 < len(_g2) else None)
                        _g2 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g2.index == 1):
                            _g1 = _g2.params[0]
                            _g2 = _g1.id
                            _g2 = _g1.name
                            _g2 = Reflect.field(_g1,"parent")
                            _g2 = Reflect.field(_g1,"qualifiers")
                            _g2 = _g1.type
                            tmp = _g1.kind.index
                            if (tmp == 0):
                                if (_g4.index == 5):
                                    if (_g4.params[0] == 3):
                                        if (_g4.params[1].index == 1):
                                            _g1 = _g3.e
                                            _g2 = _g3.p
                                            _g2 = _g3.t
                                            if (_g1.index == 0):
                                                _g2 = _g1.params[0]
                                                if (_g2.index == 2):
                                                    if (_g2.params[0] == 1):
                                                        return e
                            elif (tmp == 1):
                                if (_g4.index == 5):
                                    if (_g4.params[0] == 3):
                                        if (_g4.params[1].index == 1):
                                            _g1 = _g3.e
                                            _g2 = _g3.p
                                            _g2 = _g3.t
                                            if (_g1.index == 0):
                                                _g2 = _g1.params[0]
                                                if (_g2.index == 2):
                                                    if (_g2.params[0] == 1):
                                                        return e
                            elif (tmp == 2):
                                if (_g4.index == 5):
                                    if (_g4.params[0] == 3):
                                        if (_g4.params[1].index == 1):
                                            _g1 = _g3.e
                                            _g2 = _g3.p
                                            _g2 = _g3.t
                                            if (_g1.index == 0):
                                                _g2 = _g1.params[0]
                                                if (_g2.index == 2):
                                                    if (_g2.params[0] == 1):
                                                        return e
                            elif (tmp == 3):
                                if (_g4.index == 5):
                                    if (_g4.params[0] == 3):
                                        if (_g4.params[1].index == 1):
                                            _g1 = _g3.e
                                            _g2 = _g3.p
                                            _g2 = _g3.t
                                            if (_g1.index == 0):
                                                _g2 = _g1.params[0]
                                                if (_g2.index == 2):
                                                    if (_g2.params[0] == 1):
                                                        return e
                            else:
                                pass
        elif (tmp == 16):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g = _g2.e
            _g3 = _g2.p
            _g3 = _g2.t
            if (_g.index == 0):
                _g3 = _g.params[0]
                if (_g3.index == 2):
                    _g = _g3.params[0]
                    eindex = _g2
                    ea = _g1
                    return _hx_AnonObject({'e': hxsl_TExprDef.TArray(self.mapConsts(ea),eindex), 't': e.t, 'p': e.p})
                else:
                    eindex = _g2
                    ea = _g1
                    _g = ea.t
                    if (_g.index == 15):
                        _g3 = _g.params[1]
                        t = _g.params[0]
                        stride = (self.varSize(t,hxsl_VecType.VFloat) >> 2)
                        self.allocConst(stride,e.p)
            else:
                eindex = _g2
                ea = _g1
                _g = ea.t
                if (_g.index == 15):
                    _g1 = _g.params[1]
                    t = _g.params[0]
                    stride = (self.varSize(t,hxsl_VecType.VFloat) >> 2)
                    self.allocConst(stride,e.p)
        else:
            pass
        return hxsl_Tools.map(e,self.mapConsts)

    def allocConst(self,v,p):
        index = python_internal_ArrayImpl.indexOf(self.consts,v,None)
        if (index < 0):
            index = len(self.consts)
            _this = self.consts
            _this.append(v)
        return _hx_AnonObject({'e': hxsl_TExprDef.TArray(self.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})

    def allocConsts(self,va,p):
        _gthis = self
        pad = ((len(va) - 1) & 3)
        index = -1
        _g = 0
        _g1 = (len(self.consts) - ((len(va) - 1)))
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((i >> 2) != (((i + pad) >> 2))):
                continue
            found = True
            _g2 = 0
            _g3 = len(va)
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                if (python_internal_ArrayImpl._get(self.consts, (i + j)) != (va[j] if j >= 0 and j < len(va) else None)):
                    found = False
                    break
            if found:
                index = i
                break
        if (index < 0):
            while ((len(self.consts) >> 2) != (((len(self.consts) + pad) >> 2))):
                _this = self.consts
                _this.append(0)
            index = len(self.consts)
            _g = 0
            while (_g < len(va)):
                v = (va[_g] if _g >= 0 and _g < len(va) else None)
                _g = (_g + 1)
                _this = self.consts
                _this.append(v)
        _g = len(va)
        if (_g == 1):
            return _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})
        elif (_g == 2):
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec2), 't': hxsl_Type.TVoid, 'p': p}),[_hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 1))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})]), 't': hxsl_Type.TVec(2,hxsl_VecType.VFloat), 'p': p})
        elif (_g == 3):
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec3), 't': hxsl_Type.TVoid, 'p': p}),[_hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 1))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 2))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})]), 't': hxsl_Type.TVec(3,hxsl_VecType.VFloat), 'p': p})
        elif (_g == 4):
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec4), 't': hxsl_Type.TVoid, 'p': p}),[_hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 1))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 3))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 4))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})]), 't': hxsl_Type.TVec(4,hxsl_VecType.VFloat), 'p': p})
        else:
            raise haxe_Exception.thrown("assert")

    def mkInt(self,v,pos):
        return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(v)), 't': hxsl_Type.TInt, 'p': pos})

    def readIndex(self,a,index,pos):
        offs = (a.pos if ((a.t is None)) else (a.pos >> 2))
        return _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a.g), 't': a.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((offs + index))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a.t), 'p': pos})

    def readOffset(self,a,stride,delta,index,pos):
        index1 = (((a.pos if ((a.t is None)) else (a.pos >> 2))) + index)
        offset = (delta if ((index1 == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index1)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
        return _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a.g), 't': a.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a.t), 'p': pos})

    def access(self,a,t,pos,acc):
        _gthis = self
        tmp = t.index
        if (tmp == 6):
            tmp = self.access(a,hxsl_Type.TMat3x4,pos,acc)
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3), 't': hxsl_Type.TFun([]), 'p': pos}),[tmp]), 't': hxsl_Type.TMat3, 'p': pos})
        elif (tmp == 7):
            tmp = hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4)
            tmp1 = hxsl_Type.TFun([])
            tmp2 = None
            tmp3 = acc.index
            if (tmp3 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp2 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp3 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp2 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            tmp3 = None
            tmp4 = acc.index
            if (tmp4 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp3 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((offs + 1))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp4 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (((a1.pos if ((a1.t is None)) else (a1.pos >> 2))) + 1)
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp3 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            tmp4 = None
            tmp5 = acc.index
            if (tmp5 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp4 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((offs + 2))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp5 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (((a1.pos if ((a1.t is None)) else (a1.pos >> 2))) + 2)
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp4 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            tmp5 = None
            tmp6 = acc.index
            if (tmp6 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp5 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((offs + 3))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp6 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (((a1.pos if ((a1.t is None)) else (a1.pos >> 2))) + 3)
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp5 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': tmp, 't': tmp1, 'p': pos}),[tmp2, tmp3, tmp4, tmp5]), 't': hxsl_Type.TMat4, 'p': pos})
        elif (tmp == 8):
            tmp = hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3x4)
            tmp1 = hxsl_Type.TFun([])
            tmp2 = None
            tmp3 = acc.index
            if (tmp3 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp2 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp3 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp2 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            tmp3 = None
            tmp4 = acc.index
            if (tmp4 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp3 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((offs + 1))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp4 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (((a1.pos if ((a1.t is None)) else (a1.pos >> 2))) + 1)
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp3 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            tmp4 = None
            tmp5 = acc.index
            if (tmp5 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp4 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((offs + 2))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp5 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (((a1.pos if ((a1.t is None)) else (a1.pos >> 2))) + 2)
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp4 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': tmp, 't': tmp1, 'p': pos}),[tmp2, tmp3, tmp4]), 't': hxsl_Type.TMat3x4, 'p': pos})
        elif (tmp == 15):
            _g = t.params[1]
            if (_g.index == 0):
                _hx_len = _g.params[0]
                t1 = t.params[0]
                x = (a.size / _hx_len)
                stride = None
                try:
                    stride = int(x)
                except BaseException as _g:
                    None
                    stride = None
                _g = []
                _g1 = 0
                _g2 = _hx_len
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    a1 = hxsl__Flatten_Alloc(a.g,a.t,(a.pos + ((stride * i))),stride)
                    x = self.access(a1,t1,pos,hxsl_ARead.AIndex(a1))
                    _g.append(x)
                earr = _g
                return _hx_AnonObject({'e': hxsl_TExprDef.TArrayDecl(earr), 't': t1, 'p': pos})
            else:
                if hxsl_Tools.isSampler(t):
                    e = None
                    e1 = acc.index
                    if (e1 == 0):
                        a1 = acc.params[0]
                        offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                        e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
                    elif (e1 == 1):
                        a1 = acc.params[0]
                        stride = acc.params[1]
                        delta = acc.params[2]
                        index = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                        offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                        e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
                    else:
                        pass
                    e.t = t
                    return e
                size = self.varSize(t,a.t)
                if (size > 4):
                    return hxsl_Error.t(("Access not supported for " + HxOverrides.stringOrNull(hxsl_Tools.toString(t))),None)
                e = None
                e1 = acc.index
                if (e1 == 0):
                    a1 = acc.params[0]
                    offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
                elif (e1 == 1):
                    a1 = acc.params[0]
                    stride = acc.params[1]
                    delta = acc.params[2]
                    index = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                    offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
                else:
                    pass
                if (size == 4):
                    if (((a.pos & 3)) != 0):
                        raise haxe_Exception.thrown("assert")
                else:
                    sw = []
                    _g = 0
                    _g1 = size
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        x = python_internal_ArrayImpl._get(hxsl_Tools.SWIZ, (i + ((a.pos & 3))))
                        sw.append(x)
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TSwiz(e,sw), 't': t, 'p': pos})
                tmp = t.index
                if (tmp == 1):
                    e.t = hxsl_Type.TFloat
                    e = self.toInt(e)
                elif (tmp == 5):
                    if (t.params[1].index == 0):
                        size = t.params[0]
                        e.t = hxsl_Type.TVec(size,hxsl_VecType.VFloat)
                        e = _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(python_internal_ArrayImpl._get([hxsl_TGlobal.IVec2, hxsl_TGlobal.IVec3, hxsl_TGlobal.IVec4], (size - 2))), 't': hxsl_Type.TFun([]), 'p': pos}),[e]), 't': t, 'p': pos})
                else:
                    pass
                return e
        else:
            if hxsl_Tools.isSampler(t):
                e = None
                e1 = acc.index
                if (e1 == 0):
                    a1 = acc.params[0]
                    offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
                elif (e1 == 1):
                    a1 = acc.params[0]
                    stride = acc.params[1]
                    delta = acc.params[2]
                    index = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                    offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
                else:
                    pass
                e.t = t
                return e
            size = self.varSize(t,a.t)
            if (size > 4):
                return hxsl_Error.t(("Access not supported for " + HxOverrides.stringOrNull(hxsl_Tools.toString(t))),None)
            e = None
            e1 = acc.index
            if (e1 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (e1 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            if (size == 4):
                if (((a.pos & 3)) != 0):
                    raise haxe_Exception.thrown("assert")
            else:
                sw = []
                _g = 0
                _g1 = size
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    x = python_internal_ArrayImpl._get(hxsl_Tools.SWIZ, (i + ((a.pos & 3))))
                    sw.append(x)
                e = _hx_AnonObject({'e': hxsl_TExprDef.TSwiz(e,sw), 't': t, 'p': pos})
            tmp = t.index
            if (tmp == 1):
                e.t = hxsl_Type.TFloat
                e = self.toInt(e)
            elif (tmp == 5):
                if (t.params[1].index == 0):
                    size = t.params[0]
                    e.t = hxsl_Type.TVec(size,hxsl_VecType.VFloat)
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(python_internal_ArrayImpl._get([hxsl_TGlobal.IVec2, hxsl_TGlobal.IVec3, hxsl_TGlobal.IVec4], (size - 2))), 't': hxsl_Type.TFun([]), 'p': pos}),[e]), 't': t, 'p': pos})
            else:
                pass
            return e

    def toInt(self,e):
        if (e.t == hxsl_Type.TInt):
            return e
        return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToInt), 't': hxsl_Type.TFun([]), 'p': e.p}),[e]), 't': hxsl_Type.TInt, 'p': e.p})

    def optimize(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 8):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g1.e
            _g4 = _g1.p
            _g4 = _g1.t
            if (_g3.index == 2):
                if (_g3.params[0].index == 52):
                    if (len(_g2) == 1):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g2 = _g1.e
                        _g3 = _g1.p
                        _g3 = _g1.t
                        if (_g2.index == 8):
                            _g1 = _g2.params[0]
                            _g3 = _g1.e
                            _g4 = _g1.p
                            _g4 = _g1.t
                            if (_g3.index == 2):
                                if (_g3.params[0].index == 51):
                                    args = _g2.params[1]
                                    rem = 0
                                    size = 0
                                    while (size < 4):
                                        t = python_internal_ArrayImpl._get(args, ((len(args) - 1) - rem)).t
                                        size = (size + self.varSize(t,hxsl_VecType.VFloat))
                                        rem = (rem + 1)
                                    if (size == 4):
                                        _g1 = 0
                                        _g2 = rem
                                        while (_g1 < _g2):
                                            i = _g1
                                            _g1 = (_g1 + 1)
                                            if (len(args) != 0):
                                                args.pop()
                                        emat = None
                                        _g1 = e.e
                                        if (_g1.index == 8):
                                            _g2 = _g1.params[1]
                                            e1 = _g1.params[0]
                                            emat = e1
                                        else:
                                            raise haxe_Exception.thrown("assert")
                                        return _hx_AnonObject({'e': hxsl_TExprDef.TCall(emat,args), 't': e.t, 'p': e.p})
        elif (tmp == 16):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g = _g1.e
            _g3 = _g1.p
            _g3 = _g1.t
            if (_g.index == 17):
                _g1 = _g2.e
                _g3 = _g2.p
                _g3 = _g2.t
                if (_g1.index == 0):
                    _g2 = _g1.params[0]
                    if (_g2.index == 2):
                        i = _g2.params[0]
                        el = _g.params[0]
                        if ((i >= 0) and ((i < len(el)))):
                            return (el[i] if i >= 0 and i < len(el) else None)
                        hxsl_Error.t("Reading outside array bounds",e.p)
        else:
            pass
        return e

    def packTextures(self,name,vars,t):
        alloc = list()
        g = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': name, 'type': t, 'kind': hxsl_VarKind.Param})
        pos = 0
        samplers = []
        _g = 0
        while (_g < len(vars)):
            v = (vars[_g] if _g >= 0 and _g < len(vars) else None)
            _g = (_g + 1)
            count = 1
            if (v.type != t):
                _g1 = v.type
                tmp = _g1.index
                if (tmp == 15):
                    _g2 = _g1.params[1]
                    if (_g2.index == 0):
                        n = _g2.params[0]
                        t2 = _g1.params[0]
                        if (t2 == t):
                            count = n
                        else:
                            continue
                    else:
                        continue
                elif (tmp == 17):
                    _g3 = _g1.params[0]
                    if (t != hxsl_Type.TSampler2D):
                        continue
                else:
                    continue
            a = hxsl__Flatten_Alloc(g,None,pos,count)
            a.v = v
            if (Reflect.field(v,"qualifiers") is not None):
                _g4 = 0
                _g5 = Reflect.field(v,"qualifiers")
                while (_g4 < len(_g5)):
                    q = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                    _g4 = (_g4 + 1)
                    if (q.index == 12):
                        name = q.params[0]
                        _g6 = 0
                        _g7 = count
                        while (_g6 < _g7):
                            i = _g6
                            _g6 = (_g6 + 1)
                            python_internal_ArrayImpl._set(samplers, (pos + i), name)
            self.varMap.set(v,a)
            alloc.append(a)
            pos = (pos + count)
        g.type = hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(pos))
        if (len(samplers) > 0):
            _g = 0
            _g1 = pos
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if ((samplers[i] if i >= 0 and i < len(samplers) else None) is None):
                    python_internal_ArrayImpl._set(samplers, i, "")
            if (Reflect.field(g,"qualifiers") is None):
                Reflect.setField(g,"qualifiers",[])
            _this = Reflect.field(g,"qualifiers")
            x = hxsl_VarQualifier.Sampler(",".join([python_Boot.toString1(x1,'') for x1 in samplers]))
            _this.append(x)
        if (len(alloc) > 0):
            _this = self.outVars
            _this.append(g)
            self.allocData.set(g,alloc)
        return alloc

    def packBuffers(self,vars):
        alloc = list()
        g = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': "buffers", 'type': hxsl_Type.TVoid, 'kind': hxsl_VarKind.Param})
        _g = 0
        while (_g < len(vars)):
            v = (vars[_g] if _g >= 0 and _g < len(vars) else None)
            _g = (_g + 1)
            _g1 = v.type
            tmp = None
            if (_g1.index == 16):
                _g2 = _g1.params[0]
                _g3 = _g1.params[1]
                tmp = True
            else:
                tmp = False
            if tmp:
                a = hxsl__Flatten_Alloc(g,None,len(alloc),1)
                a.v = v
                alloc.append(a)
                _this = self.outVars
                _this.append(v)
        g.type = hxsl_Type.TArray(hxsl_Type.TBuffer(hxsl_Type.TVoid,hxsl_SizeDecl.SConst(0)),hxsl_SizeDecl.SConst(len(alloc)))
        self.allocData.set(g,alloc)

    def pack(self,name,kind,vars,t):
        alloc = list()
        apos = 0
        g = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': name, 'type': hxsl_Type.TVec(0,t), 'kind': kind})
        _g = 0
        while (_g < len(vars)):
            v = (vars[_g] if _g >= 0 and _g < len(vars) else None)
            _g = (_g + 1)
            tmp = None
            if (not hxsl_Tools.isSampler(v.type)):
                _g1 = v.type
                if (_g1.index == 16):
                    _g2 = _g1.params[0]
                    _g3 = _g1.params[1]
                    tmp = True
                else:
                    tmp = False
            else:
                tmp = True
            if tmp:
                continue
            _g4 = v.type
            if (_g4.index == 15):
                _g5 = _g4.params[1]
                t1 = _g4.params[0]
                if hxsl_Tools.isSampler(t1):
                    continue
            size = self.varSize(v.type,t)
            best = None
            _g6 = 0
            while (_g6 < len(alloc)):
                a = (alloc[_g6] if _g6 >= 0 and _g6 < len(alloc) else None)
                _g6 = (_g6 + 1)
                if (((a.v is None) and ((a.size >= size))) and (((best is None) or ((best.size > a.size))))):
                    best = a
            if (best is not None):
                free = (best.size - size)
                if (free > 0):
                    i = python_internal_ArrayImpl.indexOf(alloc,best,None)
                    a1 = hxsl__Flatten_Alloc(g,t,(best.pos + size),free)
                    alloc.insert((i + 1), a1)
                    best.size = size
                best.v = v
                self.varMap.set(v,best)
            else:
                a2 = hxsl__Flatten_Alloc(g,t,apos,size)
                apos = (apos + size)
                a2.v = v
                self.varMap.set(v,a2)
                alloc.append(a2)
                pad = HxOverrides.mod(((4 - (HxOverrides.mod(size, 4)))), 4)
                if (pad > 0):
                    a3 = hxsl__Flatten_Alloc(g,t,apos,pad)
                    apos = (apos + pad)
                    alloc.append(a3)
        g.type = hxsl_Type.TArray(hxsl_Type.TVec(4,t),hxsl_SizeDecl.SConst((apos >> 2)))
        if (apos > 0):
            _this = self.outVars
            _this.append(g)
            self.allocData.set(g,alloc)
        return g

    def varSize(self,v,t):
        tmp = v.index
        if ((tmp == 3) or ((tmp == 1))):
            if (t == hxsl_VecType.VFloat):
                return 1
            else:
                raise haxe_Exception.thrown(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        elif (tmp == 5):
            n = v.params[0]
            t2 = v.params[1]
            if (t == t2):
                return n
            else:
                raise haxe_Exception.thrown(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        elif (tmp == 7):
            if (t == hxsl_VecType.VFloat):
                return 16
            else:
                raise haxe_Exception.thrown(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        elif ((tmp == 8) or ((tmp == 6))):
            if (t == hxsl_VecType.VFloat):
                return 12
            else:
                raise haxe_Exception.thrown(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        elif (tmp == 15):
            _g = v.params[1]
            if (_g.index == 0):
                n = _g.params[0]
                at = v.params[0]
                return (self.varSize(at,t) * n)
            else:
                raise haxe_Exception.thrown(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        else:
            raise haxe_Exception.thrown(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))

    def gatherVar(self,v):
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g = 0
            while (_g < len(vl)):
                v1 = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                self.gatherVar(v1)
        else:
            tmp = v.kind.index
            if (tmp == 0):
                if hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.PerObject):
                    _this = self.params
                    _this.append(v)
                else:
                    _this = self.globals
                    _this.append(v)
            elif (tmp == 2):
                _this = self.params
                _this.append(v)
            else:
                _this = self.outVars
                _this.append(v)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.globals = None
        _hx_o.params = None
        _hx_o.outVars = None
        _hx_o.varMap = None
        _hx_o.econsts = None
        _hx_o.consts = None
        _hx_o.allocData = None
hxsl_Flatten._hx_class = hxsl_Flatten
_hx_classes["hxsl.Flatten"] = hxsl_Flatten


class hxsl__Globals_GlobalSlot_Impl_:
    _hx_class_name = "hxsl._Globals.GlobalSlot_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toInt", "set", "get"]

    @staticmethod
    def _new(name):
        this1 = hxsl_Globals.allocID(name)
        return this1

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def set(this1,globals,v):
        globals.map.set(this1,v)

    @staticmethod
    def get(this1,globals):
        return globals.map.h.get(this1,None)
hxsl__Globals_GlobalSlot_Impl_._hx_class = hxsl__Globals_GlobalSlot_Impl_
_hx_classes["hxsl._Globals.GlobalSlot_Impl_"] = hxsl__Globals_GlobalSlot_Impl_


class hxsl_Globals:
    _hx_class_name = "hxsl.Globals"
    _hx_is_interface = "False"
    __slots__ = ("map", "channels", "maxChannels")
    _hx_fields = ["map", "channels", "maxChannels"]
    _hx_methods = ["set", "get", "fastSet", "fastGet", "resetChannels", "allocChannelID"]
    _hx_statics = ["ALL", "MAP", "allocID", "getIDName"]

    def __init__(self):
        self.maxChannels = None
        self.channels = []
        self.map = haxe_ds_IntMap()

    def set(self,path,v):
        self.map.set(hxsl_Globals.allocID(path),v)

    def get(self,path):
        this1 = self.map
        key = hxsl_Globals.allocID(path)
        return this1.h.get(key,None)

    def fastSet(self,id,v):
        self.map.set(id,v)

    def fastGet(self,id):
        return self.map.h.get(id,None)

    def resetChannels(self):
        self.maxChannels = 0

    def allocChannelID(self,t):
        _g = 0
        _g1 = self.maxChannels
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.channels[i] if i >= 0 and i < len(self.channels) else None) == t):
                return i
        if (self.maxChannels == ((1 << hxsl_Tools.MAX_CHANNELS_BITS))):
            raise haxe_Exception.thrown("Too many unique channels")
        i = self.maxChannels
        self.maxChannels = (self.maxChannels + 1)
        python_internal_ArrayImpl._set(self.channels, i, t)
        return i
    ALL = None
    MAP = None

    @staticmethod
    def allocID(path):
        if (hxsl_Globals.MAP is None):
            hxsl_Globals.MAP = haxe_ds_StringMap()
            hxsl_Globals.ALL = []
        id = hxsl_Globals.MAP.h.get(path,None)
        if (id is None):
            id = len(hxsl_Globals.ALL)
            _this = hxsl_Globals.ALL
            _this.append(path)
            hxsl_Globals.MAP.h[path] = id
        return id

    @staticmethod
    def getIDName(id):
        return python_internal_ArrayImpl._get(hxsl_Globals.ALL, id)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.map = None
        _hx_o.channels = None
        _hx_o.maxChannels = None
hxsl_Globals._hx_class = hxsl_Globals
_hx_classes["hxsl.Globals"] = hxsl_Globals


class hxsl__Linker_AllocatedVar:
    _hx_class_name = "hxsl._Linker.AllocatedVar"
    _hx_is_interface = "False"
    __slots__ = ("id", "v", "path", "merged", "kind", "parent", "rootShaderName", "instanceIndex")
    _hx_fields = ["id", "v", "path", "merged", "kind", "parent", "rootShaderName", "instanceIndex"]

    def __init__(self):
        self.instanceIndex = None
        self.rootShaderName = None
        self.parent = None
        self.kind = None
        self.merged = None
        self.path = None
        self.v = None
        self.id = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.v = None
        _hx_o.path = None
        _hx_o.merged = None
        _hx_o.kind = None
        _hx_o.parent = None
        _hx_o.rootShaderName = None
        _hx_o.instanceIndex = None
hxsl__Linker_AllocatedVar._hx_class = hxsl__Linker_AllocatedVar
_hx_classes["hxsl._Linker.AllocatedVar"] = hxsl__Linker_AllocatedVar


class hxsl__Linker_ShaderInfos:
    _hx_class_name = "hxsl._Linker.ShaderInfos"
    _hx_is_interface = "False"
    __slots__ = ("uid", "name", "priority", "body", "usedFunctions", "deps", "read", "write", "processed", "vertex", "onStack", "hasDiscard", "marked")
    _hx_fields = ["uid", "name", "priority", "body", "usedFunctions", "deps", "read", "write", "processed", "vertex", "onStack", "hasDiscard", "marked"]
    _hx_statics = ["UID"]

    def __init__(self,n,v):
        self.marked = None
        self.hasDiscard = None
        self.onStack = None
        self.deps = None
        self.body = None
        self.priority = None
        self.name = n
        def _hx_local_2():
            _hx_local_0 = hxsl__Linker_ShaderInfos
            _hx_local_1 = _hx_local_0.UID
            _hx_local_0.UID = (_hx_local_1 + 1)
            return _hx_local_1
        self.uid = _hx_local_2()
        self.vertex = v
        self.processed = haxe_ds_IntMap()
        self.usedFunctions = []
        self.read = haxe_ds_IntMap()
        self.write = haxe_ds_IntMap()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.uid = None
        _hx_o.name = None
        _hx_o.priority = None
        _hx_o.body = None
        _hx_o.usedFunctions = None
        _hx_o.deps = None
        _hx_o.read = None
        _hx_o.write = None
        _hx_o.processed = None
        _hx_o.vertex = None
        _hx_o.onStack = None
        _hx_o.hasDiscard = None
        _hx_o.marked = None
hxsl__Linker_ShaderInfos._hx_class = hxsl__Linker_ShaderInfos
_hx_classes["hxsl._Linker.ShaderInfos"] = hxsl__Linker_ShaderInfos


class hxsl_Linker:
    _hx_class_name = "hxsl.Linker"
    _hx_is_interface = "False"
    __slots__ = ("allVars", "varMap", "curShader", "shaders", "varIdMap", "locals", "curInstance", "batchMode", "isBatchShader", "debugDepth")
    _hx_fields = ["allVars", "varMap", "curShader", "shaders", "varIdMap", "locals", "curInstance", "batchMode", "isBatchShader", "debugDepth"]
    _hx_methods = ["debug", "error", "mergeVar", "allocVar", "mapExprVar", "addShader", "sortByPriorityDesc", "buildDependency", "initDependencies", "collect", "uniqueLocals", "link"]

    def __init__(self,batchMode = None):
        if (batchMode is None):
            batchMode = False
        self.isBatchShader = None
        self.curInstance = None
        self.locals = None
        self.varIdMap = None
        self.shaders = None
        self.curShader = None
        self.varMap = None
        self.allVars = None
        self.debugDepth = 0
        self.batchMode = batchMode

    def debug(self,msg,pos = None):
        pass

    def error(self,msg,p):
        return hxsl_Error.t(msg,p)

    def mergeVar(self,path,v,v2,p,shaderName):
        tmp = v.kind.index
        if (tmp == 2):
            if (not (((shaderName is not None) and hxsl_Tools.hasBorrowQualifier(v2,shaderName)))):
                raise haxe_Exception.thrown("assert")
        elif (((((tmp == 5) or ((tmp == 4))) or ((tmp == 3))) or ((tmp == 1))) or ((tmp == 0))):
            pass
        elif (tmp == 6):
            raise haxe_Exception.thrown("assert")
        else:
            pass
        if (((v.kind != v2.kind) and ((v.kind != hxsl_VarKind.Local))) and ((v2.kind != hxsl_VarKind.Local))):
            self.error(((((("'" + ("null" if path is None else path)) + "' kind does not match : ") + Std.string(v.kind)) + " should be ") + Std.string(v2.kind)),p)
        _g = v.type
        _g1 = v2.type
        if (_g.index == 13):
            if (_g1.index == 13):
                fl2 = _g1.params[0]
                fl1 = _g.params[0]
                _g = 0
                while (_g < len(fl1)):
                    f1 = (fl1[_g] if _g >= 0 and _g < len(fl1) else None)
                    _g = (_g + 1)
                    ft = None
                    _g1 = 0
                    while (_g1 < len(fl2)):
                        f2 = (fl2[_g1] if _g1 >= 0 and _g1 < len(fl2) else None)
                        _g1 = (_g1 + 1)
                        if (f1.name == f2.name):
                            ft = f2
                            break
                    if (ft is None):
                        x = self.allocVar(f1,p,shaderName).v
                        fl2.append(x)
                    else:
                        self.mergeVar(((("null" if path is None else path) + ".") + HxOverrides.stringOrNull(ft.name)),f1,ft,p,shaderName)
            elif (not Type.enumEq(v.type,v2.type)):
                self.error(((((("'" + ("null" if path is None else path)) + "' type does not match : ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v.type))) + " should be ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v2.type))),p)
        elif (not Type.enumEq(v.type,v2.type)):
            self.error(((((("'" + ("null" if path is None else path)) + "' type does not match : ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v.type))) + " should be ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v2.type))),p)

    def allocVar(self,v,p,shaderName = None,path = None,parent = None):
        _gthis = self
        if ((Reflect.field(v,"parent") is not None) and ((parent is None))):
            parent = self.allocVar(Reflect.field(v,"parent"),p,shaderName)
            p1 = parent.v
            path = p1.name
            p1 = Reflect.field(p1,"parent")
            while (p1 is not None):
                path = ((HxOverrides.stringOrNull(p1.name) + ".") + ("null" if path is None else path))
                p1 = Reflect.field(p1,"parent")
        key = (v.name if ((path is None)) else ((("null" if path is None else path) + ".") + HxOverrides.stringOrNull(v.name)))
        if (Reflect.field(v,"qualifiers") is not None):
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (q.index == 4):
                    n = q.params[0]
                    key = n
        v2 = self.varMap.h.get(key,None)
        vname = v.name
        if (v2 is not None):
            _g = 0
            _g1 = v2.merged
            while (_g < len(_g1)):
                vm = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (vm == v):
                    return v2
            tmp = None
            borrowed = hxsl_Tools.hasBorrowQualifier(v2.v,shaderName)
            if (not (((((((v.kind == hxsl_VarKind.Param) and (not borrowed)) and (not hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Shared))) and (not _gthis.isBatchShader)) or ((v.kind == hxsl_VarKind.Function))) or (((((v.kind == hxsl_VarKind.Var) or ((v.kind == hxsl_VarKind.Local)))) and hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Private)))))):
                v1 = v2.v
                borrowed = hxsl_Tools.hasBorrowQualifier(v,v2.rootShaderName)
                tmp = ((((((v1.kind == hxsl_VarKind.Param) and (not borrowed)) and (not hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Shared))) and (not _gthis.isBatchShader)) or ((v1.kind == hxsl_VarKind.Function))) or (((((v1.kind == hxsl_VarKind.Var) or ((v1.kind == hxsl_VarKind.Local)))) and hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Private))))
            else:
                tmp = True
            if (tmp or (((v.kind == hxsl_VarKind.Param) and ((v2.v.kind == hxsl_VarKind.Param))))):
                k = 2
                while True:
                    a = self.varMap.h.get((("null" if key is None else key) + Std.string(k)),None)
                    if (a is None):
                        break
                    _g = 0
                    _g1 = a.merged
                    while (_g < len(_g1)):
                        vm = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                        _g = (_g + 1)
                        if (vm == v):
                            return a
                    k = (k + 1)
                vname = (("null" if vname is None else vname) + Std.string(k))
                key = (("null" if key is None else key) + Std.string(k))
            else:
                _this = v2.merged
                _this.append(v)
                self.mergeVar(key,v,v2.v,p,v2.rootShaderName)
                self.varIdMap.set(v.id,v2.id)
                return v2
        vid = (len(self.allVars) + 1)
        v2 = _hx_AnonObject({'id': vid, 'name': vname, 'type': v.type, 'kind': v.kind, 'qualifiers': Reflect.field(v,"qualifiers"), 'parent': (None if ((parent is None)) else parent.v)})
        a = hxsl__Linker_AllocatedVar()
        a.v = v2
        a.merged = [v]
        a.path = key
        a.id = vid
        a.parent = parent
        a.instanceIndex = self.curInstance
        a.rootShaderName = shaderName
        _this = self.allVars
        _this.append(a)
        self.varMap.h[key] = a
        _g = v2.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g = []
            _g1 = 0
            while (_g1 < len(vl)):
                v = (vl[_g1] if _g1 >= 0 and _g1 < len(vl) else None)
                _g1 = (_g1 + 1)
                x = self.allocVar(v,p,shaderName,key,a).v
                _g.append(x)
            v2.type = hxsl_Type.TStruct(_g)
        return a

    def mapExprVar(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 1):
            v = _g.params[0]
            if (not (v.id in self.locals.h)):
                v1 = self.allocVar(v,e.p)
                if ((self.curShader is not None) and (not (v1.id in self.curShader.write.h))):
                    self.curShader.read.set(v1.id,v1)
                    if ((self.curShader.vertex is None) and ((v1.v.kind == hxsl_VarKind.Var))):
                        self.curShader.vertex = False
                return _hx_AnonObject({'e': hxsl_TExprDef.TVar(v1.v), 't': v1.v.type, 'p': e.p})
        elif (tmp == 5):
            op = _g.params[0]
            e1 = _g.params[1]
            e2 = _g.params[2]
            _g1 = e1.e
            tmp = op.index
            if (tmp == 4):
                tmp = _g1.index
                if (tmp == 1):
                    _g2 = _g1.params[0]
                    v = _g2
                    if (not (v.id in self.locals.h)):
                        e21 = self.mapExprVar(e2)
                        v1 = self.allocVar(v,e1.p)
                        if (self.curShader is not None):
                            self.curShader.write.set(v1.id,v1)
                        return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,_hx_AnonObject({'e': hxsl_TExprDef.TVar(v1.v), 't': v1.v.type, 'p': e.p}),e21), 't': e.t, 'p': e.p})
                    else:
                        v = _g2
                        if (not (v.id in self.locals.h)):
                            e11 = self.mapExprVar(e1)
                            e21 = self.mapExprVar(e2)
                            v1 = self.allocVar(v,e11.p)
                            if (self.curShader is not None):
                                self.curShader.write.set(v1.id,v1)
                            return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,e11,e21), 't': e.t, 'p': e.p})
                elif (tmp == 9):
                    _g2 = _g1.params[0]
                    _g3 = _g1.params[1]
                    _g3 = _g2.e
                    _g4 = _g2.p
                    _g4 = _g2.t
                    if (_g3.index == 1):
                        v = _g3.params[0]
                        if (not (v.id in self.locals.h)):
                            e11 = self.mapExprVar(e1)
                            e21 = self.mapExprVar(e2)
                            v1 = self.allocVar(v,e11.p)
                            if (self.curShader is not None):
                                self.curShader.write.set(v1.id,v1)
                            return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,e11,e21), 't': e.t, 'p': e.p})
                else:
                    pass
            elif (tmp == 20):
                _g2 = op.params[0]
                tmp = _g1.index
                if (tmp == 1):
                    v = _g1.params[0]
                    if (not (v.id in self.locals.h)):
                        e11 = self.mapExprVar(e1)
                        e21 = self.mapExprVar(e2)
                        v1 = self.allocVar(v,e11.p)
                        if (self.curShader is not None):
                            self.curShader.write.set(v1.id,v1)
                        return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,e11,e21), 't': e.t, 'p': e.p})
                elif (tmp == 9):
                    _g2 = _g1.params[0]
                    _g3 = _g1.params[1]
                    _g1 = _g2.e
                    _g3 = _g2.p
                    _g3 = _g2.t
                    if (_g1.index == 1):
                        v = _g1.params[0]
                        if (not (v.id in self.locals.h)):
                            e11 = self.mapExprVar(e1)
                            e21 = self.mapExprVar(e2)
                            v1 = self.allocVar(v,e11.p)
                            if (self.curShader is not None):
                                self.curShader.write.set(v1.id,v1)
                            return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,e11,e21), 't': e.t, 'p': e.p})
                else:
                    pass
            else:
                pass
        elif (tmp == 7):
            _g1 = _g.params[1]
            v = _g.params[0]
            self.locals.set(v.id,True)
        elif (tmp == 11):
            if (self.curShader is not None):
                self.curShader.vertex = False
                self.curShader.hasDiscard = True
        elif (tmp == 13):
            _g1 = _g.params[1]
            _g1 = _g.params[2]
            v = _g.params[0]
            self.locals.set(v.id,True)
        else:
            pass
        return hxsl_Tools.map(e,self.mapExprVar)

    def addShader(self,name,vertex,e,p):
        s = hxsl__Linker_ShaderInfos(name,vertex)
        self.curShader = s
        s.priority = p
        s.body = self.mapExprVar(e)
        _this = self.shaders
        _this.append(s)
        self.curShader = None
        return s

    def sortByPriorityDesc(self,s1,s2):
        if (s1.priority == s2.priority):
            return (s1.uid - s2.uid)
        return (s2.priority - s1.priority)

    def buildDependency(self,s,v,isWritten):
        found = (not isWritten)
        _g = 0
        _g1 = self.shaders
        while (_g < len(_g1)):
            parent = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (parent == s):
                found = True
                continue
            elif (not found):
                continue
            if (not (v.id in parent.write.h)):
                continue
            if s.vertex:
                if (parent.vertex == False):
                    continue
                if (parent.vertex is None):
                    parent.vertex = True
            s.deps.set(parent,True)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.debugDepth
            _hx_local_1.debugDepth = (_hx_local_2 + 1)
            _hx_local_2
            self.initDependencies(parent)
            _hx_local_3 = self
            _hx_local_4 = _hx_local_3.debugDepth
            _hx_local_3.debugDepth = (_hx_local_4 - 1)
            _hx_local_4
            if (not (v.id in parent.read.h)):
                return
        if (v.v.kind == hxsl_VarKind.Var):
            self.error((((("Variable " + HxOverrides.stringOrNull(v.path)) + " required by ") + HxOverrides.stringOrNull(s.name)) + " is missing initializer"),None)

    def initDependencies(self,s):
        if (s.deps is not None):
            return
        s.deps = haxe_ds_ObjectMap()
        r = s.read.iterator()
        while r.hasNext():
            r1 = r.next()
            self.buildDependency(s,r1,(r1.id in s.write.h))
        if (s.vertex is None):
            d = s.deps.keys()
            while d.hasNext():
                d1 = d.next()
                if (d1.vertex == False):
                    s.vertex = False
                    break
        if s.vertex:
            d = s.deps.keys()
            while d.hasNext():
                d1 = d.next()
                if (d1.vertex is None):
                    d1.vertex = True

    def collect(self,cur,out,vertex):
        if cur.onStack:
            self.error((("Loop in shader dependencies (" + HxOverrides.stringOrNull(cur.name)) + ")"),None)
        if (cur.marked == vertex):
            return
        cur.marked = vertex
        cur.onStack = True
        _g = []
        d = cur.deps.keys()
        while d.hasNext():
            d1 = d.next()
            _g.append(d1)
        deps = _g
        deps.sort(key= python_lib_Functools.cmp_to_key(self.sortByPriorityDesc))
        _g = 0
        while (_g < len(deps)):
            d = (deps[_g] if _g >= 0 and _g < len(deps) else None)
            _g = (_g + 1)
            self.collect(d,out,vertex)
        if (cur.vertex is None):
            cur.vertex = vertex
        if (cur.vertex == vertex):
            out.append(cur)
        cur.onStack = False

    def uniqueLocals(self,expr,locals):
        _g = expr.e
        tmp = _g.index
        if (tmp == 4):
            el = _g.params[0]
            _g1 = haxe_ds_StringMap()
            k = locals.keys()
            while k.hasNext():
                k1 = k.next()
                _g1.h[k1] = True
            locals1 = _g1
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                self.uniqueLocals(e,locals1)
        elif (tmp == 7):
            _g1 = _g.params[1]
            v = _g.params[0]
            if (v.name in locals.h):
                k = 2
                while ((HxOverrides.stringOrNull(v.name) + Std.string(k)) in locals.h):
                    k = (k + 1)
                v.name = (HxOverrides.stringOrNull(v.name) + Std.string(k))
            locals.h[v.name] = True
        else:
            _g = self.uniqueLocals
            locals1 = locals
            def _hx_local_3(expr):
                _g(expr,locals1)
            hxsl_Tools.iter(expr,_hx_local_3)

    def link(self,shadersData):
        _gthis = self
        self.varMap = haxe_ds_StringMap()
        self.varIdMap = haxe_ds_IntMap()
        self.allVars = list()
        self.shaders = []
        self.locals = haxe_ds_IntMap()
        dupShaders = haxe_ds_ObjectMap()
        _g = []
        _g1 = 0
        while (_g1 < len(shadersData)):
            s = (shadersData[_g1] if _g1 >= 0 and _g1 < len(shadersData) else None)
            _g1 = (_g1 + 1)
            s1 = s
            sreal = s1
            if (s1 in dupShaders.h):
                s1 = hxsl_Clone.shaderData(s1)
            dupShaders.set(s1,sreal)
            _g.append(s1)
        shadersData = _g
        self.curInstance = 0
        outVars = []
        _g = 0
        while (_g < len(shadersData)):
            s = (shadersData[_g] if _g >= 0 and _g < len(shadersData) else None)
            _g = (_g + 1)
            self.isBatchShader = (self.batchMode and s.name.startswith("batchShader_"))
            _g1 = 0
            _g2 = s.vars
            while (_g1 < len(_g2)):
                v = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                v2 = self.allocVar(v,None,s.name)
                if ((self.isBatchShader and ((v2.v.kind == hxsl_VarKind.Param))) and (not v2.path.startswith("Batch_"))):
                    v2.v.kind = hxsl_VarKind.Local
                if (v.kind == hxsl_VarKind.Output):
                    outVars.append(v)
            _g3 = 0
            _g4 = s.funs
            while (_g3 < len(_g4)):
                f = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                _g3 = (_g3 + 1)
                v1 = self.allocVar(f.ref,f.expr.p)
                v1.kind = f.kind
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.curInstance
            _hx_local_4.curInstance = (_hx_local_5 + 1)
            _hx_local_5
        priority = 0
        initPrio_init = [-3000]
        initPrio_vert = [-2000]
        initPrio_frag = [-1000]
        _g = 0
        while (_g < len(shadersData)):
            s = (shadersData[_g] if _g >= 0 and _g < len(shadersData) else None)
            _g = (_g + 1)
            _g1 = 0
            _g2 = s.funs
            while (_g1 < len(_g2)):
                f = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                v = self.allocVar(f.ref,f.expr.p)
                if (v.kind is None):
                    raise haxe_Exception.thrown("assert")
                tmp = v.kind.index
                if ((tmp == 1) or ((tmp == 0))):
                    self.addShader(((HxOverrides.stringOrNull(s.name) + ".") + HxOverrides.stringOrNull((("vertex" if ((v.kind == hxsl_FunctionKind.Vertex)) else "fragment")))),(v.kind == hxsl_FunctionKind.Vertex),f.expr,priority)
                elif (tmp == 2):
                    prio = None
                    status = None
                    _g3 = f.ref.name
                    _hx_local_8 = len(_g3)
                    if (_hx_local_8 == 16):
                        if (_g3 == "__init__fragment"):
                            prio = initPrio_frag
                            status = False
                        else:
                            prio = initPrio_init
                            status = None
                    elif (_hx_local_8 == 14):
                        if (_g3 == "__init__vertex"):
                            prio = initPrio_vert
                            status = True
                        else:
                            prio = initPrio_init
                            status = None
                    else:
                        prio = initPrio_init
                        status = None
                    _g4 = f.expr.e
                    if (_g4.index == 4):
                        el = _g4.params[0]
                        index = 0
                        _g5 = 0
                        while (_g5 < len(el)):
                            e = (el[_g5] if _g5 >= 0 and _g5 < len(el) else None)
                            _g5 = (_g5 + 1)
                            tmp1 = index
                            index = (index + 1)
                            def _hx_local_13():
                                _hx_local_10 = prio
                                _hx_local_11 = 0
                                _hx_local_12 = (_hx_local_10[_hx_local_11] if _hx_local_11 >= 0 and _hx_local_11 < len(_hx_local_10) else None)
                                python_internal_ArrayImpl._set(_hx_local_10, _hx_local_11, (_hx_local_12 + 1))
                                return _hx_local_12
                            self.addShader((((HxOverrides.stringOrNull(s.name) + ".") + HxOverrides.stringOrNull(f.ref.name)) + Std.string(tmp1)),status,e,_hx_local_13())
                    else:
                        def _hx_local_17():
                            _hx_local_14 = prio
                            _hx_local_15 = 0
                            _hx_local_16 = (_hx_local_14[_hx_local_15] if _hx_local_15 >= 0 and _hx_local_15 < len(_hx_local_14) else None)
                            python_internal_ArrayImpl._set(_hx_local_14, _hx_local_15, (_hx_local_16 + 1))
                            return _hx_local_16
                        self.addShader(((HxOverrides.stringOrNull(s.name) + ".") + HxOverrides.stringOrNull(f.ref.name)),status,f.expr,_hx_local_17())
                elif (tmp == 3):
                    raise haxe_Exception.thrown(("Unexpected helper function in linker " + HxOverrides.stringOrNull(v.v.name)))
                else:
                    pass
            priority = (priority + 1)
        self.shaders.sort(key= python_lib_Functools.cmp_to_key(self.sortByPriorityDesc))
        entry = hxsl__Linker_ShaderInfos("<entry>",False)
        entry.deps = haxe_ds_ObjectMap()
        _g = 0
        while (_g < len(outVars)):
            v = (outVars[_g] if _g >= 0 and _g < len(outVars) else None)
            _g = (_g + 1)
            self.buildDependency(entry,self.allocVar(v,None),False)
        _g = 0
        _g1 = self.shaders
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if s.hasDiscard:
                self.initDependencies(s)
                entry.deps.set(s,True)
        _g = 0
        _g1 = self.shaders
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (s.vertex is not None):
                continue
            onlyParams = True
            r = s.read.iterator()
            while r.hasNext():
                r1 = r.next()
                if (r1.v.kind != hxsl_VarKind.Param):
                    onlyParams = False
                    break
            if onlyParams:
                s.vertex = False
        v = []
        f = []
        self.collect(entry,v,True)
        self.collect(entry,f,False)
        if (((None if ((len(f) == 0)) else f.pop())) != entry):
            raise haxe_Exception.thrown("assert")
        _g = 0
        _g1 = self.shaders
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            s.marked = None
        _g = 0
        _g1 = (v + f)
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            d = s.deps.keys()
            while d.hasNext():
                d1 = d.next()
                if (d1.marked is None):
                    self.error((((HxOverrides.stringOrNull(d1.name) + " needed by ") + HxOverrides.stringOrNull(s.name)) + " is unreachable"),None)
            s.marked = True
        outVars = []
        varMap = haxe_ds_IntMap()
        addVar = None
        def _hx_local_24(v):
            if (v.id in varMap.h):
                return
            varMap.set(v.id,True)
            if (Reflect.field(v.v,"parent") is not None):
                addVar(v.parent)
            else:
                x = v.v
                outVars.append(x)
        addVar = _hx_local_24
        _g = 0
        _g1 = (v + f)
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            v1 = s.read.iterator()
            while v1.hasNext():
                v2 = v1.next()
                addVar(v2)
            v3 = s.write.iterator()
            while v3.hasNext():
                v4 = v3.next()
                addVar(v4)
        cleanVar = None
        def _hx_local_27(v):
            _g = v.type
            if (_g.index == 13):
                vl = _g.params[0]
                if (v.kind != hxsl_VarKind.Input):
                    vout = []
                    _g = 0
                    while (_g < len(vl)):
                        v1 = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                        _g = (_g + 1)
                        if (v1.id in varMap.h):
                            cleanVar(v1)
                            vout.append(v1)
                    v.type = hxsl_Type.TStruct(vout)
        cleanVar = _hx_local_27
        _g = 0
        while (_g < len(outVars)):
            v1 = (outVars[_g] if _g >= 0 and _g < len(outVars) else None)
            _g = (_g + 1)
            cleanVar(v1)
        def _hx_local_31(kind,name,a):
            v = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': name, 'type': hxsl_Type.TFun([_hx_AnonObject({'ret': hxsl_Type.TVoid, 'args': []})]), 'kind': hxsl_VarKind.Function})
            outVars.append(v)
            exprs = []
            _g = 0
            while (_g < len(a)):
                s = (a[_g] if _g >= 0 and _g < len(a) else None)
                _g = (_g + 1)
                _g1 = s.body.e
                if (_g1.index == 4):
                    el = _g1.params[0]
                    _g2 = 0
                    while (_g2 < len(el)):
                        e = (el[_g2] if _g2 >= 0 and _g2 < len(el) else None)
                        _g2 = (_g2 + 1)
                        exprs.append(e)
                else:
                    x = s.body
                    exprs.append(x)
            expr = _hx_AnonObject({'e': hxsl_TExprDef.TBlock(exprs), 't': hxsl_Type.TVoid, 'p': (None if ((len(exprs) == 0)) else (exprs[0] if 0 < len(exprs) else None).p)})
            _gthis.uniqueLocals(expr,haxe_ds_StringMap())
            return _hx_AnonObject({'kind': kind, 'ref': v, 'ret': hxsl_Type.TVoid, 'args': [], 'expr': expr})
        build = _hx_local_31
        funs = [build(hxsl_FunctionKind.Vertex,"vertex",v), build(hxsl_FunctionKind.Fragment,"fragment",f)]
        s = dupShaders.keys()
        while s.hasNext():
            s1 = s.next()
            sreal = dupShaders.h.get(s1,None)
            if (s1 == sreal):
                continue
            _g = 0
            _g1 = len(s1.vars)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this = self.allocVar((s1.vars[i] if i >= 0 and i < len(s1.vars) else None),None).merged
                x = (sreal.vars[i] if i >= 0 and i < len(sreal.vars) else None)
                _this.insert(0, x)
        return _hx_AnonObject({'name': "out", 'vars': outVars, 'funs': funs})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.allVars = None
        _hx_o.varMap = None
        _hx_o.curShader = None
        _hx_o.shaders = None
        _hx_o.varIdMap = None
        _hx_o.locals = None
        _hx_o.curInstance = None
        _hx_o.batchMode = None
        _hx_o.isBatchShader = None
        _hx_o.debugDepth = None
hxsl_Linker._hx_class = hxsl_Linker
_hx_classes["hxsl.Linker"] = hxsl_Linker

class hxsl_Output(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Output"
    _hx_constructs = ["Const", "Value", "PackNormal", "PackFloat", "Vec2", "Vec3", "Vec4", "Swiz"]

    @staticmethod
    def Const(v):
        return hxsl_Output("Const", 0, (v,))

    @staticmethod
    def Value(v,size = None):
        return hxsl_Output("Value", 1, (v,size))

    @staticmethod
    def PackNormal(v):
        return hxsl_Output("PackNormal", 2, (v,))

    @staticmethod
    def PackFloat(v):
        return hxsl_Output("PackFloat", 3, (v,))

    @staticmethod
    def Vec2(a):
        return hxsl_Output("Vec2", 4, (a,))

    @staticmethod
    def Vec3(a):
        return hxsl_Output("Vec3", 5, (a,))

    @staticmethod
    def Vec4(a):
        return hxsl_Output("Vec4", 6, (a,))

    @staticmethod
    def Swiz(a,swiz):
        return hxsl_Output("Swiz", 7, (a,swiz))
hxsl_Output._hx_class = hxsl_Output
_hx_classes["hxsl.Output"] = hxsl_Output


class hxsl_Printer:
    _hx_class_name = "hxsl.Printer"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "varId")
    _hx_fields = ["buffer", "varId"]
    _hx_methods = ["add", "shaderString", "varString", "funString", "exprString", "addVar", "addFun", "addVarName", "addConst", "addExpr"]
    _hx_statics = ["SWIZ", "opStr", "toString", "shaderToString", "check"]

    def __init__(self,varId = None):
        if (varId is None):
            varId = False
        self.buffer = None
        self.varId = varId

    def add(self,v):
        _this = self.buffer
        s = Std.string(v)
        _this.b.write(s)

    def shaderString(self,s):
        self.buffer = StringBuf()
        _g = 0
        _g1 = s.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.addVar(v,None)
            _this = self.buffer
            s1 = Std.string(";\n")
            _this.b.write(s1)
        if (len(s.vars) > 0):
            _this = self.buffer
            s1 = Std.string("\n")
            _this.b.write(s1)
        _g = 0
        _g1 = s.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.addFun(f)
            _this = self.buffer
            s = Std.string("\n\n")
            _this.b.write(s)
        return self.buffer.b.getvalue()

    def varString(self,v):
        self.buffer = StringBuf()
        self.addVar(v,None)
        return self.buffer.b.getvalue()

    def funString(self,f):
        self.buffer = StringBuf()
        self.addFun(f)
        return self.buffer.b.getvalue()

    def exprString(self,e):
        self.buffer = StringBuf()
        self.addExpr(e,"")
        return self.buffer.b.getvalue()

    def addVar(self,v,defKind,tabs = None,parent = None):
        if (tabs is None):
            tabs = ""
        if (Reflect.field(v,"qualifiers") is not None):
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                v1 = None
                v2 = q.index
                if (v2 == 0):
                    _hx_max = q.params[0]
                    v1 = ("const" + HxOverrides.stringOrNull((("" if ((_hx_max is None)) else (("(" + Std.string(_hx_max)) + ")")))))
                elif (v2 == 1):
                    v1 = "private"
                elif (v2 == 2):
                    v1 = "nullable"
                elif (v2 == 3):
                    v1 = "perObject"
                elif (v2 == 4):
                    n = q.params[0]
                    v1 = (("name('" + ("null" if n is None else n)) + "')")
                elif (v2 == 5):
                    v1 = "shared"
                elif (v2 == 6):
                    p = q.params[0]
                    v1 = (HxOverrides.stringOrNull(p.tag.lower()) + "p")
                elif (v2 == 7):
                    _hx_min = q.params[0]
                    max1 = q.params[1]
                    v1 = (((("range(" + Std.string(_hx_min)) + ",") + Std.string(max1)) + ")")
                elif (v2 == 8):
                    v1 = "ignore"
                elif (v2 == 9):
                    n1 = q.params[0]
                    v1 = (("perInstance(" + Std.string(n1)) + ")")
                elif (v2 == 10):
                    s = q.params[0]
                    v1 = (("doc(\"" + HxOverrides.stringOrNull(StringTools.replace(s,"\"","\\\""))) + "\")")
                elif (v2 == 11):
                    s1 = q.params[0]
                    v1 = (("borrow(" + ("null" if s1 is None else s1)) + ")")
                elif (v2 == 12):
                    s2 = q.params[0]
                    v1 = (("sampler(" + ("null" if s2 is None else s2)) + ")")
                else:
                    pass
                _this = self.buffer
                s3 = Std.string((("@" + ("null" if v1 is None else v1)) + " "))
                _this.b.write(s3)
        if (v.kind != defKind):
            tmp = v.kind.index
            if (tmp == 0):
                _this = self.buffer
                s = Std.string("@global ")
                _this.b.write(s)
            elif (tmp == 1):
                _this = self.buffer
                s = Std.string("@input ")
                _this.b.write(s)
            elif (tmp == 2):
                _this = self.buffer
                s = Std.string("@param ")
                _this.b.write(s)
            elif (tmp == 3):
                _this = self.buffer
                s = Std.string("@varying ")
                _this.b.write(s)
            elif (tmp == 4):
                _this = self.buffer
                s = Std.string("@local ")
                _this.b.write(s)
            elif (tmp == 5):
                _this = self.buffer
                s = Std.string("@output ")
                _this.b.write(s)
            elif (tmp == 6):
                _this = self.buffer
                s = Std.string("@function ")
                _this.b.write(s)
            else:
                pass
        _this = self.buffer
        s = Std.string("var ")
        _this.b.write(s)
        if (Reflect.field(v,"parent") == parent):
            _this = self.buffer
            s = Std.string((HxOverrides.stringOrNull(v.name) + HxOverrides.stringOrNull(((("@" + Std.string(v.id)) if (self.varId) else "")))))
            _this.b.write(s)
        else:
            self.addVarName(v)
        _this = self.buffer
        s = Std.string(" : ")
        _this.b.write(s)
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _this = self.buffer
            s = Std.string("{")
            _this.b.write(s)
            first = True
            _g = 0
            while (_g < len(vl)):
                v1 = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                if first:
                    first = False
                else:
                    _this = self.buffer
                    s = Std.string(", ")
                    _this.b.write(s)
                self.addVar(v1,v1.kind,tabs,v1)
            _this = self.buffer
            s = Std.string("}")
            _this.b.write(s)
        else:
            v1 = hxsl_Tools.toString(v.type)
            _this = self.buffer
            s = Std.string(v1)
            _this.b.write(s)

    def addFun(self,f):
        _this = self.buffer
        s = Std.string((("function " + HxOverrides.stringOrNull(f.ref.name)) + "("))
        _this.b.write(s)
        first = True
        _g = 0
        _g1 = f.args
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if first:
                _this = self.buffer
                s = Std.string(" ")
                _this.b.write(s)
                first = False
            else:
                _this1 = self.buffer
                s1 = Std.string(", ")
                _this1.b.write(s1)
            self.addVar(a,hxsl_VarKind.Local)
        if (len(f.args) > 0):
            _this = self.buffer
            s = Std.string(" ")
            _this.b.write(s)
        v = ((") : " + HxOverrides.stringOrNull(hxsl_Tools.toString(f.ret))) + " ")
        _this = self.buffer
        s = Std.string(v)
        _this.b.write(s)
        self.addExpr(f.expr,"")

    def addVarName(self,v):
        if (Reflect.field(v,"parent") is not None):
            self.addVarName(Reflect.field(v,"parent"))
            _this = self.buffer
            s = Std.string(".")
            _this.b.write(s)
        _this = self.buffer
        s = Std.string(v.name)
        _this.b.write(s)
        if self.varId:
            _this = self.buffer
            s = Std.string(("@" + Std.string(v.id)))
            _this.b.write(s)

    def addConst(self,c):
        _this = self.buffer
        s = None
        s1 = c.index
        if (s1 == 0):
            s = "null"
        elif (s1 == 1):
            b = c.params[0]
            s = b
        elif (s1 == 2):
            i = c.params[0]
            s = i
        elif (s1 == 3):
            f = c.params[0]
            s = f
        elif (s1 == 4):
            s1 = c.params[0]
            s = (("\"" + ("null" if s1 is None else s1)) + "\"")
        else:
            pass
        s1 = Std.string(s)
        _this.b.write(s1)

    def addExpr(self,e,tabs):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            c = _g.params[0]
            self.addConst(c)
        elif (tmp == 1):
            v = _g.params[0]
            self.addVarName(v)
        elif (tmp == 2):
            g = _g.params[0]
            v = hxsl_Tools2.toString(g)
            _this = self.buffer
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 3):
            e = _g.params[0]
            _this = self.buffer
            s = Std.string("(")
            _this.b.write(s)
            self.addExpr(e,tabs)
            _this = self.buffer
            s = Std.string(")")
            _this.b.write(s)
        elif (tmp == 4):
            el = _g.params[0]
            _this = self.buffer
            s = Std.string("{")
            _this.b.write(s)
            tabs = (("null" if tabs is None else tabs) + "\t")
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                _this = self.buffer
                s = Std.string(("\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
                self.addExpr(e,tabs)
                _this1 = self.buffer
                s1 = Std.string(";")
                _this1.b.write(s1)
            tabs = HxString.substr(tabs,1,None)
            if (len(el) > 0):
                _this = self.buffer
                s = Std.string(("\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
            _this = self.buffer
            s = Std.string("}")
            _this.b.write(s)
        elif (tmp == 5):
            op = _g.params[0]
            e1 = _g.params[1]
            e2 = _g.params[2]
            self.addExpr(e1,tabs)
            v = ((" " + HxOverrides.stringOrNull(hxsl_Printer.opStr(op))) + " ")
            _this = self.buffer
            s = Std.string(v)
            _this.b.write(s)
            self.addExpr(e2,tabs)
        elif (tmp == 6):
            op = _g.params[0]
            e = _g.params[1]
            v = None
            v1 = op.index
            if (v1 == 0):
                v = "++"
            elif (v1 == 1):
                v = "--"
            elif (v1 == 2):
                v = "!"
            elif (v1 == 3):
                v = "-"
            elif (v1 == 4):
                v = "~"
            else:
                raise haxe_Exception.thrown("assert")
            _this = self.buffer
            s = Std.string(v)
            _this.b.write(s)
            self.addExpr(e,tabs)
        elif (tmp == 7):
            v = _g.params[0]
            init = _g.params[1]
            self.addVar(v,hxsl_VarKind.Local,tabs)
            if (init is not None):
                _this = self.buffer
                s = Std.string(" = ")
                _this.b.write(s)
                self.addExpr(init,tabs)
        elif (tmp == 8):
            e = _g.params[0]
            el = _g.params[1]
            self.addExpr(e,tabs)
            _this = self.buffer
            s = Std.string("(")
            _this.b.write(s)
            first = True
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                if first:
                    first = False
                else:
                    _this = self.buffer
                    s = Std.string(", ")
                    _this.b.write(s)
                self.addExpr(e,tabs)
            _this = self.buffer
            s = Std.string(")")
            _this.b.write(s)
        elif (tmp == 9):
            e = _g.params[0]
            regs = _g.params[1]
            self.addExpr(e,tabs)
            _this = self.buffer
            s = Std.string(".")
            _this.b.write(s)
            _g1 = 0
            while (_g1 < len(regs)):
                r = (regs[_g1] if _g1 >= 0 and _g1 < len(regs) else None)
                _g1 = (_g1 + 1)
                _this = self.buffer
                s = Std.string(python_internal_ArrayImpl._get(hxsl_Printer.SWIZ, r.index))
                _this.b.write(s)
        elif (tmp == 10):
            cond = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            _this = self.buffer
            s = Std.string("if( ")
            _this.b.write(s)
            self.addExpr(cond,tabs)
            _this = self.buffer
            s = Std.string(" ) ")
            _this.b.write(s)
            self.addExpr(eif,tabs)
            if (eelse is not None):
                _this = self.buffer
                s = Std.string(" else ")
                _this.b.write(s)
                self.addExpr(eelse,tabs)
        elif (tmp == 11):
            _this = self.buffer
            s = Std.string("discard")
            _this.b.write(s)
        elif (tmp == 12):
            e = _g.params[0]
            _this = self.buffer
            s = Std.string("return")
            _this.b.write(s)
            if (e is not None):
                _this = self.buffer
                s = Std.string(" ")
                _this.b.write(s)
                self.addExpr(e,tabs)
        elif (tmp == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            _this = self.buffer
            s = Std.string("for( ")
            _this.b.write(s)
            self.addVarName(v)
            _this = self.buffer
            s = Std.string(" in ")
            _this.b.write(s)
            self.addExpr(it,tabs)
            _this = self.buffer
            s = Std.string(" ) ")
            _this.b.write(s)
            self.addExpr(loop,tabs)
        elif (tmp == 14):
            _this = self.buffer
            s = Std.string("continue")
            _this.b.write(s)
        elif (tmp == 15):
            _this = self.buffer
            s = Std.string("break")
            _this.b.write(s)
        elif (tmp == 16):
            e1 = _g.params[0]
            e2 = _g.params[1]
            self.addExpr(e1,tabs)
            _this = self.buffer
            s = Std.string("[")
            _this.b.write(s)
            self.addExpr(e2,tabs)
            _this = self.buffer
            s = Std.string("]")
            _this.b.write(s)
        elif (tmp == 17):
            el = _g.params[0]
            _this = self.buffer
            s = Std.string("[")
            _this.b.write(s)
            first = True
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                if first:
                    first = False
                else:
                    _this = self.buffer
                    s = Std.string(", ")
                    _this.b.write(s)
                self.addExpr(e,tabs)
            _this = self.buffer
            s = Std.string("]")
            _this.b.write(s)
        elif (tmp == 18):
            e = _g.params[0]
            cases = _g.params[1]
            _hx_def = _g.params[2]
            _this = self.buffer
            s = Std.string("switch( ")
            _this.b.write(s)
            self.addExpr(e,tabs)
            _this = self.buffer
            s = Std.string(") {")
            _this.b.write(s)
            old = tabs
            _g1 = 0
            while (_g1 < len(cases)):
                c = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
                _g1 = (_g1 + 1)
                _this = self.buffer
                s = Std.string(("\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
                _this1 = self.buffer
                s1 = Std.string("case ")
                _this1.b.write(s1)
                first = True
                _g2 = 0
                _g3 = c.values
                while (_g2 < len(_g3)):
                    v = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if first:
                        first = False
                    else:
                        _this2 = self.buffer
                        s2 = Std.string(", ")
                        _this2.b.write(s2)
                    self.addExpr(v,tabs)
                tabs = (("null" if tabs is None else tabs) + "\t")
                _this3 = self.buffer
                s3 = Std.string((":\n" + ("null" if tabs is None else tabs)))
                _this3.b.write(s3)
                self.addExpr(c.expr,tabs)
                tabs = old
            if (_hx_def is not None):
                _this = self.buffer
                s = Std.string(("\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
                tabs = (("null" if tabs is None else tabs) + "\t")
                _this = self.buffer
                s = Std.string(("default:\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
                self.addExpr(_hx_def,tabs)
                tabs = old
            _this = self.buffer
            s = Std.string((("\n" + ("null" if tabs is None else tabs)) + "}"))
            _this.b.write(s)
        elif (tmp == 19):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            if (_g.params[2] == False):
                loop = _g2
                e = _g1
                old = tabs
                tabs = (("null" if tabs is None else tabs) + "\t")
                _this = self.buffer
                s = Std.string(("do {\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
                self.addExpr(loop,tabs)
                tabs = old
                _this = self.buffer
                s = Std.string((("\n" + ("null" if tabs is None else tabs)) + "} while( "))
                _this.b.write(s)
                self.addExpr(e,tabs)
                _this = self.buffer
                s = Std.string(" )")
                _this.b.write(s)
            else:
                loop = _g2
                e = _g1
                _this = self.buffer
                s = Std.string("while( ")
                _this.b.write(s)
                self.addExpr(e,tabs)
                old = tabs
                tabs = (("null" if tabs is None else tabs) + "\t")
                _this = self.buffer
                s = Std.string((" ) {\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
                self.addExpr(loop,tabs)
                tabs = old
                _this = self.buffer
                s = Std.string((("\n" + ("null" if tabs is None else tabs)) + "}"))
                _this.b.write(s)
        elif (tmp == 20):
            m = _g.params[0]
            args = _g.params[1]
            e = _g.params[2]
            _this = self.buffer
            s = Std.string("@")
            _this.b.write(s)
            _this = self.buffer
            s = Std.string(m)
            _this.b.write(s)
            if (len(args) > 0):
                _this = self.buffer
                s = Std.string("(")
                _this.b.write(s)
                first = True
                _g = 0
                while (_g < len(args)):
                    c = (args[_g] if _g >= 0 and _g < len(args) else None)
                    _g = (_g + 1)
                    if first:
                        first = False
                    else:
                        _this = self.buffer
                        s = Std.string(", ")
                        _this.b.write(s)
                    self.addConst(c)
                _this = self.buffer
                s = Std.string(")")
                _this.b.write(s)
            _this = self.buffer
            s = Std.string(" ")
            _this.b.write(s)
            self.addExpr(e,tabs)
        else:
            pass

    @staticmethod
    def opStr(op):
        tmp = op.index
        if (tmp == 0):
            return "+"
        elif (tmp == 1):
            return "*"
        elif (tmp == 2):
            return "/"
        elif (tmp == 3):
            return "-"
        elif (tmp == 4):
            return "="
        elif (tmp == 5):
            return "=="
        elif (tmp == 6):
            return "!="
        elif (tmp == 7):
            return ">"
        elif (tmp == 8):
            return ">="
        elif (tmp == 9):
            return "<"
        elif (tmp == 10):
            return "<="
        elif (tmp == 11):
            return "&"
        elif (tmp == 12):
            return "|"
        elif (tmp == 13):
            return "^"
        elif (tmp == 14):
            return "&&"
        elif (tmp == 15):
            return "||"
        elif (tmp == 16):
            return "<<"
        elif (tmp == 17):
            return ">>"
        elif (tmp == 18):
            return ">>>"
        elif (tmp == 19):
            return "%"
        elif (tmp == 20):
            op1 = op.params[0]
            return (HxOverrides.stringOrNull(hxsl_Printer.opStr(op1)) + "=")
        elif (tmp == 21):
            return "..."
        elif (tmp == 22):
            return "=>"
        elif (tmp == 23):
            return " in "
        else:
            pass

    @staticmethod
    def toString(e,varId = None):
        if (varId is None):
            varId = False
        return hxsl_Printer(varId).exprString(e)

    @staticmethod
    def shaderToString(s,varId = None):
        if (varId is None):
            varId = False
        return hxsl_Printer(varId).shaderString(s)

    @staticmethod
    def check(s,_hx_from = None):
        try:
            vars = haxe_ds_IntMap()
            regVars = []
            regVar = None
            def _hx_local_1(v,reg):
                if reg:
                    if (v.id in vars.h):
                        raise haxe_Exception.thrown(("Duplicate var " + Std.string(v.id)))
                    vars.set(v.id,v)
                    regVars.append(v)
                else:
                    vars.remove(v.id)
                _g = v.type
                if (_g.index == 13):
                    vl = _g.params[0]
                    _g = 0
                    while (_g < len(vl)):
                        v = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                        _g = (_g + 1)
                        regVar(v,reg)
            regVar = _hx_local_1
            checkExpr = None
            def _hx_local_4(e):
                nonlocal regVars
                nonlocal regVars
                _g = e.e
                checkExpr1 = _g.index
                if (checkExpr1 == 1):
                    v = _g.params[0]
                    if (not (v.id in vars.h)):
                        raise haxe_Exception.thrown(((("Unbound var " + HxOverrides.stringOrNull(v.name)) + "@") + Std.string(v.id)))
                elif (checkExpr1 == 4):
                    el = _g.params[0]
                    old = regVars
                    regVars = []
                    _g1 = 0
                    while (_g1 < len(el)):
                        e1 = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                        _g1 = (_g1 + 1)
                        checkExpr(e1)
                    _g1 = 0
                    while (_g1 < len(regVars)):
                        v = (regVars[_g1] if _g1 >= 0 and _g1 < len(regVars) else None)
                        _g1 = (_g1 + 1)
                        regVar(v,False)
                    regVars = old
                elif (checkExpr1 == 7):
                    v = _g.params[0]
                    init = _g.params[1]
                    if (init is not None):
                        checkExpr(init)
                    regVar(v,True)
                elif (checkExpr1 == 13):
                    v = _g.params[0]
                    it = _g.params[1]
                    loop = _g.params[2]
                    checkExpr(it)
                    regVar(v,True)
                    checkExpr(loop)
                    regVar(v,False)
                else:
                    hxsl_Tools.iter(e,checkExpr)
            checkExpr = _hx_local_4
            _g = 0
            _g1 = s.vars
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                regVar(v,True)
            _g = 0
            _g1 = s.funs
            while (_g < len(_g1)):
                f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _g2 = 0
                _g3 = f.args
                while (_g2 < len(_g3)):
                    v = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    regVar(v,True)
                checkExpr(f.expr)
                _g4 = 0
                _g5 = f.args
                while (_g4 < len(_g5)):
                    v1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                    _g4 = (_g4 + 1)
                    regVar(v1,False)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,str):
                e = _g1
                msg = ((("null" if e is None else e) + "\n    in\n") + HxOverrides.stringOrNull(hxsl_Printer.shaderToString(s,True)))
                if (_hx_from is not None):
                    _g1 = []
                    _g2 = 0
                    while (_g2 < len(_hx_from)):
                        s = (_hx_from[_g2] if _g2 >= 0 and _g2 < len(_hx_from) else None)
                        _g2 = (_g2 + 1)
                        x = hxsl_Printer.shaderToString(s,True)
                        _g1.append(x)
                    msg = (("null" if msg is None else msg) + HxOverrides.stringOrNull((("\n    from\n\n" + HxOverrides.stringOrNull("\n\n".join([python_Boot.toString1(x1,'') for x1 in _g1]))))))
                raise haxe_Exception.thrown(msg)
            else:
                raise _g

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.varId = None
hxsl_Printer._hx_class = hxsl_Printer
_hx_classes["hxsl.Printer"] = hxsl_Printer


class hxsl_AllocParam:
    _hx_class_name = "hxsl.AllocParam"
    _hx_is_interface = "False"
    __slots__ = ("name", "pos", "instance", "index", "type", "perObjectGlobal", "next")
    _hx_fields = ["name", "pos", "instance", "index", "type", "perObjectGlobal", "next"]
    _hx_methods = ["clone"]

    def __init__(self,name,pos,instance,index,_hx_type):
        self.next = None
        self.perObjectGlobal = None
        self.name = name
        self.pos = pos
        self.instance = instance
        self.index = index
        self.type = _hx_type

    def clone(self,resetGID = None):
        if (resetGID is None):
            resetGID = False
        p = hxsl_AllocParam(self.name,self.pos,self.instance,self.index,self.type)
        if (self.perObjectGlobal is not None):
            p.perObjectGlobal = self.perObjectGlobal.clone(resetGID)
        if (self.next is not None):
            p.next = self.next.clone(resetGID)
        return p

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.pos = None
        _hx_o.instance = None
        _hx_o.index = None
        _hx_o.type = None
        _hx_o.perObjectGlobal = None
        _hx_o.next = None
hxsl_AllocParam._hx_class = hxsl_AllocParam
_hx_classes["hxsl.AllocParam"] = hxsl_AllocParam


class hxsl_AllocGlobal:
    _hx_class_name = "hxsl.AllocGlobal"
    _hx_is_interface = "False"
    __slots__ = ("pos", "gid", "path", "type", "next")
    _hx_fields = ["pos", "gid", "path", "type", "next"]
    _hx_methods = ["clone"]

    def __init__(self,pos,path,_hx_type):
        self.next = None
        self.pos = pos
        self.path = path
        self.gid = hxsl_Globals.allocID(path)
        self.type = _hx_type

    def clone(self,resetGID = None):
        if (resetGID is None):
            resetGID = False
        g = hxsl_AllocGlobal(self.pos,self.path,self.type)
        if (self.next is not None):
            g.next = self.next.clone(resetGID)
        if resetGID:
            g.gid = 0
        return g

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pos = None
        _hx_o.gid = None
        _hx_o.path = None
        _hx_o.type = None
        _hx_o.next = None
hxsl_AllocGlobal._hx_class = hxsl_AllocGlobal
_hx_classes["hxsl.AllocGlobal"] = hxsl_AllocGlobal


class hxsl_RuntimeShaderData:
    _hx_class_name = "hxsl.RuntimeShaderData"
    _hx_is_interface = "False"
    __slots__ = ("vertex", "data", "code", "params", "paramsSize", "globals", "globalsSize", "textures", "texturesCount", "buffers", "bufferCount", "consts")
    _hx_fields = ["vertex", "data", "code", "params", "paramsSize", "globals", "globalsSize", "textures", "texturesCount", "buffers", "bufferCount", "consts"]

    def __init__(self):
        self.consts = None
        self.bufferCount = None
        self.buffers = None
        self.texturesCount = None
        self.textures = None
        self.globalsSize = None
        self.globals = None
        self.paramsSize = None
        self.params = None
        self.code = None
        self.data = None
        self.vertex = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vertex = None
        _hx_o.data = None
        _hx_o.code = None
        _hx_o.params = None
        _hx_o.paramsSize = None
        _hx_o.globals = None
        _hx_o.globalsSize = None
        _hx_o.textures = None
        _hx_o.texturesCount = None
        _hx_o.buffers = None
        _hx_o.bufferCount = None
        _hx_o.consts = None
hxsl_RuntimeShaderData._hx_class = hxsl_RuntimeShaderData
_hx_classes["hxsl.RuntimeShaderData"] = hxsl_RuntimeShaderData


class hxsl_ShaderInstanceDesc:
    _hx_class_name = "hxsl.ShaderInstanceDesc"
    _hx_is_interface = "False"
    __slots__ = ("shader", "bits", "index")
    _hx_fields = ["shader", "bits", "index"]

    def __init__(self,shader,bits):
        self.index = None
        self.shader = shader
        self.bits = bits

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shader = None
        _hx_o.bits = None
        _hx_o.index = None
hxsl_ShaderInstanceDesc._hx_class = hxsl_ShaderInstanceDesc
_hx_classes["hxsl.ShaderInstanceDesc"] = hxsl_ShaderInstanceDesc


class hxsl_RuntimeShader:
    _hx_class_name = "hxsl.RuntimeShader"
    _hx_is_interface = "False"
    __slots__ = ("id", "vertex", "fragment", "globals", "signature", "batchMode", "spec")
    _hx_fields = ["id", "vertex", "fragment", "globals", "signature", "batchMode", "spec"]
    _hx_methods = ["hasGlobal"]
    _hx_statics = ["UID"]

    def __init__(self):
        self.spec = None
        self.batchMode = None
        self.signature = None
        self.globals = None
        self.fragment = None
        self.vertex = None
        def _hx_local_2():
            _hx_local_0 = hxsl_RuntimeShader
            _hx_local_1 = _hx_local_0.UID
            _hx_local_0.UID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()

    def hasGlobal(self,gid):
        return (gid in self.globals.h)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.vertex = None
        _hx_o.fragment = None
        _hx_o.globals = None
        _hx_o.signature = None
        _hx_o.batchMode = None
        _hx_o.spec = None
hxsl_RuntimeShader._hx_class = hxsl_RuntimeShader
_hx_classes["hxsl.RuntimeShader"] = hxsl_RuntimeShader


class hxsl_Serializer:
    _hx_class_name = "hxsl.Serializer"
    _hx_is_interface = "False"
    __slots__ = ("out", "input", "varMap", "idMap", "typeIdMap", "types", "uid", "tid")
    _hx_fields = ["out", "input", "varMap", "idMap", "typeIdMap", "types", "uid", "tid"]
    _hx_methods = ["writeArr", "readArr", "readVarInt", "writeVarInt", "writeID", "readID", "writeTID", "writeType", "readType", "writeString", "readString", "writeVar", "writeFun", "writeConst", "writeExpr", "readConst", "readExpr", "readVar", "readFun", "unserialize", "serialize"]
    _hx_statics = ["TVECS", "BOPS", "UNOPS", "TGLOBALS", "TSWIZ", "REGS", "VKINDS", "PRECS", "FKIND", "SIGN", "run"]

    def __init__(self):
        self.types = None
        self.typeIdMap = None
        self.idMap = None
        self.varMap = None
        self.input = None
        self.out = None
        self.tid = 1
        self.uid = 1

    def writeArr(self,arr,f):
        self.writeVarInt(len(arr))
        _g = 0
        while (_g < len(arr)):
            v = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            f(v)

    def readArr(self,f):
        _g = []
        _g1 = 0
        _g2 = self.readVarInt()
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = f()
            _g.append(x)
        return _g

    def readVarInt(self):
        b = self.input.readByte()
        if (b < 128):
            return b
        if (b == 255):
            return self.input.readInt32()
        return ((((b & 127)) << 8) | self.input.readByte())

    def writeVarInt(self,id):
        if (id < 128):
            self.out.b.append(id)
        else:
            n = (id >> 8)
            if (n >= 127):
                self.out.b.append(255)
                self.out.addInt32(n)
            else:
                self.out.b.append((n | 128))
                self.out.b.append((id & 255))

    def writeID(self,id):
        id2 = self.idMap.h.get(id,None)
        if (id2 is None):
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.uid
                _hx_local_0.uid = (_hx_local_1 + 1)
                return _hx_local_1
            id2 = _hx_local_2()
            self.idMap.set(id,id2)
        self.writeVarInt(id2)

    def readID(self):
        return self.readVarInt()

    def writeTID(self,t):
        tid = self.typeIdMap.get(t)
        if (tid is not None):
            self.writeVarInt(tid)
            return False
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.tid
            _hx_local_0.tid = (_hx_local_1 + 1)
            return _hx_local_1
        tid = _hx_local_2()
        self.typeIdMap.set(t,tid)
        self.writeVarInt(tid)
        return True

    def writeType(self,t):
        self.out.b.append(t.index)
        tmp = t.index
        if ((((((((((((tmp == 18) or ((tmp == 12))) or ((tmp == 11))) or ((tmp == 10))) or ((tmp == 8))) or ((tmp == 7))) or ((tmp == 6))) or ((tmp == 4))) or ((tmp == 3))) or ((tmp == 2))) or ((tmp == 1))) or ((tmp == 0))):
            pass
        elif (tmp == 5):
            size = t.params[0]
            t1 = t.params[1]
            self.out.b.append((size | ((t1.index << 3))))
        elif (tmp == 9):
            size = t.params[0]
            self.out.addInt32(size)
        elif (tmp == 13):
            vl = t.params[0]
            if self.writeTID(t):
                f = self.writeVar
                self.writeVarInt(len(vl))
                _g = 0
                while (_g < len(vl)):
                    v = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                    _g = (_g + 1)
                    f(v)
        elif (tmp == 14):
            variants = t.params[0]
        elif (tmp == 15):
            t1 = t.params[0]
            size = t.params[1]
            self.writeType(t1)
            tmp = size.index
            if (tmp == 0):
                v = size.params[0]
                self.out.b.append(0)
                self.writeVarInt(v)
            elif (tmp == 1):
                v = size.params[0]
                self.writeVar(v)
            else:
                pass
        elif (tmp == 16):
            t1 = t.params[0]
            size = t.params[1]
            self.writeType(t1)
            tmp = size.index
            if (tmp == 0):
                v = size.params[0]
                self.out.b.append(0)
                self.writeVarInt(v)
            elif (tmp == 1):
                v = size.params[0]
                self.writeVar(v)
            else:
                pass
        elif (tmp == 17):
            size = t.params[0]
            self.out.b.append(size)
        else:
            pass

    def readType(self):
        _g = self.input.readByte()
        if (_g == 0):
            return hxsl_Type.TVoid
        elif (_g == 1):
            return hxsl_Type.TInt
        elif (_g == 2):
            return hxsl_Type.TBool
        elif (_g == 3):
            return hxsl_Type.TFloat
        elif (_g == 4):
            return hxsl_Type.TString
        elif (_g == 5):
            bits = self.input.readByte()
            v = hxsl_Serializer.TVECS.h.get(bits,None)
            if (v is None):
                v = hxsl_Type.TVec((bits & 7),Type.createEnumIndex(hxsl_VecType,(bits >> 3),None))
                hxsl_Serializer.TVECS.set(bits,v)
            return v
        elif (_g == 6):
            return hxsl_Type.TMat3
        elif (_g == 7):
            return hxsl_Type.TMat4
        elif (_g == 8):
            return hxsl_Type.TMat3x4
        elif (_g == 9):
            return hxsl_Type.TBytes(self.input.readInt32())
        elif (_g == 10):
            return hxsl_Type.TSampler2D
        elif (_g == 11):
            return hxsl_Type.TSampler2DArray
        elif (_g == 12):
            return hxsl_Type.TSamplerCube
        elif (_g == 13):
            id = self.readVarInt()
            t = (self.types[id] if id >= 0 and id < len(self.types) else None)
            if (t is not None):
                return t
            f = self.readVar
            _g = []
            _g1 = 0
            _g2 = self.readVarInt()
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = f()
                _g.append(x)
            t = hxsl_Type.TStruct(_g)
            python_internal_ArrayImpl._set(self.types, id, t)
            return t
        elif (_g == 14):
            return hxsl_Type.TFun(None)
        elif (_g == 15):
            t = self.readType()
            v = self.readVar()
            return hxsl_Type.TArray(t,(hxsl_SizeDecl.SConst(self.readVarInt()) if ((v is None)) else hxsl_SizeDecl.SVar(v)))
        elif (_g == 16):
            t = self.readType()
            v = self.readVar()
            return hxsl_Type.TBuffer(t,(hxsl_SizeDecl.SConst(self.readVarInt()) if ((v is None)) else hxsl_SizeDecl.SVar(v)))
        elif (_g == 17):
            return hxsl_Type.TChannel(self.input.readByte())
        elif (_g == 18):
            return hxsl_Type.TMat2
        else:
            raise haxe_Exception.thrown("assert")

    def writeString(self,s):
        _hx_bytes = haxe_io_Bytes.ofString(s)
        self.writeVarInt(_hx_bytes.length)
        self.out.b.extend(_hx_bytes.b)

    def readString(self):
        _hx_len = self.readVarInt()
        s = self.input.read(_hx_len).getString(0,_hx_len)
        return s

    def writeVar(self,v):
        if (v is None):
            self.out.b.append(0)
            return
        self.writeID(v.id)
        if (v.id in self.varMap.h):
            return
        self.varMap.set(v.id,v)
        self.writeString(v.name)
        self.writeType(v.type)
        self.out.b.append(v.kind.index)
        self.writeVar(Reflect.field(v,"parent"))
        if (Reflect.field(v,"qualifiers") is None):
            self.out.b.append(0)
        else:
            self.out.b.append(len(Reflect.field(v,"qualifiers")))
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.out.b.append(q.index)
                tmp = q.index
                if (tmp == 0):
                    _hx_max = q.params[0]
                    self.out.addInt32((0 if ((_hx_max is None)) else _hx_max))
                elif (tmp == 4):
                    n = q.params[0]
                    self.writeString(n)
                elif (((((tmp == 8) or ((tmp == 5))) or ((tmp == 3))) or ((tmp == 2))) or ((tmp == 1))):
                    pass
                elif (tmp == 6):
                    p = q.params[0]
                    self.out.b.append(p.index)
                elif (tmp == 7):
                    _hx_min = q.params[0]
                    max1 = q.params[1]
                    self.out.addInt64(haxe_io_FPHelper.doubleToI64(_hx_min))
                    self.out.addInt64(haxe_io_FPHelper.doubleToI64(max1))
                elif (tmp == 9):
                    v = q.params[0]
                    self.out.addInt32(v)
                elif (tmp == 10):
                    s = q.params[0]
                    self.writeString(s)
                elif (tmp == 11):
                    s1 = q.params[0]
                    self.writeString(s1)
                elif (tmp == 12):
                    s2 = q.params[0]
                    self.writeString(s2)
                else:
                    pass

    def writeFun(self,f):
        self.out.b.append(f.kind.index)
        self.writeVar(f.ref)
        arr = f.args
        f1 = self.writeVar
        self.writeVarInt(len(arr))
        _g = 0
        while (_g < len(arr)):
            v = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            f1(v)
        self.writeType(f.ret)
        self.writeExpr(f.expr)

    def writeConst(self,c):
        self.out.b.append(c.index)
        tmp = c.index
        if (tmp == 0):
            pass
        elif (tmp == 1):
            b = c.params[0]
            self.out.b.append((1 if b else 0))
        elif (tmp == 2):
            v = c.params[0]
            self.out.addInt32(v)
        elif (tmp == 3):
            v = c.params[0]
            self.out.addInt64(haxe_io_FPHelper.doubleToI64(v))
        elif (tmp == 4):
            v = c.params[0]
            self.writeString(v)
        else:
            pass

    def writeExpr(self,e):
        _gthis = self
        if (e is None):
            self.out.b.append(0)
            return
        self.out.b.append((e.e.index + 1))
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            c = _g.params[0]
            self.writeConst(c)
        elif (tmp == 1):
            v = _g.params[0]
            self.writeVar(v)
        elif (tmp == 2):
            g = _g.params[0]
            self.out.b.append(g.index)
        elif (tmp == 3):
            e1 = _g.params[0]
            self.writeExpr(e1)
        elif (tmp == 4):
            el = _g.params[0]
            f = self.writeExpr
            self.writeVarInt(len(el))
            _g1 = 0
            while (_g1 < len(el)):
                v = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                f(v)
        elif (tmp == 5):
            op = _g.params[0]
            e1 = _g.params[1]
            e2 = _g.params[2]
            if (op.index == 20):
                op1 = op.params[0]
                self.out.b.append((op1.index | 128))
            else:
                self.out.b.append(op.index)
            self.writeExpr(e1)
            self.writeExpr(e2)
        elif (tmp == 6):
            op = _g.params[0]
            e1 = _g.params[1]
            self.out.b.append(op.index)
            self.writeExpr(e1)
        elif (tmp == 7):
            v = _g.params[0]
            init = _g.params[1]
            self.writeVar(v)
            self.writeExpr(init)
        elif (tmp == 8):
            e1 = _g.params[0]
            args = _g.params[1]
            self.writeExpr(e1)
            f = self.writeExpr
            self.writeVarInt(len(args))
            _g1 = 0
            while (_g1 < len(args)):
                v = (args[_g1] if _g1 >= 0 and _g1 < len(args) else None)
                _g1 = (_g1 + 1)
                f(v)
        elif (tmp == 9):
            e1 = _g.params[0]
            regs = _g.params[1]
            self.writeExpr(e1)
            if (len(regs) == 0):
                raise haxe_Exception.thrown("assert")
            bits = (len(regs) - 1)
            k = 2
            _g1 = 0
            while (_g1 < len(regs)):
                r = (regs[_g1] if _g1 >= 0 and _g1 < len(regs) else None)
                _g1 = (_g1 + 1)
                bits = (bits | ((r.index << k)))
                k = (k + 2)
            self.out.b.append((bits & 255))
            self.out.b.append((bits >> 8))
        elif (tmp == 10):
            econd = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            self.writeExpr(econd)
            self.writeExpr(eif)
            self.writeExpr(eelse)
        elif (tmp == 11):
            pass
        elif (tmp == 12):
            e1 = _g.params[0]
            self.writeExpr(e1)
        elif (tmp == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            self.writeVar(v)
            self.writeExpr(it)
            self.writeExpr(loop)
        elif (tmp == 14):
            pass
        elif (tmp == 15):
            pass
        elif (tmp == 16):
            e1 = _g.params[0]
            index = _g.params[1]
            self.writeExpr(e1)
            self.writeExpr(index)
        elif (tmp == 17):
            el = _g.params[0]
            f = self.writeExpr
            self.writeVarInt(len(el))
            _g1 = 0
            while (_g1 < len(el)):
                v = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                f(v)
        elif (tmp == 18):
            e1 = _g.params[0]
            cases = _g.params[1]
            _hx_def = _g.params[2]
            self.writeExpr(e1)
            self.writeVarInt(len(cases))
            _g1 = 0
            while (_g1 < len(cases)):
                v = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
                _g1 = (_g1 + 1)
                arr = v.values
                f = _gthis.writeExpr
                _gthis.writeVarInt(len(arr))
                _g2 = 0
                while (_g2 < len(arr)):
                    v1 = (arr[_g2] if _g2 >= 0 and _g2 < len(arr) else None)
                    _g2 = (_g2 + 1)
                    f(v1)
                _gthis.writeExpr(v.expr)
            self.writeExpr(_hx_def)
        elif (tmp == 19):
            e1 = _g.params[0]
            loop = _g.params[1]
            normalWhile = _g.params[2]
            self.writeExpr(e1)
            self.writeExpr(loop)
            self.out.b.append((1 if normalWhile else 0))
        elif (tmp == 20):
            m = _g.params[0]
            args = _g.params[1]
            e1 = _g.params[2]
            self.writeString(m)
            f = self.writeConst
            self.writeVarInt(len(args))
            _g = 0
            while (_g < len(args)):
                v = (args[_g] if _g >= 0 and _g < len(args) else None)
                _g = (_g + 1)
                f(v)
            self.writeExpr(e1)
        else:
            pass
        self.writeType(e.t)

    def readConst(self):
        _g = self.input.readByte()
        if (_g == 0):
            return hxsl_Const.CNull
        elif (_g == 1):
            return hxsl_Const.CBool((self.input.readByte() != 0))
        elif (_g == 2):
            return hxsl_Const.CInt(self.input.readInt32())
        elif (_g == 3):
            return hxsl_Const.CFloat(self.input.readDouble())
        elif (_g == 4):
            return hxsl_Const.CString(self.readString())
        else:
            raise haxe_Exception.thrown("assert")

    def readExpr(self):
        _gthis = self
        k = self.input.readByte()
        tmp = k
        k = (k - 1)
        if (tmp == 0):
            return None
        e = None
        k1 = k
        if (k1 == 0):
            e = hxsl_TExprDef.TConst(self.readConst())
        elif (k1 == 1):
            e = hxsl_TExprDef.TVar(self.readVar())
        elif (k1 == 2):
            e = hxsl_TExprDef.TGlobal(python_internal_ArrayImpl._get(hxsl_Serializer.TGLOBALS, self.input.readByte()))
        elif (k1 == 3):
            e = hxsl_TExprDef.TParenthesis(self.readExpr())
        elif (k1 == 4):
            f = self.readExpr
            _g = []
            _g1 = 0
            _g2 = self.readVarInt()
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = f()
                _g.append(x)
            e = hxsl_TExprDef.TBlock(_g)
        elif (k1 == 5):
            op = self.input.readByte()
            e = hxsl_TExprDef.TBinop((haxe_macro_Binop.OpAssignOp(python_internal_ArrayImpl._get(hxsl_Serializer.BOPS, (op & 127))) if ((op >= 128)) else python_internal_ArrayImpl._get(hxsl_Serializer.BOPS, op)),self.readExpr(),self.readExpr())
        elif (k1 == 6):
            e = hxsl_TExprDef.TUnop(python_internal_ArrayImpl._get(hxsl_Serializer.UNOPS, self.input.readByte()),self.readExpr())
        elif (k1 == 7):
            e = hxsl_TExprDef.TVarDecl(self.readVar(),self.readExpr())
        elif (k1 == 8):
            e1 = self.readExpr()
            f = self.readExpr
            _g = []
            _g1 = 0
            _g2 = self.readVarInt()
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = f()
                _g.append(x)
            e = hxsl_TExprDef.TCall(e1,_g)
        elif (k1 == 9):
            e1 = self.readExpr()
            bits = self.input.readUInt16()
            swiz = hxsl_Serializer.TSWIZ.h.get(bits,None)
            if (swiz is None):
                _g = []
                _g1 = 0
                _g2 = (((bits & 3)) + 1)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    x = python_internal_ArrayImpl._get(hxsl_Serializer.REGS, ((bits >> (((i * 2) + 2))) & 3))
                    _g.append(x)
                swiz = _g
                hxsl_Serializer.TSWIZ.set(bits,swiz)
            e = hxsl_TExprDef.TSwiz(e1,swiz)
        elif (k1 == 10):
            e = hxsl_TExprDef.TIf(self.readExpr(),self.readExpr(),self.readExpr())
        elif (k1 == 11):
            e = hxsl_TExprDef.TDiscard
        elif (k1 == 12):
            e = hxsl_TExprDef.TReturn(self.readExpr())
        elif (k1 == 13):
            e = hxsl_TExprDef.TFor(self.readVar(),self.readExpr(),self.readExpr())
        elif (k1 == 14):
            e = hxsl_TExprDef.TContinue
        elif (k1 == 15):
            e = hxsl_TExprDef.TBreak
        elif (k1 == 16):
            e = hxsl_TExprDef.TArray(self.readExpr(),self.readExpr())
        elif (k1 == 17):
            f = self.readExpr
            _g = []
            _g1 = 0
            _g2 = self.readVarInt()
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = f()
                _g.append(x)
            e = hxsl_TExprDef.TArrayDecl(_g)
        elif (k1 == 18):
            e1 = self.readExpr()
            _g = []
            _g1 = 0
            _g2 = self.readVarInt()
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                f = _gthis.readExpr
                _g3 = []
                _g4 = 0
                _g5 = _gthis.readVarInt()
                while (_g4 < _g5):
                    i1 = _g4
                    _g4 = (_g4 + 1)
                    x = f()
                    _g3.append(x)
                x1 = _hx_AnonObject({'values': _g3, 'expr': _gthis.readExpr()})
                _g.append(x1)
            e = hxsl_TExprDef.TSwitch(e1,_g,self.readExpr())
        elif (k1 == 19):
            e = hxsl_TExprDef.TWhile(self.readExpr(),self.readExpr(),(self.input.readByte() != 0))
        elif (k1 == 20):
            e1 = self.readString()
            f = self.readConst
            _g = []
            _g1 = 0
            _g2 = self.readVarInt()
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = f()
                _g.append(x)
            e = hxsl_TExprDef.TMeta(e1,_g,self.readExpr())
        else:
            raise haxe_Exception.thrown("assert")
        return _hx_AnonObject({'e': e, 't': self.readType(), 'p': None})

    def readVar(self):
        id = self.readVarInt()
        if (id == 0):
            return None
        v = self.varMap.h.get(id,None)
        if (v is not None):
            return v
        v = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': self.readString(), 'type': None, 'kind': None})
        self.varMap.set(id,v)
        v.type = self.readType()
        v.kind = python_internal_ArrayImpl._get(hxsl_Serializer.VKINDS, self.input.readByte())
        Reflect.setField(v,"parent",self.readVar())
        nq = self.input.readByte()
        if (nq > 0):
            Reflect.setField(v,"qualifiers",[])
            _g = 0
            _g1 = nq
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                qid = self.input.readByte()
                q = None
                qid1 = qid
                if (qid1 == 0):
                    n = self.input.readInt32()
                    q = hxsl_VarQualifier.Const((None if ((n == 0)) else n))
                elif (qid1 == 1):
                    q = hxsl_VarQualifier.Private
                elif (qid1 == 2):
                    q = hxsl_VarQualifier.Nullable
                elif (qid1 == 3):
                    q = hxsl_VarQualifier.PerObject
                elif (qid1 == 4):
                    q = hxsl_VarQualifier.Name(self.readString())
                elif (qid1 == 5):
                    q = hxsl_VarQualifier.Shared
                elif (qid1 == 6):
                    q = hxsl_VarQualifier.Precision(python_internal_ArrayImpl._get(hxsl_Serializer.PRECS, self.input.readByte()))
                elif (qid1 == 7):
                    q = hxsl_VarQualifier.Range(self.input.readDouble(),self.input.readDouble())
                elif (qid1 == 8):
                    q = hxsl_VarQualifier.Ignore
                elif (qid1 == 9):
                    q = hxsl_VarQualifier.PerInstance(self.input.readInt32())
                elif (qid1 == 10):
                    q = hxsl_VarQualifier.Doc(self.readString())
                elif (qid1 == 11):
                    q = hxsl_VarQualifier.Borrow(self.readString())
                elif (qid1 == 12):
                    q = hxsl_VarQualifier.Sampler(self.readString())
                else:
                    raise haxe_Exception.thrown("assert")
                _this = Reflect.field(v,"qualifiers")
                _this.append(q)
        return v

    def readFun(self):
        tmp = python_internal_ArrayImpl._get(hxsl_Serializer.FKIND, self.input.readByte())
        tmp1 = self.readVar()
        f = self.readVar
        _g = []
        _g1 = 0
        _g2 = self.readVarInt()
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = f()
            _g.append(x)
        return _hx_AnonObject({'kind': tmp, 'ref': tmp1, 'args': _g, 'ret': self.readType(), 'expr': self.readExpr()})

    def unserialize(self,data):
        self.input = haxe_io_BytesInput(haxe_crypto_Base64.decode(data,False))
        if (((self.input.readByte() != ((hxsl_Serializer.SIGN & 255))) or ((self.input.readByte() != (((hxsl_Serializer.SIGN >> 8) & 255))))) or ((self.input.readByte() != (((hxsl_Serializer.SIGN >> 16) & 255))))):
            raise haxe_Exception.thrown("Invalid HXSL data")
        self.varMap = haxe_ds_IntMap()
        self.types = []
        tmp = self.readString()
        f = self.readVar
        _g = []
        _g1 = 0
        _g2 = self.readVarInt()
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = f()
            _g.append(x)
        tmp1 = _g
        f = self.readFun
        _g = []
        _g1 = 0
        _g2 = self.readVarInt()
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = f()
            _g.append(x)
        return _hx_AnonObject({'name': tmp, 'vars': tmp1, 'funs': _g})

    def serialize(self,s):
        self.varMap = haxe_ds_IntMap()
        self.idMap = haxe_ds_IntMap()
        self.typeIdMap = haxe_ds_EnumValueMap()
        self.out = haxe_io_BytesBuffer()
        self.out.b.append((hxsl_Serializer.SIGN & 255))
        self.out.b.append(((hxsl_Serializer.SIGN >> 8) & 255))
        self.out.b.append(((hxsl_Serializer.SIGN >> 16) & 255))
        self.writeString(s.name)
        arr = s.vars
        f = self.writeVar
        self.writeVarInt(len(arr))
        _g = 0
        while (_g < len(arr)):
            v = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            f(v)
        arr = s.funs
        f = self.writeFun
        self.writeVarInt(len(arr))
        _g = 0
        while (_g < len(arr)):
            v = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            f(v)
        return haxe_crypto_Base64.encode(self.out.getBytes(),False)

    @staticmethod
    def run(s):
        return hxsl_Serializer().serialize(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.out = None
        _hx_o.input = None
        _hx_o.varMap = None
        _hx_o.idMap = None
        _hx_o.typeIdMap = None
        _hx_o.types = None
        _hx_o.uid = None
        _hx_o.tid = None
hxsl_Serializer._hx_class = hxsl_Serializer
_hx_classes["hxsl.Serializer"] = hxsl_Serializer


class hxsl_ShaderList:
    _hx_class_name = "hxsl.ShaderList"
    _hx_is_interface = "False"
    __slots__ = ("s", "next")
    _hx_fields = ["s", "next"]
    _hx_methods = ["clone", "iterator", "iterateTo"]
    _hx_statics = ["addSort"]

    def __init__(self,s,n = None):
        self.s = s
        self.next = n

    def clone(self):
        return hxsl_ShaderList(self.s.clone(),(None if ((self.next is None)) else self.next.clone()))

    def iterator(self):
        return hxsl__ShaderList_ShaderIterator(self,None)

    def iterateTo(self,s):
        return hxsl__ShaderList_ShaderIterator(self,s)

    @staticmethod
    def addSort(s,shaders):
        prev = None
        hd = shaders
        while ((hd is not None) and ((hd.s.priority < s.priority))):
            prev = hd
            hd = hd.next
        if (prev is None):
            return hxsl_ShaderList(s,shaders)
        prev.next = hxsl_ShaderList(s,prev.next)
        return shaders

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.s = None
        _hx_o.next = None
hxsl_ShaderList._hx_class = hxsl_ShaderList
_hx_classes["hxsl.ShaderList"] = hxsl_ShaderList


class hxsl__ShaderList_ShaderIterator:
    _hx_class_name = "hxsl._ShaderList.ShaderIterator"
    _hx_is_interface = "False"
    __slots__ = ("l", "last")
    _hx_fields = ["l", "last"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,l,last):
        self.l = l
        self.last = last

    def hasNext(self):
        return (self.l != self.last)

    def next(self):
        s = self.l.s
        self.l = self.l.next
        return s

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.l = None
        _hx_o.last = None
hxsl__ShaderList_ShaderIterator._hx_class = hxsl__ShaderList_ShaderIterator
_hx_classes["hxsl._ShaderList.ShaderIterator"] = hxsl__ShaderList_ShaderIterator


class hxsl_ShaderInstance:
    _hx_class_name = "hxsl.ShaderInstance"
    _hx_is_interface = "False"
    __slots__ = ("id", "shader", "params")
    _hx_fields = ["id", "shader", "params"]

    def __init__(self,shader):
        self.id = hxsl_Tools.allocVarId()
        self.shader = shader
        self.params = haxe_ds_IntMap()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.shader = None
        _hx_o.params = None
hxsl_ShaderInstance._hx_class = hxsl_ShaderInstance
_hx_classes["hxsl.ShaderInstance"] = hxsl_ShaderInstance


class hxsl_ShaderGlobal:
    _hx_class_name = "hxsl.ShaderGlobal"
    _hx_is_interface = "False"
    __slots__ = ("v", "globalId")
    _hx_fields = ["v", "globalId"]

    def __init__(self,v,gid):
        self.v = v
        self.globalId = gid

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.v = None
        _hx_o.globalId = None
hxsl_ShaderGlobal._hx_class = hxsl_ShaderGlobal
_hx_classes["hxsl.ShaderGlobal"] = hxsl_ShaderGlobal


class hxsl_ShaderConst:
    _hx_class_name = "hxsl.ShaderConst"
    _hx_is_interface = "False"
    __slots__ = ("v", "pos", "bits", "globalId", "next")
    _hx_fields = ["v", "pos", "bits", "globalId", "next"]

    def __init__(self,v,pos,bits):
        self.next = None
        self.globalId = None
        self.v = v
        self.pos = pos
        self.bits = bits

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.v = None
        _hx_o.pos = None
        _hx_o.bits = None
        _hx_o.globalId = None
        _hx_o.next = None
hxsl_ShaderConst._hx_class = hxsl_ShaderConst
_hx_classes["hxsl.ShaderConst"] = hxsl_ShaderConst


class hxsl_SharedShader:
    _hx_class_name = "hxsl.SharedShader"
    _hx_is_interface = "False"
    __slots__ = ("data", "globals", "consts", "instanceCache", "paramsCount")
    _hx_fields = ["data", "globals", "consts", "instanceCache", "paramsCount"]
    _hx_methods = ["initialize", "getInstance", "makeInstance", "addSelfParam", "addParam", "browseVar"]
    _hx_statics = ["UNROLL_LOOPS"]

    def __init__(self,src):
        self.paramsCount = None
        self.instanceCache = haxe_ds_IntMap()
        self.consts = None
        self.globals = []
        if (src == ""):
            return
        self.data = hxsl_Serializer().unserialize(src)
        self.initialize()

    def initialize(self):
        _g = 0
        _g1 = self.data.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.browseVar(v)

    def getInstance(self,constBits):
        i = self.instanceCache.h.get(constBits,None)
        if (i is None):
            return self.makeInstance(constBits)
        else:
            return i

    def makeInstance(self,constBits):
        eval = hxsl_Eval()
        c = self.consts
        while (c is not None):
            c1 = c.v
            _g = c.v.type
            tmp = None
            tmp1 = _g.index
            if (tmp1 == 1):
                tmp = hxsl_Const.CInt((HxOverrides.rshift(constBits, c.pos) & ((((1 << c.bits)) - 1))))
            elif (tmp1 == 2):
                tmp = hxsl_Const.CBool((((HxOverrides.rshift(constBits, c.pos) & 1)) != 0))
            elif (tmp1 == 17):
                _g1 = _g.params[0]
                tmp = hxsl_Const.CInt((HxOverrides.rshift(constBits, c.pos) & ((((1 << c.bits)) - 1))))
            else:
                raise haxe_Exception.thrown("assert")
            eval.setConstant(c1,tmp)
            c = c.next
        eval.inlineCalls = True
        eval.unrollLoops = hxsl_SharedShader.UNROLL_LOOPS
        i = hxsl_ShaderInstance(eval.eval(self.data))
        self.paramsCount = 0
        _g = 0
        _g1 = self.data.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.addParam(eval,i,v)
        self.instanceCache.set(constBits,i)
        return i

    def addSelfParam(self,i,v):
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g = 0
            while (_g < len(vl)):
                v1 = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                self.addSelfParam(i,v1)
        elif (v.kind == hxsl_VarKind.Param):
            i.params.set(v.id,self.paramsCount)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.paramsCount
            _hx_local_1.paramsCount = (_hx_local_2 + 1)
            _hx_local_2

    def addParam(self,eval,i,v):
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g = 0
            while (_g < len(vl)):
                v1 = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                self.addParam(eval,i,v1)
        elif (v.kind == hxsl_VarKind.Param):
            i.params.set(eval.varMap.h.get(v,None).id,self.paramsCount)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.paramsCount
            _hx_local_1.paramsCount = (_hx_local_2 + 1)
            _hx_local_2

    def browseVar(self,v,path = None):
        v.id = hxsl_Tools.allocVarId()
        if (path is None):
            path = hxsl_Tools.getName(v)
        else:
            path = (("null" if path is None else path) + HxOverrides.stringOrNull((("." + HxOverrides.stringOrNull(v.name)))))
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g = 0
            while (_g < len(vl)):
                vs = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                self.browseVar(vs,path)
        else:
            globalId = 0
            if (v.kind == hxsl_VarKind.Global):
                globalId = hxsl_Globals.allocID(path)
                _this = self.globals
                x = hxsl_ShaderGlobal(v,globalId)
                _this.append(x)
            if (not hxsl_Tools.isConst(v)):
                return
            bits = hxsl_Tools.getConstBits(v)
            if (bits > 0):
                pos = (0 if ((self.consts is None)) else (self.consts.pos + self.consts.bits))
                c = hxsl_ShaderConst(v,pos,bits)
                c.globalId = globalId
                c.next = self.consts
                self.consts = c

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
        _hx_o.globals = None
        _hx_o.consts = None
        _hx_o.instanceCache = None
        _hx_o.paramsCount = None
hxsl_SharedShader._hx_class = hxsl_SharedShader
_hx_classes["hxsl.SharedShader"] = hxsl_SharedShader


class hxsl__Splitter_VarProps:
    _hx_class_name = "hxsl._Splitter.VarProps"
    _hx_is_interface = "False"
    __slots__ = ("v", "read", "write", "local", "requireInit")
    _hx_fields = ["v", "read", "write", "local", "requireInit"]

    def __init__(self,v):
        self.requireInit = None
        self.local = None
        self.v = v
        self.read = 0
        self.write = 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.v = None
        _hx_o.read = None
        _hx_o.write = None
        _hx_o.local = None
        _hx_o.requireInit = None
hxsl__Splitter_VarProps._hx_class = hxsl__Splitter_VarProps
_hx_classes["hxsl._Splitter.VarProps"] = hxsl__Splitter_VarProps


class hxsl_Splitter:
    _hx_class_name = "hxsl.Splitter"
    _hx_is_interface = "False"
    __slots__ = ("vars", "varNames", "varMap")
    _hx_fields = ["vars", "varNames", "varMap"]
    _hx_methods = ["split", "addExpr", "checkVar", "mapVars", "get", "uniqueName", "checkExpr"]

    def __init__(self):
        self.varMap = None
        self.varNames = None
        self.vars = None

    def split(self,s):
        vfun = None
        vvars = haxe_ds_IntMap()
        ffun = None
        fvars = haxe_ds_IntMap()
        self.varNames = haxe_ds_StringMap()
        self.varMap = haxe_ds_ObjectMap()
        _g = 0
        _g1 = s.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            tmp = f.kind.index
            if (tmp == 0):
                self.vars = vvars
                vfun = f
                self.checkExpr(f.expr)
            elif (tmp == 1):
                self.vars = fvars
                ffun = f
                self.checkExpr(f.expr)
            else:
                raise haxe_Exception.thrown("assert")
        vfun = _hx_AnonObject({'ret': vfun.ret, 'ref': vfun.ref, 'kind': vfun.kind, 'args': vfun.args, 'expr': self.mapVars(vfun.expr)})
        _g = 0
        _g1 = Lambda.array(vvars)
        while (_g < len(_g1)):
            inf = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            v = inf.v
            tmp = v.kind.index
            if ((tmp == 4) or ((tmp == 3))):
                v.kind = (hxsl_VarKind.Var if ((v.id in fvars.h)) else hxsl_VarKind.Local)
            else:
                pass
            tmp1 = v.kind.index
            if ((tmp1 == 5) or ((tmp1 == 3))):
                if ((inf.read > 0) or ((inf.write > 1))):
                    nv = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': v.name, 'kind': v.kind, 'type': v.type})
                    self.vars = vvars
                    ninf = self.get(nv)
                    v.kind = hxsl_VarKind.Local
                    p = vfun.expr.p
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,_hx_AnonObject({'e': hxsl_TExprDef.TVar(nv), 't': nv.type, 'p': p}),_hx_AnonObject({'e': hxsl_TExprDef.TVar(v), 't': v.type, 'p': p})), 't': nv.type, 'p': p})
                    self.addExpr(vfun,e)
                    self.checkExpr(e)
                    if (nv.kind == hxsl_VarKind.Var):
                        old = fvars.h.get(v.id,None)
                        self.varMap.set(v,nv)
                        fvars.remove(v.id)
                        np = hxsl__Splitter_VarProps(nv)
                        np.read = old.read
                        np.write = old.write
                        fvars.set(nv.id,np)
            else:
                pass
        finits = []
        todo = []
        inf = fvars.iterator()
        while inf.hasNext():
            inf1 = inf.next()
            v = inf1.v
            tmp = v.kind.index
            if (tmp == 1):
                nv = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': v.name, 'kind': hxsl_VarKind.Var, 'type': v.type})
                self.uniqueName(nv)
                i = vvars.h.get(v.id,None)
                if (i is None):
                    i = hxsl__Splitter_VarProps(v)
                    vvars.set(v.id,i)
                i.read = (i.read + 1)
                vp = hxsl__Splitter_VarProps(nv)
                vp.write = 1
                vvars.set(nv.id,vp)
                fp = hxsl__Splitter_VarProps(nv)
                fp.read = 1
                todo.append(fp)
                self.addExpr(vfun,_hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,_hx_AnonObject({'e': hxsl_TExprDef.TVar(nv), 't': v.type, 'p': vfun.expr.p}),_hx_AnonObject({'e': hxsl_TExprDef.TVar(v), 't': v.type, 'p': vfun.expr.p})), 't': v.type, 'p': vfun.expr.p}))
                self.varMap.set(v,nv)
                inf1.local = True
            elif (tmp == 3):
                if (inf1.write > 0):
                    nv1 = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': v.name, 'kind': hxsl_VarKind.Local, 'type': v.type})
                    self.uniqueName(nv1)
                    x = _hx_AnonObject({'e': hxsl_TExprDef.TVarDecl(nv1,_hx_AnonObject({'e': hxsl_TExprDef.TVar(v), 't': v.type, 'p': ffun.expr.p})), 't': hxsl_Type.TVoid, 'p': ffun.expr.p})
                    finits.append(x)
                    self.varMap.set(v,nv1)
            else:
                pass
        _g = 0
        while (_g < len(todo)):
            v = (todo[_g] if _g >= 0 and _g < len(todo) else None)
            _g = (_g + 1)
            fvars.set(v.v.id,v)
        v = vvars.iterator()
        while v.hasNext():
            v1 = v.next()
            self.checkVar(v1,True,vvars,vfun.expr.p)
        v = fvars.iterator()
        while v.hasNext():
            v1 = v.next()
            self.checkVar(v1,False,vvars,ffun.expr.p)
        v = self.varMap.keys()
        while v.hasNext():
            v1 = v.next()
            this1 = self.varMap
            key = self.varMap.h.get(v1,None)
            v2 = this1.h.get(key,None)
            if (v2 is not None):
                self.varMap.set(v1,v2)
        ffun = _hx_AnonObject({'ret': ffun.ret, 'ref': ffun.ref, 'kind': ffun.kind, 'args': ffun.args, 'expr': self.mapVars(ffun.expr)})
        _g = ffun.expr.e
        if (_g.index == 4):
            el = _g.params[0]
            _g = 0
            while (_g < len(finits)):
                e = (finits[_g] if _g >= 0 and _g < len(finits) else None)
                _g = (_g + 1)
                el.insert(0, e)
        else:
            x = ffun.expr
            finits.append(x)
            ffun.expr = _hx_AnonObject({'e': hxsl_TExprDef.TBlock(finits), 't': hxsl_Type.TVoid, 'p': ffun.expr.p})
        _g = []
        v = vvars.iterator()
        while v.hasNext():
            v1 = v.next()
            if (not v1.local):
                x = v1.v
                _g.append(x)
        vvars = _g
        _g = []
        v = fvars.iterator()
        while v.hasNext():
            v1 = v.next()
            if (not v1.local):
                x = v1.v
                _g.append(x)
        fvars = _g
        def _hx_local_5(v1,v2):
            return (v1.id - v2.id)
        vvars.sort(key= python_lib_Functools.cmp_to_key(_hx_local_5))
        def _hx_local_6(v1,v2):
            return (v1.id - v2.id)
        fvars.sort(key= python_lib_Functools.cmp_to_key(_hx_local_6))
        return _hx_AnonObject({'vertex': _hx_AnonObject({'name': "vertex", 'vars': vvars, 'funs': [vfun]}), 'fragment': _hx_AnonObject({'name': "fragment", 'vars': fvars, 'funs': [ffun]})})

    def addExpr(self,f,e):
        _g = f.expr.e
        if (_g.index == 4):
            el = _g.params[0]
            el.append(e)
        else:
            f.expr = _hx_AnonObject({'e': hxsl_TExprDef.TBlock([f.expr, e]), 't': hxsl_Type.TVoid, 'p': f.expr.p})

    def checkVar(self,v,vertex,vvars,p):
        tmp = v.v.kind.index
        if (tmp == 3):
            if (not vertex):
                i = vvars.h.get(v.v.id,None)
                if ((i is None) or ((i.write == 0))):
                    raise haxe_Exception.thrown(hxsl_Error((("Varying " + HxOverrides.stringOrNull(v.v.name)) + " is not written by vertex shader"),p))
        elif (tmp == 4):
            if v.requireInit:
                raise haxe_Exception.thrown(hxsl_Error((("Variable " + HxOverrides.stringOrNull(v.v.name)) + " is used without being initialized"),p))
        else:
            pass

    def mapVars(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 1):
            v = _g.params[0]
            v2 = self.varMap.h.get(v,None)
            if (v2 is None):
                return e
            else:
                return _hx_AnonObject({'e': hxsl_TExprDef.TVar(v2), 't': e.t, 'p': e.p})
        elif (tmp == 7):
            v = _g.params[0]
            init = _g.params[1]
            v2 = self.varMap.h.get(v,None)
            if (v2 is None):
                return hxsl_Tools.map(e,self.mapVars)
            else:
                return _hx_AnonObject({'e': hxsl_TExprDef.TVarDecl(v2,self.mapVars(init)), 't': e.t, 'p': e.p})
        elif (tmp == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            v2 = self.varMap.h.get(v,None)
            if (v2 is None):
                return hxsl_Tools.map(e,self.mapVars)
            else:
                return _hx_AnonObject({'e': hxsl_TExprDef.TFor(v2,self.mapVars(it),self.mapVars(loop)), 't': e.t, 'p': e.p})
        else:
            return hxsl_Tools.map(e,self.mapVars)

    def get(self,v):
        i = self.vars.h.get(v.id,None)
        if (i is None):
            v2 = self.varMap.h.get(v,None)
            if (v2 is not None):
                return self.get(v2)
            oldName = v.name
            self.uniqueName(v)
            if ((v.kind == hxsl_VarKind.Local) and ((oldName != v.name))):
                nv = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': v.name, 'kind': v.kind, 'type': v.type})
                self.varMap.set(v,nv)
                v.name = oldName
                v = nv
            i = hxsl__Splitter_VarProps(v)
            self.vars.set(v.id,i)
        return i

    def uniqueName(self,v):
        if (((v.kind == hxsl_VarKind.Global) or ((v.kind == hxsl_VarKind.Output))) or ((v.kind == hxsl_VarKind.Input))):
            return
        Reflect.setField(v,"parent",None)
        n = self.varNames.h.get(v.name,None)
        if ((n is not None) and ((n != v))):
            prefix = v.name
            while ((HxString.charCodeAt(prefix,(len(prefix) - 1)) >= 48) and ((HxString.charCodeAt(prefix,(len(prefix) - 1)) <= 57))):
                prefix = HxString.substr(prefix,0,-1)
            k = (2 if ((prefix == v.name)) else Std.parseInt(HxString.substr(v.name,len(prefix),None)))
            while ((("null" if prefix is None else prefix) + Std.string(k)) in self.varNames.h):
                k = (k + 1)
            v.name = (("null" if prefix is None else prefix) + Std.string(k))
        self.varNames.h[v.name] = v

    def checkExpr(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 1):
            v = _g.params[0]
            inf = self.get(v)
            if (inf.write == 0):
                inf.requireInit = True
            inf.read = (inf.read + 1)
        elif (tmp == 5):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g.params[2]
            tmp = _g1.index
            if (tmp == 4):
                _g4 = _g2.e
                _g5 = _g2.p
                _g5 = _g2.t
                tmp = _g4.index
                if (tmp == 1):
                    v = _g4.params[0]
                    e1 = _g3
                    inf = self.get(v)
                    inf.write = (inf.write + 1)
                    self.checkExpr(e1)
                elif (tmp == 9):
                    _g5 = _g4.params[0]
                    _g6 = _g4.params[1]
                    _g4 = _g5.e
                    _g6 = _g5.p
                    _g6 = _g5.t
                    if (_g4.index == 1):
                        v = _g4.params[0]
                        e1 = _g3
                        inf = self.get(v)
                        inf.write = (inf.write + 1)
                        self.checkExpr(e1)
                    else:
                        hxsl_Tools.iter(e,self.checkExpr)
                else:
                    hxsl_Tools.iter(e,self.checkExpr)
            elif (tmp == 20):
                _g4 = _g1.params[0]
                _g1 = _g2.e
                _g4 = _g2.p
                _g4 = _g2.t
                tmp = _g1.index
                if (tmp == 1):
                    v = _g1.params[0]
                    e1 = _g3
                    inf = self.get(v)
                    if (inf.write == 0):
                        inf.requireInit = True
                    inf.read = (inf.read + 1)
                    inf.write = (inf.write + 1)
                    self.checkExpr(e1)
                elif (tmp == 9):
                    _g2 = _g1.params[0]
                    _g4 = _g1.params[1]
                    _g1 = _g2.e
                    _g4 = _g2.p
                    _g4 = _g2.t
                    if (_g1.index == 1):
                        v = _g1.params[0]
                        e1 = _g3
                        inf = self.get(v)
                        if (inf.write == 0):
                            inf.requireInit = True
                        inf.read = (inf.read + 1)
                        inf.write = (inf.write + 1)
                        self.checkExpr(e1)
                    else:
                        hxsl_Tools.iter(e,self.checkExpr)
                else:
                    hxsl_Tools.iter(e,self.checkExpr)
            else:
                hxsl_Tools.iter(e,self.checkExpr)
        elif (tmp == 7):
            v = _g.params[0]
            init = _g.params[1]
            inf = self.get(v)
            inf.local = True
            if (init is not None):
                self.checkExpr(init)
                inf.write = (inf.write + 1)
        elif (tmp == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            self.checkExpr(it)
            inf = self.get(v)
            inf.local = True
            inf.write = (inf.write + 1)
            self.checkExpr(loop)
        else:
            hxsl_Tools.iter(e,self.checkExpr)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vars = None
        _hx_o.varNames = None
        _hx_o.varMap = None
hxsl_Splitter._hx_class = hxsl_Splitter
_hx_classes["hxsl.Splitter"] = hxsl_Splitter


class hxsl_ChannelTools:
    _hx_class_name = "hxsl.ChannelTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["isPackedFormat"]

    @staticmethod
    def isPackedFormat(c):
        return (c.format == h3d_mat_Texture.nativeFormat)
hxsl_ChannelTools._hx_class = hxsl_ChannelTools
_hx_classes["hxsl.ChannelTools"] = hxsl_ChannelTools


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        this1 = python_Lib.anonAsDict(d)
        return this1
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_
_hx_classes["python._KwArgs.KwArgs_Impl_"] = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "dictToAnon", "anonToDict", "anonAsDict"]

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def dictToAnon(v):
        return _hx_AnonObject(v.copy())

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None
python_Lib._hx_class = python_Lib
_hx_classes["python.Lib"] = python_Lib


class HxOverrides:
    _hx_class_name = "HxOverrides"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "split", "rshift", "modf", "mod", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return haxe_iterators_ArrayIterator(x)
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def split(x,delimiter):
        if isinstance(x,str):
            _this = x
            if (delimiter == ""):
                return list(_this)
            else:
                return _this.split(delimiter)
        return x.split(delimiter)

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1
HxOverrides._hx_class = HxOverrides
_hx_classes["HxOverrides"] = HxOverrides


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    _hx_is_interface = "False"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = ["close", "tell", "throwEof", "readinto", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise haxe_Exception.thrown("Write-only stream")

    def close(self):
        self.stream.close()

    def tell(self):
        return self.stream.tell()

    def throwEof(self):
        self.wasEof = True
        raise haxe_Exception.thrown(haxe_io_Eof())

    def readinto(self,b):
        raise haxe_Exception.thrown("abstract method, should be overridden")

    def readBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        ba = bytearray(_hx_len)
        ret = self.readinto(ba)
        if (ret == 0):
            self.throwEof()
        s.blit(pos,haxe_io_Bytes.ofData(ba),0,_hx_len)
        return ret

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None
        _hx_o.wasEof = None
python_io_NativeInput._hx_class = python_io_NativeInput
_hx_classes["python.io.NativeInput"] = python_io_NativeInput


class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    _hx_is_interface = "True"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "readByte", "readBytes", "close", "readFullBytes", "read", "readUntil", "readLine", "readFloat", "readDouble", "readInt16", "readUInt16", "readUInt24", "readInt32", "readString"]
python_io_IInput._hx_class = python_io_IInput
_hx_classes["python.io.IInput"] = python_io_IInput


class python_io_NativeBytesInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeBytesInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "seek", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    def seek(self,p,pos):
        self.wasEof = False
        python_io_IoTools.seekInBinaryMode(self.stream,p,pos)

    def readinto(self,b):
        return self.stream.readinto(b)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeBytesInput._hx_class = python_io_NativeBytesInput
_hx_classes["python.io.NativeBytesInput"] = python_io_NativeBytesInput


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["seek", "tell"]
    _hx_interfaces = [python_io_IInput]
python_io_IFileInput._hx_class = python_io_IFileInput
_hx_classes["python.io.IFileInput"] = python_io_IFileInput


class python_io_FileBytesInput(python_io_NativeBytesInput):
    _hx_class_name = "python.io.FileBytesInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeBytesInput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileBytesInput._hx_class = python_io_FileBytesInput
_hx_classes["python.io.FileBytesInput"] = python_io_FileBytesInput


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "seek", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.buffer.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    def seek(self,p,pos):
        self.wasEof = False
        python_io_IoTools.seekInTextMode(self.stream,self.tell,p,pos)

    def readinto(self,b):
        return self.stream.buffer.readinto(b)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeTextInput._hx_class = python_io_NativeTextInput
_hx_classes["python.io.NativeTextInput"] = python_io_NativeTextInput


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextInput._hx_class = python_io_FileTextInput
_hx_classes["python.io.FileTextInput"] = python_io_FileTextInput


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileInputFromBytes", "seekInTextMode", "seekInBinaryMode"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileInputFromBytes(t):
        return sys_io_FileInput(python_io_FileBytesInput(t))

    @staticmethod
    def seekInTextMode(stream,tell,p,pos):
        pos1 = None
        pos2 = pos.index
        if (pos2 == 0):
            pos1 = 0
        elif (pos2 == 1):
            p = (tell() + p)
            pos1 = 0
        elif (pos2 == 2):
            stream.seek(0,2)
            p = (tell() + p)
            pos1 = 0
        else:
            pass
        stream.seek(p,pos1)

    @staticmethod
    def seekInBinaryMode(stream,p,pos):
        pos1 = None
        pos2 = pos.index
        if (pos2 == 0):
            pos1 = 0
        elif (pos2 == 1):
            pos1 = 1
        elif (pos2 == 2):
            pos1 = 2
        else:
            pass
        stream.seek(p,pos1)
python_io_IoTools._hx_class = python_io_IoTools
_hx_classes["python.io.IoTools"] = python_io_IoTools


class screens_Screen(h2d_Scene):
    _hx_class_name = "screens.Screen"
    _hx_is_interface = "False"
    __slots__ = ("ASSET_SCALE",)
    _hx_fields = ["ASSET_SCALE"]
    _hx_methods = ["init", "update"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Scene


    def __init__(self):
        self.ASSET_SCALE = 0.375
        super().__init__()

    def init(self):
        pass

    def update(self,dt):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.ASSET_SCALE = None
screens_Screen._hx_class = screens_Screen
_hx_classes["screens.Screen"] = screens_Screen


class screens_Menu(screens_Screen):
    _hx_class_name = "screens.Menu"
    _hx_is_interface = "False"
    __slots__ = ("TITLE_SCALE", "time", "mov", "sy", "ey", "ty", "tf_start", "tf_exit", "tf_title")
    _hx_fields = ["TITLE_SCALE", "time", "mov", "sy", "ey", "ty", "tf_start", "tf_exit", "tf_title"]
    _hx_methods = ["init", "add_title", "update_menu", "menu_add", "update"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = screens_Screen


    def __init__(self):
        self.tf_title = None
        self.tf_exit = None
        self.tf_start = None
        self.time = None
        self.ty = 30
        self.ey = 640
        self.sy = 560
        self.mov = 1
        self.TITLE_SCALE = 3
        super().__init__()

    def init(self):
        haxe_Log.trace("Menu init()",_hx_AnonObject({'fileName': "src/screens/Menu.hx", 'lineNumber': 15, 'className': "screens.Menu", 'methodName': "init"}))
        bitmap = h2d_Bitmap(hxd_Res.get_loader().loadCache("background.png",hxd_res_Image).toTile(),self)
        v = self.ASSET_SCALE
        bitmap.posChanged = True
        bitmap.scaleX = (bitmap.scaleX * v)
        bitmap.posChanged = True
        bitmap.scaleY = (bitmap.scaleY * v)
        self.tf_title = h2d_Text(hxd_Res.get_loader().loadCache("GloriaHallelujah.fnt",hxd_res_BitmapFont).toFont(),self)
        _this = self.tf_title
        v = self.TITLE_SCALE
        _this.posChanged = True
        _this.scaleX = (_this.scaleX * v)
        _this.posChanged = True
        _this.scaleY = (_this.scaleY * v)
        self.add_title(self.tf_title,self.ty)
        self.tf_start = h2d_Text(hxd_Res.get_loader().loadCache("GloriaHallelujah.fnt",hxd_res_BitmapFont).toFont(),self)
        self.tf_exit = h2d_Text(hxd_Res.get_loader().loadCache("GloriaHallelujah.fnt",hxd_res_BitmapFont).toFont(),self)
        self.update_menu(self.sy,self.ey)

    def add_title(self,item,y):
        item.set_text("Colhe Cacau!")
        v = ((self.window.get_width() / 2) - (((item.get_textWidth() * self.TITLE_SCALE) / 2)))
        item.posChanged = True
        item.x = v
        item.posChanged = True
        item.y = y

    def update_menu(self,sy,ey):
        self.menu_add(self.tf_start,sy,"Press enter to start")
        self.menu_add(self.tf_exit,ey,"Press esc to exit")

    def menu_add(self,item,y,descricao):
        item.set_text(descricao)
        v = ((self.window.get_width() / 2) - ((item.get_textWidth() / 2)))
        item.posChanged = True
        item.x = v
        item.posChanged = True
        item.y = y

    def update(self,dt):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.time
        _hx_local_0.time = (_hx_local_1 + dt)
        _hx_local_0.time
        if (self.time >= 0.1):
            if ((self.mov < 4) or (((self.sy > 554) and ((self.ey < 644))))):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.sy
                _hx_local_2.sy = (_hx_local_3 - 1)
                _hx_local_2.sy
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.ty
                _hx_local_4.ty = (_hx_local_5 - 1)
                _hx_local_4.ty
            elif ((self.mov > 3) or (((self.sy > 564) and ((self.ey < 634))))):
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.sy
                _hx_local_6.sy = (_hx_local_7 + 1)
                _hx_local_6.sy
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.ty
                _hx_local_8.ty = (_hx_local_9 + 1)
                _hx_local_8.ty
            self.update_menu(self.sy,self.ey)
            if (self.mov < 7):
                _hx_local_10 = self
                _hx_local_11 = _hx_local_10.mov
                _hx_local_10.mov = (_hx_local_11 + 1)
                _hx_local_10.mov
            else:
                self.mov = 1
            self.time = 0
        if hxd_Key.isPressed(27):
            haxe_Log.trace("Menu update(): esc wasPressed",_hx_AnonObject({'fileName': "src/screens/Menu.hx", 'lineNumber': 73, 'className': "screens.Menu", 'methodName': "update"}))
            hxd_System.exit()
        if hxd_Key.isPressed(13):
            haxe_Log.trace("Menu update(): ender wasPressed",_hx_AnonObject({'fileName': "src/screens/Menu.hx", 'lineNumber': 78, 'className': "screens.Menu", 'methodName': "update"}))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.TITLE_SCALE = None
        _hx_o.time = None
        _hx_o.mov = None
        _hx_o.sy = None
        _hx_o.ey = None
        _hx_o.ty = None
        _hx_o.tf_start = None
        _hx_o.tf_exit = None
        _hx_o.tf_title = None
screens_Menu._hx_class = screens_Menu
_hx_classes["screens.Menu"] = screens_Menu


class sys_io_File:
    _hx_class_name = "sys.io.File"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getContent", "saveContent", "getBytes", "saveBytes", "read", "copy"]

    @staticmethod
    def getContent(path):
        f = python_lib_Builtins.open(path,"r",-1,"utf-8",None,"")
        content = f.read(-1)
        f.close()
        return content

    @staticmethod
    def saveContent(path,content):
        f = python_lib_Builtins.open(path,"w",-1,"utf-8",None,"")
        f.write(content)
        f.close()

    @staticmethod
    def getBytes(path):
        f = python_lib_Builtins.open(path,"rb",-1)
        size = f.read(-1)
        b = haxe_io_Bytes.ofData(size)
        f.close()
        return b

    @staticmethod
    def saveBytes(path,_hx_bytes):
        f = python_lib_Builtins.open(path,"wb",-1)
        f.write(_hx_bytes.b)
        f.close()

    @staticmethod
    def read(path,binary = None):
        if (binary is None):
            binary = True
        mode = ("rb" if binary else "r")
        f = python_lib_Builtins.open(path,mode,-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileInputFromBytes(f)
        else:
            return python_io_IoTools.createFileInputFromText(f)

    @staticmethod
    def copy(srcPath,dstPath):
        python_lib_Shutil.copy(srcPath,dstPath)
sys_io_File._hx_class = sys_io_File
_hx_classes["sys.io.File"] = sys_io_File


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    _hx_is_interface = "False"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "seek", "tell", "readByte", "readBytes", "close", "readFullBytes", "read", "readUntil", "readLine", "readFloat", "readDouble", "readInt16", "readUInt16", "readUInt24", "readInt32", "readString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def seek(self,p,pos):
        self.impl.seek(p,pos)

    def tell(self):
        return self.impl.tell()

    def readByte(self):
        return self.impl.readByte()

    def readBytes(self,s,pos,_hx_len):
        return self.impl.readBytes(s,pos,_hx_len)

    def close(self):
        self.impl.close()

    def readFullBytes(self,s,pos,_hx_len):
        self.impl.readFullBytes(s,pos,_hx_len)

    def read(self,nbytes):
        return self.impl.read(nbytes)

    def readUntil(self,end):
        return self.impl.readUntil(end)

    def readLine(self):
        return self.impl.readLine()

    def readFloat(self):
        return self.impl.readFloat()

    def readDouble(self):
        return self.impl.readDouble()

    def readInt16(self):
        return self.impl.readInt16()

    def readUInt16(self):
        return self.impl.readUInt16()

    def readUInt24(self):
        return self.impl.readUInt24()

    def readInt32(self):
        return self.impl.readInt32()

    def readString(self,_hx_len,encoding = None):
        return self.impl.readString(_hx_len)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None
sys_io_FileInput._hx_class = sys_io_FileInput
_hx_classes["sys.io.FileInput"] = sys_io_FileInput

class sys_io_FileSeek(Enum):
    __slots__ = ()
    _hx_class_name = "sys.io.FileSeek"
    _hx_constructs = ["SeekBegin", "SeekCur", "SeekEnd"]
sys_io_FileSeek.SeekBegin = sys_io_FileSeek("SeekBegin", 0, ())
sys_io_FileSeek.SeekCur = sys_io_FileSeek("SeekCur", 1, ())
sys_io_FileSeek.SeekEnd = sys_io_FileSeek("SeekEnd", 2, ())
sys_io_FileSeek._hx_class = sys_io_FileSeek
_hx_classes["sys.io.FileSeek"] = sys_io_FileSeek


class sys_thread__EventLoop_RegularEvent:
    _hx_class_name = "sys.thread._EventLoop.RegularEvent"
    _hx_is_interface = "False"
    __slots__ = ("nextRunTime", "interval", "run", "next", "previous")
    _hx_fields = ["nextRunTime", "interval", "run", "next", "previous"]

    def __init__(self,run,nextRunTime,interval):
        self.previous = None
        self.next = None
        self.run = run
        self.nextRunTime = nextRunTime
        self.interval = interval

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nextRunTime = None
        _hx_o.interval = None
        _hx_o.run = None
        _hx_o.next = None
        _hx_o.previous = None
sys_thread__EventLoop_RegularEvent._hx_class = sys_thread__EventLoop_RegularEvent
_hx_classes["sys.thread._EventLoop.RegularEvent"] = sys_thread__EventLoop_RegularEvent


class sys_thread_Lock:
    _hx_class_name = "sys.thread.Lock"
    _hx_is_interface = "False"
    __slots__ = ("semaphore",)
    _hx_fields = ["semaphore"]

    def __init__(self):
        self.semaphore = Lock(0)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.semaphore = None
sys_thread_Lock._hx_class = sys_thread_Lock
_hx_classes["sys.thread.Lock"] = sys_thread_Lock


class sys_thread_NoEventLoopException(haxe_Exception):
    _hx_class_name = "sys.thread.NoEventLoopException"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,msg = None,previous = None):
        if (msg is None):
            msg = "Event loop is not available. Refer to sys.thread.Thread.runWithEventLoop."
        super().__init__(msg,previous)
sys_thread_NoEventLoopException._hx_class = sys_thread_NoEventLoopException
_hx_classes["sys.thread.NoEventLoopException"] = sys_thread_NoEventLoopException


class sys_thread__Thread_Thread_Impl_:
    _hx_class_name = "sys.thread._Thread.Thread_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_events", "processEvents"]
    events = None

    @staticmethod
    def get_events(this1):
        if (this1.events is None):
            raise sys_thread_NoEventLoopException()
        return this1.events

    @staticmethod
    def processEvents():
        sys_thread__Thread_HxThread.current().events.loop()
sys_thread__Thread_Thread_Impl_._hx_class = sys_thread__Thread_Thread_Impl_
_hx_classes["sys.thread._Thread.Thread_Impl_"] = sys_thread__Thread_Thread_Impl_

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi
sys_thread__Thread_HxThread.threads = haxe_ds_ObjectMap()
sys_thread__Thread_HxThread.threadsMutex = sys_thread_Mutex()
sys_thread__Thread_HxThread.mainThread = sys_thread__Thread_HxThread(threading.current_thread())
sys_thread__Thread_HxThread.mainThread.events = sys_thread_EventLoop()

Sys._programPath = sys_FileSystem.fullPath(python_lib_Inspect.getsourcefile(Sys))
Xml.Element = 0
Xml.PCData = 1
Xml.CData = 2
Xml.Comment = 3
Xml.DocType = 4
Xml.ProcessingInstruction = 5
Xml.Document = 6
format_gif_Tools.LN2 = python_lib_Math.log(2)
format_mp3_MPEG.V1 = 3
format_mp3_MPEG.V2 = 2
format_mp3_MPEG.V25 = 0
format_mp3_MPEG.Reserved = 1
format_mp3_MPEG.V1_Bitrates = [[format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_40, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_192, format_mp3_Bitrate.BR_224, format_mp3_Bitrate.BR_256, format_mp3_Bitrate.BR_320, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_192, format_mp3_Bitrate.BR_224, format_mp3_Bitrate.BR_256, format_mp3_Bitrate.BR_320, format_mp3_Bitrate.BR_384, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_192, format_mp3_Bitrate.BR_224, format_mp3_Bitrate.BR_256, format_mp3_Bitrate.BR_288, format_mp3_Bitrate.BR_320, format_mp3_Bitrate.BR_352, format_mp3_Bitrate.BR_384, format_mp3_Bitrate.BR_416, format_mp3_Bitrate.BR_448, format_mp3_Bitrate.BR_Bad]]
format_mp3_MPEG.V2_Bitrates = [[format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_8, format_mp3_Bitrate.BR_16, format_mp3_Bitrate.BR_24, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_40, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_144, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_8, format_mp3_Bitrate.BR_16, format_mp3_Bitrate.BR_24, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_40, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_144, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_144, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_176, format_mp3_Bitrate.BR_192, format_mp3_Bitrate.BR_224, format_mp3_Bitrate.BR_256, format_mp3_Bitrate.BR_Bad]]
format_mp3_MPEG.SamplingRates = [[format_mp3_SamplingRate.SR_11025, format_mp3_SamplingRate.SR_12000, format_mp3_SamplingRate.SR_8000, format_mp3_SamplingRate.SR_Bad], [format_mp3_SamplingRate.SR_Bad, format_mp3_SamplingRate.SR_Bad, format_mp3_SamplingRate.SR_Bad, format_mp3_SamplingRate.SR_Bad], [format_mp3_SamplingRate.SR_22050, format_mp3_SamplingRate.SR_24000, format_mp3_SamplingRate.SR_12000, format_mp3_SamplingRate.SR_Bad], [format_mp3_SamplingRate.SR_44100, format_mp3_SamplingRate.SR_48000, format_mp3_SamplingRate.SR_32000, format_mp3_SamplingRate.SR_Bad]]
format_mp3_CLayer.LReserved = 0
format_mp3_CLayer.LLayer3 = 1
format_mp3_CLayer.LLayer2 = 2
format_mp3_CLayer.LLayer1 = 3
format_mp3_CChannelMode.CStereo = 0
format_mp3_CChannelMode.CJointStereo = 1
format_mp3_CChannelMode.CDualChannel = 2
format_mp3_CChannelMode.CMono = 3
format_mp3_CEmphasis.ENone = 0
format_mp3_CEmphasis.EMs50_15 = 1
format_mp3_CEmphasis.EReserved = 2
format_mp3_CEmphasis.ECCIT_J17 = 3
h2d_RenderContext.BUFFERING = False
h2d_col_Matrix.tmp = h2d_col_Matrix()
h3d_Buffer.GUID = 0
h3d_Engine.SOFTWARE_DRIVER = False
h3d_Engine.ANTIALIASING = 0
h3d_Engine.CURRENT = None
h3d_Matrix.tmp = h3d_Matrix()
h3d_Matrix.lumR = 0.212671
h3d_Matrix.lumG = 0.71516
h3d_Matrix.lumB = 0.072169
h3d_Matrix.SQ13 = 0.57735026918962576450914878050196
h3d_anim_Animation.EPSILON = 0.000001
h3d_col_ObjectCollider.TMP_RAY = h3d_col_Ray()
h3d_col_ObjectCollider.TMP_MAT = h3d_Matrix()
h3d_impl_InputNames.UID = 0
h3d_impl_InputNames.CACHE = haxe_ds_StringMap()
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
h3d_impl_MemoryManager.MAX_MEMORY = 4294967296.
h3d_impl_MemoryManager.MAX_BUFFERS = 65536
h3d_impl_MemoryManager.SIZE = 65533
h3d_impl_MemoryManager.ALL_FLAGS = Type.allEnums(h3d_BufferFlag)
h3d_mat_Defaults.defaultKillAlphaThreshold = 0.5
h3d_mat_Defaults.loadingTextureColor = -65281
h3d_mat_MaterialSetup.current = h3d_mat_MaterialSetup("Default")
h3d_mat_Pass.enableLights_bits = 1
h3d_mat_Pass.enableLights_offset = 0
h3d_mat_Pass.enableLights_mask = 1
h3d_mat_Pass.dynamicParameters_bits = 1
h3d_mat_Pass.dynamicParameters_offset = 1
h3d_mat_Pass.dynamicParameters_mask = 2
h3d_mat_Pass.isStatic_bits = 1
h3d_mat_Pass.isStatic_offset = 2
h3d_mat_Pass.isStatic_mask = 4
h3d_mat_Pass.batchMode_bits = 1
h3d_mat_Pass.batchMode_offset = 3
h3d_mat_Pass.batchMode_mask = 8
h3d_mat_Pass.culling_bits = 2
h3d_mat_Pass.culling_offset = 0
h3d_mat_Pass.culling_mask = 3
h3d_mat_Pass.depthWrite_bits = 1
h3d_mat_Pass.depthWrite_offset = 2
h3d_mat_Pass.depthWrite_mask = 4
h3d_mat_Pass.depthTest_bits = 3
h3d_mat_Pass.depthTest_offset = 3
h3d_mat_Pass.depthTest_mask = 56
h3d_mat_Pass.blendSrc_bits = 4
h3d_mat_Pass.blendSrc_offset = 6
h3d_mat_Pass.blendSrc_mask = 960
h3d_mat_Pass.blendDst_bits = 4
h3d_mat_Pass.blendDst_offset = 10
h3d_mat_Pass.blendDst_mask = 15360
h3d_mat_Pass.blendAlphaSrc_bits = 4
h3d_mat_Pass.blendAlphaSrc_offset = 14
h3d_mat_Pass.blendAlphaSrc_mask = 245760
h3d_mat_Pass.blendAlphaDst_bits = 4
h3d_mat_Pass.blendAlphaDst_offset = 18
h3d_mat_Pass.blendAlphaDst_mask = 3932160
h3d_mat_Pass.blendOp_bits = 3
h3d_mat_Pass.blendOp_offset = 22
h3d_mat_Pass.blendOp_mask = 29360128
h3d_mat_Pass.blendAlphaOp_bits = 3
h3d_mat_Pass.blendAlphaOp_offset = 25
h3d_mat_Pass.blendAlphaOp_mask = 234881024
h3d_mat_Pass.wireframe_bits = 1
h3d_mat_Pass.wireframe_offset = 28
h3d_mat_Pass.wireframe_mask = 268435456
h3d_mat_Pass.reserved_bits = 1
h3d_mat_Pass.reserved_offset = 29
h3d_mat_Pass.reserved_mask = 536870912
h3d_mat_Stencil.readMask_bits = 8
h3d_mat_Stencil.readMask_offset = 0
h3d_mat_Stencil.readMask_mask = 255
h3d_mat_Stencil.writeMask_bits = 8
h3d_mat_Stencil.writeMask_offset = 8
h3d_mat_Stencil.writeMask_mask = 65280
h3d_mat_Stencil.reference_bits = 8
h3d_mat_Stencil.reference_offset = 16
h3d_mat_Stencil.reference_mask = 16711680
h3d_mat_Stencil.frontTest_bits = 3
h3d_mat_Stencil.frontTest_offset = 0
h3d_mat_Stencil.frontTest_mask = 7
h3d_mat_Stencil.frontPass_bits = 3
h3d_mat_Stencil.frontPass_offset = 3
h3d_mat_Stencil.frontPass_mask = 56
h3d_mat_Stencil.frontSTfail_bits = 3
h3d_mat_Stencil.frontSTfail_offset = 6
h3d_mat_Stencil.frontSTfail_mask = 448
h3d_mat_Stencil.frontDPfail_bits = 3
h3d_mat_Stencil.frontDPfail_offset = 9
h3d_mat_Stencil.frontDPfail_mask = 3584
h3d_mat_Stencil.backTest_bits = 3
h3d_mat_Stencil.backTest_offset = 12
h3d_mat_Stencil.backTest_mask = 28672
h3d_mat_Stencil.backPass_bits = 3
h3d_mat_Stencil.backPass_offset = 15
h3d_mat_Stencil.backPass_mask = 229376
h3d_mat_Stencil.backSTfail_bits = 3
h3d_mat_Stencil.backSTfail_offset = 18
h3d_mat_Stencil.backSTfail_mask = 1835008
h3d_mat_Stencil.backDPfail_bits = 3
h3d_mat_Stencil.backDPfail_offset = 21
h3d_mat_Stencil.backDPfail_mask = 14680064
h3d_mat_Texture.UID = 0
h3d_mat_Texture.PREVENT_AUTO_DISPOSE = 2147483647
h3d_mat_Texture.nativeFormat = hxd_PixelFormat.RGBA
h3d_mat_Texture.checkerTextureKeys = haxe_ds_IntMap()
h3d_mat_Texture.noiseTextureKeys = haxe_ds_IntMap()
h3d_mat_Texture.genTextureKeys = haxe_ds_StringMap()
h3d_pass_Blur.__meta__ = _hx_AnonObject({'obj': _hx_AnonObject({'ignore': ["shader"]})})
h3d_shader_ScreenShader.SRC = "HXSLF2gzZC5zaGFkZXIuU2NyZWVuU2hhZGVyBwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACghfX2luaXRfXw4GAAALBnZlcnRleA4GAAACAgoAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAALAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAA"
h3d_pass__Border_BorderShader.SRC = "HXSLHWgzZC5wYXNzLl9Cb3JkZXIuQm9yZGVyU2hhZGVyCQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgVjb2xvcgUMAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMAgoFDAUMAA"
h3d_pass__Copy_ArrayCopyShader.SRC = "HXSLHmgzZC5wYXNzLl9Db3B5LkFycmF5Q29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQsCAAALBWxheWVyAQIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFAQYEAggFDAkDIQ4CAgoLCQMpDgICCQUKCQMmDgECCwEDBQsFDAUMAA"
h3d_pass__Copy_CopyShader.SRC = "HXSLGWgzZC5wYXNzLl9Db3B5LkNvcHlTaGFkZXIJAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKB3RleHR1cmUKAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMCQMhDgICCgoCCQUKBQwFDAA"
h3d_pass__CubeCopy_CubeCopyShader.SRC = "HXSLIWgzZC5wYXNzLl9DdWJlQ29weS5DdWJlQ29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQwCAAALA21hdAYCAAAMCF9faW5pdF9fDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwIMAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADQAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDgAABQIIDwJ1dgUKBAAABgMGAQIJBQoBAwAAAAAAAABAAwUKAQMAAAAAAADwPwMFCgAGBAIIBQwJAyEOAgIKDAkDHw4BBgEJAykOAgIPBQoBAwAAAAAAAPA/AwULAgsGBQsFCwUMBQwA"
h3d_pass_Default.__meta__ = _hx_AnonObject({'fields': _hx_AnonObject({'cameraView': _hx_AnonObject({'_hx_global': ["camera.view"]}), 'cameraNear': _hx_AnonObject({'_hx_global': ["camera.zNear"]}), 'cameraFar': _hx_AnonObject({'_hx_global': ["camera.zFar"]}), 'cameraProj': _hx_AnonObject({'_hx_global': ["camera.proj"]}), 'cameraPos': _hx_AnonObject({'_hx_global': ["camera.position"]}), 'cameraProjDiag': _hx_AnonObject({'_hx_global': ["camera.projDiag"]}), 'cameraProjFlip': _hx_AnonObject({'_hx_global': ["camera.projFlip"]}), 'cameraViewProj': _hx_AnonObject({'_hx_global': ["camera.viewProj"]}), 'cameraInverseViewProj': _hx_AnonObject({'_hx_global': ["camera.inverseViewProj"]}), 'globalTime': _hx_AnonObject({'_hx_global': ["global.time"]}), 'pixelSize': _hx_AnonObject({'_hx_global': ["global.pixelSize"]}), 'globalModelView': _hx_AnonObject({'_hx_global': ["global.modelView"]}), 'globalModelViewInverse': _hx_AnonObject({'_hx_global': ["global.modelViewInverse"]})})})
h3d_pass__HardwarePick_FixedColor.SRC = "HXSLIWgzZC5wYXNzLl9IYXJkd2FyZVBpY2suRml4ZWRDb2xvcgUBB2NvbG9ySUQFDAIAAAIIdmlld3BvcnQFDAIAAAMGb3V0cHV0DQECBAhwb3NpdGlvbgUMBAMABQdjb2xvcklEBQwEAwAEAAAGBnZlcnRleA4GAAAHCGZyYWdtZW50DgYAAAIABgAABQEGBAIEBQwGAQQGAAIEBQwGAQkDKg4DCgICBQwRAAUKAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMCgIEBQwMAAMFDAUMBQwJAyoOAwoCAgUMOQAFCgEDAAAAAAAA8D8DAQMAAAAAAADwPwMFDAUMBQwAAQcAAAUBBgQCBQUMAgEFDAUMAA"
h3d_pass_ShaderManager.STRICT = True
h3d_scene_Object.ROT2RAD = -0.017453292519943295769236907684886
h3d_scene_Object.tmpMat = h3d_Matrix()
h3d_scene_Object.tmpVec = h3d_Vector()
h3d_scene__Object_ObjectFlags_Impl_.FPosChanged = 1
h3d_scene__Object_ObjectFlags_Impl_.FVisible = 2
h3d_scene__Object_ObjectFlags_Impl_.FCulled = 4
h3d_scene__Object_ObjectFlags_Impl_.FFollowPositionOnly = 8
h3d_scene__Object_ObjectFlags_Impl_.FLightCameraCenter = 16
h3d_scene__Object_ObjectFlags_Impl_.FAllocated = 32
h3d_scene__Object_ObjectFlags_Impl_.FAlwaysSync = 64
h3d_scene__Object_ObjectFlags_Impl_.FInheritCulled = 128
h3d_scene__Object_ObjectFlags_Impl_.FNoSerialize = 256
h3d_scene__Object_ObjectFlags_Impl_.FIgnoreBounds = 512
h3d_scene__Object_ObjectFlags_Impl_.FIgnoreCollide = 1024
h3d_scene__Object_ObjectFlags_Impl_.FIgnoreParentTransform = 2048
h3d_scene__Object_ObjectFlags_Impl_.FCullingColliderInherited = 4096
h3d_scene_Skin.TMP_MAT = h3d_Matrix()
h3d_shader_AmbientLight.SRC = "HXSLF2gzZC5zaGFkZXIuQW1iaWVudExpZ2h0CgEGZ2xvYmFsDQECAgxhbWJpZW50TGlnaHQFCwABAAMQcGVyUGl4ZWxMaWdodGluZwIAAQEAAAAAAAAAAAQKcGl4ZWxDb2xvcgUMBAAABQ9saWdodFBpeGVsQ29sb3IFCwQAAAYKbGlnaHRDb2xvcgULBAAABwhhZGRpdGl2ZQICAAEAAAAAAAgIX19pbml0X18OBgAACRBfX2luaXRfX2ZyYWdtZW50DgYAAAoJY2FsY0xpZ2h0DgYAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAABQIIAAAFAQYEAgYFCwsCBwICAgULCQMpDgEBAwAAAAAAAAAAAwULBQsFCwACCQAABQEGBAIFBQsLAgcCAgIFCwkDKQ4BAQMAAAAAAAAAAAMFCwULBQsAAwoBDQpsaWdodENvbG9yBQsEAAAFCwUBDQsCBwICDQULBAYAAgIFCwYBCQMWDgIEBgMBAwAAAAAAAPA/AwICBQsFCwULAQMAAAAAAAAAAAMFCwINBQsFCwULBQsFCwAAAAsAAAUBCwcCAgMCAgaBCgIEBQySAAULCQIKDgECBgULBQsFCwAAAAEMAAAFAQsCAwIGgQoCBAUMkgAFCwkCCg4BAgUFCwULBQsAAAA"
h3d_shader_Base2d.SRC = "HXSLEWgzZC5zaGFkZXIuQmFzZTJkGwEFaW5wdXQNAQMCCHBvc2l0aW9uBQoBAQADAnV2BQoBAQAEBWNvbG9yBQwBAQABAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgEdGltZQMAAAAJBnpWYWx1ZQMCAAAKB3RleHR1cmUKAgAACw5zcHJpdGVQb3NpdGlvbgUMBAAADBBhYnNvbHV0ZVBvc2l0aW9uBQwEAAANCnBpeGVsQ29sb3IFDAQAAA4MdGV4dHVyZUNvbG9yBQwEAAAPDGNhbGN1bGF0ZWRVVgUKAwAAEAppc1JlbGF0aXZlAgIAAQAAAAAAEQVjb2xvcgUMAgAAEg9hYnNvbHV0ZU1hdHJpeEEFCwIAABMPYWJzb2x1dGVNYXRyaXhCBQsCAAAUDWZpbHRlck1hdHJpeEEFCwIAABUNZmlsdGVyTWF0cml4QgULAgAAFghoYXNVVlBvcwICAAEAAAAAABcFdXZQb3MFDAIAABgJa2lsbEFscGhhAgIAAQAAAAAAGQpwaXhlbEFsaWduAgIAAQAAAAAAGhBoYWxmUGl4ZWxJbnZlcnNlBQoCAAAbCXZpZXdwb3J0QQULAgAAHAl2aWV3cG9ydEIFCwIAAB0Ob3V0cHV0UG9zaXRpb24FDAQAAB4IX19pbml0X18OBgAAHwZ2ZXJ0ZXgOBgAAIAhmcmFnbWVudA4GAAADAh4AAAUGBgQCCwUMCQMqDgMCAgUKAgkDAQMAAAAAAADwPwMFDAUMCwIQAgUDBgQKAgwFDAAAAwkDHQ4CCQMpDgIKAgsFDBEABQoBAwAAAAAAAPA/AwULAhIFCwMDBgQKAgwFDAQAAwkDHQ4CCQMpDgIKAgsFDBEABQoBAwAAAAAAAPA/AwULAhMFCwMDBgQKAgwFDDkABQoKAgsFDDkABQoFCgAGBAIMBQwCCwUMBQwABgQCDwUKCwIWAgYABgECAwUKCgIXBQw5AAUKBQoKAhcFDBEABQoFCgIDBQoFCgUKBgQCDQUMCwIQAgYBAhEFDAIEBQwFDAIEBQwFDAUMBgQCDgUMCQMhDgICCgoCDwUKBQwFDAaBAg0FDAIOBQwFDAAAHwAABQUIIQN0bXAFCwQAAAkDKQ4CCgIMBQwRAAUKAQMAAAAAAADwPwMFCwAGBAIhBQsJAykOAwkDHQ4CAiEFCwIUBQsDCQMdDgICIQULAhUFCwMBAwAAAAAAAPA/AwULBQsGBAIdBQwJAyoOAwkDHQ4CAiEFCwIbBQsDCQMdDgICIQULAhwFCwMKAgwFDDkABQoFDAUMCwIZAgaDCgIdBQwRAAUKAhoFCgUKAAAGBAIGBQwCHQUMBQwAASAAAAUCCwYOAhgCBgkKAg0FDAwAAwED/Knx0k1iUD8DAgIMAAAABgQCBwUMAg0FDAUMAA"
h3d_shader_BaseMesh.SRC = "HXSLE2gzZC5zaGFkZXIuQmFzZU1lc2gXAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQVjb2xvcgUMAgAAJg1zcGVjdWxhclBvd2VyAwIAAQcAAAAAAAAAAAAAAAAAAFlAJw5zcGVjdWxhckFtb3VudAMCAAEHAAAAAAAAAAAAAAAAAAAkQCgNc3BlY3VsYXJDb2xvcgULAgAAKQhfX2luaXRfXw4GAAAqEF9faW5pdF9fZnJhZ21lbnQOBgAAKwZ2ZXJ0ZXgOBgAALAhmcmFnbWVudA4GAAAEAikAAAULBgQCGgULAhIFCwULBgQCGwULBgECGgULCQM0DgECDwcIBQsFCwYEAh4FDAYBCQMqDgICGwULAQMAAAAAAADwPwMFDAIHBwUMBQwGBAIdBQsJAx8OAQQGAQITBQsJAzIOAQIPBwYFCwULBQsFCwYEAgsFCwkDHw4BBAYDAgQFCwIbBQsFCwULBQsFCwYEAh8FDAIlBQwFDAYEAiIDAiYDAwYEAiMFCwYBAigFCwInAwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCJAMGAgkDGw4BBgMCGwULAgQFCwULAwIKAwMDAAIqAAAFBQYEAh0FCwkDHw4BAh0FCwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCIgMCJgMDBgQCIwULBgECKAULAicDBQsFCwAAKwAABQIGBAIVBQwGAQIeBQwJAyoOBAEDAAAAAAAA8D8DAgUDAQMAAAAAAADwPwMBAwAAAAAAAPA/AwUMBQwFDAYEAhwFCwIbBQsFCwABLAAABQQGBAIWBQwCHwUMBQwGBAIXAwIgAwMGBAIYBQsCHQULBQsGBAIZAwIkAwMA"
h3d_shader_Blur.SRC = "HXSLD2gzZC5zaGFkZXIuQmx1choBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoVY2FtZXJhSW52ZXJzZVZpZXdQcm9qBwIAAAsHdGV4dHVyZQoCAAAMDGRlcHRoVGV4dHVyZQoCAAANB1F1YWxpdHkBAgABAAAAAAAOB2lzRGVwdGgCAgABAAAAAAAPBnZhbHVlcw8DDQIAABAHb2Zmc2V0cw8DDQIAABEFcGl4ZWwFCgIAABINaGFzRml4ZWRDb2xvcgICAAEAAAAAABMQc21vb3RoRml4ZWRDb2xvcgICAAEAAAAAABQKZml4ZWRDb2xvcgUMAgAAFRBpc0RlcHRoRGVwZW5kYW50AgIAAQAAAAAAFgloYXNOb3JtYWwCAgABAAAAAAAXDW5vcm1hbFRleHR1cmUKAgAAGAZpc0N1YmUCAgABAAAAAAAZC2N1YmVUZXh0dXJlDAIAABoHY3ViZURpcgYCAAAbCF9faW5pdF9fDgYAABwGdmVydGV4DgYAAB0IZnJhZ21lbnQOBgAAHgtnZXRQb3NpdGlvbg4GAAAEAhsAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAcAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEdAAAFAgsCFQIFBggfBHBjdXIFCwQAAAkCHg4BAgMFCgULAAggBGNjdXIFDAQAAAkDIQ4CAgsKAgMFCgUMAAghBWNvbG9yBQwEAAAJAyoOBAEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwEDAAAAAAAAAAADBQwACCIEbmN1cgULBAAACQM5DgEJAyEOAgIXCgIDBQoFDAULABUGdW5yb2xsAA4jAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUICCQCdXYFCgQAAAYAAgMFCgYBAhEFChECEA8DDQsGCQIjAQECAAAAAAECBwMCIwEBAiMBAQMFCgUKAAglAWMFDAQAAAkDIQ4CAgsKAiQFCgUMAAgmAXAFCwQAAAkCHg4BAiQFCgULAAgnAWQDBAAACQMdDgIEBgMCJgULAh8FCwULBQsGAwImBQsCHwULBQsDAAgoAW4FCwQAAAkDOQ4BCQMhDgICFwoCJAUKBQwFCwAGBAIlBQwJAxgOAwIgBQwCJQUMCQMdDgICIgULAigFCwMFDAUMBgQCJQUMCQMYDgMCJQUMAiAFDAkDFQ4CBAYBCQMWDgIEBgMCJwMBA/yp8dJNYlA/AwMDAQMAAAAAAAAAAAMDAQMAAAAAAGr4QAMDAwEDAAAAAAAA8D8DAwUMBQwGgAIhBQwGAQIlBQwRAg8PAw0LBgkCIwEBAgAAAAABAgcDAiMBAQIjAQEDBQwFDAAAAAYEAggFDAIhBQwFDAALAg4CBQMIKQN2YWwDBAAAAQMAAAAAAAAAAAMAFQZ1bnJvbGwADioBaQEEAAAGFQYABwMCDQEBAQIBAAAAAQECDQEPAQAABQELAhgCBoACKQMGAQkDNw4BCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwDEQIPDwMNCwYJAioBAQIAAAAAAQIHAwIqAQECKgEBAwMDBoACKQMGAQkDNw4BCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFDAMRAg8PAw0LBgkCKgEBAgAAAAABAgcDAioBAQIqAQEDAwMAAAAABgQCCAUMCQM2DgEJAxUOAgIpAwEDyxpQyv//7z8DAwUMBQwABQMIKwVjb2xvcgUMBAAACQMqDgQBAwAAAAAAAAAAAwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMABUGdW5yb2xsAA4sAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUBCwIYAgaAAisFDAYBCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwRAg8PAw0LBgkCLAEBAgAAAAABAgcDAiwBAQIsAQEDBQwFDAaAAisFDAYBCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFDBECDw8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFDAUMAAAAAAYEAggFDAIrBQwFDAAAAAsCEgIFAgsCEwIGgQoCCAUMDAADCgIUBQwMAAMDBgQKAggFDAwAAwYBCgIUBQwMAAMJAyYOAQYHCgIIBQwMAAMBAwAAAAAAAAAAAwIDAwMABgQKAggFDJIABQsGAQoCFAUMkgAFCwoCCAUMDAADBQsFCwAAAAADHgEtAnV2BQoEAAAFCwUECC4FZGVwdGgDBAAACQM3DgEJAyEOAgIMCgItBQoFDAMACC8EdGVtcAUMBAAABgEJAyoOAwkDOw4BAi0FCgUKAi4DAQMAAAAAAADwPwMFDAIKBwUMAAgwCG9yaWdpbldTBQsEAAAGAgoCLwUMkgAFCwoCLwUMDAADBQsADQIwBQsAAA"
h3d_shader_ColorAdd.SRC = "HXSLE2gzZC5zaGFkZXIuQ29sb3JBZGQDAQpwaXhlbENvbG9yBQwEAAACBWNvbG9yBQsCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGgAoCAQUMkgAFCwICBQsFCwA"
h3d_shader_ColorKey.SRC = "HXSLE2gzZC5zaGFkZXIuQ29sb3JLZXkDAQhjb2xvcktleQUMAgAAAgx0ZXh0dXJlQ29sb3IFDAQAAAMIZnJhZ21lbnQOBgAAAQEDAAAFAggEBWNkaWZmBQwEAAAGAwICBQwCAQUMBQwACwYJCQMdDgICBAUMAgQFDAMBA/Fo44i1+OQ+AwIMAAAAAA"
h3d_shader_ColorMatrix.SRC = "HXSLFmgzZC5zaGFkZXIuQ29sb3JNYXRyaXgDAQpwaXhlbENvbG9yBQwEAAACBm1hdHJpeAcCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGBAIBBQwJAyoOAgoEBgEJAyoOAgoCAQUMkgAFCwEDAAAAAAAA8D8DBQwCAgcFDAUMkgAFCwoEBgECAQUMAgIHBQwFDAwAAwUMBQwA"
h3d_shader_DirShadow.SRC = "HXSLFGgzZC5zaGFkZXIuRGlyU2hhZG93EgEGZW5hYmxlAgIAAQAAAAAAAgdVU0VfRVNNAgIAAQAAAAAAAwtzaGFkb3dQb3dlcgMCAAAEB1VTRV9QQ0YCAgABAAAAAAAFCnBjZlF1YWxpdHkBAgABAAAAAAAGCHBjZlNjYWxlAwIAAAcJc2hhZG93UmVzBQoCAAAICXNoYWRvd01hcBEBAgAACQpzaGFkb3dQcm9qCAIAAAoKc2hhZG93QmlhcwMCAAALE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAwGc2hhZG93AwQAAA0JZGlyU2hhZG93AwQAAA4OcG9pc3NvbkRpc2tMb3cPBQwABAIAAA8PcG9pc3NvbkRpc2tIaWdoDwUMAAwCAAAQE3BvaXNzb25EaXNrVmVyeUhpZ2gPBQwAQAIAABEEcmFuZA4GAAASCGZyYWdtZW50DgYAAAIDEQETAXYDBAAAAwUCCBQCZHADBAAACQMdDgIJAyoOAQITAwUMCQMqDgQBA18pyxDH+ilAAwED9P3UeOmOU0ADAQOiRbbz/ZRGQAMBA1CNl24Sq1dAAwUMAwANCQMTDgEGAQkDAg4BAhQDAwEDUPwYc9Fd5UADAwMAAAESAAAFAgsCAQIFAQsCBAIFBwYEAgwDAQMAAAAAAADwPwMDCBUJdGV4ZWxTaXplBQoEAAAGAgEDAAAAAAAA8D8DAgcFCgUKAAgWCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACBcIc2hhZG93VXYFCgQAAAkDOg4BCgIWBQsRAAUKBQoACBgEek1heAMEAAAJAzUOAQoCFgULCAADAwAIGQNyb3QDBAAABgEGAQkCEQ4BBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwEDH4XrUbgeCUADAwEDAAAAAAAAAEADAwATBAIFAQEDAQECAQAAAAEFAggaDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAABBAAwMADhsBaQEEAAAGFQECAAAAAAEBAgQAAAABDwEAAAUECBwGb2Zmc2V0BQoEAAAGAQYBChECDg8FDAAEAhsBBQwRAAUKAhUFCgUKAgYDBQoABgQCHAUKCQMoDgIGAwYBCQMDDgECGQMDCgIcBQoAAAMDBgEJAwIOAQIZAwMKAhwFCgQAAwMDBgAGAQkDAw4BAhkDAwoCHAUKBAADAwYBCQMCDgECGQMDCgIcBQoAAAMDAwUKBQoIHQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCHAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAh0DAgaDAgwDAhoDAwAAAAAAAQECAgAAAAEFAggeDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAChAAwMADh8BaQEEAAAGFQECAAAAAAEBAgwAAAABDwEAAAUECCAGb2Zmc2V0BQoEAAAGAQYBChECDw8FDAAMAh8BBQwRAAUKAhUFCgUKAgYDBQoABgQCIAUKCQMoDgIGAwYBCQMDDgECGQMDCgIgBQoAAAMDBgEJAwIOAQIZAwMKAiAFCgQAAwMDBgAGAQkDAw4BAhkDAwoCIAUKBAADAwYBCQMCDgECGQMDCgIgBQoAAAMDAwUKBQoIIQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCIAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiEDAgaDAgwDAh4DAwAAAAAAAQECAwAAAAEFAggiDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAFBAAwMADiMBaQEEAAAGFQECAAAAAAEBAkAAAAABDwEAAAUECCQGb2Zmc2V0BQoEAAAGAQYBChECEA8FDABAAiMBBQwRAAUKAhUFCgUKAgYDBQoABgQCJAUKCQMoDgIGAwYBCQMDDgECGQMDCgIkBQoAAAMDBgEJAwIOAQIZAwMKAiQFCgQAAwMDBgAGAQkDAw4BAhkDAwoCJAUKBAADAwYBCQMCDgECGQMDCgIkBQoAAAMDAwUKBQoIJQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCJAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiUDAgaDAgwDAiIDAwAAAAAAAAAACwICAgUFCCYJc2hhZG93UG9zBQsEAAAGAQILBQsCCQgFCwAIJwVkZXB0aAMEAAAJAz8OAgIIEQEJAzoOAQoCJgULEQAFCgUKAwAIKAR6TWF4AwQAAAkDNQ4BCgImBQsIAAMDAAgpBWRlbHRhAwQAAAYDCQMVDgIEBgACJwMCCgMDAwIoAwMCKAMDAAYEAgwDCQM1DgEJAwkOAQYBAgMDAikDAwMDAwAFBAgqCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACCsIc2hhZG93VXYFCgQAAAkDOg4BCgIqBQsRAAUKBQoACCwFZGVwdGgDBAAACQM/DgICCBEBCgIrBQoRAAUKAwAGBAIMAwsGBwYDCgIqBQsIAAMCCgMDAiwDAgEDAAAAAAAAAAADAQMAAAAAAADwPwMDAwAAAAAAAAYEAg0DAgwDAwA"
h3d_shader_GenTexture.SRC = "HXSLFWgzZC5zaGFkZXIuR2VuVGV4dHVyZQoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEbW9kZQECAAEAAAAAAAsFY29sb3IFDAIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFARMEAgoBAQEBAQIAAAAAAQUBBgQCCAUMCwYHCQMbDgEKAgYFDBEABQoDAQMAAAAAAADwPwMCCQMqDgEBAwAAAAAAAAAAAwUMAgsFDAUMBQwAAAAA"
h3d_shader_LineShader.SRC = "HXSLFWgzZC5zaGFkZXIuTGluZVNoYWRlcgwBBmNhbWVyYQ0BAwIEdmlldwcAAQADBHByb2oHAAEABAh2aWV3UHJvagcAAQAAAAAFBmdsb2JhbA0CAgYJcGl4ZWxTaXplBQoABQAHCW1vZGVsVmlldwcABQEDAAAACAVpbnB1dA0DAwkIcG9zaXRpb24FCwEIAAoGbm9ybWFsBQsBCAALAnV2BQoBCAABAAAMBm91dHB1dA0EAQ0IcG9zaXRpb24FDAQMAAQAAA4RdHJhbnNmb3JtZWROb3JtYWwFCwQAAA8TdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAEBFwcm9qZWN0ZWRQb3NpdGlvbgUMBAAAEQtsZW5ndGhTY2FsZQMCAAASBXdpZHRoAwIAABMEcGRpcgUMBAAAFAhfX2luaXRfXw4GAAAVBnZlcnRleA4GAAACAhQAAAUBBQUIFgNkaXIFCwQAAAYBAgoFCwkDMg4BAgcHBgULAAYEAhMFDAYBCQMqDgIGAQIWBQsJAzIOAQICBwYFCwEDAAAAAAAA8D8DBQwCAwcFDAUMBoEKAhMFDBEABQoGAgEDAAAAAAAA8D8DCQMNDgEGAAYBCgITBQwAAAMKAhMFDAAAAwMGAQoCEwUMBAADCgITBQwEAAMDAwMDBQoGgAIPBQsGAQYBAhYFCwoCCwUKAAADBQsCEQMFCwULBgQCDgULCQMfDgECFgULBQsFCwAAABUAAAUBBoAKAhAFDBEABQoGAQYBBgEGAQQGAQoCEwUMBQAFCgkDKA4CAQMAAAAAAADwPwMBAwAAAAAAAPC/AwUKBQoFCgQGAwoCCwUKBAADAQMAAAAAAADgPwMDAwUKCgIQBQwIAAMFCgIGBQoFCgISAwUKBQoA"
h3d_shader_MinMaxShader.SRC = "HXSLF2gzZC5zaGFkZXIuTWluTWF4U2hhZGVyCwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgR0ZXhBCgIAAAsEdGV4QgoCAAAMBWlzTWF4AgIAAQAAAAAADQhfX2luaXRfXw4GAAAOBnZlcnRleA4GAAAPCGZyYWdtZW50DgYAAAMCDQAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAA4AAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ8AAAUDCBABYQUMBAAACQMhDgICCgoCCQUKBQwACBEBYgUMBAAACQMhDgICCwoCCQUKBQwABgQCCAUMCwIMAgkDFg4CAhAFDAIRBQwFDAkDFQ4CAhAFDAIRBQwFDAUMBQwA"
h3d_shader_CubeMinMaxShader.SRC = "HXSLG2gzZC5zaGFkZXIuQ3ViZU1pbk1heFNoYWRlcgwBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEdGV4QQwCAAALBHRleEIMAgAADAVpc01heAICAAEAAAAAAA0DbWF0BgIAAA4IX19pbml0X18OBgAADwZ2ZXJ0ZXgOBgAAEAhmcmFnbWVudA4GAAADAg4AAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAPAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEQAAAFBQgRAnV2BQoEAAAGAwYBAgkFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAAgSA2RpcgULBAAABgEJAykOAgIRBQoBAwAAAAAAAPA/AwULAg0GBQsACBMBYQUMBAAACQMhDgICCgwCEgULBQwACBQBYgUMBAAACQMhDgICCwwCEgULBQwABgQCCAUMCwIMAgkDFg4CAhMFDAIUBQwFDAkDFQ4CAhMFDAIUBQwFDAUMBQwA"
h3d_shader_NormalMap.SRC = "HXSLFGgzZC5zaGFkZXIuTm9ybWFsTWFwCgEGY2FtZXJhDQECAghwb3NpdGlvbgULAAEAAwNkaXIFCwMBAAAAAAQGZ2xvYmFsDQIBBQltb2RlbFZpZXcHAAQBAwAAAAYFaW5wdXQNAwIHBm5vcm1hbAULAQYACAd0YW5nZW50BQsBBgABAAAJB3RleHR1cmUKAgAACgxjYWxjdWxhdGVkVVYFCgQAAAsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAADBF0cmFuc2Zvcm1lZE5vcm1hbAULBAAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAMAAA4OX19pbml0X192ZXJ0ZXgOBgAADwhmcmFnbWVudA4GAAACAg4AAAUBBgQCDQUMCQMqDgIGAQIIBQsJAzIOAQIFBwYFCwsGBwkDHQ4CAggFCwIIBQsDAQMAAAAAAADgPwMCAQMAAAAAAADwPwMBAwAAAAAAAPC/AwMFDAUMAAEPAAAFBQgQAW4FCwQAAAIMBQsACBECbmYFCwQAAAkDOQ4BCQMhDgICCQoCCgUKBQwFCwAIEgR0YW5YBQsEAAAJAx8OAQoCDQUMkgAFCwULAAgTBHRhblkFCwQAAAYBCQMeDgICEAULAhIFCwULBwMKAg0FDAwAAwMFCwAGBAIMBQsJAx8OAQQGAAYABgEKAhEFCwAAAwISBQsFCwYBCgIRBQsEAAMCEwULBQsFCwYBCgIRBQsIAAMCEAULBQsFCwULBQsFCwA"
h3d_shader_Shadow.SRC = "HXSLEWgzZC5zaGFkZXIuU2hhZG93BgEGc2hhZG93DQEFAgNtYXARAQABAAMEcHJvaggAAQAEBWNvbG9yBQsAAQAFBXBvd2VyAwABAAYEYmlhcwMAAQAAAAAHCnBpeGVsQ29sb3IFDAQAAAgTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAACRhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAoJc2hhZG93UG9zBQsEAAEBCwhmcmFnbWVudA4GAAABAQsAAAUGCAwJc2hhZG93UG9zBQsEAAAGAQIJBQsCAwgFCwAIDQVkZXB0aAMEAAAJAz8OAgICEQEJAzoOAQoCDAULEQAFCgUKAwAIDgR6TWF4AwQAAAkDNQ4BCgIMBQsIAAMDAAgPBWRlbHRhAwQAAAYDCQMVDgIEBgACDQMCBgMDAwIOAwMCDgMDAAgQBXNoYWRlAwQAAAkDNQ4BCQMJDgEGAQIFAwIPAwMDAwAGgQoCBwUMkgAFCwYABgEEBgMBAwAAAAAAAPA/AwIQAwMDCgIEBQuSAAULBQsCEAMFCwULAA"
h3d_shader_SignedDistanceField.SRC = "HXSLHmgzZC5zaGFkZXIuU2lnbmVkRGlzdGFuY2VGaWVsZA4BBWlucHV0DQEDAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEABAVjb2xvcgUMAQEAAQAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAIBHRpbWUDAAAACQ5zcHJpdGVQb3NpdGlvbgUMBAAAChBhYnNvbHV0ZVBvc2l0aW9uBQwEAAALCnBpeGVsQ29sb3IFDAQAAAwMdGV4dHVyZUNvbG9yBQwEAAANDGNhbGN1bGF0ZWRVVgUKAwAADg5vdXRwdXRQb3NpdGlvbgUMBAAADwdjaGFubmVsAQIAAQAAAAAAEAthbHBoYUN1dG9mZgMCAAARCXNtb290aGluZwMCAAASBm1lZGlhbg4GAAATCGZyYWdtZW50DgYAAAIDEgMUAXIDBAAAFQFnAwQAABYBYgMEAAADBQENCQMWDgIJAxUOAgIUAwIVAwMJAxUOAgkDFg4CAhQDAhUDAwIWAwMDAAABEwAABQQIFw10ZXh0dXJlU2FtcGxlBQwEAAACDAUMAAgYCGRpc3RhbmNlAwQAAAAABgQCGAMLBgUCDwEBAgAAAAABAgoCFwUMAAADCwYFAg8BAQIBAAAAAQIKAhcFDAQAAwsGBQIPAQECAgAAAAECCgIXBQwIAAMLBgUCDwEBAgMAAAABAgoCFwUMDAADCQISDgMKAhcFDAAAAwoCFwUMBAADCgIXBQwIAAMDAwMDAwMGBAIMBQwJAyoOBAEDAAAAAAAA8D8DAQMAAAAAAADwPwMBAwAAAAAAAPA/AwkDGg4DBgMCEAMCEQMDBgACEAMCEQMDAhgDAwUMBQwA"
h3d_shader_SkinBase.SRC = "HXSLE2gzZC5zaGFkZXIuU2tpbkJhc2UFARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIAA"
h3d_shader_Skin.SRC = "HXSLD2gzZC5zaGFkZXIuU2tpbggBEHJlbGF0aXZlUG9zaXRpb24FCwQAAAITdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAAxF0cmFuc2Zvcm1lZE5vcm1hbAULBAAABAhNYXhCb25lcwECAAEAAAAAAAUNYm9uZXNNYXRyaXhlcw8IBAIAAQgGBWlucHV0DQEEBwhwb3NpdGlvbgULAQYACAZub3JtYWwFCwEGAAkHd2VpZ2h0cwULAQYACgdpbmRleGVzCQQAAAABBgABAAALEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADAZ2ZXJ0ZXgOBgAAAQAMAAAFAgYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQJAyUOAQoCCgkEAAAAAAADAQgFCwULCgIJBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAkDJQ4BCgIKCQQAAAAEAAMBCAULBQsKAgkFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQJAyUOAQoCCgkEAAAACAADAQgFCwULCgIJBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAkDJQ4BCgIKCQQAAAAAAAMBCAYFCwULCgIJBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECQMlDgEKAgoJBAAAAAQAAwEIBgULBQsKAgkFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAkDJQ4BCgIKCQQAAAAIAAMBCAYFCwULCgIJBQsIAAMFCwULBQsFCwA"
h3d_shader_SkinTangent.SRC = "HXSLFmgzZC5zaGFkZXIuU2tpblRhbmdlbnQIARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIBgVpbnB1dA0BBQcIcG9zaXRpb24FCwEGAAgGbm9ybWFsBQsBBgAJB3RhbmdlbnQFCwEGAAoHd2VpZ2h0cwULAQYACwdpbmRleGVzCQQAAAABBgABAAAMEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADQZ2ZXJ0ZXgOBgAAAQANAAAFAwYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQJAyUOAQoCCwkEAAAAAAADAQgFCwULCgIKBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAkDJQ4BCgILCQQAAAAEAAMBCAULBQsKAgoFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQJAyUOAQoCCwkEAAAACAADAQgFCwULCgIKBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAkDJQ4BCgILCQQAAAAAAAMBCAYFCwULCgIKBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECQMlDgEKAgsJBAAAAAQAAwEIBgULBQsKAgoFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAkDJQ4BCgILCQQAAAAIAAMBCAYFCwULCgIKBQsIAAMFCwULBQsFCwYEAgwFDAkDKg4CCQMfDgEGAAYABgEEBgEKAgkFC5IABQsJAzIOARECBQ8IBAkDJQ4BCgILCQQAAAAAAAMBCAYFCwULCgIKBQsAAAMFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQJAyUOAQoCCwkEAAAABAADAQgGBQsFCwoCCgULBAADBQsFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQJAyUOAQoCCwkEAAAACAADAQgGBQsFCwoCCgULCAADBQsFCwULCgIMBQwMAAMFDAUMAA"
h3d_shader_SpecularTexture.SRC = "HXSLGmgzZC5zaGFkZXIuU3BlY3VsYXJUZXh0dXJlBAEHdGV4dHVyZQoCAAACDGNhbGN1bGF0ZWRVVgUKBAAAAwlzcGVjQ29sb3IFCwQAAAQIZnJhZ21lbnQOBgAAAQEEAAAFAQaBAgMFCwoJAyEOAgIBCgICBQoFDJIABQsFCwA"
h3d_shader_Texture.SRC = "HXSLEmgzZC5zaGFkZXIuVGV4dHVyZQsBBWlucHV0DQEBAgJ1dgUKAQEAAQAAAwhhZGRpdGl2ZQICAAEAAAAAAAQJa2lsbEFscGhhAgIAAQAAAAAABQ1zcGVjdWxhckFscGhhAgIAAQAAAAAABhJraWxsQWxwaGFUaHJlc2hvbGQDAgABBwAAAAAAAAAAAAAAAAAA8D8HB3RleHR1cmUKAgAACAxjYWxjdWxhdGVkVVYFCgQAAAkKcGl4ZWxDb2xvcgUMBAAACglzcGVjQ29sb3IFCwQAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAAAgALAAAFAQYEAggFCgICBQoFCgABDAAABQQIDQFjBQwEAAAJAyEOAgIHCgIIBQoFDAALBg4CBAIGCQYDCgINBQwMAAMCBgMDAQMAAAAAAAAAAAMCAgwAAAALAgMCBoACCQUMAg0FDAUMBoECCQUMAg0FDAUMAAsCBQIGgQIKBQsKAg0FDP4ABQsFCwAAAA"
h3d_shader_UVDelta.SRC = "HXSLEmgzZC5zaGFkZXIuVVZEZWx0YQQBB3V2RGVsdGEFCgIAAAIHdXZTY2FsZQUKAgAAAwxjYWxjdWxhdGVkVVYFCgQAAAQGdmVydGV4DgYAAAEABAAABQEGBAIDBQoGAAYBAgMFCgICBQoFCgIBBQoFCgUKAA"
h3d_shader_VertexColorAlpha.SRC = "HXSLG2gzZC5zaGFkZXIuVmVydGV4Q29sb3JBbHBoYQQBBWlucHV0DQEBAgVjb2xvcgUMAQEAAQAAAwpwaXhlbENvbG9yBQwEAAAECGFkZGl0aXZlAgIAAQAAAAAABQhmcmFnbWVudA4GAAABAQUAAAUBCwIEAgaAAgMFDAICBQwFDAaBAgMFDAICBQwFDAAA"
h3d_shader_VolumeDecal.SRC = "HXSLFmgzZC5zaGFkZXIuVm9sdW1lRGVjYWwYAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQhkZXB0aE1hcBEBAAAAJgVzY2FsZQUKAgAAJwZub3JtYWwFCwIAACgHdGFuZ2VudAULAgAAKQppc0NlbnRlcmVkAgIAAQAAAAAAKgxjYWxjdWxhdGVkVVYFCgQAACsSdHJhbnNmb3JtZWRUYW5nZW50BQwEAAAsDl9faW5pdF9fdmVydGV4DgYAAC0IZnJhZ21lbnQOBgAAAgIsAAAFAgYEAh0FCwkDHw4BBAYBAicFCwkDMg4BAg8HBgULBQsFCwULBgQCKwUMCQMqDgIJAx8OAQQGAQIoBQsJAzIOAQIPBwYFCwULBQsBAwAAAAAAAPA/AwUMBQwAAS0AAAUJCC4GbWF0cml4BwQAAAYBAggHAhAHBwAILwlzY3JlZW5Qb3MFCgQAAAYCCgIeBQwRAAUKCgIeBQwMAAMFCgAIMANydXYFDAQAAAkDKg4DAi8FCgkDPw4CAiURAQkDOg4BAi8FCgUKAwEDAAAAAAAA8D8DBQwACDEEd3BvcwUMBAAABgECMAUMAi4HBQwACDIEcHBvcwUMBAAABgECMAUMAggHBQwABgQCHAULBgIKAjIFDJIABQsKAjIFDAwAAwULBQsGBAIqBQoGAQImBQoEBgIKAjEFDBEABQoKAjEFDAwAAwUKBQoFCgUKCwIpAgaAAioFCgEDAAAAAAAA4D8DBQoAAAsGCQkDFQ4CCQMVDgIKAioFCgAAAwoCKgUKBAADAwkDFQ4CBgMBAwAAAAAAAPA/AwoCKgUKAAADAwYDAQMAAAAAAADwPwMKAioFCgQAAwMDAwEDAAAAAAAAAAADAgwAAAAA"
haxe_MainLoop.mutex = sys_thread_Mutex()
haxe_MainLoop.mainThread = sys_thread__Thread_HxThread.current()
haxe_Serializer.USE_CACHE = False
haxe_Serializer.USE_ENUM_INDEX = False
haxe_Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"
haxe_Serializer.BASE64_CODES = None
haxe_Unserializer.DEFAULT_RESOLVER = haxe__Unserializer_DefaultResolver()
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"
haxe_Unserializer.CODES = None
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS)
def _hx_init_haxe_io_FPHelper_i64tmp():
    def _hx_local_0():
        this1 = haxe__Int64____Int64(0,0)
        return this1
    return _hx_local_0()
haxe_io_FPHelper.i64tmp = _hx_init_haxe_io_FPHelper_i64tmp()
def _hx_init_haxe_xml_Parser_escapes():
    def _hx_local_0():
        h = haxe_ds_StringMap()
        h.h["lt"] = "<"
        h.h["gt"] = ">"
        h.h["amp"] = "&"
        h.h["quot"] = "\""
        h.h["apos"] = "'"
        return h
    return _hx_local_0()
haxe_xml_Parser.escapes = _hx_init_haxe_xml_Parser_escapes()
haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1]
haxe_zip_InflateImpl.LEN_BASE_VAL_TBL = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]
haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1]
haxe_zip_InflateImpl.DIST_BASE_VAL_TBL = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]
haxe_zip_InflateImpl.CODE_LENGTHS_POS = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
haxe_zip_InflateImpl.FIXED_HUFFMAN = None
hxd_Charset.ASCII = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
hxd_Charset.LATIN1 = "-"
hxd_Charset.CYRILLIC = ""
hxd_Charset.POLISH = ""
hxd_Charset.TURKISH = "I"
hxd_Charset.JP_KANA = ""
hxd_Charset.UNICODE_SPECIALS = ""
hxd_Charset.DEFAULT_CHARS = (HxOverrides.stringOrNull(hxd_Charset.ASCII) + HxOverrides.stringOrNull(hxd_Charset.LATIN1))
def _hx_init_hxd_Charset_complementChars():
    def _hx_local_0():
        _hx_str = ""
        _g = haxe_ds_IntMap()
        _g1 = 0
        _g2 = len(_hx_str)
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.set(HxString.charCodeAt(_hx_str,i),True)
        return _g
    return _hx_local_0()
hxd_Charset.complementChars = _hx_init_hxd_Charset_complementChars()
hxd_Key.BACKSPACE = 8
hxd_Key.TAB = 9
hxd_Key.ENTER = 13
hxd_Key.SHIFT = 16
hxd_Key.CTRL = 17
hxd_Key.ALT = 18
hxd_Key.ESCAPE = 27
hxd_Key.SPACE = 32
hxd_Key.PGUP = 33
hxd_Key.PGDOWN = 34
hxd_Key.END = 35
hxd_Key.HOME = 36
hxd_Key.LEFT = 37
hxd_Key.UP = 38
hxd_Key.RIGHT = 39
hxd_Key.DOWN = 40
hxd_Key.INSERT = 45
hxd_Key.DELETE = 46
hxd_Key.QWERTY_EQUALS = 187
hxd_Key.QWERTY_MINUS = 189
hxd_Key.QWERTY_TILDE = 192
hxd_Key.QWERTY_BRACKET_LEFT = 219
hxd_Key.QWERTY_BRACKET_RIGHT = 221
hxd_Key.QWERTY_SEMICOLON = 186
hxd_Key.QWERTY_QUOTE = 222
hxd_Key.QWERTY_BACKSLASH = 220
hxd_Key.QWERTY_COMMA = 188
hxd_Key.QWERTY_PERIOD = 190
hxd_Key.QWERTY_SLASH = 191
hxd_Key.INTL_BACKSLASH = 226
hxd_Key.LEFT_WINDOW_KEY = 91
hxd_Key.RIGHT_WINDOW_KEY = 92
hxd_Key.CONTEXT_MENU = 93
hxd_Key.PAUSE_BREAK = 19
hxd_Key.CAPS_LOCK = 20
hxd_Key.NUM_LOCK = 144
hxd_Key.SCROLL_LOCK = 145
hxd_Key.NUMBER_0 = 48
hxd_Key.NUMBER_1 = 49
hxd_Key.NUMBER_2 = 50
hxd_Key.NUMBER_3 = 51
hxd_Key.NUMBER_4 = 52
hxd_Key.NUMBER_5 = 53
hxd_Key.NUMBER_6 = 54
hxd_Key.NUMBER_7 = 55
hxd_Key.NUMBER_8 = 56
hxd_Key.NUMBER_9 = 57
hxd_Key.NUMPAD_0 = 96
hxd_Key.NUMPAD_1 = 97
hxd_Key.NUMPAD_2 = 98
hxd_Key.NUMPAD_3 = 99
hxd_Key.NUMPAD_4 = 100
hxd_Key.NUMPAD_5 = 101
hxd_Key.NUMPAD_6 = 102
hxd_Key.NUMPAD_7 = 103
hxd_Key.NUMPAD_8 = 104
hxd_Key.NUMPAD_9 = 105
hxd_Key.A = 65
hxd_Key.B = 66
hxd_Key.C = 67
hxd_Key.D = 68
hxd_Key.E = 69
hxd_Key.F = 70
hxd_Key.G = 71
hxd_Key.H = 72
hxd_Key.I = 73
hxd_Key.J = 74
hxd_Key.K = 75
hxd_Key.L = 76
hxd_Key.M = 77
hxd_Key.N = 78
hxd_Key.O = 79
hxd_Key.P = 80
hxd_Key.Q = 81
hxd_Key.R = 82
hxd_Key.S = 83
hxd_Key.T = 84
hxd_Key.U = 85
hxd_Key.V = 86
hxd_Key.W = 87
hxd_Key.X = 88
hxd_Key.Y = 89
hxd_Key.Z = 90
hxd_Key.F1 = 112
hxd_Key.F2 = 113
hxd_Key.F3 = 114
hxd_Key.F4 = 115
hxd_Key.F5 = 116
hxd_Key.F6 = 117
hxd_Key.F7 = 118
hxd_Key.F8 = 119
hxd_Key.F9 = 120
hxd_Key.F10 = 121
hxd_Key.F11 = 122
hxd_Key.F12 = 123
hxd_Key.F13 = 124
hxd_Key.F14 = 125
hxd_Key.F15 = 126
hxd_Key.F16 = 127
hxd_Key.F17 = 128
hxd_Key.F18 = 129
hxd_Key.F19 = 130
hxd_Key.F20 = 131
hxd_Key.F21 = 132
hxd_Key.F22 = 133
hxd_Key.F23 = 134
hxd_Key.F24 = 135
hxd_Key.NUMPAD_MULT = 106
hxd_Key.NUMPAD_ADD = 107
hxd_Key.NUMPAD_ENTER = 108
hxd_Key.NUMPAD_SUB = 109
hxd_Key.NUMPAD_DOT = 110
hxd_Key.NUMPAD_DIV = 111
hxd_Key.MOUSE_LEFT = 0
hxd_Key.MOUSE_RIGHT = 1
hxd_Key.MOUSE_MIDDLE = 2
hxd_Key.MOUSE_BACK = 3
hxd_Key.MOUSE_FORWARD = 4
hxd_Key.MOUSE_WHEEL_UP = 5
hxd_Key.MOUSE_WHEEL_DOWN = 6
hxd_Key.LOC_LEFT = 256
hxd_Key.LOC_RIGHT = 512
hxd_Key.LSHIFT = 272
hxd_Key.RSHIFT = 528
hxd_Key.LCTRL = 273
hxd_Key.RCTRL = 529
hxd_Key.LALT = 274
hxd_Key.RALT = 530
hxd_Key.initDone = False
hxd_Key.keyPressed = []
hxd_Key.ALLOW_KEY_REPEAT = False
hxd_Math.PI = 3.14159265358979323
hxd_Math.EPSILON = 1e-10
hxd__Pixels_Channel_Impl_.R = 0
hxd__Pixels_Channel_Impl_.G = 1
hxd__Pixels_Channel_Impl_.B = 2
hxd__Pixels_Channel_Impl_.A = 3
hxd_System.setCursor = hxd_System.setNativeCursor
hxd_Timer.wantedFPS = 60.
hxd_Timer.maxDeltaTime = 0.5
hxd_Timer.smoothFactor = 0.95
hxd_Timer.lastTimeStamp = python_lib_Timeit.default_timer()
hxd_Timer.elapsedTime = 0.
hxd_Timer.frameCount = 0
hxd_Timer.dt = (1 / hxd_Timer.wantedFPS)
hxd_Timer.currentDT = (1 / hxd_Timer.wantedFPS)
hxd_Window.inst = None
hxd_clipper__Clipper_ClipperBase.HORIZONTAL = -9007199254740992.
hxd_clipper__Clipper_ClipperBase.TOLERANCE = 1E-20
hxd_clipper__Clipper_ClipperBase.SKIP = -2
hxd_clipper__Clipper_ClipperBase.UNASSIGNED = -1
hxd_fmt_bfnt_Writer.VERSION = 1
hxd_fmt_fbx_BaseLibrary.maxBonesPerSkin = 34
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DFloat = 1
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DVec2 = 2
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DVec3 = 3
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DVec4 = 4
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DBytes4 = 9
hxd_fmt_hmd_Position.QTMP = h3d_Quat()
hxd_fmt_hmd_Data.CURRENT_VERSION = 3
hxd_fmt_hmd_Reader.BLEND = Type.allEnums(h2d_BlendMode)
hxd_fmt_hmd_Reader.CULLING = Type.allEnums(h3d_mat_Face)
hxd_fs_Convert.converts = haxe_ds_StringMap()
hxd_fs_ConvertFBX2HMD._ = hxd_fs_Convert.register(hxd_fs_ConvertFBX2HMD())
hxd_fs_ConvertWAV2MP3._ = hxd_fs_Convert.register(hxd_fs_ConvertWAV2MP3())
hxd_fs_ConvertWAV2OGG._ = hxd_fs_Convert.register(hxd_fs_ConvertWAV2OGG())
hxd_fs_ConvertTGA2PNG._ = hxd_fs_Convert.register(hxd_fs_ConvertTGA2PNG())
hxd_fs_ConvertFNT2BFNT._ = hxd_fs_Convert.register(hxd_fs_ConvertFNT2BFNT())
def _hx_init_hxd_fs_CompressIMG_TEXCONV_FMT():
    def _hx_local_0():
        _g = haxe_ds_StringMap()
        _g.h["R16F"] = "R16_FLOAT"
        _g.h["R32F"] = "R32_FLOAT"
        _g.h["RG16F"] = "R16G16_FLOAT"
        _g.h["RG32F"] = "R32G32_FLOAT"
        _g.h["RGB16F"] = "R16G16B16_FLOAT"
        _g.h["RGB32F"] = "R32G32B32_FLOAT"
        _g.h["RGBA16F"] = "R16G16B16A16_FLOAT"
        _g.h["RGBA32F"] = "R32G32B32A32_FLOAT"
        return _g
    return _hx_local_0()
hxd_fs_CompressIMG.TEXCONV_FMT = _hx_init_hxd_fs_CompressIMG_TEXCONV_FMT()
hxd_fs_CompressIMG._ = hxd_fs_Convert.register(hxd_fs_CompressIMG("png,tga,jpg,jpeg","dds"))
hxd_fs_DummyConvert._ = [hxd_fs_Convert.register(hxd_fs_DummyConvert(None,"dummy")), hxd_fs_Convert.register(hxd_fs_DummyConvert(None,"remove"))]
hxd_fs_FileConverter.extraConfigs = []
hxd_fs_LocalEntry.WATCH_INDEX = 0
hxd_fs_LocalEntry.WATCH_LIST = None
hxd_fs_LocalEntry.tmpDir = None
hxd_fs_LocalFileSystem.isWindows = (Sys.systemName() == "Windows")
hxd_fs_LocalFileSystem.FILES_CHECK_MAX = 5
hxd_impl__Allocator_BufferFlags_Impl_.Dynamic = 0
hxd_impl__Allocator_BufferFlags_Impl_.UniformDynamic = 1
hxd_impl__Allocator_BufferFlags_Impl_.RawFormat = 2
hxd_impl__Allocator_BufferFlags_Impl_.RawQuads = 3
hxd_res_Resource.LIVE_UPDATE = False
hxd_res__Image_ImageFormat_Impl_.Jpg = 0
hxd_res__Image_ImageFormat_Impl_.Png = 1
hxd_res__Image_ImageFormat_Impl_.Gif = 2
hxd_res__Image_ImageFormat_Impl_.Tga = 3
hxd_res__Image_ImageFormat_Impl_.Dds = 4
hxd_res__Image_ImageFormat_Impl_.Raw = 5
hxd_res__Image_ImageFormat_Impl_.Hdr = 6
hxd_res_Image.DEFAULT_FILTER = h3d_mat_Filter.Linear
hxd_res_Image.DEFAULT_ASYNC = False
hxd_res_Image.ENABLE_AUTO_WATCH = True
hxd_res_NanoJpeg.BLOCKSIZE = 64
hxd_res_NanoJpeg.W1 = 2841
hxd_res_NanoJpeg.W2 = 2676
hxd_res_NanoJpeg.W3 = 2408
hxd_res_NanoJpeg.W5 = 1609
hxd_res_NanoJpeg.W6 = 1108
hxd_res_NanoJpeg.W7 = 565
hxd_res_NanoJpeg.CF4A = -9
hxd_res_NanoJpeg.CF4B = 111
hxd_res_NanoJpeg.CF4C = 29
hxd_res_NanoJpeg.CF4D = -3
hxd_res_NanoJpeg.CF3A = 28
hxd_res_NanoJpeg.CF3B = 109
hxd_res_NanoJpeg.CF3C = -9
hxd_res_NanoJpeg.CF3X = 104
hxd_res_NanoJpeg.CF3Y = 27
hxd_res_NanoJpeg.CF3Z = -3
hxd_res_NanoJpeg.CF2A = 139
hxd_res_NanoJpeg.CF2B = -11
hxd_res_NanoJpeg.inst = None
hxd_res_Sound.ENABLE_AUTO_WATCH = True
hxd_snd_Channel.ID = 0
hxd_snd_Source.ID = 0
hxd_snd_Manager.STREAM_DURATION = 5.
hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT = 44100
hxd_snd_Manager.BUFFER_QUEUE_LENGTH = 2
hxd_snd_Manager.MAX_SOURCES = 16
hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE = 256
hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD = 1e-5
hxd_snd_Manager.BUFFER_STREAM_SPLIT = 16
hxd_snd_openal__Emulator_Channel.FADE_START = 10
hxd_snd_openal_Source.STOP_DELAY = 0
hxd_snd_openal_Source.CHANNEL_BUFSIZE = 4096
hxd_snd_openal_Source.ID = 0
hxd_snd_openal_Source.all = haxe_ds_IntMap()
hxd_snd_openal_Buffer.ID = 0
hxd_snd_openal_Buffer.all = haxe_ds_IntMap()
hxd_snd_openal_Emulator.FORMAT_MONOF32 = 4368
hxd_snd_openal_Emulator.FORMAT_STEREOF32 = 4369
hxd_snd_openal_Emulator.NONE = 0
hxd_snd_openal_Emulator.FALSE = 0
hxd_snd_openal_Emulator.TRUE = 1
hxd_snd_openal_Emulator.SOURCE_RELATIVE = 514
hxd_snd_openal_Emulator.CONE_INNER_ANGLE = 4097
hxd_snd_openal_Emulator.CONE_OUTER_ANGLE = 4098
hxd_snd_openal_Emulator.PITCH = 4099
hxd_snd_openal_Emulator.POSITION = 4100
hxd_snd_openal_Emulator.DIRECTION = 4101
hxd_snd_openal_Emulator.VELOCITY = 4102
hxd_snd_openal_Emulator.LOOPING = 4103
hxd_snd_openal_Emulator.BUFFER = 4105
hxd_snd_openal_Emulator.GAIN = 4106
hxd_snd_openal_Emulator.MIN_GAIN = 4109
hxd_snd_openal_Emulator.MAX_GAIN = 4110
hxd_snd_openal_Emulator.ORIENTATION = 4111
hxd_snd_openal_Emulator.SOURCE_STATE = 4112
hxd_snd_openal_Emulator.INITIAL = 4113
hxd_snd_openal_Emulator.PLAYING = 4114
hxd_snd_openal_Emulator.PAUSED = 4115
hxd_snd_openal_Emulator.STOPPED = 4116
hxd_snd_openal_Emulator.BUFFERS_QUEUED = 4117
hxd_snd_openal_Emulator.BUFFERS_PROCESSED = 4118
hxd_snd_openal_Emulator.REFERENCE_DISTANCE = 4128
hxd_snd_openal_Emulator.ROLLOFF_FACTOR = 4129
hxd_snd_openal_Emulator.CONE_OUTER_GAIN = 4130
hxd_snd_openal_Emulator.MAX_DISTANCE = 4131
hxd_snd_openal_Emulator.SEC_OFFSET = 4132
hxd_snd_openal_Emulator.SAMPLE_OFFSET = 4133
hxd_snd_openal_Emulator.BYTE_OFFSET = 4134
hxd_snd_openal_Emulator.SOURCE_TYPE = 4135
hxd_snd_openal_Emulator.STATIC = 4136
hxd_snd_openal_Emulator.STREAMING = 4137
hxd_snd_openal_Emulator.UNDETERMINED = 4144
hxd_snd_openal_Emulator.FORMAT_MONO8 = 4352
hxd_snd_openal_Emulator.FORMAT_MONO16 = 4353
hxd_snd_openal_Emulator.FORMAT_STEREO8 = 4354
hxd_snd_openal_Emulator.FORMAT_STEREO16 = 4355
hxd_snd_openal_Emulator.FREQUENCY = 8193
hxd_snd_openal_Emulator.BITS = 8194
hxd_snd_openal_Emulator.CHANNELS = 8195
hxd_snd_openal_Emulator.SIZE = 8196
hxd_snd_openal_Emulator.UNUSED = 8208
hxd_snd_openal_Emulator.PENDING = 8209
hxd_snd_openal_Emulator.PROCESSED = 8210
hxd_snd_openal_Emulator.NO_ERROR = 0
hxd_snd_openal_Emulator.INVALID_NAME = 40961
hxd_snd_openal_Emulator.INVALID_ENUM = 40962
hxd_snd_openal_Emulator.INVALID_VALUE = 40963
hxd_snd_openal_Emulator.INVALID_OPERATION = 40964
hxd_snd_openal_Emulator.OUT_OF_MEMORY = 40965
hxd_snd_openal_Emulator.VENDOR = 45057
hxd_snd_openal_Emulator.VERSION = 45058
hxd_snd_openal_Emulator.RENDERER = 45059
hxd_snd_openal_Emulator.EXTENSIONS = 45060
hxd_snd_openal_Emulator.DOPPLER_FACTOR = 49152
hxd_snd_openal_Emulator.DOPPLER_VELOCITY = 49153
hxd_snd_openal_Emulator.SPEED_OF_SOUND = 49155
hxd_snd_openal_Emulator.DISTANCE_MODEL = 53248
hxd_snd_openal_Emulator.INVERSE_DISTANCE = 53249
hxd_snd_openal_Emulator.INVERSE_DISTANCE_CLAMPED = 53250
hxd_snd_openal_Emulator.LINEAR_DISTANCE = 53251
hxd_snd_openal_Emulator.LINEAR_DISTANCE_CLAMPED = 53252
hxd_snd_openal_Emulator.EXPONENT_DISTANCE = 53253
hxd_snd_openal_Emulator.EXPONENT_DISTANCE_CLAMPED = 53254
hxd_snd_openal_ALC.ctx = None
hxd_snd_openal_ALC.FALSE = 0
hxd_snd_openal_ALC.TRUE = 1
hxd_snd_openal_ALC.FREQUENCY = 4103
hxd_snd_openal_ALC.REFRESH = 4104
hxd_snd_openal_ALC.SYNC = 4105
hxd_snd_openal_ALC.MONO_SOURCES = 4112
hxd_snd_openal_ALC.STEREO_SOURCES = 4113
hxd_snd_openal_ALC.NO_ERROR = 0
hxd_snd_openal_ALC.INVALID_DEVICE = 40961
hxd_snd_openal_ALC.INVALID_CONTEXT = 40962
hxd_snd_openal_ALC.INVALID_ENUM = 40963
hxd_snd_openal_ALC.INVALID_VALUE = 40964
hxd_snd_openal_ALC.OUT_OF_MEMORY = 40965
hxd_snd_openal_ALC.MAJOR_VERSION = 4096
hxd_snd_openal_ALC.MINOR_VERSION = 4097
hxd_snd_openal_ALC.ATTRIBUTES_SIZE = 4098
hxd_snd_openal_ALC.ALL_ATTRIBUTES = 4099
hxd_snd_openal_ALC.DEFAULT_DEVICE_SPECIFIER = 4100
hxd_snd_openal_ALC.DEVICE_SPECIFIER = 4101
hxd_snd_openal_ALC.EXTENSIONS = 4102
hxd_snd_openal_ALC.EXT_CAPTURE = 1
hxd_snd_openal_ALC.CAPTURE_DEVICE_SPECIFIER = 784
hxd_snd_openal_ALC.CAPTURE_DEFAULT_DEVICE_SPECIFIER = 785
hxd_snd_openal_ALC.CAPTURE_SAMPLES = 786
hxd_snd_openal_ALC.ENUMERATE_ALL_EXT = 1
hxd_snd_openal_ALC.DEFAULT_ALL_DEVICES_SPECIFIER = 4114
hxd_snd_openal_ALC.ALL_DEVICES_SPECIFIER = 4115
hxd_snd_openal_EFX.EFX_MAJOR_VERSION = 131073
hxd_snd_openal_EFX.EFX_MINOR_VERSION = 131074
hxd_snd_openal_EFX.MAX_AUXILIARY_SENDS = 131075
hxd_snd_openal_EFX.METERS_PER_UNIT = 131076
hxd_snd_openal_EFX.DIRECT_FILTER = 131077
hxd_snd_openal_EFX.FILTER_NULL = 0
hxsl_Tools.UID = 0
hxsl_Tools.SWIZ = Type.allEnums(hxsl_Component)
hxsl_Tools.MAX_CHANNELS_BITS = 3
hxsl_BatchShader.SRC = "HXSLEGh4c2wuQmF0Y2hTaGFkZXICAQtCYXRjaF9Db3VudAECAAEAAAABAAIMQmF0Y2hfQnVmZmVyEAUMAQIAAAA"
hxsl__Linker_ShaderInfos.UID = 0
hxsl_Printer.SWIZ = ["x", "y", "z", "w"]
hxsl_RuntimeShader.UID = 0
hxsl_Serializer.TVECS = haxe_ds_IntMap()
def _hx_init_hxsl_Serializer_BOPS():
    def _hx_local_0():
        ops = Type.allEnums(haxe_macro_Binop)
        pos = haxe_macro_Binop.OpAssignOp(None).index
        ops.insert(pos, None)
        return ops
    return _hx_local_0()
hxsl_Serializer.BOPS = _hx_init_hxsl_Serializer_BOPS()
hxsl_Serializer.UNOPS = Type.allEnums(haxe_macro_Unop)
hxsl_Serializer.TGLOBALS = Type.allEnums(hxsl_TGlobal)
hxsl_Serializer.TSWIZ = haxe_ds_IntMap()
hxsl_Serializer.REGS = [hxsl_Component.X, hxsl_Component.Y, hxsl_Component.Z, hxsl_Component.W]
hxsl_Serializer.VKINDS = Type.allEnums(hxsl_VarKind)
hxsl_Serializer.PRECS = Type.allEnums(hxsl_Prec)
hxsl_Serializer.FKIND = Type.allEnums(hxsl_FunctionKind)
hxsl_Serializer.SIGN = 9139229
hxsl_SharedShader.UNROLL_LOOPS = False
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")

Main.main()
sys_thread__Thread_Thread_Impl_.processEvents()
