# Generated by Haxe 4.2.1
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import functools as python_lib_Functools
from threading import RLock as sys_thread__Mutex_NativeRLock
import threading
import timeit as python_lib_Timeit
import sys as python_lib_Sys
import builtins as python_lib_Builtins
import json as python_lib_Json
import os as python_lib_Os
import random as python_lib_Random
import re as python_lib_Re
import shutil as python_lib_Shutil
import subprocess as python_lib_Subprocess
import time as python_lib_Time
import traceback as python_lib_Traceback
from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
from io import StringIO as python_lib_io_StringIO
import urllib.parse as python_lib_urllib_Parse
from threading import Semaphore as Lock


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



_hx_classes = {}


class Enum:
    _hx_class_name = "Enum"
    _hx_is_interface = "False"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tag = None
        _hx_o.index = None
        _hx_o.params = None
Enum._hx_class = Enum
_hx_classes["Enum"] = Enum


class Class: pass


class Date:
    _hx_class_name = "Date"
    _hx_is_interface = "False"
    __slots__ = ("date", "dateUTC")
    _hx_fields = ["date", "dateUTC"]
    _hx_methods = ["toString"]
    _hx_statics = ["now", "fromTime", "makeLocal", "fromString"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        self.dateUTC = None
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = Date.makeLocal(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0))
        self.dateUTC = self.date.astimezone(python_lib_datetime_Timezone.utc)

    def toString(self):
        return self.date.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def now():
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.now())
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def fromTime(t):
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.fromtimestamp((t / 1000.0)))
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def makeLocal(date):
        try:
            return date.astimezone()
        except BaseException as _g:
            None
            tzinfo = python_lib_datetime_Datetime.now(python_lib_datetime_Timezone.utc).astimezone().tzinfo
            return date.replace(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'tzinfo': tzinfo})))

    @staticmethod
    def fromString(s):
        _g = len(s)
        if (_g == 8):
            k = s.split(":")
            return Date.fromTime((((Std.parseInt((k[0] if 0 < len(k) else None)) * 3600000.) + ((Std.parseInt((k[1] if 1 < len(k) else None)) * 60000.))) + ((Std.parseInt((k[2] if 2 < len(k) else None)) * 1000.))))
        elif (_g == 10):
            k = s.split("-")
            return Date(Std.parseInt((k[0] if 0 < len(k) else None)),(Std.parseInt((k[1] if 1 < len(k) else None)) - 1),Std.parseInt((k[2] if 2 < len(k) else None)),0,0,0)
        elif (_g == 19):
            k = s.split(" ")
            _this = (k[0] if 0 < len(k) else None)
            y = _this.split("-")
            _this = (k[1] if 1 < len(k) else None)
            t = _this.split(":")
            return Date(Std.parseInt((y[0] if 0 < len(y) else None)),(Std.parseInt((y[1] if 1 < len(y) else None)) - 1),Std.parseInt((y[2] if 2 < len(y) else None)),Std.parseInt((t[0] if 0 < len(t) else None)),Std.parseInt((t[1] if 1 < len(t) else None)),Std.parseInt((t[2] if 2 < len(t) else None)))
        else:
            raise haxe_Exception.thrown(("Invalid date format : " + ("null" if s is None else s)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.date = None
        _hx_o.dateUTC = None
Date._hx_class = Date
_hx_classes["Date"] = Date


class EReg:
    _hx_class_name = "EReg"
    _hx_is_interface = "False"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]
    _hx_methods = ["matchSub", "replace", "map"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def matchSub(self,s,pos,_hx_len = None):
        if (_hx_len is None):
            _hx_len = -1
        if (_hx_len != -1):
            self.matchObj = self.pattern.search(s,pos,(pos + _hx_len))
        else:
            self.matchObj = self.pattern.search(s,pos)
        return (self.matchObj is not None)

    def replace(self,s,by):
        _this = by.split("$$")
        by = "_hx_#repl#__".join([python_Boot.toString1(x1,'') for x1 in _this])
        def _hx_local_0(x):
            res = by
            g = x.groups()
            _g = 0
            _g1 = len(g)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                gs = g[i]
                if (gs is None):
                    continue
                delimiter = ("$" + HxOverrides.stringOrNull(str((i + 1))))
                _this = (list(res) if ((delimiter == "")) else res.split(delimiter))
                res = gs.join([python_Boot.toString1(x1,'') for x1 in _this])
            _this = res.split("_hx_#repl#__")
            res = "$".join([python_Boot.toString1(x1,'') for x1 in _this])
            return res
        replace = _hx_local_0
        return python_lib_Re.sub(self.pattern,replace,s,(0 if (self._hx_global) else 1))

    def map(self,s,f):
        buf_b = python_lib_io_StringIO()
        pos = 0
        right = s
        cur = self
        while (pos < len(s)):
            if (self.matchObj is None):
                self.matchObj = python_lib_Re.search(self.pattern,s)
            else:
                self.matchObj = self.matchObj.re.search(s,pos)
            if (self.matchObj is None):
                break
            pos1 = self.matchObj.end()
            curPos_pos = cur.matchObj.start()
            curPos_len = (cur.matchObj.end() - cur.matchObj.start())
            buf_b.write(Std.string(HxString.substr(HxString.substr(cur.matchObj.string,0,cur.matchObj.start()),pos,None)))
            buf_b.write(Std.string(f(cur)))
            right = HxString.substr(cur.matchObj.string,cur.matchObj.end(),None)
            if (not self._hx_global):
                buf_b.write(Std.string(right))
                return buf_b.getvalue()
            if (curPos_len == 0):
                buf_b.write(Std.string(("" if (((pos1 < 0) or ((pos1 >= len(s))))) else s[pos1])))
                right = HxString.substr(right,1,None)
                pos = (pos1 + 1)
            else:
                pos = pos1
        buf_b.write(Std.string(right))
        return buf_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o.matchObj = None
        _hx_o._hx_global = None
EReg._hx_class = EReg
_hx_classes["EReg"] = EReg


class h3d_IDrawable:
    _hx_class_name = "h3d.IDrawable"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["render"]
h3d_IDrawable._hx_class = h3d_IDrawable
_hx_classes["h3d.IDrawable"] = h3d_IDrawable


class hxd_App:
    _hx_class_name = "hxd.App"
    _hx_is_interface = "False"
    __slots__ = ("engine", "s3d", "s2d", "sevents", "isDisposed")
    _hx_fields = ["engine", "s3d", "s2d", "sevents", "isDisposed"]
    _hx_methods = ["onResize", "setScene", "setCurrent", "setScene2D", "setScene3D", "render", "setup", "dispose", "loadAssets", "init", "mainLoop", "update"]
    _hx_statics = ["staticHandler"]
    _hx_interfaces = [h3d_IDrawable]

    def __init__(self):
        self.isDisposed = None
        self.sevents = None
        self.s2d = None
        self.s3d = None
        self.engine = None
        _gthis = self
        engine = h3d_Engine.CURRENT
        if (engine is not None):
            self.engine = engine
            engine.onReady = self.setup
            haxe_Timer.delay(self.setup,0)
        else:
            def _hx_local_0():
                nonlocal engine
                engine = h3d_Engine()
                _gthis.engine = engine
                engine.onReady = _gthis.setup
                engine.init()
            hxd_System.start(_hx_local_0)

    def onResize(self):
        pass

    def setScene(self,scene,disposePrevious = None):
        if (disposePrevious is None):
            disposePrevious = True
        new2D = Std.downcast(scene,h2d_Scene)
        new3D = Std.downcast(scene,h3d_scene_Scene)
        if (new2D is not None):
            self.sevents.removeScene(self.s2d)
            self.sevents.addScene(scene,0)
        else:
            if (new3D is not None):
                self.sevents.removeScene(self.s3d)
            self.sevents.addScene(scene)
        if disposePrevious:
            if (new2D is not None):
                self.s2d.dispose()
            elif (new3D is not None):
                self.s3d.dispose()
            else:
                raise haxe_Exception.thrown("Can't dispose previous scene")
        if (new2D is not None):
            self.s2d = new2D
        if (new3D is not None):
            self.s3d = new3D

    def setCurrent(self):
        _gthis = self
        self.engine = h3d_Engine.CURRENT
        self.isDisposed = False
        self.engine.onReady = hxd_App.staticHandler
        def _hx_local_0():
            if (_gthis.s2d is None):
                return
            _gthis.s2d.checkResize()
            _gthis.onResize()
        self.engine.onResized = _hx_local_0
        hxd_System.setLoop(self.mainLoop)

    def setScene2D(self,s2d,disposePrevious = None):
        if (disposePrevious is None):
            disposePrevious = True
        self.sevents.removeScene(self.s2d)
        self.sevents.addScene(s2d,0)
        if disposePrevious:
            self.s2d.dispose()
        self.s2d = s2d

    def setScene3D(self,s3d,disposePrevious = None):
        if (disposePrevious is None):
            disposePrevious = True
        self.sevents.removeScene(self.s3d)
        self.sevents.addScene(s3d)
        if disposePrevious:
            self.s3d.dispose()
        self.s3d = s3d

    def render(self,e):
        self.s3d.render(e)
        self.s2d.render(e)

    def setup(self):
        _gthis = self
        initDone = False
        self.engine.onReady = hxd_App.staticHandler
        def _hx_local_0():
            if (_gthis.s2d is None):
                return
            _gthis.s2d.checkResize()
            if initDone:
                _gthis.onResize()
        self.engine.onResized = _hx_local_0
        self.s3d = h3d_scene_Scene()
        self.s2d = h2d_Scene()
        self.sevents = hxd_SceneEvents()
        self.sevents.addScene(self.s2d)
        self.sevents.addScene(self.s3d)
        def _hx_local_1():
            nonlocal initDone
            initDone = True
            _gthis.init()
            hxd_Timer.skip()
            _gthis.mainLoop()
            hxd_System.setLoop(_gthis.mainLoop)
            hxd_Key.initialize()
        self.loadAssets(_hx_local_1)

    def dispose(self):
        self.engine.onResized = hxd_App.staticHandler
        self.engine.onContextLost = hxd_App.staticHandler
        self.isDisposed = True
        if (self.s2d is not None):
            self.s2d.dispose()
        if (self.s3d is not None):
            self.s3d.dispose()
        if (self.sevents is not None):
            self.sevents.dispose()

    def loadAssets(self,onLoaded):
        onLoaded()

    def init(self):
        pass

    def mainLoop(self):
        hxd_Timer.update()
        self.sevents.checkEvents()
        if self.isDisposed:
            return
        self.update(hxd_Timer.dt)
        if self.isDisposed:
            return
        dt = hxd_Timer.dt
        if (self.s2d is not None):
            self.s2d.setElapsedTime(dt)
        if (self.s3d is not None):
            self.s3d.setElapsedTime(dt)
        self.engine.render(self)

    def update(self,dt):
        pass

    @staticmethod
    def staticHandler():
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.engine = None
        _hx_o.s3d = None
        _hx_o.s2d = None
        _hx_o.sevents = None
        _hx_o.isDisposed = None
hxd_App._hx_class = hxd_App
_hx_classes["hxd.App"] = hxd_App


class Game(hxd_App):
    _hx_class_name = "Game"
    _hx_is_interface = "False"
    __slots__ = ("screen",)
    _hx_fields = ["screen"]
    _hx_methods = ["init", "setScreen", "update"]
    _hx_statics = ["instance", "get_instance"]
    _hx_interfaces = []
    _hx_super = hxd_App


    def __init__(self):
        self.screen = None
        super().__init__()

    def init(self):
        haxe_Log.trace("Game init()",_hx_AnonObject({'fileName': "src/Game.hx", 'lineNumber': 19, 'className': "Game", 'methodName': "init"}))
        self.setScreen(screens_Menu())

    def setScreen(self,screen):
        self.setScene(screen)
        self.screen = screen
        screen.init()

    def update(self,dt):
        self.screen.update(dt)
    instance = None

    @staticmethod
    def get_instance():
        if (Game.instance is None):
            Game.instance = Game()
        return Game.instance

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.screen = None
Game._hx_class = Game
_hx_classes["Game"] = Game


class Lambda:
    _hx_class_name = "Lambda"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["array"]

    @staticmethod
    def array(it):
        a = list()
        i = HxOverrides.iterator(it)
        while i.hasNext():
            i1 = i.next()
            a.append(i1)
        return a
Lambda._hx_class = Lambda
_hx_classes["Lambda"] = Lambda


class Main(hxd_App):
    _hx_class_name = "Main"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["main"]
    _hx_interfaces = []
    _hx_super = hxd_App


    def __init__(self):
        super().__init__()

    @staticmethod
    def main():
        haxe_Log.trace("Main()",_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 3, 'className': "Main", 'methodName': "main"}))
        hxd_Res.set_loader(hxd_res_Loader(hxd_fs_LocalFileSystem("res",None)))
        Game.get_instance()
Main._hx_class = Main
_hx_classes["Main"] = Main


class Reflect:
    _hx_class_name = "Reflect"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["field", "setField", "callMethod", "isFunction", "compare", "compareMethods", "isObject", "isEnumValue", "deleteField"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def callMethod(o,func,args):
        if callable(func):
            return func(*args)
        else:
            return None

    @staticmethod
    def isFunction(f):
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return python_Boot.hasField(f,"func_code")
        else:
            return True

    @staticmethod
    def compare(a,b):
        if ((a is None) and ((b is None))):
            return 0
        if (a is None):
            return 1
        elif (b is None):
            return -1
        elif HxOverrides.eq(a,b):
            return 0
        elif (a > b):
            return 1
        else:
            return -1

    @staticmethod
    def compareMethods(f1,f2):
        if HxOverrides.eq(f1,f2):
            return True
        if (isinstance(f1,python_internal_MethodClosure) and isinstance(f2,python_internal_MethodClosure)):
            m1 = f1
            m2 = f2
            if HxOverrides.eq(m1.obj,m2.obj):
                return (m1.func == m2.func)
            else:
                return False
        if ((not Reflect.isFunction(f1)) or (not Reflect.isFunction(f2))):
            return False
        return False

    @staticmethod
    def isObject(v):
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 4):
            return True
        elif (tmp == 6):
            _g1 = _g.params[0]
            return True
        else:
            return False

    @staticmethod
    def isEnumValue(v):
        if not HxOverrides.eq(v,Enum):
            return isinstance(v,Enum)
        else:
            return False

    @staticmethod
    def deleteField(o,field):
        if (field in python_Boot.keywords):
            field = ("_hx_" + field)
        elif ((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95))):
            field = ("_hx_" + field)
        if (not python_Boot.hasField(o,field)):
            return False
        o.__delattr__(field)
        return True
Reflect._hx_class = Reflect
_hx_classes["Reflect"] = Reflect


class Std:
    _hx_class_name = "Std"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["downcast", "is", "isOfType", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def downcast(value,c):
        try:
            tmp = None
            if (not isinstance(value,c)):
                if c._hx_is_interface:
                    cls = c
                    loop = None
                    def _hx_local_1(intf):
                        f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                        if (f is not None):
                            _g = 0
                            while (_g < len(f)):
                                i = (f[_g] if _g >= 0 and _g < len(f) else None)
                                _g = (_g + 1)
                                if (i == cls):
                                    return True
                                else:
                                    l = loop(i)
                                    if l:
                                        return True
                            return False
                        else:
                            return False
                    loop = _hx_local_1
                    currentClass = value.__class__
                    result = False
                    while (currentClass is not None):
                        if loop(currentClass):
                            result = True
                            break
                        currentClass = python_Boot.getSuperClass(currentClass)
                    tmp = result
                else:
                    tmp = False
            else:
                tmp = True
            if tmp:
                return value
            else:
                return None
        except BaseException as _g:
            None
            return None

    @staticmethod
    def _hx_is(v,t):
        return Std.isOfType(v,t)

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except BaseException as _g:
            None
            base = 10
            _hx_len = len(x)
            foundCount = 0
            sign = 0
            firstDigitIndex = 0
            lastDigitIndex = -1
            previous = 0
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                c = (-1 if ((i >= len(x))) else ord(x[i]))
                if (((c > 8) and ((c < 14))) or ((c == 32))):
                    if (foundCount > 0):
                        return None
                    continue
                else:
                    c1 = c
                    if (c1 == 43):
                        if (foundCount == 0):
                            sign = 1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 45):
                        if (foundCount == 0):
                            sign = -1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 48):
                        if (not (((foundCount == 0) or (((foundCount == 1) and ((sign != 0))))))):
                            if (not (((48 <= c) and ((c <= 57))))):
                                if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                    break
                    elif ((c1 == 120) or ((c1 == 88))):
                        if ((previous == 48) and ((((foundCount == 1) and ((sign == 0))) or (((foundCount == 2) and ((sign != 0))))))):
                            base = 16
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (not (((48 <= c) and ((c <= 57))))):
                        if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                            break
                if (((foundCount == 0) and ((sign == 0))) or (((foundCount == 1) and ((sign != 0))))):
                    firstDigitIndex = i
                foundCount = (foundCount + 1)
                lastDigitIndex = i
                previous = c
            if (firstDigitIndex <= lastDigitIndex):
                digits = HxString.substring(x,firstDigitIndex,(lastDigitIndex + 1))
                try:
                    return (((-1 if ((sign == -1)) else 1)) * int(digits,base))
                except BaseException as _g:
                    return None
            return None

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except BaseException as _g:
            None
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN
Std._hx_class = Std
_hx_classes["Std"] = Std


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
StringBuf._hx_class = StringBuf
_hx_classes["StringBuf"] = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["htmlEscape", "isSpace", "ltrim", "rtrim", "trim", "lpad", "replace", "hex"]

    @staticmethod
    def htmlEscape(s,quotes = None):
        buf_b = python_lib_io_StringIO()
        _g_offset = 0
        _g_s = s
        while (_g_offset < len(_g_s)):
            index = _g_offset
            _g_offset = (_g_offset + 1)
            code = ord(_g_s[index])
            code1 = code
            if (code1 == 34):
                if quotes:
                    buf_b.write("&quot;")
                else:
                    buf_b.write("".join(map(chr,[code])))
            elif (code1 == 38):
                buf_b.write("&amp;")
            elif (code1 == 39):
                if quotes:
                    buf_b.write("&#039;")
                else:
                    buf_b.write("".join(map(chr,[code])))
            elif (code1 == 60):
                buf_b.write("&lt;")
            elif (code1 == 62):
                buf_b.write("&gt;")
            else:
                buf_b.write("".join(map(chr,[code])))
        return buf_b.getvalue()

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))

    @staticmethod
    def lpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        l = (l - len(s))
        while (buf.get_length() < l):
            s1 = Std.string(c)
            buf.b.write(s1)
        s1 = Std.string(s)
        buf.b.write(s1)
        return buf.b.getvalue()

    @staticmethod
    def replace(s,sub,by):
        _this = (list(s) if ((sub == "")) else s.split(sub))
        return by.join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def hex(n,digits = None):
        s = ""
        hexChars = "0123456789ABCDEF"
        while True:
            index = (n & 15)
            s = (HxOverrides.stringOrNull((("" if (((index < 0) or ((index >= len(hexChars))))) else hexChars[index]))) + ("null" if s is None else s))
            n = HxOverrides.rshift(n, 4)
            if (not ((n > 0))):
                break
        if ((digits is not None) and ((len(s) < digits))):
            diff = (digits - len(s))
            _g = 0
            _g1 = diff
            while (_g < _g1):
                _ = _g
                _g = (_g + 1)
                s = ("0" + ("null" if s is None else s))
        return s
StringTools._hx_class = StringTools
_hx_classes["StringTools"] = StringTools


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["exists", "stat", "rename", "fullPath", "isDirectory", "createDirectory", "deleteFile", "readDirectory"]

    @staticmethod
    def exists(path):
        return python_lib_os_Path.exists(path)

    @staticmethod
    def stat(path):
        s = python_lib_Os.stat(path)
        return _hx_AnonObject({'gid': s.st_gid, 'uid': s.st_uid, 'atime': Date.fromTime((1000 * s.st_atime)), 'mtime': Date.fromTime((1000 * s.st_mtime)), 'ctime': Date.fromTime((1000 * s.st_ctime)), 'size': s.st_size, 'dev': s.st_dev, 'ino': s.st_ino, 'nlink': s.st_nlink, 'rdev': getattr(s,"st_rdev",0), 'mode': s.st_mode})

    @staticmethod
    def rename(path,newPath):
        python_lib_Os.rename(path,newPath)

    @staticmethod
    def fullPath(relPath):
        return python_lib_os_Path.realpath(relPath)

    @staticmethod
    def isDirectory(path):
        return python_lib_os_Path.isdir(path)

    @staticmethod
    def createDirectory(path):
        python_lib_Os.makedirs(path,511,True)

    @staticmethod
    def deleteFile(path):
        python_lib_Os.remove(path)

    @staticmethod
    def readDirectory(path):
        return python_lib_Os.listdir(path)
sys_FileSystem._hx_class = sys_FileSystem
_hx_classes["sys.FileSystem"] = sys_FileSystem


class Sys:
    _hx_class_name = "Sys"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["environ", "get_environ", "getEnv", "systemName", "command", "_programPath", "programPath"]
    environ = None

    @staticmethod
    def get_environ():
        _g = Sys.environ
        if (_g is None):
            environ = haxe_ds_StringMap()
            env = python_lib_Os.environ
            key = python_HaxeIterator(iter(env.keys()))
            while key.hasNext():
                key1 = key.next()
                value = env.get(key1,None)
                environ.h[key1] = value
            def _hx_local_1():
                def _hx_local_0():
                    Sys.environ = environ
                    return Sys.environ
                return _hx_local_0()
            return _hx_local_1()
        else:
            env = _g
            return env

    @staticmethod
    def getEnv(s):
        return Sys.get_environ().h.get(s,None)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            else:
                raise haxe_Exception.thrown("not supported platform")

    @staticmethod
    def command(cmd,args = None):
        if (args is None):
            return python_lib_Subprocess.call(cmd,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'shell': True})))
        else:
            return python_lib_Subprocess.call(([cmd] + args))

    @staticmethod
    def programPath():
        return Sys._programPath
Sys._hx_class = Sys
_hx_classes["Sys"] = Sys

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"
    _hx_constructs = ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, (c,))

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, (e,))
ValueType.TNull = ValueType("TNull", 0, ())
ValueType.TInt = ValueType("TInt", 1, ())
ValueType.TFloat = ValueType("TFloat", 2, ())
ValueType.TBool = ValueType("TBool", 3, ())
ValueType.TObject = ValueType("TObject", 4, ())
ValueType.TFunction = ValueType("TFunction", 5, ())
ValueType.TUnknown = ValueType("TUnknown", 8, ())
ValueType._hx_class = ValueType
_hx_classes["ValueType"] = ValueType


class Type:
    _hx_class_name = "Type"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getClass", "getSuperClass", "getClassName", "getEnumName", "resolveClass", "resolveEnum", "createEmptyInstance", "createEnum", "createEnumIndex", "getEnumConstructs", "typeof", "enumEq", "allEnums"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        o1 = o
        if ((o1 is not None) and ((HxOverrides.eq(o1,str) or python_lib_Inspect.isclass(o1)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,"_hx_class"):
            return o._hx_class
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getSuperClass(c):
        return python_Boot.getSuperClass(c)

    @staticmethod
    def getClassName(c):
        if hasattr(c,"_hx_class_name"):
            return c._hx_class_name
        else:
            if (c == list):
                return "Array"
            if (c == Math):
                return "Math"
            if (c == str):
                return "String"
            try:
                return c.__name__
            except BaseException as _g:
                None
                return None

    @staticmethod
    def getEnumName(e):
        return e._hx_class_name

    @staticmethod
    def resolveClass(name):
        if (name == "Array"):
            return list
        if (name == "Math"):
            return Math
        if (name == "String"):
            return str
        cl = _hx_classes.get(name,None)
        tmp = None
        if (cl is not None):
            o = cl
            tmp = (not (((o is not None) and ((HxOverrides.eq(o,str) or python_lib_Inspect.isclass(o))))))
        else:
            tmp = True
        if tmp:
            return None
        return cl

    @staticmethod
    def resolveEnum(name):
        if (name == "Bool"):
            return Bool
        o = Type.resolveClass(name)
        if hasattr(o,"_hx_constructs"):
            return o
        else:
            return None

    @staticmethod
    def createEmptyInstance(cl):
        i = cl.__new__(cl)
        callInit = None
        def _hx_local_0(cl):
            sc = Type.getSuperClass(cl)
            if (sc is not None):
                callInit(sc)
            if hasattr(cl,"_hx_empty_init"):
                cl._hx_empty_init(i)
        callInit = _hx_local_0
        callInit(cl)
        return i

    @staticmethod
    def createEnum(e,constr,params = None):
        f = Reflect.field(e,constr)
        if (f is None):
            raise haxe_Exception.thrown(("No such constructor " + ("null" if constr is None else constr)))
        if Reflect.isFunction(f):
            if (params is None):
                raise haxe_Exception.thrown((("Constructor " + ("null" if constr is None else constr)) + " need parameters"))
            return Reflect.callMethod(e,f,params)
        if ((params is not None) and ((len(params) != 0))):
            raise haxe_Exception.thrown((("Constructor " + ("null" if constr is None else constr)) + " does not need parameters"))
        return f

    @staticmethod
    def createEnumIndex(e,index,params = None):
        c = python_internal_ArrayImpl._get(e._hx_constructs, index)
        if (c is None):
            raise haxe_Exception.thrown((Std.string(index) + " is not a valid enum constructor index"))
        return Type.createEnum(e,c,params)

    @staticmethod
    def getEnumConstructs(e):
        if hasattr(e,"_hx_constructs"):
            x = e._hx_constructs
            return list(x)
        else:
            return []

    @staticmethod
    def typeof(v):
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown

    @staticmethod
    def enumEq(a,b):
        if HxOverrides.eq(a,b):
            return True
        try:
            if ((b is None) and (not HxOverrides.eq(a,b))):
                return False
            if (a.tag != b.tag):
                return False
            p1 = a.params
            p2 = b.params
            if (len(p1) != len(p2)):
                return False
            _g = 0
            _g1 = len(p1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (not Type.enumEq(p1[i],p2[i])):
                    return False
            if (a._hx_class != b._hx_class):
                return False
        except BaseException as _g:
            None
            return False
        return True

    @staticmethod
    def allEnums(e):
        ctors = Type.getEnumConstructs(e)
        ret = []
        _g = 0
        while (_g < len(ctors)):
            ctor = (ctors[_g] if _g >= 0 and _g < len(ctors) else None)
            _g = (_g + 1)
            v = Reflect.field(e,ctor)
            if Std.isOfType(v,e):
                ret.append(v)
        return ret
Type._hx_class = Type
_hx_classes["Type"] = Type


class _Xml_XmlType_Impl_:
    _hx_class_name = "_Xml.XmlType_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(this1):
        _g = this1
        if (_g == 0):
            return "Element"
        elif (_g == 1):
            return "PCData"
        elif (_g == 2):
            return "CData"
        elif (_g == 3):
            return "Comment"
        elif (_g == 4):
            return "DocType"
        elif (_g == 5):
            return "ProcessingInstruction"
        elif (_g == 6):
            return "Document"
        else:
            pass
_Xml_XmlType_Impl_._hx_class = _Xml_XmlType_Impl_
_hx_classes["_Xml.XmlType_Impl_"] = _Xml_XmlType_Impl_


class Xml:
    _hx_class_name = "Xml"
    _hx_is_interface = "False"
    __slots__ = ("nodeType", "nodeName", "nodeValue", "parent", "children", "attributeMap")
    _hx_fields = ["nodeType", "nodeName", "nodeValue", "parent", "children", "attributeMap"]
    _hx_methods = ["get", "set", "exists", "attributes", "elements", "elementsNamed", "firstElement", "addChild", "removeChild", "toString"]
    _hx_statics = ["Element", "PCData", "CData", "Comment", "DocType", "ProcessingInstruction", "Document", "parse", "createElement", "createPCData", "createCData", "createComment", "createDocType", "createProcessingInstruction", "createDocument"]

    def __init__(self,nodeType):
        self.parent = None
        self.nodeValue = None
        self.nodeName = None
        self.nodeType = nodeType
        self.children = []
        self.attributeMap = haxe_ds_StringMap()

    def get(self,att):
        if (self.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        return self.attributeMap.h.get(att,None)

    def set(self,att,value):
        if (self.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        self.attributeMap.h[att] = value

    def exists(self,att):
        if (self.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        return (att in self.attributeMap.h)

    def attributes(self):
        if (self.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        return self.attributeMap.keys()

    def elements(self):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        _g = []
        _g1 = 0
        _g2 = self.children
        while (_g1 < len(_g2)):
            child = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            if (child.nodeType == Xml.Element):
                _g.append(child)
        ret = _g
        return haxe_iterators_ArrayIterator(ret)

    def elementsNamed(self,name):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        _g = []
        _g1 = 0
        _g2 = self.children
        while (_g1 < len(_g2)):
            child = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            tmp = None
            if (child.nodeType == Xml.Element):
                if (child.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((child.nodeType is None)) else _Xml_XmlType_Impl_.toString(child.nodeType))))))
                tmp = (child.nodeName == name)
            else:
                tmp = False
            if tmp:
                _g.append(child)
        ret = _g
        return haxe_iterators_ArrayIterator(ret)

    def firstElement(self):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            child = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (child.nodeType == Xml.Element):
                return child
        return None

    def addChild(self,x):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        if (x.parent is not None):
            x.parent.removeChild(x)
        _this = self.children
        _this.append(x)
        x.parent = self

    def removeChild(self,x):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((self.nodeType is None)) else _Xml_XmlType_Impl_.toString(self.nodeType))))))
        if python_internal_ArrayImpl.remove(self.children,x):
            x.parent = None
            return True
        return False

    def toString(self):
        return haxe_xml_Printer.print(self)

    @staticmethod
    def parse(_hx_str):
        return haxe_xml_Parser.parse(_hx_str)

    @staticmethod
    def createElement(name):
        xml = Xml(Xml.Element)
        if (xml.nodeType != Xml.Element):
            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeName = name
        return xml

    @staticmethod
    def createPCData(data):
        xml = Xml(Xml.PCData)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createCData(data):
        xml = Xml(Xml.CData)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createComment(data):
        xml = Xml(Xml.Comment)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createDocType(data):
        xml = Xml(Xml.DocType)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createProcessingInstruction(data):
        xml = Xml(Xml.ProcessingInstruction)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((xml.nodeType is None)) else _Xml_XmlType_Impl_.toString(xml.nodeType))))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createDocument():
        return Xml(Xml.Document)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nodeType = None
        _hx_o.nodeName = None
        _hx_o.nodeValue = None
        _hx_o.parent = None
        _hx_o.children = None
        _hx_o.attributeMap = None
Xml._hx_class = Xml
_hx_classes["Xml"] = Xml

class format_gif_Block(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.Block"
    _hx_constructs = ["BFrame", "BExtension", "BEOF"]

    @staticmethod
    def BFrame(frame):
        return format_gif_Block("BFrame", 0, (frame,))

    @staticmethod
    def BExtension(extension):
        return format_gif_Block("BExtension", 1, (extension,))
format_gif_Block.BEOF = format_gif_Block("BEOF", 2, ())
format_gif_Block._hx_class = format_gif_Block
_hx_classes["format.gif.Block"] = format_gif_Block

class format_gif_Extension(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.Extension"
    _hx_constructs = ["EGraphicControl", "EComment", "EText", "EApplicationExtension", "EUnknown"]

    @staticmethod
    def EGraphicControl(gce):
        return format_gif_Extension("EGraphicControl", 0, (gce,))

    @staticmethod
    def EComment(text):
        return format_gif_Extension("EComment", 1, (text,))

    @staticmethod
    def EText(pte):
        return format_gif_Extension("EText", 2, (pte,))

    @staticmethod
    def EApplicationExtension(ext):
        return format_gif_Extension("EApplicationExtension", 3, (ext,))

    @staticmethod
    def EUnknown(id,data):
        return format_gif_Extension("EUnknown", 4, (id,data))
format_gif_Extension._hx_class = format_gif_Extension
_hx_classes["format.gif.Extension"] = format_gif_Extension

class format_gif_ApplicationExtension(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.ApplicationExtension"
    _hx_constructs = ["AENetscapeLooping", "AEUnknown"]

    @staticmethod
    def AENetscapeLooping(loops):
        return format_gif_ApplicationExtension("AENetscapeLooping", 0, (loops,))

    @staticmethod
    def AEUnknown(name,version,data):
        return format_gif_ApplicationExtension("AEUnknown", 1, (name,version,data))
format_gif_ApplicationExtension._hx_class = format_gif_ApplicationExtension
_hx_classes["format.gif.ApplicationExtension"] = format_gif_ApplicationExtension

class format_gif_Version(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.Version"
    _hx_constructs = ["GIF87a", "GIF89a", "Unknown"]

    @staticmethod
    def Unknown(version):
        return format_gif_Version("Unknown", 2, (version,))
format_gif_Version.GIF87a = format_gif_Version("GIF87a", 0, ())
format_gif_Version.GIF89a = format_gif_Version("GIF89a", 1, ())
format_gif_Version._hx_class = format_gif_Version
_hx_classes["format.gif.Version"] = format_gif_Version

class format_gif_DisposalMethod(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.DisposalMethod"
    _hx_constructs = ["UNSPECIFIED", "NO_ACTION", "FILL_BACKGROUND", "RENDER_PREVIOUS", "UNDEFINED"]

    @staticmethod
    def UNDEFINED(index):
        return format_gif_DisposalMethod("UNDEFINED", 4, (index,))
format_gif_DisposalMethod.UNSPECIFIED = format_gif_DisposalMethod("UNSPECIFIED", 0, ())
format_gif_DisposalMethod.NO_ACTION = format_gif_DisposalMethod("NO_ACTION", 1, ())
format_gif_DisposalMethod.FILL_BACKGROUND = format_gif_DisposalMethod("FILL_BACKGROUND", 2, ())
format_gif_DisposalMethod.RENDER_PREVIOUS = format_gif_DisposalMethod("RENDER_PREVIOUS", 3, ())
format_gif_DisposalMethod._hx_class = format_gif_DisposalMethod
_hx_classes["format.gif.DisposalMethod"] = format_gif_DisposalMethod


class format_gif_Reader:
    _hx_class_name = "format.gif.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i",)
    _hx_fields = ["i"]
    _hx_methods = ["read", "readBlock", "readImage", "readPixels", "deinterlace", "readExtension", "readApplicationExtension", "readBlocks", "readColorTable"]

    def __init__(self,i):
        self.i = i
        i.set_bigEndian(False)

    def read(self):
        b = 71
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 73
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 70
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        gifVer = self.i.readString(3)
        version = format_gif_Version.GIF89a
        gifVer1 = gifVer
        if (gifVer1 == "87a"):
            version = format_gif_Version.GIF87a
        elif (gifVer1 == "89a"):
            version = format_gif_Version.GIF89a
        else:
            version = format_gif_Version.Unknown(gifVer)
        width = self.i.readUInt16()
        height = self.i.readUInt16()
        packedField = self.i.readByte()
        bgIndex = self.i.readByte()
        pixelAspectRatio = self.i.readByte()
        if (pixelAspectRatio != 0):
            pixelAspectRatio = (((pixelAspectRatio + 15)) / 64)
        else:
            pixelAspectRatio = 1
        lsd = _hx_AnonObject({'width': width, 'height': height, 'hasGlobalColorTable': (((packedField & 128)) == 128), 'colorResolution': HxOverrides.rshift(((packedField & 112)), 4), 'sorted': (((packedField & 8)) == 8), 'globalColorTableSize': (2 << ((packedField & 7))), 'backgroundColorIndex': bgIndex, 'pixelAspectRatio': pixelAspectRatio})
        gct = None
        if lsd.hasGlobalColorTable:
            gct = self.readColorTable(lsd.globalColorTableSize)
        blocks = haxe_ds_List()
        while True:
            b = self.readBlock()
            blocks.add(b)
            if (b == format_gif_Block.BEOF):
                break
        return _hx_AnonObject({'version': version, 'logicalScreenDescriptor': lsd, 'globalColorTable': gct, 'blocks': blocks})

    def readBlock(self):
        blockID = self.i.readByte()
        blockID1 = blockID
        if (blockID1 == 33):
            return self.readExtension()
        elif (blockID1 == 44):
            return self.readImage()
        elif (blockID1 == 59):
            return format_gif_Block.BEOF
        else:
            pass
        return format_gif_Block.BEOF

    def readImage(self):
        x = self.i.readUInt16()
        y = self.i.readUInt16()
        width = self.i.readUInt16()
        height = self.i.readUInt16()
        packed = self.i.readByte()
        localColorTable = (((packed & 128)) == 128)
        interlaced = (((packed & 64)) == 64)
        sorted = (((packed & 32)) == 32)
        localColorTableSize = (2 << ((packed & 7)))
        lct = None
        if localColorTable:
            lct = self.readColorTable(localColorTableSize)
        return format_gif_Block.BFrame(_hx_AnonObject({'x': x, 'y': y, 'width': width, 'height': height, 'localColorTable': localColorTable, 'interlaced': interlaced, 'sorted': sorted, 'localColorTableSize': localColorTableSize, 'pixels': self.readPixels(width,height,interlaced), 'colorTable': lct}))

    def readPixels(self,width,height,interlaced):
        input = self.i
        pixelsCount = (width * height)
        pixels = haxe_io_Bytes.alloc(pixelsCount)
        minCodeSize = input.readByte()
        blockSize = (input.readByte() - 1)
        bits = input.readByte()
        bitsCount = 8
        clearCode = (1 << minCodeSize)
        eoiCode = (clearCode + 1)
        codeSize = (minCodeSize + 1)
        codeSizeLimit = (1 << codeSize)
        codeMask = (codeSizeLimit - 1)
        baseDict = list()
        _g = 0
        _g1 = clearCode
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(baseDict, i, [i])
        _hx_dict = list()
        dictLen = (clearCode + 2)
        newRecord = None
        i = 0
        code = 0
        last = None
        while (i < pixelsCount):
            last = code
            while (bitsCount < codeSize):
                if (blockSize == 0):
                    break
                bits = (bits | ((input.readByte() << bitsCount)))
                bitsCount = (bitsCount + 8)
                blockSize = (blockSize - 1)
                if (blockSize == 0):
                    blockSize = input.readByte()
            code = (bits & codeMask)
            bits = (bits >> codeSize)
            bitsCount = (bitsCount - codeSize)
            if (code == clearCode):
                _hx_dict = list(baseDict)
                dictLen = (clearCode + 2)
                codeSize = (minCodeSize + 1)
                codeSizeLimit = (1 << codeSize)
                codeMask = (codeSizeLimit - 1)
                continue
            if (code == eoiCode):
                break
            if (code < dictLen):
                if (last != clearCode):
                    newRecord = list((_hx_dict[last] if last >= 0 and last < len(_hx_dict) else None))
                    newRecord.append(python_internal_ArrayImpl._get((_hx_dict[code] if code >= 0 and code < len(_hx_dict) else None), 0))
                    tmp = dictLen
                    dictLen = (dictLen + 1)
                    python_internal_ArrayImpl._set(_hx_dict, tmp, newRecord)
            else:
                if (code != dictLen):
                    raise haxe_Exception.thrown(((("Invalid LZW code. Excepted: " + Std.string(dictLen)) + ", got: ") + Std.string(code)))
                newRecord = list((_hx_dict[last] if last >= 0 and last < len(_hx_dict) else None))
                newRecord.append((newRecord[0] if 0 < len(newRecord) else None))
                tmp1 = dictLen
                dictLen = (dictLen + 1)
                python_internal_ArrayImpl._set(_hx_dict, tmp1, newRecord)
            newRecord = (_hx_dict[code] if code >= 0 and code < len(_hx_dict) else None)
            _g = 0
            while (_g < len(newRecord)):
                item = (newRecord[_g] if _g >= 0 and _g < len(newRecord) else None)
                _g = (_g + 1)
                pos = i
                i = (i + 1)
                pixels.b[pos] = (item & 255)
            if ((dictLen == codeSizeLimit) and ((codeSize < 12))):
                codeSize = (codeSize + 1)
                codeSizeLimit = (1 << codeSize)
                codeMask = (codeSizeLimit - 1)
        while (blockSize > 0):
            input.readByte()
            blockSize = (blockSize - 1)
            if (blockSize == 0):
                blockSize = input.readByte()
        while (i < pixelsCount):
            pos = i
            i = (i + 1)
            pixels.b[pos] = 0
        if interlaced:
            buffer = haxe_io_Bytes.alloc(pixelsCount)
            offset = self.deinterlace(pixels,buffer,8,0,0,width,height)
            offset = self.deinterlace(pixels,buffer,8,4,offset,width,height)
            offset = self.deinterlace(pixels,buffer,4,2,offset,width,height)
            self.deinterlace(pixels,buffer,2,1,offset,width,height)
            pixels = buffer
        return pixels

    def deinterlace(self,input,output,step,y,offset,width,height):
        while (y < height):
            output.blit((y * width),input,offset,width)
            offset = (offset + width)
            y = (y + step)
        return offset

    def readExtension(self):
        subId = self.i.readByte()
        subId1 = subId
        if (subId1 == 1):
            if (self.i.readByte() != 12):
                raise haxe_Exception.thrown("Incorrect size of Plain Text Extension introducer block.")
            tmp = self.i.readUInt16()
            tmp1 = self.i.readUInt16()
            tmp2 = self.i.readUInt16()
            tmp3 = self.i.readUInt16()
            tmp4 = self.i.readByte()
            tmp5 = self.i.readByte()
            tmp6 = self.i.readByte()
            tmp7 = self.i.readByte()
            buffer = haxe_io_BytesOutput()
            _hx_bytes = haxe_io_Bytes.alloc(255)
            _hx_len = self.i.readByte()
            while (_hx_len != 0):
                self.i.readBytes(_hx_bytes,0,_hx_len)
                buffer.writeBytes(_hx_bytes,0,_hx_len)
                _hx_len = self.i.readByte()
            buffer.flush()
            _hx_bytes = buffer.getBytes()
            buffer.close()
            return format_gif_Block.BExtension(format_gif_Extension.EText(_hx_AnonObject({'textGridX': tmp, 'textGridY': tmp1, 'textGridWidth': tmp2, 'textGridHeight': tmp3, 'charCellWidth': tmp4, 'charCellHeight': tmp5, 'textForegroundColorIndex': tmp6, 'textBackgroundColorIndex': tmp7, 'text': _hx_bytes.toString()})))
        elif (subId1 == 249):
            if (self.i.readByte() != 4):
                raise haxe_Exception.thrown("Incorrect Graphic Control Extension block size!")
            packed = self.i.readByte()
            disposalMethod = None
            _g = (((packed & 28)) >> 2)
            if (_g == 0):
                disposalMethod = format_gif_DisposalMethod.UNSPECIFIED
            elif (_g == 1):
                disposalMethod = format_gif_DisposalMethod.NO_ACTION
            elif (_g == 2):
                disposalMethod = format_gif_DisposalMethod.FILL_BACKGROUND
            elif (_g == 3):
                disposalMethod = format_gif_DisposalMethod.RENDER_PREVIOUS
            else:
                disposalMethod = format_gif_DisposalMethod.UNDEFINED((((packed & 28)) >> 2))
            b = format_gif_Block.BExtension(format_gif_Extension.EGraphicControl(_hx_AnonObject({'disposalMethod': disposalMethod, 'userInput': (((packed & 2)) == 2), 'hasTransparentColor': (((packed & 1)) == 1), 'delay': self.i.readUInt16(), 'transparentIndex': self.i.readByte()})))
            self.i.readByte()
            return b
        elif (subId1 == 254):
            buffer = haxe_io_BytesOutput()
            _hx_bytes = haxe_io_Bytes.alloc(255)
            _hx_len = self.i.readByte()
            while (_hx_len != 0):
                self.i.readBytes(_hx_bytes,0,_hx_len)
                buffer.writeBytes(_hx_bytes,0,_hx_len)
                _hx_len = self.i.readByte()
            buffer.flush()
            _hx_bytes = buffer.getBytes()
            buffer.close()
            return format_gif_Block.BExtension(format_gif_Extension.EComment(_hx_bytes.toString()))
        elif (subId1 == 255):
            return self.readApplicationExtension()
        else:
            buffer = haxe_io_BytesOutput()
            _hx_bytes = haxe_io_Bytes.alloc(255)
            _hx_len = self.i.readByte()
            while (_hx_len != 0):
                self.i.readBytes(_hx_bytes,0,_hx_len)
                buffer.writeBytes(_hx_bytes,0,_hx_len)
                _hx_len = self.i.readByte()
            buffer.flush()
            _hx_bytes = buffer.getBytes()
            buffer.close()
            return format_gif_Block.BExtension(format_gif_Extension.EUnknown(subId,_hx_bytes))

    def readApplicationExtension(self):
        if (self.i.readByte() != 11):
            raise haxe_Exception.thrown("Incorrect size of Application Extension introducer block.")
        name = self.i.readString(8)
        version = self.i.readString(3)
        buffer = haxe_io_BytesOutput()
        _hx_bytes = haxe_io_Bytes.alloc(255)
        _hx_len = self.i.readByte()
        while (_hx_len != 0):
            self.i.readBytes(_hx_bytes,0,_hx_len)
            buffer.writeBytes(_hx_bytes,0,_hx_len)
            _hx_len = self.i.readByte()
        buffer.flush()
        _hx_bytes = buffer.getBytes()
        buffer.close()
        data = _hx_bytes
        if (((name == "NETSCAPE") and ((version == "2.0"))) and ((data.b[0] == 1))):
            return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AENetscapeLooping((data.b[1] | ((data.b[2] << 8))))))
        return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AEUnknown(name,version,data)))

    def readBlocks(self):
        buffer = haxe_io_BytesOutput()
        _hx_bytes = haxe_io_Bytes.alloc(255)
        _hx_len = self.i.readByte()
        while (_hx_len != 0):
            self.i.readBytes(_hx_bytes,0,_hx_len)
            buffer.writeBytes(_hx_bytes,0,_hx_len)
            _hx_len = self.i.readByte()
        buffer.flush()
        _hx_bytes = buffer.getBytes()
        buffer.close()
        return _hx_bytes

    def readColorTable(self,size):
        size = (size * 3)
        output = haxe_io_Bytes.alloc(size)
        c = 0
        while (c < size):
            v = self.i.readByte()
            output.b[c] = (v & 255)
            v1 = self.i.readByte()
            output.b[(c + 1)] = (v1 & 255)
            v2 = self.i.readByte()
            output.b[(c + 2)] = (v2 & 255)
            c = (c + 3)
        return output

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
format_gif_Reader._hx_class = format_gif_Reader
_hx_classes["format.gif.Reader"] = format_gif_Reader


class format_gif_Tools:
    _hx_class_name = "format.gif.Tools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["framesCount", "frame", "graphicControl", "extractBGRA", "extractRGBA", "extractFullBGRA", "extractFullRGBA", "loopCount", "LN2", "log2"]

    @staticmethod
    def framesCount(data):
        frames = 0
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            if (block.index == 0):
                _g = block.params[0]
                frames = (frames + 1)
        return frames

    @staticmethod
    def frame(data,frameIndex):
        counter = 0
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            if (block.index == 0):
                frame = block.params[0]
                if (counter == frameIndex):
                    return frame
                counter = (counter + 1)
        return None

    @staticmethod
    def graphicControl(data,frameIndex):
        counter = 0
        gce = None
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                if (counter == frameIndex):
                    return gce
                gce = None
                counter = (counter + 1)
            elif (tmp == 1):
                _g = block.params[0]
                if (_g.index == 0):
                    g = _g.params[0]
                    gce = g
            else:
                pass
        return None

    @staticmethod
    def extractBGRA(data,frameIndex):
        gce = None
        frameCaret = 0
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                if (frameCaret == frameIndex):
                    _hx_bytes = haxe_io_Bytes.alloc(((frame.width * frame.height) * 4))
                    ct = (frame.colorTable if (frame.localColorTable) else Reflect.field(data,"globalColorTable"))
                    if (ct is None):
                        raise haxe_Exception.thrown("Frame does not have a color table!")
                    transparentIndex = ((gce.transparentIndex * 3) if (((gce is not None) and gce.hasTransparentColor)) else -1)
                    writeCaret = 0
                    _g = 0
                    _g1 = frame.pixels.length
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        index = (frame.pixels.b[i] * 3)
                        v = ct.b[(index + 2)]
                        _hx_bytes.b[writeCaret] = (v & 255)
                        v1 = ct.b[(index + 1)]
                        _hx_bytes.b[(writeCaret + 1)] = (v1 & 255)
                        v2 = ct.b[index]
                        _hx_bytes.b[(writeCaret + 2)] = (v2 & 255)
                        if (transparentIndex == index):
                            _hx_bytes.b[(writeCaret + 3)] = 0
                        else:
                            _hx_bytes.b[(writeCaret + 3)] = 255
                        writeCaret = (writeCaret + 4)
                    return _hx_bytes
                frameCaret = (frameCaret + 1)
                gce = None
            elif (tmp == 1):
                ext = block.params[0]
                if (ext.index == 0):
                    g = ext.params[0]
                    gce = g
            else:
                pass
        return None

    @staticmethod
    def extractRGBA(data,frameIndex):
        gce = None
        frameCaret = 0
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                if (frameCaret == frameIndex):
                    _hx_bytes = haxe_io_Bytes.alloc(((frame.width * frame.height) * 4))
                    ct = (frame.colorTable if (frame.localColorTable) else Reflect.field(data,"globalColorTable"))
                    if (ct is None):
                        raise haxe_Exception.thrown("Frame does not have a color table!")
                    transparentIndex = ((gce.transparentIndex * 3) if (((gce is not None) and gce.hasTransparentColor)) else -1)
                    writeCaret = 0
                    _g = 0
                    _g1 = frame.pixels.length
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        index = (frame.pixels.b[i] * 3)
                        v = ct.b[index]
                        _hx_bytes.b[writeCaret] = (v & 255)
                        v1 = ct.b[(index + 1)]
                        _hx_bytes.b[(writeCaret + 1)] = (v1 & 255)
                        v2 = ct.b[(index + 2)]
                        _hx_bytes.b[(writeCaret + 2)] = (v2 & 255)
                        if (transparentIndex == index):
                            _hx_bytes.b[(writeCaret + 3)] = 0
                        else:
                            _hx_bytes.b[(writeCaret + 3)] = 255
                        writeCaret = (writeCaret + 4)
                    return _hx_bytes
                frameCaret = (frameCaret + 1)
                gce = None
            elif (tmp == 1):
                ext = block.params[0]
                if (ext.index == 0):
                    g = ext.params[0]
                    gce = g
            else:
                pass
        return None

    @staticmethod
    def extractFullBGRA(data,frameIndex):
        gce = None
        frameCaret = 0
        _hx_bytes = haxe_io_Bytes.alloc(((data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height) * 4))
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                ct = (frame.colorTable if (frame.localColorTable) else Reflect.field(data,"globalColorTable"))
                if (ct is None):
                    raise haxe_Exception.thrown("Frame does not have a color table!")
                transparentIndex = ((gce.transparentIndex * 3) if (((gce is not None) and gce.hasTransparentColor)) else -1)
                pixels = frame.pixels
                x = 0
                writeCaret = ((((frame.y * data.logicalScreenDescriptor.width) + frame.x)) * 4)
                lineSkip = ((((data.logicalScreenDescriptor.width - frame.width)) * 4) + 4)
                disposalMethod = (gce.disposalMethod if (((frameCaret != frameIndex) and ((gce is not None)))) else format_gif_DisposalMethod.NO_ACTION)
                tmp1 = disposalMethod.index
                if (tmp1 == 2):
                    _g = 0
                    _g1 = pixels.length
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        _hx_bytes.b[writeCaret] = 0
                        _hx_bytes.b[(writeCaret + 1)] = 0
                        _hx_bytes.b[(writeCaret + 2)] = 0
                        _hx_bytes.b[(writeCaret + 3)] = 0
                        x = (x + 1)
                        tmp2 = x
                        if (tmp2 == frame.width):
                            x = 0
                            writeCaret = (writeCaret + lineSkip)
                        else:
                            writeCaret = (writeCaret + 4)
                elif (tmp1 == 3):
                    pass
                else:
                    _g2 = 0
                    _g3 = pixels.length
                    while (_g2 < _g3):
                        i1 = _g2
                        _g2 = (_g2 + 1)
                        index = (pixels.b[i1] * 3)
                        if (transparentIndex != index):
                            v = ct.b[(index + 2)]
                            _hx_bytes.b[writeCaret] = (v & 255)
                            v1 = ct.b[(index + 1)]
                            _hx_bytes.b[(writeCaret + 1)] = (v1 & 255)
                            v2 = ct.b[index]
                            _hx_bytes.b[(writeCaret + 2)] = (v2 & 255)
                            _hx_bytes.b[(writeCaret + 3)] = 255
                        x = (x + 1)
                        tmp3 = x
                        if (tmp3 == frame.width):
                            x = 0
                            writeCaret = (writeCaret + lineSkip)
                        else:
                            writeCaret = (writeCaret + 4)
                if (frameCaret == frameIndex):
                    return _hx_bytes
                frameCaret = (frameCaret + 1)
                gce = None
            elif (tmp == 1):
                ext = block.params[0]
                if (ext.index == 0):
                    g = ext.params[0]
                    gce = g
            else:
                pass
        return _hx_bytes

    @staticmethod
    def extractFullRGBA(data,frameIndex):
        gce = None
        frameCaret = 0
        _hx_bytes = haxe_io_Bytes.alloc(((data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height) * 4))
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                ct = (frame.colorTable if (frame.localColorTable) else Reflect.field(data,"globalColorTable"))
                if (ct is None):
                    raise haxe_Exception.thrown("Frame does not have a color table!")
                transparentIndex = ((gce.transparentIndex * 3) if (((gce is not None) and gce.hasTransparentColor)) else -1)
                pixels = frame.pixels
                x = 0
                writeCaret = ((((frame.y * data.logicalScreenDescriptor.width) + frame.x)) * 4)
                lineSkip = ((((data.logicalScreenDescriptor.width - frame.width)) * 4) + 4)
                disposalMethod = (gce.disposalMethod if (((frameCaret != frameIndex) and ((gce is not None)))) else format_gif_DisposalMethod.NO_ACTION)
                tmp1 = disposalMethod.index
                if (tmp1 == 2):
                    _g = 0
                    _g1 = pixels.length
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        _hx_bytes.b[writeCaret] = 0
                        _hx_bytes.b[(writeCaret + 1)] = 0
                        _hx_bytes.b[(writeCaret + 2)] = 0
                        _hx_bytes.b[(writeCaret + 3)] = 0
                        x = (x + 1)
                        tmp2 = x
                        if (tmp2 == frame.width):
                            x = 0
                            writeCaret = (writeCaret + lineSkip)
                        else:
                            writeCaret = (writeCaret + 4)
                elif (tmp1 == 3):
                    pass
                else:
                    _g2 = 0
                    _g3 = pixels.length
                    while (_g2 < _g3):
                        i1 = _g2
                        _g2 = (_g2 + 1)
                        index = (pixels.b[i1] * 3)
                        if (transparentIndex != index):
                            v = ct.b[index]
                            _hx_bytes.b[writeCaret] = (v & 255)
                            v1 = ct.b[(index + 1)]
                            _hx_bytes.b[(writeCaret + 1)] = (v1 & 255)
                            v2 = ct.b[(index + 2)]
                            _hx_bytes.b[(writeCaret + 2)] = (v2 & 255)
                            _hx_bytes.b[(writeCaret + 3)] = 255
                        x = (x + 1)
                        tmp3 = x
                        if (tmp3 == frame.width):
                            x = 0
                            writeCaret = (writeCaret + lineSkip)
                        else:
                            writeCaret = (writeCaret + 4)
                if (frameCaret == frameIndex):
                    return _hx_bytes
                frameCaret = (frameCaret + 1)
                gce = None
            elif (tmp == 1):
                ext = block.params[0]
                if (ext.index == 0):
                    g = ext.params[0]
                    gce = g
            else:
                pass
        return _hx_bytes

    @staticmethod
    def loopCount(data):
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            if (block.index == 1):
                _g = block.params[0]
                if (_g.index == 3):
                    _g1 = _g.params[0]
                    if (_g1.index == 0):
                        loops = _g1.params[0]
                        return loops
        return 1

    @staticmethod
    def log2(val):
        return (((Math.NEGATIVE_INFINITY if ((val == 0.0)) else (Math.NaN if ((val < 0.0)) else python_lib_Math.log(val)))) / format_gif_Tools.LN2)
format_gif_Tools._hx_class = format_gif_Tools
_hx_classes["format.gif.Tools"] = format_gif_Tools

class format_mp3_SamplingRate(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.SamplingRate"
    _hx_constructs = ["SR_8000", "SR_11025", "SR_12000", "SR_22050", "SR_24000", "SR_32000", "SR_44100", "SR_48000", "SR_Bad"]
format_mp3_SamplingRate.SR_8000 = format_mp3_SamplingRate("SR_8000", 0, ())
format_mp3_SamplingRate.SR_11025 = format_mp3_SamplingRate("SR_11025", 1, ())
format_mp3_SamplingRate.SR_12000 = format_mp3_SamplingRate("SR_12000", 2, ())
format_mp3_SamplingRate.SR_22050 = format_mp3_SamplingRate("SR_22050", 3, ())
format_mp3_SamplingRate.SR_24000 = format_mp3_SamplingRate("SR_24000", 4, ())
format_mp3_SamplingRate.SR_32000 = format_mp3_SamplingRate("SR_32000", 5, ())
format_mp3_SamplingRate.SR_44100 = format_mp3_SamplingRate("SR_44100", 6, ())
format_mp3_SamplingRate.SR_48000 = format_mp3_SamplingRate("SR_48000", 7, ())
format_mp3_SamplingRate.SR_Bad = format_mp3_SamplingRate("SR_Bad", 8, ())
format_mp3_SamplingRate._hx_class = format_mp3_SamplingRate
_hx_classes["format.mp3.SamplingRate"] = format_mp3_SamplingRate

class format_mp3_Bitrate(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.Bitrate"
    _hx_constructs = ["BR_8", "BR_16", "BR_24", "BR_32", "BR_40", "BR_48", "BR_56", "BR_64", "BR_80", "BR_96", "BR_112", "BR_128", "BR_144", "BR_160", "BR_176", "BR_192", "BR_224", "BR_256", "BR_288", "BR_320", "BR_352", "BR_384", "BR_416", "BR_448", "BR_Free", "BR_Bad"]
format_mp3_Bitrate.BR_8 = format_mp3_Bitrate("BR_8", 0, ())
format_mp3_Bitrate.BR_16 = format_mp3_Bitrate("BR_16", 1, ())
format_mp3_Bitrate.BR_24 = format_mp3_Bitrate("BR_24", 2, ())
format_mp3_Bitrate.BR_32 = format_mp3_Bitrate("BR_32", 3, ())
format_mp3_Bitrate.BR_40 = format_mp3_Bitrate("BR_40", 4, ())
format_mp3_Bitrate.BR_48 = format_mp3_Bitrate("BR_48", 5, ())
format_mp3_Bitrate.BR_56 = format_mp3_Bitrate("BR_56", 6, ())
format_mp3_Bitrate.BR_64 = format_mp3_Bitrate("BR_64", 7, ())
format_mp3_Bitrate.BR_80 = format_mp3_Bitrate("BR_80", 8, ())
format_mp3_Bitrate.BR_96 = format_mp3_Bitrate("BR_96", 9, ())
format_mp3_Bitrate.BR_112 = format_mp3_Bitrate("BR_112", 10, ())
format_mp3_Bitrate.BR_128 = format_mp3_Bitrate("BR_128", 11, ())
format_mp3_Bitrate.BR_144 = format_mp3_Bitrate("BR_144", 12, ())
format_mp3_Bitrate.BR_160 = format_mp3_Bitrate("BR_160", 13, ())
format_mp3_Bitrate.BR_176 = format_mp3_Bitrate("BR_176", 14, ())
format_mp3_Bitrate.BR_192 = format_mp3_Bitrate("BR_192", 15, ())
format_mp3_Bitrate.BR_224 = format_mp3_Bitrate("BR_224", 16, ())
format_mp3_Bitrate.BR_256 = format_mp3_Bitrate("BR_256", 17, ())
format_mp3_Bitrate.BR_288 = format_mp3_Bitrate("BR_288", 18, ())
format_mp3_Bitrate.BR_320 = format_mp3_Bitrate("BR_320", 19, ())
format_mp3_Bitrate.BR_352 = format_mp3_Bitrate("BR_352", 20, ())
format_mp3_Bitrate.BR_384 = format_mp3_Bitrate("BR_384", 21, ())
format_mp3_Bitrate.BR_416 = format_mp3_Bitrate("BR_416", 22, ())
format_mp3_Bitrate.BR_448 = format_mp3_Bitrate("BR_448", 23, ())
format_mp3_Bitrate.BR_Free = format_mp3_Bitrate("BR_Free", 24, ())
format_mp3_Bitrate.BR_Bad = format_mp3_Bitrate("BR_Bad", 25, ())
format_mp3_Bitrate._hx_class = format_mp3_Bitrate
_hx_classes["format.mp3.Bitrate"] = format_mp3_Bitrate


class format_mp3_MPEG:
    _hx_class_name = "format.mp3.MPEG"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["V1", "V2", "V25", "Reserved", "enum2Num", "num2Enum", "V1_Bitrates", "V2_Bitrates", "SamplingRates", "srNum2Enum", "srEnum2Num", "getBitrateIdx", "getSamplingRateIdx", "bitrateEnum2Num", "bitrateNum2Enum"]

    @staticmethod
    def enum2Num(m):
        tmp = m.index
        if (tmp == 0):
            return 3
        elif (tmp == 1):
            return 2
        elif (tmp == 2):
            return 0
        elif (tmp == 3):
            return format_mp3_MPEG.Reserved
        else:
            pass

    @staticmethod
    def num2Enum(m):
        m1 = m
        if (m1 == 0):
            return format_mp3_MPEGVersion.MPEG_V25
        elif (m1 == 2):
            return format_mp3_MPEGVersion.MPEG_V2
        elif (m1 == 3):
            return format_mp3_MPEGVersion.MPEG_V1
        else:
            return format_mp3_MPEGVersion.MPEG_Reserved

    @staticmethod
    def srNum2Enum(sr):
        sr1 = sr
        if (sr1 == 8000):
            return format_mp3_SamplingRate.SR_8000
        elif (sr1 == 11025):
            return format_mp3_SamplingRate.SR_11025
        elif (sr1 == 12000):
            return format_mp3_SamplingRate.SR_12000
        elif (sr1 == 22050):
            return format_mp3_SamplingRate.SR_22050
        elif (sr1 == 24000):
            return format_mp3_SamplingRate.SR_24000
        elif (sr1 == 32000):
            return format_mp3_SamplingRate.SR_32000
        elif (sr1 == 44100):
            return format_mp3_SamplingRate.SR_44100
        elif (sr1 == 48000):
            return format_mp3_SamplingRate.SR_48000
        else:
            return format_mp3_SamplingRate.SR_Bad

    @staticmethod
    def srEnum2Num(sr):
        tmp = sr.index
        if (tmp == 0):
            return 8000
        elif (tmp == 1):
            return 11025
        elif (tmp == 2):
            return 12000
        elif (tmp == 3):
            return 22050
        elif (tmp == 4):
            return 24000
        elif (tmp == 5):
            return 32000
        elif (tmp == 6):
            return 44100
        elif (tmp == 7):
            return 48000
        elif (tmp == 8):
            return -1
        else:
            pass

    @staticmethod
    def getBitrateIdx(br,mpeg,layer):
        arr = python_internal_ArrayImpl._get(((format_mp3_MPEG.V1_Bitrates if ((mpeg == format_mp3_MPEGVersion.MPEG_V1)) else format_mp3_MPEG.V2_Bitrates)), format_mp3_CLayer.enum2Num(layer))
        if ((arr[0] if 0 < len(arr) else None) == br):
            return 0
        if ((arr[1] if 1 < len(arr) else None) == br):
            return 1
        if ((arr[2] if 2 < len(arr) else None) == br):
            return 2
        if ((arr[3] if 3 < len(arr) else None) == br):
            return 3
        if ((arr[4] if 4 < len(arr) else None) == br):
            return 4
        if ((arr[5] if 5 < len(arr) else None) == br):
            return 5
        if ((arr[6] if 6 < len(arr) else None) == br):
            return 6
        if ((arr[7] if 7 < len(arr) else None) == br):
            return 7
        if ((arr[8] if 8 < len(arr) else None) == br):
            return 8
        if ((arr[9] if 9 < len(arr) else None) == br):
            return 9
        if ((arr[10] if 10 < len(arr) else None) == br):
            return 10
        if ((arr[11] if 11 < len(arr) else None) == br):
            return 11
        if ((arr[12] if 12 < len(arr) else None) == br):
            return 12
        if ((arr[13] if 13 < len(arr) else None) == br):
            return 13
        if ((arr[14] if 14 < len(arr) else None) == br):
            return 14
        if ((arr[15] if 15 < len(arr) else None) == br):
            return 15
        raise haxe_Exception.thrown("Bitrate index not found")

    @staticmethod
    def getSamplingRateIdx(sr,mpeg):
        arr = python_internal_ArrayImpl._get(format_mp3_MPEG.SamplingRates, format_mp3_MPEG.enum2Num(mpeg))
        if ((arr[0] if 0 < len(arr) else None) == sr):
            return 0
        if ((arr[1] if 1 < len(arr) else None) == sr):
            return 1
        if ((arr[2] if 2 < len(arr) else None) == sr):
            return 2
        if ((arr[3] if 3 < len(arr) else None) == sr):
            return 3
        raise haxe_Exception.thrown("Sampling rate index not found")

    @staticmethod
    def bitrateEnum2Num(br):
        tmp = br.index
        if (tmp == 0):
            return 8
        elif (tmp == 1):
            return 16
        elif (tmp == 2):
            return 24
        elif (tmp == 3):
            return 32
        elif (tmp == 4):
            return 40
        elif (tmp == 5):
            return 48
        elif (tmp == 6):
            return 56
        elif (tmp == 7):
            return 64
        elif (tmp == 8):
            return 80
        elif (tmp == 9):
            return 96
        elif (tmp == 10):
            return 112
        elif (tmp == 11):
            return 128
        elif (tmp == 12):
            return 144
        elif (tmp == 13):
            return 160
        elif (tmp == 14):
            return 176
        elif (tmp == 15):
            return 192
        elif (tmp == 16):
            return 224
        elif (tmp == 17):
            return 256
        elif (tmp == 18):
            return 288
        elif (tmp == 19):
            return 320
        elif (tmp == 20):
            return 352
        elif (tmp == 21):
            return 384
        elif (tmp == 22):
            return 416
        elif (tmp == 23):
            return 448
        elif (tmp == 24):
            return 0
        elif (tmp == 25):
            return -1
        else:
            pass

    @staticmethod
    def bitrateNum2Enum(br):
        br1 = br
        if (br1 == 0):
            return format_mp3_Bitrate.BR_Free
        elif (br1 == 8):
            return format_mp3_Bitrate.BR_8
        elif (br1 == 16):
            return format_mp3_Bitrate.BR_16
        elif (br1 == 24):
            return format_mp3_Bitrate.BR_24
        elif (br1 == 32):
            return format_mp3_Bitrate.BR_32
        elif (br1 == 40):
            return format_mp3_Bitrate.BR_40
        elif (br1 == 48):
            return format_mp3_Bitrate.BR_48
        elif (br1 == 56):
            return format_mp3_Bitrate.BR_56
        elif (br1 == 64):
            return format_mp3_Bitrate.BR_64
        elif (br1 == 80):
            return format_mp3_Bitrate.BR_80
        elif (br1 == 96):
            return format_mp3_Bitrate.BR_96
        elif (br1 == 112):
            return format_mp3_Bitrate.BR_112
        elif (br1 == 128):
            return format_mp3_Bitrate.BR_128
        elif (br1 == 144):
            return format_mp3_Bitrate.BR_144
        elif (br1 == 160):
            return format_mp3_Bitrate.BR_160
        elif (br1 == 176):
            return format_mp3_Bitrate.BR_176
        elif (br1 == 192):
            return format_mp3_Bitrate.BR_192
        elif (br1 == 224):
            return format_mp3_Bitrate.BR_224
        elif (br1 == 256):
            return format_mp3_Bitrate.BR_256
        elif (br1 == 288):
            return format_mp3_Bitrate.BR_288
        elif (br1 == 320):
            return format_mp3_Bitrate.BR_320
        elif (br1 == 352):
            return format_mp3_Bitrate.BR_352
        elif (br1 == 384):
            return format_mp3_Bitrate.BR_384
        elif (br1 == 416):
            return format_mp3_Bitrate.BR_416
        elif (br1 == 448):
            return format_mp3_Bitrate.BR_448
        else:
            return format_mp3_Bitrate.BR_Bad
format_mp3_MPEG._hx_class = format_mp3_MPEG
_hx_classes["format.mp3.MPEG"] = format_mp3_MPEG


class format_mp3_CLayer:
    _hx_class_name = "format.mp3.CLayer"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["LReserved", "LLayer3", "LLayer2", "LLayer1", "enum2Num", "num2Enum"]

    @staticmethod
    def enum2Num(l):
        tmp = l.index
        if (tmp == 0):
            return format_mp3_CLayer.LReserved
        elif (tmp == 1):
            return format_mp3_CLayer.LLayer3
        elif (tmp == 2):
            return format_mp3_CLayer.LLayer2
        elif (tmp == 3):
            return format_mp3_CLayer.LLayer1
        else:
            pass

    @staticmethod
    def num2Enum(l):
        l1 = l
        if (l1 == 1):
            return format_mp3_Layer.Layer3
        elif (l1 == 2):
            return format_mp3_Layer.Layer2
        elif (l1 == 3):
            return format_mp3_Layer.Layer1
        else:
            return format_mp3_Layer.LayerReserved
format_mp3_CLayer._hx_class = format_mp3_CLayer
_hx_classes["format.mp3.CLayer"] = format_mp3_CLayer


class format_mp3_CChannelMode:
    _hx_class_name = "format.mp3.CChannelMode"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["CStereo", "CJointStereo", "CDualChannel", "CMono", "enum2Num", "num2Enum"]

    @staticmethod
    def enum2Num(c):
        tmp = c.index
        if (tmp == 0):
            return 0
        elif (tmp == 1):
            return 1
        elif (tmp == 2):
            return 2
        elif (tmp == 3):
            return 3
        else:
            pass

    @staticmethod
    def num2Enum(c):
        c1 = c
        if (c1 == 0):
            return format_mp3_ChannelMode.Stereo
        elif (c1 == 1):
            return format_mp3_ChannelMode.JointStereo
        elif (c1 == 2):
            return format_mp3_ChannelMode.DualChannel
        elif (c1 == 3):
            return format_mp3_ChannelMode.Mono
        else:
            raise haxe_Exception.thrown("assert")
format_mp3_CChannelMode._hx_class = format_mp3_CChannelMode
_hx_classes["format.mp3.CChannelMode"] = format_mp3_CChannelMode


class format_mp3_CEmphasis:
    _hx_class_name = "format.mp3.CEmphasis"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ENone", "EMs50_15", "EReserved", "ECCIT_J17", "enum2Num", "num2Enum"]

    @staticmethod
    def enum2Num(c):
        tmp = c.index
        if (tmp == 0):
            return 0
        elif (tmp == 1):
            return 1
        elif (tmp == 2):
            return 3
        elif (tmp == 3):
            return 2
        else:
            pass

    @staticmethod
    def num2Enum(c):
        c1 = c
        if (c1 == 0):
            return format_mp3_Emphasis.NoEmphasis
        elif (c1 == 1):
            return format_mp3_Emphasis.Ms50_15
        elif (c1 == 2):
            return format_mp3_Emphasis.InvalidEmphasis
        elif (c1 == 3):
            return format_mp3_Emphasis.CCIT_J17
        else:
            raise haxe_Exception.thrown("assert")
format_mp3_CEmphasis._hx_class = format_mp3_CEmphasis
_hx_classes["format.mp3.CEmphasis"] = format_mp3_CEmphasis

class format_mp3_MPEGVersion(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.MPEGVersion"
    _hx_constructs = ["MPEG_V1", "MPEG_V2", "MPEG_V25", "MPEG_Reserved"]
format_mp3_MPEGVersion.MPEG_V1 = format_mp3_MPEGVersion("MPEG_V1", 0, ())
format_mp3_MPEGVersion.MPEG_V2 = format_mp3_MPEGVersion("MPEG_V2", 1, ())
format_mp3_MPEGVersion.MPEG_V25 = format_mp3_MPEGVersion("MPEG_V25", 2, ())
format_mp3_MPEGVersion.MPEG_Reserved = format_mp3_MPEGVersion("MPEG_Reserved", 3, ())
format_mp3_MPEGVersion._hx_class = format_mp3_MPEGVersion
_hx_classes["format.mp3.MPEGVersion"] = format_mp3_MPEGVersion

class format_mp3_Layer(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.Layer"
    _hx_constructs = ["LayerReserved", "Layer3", "Layer2", "Layer1"]
format_mp3_Layer.LayerReserved = format_mp3_Layer("LayerReserved", 0, ())
format_mp3_Layer.Layer3 = format_mp3_Layer("Layer3", 1, ())
format_mp3_Layer.Layer2 = format_mp3_Layer("Layer2", 2, ())
format_mp3_Layer.Layer1 = format_mp3_Layer("Layer1", 3, ())
format_mp3_Layer._hx_class = format_mp3_Layer
_hx_classes["format.mp3.Layer"] = format_mp3_Layer

class format_mp3_ChannelMode(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.ChannelMode"
    _hx_constructs = ["Stereo", "JointStereo", "DualChannel", "Mono"]
format_mp3_ChannelMode.Stereo = format_mp3_ChannelMode("Stereo", 0, ())
format_mp3_ChannelMode.JointStereo = format_mp3_ChannelMode("JointStereo", 1, ())
format_mp3_ChannelMode.DualChannel = format_mp3_ChannelMode("DualChannel", 2, ())
format_mp3_ChannelMode.Mono = format_mp3_ChannelMode("Mono", 3, ())
format_mp3_ChannelMode._hx_class = format_mp3_ChannelMode
_hx_classes["format.mp3.ChannelMode"] = format_mp3_ChannelMode

class format_mp3_Emphasis(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.Emphasis"
    _hx_constructs = ["NoEmphasis", "Ms50_15", "CCIT_J17", "InvalidEmphasis"]
format_mp3_Emphasis.NoEmphasis = format_mp3_Emphasis("NoEmphasis", 0, ())
format_mp3_Emphasis.Ms50_15 = format_mp3_Emphasis("Ms50_15", 1, ())
format_mp3_Emphasis.CCIT_J17 = format_mp3_Emphasis("CCIT_J17", 2, ())
format_mp3_Emphasis.InvalidEmphasis = format_mp3_Emphasis("InvalidEmphasis", 3, ())
format_mp3_Emphasis._hx_class = format_mp3_Emphasis
_hx_classes["format.mp3.Emphasis"] = format_mp3_Emphasis

class format_mp3_FrameType(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.FrameType"
    _hx_constructs = ["FT_MP3", "FT_NONE"]
format_mp3_FrameType.FT_MP3 = format_mp3_FrameType("FT_MP3", 0, ())
format_mp3_FrameType.FT_NONE = format_mp3_FrameType("FT_NONE", 1, ())
format_mp3_FrameType._hx_class = format_mp3_FrameType
_hx_classes["format.mp3.FrameType"] = format_mp3_FrameType


class format_mp3_Reader:
    _hx_class_name = "format.mp3.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i", "bits", "version", "samples", "sampleSize", "any_read", "id3v2_data", "id3v2_version", "id3v2_flags")
    _hx_fields = ["i", "bits", "version", "samples", "sampleSize", "any_read", "id3v2_data", "id3v2_version", "id3v2_flags"]
    _hx_methods = ["skipID3v2", "seekFrame", "readFrames", "readFrameHeader", "readFrame", "read"]

    def __init__(self,i):
        self.id3v2_flags = None
        self.id3v2_version = None
        self.id3v2_data = None
        self.version = None
        self.i = i
        i.set_bigEndian(True)
        self.bits = format_tools_BitsInput(i)
        self.samples = 0
        self.sampleSize = 0
        self.any_read = False

    def skipID3v2(self):
        self.id3v2_version = self.i.readUInt16()
        self.id3v2_flags = self.i.readByte()
        size = (self.i.readByte() & 127)
        size = ((size << 7) | ((self.i.readByte() & 127)))
        size = ((size << 7) | ((self.i.readByte() & 127)))
        size = ((size << 7) | ((self.i.readByte() & 127)))
        self.id3v2_data = self.i.read(size)

    def seekFrame(self):
        found = False
        try:
            b = None
            while True:
                b = self.i.readByte()
                if (not self.any_read):
                    self.any_read = True
                    if (b == 73):
                        b = self.i.readByte()
                        if (b == 68):
                            b = self.i.readByte()
                            if (b == 51):
                                self.skipID3v2()
                if (b == 255):
                    self.bits.nbits = 0
                    b = self.bits.readBits(3)
                    if (b == 7):
                        return format_mp3_FrameType.FT_MP3
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof):
                return format_mp3_FrameType.FT_NONE
            else:
                raise _g

    def readFrames(self):
        frames = list()
        ft = None
        while True:
            ft = self.seekFrame()
            if (not ((ft != format_mp3_FrameType.FT_NONE))):
                break
            tmp = ft.index
            if (tmp == 0):
                f = self.readFrame()
                if (f is not None):
                    frames.append(f)
            elif (tmp == 1):
                pass
            else:
                pass
        return frames

    def readFrameHeader(self):
        version = self.bits.readBits(2)
        layer = self.bits.readBits(2)
        hasCrc = (not self.bits.readBit())
        if ((version == format_mp3_MPEG.Reserved) or ((layer == format_mp3_CLayer.LReserved))):
            return None
        bitrateIdx = self.bits.readBits(4)
        bitrate = format_mp3_Tools.getBitrate(version,layer,bitrateIdx)
        samplingRateIdx = self.bits.readBits(2)
        samplingRate = format_mp3_Tools.getSamplingRate(version,samplingRateIdx)
        isPadded = self.bits.readBit()
        privateBit = self.bits.readBit()
        if (((bitrate == format_mp3_Bitrate.BR_Bad) or ((bitrate == format_mp3_Bitrate.BR_Free))) or ((samplingRate == format_mp3_SamplingRate.SR_Bad))):
            return None
        channelMode = self.bits.readBits(2)
        isIntensityStereo = self.bits.readBit()
        isMSStereo = self.bits.readBit()
        isCopyrighted = self.bits.readBit()
        isOriginal = self.bits.readBit()
        emphasis = self.bits.readBits(2)
        crc16 = 0
        if hasCrc:
            crc16 = self.i.readUInt16()
        return _hx_AnonObject({'version': format_mp3_MPEG.num2Enum(version), 'layer': format_mp3_CLayer.num2Enum(layer), 'hasCrc': hasCrc, 'crc16': crc16, 'bitrate': bitrate, 'samplingRate': samplingRate, 'isPadded': isPadded, 'privateBit': privateBit, 'channelMode': format_mp3_CChannelMode.num2Enum(channelMode), 'isIntensityStereo': isIntensityStereo, 'isMSStereo': isMSStereo, 'isCopyrighted': isCopyrighted, 'isOriginal': isOriginal, 'emphasis': format_mp3_CEmphasis.num2Enum(emphasis)})

    def readFrame(self):
        header = self.readFrameHeader()
        if ((header is None) or format_mp3_Tools.isInvalidFrameHeader(header)):
            return None
        try:
            data = self.i.read(format_mp3_Tools.getSampleDataSizeHdr(header))
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.samples
            _hx_local_0.samples = (_hx_local_1 + format_mp3_Tools.getSampleCountHdr(header))
            _hx_local_0.samples
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.sampleSize
            _hx_local_2.sampleSize = (_hx_local_3 + data.length)
            _hx_local_2.sampleSize
            return _hx_AnonObject({'header': header, 'data': data})
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof):
                return None
            else:
                raise _g

    def read(self):
        fs = self.readFrames()
        return _hx_AnonObject({'frames': fs, 'sampleCount': self.samples, 'sampleSize': self.sampleSize, 'id3v2': (None if ((self.id3v2_data is None)) else _hx_AnonObject({'versionBytes': self.id3v2_version, 'flagByte': self.id3v2_flags, 'data': self.id3v2_data}))})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.bits = None
        _hx_o.version = None
        _hx_o.samples = None
        _hx_o.sampleSize = None
        _hx_o.any_read = None
        _hx_o.id3v2_data = None
        _hx_o.id3v2_version = None
        _hx_o.id3v2_flags = None
format_mp3_Reader._hx_class = format_mp3_Reader
_hx_classes["format.mp3.Reader"] = format_mp3_Reader


class format_mp3_Tools:
    _hx_class_name = "format.mp3.Tools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getBitrate", "getSamplingRate", "isInvalidFrameHeader", "getSampleDataSize", "getSampleDataSizeHdr", "getSampleCount", "getSampleCountHdr", "getFrameInfo"]

    @staticmethod
    def getBitrate(mpegVersion,layerIdx,bitrateIdx):
        if ((mpegVersion == format_mp3_MPEG.Reserved) or ((layerIdx == format_mp3_CLayer.LReserved))):
            return format_mp3_Bitrate.BR_Bad
        return python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(((format_mp3_MPEG.V1_Bitrates if ((mpegVersion == 3)) else format_mp3_MPEG.V2_Bitrates)), layerIdx), bitrateIdx)

    @staticmethod
    def getSamplingRate(mpegVersion,samplingRateIdx):
        return python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(format_mp3_MPEG.SamplingRates, mpegVersion), samplingRateIdx)

    @staticmethod
    def isInvalidFrameHeader(hdr):
        if (not (((((hdr.version == format_mp3_MPEGVersion.MPEG_Reserved) or ((hdr.layer == format_mp3_Layer.LayerReserved))) or ((hdr.bitrate == format_mp3_Bitrate.BR_Bad))) or ((hdr.bitrate == format_mp3_Bitrate.BR_Free))))):
            return (hdr.samplingRate == format_mp3_SamplingRate.SR_Bad)
        else:
            return True

    @staticmethod
    def getSampleDataSize(mpegVersion,bitrate,samplingRate,isPadded,hasCrc):
        tmp = None
        try:
            tmp = int((((((144 if ((mpegVersion == 3)) else 72)) * bitrate) * 1000) / samplingRate))
        except BaseException as _g:
            None
            tmp = None
        return (((tmp + ((1 if isPadded else 0))) - ((2 if hasCrc else 0))) - 4)

    @staticmethod
    def getSampleDataSizeHdr(hdr):
        return format_mp3_Tools.getSampleDataSize(format_mp3_MPEG.enum2Num(hdr.version),format_mp3_MPEG.bitrateEnum2Num(hdr.bitrate),format_mp3_MPEG.srEnum2Num(hdr.samplingRate),hdr.isPadded,hdr.hasCrc)

    @staticmethod
    def getSampleCount(mpegVersion):
        if (mpegVersion == 3):
            return 1152
        else:
            return 576

    @staticmethod
    def getSampleCountHdr(hdr):
        return format_mp3_Tools.getSampleCount(format_mp3_MPEG.enum2Num(hdr.version))

    @staticmethod
    def getFrameInfo(fr):
        return ((((((((((((((((((Std.string(fr.header.version) + ", ") + Std.string(fr.header.layer)) + ", ") + Std.string(fr.header.channelMode)) + ", ") + Std.string(fr.header.samplingRate)) + " Hz, ") + Std.string(fr.header.bitrate)) + " kbps ") + "Emphasis: ") + Std.string(fr.header.emphasis)) + ", ") + HxOverrides.stringOrNull((("(CRC) " if (fr.header.hasCrc) else "")))) + HxOverrides.stringOrNull((("(Padded) " if (fr.header.isPadded) else "")))) + HxOverrides.stringOrNull((("(Intensity Stereo) " if (fr.header.isIntensityStereo) else "")))) + HxOverrides.stringOrNull((("(MS Stereo) " if (fr.header.isMSStereo) else "")))) + HxOverrides.stringOrNull((("(Copyrighted) " if (fr.header.isCopyrighted) else "")))) + HxOverrides.stringOrNull((("(Original) " if (fr.header.isOriginal) else ""))))
format_mp3_Tools._hx_class = format_mp3_Tools
_hx_classes["format.mp3.Tools"] = format_mp3_Tools

class format_png_Color(Enum):
    __slots__ = ()
    _hx_class_name = "format.png.Color"
    _hx_constructs = ["ColGrey", "ColTrue", "ColIndexed"]

    @staticmethod
    def ColGrey(alpha):
        return format_png_Color("ColGrey", 0, (alpha,))

    @staticmethod
    def ColTrue(alpha):
        return format_png_Color("ColTrue", 1, (alpha,))
format_png_Color.ColIndexed = format_png_Color("ColIndexed", 2, ())
format_png_Color._hx_class = format_png_Color
_hx_classes["format.png.Color"] = format_png_Color

class format_png_Chunk(Enum):
    __slots__ = ()
    _hx_class_name = "format.png.Chunk"
    _hx_constructs = ["CEnd", "CHeader", "CData", "CPalette", "CUnknown"]

    @staticmethod
    def CHeader(h):
        return format_png_Chunk("CHeader", 1, (h,))

    @staticmethod
    def CData(b):
        return format_png_Chunk("CData", 2, (b,))

    @staticmethod
    def CPalette(b):
        return format_png_Chunk("CPalette", 3, (b,))

    @staticmethod
    def CUnknown(id,data):
        return format_png_Chunk("CUnknown", 4, (id,data))
format_png_Chunk.CEnd = format_png_Chunk("CEnd", 0, ())
format_png_Chunk._hx_class = format_png_Chunk
_hx_classes["format.png.Chunk"] = format_png_Chunk


class format_png_Reader:
    _hx_class_name = "format.png.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i", "checkCRC")
    _hx_fields = ["i", "checkCRC"]
    _hx_methods = ["read", "readHeader", "readChunk"]

    def __init__(self,i):
        self.i = i
        i.set_bigEndian(True)
        self.checkCRC = True

    def read(self):
        b = 137
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 80
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 78
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 71
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 13
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 10
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 26
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        b = 10
        if (self.i.readByte() != b):
            raise haxe_Exception.thrown("Invalid header")
        l = haxe_ds_List()
        while True:
            c = self.readChunk()
            l.add(c)
            if (c == format_png_Chunk.CEnd):
                break
        return l

    def readHeader(self,i):
        i.set_bigEndian(True)
        width = i.readInt32()
        height = i.readInt32()
        colbits = i.readByte()
        color = i.readByte()
        color1 = None
        color2 = color
        if (color2 == 0):
            color1 = format_png_Color.ColGrey(False)
        elif (color2 == 2):
            color1 = format_png_Color.ColTrue(False)
        elif (color2 == 3):
            color1 = format_png_Color.ColIndexed
        elif (color2 == 4):
            color1 = format_png_Color.ColGrey(True)
        elif (color2 == 6):
            color1 = format_png_Color.ColTrue(True)
        else:
            raise haxe_Exception.thrown(((("Unknown color model " + Std.string(color)) + ":") + Std.string(colbits)))
        compress = i.readByte()
        _hx_filter = i.readByte()
        if ((compress != 0) or ((_hx_filter != 0))):
            raise haxe_Exception.thrown("Invalid header")
        interlace = i.readByte()
        if ((interlace != 0) and ((interlace != 1))):
            raise haxe_Exception.thrown("Invalid header")
        return _hx_AnonObject({'width': width, 'height': height, 'colbits': colbits, 'color': color1, 'interlaced': (interlace == 1)})

    def readChunk(self):
        dataLen = self.i.readInt32()
        id = self.i.readString(4)
        data = self.i.read(dataLen)
        crc = self.i.readInt32()
        if self.checkCRC:
            c_crc = -1
            tmp = (((c_crc ^ HxString.charCodeAt(id,0))) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            tmp = (((c_crc ^ HxString.charCodeAt(id,1))) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            tmp = (((c_crc ^ HxString.charCodeAt(id,2))) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            tmp = (((c_crc ^ HxString.charCodeAt(id,3))) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            b = data.b
            _g = 0
            _g1 = data.length
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                tmp = (((c_crc ^ b[i])) & 255)
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            if (((c_crc ^ -1)) != crc):
                raise haxe_Exception.thrown("CRC check failure")
        id1 = id
        if (id1 == "IDAT"):
            return format_png_Chunk.CData(data)
        elif (id1 == "IEND"):
            return format_png_Chunk.CEnd
        elif (id1 == "IHDR"):
            return format_png_Chunk.CHeader(self.readHeader(haxe_io_BytesInput(data)))
        elif (id1 == "PLTE"):
            return format_png_Chunk.CPalette(data)
        else:
            return format_png_Chunk.CUnknown(id,data)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.checkCRC = None
format_png_Reader._hx_class = format_png_Reader
_hx_classes["format.png.Reader"] = format_png_Reader


class format_png_Tools:
    _hx_class_name = "format.png.Tools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getHeader", "getPalette", "filter", "reverseBytes", "extractGrey", "extract32", "buildGrey", "buildIndexed", "buildRGB", "build32ARGB", "build32BGRA"]

    @staticmethod
    def getHeader(d):
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            if (c.index == 1):
                h = c.params[0]
                return h
        raise haxe_Exception.thrown("Header not found")

    @staticmethod
    def getPalette(d):
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            if (c.index == 3):
                b = c.params[0]
                return b
        return None

    @staticmethod
    def filter(data,x,y,stride,prev,p,numChannels = None):
        if (numChannels is None):
            numChannels = 4
        b = (0 if ((y == 0)) else data.b[(p - stride)])
        c = (0 if (((x == 0) or ((y == 0)))) else data.b[((p - stride) - numChannels)])
        k = ((prev + b) - c)
        pa = (k - prev)
        if (pa < 0):
            pa = -pa
        pb = (k - b)
        if (pb < 0):
            pb = -pb
        pc = (k - c)
        if (pc < 0):
            pc = -pc
        if ((pa <= pb) and ((pa <= pc))):
            return prev
        elif (pb <= pc):
            return b
        else:
            return c

    @staticmethod
    def reverseBytes(b):
        p = 0
        _g = 0
        _g1 = (b.length >> 2)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            b1 = b.b[p]
            g = b.b[(p + 1)]
            r = b.b[(p + 2)]
            a = b.b[(p + 3)]
            p1 = p
            p = (p + 1)
            b.b[p1] = (a & 255)
            p2 = p
            p = (p + 1)
            b.b[p2] = (r & 255)
            p3 = p
            p = (p + 1)
            b.b[p3] = (g & 255)
            p4 = p
            p = (p + 1)
            b.b[p4] = (b1 & 255)

    @staticmethod
    def extractGrey(d):
        h = format_png_Tools.getHeader(d)
        grey = haxe_io_Bytes.alloc((h.width * h.height))
        data = None
        fullData = None
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            if (c.index == 2):
                b = c.params[0]
                if (fullData is not None):
                    fullData.b.extend(b.b)
                elif (data is None):
                    data = b
                else:
                    fullData = haxe_io_BytesBuffer()
                    fullData.b.extend(data.b)
                    fullData.b.extend(b.b)
                    data = None
        if (fullData is not None):
            data = fullData.getBytes()
        if (data is None):
            raise haxe_Exception.thrown("Data not found")
        data = format_tools_Inflate.run(data)
        r = 0
        w = 0
        _g = h.color
        if (_g.index == 0):
            alpha = _g.params[0]
            if (h.colbits != 8):
                raise haxe_Exception.thrown("Unsupported color mode")
            width = h.width
            stride = ((((2 if alpha else 1)) * width) + 1)
            if (data.length < ((h.height * stride))):
                raise haxe_Exception.thrown("Not enough data")
            rinc = (2 if alpha else 1)
            _g = 0
            _g1 = h.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                f1 = f
                if (f1 == 0):
                    _g2 = 0
                    _g3 = width
                    while (_g2 < _g3):
                        x = _g2
                        _g2 = (_g2 + 1)
                        v = data.b[r]
                        r = (r + rinc)
                        pos1 = w
                        w = (w + 1)
                        grey.b[pos1] = (v & 255)
                elif (f1 == 1):
                    cv = 0
                    _g4 = 0
                    _g5 = width
                    while (_g4 < _g5):
                        x1 = _g4
                        _g4 = (_g4 + 1)
                        cv = (cv + data.b[r])
                        r = (r + rinc)
                        pos2 = w
                        w = (w + 1)
                        grey.b[pos2] = (cv & 255)
                elif (f1 == 2):
                    stride = (0 if ((y == 0)) else width)
                    _g6 = 0
                    _g7 = width
                    while (_g6 < _g7):
                        x2 = _g6
                        _g6 = (_g6 + 1)
                        v1 = (data.b[r] + grey.b[(w - stride)])
                        r = (r + rinc)
                        pos3 = w
                        w = (w + 1)
                        grey.b[pos3] = (v1 & 255)
                elif (f1 == 3):
                    cv1 = 0
                    stride1 = (0 if ((y == 0)) else width)
                    _g8 = 0
                    _g9 = width
                    while (_g8 < _g9):
                        x3 = _g8
                        _g8 = (_g8 + 1)
                        cv1 = ((data.b[r] + (((cv1 + grey.b[(w - stride1)]) >> 1))) & 255)
                        r = (r + rinc)
                        pos4 = w
                        w = (w + 1)
                        grey.b[pos4] = (cv1 & 255)
                elif (f1 == 4):
                    stride2 = width
                    cv2 = 0
                    _g10 = 0
                    _g11 = width
                    while (_g10 < _g11):
                        x4 = _g10
                        _g10 = (_g10 + 1)
                        numChannels = 1
                        if (numChannels is None):
                            numChannels = 4
                        b = (0 if ((y == 0)) else grey.b[(w - stride2)])
                        c = (0 if (((x4 == 0) or ((y == 0)))) else grey.b[((w - stride2) - numChannels)])
                        k = ((cv2 + b) - c)
                        pa = (k - cv2)
                        if (pa < 0):
                            pa = -pa
                        pb = (k - b)
                        if (pb < 0):
                            pb = -pb
                        pc = (k - c)
                        if (pc < 0):
                            pc = -pc
                        cv2 = ((((cv2 if (((pa <= pb) and ((pa <= pc)))) else (b if ((pb <= pc)) else c))) + data.b[r]) & 255)
                        r = (r + rinc)
                        pos5 = w
                        w = (w + 1)
                        grey.b[pos5] = (cv2 & 255)
                else:
                    raise haxe_Exception.thrown(("Invalid filter " + Std.string(f)))
        else:
            raise haxe_Exception.thrown("Unsupported color mode")
        return grey

    @staticmethod
    def extract32(d,_hx_bytes = None,flipY = None):
        h = format_png_Tools.getHeader(d)
        bgra = (haxe_io_Bytes.alloc(((h.width * h.height) * 4)) if ((_hx_bytes is None)) else _hx_bytes)
        data = None
        fullData = None
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            if (c.index == 2):
                b = c.params[0]
                if (fullData is not None):
                    fullData.b.extend(b.b)
                elif (data is None):
                    data = b
                else:
                    fullData = haxe_io_BytesBuffer()
                    fullData.b.extend(data.b)
                    fullData.b.extend(b.b)
                    data = None
        if (fullData is not None):
            data = fullData.getBytes()
        if (data is None):
            raise haxe_Exception.thrown("Data not found")
        data = format_tools_Inflate.run(data)
        r = 0
        w = 0
        lineDelta = 0
        if flipY:
            lineDelta = (-h.width * 8)
            w = (((h.height - 1)) * ((h.width * 4)))
        flipY1 = (-1 if flipY else 1)
        _g = h.color
        tmp = _g.index
        if (tmp == 0):
            alpha = _g.params[0]
            if (h.colbits != 8):
                raise haxe_Exception.thrown("Unsupported color mode")
            width = h.width
            stride = ((((2 if alpha else 1)) * width) + 1)
            if (data.length < ((h.height * stride))):
                raise haxe_Exception.thrown("Not enough data")
            alphvaIdx = -1
            if (not alpha):
                _g1_head = d.h
                while (_g1_head is not None):
                    val = _g1_head.item
                    _g1_head = _g1_head.next
                    t = val
                    if (t.index == 4):
                        if (t.params[0] == "tRNS"):
                            data1 = t.params[1]
                            if (data1.length >= 2):
                                alphvaIdx = data1.b[1]
                            break
            _g1 = 0
            _g2 = h.height
            while (_g1 < _g2):
                y = _g1
                _g1 = (_g1 + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                f1 = f
                if (f1 == 0):
                    if alpha:
                        _g3 = 0
                        _g4 = width
                        while (_g3 < _g4):
                            x = _g3
                            _g3 = (_g3 + 1)
                            pos1 = r
                            r = (r + 1)
                            v = data.b[pos1]
                            pos2 = w
                            w = (w + 1)
                            bgra.b[pos2] = (v & 255)
                            pos3 = w
                            w = (w + 1)
                            bgra.b[pos3] = (v & 255)
                            pos4 = w
                            w = (w + 1)
                            bgra.b[pos4] = (v & 255)
                            pos5 = w
                            w = (w + 1)
                            pos6 = r
                            r = (r + 1)
                            v1 = data.b[pos6]
                            bgra.b[pos5] = (v1 & 255)
                    else:
                        _g5 = 0
                        _g6 = width
                        while (_g5 < _g6):
                            x1 = _g5
                            _g5 = (_g5 + 1)
                            pos7 = r
                            r = (r + 1)
                            v2 = data.b[pos7]
                            pos8 = w
                            w = (w + 1)
                            bgra.b[pos8] = (v2 & 255)
                            pos9 = w
                            w = (w + 1)
                            bgra.b[pos9] = (v2 & 255)
                            pos10 = w
                            w = (w + 1)
                            bgra.b[pos10] = (v2 & 255)
                            pos11 = w
                            w = (w + 1)
                            bgra.b[pos11] = (((0 if ((v2 == alphvaIdx)) else 255)) & 255)
                elif (f1 == 1):
                    cv = 0
                    ca = 0
                    if alpha:
                        _g7 = 0
                        _g8 = width
                        while (_g7 < _g8):
                            x2 = _g7
                            _g7 = (_g7 + 1)
                            pos12 = r
                            r = (r + 1)
                            cv = (cv + data.b[pos12])
                            pos13 = w
                            w = (w + 1)
                            bgra.b[pos13] = (cv & 255)
                            pos14 = w
                            w = (w + 1)
                            bgra.b[pos14] = (cv & 255)
                            pos15 = w
                            w = (w + 1)
                            bgra.b[pos15] = (cv & 255)
                            pos16 = r
                            r = (r + 1)
                            ca = (ca + data.b[pos16])
                            pos17 = w
                            w = (w + 1)
                            bgra.b[pos17] = (ca & 255)
                    else:
                        _g9 = 0
                        _g10 = width
                        while (_g9 < _g10):
                            x3 = _g9
                            _g9 = (_g9 + 1)
                            pos18 = r
                            r = (r + 1)
                            cv = (cv + data.b[pos18])
                            pos19 = w
                            w = (w + 1)
                            bgra.b[pos19] = (cv & 255)
                            pos20 = w
                            w = (w + 1)
                            bgra.b[pos20] = (cv & 255)
                            pos21 = w
                            w = (w + 1)
                            bgra.b[pos21] = (cv & 255)
                            pos22 = w
                            w = (w + 1)
                            bgra.b[pos22] = (((0 if ((cv == alphvaIdx)) else 255)) & 255)
                elif (f1 == 2):
                    stride = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if alpha:
                        _g11 = 0
                        _g12 = width
                        while (_g11 < _g12):
                            x4 = _g11
                            _g11 = (_g11 + 1)
                            pos23 = r
                            r = (r + 1)
                            v3 = (data.b[pos23] + bgra.b[(w - stride)])
                            pos24 = w
                            w = (w + 1)
                            bgra.b[pos24] = (v3 & 255)
                            pos25 = w
                            w = (w + 1)
                            bgra.b[pos25] = (v3 & 255)
                            pos26 = w
                            w = (w + 1)
                            bgra.b[pos26] = (v3 & 255)
                            pos27 = w
                            w = (w + 1)
                            pos28 = r
                            r = (r + 1)
                            v4 = (data.b[pos28] + bgra.b[(w - stride)])
                            bgra.b[pos27] = (v4 & 255)
                    else:
                        _g13 = 0
                        _g14 = width
                        while (_g13 < _g14):
                            x5 = _g13
                            _g13 = (_g13 + 1)
                            pos29 = r
                            r = (r + 1)
                            v5 = (data.b[pos29] + bgra.b[(w - stride)])
                            pos30 = w
                            w = (w + 1)
                            bgra.b[pos30] = (v5 & 255)
                            pos31 = w
                            w = (w + 1)
                            bgra.b[pos31] = (v5 & 255)
                            pos32 = w
                            w = (w + 1)
                            bgra.b[pos32] = (v5 & 255)
                            pos33 = w
                            w = (w + 1)
                            bgra.b[pos33] = (((0 if ((v5 == alphvaIdx)) else 255)) & 255)
                elif (f1 == 3):
                    cv1 = 0
                    ca1 = 0
                    stride1 = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if alpha:
                        _g15 = 0
                        _g16 = width
                        while (_g15 < _g16):
                            x6 = _g15
                            _g15 = (_g15 + 1)
                            pos34 = r
                            r = (r + 1)
                            cv1 = ((data.b[pos34] + (((cv1 + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos35 = w
                            w = (w + 1)
                            bgra.b[pos35] = (cv1 & 255)
                            pos36 = w
                            w = (w + 1)
                            bgra.b[pos36] = (cv1 & 255)
                            pos37 = w
                            w = (w + 1)
                            bgra.b[pos37] = (cv1 & 255)
                            pos38 = r
                            r = (r + 1)
                            ca1 = ((data.b[pos38] + (((ca1 + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos39 = w
                            w = (w + 1)
                            bgra.b[pos39] = (ca1 & 255)
                    else:
                        _g17 = 0
                        _g18 = width
                        while (_g17 < _g18):
                            x7 = _g17
                            _g17 = (_g17 + 1)
                            pos40 = r
                            r = (r + 1)
                            cv1 = ((data.b[pos40] + (((cv1 + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos41 = w
                            w = (w + 1)
                            bgra.b[pos41] = (cv1 & 255)
                            pos42 = w
                            w = (w + 1)
                            bgra.b[pos42] = (cv1 & 255)
                            pos43 = w
                            w = (w + 1)
                            bgra.b[pos43] = (cv1 & 255)
                            pos44 = w
                            w = (w + 1)
                            bgra.b[pos44] = (((0 if ((cv1 == alphvaIdx)) else 255)) & 255)
                elif (f1 == 4):
                    stride2 = ((width * 4) * flipY1)
                    cv2 = 0
                    ca2 = 0
                    if alpha:
                        _g19 = 0
                        _g20 = width
                        while (_g19 < _g20):
                            x8 = _g19
                            _g19 = (_g19 + 1)
                            b = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k = ((cv2 + b) - c)
                            pa = (k - cv2)
                            if (pa < 0):
                                pa = -pa
                            pb = (k - b)
                            if (pb < 0):
                                pb = -pb
                            pc = (k - c)
                            if (pc < 0):
                                pc = -pc
                            pos45 = r
                            r = (r + 1)
                            cv2 = ((((cv2 if (((pa <= pb) and ((pa <= pc)))) else (b if ((pb <= pc)) else c))) + data.b[pos45]) & 255)
                            pos46 = w
                            w = (w + 1)
                            bgra.b[pos46] = (cv2 & 255)
                            pos47 = w
                            w = (w + 1)
                            bgra.b[pos47] = (cv2 & 255)
                            pos48 = w
                            w = (w + 1)
                            bgra.b[pos48] = (cv2 & 255)
                            b1 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c1 = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k1 = ((ca2 + b1) - c1)
                            pa1 = (k1 - ca2)
                            if (pa1 < 0):
                                pa1 = -pa1
                            pb1 = (k1 - b1)
                            if (pb1 < 0):
                                pb1 = -pb1
                            pc1 = (k1 - c1)
                            if (pc1 < 0):
                                pc1 = -pc1
                            pos49 = r
                            r = (r + 1)
                            ca2 = ((((ca2 if (((pa1 <= pb1) and ((pa1 <= pc1)))) else (b1 if ((pb1 <= pc1)) else c1))) + data.b[pos49]) & 255)
                            pos50 = w
                            w = (w + 1)
                            bgra.b[pos50] = (ca2 & 255)
                    else:
                        _g21 = 0
                        _g22 = width
                        while (_g21 < _g22):
                            x9 = _g21
                            _g21 = (_g21 + 1)
                            b2 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c2 = (0 if (((x9 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k2 = ((cv2 + b2) - c2)
                            pa2 = (k2 - cv2)
                            if (pa2 < 0):
                                pa2 = -pa2
                            pb2 = (k2 - b2)
                            if (pb2 < 0):
                                pb2 = -pb2
                            pc2 = (k2 - c2)
                            if (pc2 < 0):
                                pc2 = -pc2
                            pos51 = r
                            r = (r + 1)
                            cv2 = ((((cv2 if (((pa2 <= pb2) and ((pa2 <= pc2)))) else (b2 if ((pb2 <= pc2)) else c2))) + data.b[pos51]) & 255)
                            pos52 = w
                            w = (w + 1)
                            bgra.b[pos52] = (cv2 & 255)
                            pos53 = w
                            w = (w + 1)
                            bgra.b[pos53] = (cv2 & 255)
                            pos54 = w
                            w = (w + 1)
                            bgra.b[pos54] = (cv2 & 255)
                            pos55 = w
                            w = (w + 1)
                            bgra.b[pos55] = (((0 if ((cv2 == alphvaIdx)) else 255)) & 255)
                else:
                    raise haxe_Exception.thrown(("Invalid filter " + Std.string(f)))
                w = (w + lineDelta)
        elif (tmp == 1):
            alpha = _g.params[0]
            if (h.colbits != 8):
                raise haxe_Exception.thrown("Unsupported color mode")
            width = h.width
            stride = ((((4 if alpha else 3)) * width) + 1)
            if (data.length < ((h.height * stride))):
                raise haxe_Exception.thrown("Not enough data")
            alphaRed = -1
            alphaGreen = -1
            alphaBlue = -1
            if (not alpha):
                _g1_head = d.h
                while (_g1_head is not None):
                    val = _g1_head.item
                    _g1_head = _g1_head.next
                    t = val
                    if (t.index == 4):
                        if (t.params[0] == "tRNS"):
                            data1 = t.params[1]
                            if (data1.length >= 6):
                                alphaRed = data1.b[1]
                                alphaGreen = data1.b[3]
                                alphaBlue = data1.b[5]
                            break
            cr = 0
            cg = 0
            cb = 0
            ca = 0
            _g = 0
            _g1 = h.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                f1 = f
                if (f1 == 0):
                    if alpha:
                        _g2 = 0
                        _g3 = width
                        while (_g2 < _g3):
                            x = _g2
                            _g2 = (_g2 + 1)
                            pos1 = w
                            w = (w + 1)
                            v = data.b[(r + 2)]
                            bgra.b[pos1] = (v & 255)
                            pos2 = w
                            w = (w + 1)
                            v1 = data.b[(r + 1)]
                            bgra.b[pos2] = (v1 & 255)
                            pos3 = w
                            w = (w + 1)
                            v2 = data.b[r]
                            bgra.b[pos3] = (v2 & 255)
                            pos4 = w
                            w = (w + 1)
                            v3 = data.b[(r + 3)]
                            bgra.b[pos4] = (v3 & 255)
                            r = (r + 4)
                    else:
                        _g4 = 0
                        _g5 = width
                        while (_g4 < _g5):
                            x1 = _g4
                            _g4 = (_g4 + 1)
                            pos5 = w
                            w = (w + 1)
                            cb = data.b[(r + 2)]
                            bgra.b[pos5] = (cb & 255)
                            pos6 = w
                            w = (w + 1)
                            cg = data.b[(r + 1)]
                            bgra.b[pos6] = (cg & 255)
                            pos7 = w
                            w = (w + 1)
                            cr = data.b[r]
                            bgra.b[pos7] = (cr & 255)
                            pos8 = w
                            w = (w + 1)
                            bgra.b[pos8] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f1 == 1):
                    ca = 0
                    cb = ca
                    cg = cb
                    cr = cg
                    if alpha:
                        _g6 = 0
                        _g7 = width
                        while (_g6 < _g7):
                            x2 = _g6
                            _g6 = (_g6 + 1)
                            cb = (cb + data.b[(r + 2)])
                            pos9 = w
                            w = (w + 1)
                            bgra.b[pos9] = (cb & 255)
                            cg = (cg + data.b[(r + 1)])
                            pos10 = w
                            w = (w + 1)
                            bgra.b[pos10] = (cg & 255)
                            cr = (cr + data.b[r])
                            pos11 = w
                            w = (w + 1)
                            bgra.b[pos11] = (cr & 255)
                            ca = (ca + data.b[(r + 3)])
                            pos12 = w
                            w = (w + 1)
                            bgra.b[pos12] = (ca & 255)
                            r = (r + 4)
                    else:
                        _g8 = 0
                        _g9 = width
                        while (_g8 < _g9):
                            x3 = _g8
                            _g8 = (_g8 + 1)
                            cb = (cb + data.b[(r + 2)])
                            pos13 = w
                            w = (w + 1)
                            bgra.b[pos13] = (cb & 255)
                            cg = (cg + data.b[(r + 1)])
                            pos14 = w
                            w = (w + 1)
                            bgra.b[pos14] = (cg & 255)
                            cr = (cr + data.b[r])
                            pos15 = w
                            w = (w + 1)
                            bgra.b[pos15] = (cr & 255)
                            pos16 = w
                            w = (w + 1)
                            bgra.b[pos16] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f1 == 2):
                    stride = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if alpha:
                        _g10 = 0
                        _g11 = width
                        while (_g10 < _g11):
                            x4 = _g10
                            _g10 = (_g10 + 1)
                            v4 = (data.b[(r + 2)] + bgra.b[(w - stride)])
                            bgra.b[w] = (v4 & 255)
                            w = (w + 1)
                            v5 = (data.b[(r + 1)] + bgra.b[(w - stride)])
                            bgra.b[w] = (v5 & 255)
                            w = (w + 1)
                            v6 = (data.b[r] + bgra.b[(w - stride)])
                            bgra.b[w] = (v6 & 255)
                            w = (w + 1)
                            v7 = (data.b[(r + 3)] + bgra.b[(w - stride)])
                            bgra.b[w] = (v7 & 255)
                            w = (w + 1)
                            r = (r + 4)
                    else:
                        _g12 = 0
                        _g13 = width
                        while (_g12 < _g13):
                            x5 = _g12
                            _g12 = (_g12 + 1)
                            cb = (data.b[(r + 2)] + bgra.b[(w - stride)])
                            bgra.b[w] = (cb & 255)
                            w = (w + 1)
                            cg = (data.b[(r + 1)] + bgra.b[(w - stride)])
                            bgra.b[w] = (cg & 255)
                            w = (w + 1)
                            cr = (data.b[r] + bgra.b[(w - stride)])
                            bgra.b[w] = (cr & 255)
                            w = (w + 1)
                            pos17 = w
                            w = (w + 1)
                            bgra.b[pos17] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f1 == 3):
                    ca = 0
                    cb = ca
                    cg = cb
                    cr = cg
                    stride1 = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if alpha:
                        _g14 = 0
                        _g15 = width
                        while (_g14 < _g15):
                            x6 = _g14
                            _g14 = (_g14 + 1)
                            cb = ((data.b[(r + 2)] + (((cb + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos18 = w
                            w = (w + 1)
                            bgra.b[pos18] = (cb & 255)
                            cg = ((data.b[(r + 1)] + (((cg + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos19 = w
                            w = (w + 1)
                            bgra.b[pos19] = (cg & 255)
                            cr = ((data.b[r] + (((cr + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos20 = w
                            w = (w + 1)
                            bgra.b[pos20] = (cr & 255)
                            ca = ((data.b[(r + 3)] + (((ca + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos21 = w
                            w = (w + 1)
                            bgra.b[pos21] = (ca & 255)
                            r = (r + 4)
                    else:
                        _g16 = 0
                        _g17 = width
                        while (_g16 < _g17):
                            x7 = _g16
                            _g16 = (_g16 + 1)
                            cb = ((data.b[(r + 2)] + (((cb + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos22 = w
                            w = (w + 1)
                            bgra.b[pos22] = (cb & 255)
                            cg = ((data.b[(r + 1)] + (((cg + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos23 = w
                            w = (w + 1)
                            bgra.b[pos23] = (cg & 255)
                            cr = ((data.b[r] + (((cr + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos24 = w
                            w = (w + 1)
                            bgra.b[pos24] = (cr & 255)
                            pos25 = w
                            w = (w + 1)
                            bgra.b[pos25] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f1 == 4):
                    stride2 = ((width * 4) * flipY1)
                    ca = 0
                    cb = ca
                    cg = cb
                    cr = cg
                    if alpha:
                        _g18 = 0
                        _g19 = width
                        while (_g18 < _g19):
                            x8 = _g18
                            _g18 = (_g18 + 1)
                            b = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k = ((cb + b) - c)
                            pa = (k - cb)
                            if (pa < 0):
                                pa = -pa
                            pb = (k - b)
                            if (pb < 0):
                                pb = -pb
                            pc = (k - c)
                            if (pc < 0):
                                pc = -pc
                            cb = ((((cb if (((pa <= pb) and ((pa <= pc)))) else (b if ((pb <= pc)) else c))) + data.b[(r + 2)]) & 255)
                            pos26 = w
                            w = (w + 1)
                            bgra.b[pos26] = (cb & 255)
                            b1 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c1 = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k1 = ((cg + b1) - c1)
                            pa1 = (k1 - cg)
                            if (pa1 < 0):
                                pa1 = -pa1
                            pb1 = (k1 - b1)
                            if (pb1 < 0):
                                pb1 = -pb1
                            pc1 = (k1 - c1)
                            if (pc1 < 0):
                                pc1 = -pc1
                            cg = ((((cg if (((pa1 <= pb1) and ((pa1 <= pc1)))) else (b1 if ((pb1 <= pc1)) else c1))) + data.b[(r + 1)]) & 255)
                            pos27 = w
                            w = (w + 1)
                            bgra.b[pos27] = (cg & 255)
                            b2 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c2 = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k2 = ((cr + b2) - c2)
                            pa2 = (k2 - cr)
                            if (pa2 < 0):
                                pa2 = -pa2
                            pb2 = (k2 - b2)
                            if (pb2 < 0):
                                pb2 = -pb2
                            pc2 = (k2 - c2)
                            if (pc2 < 0):
                                pc2 = -pc2
                            cr = ((((cr if (((pa2 <= pb2) and ((pa2 <= pc2)))) else (b2 if ((pb2 <= pc2)) else c2))) + data.b[r]) & 255)
                            pos28 = w
                            w = (w + 1)
                            bgra.b[pos28] = (cr & 255)
                            b3 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c3 = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k3 = ((ca + b3) - c3)
                            pa3 = (k3 - ca)
                            if (pa3 < 0):
                                pa3 = -pa3
                            pb3 = (k3 - b3)
                            if (pb3 < 0):
                                pb3 = -pb3
                            pc3 = (k3 - c3)
                            if (pc3 < 0):
                                pc3 = -pc3
                            ca = ((((ca if (((pa3 <= pb3) and ((pa3 <= pc3)))) else (b3 if ((pb3 <= pc3)) else c3))) + data.b[(r + 3)]) & 255)
                            pos29 = w
                            w = (w + 1)
                            bgra.b[pos29] = (ca & 255)
                            r = (r + 4)
                    else:
                        _g20 = 0
                        _g21 = width
                        while (_g20 < _g21):
                            x9 = _g20
                            _g20 = (_g20 + 1)
                            b4 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c4 = (0 if (((x9 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k4 = ((cb + b4) - c4)
                            pa4 = (k4 - cb)
                            if (pa4 < 0):
                                pa4 = -pa4
                            pb4 = (k4 - b4)
                            if (pb4 < 0):
                                pb4 = -pb4
                            pc4 = (k4 - c4)
                            if (pc4 < 0):
                                pc4 = -pc4
                            cb = ((((cb if (((pa4 <= pb4) and ((pa4 <= pc4)))) else (b4 if ((pb4 <= pc4)) else c4))) + data.b[(r + 2)]) & 255)
                            pos30 = w
                            w = (w + 1)
                            bgra.b[pos30] = (cb & 255)
                            b5 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c5 = (0 if (((x9 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k5 = ((cg + b5) - c5)
                            pa5 = (k5 - cg)
                            if (pa5 < 0):
                                pa5 = -pa5
                            pb5 = (k5 - b5)
                            if (pb5 < 0):
                                pb5 = -pb5
                            pc5 = (k5 - c5)
                            if (pc5 < 0):
                                pc5 = -pc5
                            cg = ((((cg if (((pa5 <= pb5) and ((pa5 <= pc5)))) else (b5 if ((pb5 <= pc5)) else c5))) + data.b[(r + 1)]) & 255)
                            pos31 = w
                            w = (w + 1)
                            bgra.b[pos31] = (cg & 255)
                            b6 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c6 = (0 if (((x9 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k6 = ((cr + b6) - c6)
                            pa6 = (k6 - cr)
                            if (pa6 < 0):
                                pa6 = -pa6
                            pb6 = (k6 - b6)
                            if (pb6 < 0):
                                pb6 = -pb6
                            pc6 = (k6 - c6)
                            if (pc6 < 0):
                                pc6 = -pc6
                            cr = ((((cr if (((pa6 <= pb6) and ((pa6 <= pc6)))) else (b6 if ((pb6 <= pc6)) else c6))) + data.b[r]) & 255)
                            pos32 = w
                            w = (w + 1)
                            bgra.b[pos32] = (cr & 255)
                            pos33 = w
                            w = (w + 1)
                            bgra.b[pos33] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                else:
                    raise haxe_Exception.thrown(("Invalid filter " + Std.string(f)))
                w = (w + lineDelta)
        elif (tmp == 2):
            pal = format_png_Tools.getPalette(d)
            if (pal is None):
                raise haxe_Exception.thrown("PNG Palette is missing")
            alpha = None
            _g1_head = d.h
            while (_g1_head is not None):
                val = _g1_head.item
                _g1_head = _g1_head.next
                t = val
                if (t.index == 4):
                    if (t.params[0] == "tRNS"):
                        data1 = t.params[1]
                        alpha = data1
                        break
            if ((alpha is not None) and ((alpha.length < ((1 << h.colbits))))):
                alpha2 = haxe_io_Bytes.alloc((1 << h.colbits))
                alpha2.blit(0,alpha,0,alpha.length)
                alpha2.fill(alpha.length,(alpha2.length - alpha.length),255)
                alpha = alpha2
            width = h.width
            stride = (Math.ceil(((width * h.colbits) / 8)) + 1)
            if (data.length < ((h.height * stride))):
                raise haxe_Exception.thrown("Not enough data")
            tmp = (h.width * h.colbits)
            rline = (tmp >> 3)
            _g = 0
            _g1 = h.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                if (f == 0):
                    r = (r + rline)
                    continue
                f1 = f
                if (f1 == 1):
                    c = 0
                    _g2 = 0
                    _g3 = width
                    while (_g2 < _g3):
                        x = _g2
                        _g2 = (_g2 + 1)
                        v = data.b[r]
                        c = (c + v)
                        pos1 = r
                        r = (r + 1)
                        data.b[pos1] = ((c & 255) & 255)
                elif (f1 == 2):
                    stride = (0 if ((y == 0)) else (rline + 1))
                    _g4 = 0
                    _g5 = width
                    while (_g4 < _g5):
                        x1 = _g4
                        _g4 = (_g4 + 1)
                        v1 = data.b[r]
                        v2 = (v1 + data.b[(r - stride)])
                        data.b[r] = (v2 & 255)
                        r = (r + 1)
                elif (f1 == 3):
                    c1 = 0
                    stride1 = (0 if ((y == 0)) else (rline + 1))
                    _g6 = 0
                    _g7 = width
                    while (_g6 < _g7):
                        x2 = _g6
                        _g6 = (_g6 + 1)
                        v3 = data.b[r]
                        c1 = ((v3 + (((c1 + data.b[(r - stride1)]) >> 1))) & 255)
                        pos2 = r
                        r = (r + 1)
                        data.b[pos2] = (c1 & 255)
                elif (f1 == 4):
                    stride2 = (rline + 1)
                    c2 = 0
                    _g8 = 0
                    _g9 = width
                    while (_g8 < _g9):
                        x3 = _g8
                        _g8 = (_g8 + 1)
                        v4 = data.b[r]
                        numChannels = 1
                        if (numChannels is None):
                            numChannels = 4
                        b = (0 if ((y == 0)) else data.b[(r - stride2)])
                        c3 = (0 if (((x3 == 0) or ((y == 0)))) else data.b[((r - stride2) - numChannels)])
                        k = ((c2 + b) - c3)
                        pa = (k - c2)
                        if (pa < 0):
                            pa = -pa
                        pb = (k - b)
                        if (pb < 0):
                            pb = -pb
                        pc = (k - c3)
                        if (pc < 0):
                            pc = -pc
                        c2 = ((((c2 if (((pa <= pb) and ((pa <= pc)))) else (b if ((pb <= pc)) else c3))) + v4) & 255)
                        pos3 = r
                        r = (r + 1)
                        data.b[pos3] = (c2 & 255)
                else:
                    raise haxe_Exception.thrown(("Invalid filter " + Std.string(f)))
            r = 0
            if (h.colbits == 8):
                _g = 0
                _g1 = h.height
                while (_g < _g1):
                    y = _g
                    _g = (_g + 1)
                    r = (r + 1)
                    _g2 = 0
                    _g3 = h.width
                    while (_g2 < _g3):
                        x = _g2
                        _g2 = (_g2 + 1)
                        pos = r
                        r = (r + 1)
                        c = data.b[pos]
                        pos1 = w
                        w = (w + 1)
                        v = pal.b[((c * 3) + 2)]
                        bgra.b[pos1] = (v & 255)
                        pos2 = w
                        w = (w + 1)
                        v1 = pal.b[((c * 3) + 1)]
                        bgra.b[pos2] = (v1 & 255)
                        pos3 = w
                        w = (w + 1)
                        v2 = pal.b[(c * 3)]
                        bgra.b[pos3] = (v2 & 255)
                        pos4 = w
                        w = (w + 1)
                        v3 = (alpha.b[c] if ((alpha is not None)) else 255)
                        bgra.b[pos4] = (v3 & 255)
                    w = (w + lineDelta)
            elif (h.colbits < 8):
                req = h.colbits
                mask = (((1 << req)) - 1)
                _g = 0
                _g1 = h.height
                while (_g < _g1):
                    y = _g
                    _g = (_g + 1)
                    r = (r + 1)
                    bits = 0
                    nbits = 0
                    _g2 = 0
                    _g3 = h.width
                    while (_g2 < _g3):
                        x = _g2
                        _g2 = (_g2 + 1)
                        if (nbits < req):
                            pos = r
                            r = (r + 1)
                            bits = ((bits << 8) | data.b[pos])
                            nbits = (nbits + 8)
                        c = (HxOverrides.rshift(bits, ((nbits - req))) & mask)
                        nbits = (nbits - req)
                        pos1 = w
                        w = (w + 1)
                        v = pal.b[((c * 3) + 2)]
                        bgra.b[pos1] = (v & 255)
                        pos2 = w
                        w = (w + 1)
                        v1 = pal.b[((c * 3) + 1)]
                        bgra.b[pos2] = (v1 & 255)
                        pos3 = w
                        w = (w + 1)
                        v2 = pal.b[(c * 3)]
                        bgra.b[pos3] = (v2 & 255)
                        pos4 = w
                        w = (w + 1)
                        v3 = (alpha.b[c] if ((alpha is not None)) else 255)
                        bgra.b[pos4] = (v3 & 255)
                    w = (w + lineDelta)
            else:
                raise haxe_Exception.thrown((Std.string(h.colbits) + " indexed bits per pixel not supported"))
        else:
            pass
        return bgra

    @staticmethod
    def buildGrey(width,height,data,level = None):
        if (level is None):
            level = 9
        rgb = haxe_io_Bytes.alloc(((width * height) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgb.b[pos] = 0
            _g2 = 0
            _g3 = width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                pos2 = r
                r = (r + 1)
                v = data.b[pos2]
                rgb.b[pos1] = (v & 255)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColGrey(False), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def buildIndexed(width,height,data,palette,level = None):
        if (level is None):
            level = 9
        rgb = haxe_io_Bytes.alloc(((width * height) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgb.b[pos] = 0
            _g2 = 0
            _g3 = width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                pos2 = r
                r = (r + 1)
                v = data.b[pos2]
                rgb.b[pos1] = (v & 255)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColIndexed, 'interlaced': False})))
        l.add(format_png_Chunk.CPalette(palette))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def buildRGB(width,height,data,level = None):
        if (level is None):
            level = 9
        rgb = haxe_io_Bytes.alloc((((width * height) * 3) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgb.b[pos] = 0
            _g2 = 0
            _g3 = width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                v = data.b[(r + 2)]
                rgb.b[pos1] = (v & 255)
                pos2 = w
                w = (w + 1)
                v1 = data.b[(r + 1)]
                rgb.b[pos2] = (v1 & 255)
                pos3 = w
                w = (w + 1)
                v2 = data.b[r]
                rgb.b[pos3] = (v2 & 255)
                r = (r + 3)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColTrue(False), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def build32ARGB(width,height,data,level = None):
        if (level is None):
            level = 9
        rgba = haxe_io_Bytes.alloc((((width * height) * 4) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgba.b[pos] = 0
            _g2 = 0
            _g3 = width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                v = data.b[(r + 1)]
                rgba.b[pos1] = (v & 255)
                pos2 = w
                w = (w + 1)
                v1 = data.b[(r + 2)]
                rgba.b[pos2] = (v1 & 255)
                pos3 = w
                w = (w + 1)
                v2 = data.b[(r + 3)]
                rgba.b[pos3] = (v2 & 255)
                pos4 = w
                w = (w + 1)
                v3 = data.b[r]
                rgba.b[pos4] = (v3 & 255)
                r = (r + 4)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColTrue(True), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def build32BGRA(width,height,data,level = None):
        if (level is None):
            level = 9
        rgba = haxe_io_Bytes.alloc((((width * height) * 4) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgba.b[pos] = 0
            _g2 = 0
            _g3 = width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                v = data.b[(r + 2)]
                rgba.b[pos1] = (v & 255)
                pos2 = w
                w = (w + 1)
                v1 = data.b[(r + 1)]
                rgba.b[pos2] = (v1 & 255)
                pos3 = w
                w = (w + 1)
                v2 = data.b[r]
                rgba.b[pos3] = (v2 & 255)
                pos4 = w
                w = (w + 1)
                v3 = data.b[(r + 3)]
                rgba.b[pos4] = (v3 & 255)
                r = (r + 4)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColTrue(True), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)))
        l.add(format_png_Chunk.CEnd)
        return l
format_png_Tools._hx_class = format_png_Tools
_hx_classes["format.png.Tools"] = format_png_Tools


class format_png_Writer:
    _hx_class_name = "format.png.Writer"
    _hx_is_interface = "False"
    __slots__ = ("o",)
    _hx_fields = ["o"]
    _hx_methods = ["write", "writeChunk"]

    def __init__(self,o):
        self.o = o
        o.set_bigEndian(True)

    def write(self,png):
        b = 137
        self.o.writeByte(b)
        b = 80
        self.o.writeByte(b)
        b = 78
        self.o.writeByte(b)
        b = 71
        self.o.writeByte(b)
        b = 13
        self.o.writeByte(b)
        b = 10
        self.o.writeByte(b)
        b = 26
        self.o.writeByte(b)
        b = 10
        self.o.writeByte(b)
        _g_head = png.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            tmp = c.index
            if (tmp == 0):
                self.writeChunk("IEND",haxe_io_Bytes.alloc(0))
            elif (tmp == 1):
                h = c.params[0]
                b = haxe_io_BytesOutput()
                b.set_bigEndian(True)
                b.writeInt32(h.width)
                b.writeInt32(h.height)
                b.writeByte(h.colbits)
                _g = h.color
                tmp1 = None
                tmp2 = _g.index
                if (tmp2 == 0):
                    alpha = _g.params[0]
                    tmp1 = (4 if alpha else 0)
                elif (tmp2 == 1):
                    alpha1 = _g.params[0]
                    tmp1 = (6 if alpha1 else 2)
                elif (tmp2 == 2):
                    tmp1 = 3
                else:
                    pass
                b.writeByte(tmp1)
                b.writeByte(0)
                b.writeByte(0)
                b.writeByte((1 if (h.interlaced) else 0))
                self.writeChunk("IHDR",b.getBytes())
            elif (tmp == 2):
                d = c.params[0]
                self.writeChunk("IDAT",d)
            elif (tmp == 3):
                b1 = c.params[0]
                self.writeChunk("PLTE",b1)
            elif (tmp == 4):
                id = c.params[0]
                data = c.params[1]
                self.writeChunk(id,data)
            else:
                pass

    def writeChunk(self,id,data):
        self.o.writeInt32(data.length)
        self.o.writeString(id)
        self.o.write(data)
        crc_crc = -1
        tmp = (((crc_crc ^ HxString.charCodeAt(id,0))) & 255)
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        tmp = (((crc_crc ^ HxString.charCodeAt(id,1))) & 255)
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        tmp = (((crc_crc ^ HxString.charCodeAt(id,2))) & 255)
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        tmp = (((crc_crc ^ HxString.charCodeAt(id,3))) & 255)
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        b = data.b
        _g = 0
        _g1 = data.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            tmp = (((crc_crc ^ b[i])) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        self.o.writeInt32((crc_crc ^ -1))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.o = None
format_png_Writer._hx_class = format_png_Writer
_hx_classes["format.png.Writer"] = format_png_Writer

class format_tga_ImageOrigin(Enum):
    __slots__ = ()
    _hx_class_name = "format.tga.ImageOrigin"
    _hx_constructs = ["BottomLeft", "BottomRight", "TopLeft", "TopRight"]
format_tga_ImageOrigin.BottomLeft = format_tga_ImageOrigin("BottomLeft", 0, ())
format_tga_ImageOrigin.BottomRight = format_tga_ImageOrigin("BottomRight", 1, ())
format_tga_ImageOrigin.TopLeft = format_tga_ImageOrigin("TopLeft", 2, ())
format_tga_ImageOrigin.TopRight = format_tga_ImageOrigin("TopRight", 3, ())
format_tga_ImageOrigin._hx_class = format_tga_ImageOrigin
_hx_classes["format.tga.ImageOrigin"] = format_tga_ImageOrigin

class format_tga_ImageType(Enum):
    __slots__ = ()
    _hx_class_name = "format.tga.ImageType"
    _hx_constructs = ["NoImage", "UncompressedColorMapped", "UncompressedTrueColor", "UncompressedBlackAndWhite", "RunLengthColorMapped", "RunLengthTrueColor", "RunLengthBlackAndWhite", "Unknown"]

    @staticmethod
    def Unknown(type):
        return format_tga_ImageType("Unknown", 7, (type,))
format_tga_ImageType.NoImage = format_tga_ImageType("NoImage", 0, ())
format_tga_ImageType.UncompressedColorMapped = format_tga_ImageType("UncompressedColorMapped", 1, ())
format_tga_ImageType.UncompressedTrueColor = format_tga_ImageType("UncompressedTrueColor", 2, ())
format_tga_ImageType.UncompressedBlackAndWhite = format_tga_ImageType("UncompressedBlackAndWhite", 3, ())
format_tga_ImageType.RunLengthColorMapped = format_tga_ImageType("RunLengthColorMapped", 4, ())
format_tga_ImageType.RunLengthTrueColor = format_tga_ImageType("RunLengthTrueColor", 5, ())
format_tga_ImageType.RunLengthBlackAndWhite = format_tga_ImageType("RunLengthBlackAndWhite", 6, ())
format_tga_ImageType._hx_class = format_tga_ImageType
_hx_classes["format.tga.ImageType"] = format_tga_ImageType


class format_tga_Reader:
    _hx_class_name = "format.tga.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i",)
    _hx_fields = ["i"]
    _hx_methods = ["read", "readHeader", "readColorMapData", "readImageData", "readPixels", "readMono", "readIndexes", "parsePixel1", "parsePixelGreyAlpha", "parsePixel2", "parsePixel3", "parsePixel4"]

    def __init__(self,i):
        self.i = i
        i.set_bigEndian(False)

    def read(self):
        idLength = self.i.readByte()
        header = self.readHeader()
        id = ("" if ((idLength == 0)) else self.i.readString(idLength))
        colorMap = self.readColorMapData(header)
        return _hx_AnonObject({'header': header, 'imageId': id, 'colorMapData': colorMap, 'imageData': self.readImageData(header,colorMap), 'developerData': None})

    def readHeader(self):
        colorMapType = self.i.readByte()
        dataType = None
        dataId = self.i.readByte()
        dataId1 = dataId
        if (dataId1 == 0):
            dataType = format_tga_ImageType.NoImage
        elif (dataId1 == 1):
            dataType = format_tga_ImageType.UncompressedColorMapped
        elif (dataId1 == 2):
            dataType = format_tga_ImageType.UncompressedTrueColor
        elif (dataId1 == 3):
            dataType = format_tga_ImageType.UncompressedBlackAndWhite
        elif (dataId1 == 9):
            dataType = format_tga_ImageType.RunLengthColorMapped
        elif (dataId1 == 10):
            dataType = format_tga_ImageType.RunLengthTrueColor
        elif (dataId1 == 11):
            dataType = format_tga_ImageType.RunLengthBlackAndWhite
        else:
            dataType = format_tga_ImageType.Unknown(dataId)
        colorMapOrigin = self.i.readInt16()
        colorMapLength = self.i.readInt16()
        colorMapDepth = self.i.readByte()
        xOrigin = self.i.readInt16()
        yOrigin = self.i.readInt16()
        width = self.i.readInt16()
        height = self.i.readInt16()
        depth = self.i.readByte()
        descriptor = self.i.readByte()
        origin = None
        _g = (descriptor & 48)
        if (_g == 16):
            origin = format_tga_ImageOrigin.BottomRight
        elif (_g == 32):
            origin = format_tga_ImageOrigin.TopLeft
        elif (_g == 48):
            origin = format_tga_ImageOrigin.TopRight
        else:
            origin = format_tga_ImageOrigin.BottomLeft
        return _hx_AnonObject({'colorMapType': colorMapType, 'imageType': dataType, 'colorMapFirstIndex': colorMapOrigin, 'colorMapLength': colorMapLength, 'colorMapEntrySize': colorMapDepth, 'xOrigin': xOrigin, 'yOrigin': yOrigin, 'width': width, 'height': height, 'bitsPerPixel': depth, 'alphaChannelBits': (descriptor & 15), 'imageOrigin': origin})

    def readColorMapData(self,header):
        if (header.colorMapType == 0):
            return None
        return self.readPixels(header.colorMapEntrySize,header.colorMapLength,header.alphaChannelBits,False)

    def readImageData(self,header,colorMap):
        tmp = header.imageType.index
        if (tmp == 0):
            return None
        elif (tmp == 1):
            return self.readIndexes(header.bitsPerPixel,(header.width * header.height),colorMap,header.colorMapFirstIndex,False)
        elif (tmp == 2):
            return self.readPixels(header.bitsPerPixel,(header.width * header.height),header.alphaChannelBits,False)
        elif (tmp == 3):
            return self.readMono(header.bitsPerPixel,(header.width * header.height),header.alphaChannelBits,False)
        elif (tmp == 4):
            return self.readIndexes(header.bitsPerPixel,(header.width * header.height),colorMap,header.colorMapFirstIndex,True)
        elif (tmp == 5):
            return self.readPixels(header.bitsPerPixel,(header.width * header.height),header.alphaChannelBits,True)
        elif (tmp == 6):
            return self.readMono(header.bitsPerPixel,(header.width * header.height),header.alphaChannelBits,True)
        else:
            raise haxe_Exception.thrown("Unsupported image data type!")

    def readPixels(self,bitsPerPixel,amount,alphaChannelBits,rle):
        this1 = [None]*amount
        _hx_list = this1
        alpha = (alphaChannelBits != 0)
        bitFieldSize = None
        try:
            bitFieldSize = int((bitsPerPixel / 3))
        except BaseException as _g:
            None
            bitFieldSize = None
        bitFieldSize1 = bitFieldSize
        if (bitFieldSize1 > 8):
            bitFieldSize1 = 8
        parsePixel = None
        readEntry = None
        bitsPerPixel1 = bitsPerPixel
        if (bitsPerPixel1 == 8):
            readEntry = self.i.readByte
            parsePixel = self.parsePixel1
        elif (bitsPerPixel1 == 16):
            readEntry = self.i.readUInt16
            parsePixel = self.parsePixel2
        elif (bitsPerPixel1 == 24):
            readEntry = self.i.readUInt24
            parsePixel = self.parsePixel3
        elif (bitsPerPixel1 == 32):
            readEntry = self.i.readInt32
            parsePixel = self.parsePixel4
        else:
            raise haxe_Exception.thrown("Unsupported bits per pixels amount!")
        if rle:
            rleChunk = None
            i = 0
            while (i < amount):
                rleChunk = self.i.readByte()
                if (((rleChunk & 128)) != 0):
                    rleChunk = (rleChunk & 127)
                    pixel = parsePixel(readEntry(),alpha)
                    while (rleChunk >= 0):
                        index = i
                        i = (i + 1)
                        _hx_list[index] = pixel
                        rleChunk = (rleChunk - 1)
                else:
                    rleChunk = (rleChunk & 127)
                    while (rleChunk >= 0):
                        index1 = i
                        i = (i + 1)
                        val = parsePixel(readEntry(),alpha)
                        _hx_list[index1] = val
                        rleChunk = (rleChunk - 1)
        else:
            _g = 0
            _g1 = amount
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                val = parsePixel(readEntry(),alpha)
                _hx_list[i] = val
        return _hx_list

    def readMono(self,bitsPerPixel,amount,alphaChannelBits,rle):
        this1 = [None]*amount
        _hx_list = this1
        alpha = (alphaChannelBits != 0)
        parsePixel = None
        readEntry = None
        bitsPerPixel1 = bitsPerPixel
        if (bitsPerPixel1 == 8):
            readEntry = self.i.readByte
            parsePixel = self.parsePixel1
        elif (bitsPerPixel1 == 16):
            readEntry = self.i.readUInt16
            parsePixel = self.parsePixelGreyAlpha
        else:
            raise haxe_Exception.thrown("Unsupported bits per pixels amount!")
        if rle:
            rleChunk = None
            i = 0
            while (i < amount):
                rleChunk = self.i.readByte()
                if (((rleChunk & 128)) != 0):
                    rleChunk = (rleChunk & 127)
                    pixel = parsePixel(readEntry(),alpha)
                    while (rleChunk >= 0):
                        index = i
                        i = (i + 1)
                        _hx_list[index] = pixel
                        rleChunk = (rleChunk - 1)
                else:
                    rleChunk = (rleChunk & 127)
                    while (rleChunk >= 0):
                        index1 = i
                        i = (i + 1)
                        val = parsePixel(readEntry(),alpha)
                        _hx_list[index1] = val
                        rleChunk = (rleChunk - 1)
        else:
            _g = 0
            _g1 = amount
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                val = parsePixel(readEntry(),alpha)
                _hx_list[i] = val
        return _hx_list

    def readIndexes(self,bitsPerPixel,amount,colorMap,offset,rle):
        this1 = [None]*amount
        _hx_list = this1
        readEntry = None
        bitsPerPixel1 = bitsPerPixel
        if (bitsPerPixel1 == 8):
            readEntry = self.i.readByte
        elif (bitsPerPixel1 == 16):
            readEntry = self.i.readUInt16
        elif (bitsPerPixel1 == 24):
            readEntry = self.i.readUInt24
        elif (bitsPerPixel1 == 32):
            readEntry = self.i.readInt32
        else:
            raise haxe_Exception.thrown("Unsupported bits per pixels amount!")
        if rle:
            i = 0
            rleChunk = None
            while (i < amount):
                rleChunk = self.i.readByte()
                if (((rleChunk & 128)) != 0):
                    rleChunk = (rleChunk & 127)
                    pixel = colorMap[(offset + readEntry())]
                    while (rleChunk >= 0):
                        index = i
                        i = (i + 1)
                        _hx_list[index] = pixel
                        rleChunk = (rleChunk - 1)
                else:
                    rleChunk = (rleChunk & 127)
                    while (rleChunk >= 0):
                        index1 = i
                        i = (i + 1)
                        val = colorMap[(offset + readEntry())]
                        _hx_list[index1] = val
                        rleChunk = (rleChunk - 1)
        else:
            _g = 0
            _g1 = amount
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                val = colorMap[(offset + readEntry())]
                _hx_list[i] = val
        return _hx_list

    def parsePixel1(self,value,alpha):
        return (((value << 16) | ((value << 8))) | value)

    def parsePixelGreyAlpha(self,value,alpha):
        return ((((((value & 65280)) << 16) if alpha else 0)) | self.parsePixel1((value & 255),False))

    def parsePixel2(self,value,alpha):
        tmp = ((-16777216 if ((((value & 32768)) == 1)) else 0) if alpha else 0)
        tmp1 = None
        try:
            tmp1 = int(((((((value & 31744)) >> 10)) / 31) * 255))
        except BaseException as _g:
            None
            tmp1 = None
        tmp2 = (tmp | ((tmp1 << 16)))
        tmp = None
        try:
            tmp = int(((((((value & 992)) >> 5)) / 31) * 255))
        except BaseException as _g:
            None
            tmp = None
        tmp1 = (tmp2 | ((tmp << 8)))
        tmp = None
        try:
            tmp = int(((((value & 31)) / 31) * 255))
        except BaseException as _g:
            None
            tmp = None
        return (tmp1 | tmp)

    def parsePixel3(self,value,alpha):
        return value

    def parsePixel4(self,value,alpha):
        return value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
format_tga_Reader._hx_class = format_tga_Reader
_hx_classes["format.tga.Reader"] = format_tga_Reader


class format_tools_BitsInput:
    _hx_class_name = "format.tools.BitsInput"
    _hx_is_interface = "False"
    __slots__ = ("i", "nbits", "bits")
    _hx_fields = ["i", "nbits", "bits"]
    _hx_methods = ["readBits", "readBit", "reset"]

    def __init__(self,i):
        self.i = i
        self.nbits = 0
        self.bits = 0

    def readBits(self,n):
        if (self.nbits >= n):
            c = (self.nbits - n)
            k = (HxOverrides.rshift(self.bits, c) & ((((1 << n)) - 1)))
            self.nbits = c
            return k
        k = self.i.readByte()
        if (self.nbits >= 24):
            if (n > 31):
                raise haxe_Exception.thrown("Bits error")
            c = ((8 + self.nbits) - n)
            d = (self.bits & ((((1 << self.nbits)) - 1)))
            d = ((d << ((8 - c))) | ((k << c)))
            self.bits = k
            self.nbits = c
            return d
        self.bits = ((self.bits << 8) | k)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nbits
        _hx_local_0.nbits = (_hx_local_1 + 8)
        _hx_local_0.nbits
        return self.readBits(n)

    def readBit(self):
        if (self.nbits == 0):
            self.bits = self.i.readByte()
            self.nbits = 8
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nbits
        _hx_local_0.nbits = (_hx_local_1 - 1)
        _hx_local_1
        return (((HxOverrides.rshift(self.bits, self.nbits) & 1)) == 1)

    def reset(self):
        self.nbits = 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.nbits = None
        _hx_o.bits = None
format_tools_BitsInput._hx_class = format_tools_BitsInput
_hx_classes["format.tools.BitsInput"] = format_tools_BitsInput


class format_tools_Deflate:
    _hx_class_name = "format.tools.Deflate"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(b,level = None):
        if (level is None):
            level = 9
        return haxe_zip_Compress.run(b,level)
format_tools_Deflate._hx_class = format_tools_Deflate
_hx_classes["format.tools.Deflate"] = format_tools_Deflate


class format_tools_Inflate:
    _hx_class_name = "format.tools.Inflate"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(_hx_bytes):
        return haxe_zip_Uncompress.run(_hx_bytes)
format_tools_Inflate._hx_class = format_tools_Inflate
_hx_classes["format.tools.Inflate"] = format_tools_Inflate

class format_wav_WAVEFormat(Enum):
    __slots__ = ()
    _hx_class_name = "format.wav.WAVEFormat"
    _hx_constructs = ["WF_PCM"]
format_wav_WAVEFormat.WF_PCM = format_wav_WAVEFormat("WF_PCM", 0, ())
format_wav_WAVEFormat._hx_class = format_wav_WAVEFormat
_hx_classes["format.wav.WAVEFormat"] = format_wav_WAVEFormat


class format_wav_Reader:
    _hx_class_name = "format.wav.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i", "version")
    _hx_fields = ["i", "version"]
    _hx_methods = ["readInt", "read"]

    def __init__(self,i):
        self.version = None
        self.i = i
        i.set_bigEndian(False)

    def readInt(self):
        return self.i.readInt32()

    def read(self):
        if (self.i.readString(4) != "RIFF"):
            raise haxe_Exception.thrown("RIFF header expected")
        _hx_len = self.i.readInt32()
        if (self.i.readString(4) != "WAVE"):
            raise haxe_Exception.thrown("WAVE signature not found")
        fmt = self.i.readString(4)
        while (fmt != "fmt "):
            fmt1 = fmt
            if (fmt1 == "JUNK"):
                junkLen = self.i.readInt32()
                self.i.read(junkLen)
                fmt = self.i.readString(4)
            elif (fmt1 == "bext"):
                bextLen = self.i.readInt32()
                self.i.read(bextLen)
                fmt = self.i.readString(4)
            else:
                break
        if (fmt != "fmt "):
            raise haxe_Exception.thrown(("unsupported wave chunk " + ("null" if fmt is None else fmt)))
        fmtlen = self.i.readInt32()
        format = None
        _g = self.i.readUInt16()
        if ((_g == 3) or ((_g == 1))):
            format = format_wav_WAVEFormat.WF_PCM
        else:
            raise haxe_Exception.thrown("only PCM (uncompressed) WAV files are supported")
        channels = self.i.readUInt16()
        samplingRate = self.i.readInt32()
        byteRate = self.i.readInt32()
        blockAlign = self.i.readUInt16()
        bitsPerSample = self.i.readUInt16()
        if (fmtlen > 16):
            self.i.read((fmtlen - 16))
        nextChunk = self.i.readString(4)
        while (nextChunk != "data"):
            self.i.read(self.i.readInt32())
            nextChunk = self.i.readString(4)
        if (nextChunk != "data"):
            raise haxe_Exception.thrown("expected data subchunk")
        datalen = self.i.readInt32()
        data = None
        try:
            data = self.i.read(datalen)
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof):
                raise haxe_Exception.thrown("Invalid chunk data length")
            else:
                raise _g
        cuePoints = list()
        try:
            while True:
                nextChunk = self.i.readString(4)
                if (nextChunk == "cue "):
                    self.i.readInt32()
                    nbCuePoints = self.i.readInt32()
                    _g = 0
                    _g1 = nbCuePoints
                    while (_g < _g1):
                        _ = _g
                        _g = (_g + 1)
                        cueId = self.i.readInt32()
                        self.i.readInt32()
                        self.i.readString(4)
                        self.i.readInt32()
                        self.i.readInt32()
                        cueSampleOffset = self.i.readInt32()
                        cuePoints.append(_hx_AnonObject({'id': cueId, 'sampleOffset': cueSampleOffset}))
                else:
                    self.i.read(self.i.readInt32())
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return _hx_AnonObject({'header': _hx_AnonObject({'format': format, 'channels': channels, 'samplingRate': samplingRate, 'byteRate': byteRate, 'blockAlign': blockAlign, 'bitsPerSample': bitsPerSample}), 'data': data, 'cuePoints': cuePoints})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.version = None
format_wav_Reader._hx_class = format_wav_Reader
_hx_classes["format.wav.Reader"] = format_wav_Reader


class h2d_Object:
    _hx_class_name = "h2d.Object"
    _hx_is_interface = "False"
    __slots__ = ("children", "parentContainer", "parent", "name", "x", "y", "scaleX", "scaleY", "rotation", "visible", "alpha", "filter", "blendMode", "matA", "matB", "matC", "matD", "absX", "absY", "posChanged", "allocated", "lastFrame")
    _hx_fields = ["children", "parentContainer", "parent", "name", "x", "y", "scaleX", "scaleY", "rotation", "visible", "alpha", "filter", "blendMode", "matA", "matB", "matC", "matD", "absX", "absY", "posChanged", "allocated", "lastFrame"]
    _hx_methods = ["getBounds", "getSize", "getAbsPos", "contains", "find", "findAll", "set_filter", "getBoundsRec", "addBounds", "getObjectsCount", "localToGlobal", "globalToLocal", "getScene", "set_visible", "addChild", "addChildAt", "onContentChanged", "onHierarchyMoved", "onAdd", "onRemove", "getMatrix", "removeChild", "setParentContainer", "removeChildren", "remove", "drawTo", "drawToTextures", "draw", "sync", "syncPos", "calcAbsPos", "emitTile", "clipBounds", "drawFilters", "drawFiltered", "drawRec", "drawContent", "set_x", "set_y", "set_scaleX", "set_scaleY", "set_rotation", "move", "setPosition", "rotate", "scale", "setScale", "getChildAt", "getChildIndex", "getObjectByName", "get_numChildren", "iterator", "toString", "contentChanged", "constraintSize"]
    _hx_statics = ["nullDrawable"]

    def __init__(self,parent = None):
        self.lastFrame = None
        self.allocated = None
        self.filter = None
        self.name = None
        self.parent = None
        self.parentContainer = None
        self.blendMode = h2d_BlendMode.Alpha
        self.alpha = 1.
        self.visible = True
        self.rotation = 0
        self.scaleY = 1
        self.scaleX = 1
        self.y = 0
        self.x = 0
        self.matA = 1
        self.matB = 0
        self.matC = 0
        self.matD = 1
        self.absX = 0
        self.absY = 0
        self.posChanged = (parent is not None)
        self.children = []
        if (parent is not None):
            parent.addChild(self)

    def getBounds(self,relativeTo = None,out = None):
        if (out is None):
            out = h2d_col_Bounds()
        else:
            out.xMin = 1e20
            out.yMin = 1e20
            out.xMax = -1e20
            out.yMax = -1e20
        if (relativeTo is not None):
            relativeTo.syncPos()
        if (relativeTo != self):
            self.syncPos()
        self.getBoundsRec(relativeTo,out,False)
        if ((out.xMax <= out.xMin) or ((out.yMax <= out.yMin))):
            self.addBounds(relativeTo,out,-1,-1,2,2)
            def _hx_local_0():
                out.xMin = (((out.xMax + out.xMin)) * 0.5)
                return out.xMin
            out.xMax = _hx_local_0()
            def _hx_local_1():
                out.yMin = (((out.yMax + out.yMin)) * 0.5)
                return out.yMin
            out.yMax = _hx_local_1()
        return out

    def getSize(self,out = None):
        if (out is None):
            out = h2d_col_Bounds()
        else:
            out.xMin = 1e20
            out.yMin = 1e20
            out.xMax = -1e20
            out.yMax = -1e20
        self.syncPos()
        self.getBoundsRec(self.parent,out,True)
        if ((out.xMax <= out.xMin) or ((out.yMax <= out.yMin))):
            self.addBounds(self.parent,out,-1,-1,2,2)
            def _hx_local_0():
                out.xMin = (((out.xMax + out.xMin)) * 0.5)
                return out.xMin
            out.xMax = _hx_local_0()
            def _hx_local_1():
                out.yMin = (((out.yMax + out.yMin)) * 0.5)
                return out.yMin
            out.yMax = _hx_local_1()
        dx = -self.x
        dy = -self.y
        out.xMin = (out.xMin + dx)
        out.xMax = (out.xMax + dx)
        out.yMin = (out.yMin + dy)
        out.yMax = (out.yMax + dy)
        return out

    def getAbsPos(self):
        self.syncPos()
        m = h2d_col_Matrix()
        m.a = self.matA
        m.b = self.matB
        m.c = self.matC
        m.d = self.matD
        m.x = self.absX
        m.y = self.absY
        return m

    def contains(self,o):
        while (o is not None):
            o = o.parent
            if (o == self):
                return True
        return False

    def find(self,f):
        v = f(self)
        if (v is not None):
            return v
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            v = o.find(f)
            if (v is not None):
                return v
        return None

    def findAll(self,f,arr = None):
        if (arr is None):
            arr = []
        v = f(self)
        if (v is not None):
            arr.append(v)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o.findAll(f,arr)
        return arr

    def set_filter(self,f):
        if ((self.filter is not None) and self.allocated):
            self.filter.unbind(self)
        self.filter = f
        if ((f is not None) and self.allocated):
            f.bind(self)
        return f

    def getBoundsRec(self,relativeTo,out,forSize):
        if self.posChanged:
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.posChanged = True
            self.posChanged = False
        n = len(self.children)
        if (n == 0):
            out.xMin = 1e20
            out.yMin = 1e20
            out.xMax = -1e20
            out.yMax = -1e20
            return
        if (n == 1):
            c = (self.children[0] if 0 < len(self.children) else None)
            if c.visible:
                c.getBoundsRec(relativeTo,out,forSize)
            else:
                out.xMin = 1e20
                out.yMin = 1e20
                out.xMax = -1e20
                out.yMax = -1e20
            return
        xmin = Math.POSITIVE_INFINITY
        ymin = Math.POSITIVE_INFINITY
        xmax = Math.NEGATIVE_INFINITY
        ymax = Math.NEGATIVE_INFINITY
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (not c.visible):
                continue
            c.getBoundsRec(relativeTo,out,forSize)
            if (out.xMin < xmin):
                xmin = out.xMin
            if (out.yMin < ymin):
                ymin = out.yMin
            if (out.xMax > xmax):
                xmax = out.xMax
            if (out.yMax > ymax):
                ymax = out.yMax
        out.xMin = xmin
        out.yMin = ymin
        out.xMax = xmax
        out.yMax = ymax

    def addBounds(self,relativeTo,out,dx,dy,width,height):
        if ((width <= 0) or ((height <= 0))):
            return
        if (relativeTo is None):
            x = None
            y = None
            x = (((dx * self.matA) + ((dy * self.matC))) + self.absX)
            y = (((dx * self.matB) + ((dy * self.matD))) + self.absY)
            if (x < out.xMin):
                out.xMin = x
            if (x > out.xMax):
                out.xMax = x
            if (y < out.yMin):
                out.yMin = y
            if (y > out.yMax):
                out.yMax = y
            x = (((((dx + width)) * self.matA) + ((dy * self.matC))) + self.absX)
            y = (((((dx + width)) * self.matB) + ((dy * self.matD))) + self.absY)
            if (x < out.xMin):
                out.xMin = x
            if (x > out.xMax):
                out.xMax = x
            if (y < out.yMin):
                out.yMin = y
            if (y > out.yMax):
                out.yMax = y
            x = (((dx * self.matA) + ((((dy + height)) * self.matC))) + self.absX)
            y = (((dx * self.matB) + ((((dy + height)) * self.matD))) + self.absY)
            if (x < out.xMin):
                out.xMin = x
            if (x > out.xMax):
                out.xMax = x
            if (y < out.yMin):
                out.yMin = y
            if (y > out.yMax):
                out.yMax = y
            x = (((((dx + width)) * self.matA) + ((((dy + height)) * self.matC))) + self.absX)
            y = (((((dx + width)) * self.matB) + ((((dy + height)) * self.matD))) + self.absY)
            if (x < out.xMin):
                out.xMin = x
            if (x > out.xMax):
                out.xMax = x
            if (y < out.yMin):
                out.yMin = y
            if (y > out.yMax):
                out.yMax = y
            return
        if (relativeTo == self):
            if (out.xMin > dx):
                out.xMin = dx
            if (out.yMin > dy):
                out.yMin = dy
            if (out.xMax < ((dx + width))):
                out.xMax = (dx + width)
            if (out.yMax < ((dy + height))):
                out.yMax = (dy + height)
            return
        r = ((relativeTo.matA * relativeTo.matD) - ((relativeTo.matB * relativeTo.matC)))
        if (r == 0):
            return
        det = (1 / r)
        rA = (relativeTo.matD * det)
        rB = (-relativeTo.matB * det)
        rC = (-relativeTo.matC * det)
        rD = (relativeTo.matA * det)
        rX = (self.absX - relativeTo.absX)
        rY = (self.absY - relativeTo.absY)
        x = (((dx * self.matA) + ((dy * self.matC))) + rX)
        y = (((dx * self.matB) + ((dy * self.matD))) + rY)
        x1 = ((x * rA) + ((y * rC)))
        y1 = ((x * rB) + ((y * rD)))
        if (x1 < out.xMin):
            out.xMin = x1
        if (x1 > out.xMax):
            out.xMax = x1
        if (y1 < out.yMin):
            out.yMin = y1
        if (y1 > out.yMax):
            out.yMax = y1
        x = (((((dx + width)) * self.matA) + ((dy * self.matC))) + rX)
        y = (((((dx + width)) * self.matB) + ((dy * self.matD))) + rY)
        x1 = ((x * rA) + ((y * rC)))
        y1 = ((x * rB) + ((y * rD)))
        if (x1 < out.xMin):
            out.xMin = x1
        if (x1 > out.xMax):
            out.xMax = x1
        if (y1 < out.yMin):
            out.yMin = y1
        if (y1 > out.yMax):
            out.yMax = y1
        x = (((dx * self.matA) + ((((dy + height)) * self.matC))) + rX)
        y = (((dx * self.matB) + ((((dy + height)) * self.matD))) + rY)
        x1 = ((x * rA) + ((y * rC)))
        y1 = ((x * rB) + ((y * rD)))
        if (x1 < out.xMin):
            out.xMin = x1
        if (x1 > out.xMax):
            out.xMax = x1
        if (y1 < out.yMin):
            out.yMin = y1
        if (y1 > out.yMax):
            out.yMax = y1
        x = (((((dx + width)) * self.matA) + ((((dy + height)) * self.matC))) + rX)
        y = (((((dx + width)) * self.matB) + ((((dy + height)) * self.matD))) + rY)
        x1 = ((x * rA) + ((y * rC)))
        y1 = ((x * rB) + ((y * rD)))
        if (x1 < out.xMin):
            out.xMin = x1
        if (x1 > out.xMax):
            out.xMax = x1
        if (y1 < out.yMin):
            out.yMin = y1
        if (y1 > out.yMax):
            out.yMax = y1

    def getObjectsCount(self):
        k = 0
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            k = (k + ((c.getObjectsCount() + 1)))
        return k

    def localToGlobal(self,pt = None):
        self.syncPos()
        if (pt is None):
            pt = h2d_col_Point()
        px = (((pt.x * self.matA) + ((pt.y * self.matC))) + self.absX)
        py = (((pt.x * self.matB) + ((pt.y * self.matD))) + self.absY)
        pt.x = px
        pt.y = py
        return pt

    def globalToLocal(self,pt):
        self.syncPos()
        pt.x = (pt.x - self.absX)
        pt.y = (pt.y - self.absY)
        invDet = (1 / (((self.matA * self.matD) - ((self.matB * self.matC)))))
        px = ((((pt.x * self.matD) - ((pt.y * self.matC)))) * invDet)
        py = ((((-pt.x * self.matB) + ((pt.y * self.matA)))) * invDet)
        pt.x = px
        pt.y = py
        return pt

    def getScene(self):
        p = self
        while (p.parent is not None):
            p = p.parent
        return Std.downcast(p,h2d_Scene)

    def set_visible(self,b):
        if (self.visible == b):
            return b
        self.visible = b
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return b

    def addChild(self,s):
        self.addChildAt(s,len(self.children))

    def addChildAt(self,s,pos):
        if (pos < 0):
            pos = 0
        if (pos > len(self.children)):
            pos = len(self.children)
        p = self
        while (p is not None):
            if (p == s):
                raise haxe_Exception.thrown("Recursive addChild")
            p = p.parent
        if (s.parent is not None):
            old = s.allocated
            s.allocated = False
            s.parent.removeChild(s)
            s.allocated = old
        self.children.insert(pos, s)
        if ((not self.allocated) and s.allocated):
            s.onRemove()
        s.parent = self
        s.parentContainer = self.parentContainer
        s.posChanged = True
        if self.allocated:
            if (not s.allocated):
                s.onAdd()
            else:
                s.onHierarchyMoved(True)
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)

    def onContentChanged(self):
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)

    def onHierarchyMoved(self,parentChanged):
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onHierarchyMoved(parentChanged)

    def onAdd(self):
        self.allocated = True
        if (self.filter is not None):
            self.filter.bind(self)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onAdd()

    def onRemove(self):
        self.allocated = False
        if (self.filter is not None):
            self.filter.unbind(self)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onRemove()

    def getMatrix(self,m):
        m.a = self.matA
        m.b = self.matB
        m.c = self.matC
        m.d = self.matD
        m.x = self.absX
        m.y = self.absY

    def removeChild(self,s):
        if python_internal_ArrayImpl.remove(self.children,s):
            if s.allocated:
                s.onRemove()
            s.parent = None
            if (s.parentContainer is not None):
                s.setParentContainer(None)
            s.posChanged = True
            if (self.parentContainer is not None):
                self.parentContainer.contentChanged(self)

    def setParentContainer(self,c):
        self.parentContainer = c
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            s.setParentContainer(c)

    def removeChildren(self):
        while (len(self.children) > 0):
            self.removeChild((self.children[0] if 0 < len(self.children) else None))

    def remove(self):
        if (self.parent is not None):
            self.parent.removeChild(self)

    def drawTo(self,t):
        s = self.getScene()
        needDispose = (s is None)
        if (s is None):
            s = h2d_Scene()
        s.drawImplTo(self,[t])
        if needDispose:
            s.dispose()
            self.onRemove()

    def drawToTextures(self,texs,outputs):
        s = self.getScene()
        needDispose = (s is None)
        if (s is None):
            s = h2d_Scene()
        s.drawImplTo(self,texs,outputs)
        if needDispose:
            s.dispose()
            self.onRemove()

    def draw(self,ctx):
        pass

    def sync(self,ctx):
        changed = self.posChanged
        if changed:
            self.calcAbsPos()
            self.posChanged = False
        self.lastFrame = ctx.frame
        p = 0
        _hx_len = len(self.children)
        while (p < _hx_len):
            c = (self.children[p] if p >= 0 and p < len(self.children) else None)
            if (c is None):
                break
            if (c.lastFrame != ctx.frame):
                if changed:
                    c.posChanged = True
                c.sync(ctx)
            if ((self.children[p] if p >= 0 and p < len(self.children) else None) != c):
                p = 0
                _hx_len = len(self.children)
            else:
                p = (p + 1)

    def syncPos(self):
        if (self.parent is not None):
            self.parent.syncPos()
        if self.posChanged:
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.posChanged = True
            self.posChanged = False

    def calcAbsPos(self):
        if (self.parent is None):
            cr = None
            sr = None
            if (self.rotation == 0):
                cr = 1.
                sr = 0.
                self.matA = self.scaleX
                self.matB = 0
                self.matC = 0
                self.matD = self.scaleY
            else:
                f = self.rotation
                cr = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
                f = self.rotation
                sr = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
                self.matA = (self.scaleX * cr)
                self.matB = (self.scaleX * sr)
                self.matC = (self.scaleY * -sr)
                self.matD = (self.scaleY * cr)
            self.absX = self.x
            self.absY = self.y
        else:
            if (self.rotation == 0):
                self.matA = (self.scaleX * self.parent.matA)
                self.matB = (self.scaleX * self.parent.matB)
                self.matC = (self.scaleY * self.parent.matC)
                self.matD = (self.scaleY * self.parent.matD)
            else:
                f = self.rotation
                cr = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
                f = self.rotation
                sr = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
                tmpA = (self.scaleX * cr)
                tmpB = (self.scaleX * sr)
                tmpC = (self.scaleY * -sr)
                tmpD = (self.scaleY * cr)
                self.matA = ((tmpA * self.parent.matA) + ((tmpB * self.parent.matC)))
                self.matB = ((tmpA * self.parent.matB) + ((tmpB * self.parent.matD)))
                self.matC = ((tmpC * self.parent.matA) + ((tmpD * self.parent.matC)))
                self.matD = ((tmpC * self.parent.matB) + ((tmpD * self.parent.matD)))
            self.absX = (((self.x * self.parent.matA) + ((self.y * self.parent.matC))) + self.parent.absX)
            self.absY = (((self.x * self.parent.matB) + ((self.y * self.parent.matD))) + self.parent.absY)

    def emitTile(self,ctx,tile):
        if (h2d_Object.nullDrawable is None):
            h2d_Object.nullDrawable = h2d_Drawable(None)
        h2d_Object.nullDrawable.absX = self.absX
        h2d_Object.nullDrawable.absY = self.absY
        h2d_Object.nullDrawable.matA = self.matA
        h2d_Object.nullDrawable.matB = self.matB
        h2d_Object.nullDrawable.matC = self.matC
        h2d_Object.nullDrawable.matD = self.matD
        ctx.drawTile(h2d_Object.nullDrawable,tile)

    def clipBounds(self,ctx,bounds):
        view = ctx.tmpBounds
        matA = None
        matB = None
        matC = None
        matD = None
        absX = None
        absY = None
        if (ctx.inFilter is not None):
            f1 = ctx.baseShader.filterMatrixA__
            f2 = ctx.baseShader.filterMatrixB__
            tmpA = ((self.matA * f1.x) + ((self.matB * f1.y)))
            tmpB = ((self.matA * f2.x) + ((self.matB * f2.y)))
            tmpC = ((self.matC * f1.x) + ((self.matD * f1.y)))
            tmpD = ((self.matC * f2.x) + ((self.matD * f2.y)))
            tmpX = (((self.absX * f1.x) + ((self.absY * f1.y))) + f1.z)
            tmpY = (((self.absX * f2.x) + ((self.absY * f2.y))) + f2.z)
            matA = ((tmpA * ctx.viewA) + ((tmpB * ctx.viewC)))
            matB = ((tmpA * ctx.viewB) + ((tmpB * ctx.viewD)))
            matC = ((tmpC * ctx.viewA) + ((tmpD * ctx.viewC)))
            matD = ((tmpC * ctx.viewB) + ((tmpD * ctx.viewD)))
            absX = (((tmpX * ctx.viewA) + ((tmpY * ctx.viewC))) + ctx.viewX)
            absY = (((tmpX * ctx.viewB) + ((tmpY * ctx.viewD))) + ctx.viewY)
        else:
            matA = ((self.matA * ctx.viewA) + ((self.matB * ctx.viewC)))
            matB = ((self.matA * ctx.viewB) + ((self.matB * ctx.viewD)))
            matC = ((self.matC * ctx.viewA) + ((self.matD * ctx.viewC)))
            matD = ((self.matC * ctx.viewB) + ((self.matD * ctx.viewD)))
            absX = (((self.absX * ctx.viewA) + ((self.absY * ctx.viewC))) + ctx.viewX)
            absY = (((self.absX * ctx.viewB) + ((self.absY * ctx.viewD))) + ctx.viewY)
        view.xMin = 1e20
        view.yMin = 1e20
        view.xMax = -1e20
        view.yMax = -1e20
        x = bounds.xMin
        y = bounds.yMin
        x1 = (((x * matA) + ((y * matC))) + absX)
        y1 = (((x * matB) + ((y * matD))) + absY)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        x = bounds.xMax
        y = bounds.yMin
        x1 = (((x * matA) + ((y * matC))) + absX)
        y1 = (((x * matB) + ((y * matD))) + absY)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        x = bounds.xMin
        y = bounds.yMax
        x1 = (((x * matA) + ((y * matC))) + absX)
        y1 = (((x * matB) + ((y * matD))) + absY)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        x = bounds.xMax
        y = bounds.yMax
        x1 = (((x * matA) + ((y * matC))) + absX)
        y1 = (((x * matB) + ((y * matD))) + absY)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        if (view.xMin < -1):
            view.xMin = -1
        if (view.yMin < -1):
            view.yMin = -1
        if (view.xMax > 1):
            view.xMax = 1
        if (view.yMax > 1):
            view.yMax = 1
        invDet = (1 / (((matA * matD) - ((matB * matC)))))
        sxMin = view.xMin
        syMin = view.yMin
        sxMax = view.xMax
        syMax = view.yMax
        view.xMin = 1e20
        view.yMin = 1e20
        view.xMax = -1e20
        view.yMax = -1e20
        x = sxMin
        y = syMin
        x = (x - absX)
        y = (y - absY)
        x1 = ((((x * matD) - ((y * matC)))) * invDet)
        y1 = ((((-x * matB) + ((y * matA)))) * invDet)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        x = sxMax
        y = syMin
        x = (x - absX)
        y = (y - absY)
        x1 = ((((x * matD) - ((y * matC)))) * invDet)
        y1 = ((((-x * matB) + ((y * matA)))) * invDet)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        x = sxMin
        y = syMax
        x = (x - absX)
        y = (y - absY)
        x1 = ((((x * matD) - ((y * matC)))) * invDet)
        y1 = ((((-x * matB) + ((y * matA)))) * invDet)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        x = sxMax
        y = syMax
        x = (x - absX)
        y = (y - absY)
        x1 = ((((x * matD) - ((y * matC)))) * invDet)
        y1 = ((((-x * matB) + ((y * matA)))) * invDet)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        a = bounds.xMin
        b = view.xMin
        bounds.xMin = (b if ((a < b)) else a)
        a = bounds.yMin
        b = view.yMin
        bounds.yMin = (b if ((a < b)) else a)
        a = bounds.xMax
        b = view.xMax
        bounds.xMax = (b if ((a > b)) else a)
        a = bounds.yMax
        b = view.yMax
        bounds.yMax = (b if ((a > b)) else a)

    def drawFilters(self,ctx):
        if (not ctx.pushFilter(self)):
            return
        bounds = ctx.tmpBounds
        total = h2d_col_Bounds()
        maxExtent = -1.
        self.filter.sync(ctx,self)
        if self.filter.autoBounds:
            maxExtent = self.filter.boundsExtend
        else:
            self.filter.getBounds(self,bounds)
            if (bounds.xMin < total.xMin):
                total.xMin = bounds.xMin
            if (bounds.xMax > total.xMax):
                total.xMax = bounds.xMax
            if (bounds.yMin < total.yMin):
                total.yMin = bounds.yMin
            if (bounds.yMax > total.yMax):
                total.yMax = bounds.yMax
        if (maxExtent >= 0):
            self.getBounds(self,bounds)
            bounds.xMin = (bounds.xMin - maxExtent)
            bounds.yMin = (bounds.yMin - maxExtent)
            bounds.xMax = (bounds.xMax + maxExtent)
            bounds.yMax = (bounds.yMax + maxExtent)
            if (bounds.xMin < total.xMin):
                total.xMin = bounds.xMin
            if (bounds.xMax > total.xMax):
                total.xMax = bounds.xMax
            if (bounds.yMin < total.yMin):
                total.yMin = bounds.yMin
            if (bounds.yMax > total.yMax):
                total.yMax = bounds.yMax
        self.clipBounds(ctx,total)
        xMin = Math.floor((total.xMin + 1e-10))
        yMin = Math.floor((total.yMin + 1e-10))
        width = Math.ceil(((total.xMax - xMin) - 1e-10))
        height = Math.ceil(((total.yMax - yMin) - 1e-10))
        if (((width <= 0) or ((height <= 0))) or ((total.xMax < total.xMin))):
            ctx.popFilter()
            return
        t = ctx.textures.allocTarget("filterTemp",width,height,False)
        ctx.pushTarget(t,xMin,yMin,width,height)
        ctx.engine.clear(0)
        oldAlpha = ctx.globalAlpha
        shader = ctx.baseShader
        _this = shader.filterMatrixA__
        x = _this.x
        y = _this.y
        z = _this.z
        w = _this.w
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        oldA_x = x
        oldA_y = y
        oldA_z = z
        oldA_w = w
        _this = shader.filterMatrixB__
        x = _this.x
        y = _this.y
        z = _this.z
        w = _this.w
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        oldB_x = x
        oldB_y = y
        oldB_z = z
        oldB_w = w
        invDet = (1 / (((self.matA * self.matD) - ((self.matB * self.matC)))))
        invA = (self.matD * invDet)
        invB = (-self.matB * invDet)
        invC = (-self.matC * invDet)
        invD = (self.matA * invDet)
        invX = -(((self.absX * invA) + ((self.absY * invC))))
        invY = -(((self.absX * invB) + ((self.absY * invD))))
        _this = shader.filterMatrixA__
        x = invA
        y = invC
        z = invX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = shader.filterMatrixB__
        x = invB
        y = invD
        z = invY
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        ctx.globalAlpha = 1
        self.drawContent(ctx)
        finalTile = h2d_Tile.fromTexture(t)
        finalTile.dx = xMin
        finalTile.dy = yMin
        prev = finalTile
        finalTile = self.filter.draw(ctx,finalTile)
        if ((finalTile != prev) and ((finalTile is not None))):
            finalTile.dx = (finalTile.dx + xMin)
            finalTile.dy = (finalTile.dy + yMin)
        _this = shader.filterMatrixA__
        _this.x = oldA_x
        _this.y = oldA_y
        _this.z = oldA_z
        _this.w = oldA_w
        _this = shader.filterMatrixB__
        _this.x = oldB_x
        _this.y = oldB_y
        _this.z = oldB_z
        _this.w = oldB_w
        ctx.popTarget()
        ctx.popFilter()
        ctx.globalAlpha = oldAlpha
        if (finalTile is None):
            return
        self.drawFiltered(ctx,finalTile)

    def drawFiltered(self,ctx,tile):
        oldAlpha = ctx.globalAlpha
        ctx.currentBlend = None
        ctx.inFilterBlend = self.blendMode
        ctx.globalAlpha = (ctx.globalAlpha * self.alpha)
        self.emitTile(ctx,tile)
        ctx.globalAlpha = oldAlpha
        ctx.inFilterBlend = None
        ctx.currentBlend = None

    def drawRec(self,ctx):
        if (not self.visible):
            return
        if self.posChanged:
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.posChanged = True
            self.posChanged = False
        if ((self.filter is not None) and self.filter.get_enable()):
            self.drawFilters(ctx)
        else:
            old = ctx.globalAlpha
            ctx.globalAlpha = (ctx.globalAlpha * self.alpha)
            self.drawContent(ctx)
            ctx.globalAlpha = old

    def drawContent(self,ctx):
        if ctx.front2back:
            i = len(self.children)
            while True:
                tmp = i
                i = (i - 1)
                if (not ((tmp > 0))):
                    break
                (self.children[i] if i >= 0 and i < len(self.children) else None).drawRec(ctx)
            self.draw(ctx)
        else:
            self.draw(ctx)
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.drawRec(ctx)

    def set_x(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.x = v
                return self.x
            return _hx_local_0()
        return _hx_local_1()

    def set_y(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.y = v
                return self.y
            return _hx_local_0()
        return _hx_local_1()

    def set_scaleX(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scaleX = v
                return self.scaleX
            return _hx_local_0()
        return _hx_local_1()

    def set_scaleY(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scaleY = v
                return self.scaleY
            return _hx_local_0()
        return _hx_local_1()

    def set_rotation(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.rotation = v
                return self.rotation
            return _hx_local_0()
        return _hx_local_1()

    def move(self,dx,dy):
        v = self.x
        f = self.rotation
        v1 = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        self.posChanged = True
        self.x = (v + ((dx * v1)))
        v = self.y
        f = self.rotation
        v1 = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        self.posChanged = True
        self.y = (v + ((dy * v1)))

    def setPosition(self,x,y):
        self.posChanged = True
        self.x = x
        self.posChanged = True
        self.y = y

    def rotate(self,v):
        self.posChanged = True
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.rotation
        _hx_local_0.rotation = (_hx_local_1 + v)
        _hx_local_0.rotation

    def scale(self,v):
        self.posChanged = True
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.scaleX
        _hx_local_0.scaleX = (_hx_local_1 * v)
        _hx_local_0.scaleX
        self.posChanged = True
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.scaleY
        _hx_local_2.scaleY = (_hx_local_3 * v)
        _hx_local_2.scaleY

    def setScale(self,v):
        self.posChanged = True
        self.scaleX = v
        self.posChanged = True
        self.scaleY = v

    def getChildAt(self,n):
        return (self.children[n] if n >= 0 and n < len(self.children) else None)

    def getChildIndex(self,o):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == o):
                return i
        return -1

    def getObjectByName(self,name):
        if (self.name == name):
            return self
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o = c.getObjectByName(name)
            if (o is not None):
                return o
        return None

    def get_numChildren(self):
        return len(self.children)

    def iterator(self):
        return hxd_impl_ArrayIterator_h2d_Object(self.children)

    def toString(self):
        c = Type.getClassName(Type.getClass(self))
        if (self.name is None):
            return c
        else:
            return (((HxOverrides.stringOrNull(self.name) + "(") + ("null" if c is None else c)) + ")")

    def contentChanged(self,s):
        pass

    def constraintSize(self,maxWidth,maxHeight):
        pass
    nullDrawable = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.children = None
        _hx_o.parentContainer = None
        _hx_o.parent = None
        _hx_o.name = None
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.scaleX = None
        _hx_o.scaleY = None
        _hx_o.rotation = None
        _hx_o.visible = None
        _hx_o.alpha = None
        _hx_o.filter = None
        _hx_o.blendMode = None
        _hx_o.matA = None
        _hx_o.matB = None
        _hx_o.matC = None
        _hx_o.matD = None
        _hx_o.absX = None
        _hx_o.absY = None
        _hx_o.posChanged = None
        _hx_o.allocated = None
        _hx_o.lastFrame = None
h2d_Object._hx_class = h2d_Object
_hx_classes["h2d.Object"] = h2d_Object


class h2d_Drawable(h2d_Object):
    _hx_class_name = "h2d.Drawable"
    _hx_is_interface = "False"
    __slots__ = ("color", "smooth", "tileWrap", "colorKey", "shaders")
    _hx_fields = ["color", "smooth", "tileWrap", "colorKey", "shaders"]
    _hx_methods = ["set_tileWrap", "get_colorAdd", "set_colorAdd", "drawFiltered", "set_colorKey", "adjustColor", "get_colorMatrix", "set_colorMatrix", "getDebugShaderCode", "getShader", "getShaders", "addShader", "removeShader", "emitTile"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Object


    def __init__(self,parent):
        self.shaders = None
        self.colorKey = None
        self.tileWrap = None
        self.smooth = None
        self.color = None
        super().__init__(parent)
        self.color = h3d_Vector(1,1,1,1)

    def set_tileWrap(self,b):
        def _hx_local_1():
            def _hx_local_0():
                self.tileWrap = b
                return self.tileWrap
            return _hx_local_0()
        return _hx_local_1()

    def get_colorAdd(self):
        s = self.getShader(h3d_shader_ColorAdd)
        if (s is None):
            return None
        else:
            return s.color__

    def set_colorAdd(self,c):
        s = self.getShader(h3d_shader_ColorAdd)
        if (s is None):
            if (c is not None):
                s = self.addShader(h3d_shader_ColorAdd())
                s.color__ = c
        elif (c is None):
            self.removeShader(s)
        else:
            s.color__ = c
        return c

    def drawFiltered(self,ctx,tile):
        old = self.shaders
        self.shaders = None
        super().drawFiltered(ctx,tile)
        self.shaders = old

    def set_colorKey(self,v):
        s = self.getShader(h3d_shader_ColorKey)
        if (s is None):
            if (v is not None):
                s = self.addShader(h3d_shader_ColorKey((-16777216 | v)))
        elif (v is None):
            self.removeShader(s)
        else:
            _this = s.colorKey__
            c = (-16777216 | v)
            _this.x = ((((c >> 16) & 255)) / 255)
            _this.y = ((((c >> 8) & 255)) / 255)
            _this.z = (((c & 255)) / 255)
            _this.w = ((HxOverrides.rshift(c, 24)) / 255)
        def _hx_local_1():
            def _hx_local_0():
                self.colorKey = v
                return self.colorKey
            return _hx_local_0()
        return _hx_local_1()

    def adjustColor(self,col = None):
        if (col is None):
            self.set_colorMatrix(None)
        else:
            m = self.get_colorMatrix()
            if (m is None):
                m = h3d_Matrix()
                self.set_colorMatrix(m)
            m.identity()
            m.adjustColor(col)

    def get_colorMatrix(self):
        s = self.getShader(h3d_shader_ColorMatrix)
        if (s is None):
            return None
        else:
            return s.matrix__

    def set_colorMatrix(self,m):
        s = self.getShader(h3d_shader_ColorMatrix)
        if (s is None):
            if (m is not None):
                s = self.addShader(h3d_shader_ColorMatrix())
                s.matrix__ = m
        elif (m is None):
            self.removeShader(s)
        else:
            s.matrix__ = m
        return m

    def getDebugShaderCode(self,toHxsl = None):
        if (toHxsl is None):
            toHxsl = True
        ctx = self.getScene().ctx
        shader = ctx.manager.compileShaders(hxsl_ShaderList(ctx.baseShader,self.shaders))
        if toHxsl:
            varId = True
            def _hx_local_0(s):
                return hxsl_Printer.shaderToString(s,varId)
            toString = _hx_local_0
            return ((("// vertex:\n" + HxOverrides.stringOrNull(toString(shader.vertex.data))) + "\n\nfragment:\n") + HxOverrides.stringOrNull(toString(shader.fragment.data)))
        else:
            return h3d_Engine.CURRENT.driver.getNativeShaderCode(shader)

    def getShader(self,stype):
        if (self.shaders is not None):
            _g_l = self.shaders
            _g_last = None
            while (_g_l != _g_last):
                s = _g_l.s
                _g_l = _g_l.next
                s1 = s
                s2 = Std.downcast(s1,stype)
                if (s2 is not None):
                    return s2
        return None

    def getShaders(self):
        return hxsl__ShaderList_ShaderIterator(self.shaders,None)

    def addShader(self,s):
        if (s is None):
            raise haxe_Exception.thrown("Can't add null shader")
        self.shaders = hxsl_ShaderList.addSort(s,self.shaders)
        return s

    def removeShader(self,s):
        prev = None
        cur = self.shaders
        while (cur is not None):
            if (cur.s == s):
                if (prev is None):
                    self.shaders = cur.next
                else:
                    prev.next = cur.next
                return True
            prev = cur
            cur = cur.next
        return False

    def emitTile(self,ctx,tile):
        if (tile is None):
            tile = h2d_Tile(None,0,0,5,5)
        if (not ctx.drawTile(self,tile)):
            return

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color = None
        _hx_o.smooth = None
        _hx_o.tileWrap = None
        _hx_o.colorKey = None
        _hx_o.shaders = None
h2d_Drawable._hx_class = h2d_Drawable
_hx_classes["h2d.Drawable"] = h2d_Drawable


class h2d_Bitmap(h2d_Drawable):
    _hx_class_name = "h2d.Bitmap"
    _hx_is_interface = "False"
    __slots__ = ("tile", "width", "height")
    _hx_fields = ["tile", "width", "height"]
    _hx_methods = ["getBoundsRec", "set_width", "set_height", "set_tile", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Drawable


    def __init__(self,tile = None,parent = None):
        self.height = None
        self.width = None
        self.tile = None
        super().__init__(parent)
        self.set_tile(tile)

    def getBoundsRec(self,relativeTo,out,forSize):
        super().getBoundsRec(relativeTo,out,forSize)
        if (self.tile is not None):
            if ((self.width is None) and ((self.height is None))):
                self.addBounds(relativeTo,out,self.tile.dx,self.tile.dy,self.tile.width,self.tile.height)
            else:
                self.addBounds(relativeTo,out,self.tile.dx,self.tile.dy,(self.width if ((self.width is not None)) else ((self.tile.width * self.height) / self.tile.height)),(self.height if ((self.height is not None)) else ((self.tile.height * self.width) / self.tile.width)))

    def set_width(self,w):
        if (self.width == w):
            return w
        self.width = w
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return w

    def set_height(self,h):
        if (self.height == h):
            return h
        self.height = h
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return h

    def set_tile(self,t):
        if (self.tile == t):
            return t
        self.tile = t
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return t

    def draw(self,ctx):
        if ((self.width is None) and ((self.height is None))):
            self.emitTile(ctx,self.tile)
            return
        if (self.tile is None):
            self.set_tile(h2d_Tile.fromColor(16711935))
        ow = self.tile.width
        oh = self.tile.height
        self.tile.width = (self.width if ((self.width is not None)) else ((ow * self.height) / oh))
        self.tile.height = (self.height if ((self.height is not None)) else ((oh * self.width) / ow))
        self.emitTile(ctx,self.tile)
        self.tile.width = ow
        self.tile.height = oh

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tile = None
        _hx_o.width = None
        _hx_o.height = None
h2d_Bitmap._hx_class = h2d_Bitmap
_hx_classes["h2d.Bitmap"] = h2d_Bitmap

class h2d_BlendMode(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.BlendMode"
    _hx_constructs = ["None", "Alpha", "Add", "AlphaAdd", "SoftAdd", "Multiply", "AlphaMultiply", "Erase", "Screen", "Sub", "Max", "Min"]
h2d_BlendMode._hx_None = h2d_BlendMode("None", 0, ())
h2d_BlendMode.Alpha = h2d_BlendMode("Alpha", 1, ())
h2d_BlendMode.Add = h2d_BlendMode("Add", 2, ())
h2d_BlendMode.AlphaAdd = h2d_BlendMode("AlphaAdd", 3, ())
h2d_BlendMode.SoftAdd = h2d_BlendMode("SoftAdd", 4, ())
h2d_BlendMode.Multiply = h2d_BlendMode("Multiply", 5, ())
h2d_BlendMode.AlphaMultiply = h2d_BlendMode("AlphaMultiply", 6, ())
h2d_BlendMode.Erase = h2d_BlendMode("Erase", 7, ())
h2d_BlendMode.Screen = h2d_BlendMode("Screen", 8, ())
h2d_BlendMode.Sub = h2d_BlendMode("Sub", 9, ())
h2d_BlendMode.Max = h2d_BlendMode("Max", 10, ())
h2d_BlendMode.Min = h2d_BlendMode("Min", 11, ())
h2d_BlendMode._hx_class = h2d_BlendMode
_hx_classes["h2d.BlendMode"] = h2d_BlendMode


class h2d_Camera:
    _hx_class_name = "h2d.Camera"
    _hx_is_interface = "False"
    _hx_fields = ["x", "y", "scaleX", "scaleY", "rotation", "clipViewport", "anchorX", "anchorY", "visible", "follow", "followRotation", "posChanged", "viewX", "viewY", "viewW", "viewH", "matA", "matB", "matC", "matD", "absX", "absY", "invDet", "scene"]
    _hx_methods = ["remove", "layerVisible", "enter", "exit", "sync", "setScale", "scale", "setPosition", "move", "rotate", "setAnchor", "setViewport", "setRawViewport", "screenXToCamera", "screenYToCamera", "cameraXToScreen", "cameraYToScreen", "sceneXToCamera", "sceneYToCamera", "cameraXToScene", "cameraYToScene", "eventToCamera", "screenToCamera", "cameraToScreen", "sceneToCamera", "cameraToScene", "checkScene", "set_x", "set_y", "set_scaleX", "set_scaleY", "set_rotation", "get_viewportX", "set_viewportX", "get_viewportY", "set_viewportY", "get_viewportWidth", "set_viewportWidth", "get_viewportHeight", "set_viewportHeight", "set_anchorX", "set_anchorY"]

    def __init__(self,scene = None):
        self.scene = None
        self.invDet = None
        self.absY = None
        self.absX = None
        self.matD = None
        self.matC = None
        self.matB = None
        self.matA = None
        self.follow = None
        self.clipViewport = None
        self.followRotation = False
        self.posChanged = True
        self.x = 0
        self.posChanged = True
        self.y = 0
        self.posChanged = True
        self.scaleX = 1
        self.posChanged = True
        self.scaleY = 1
        self.posChanged = True
        self.rotation = 0
        self.posChanged = True
        self.anchorX = 0
        self.posChanged = True
        self.anchorY = 0
        self.viewX = 0
        self.viewY = 0
        self.viewW = 1
        self.viewH = 1
        self.visible = True
        if (scene is not None):
            scene.addCamera(self)

    def remove(self):
        if (self.scene is not None):
            self.scene.removeCamera(self)

    def layerVisible(self,layer):
        return True

    def enter(self,ctx):
        ctx.pushCamera(self)
        if self.clipViewport:
            old = ctx.inFilter
            ctx.inFilter = None
            ctx.pushRenderZone((self.viewX * self.scene.width),(self.viewY * self.scene.height),(self.viewW * self.scene.width),(self.viewH * self.scene.height))
            ctx.inFilter = old

    def exit(self,ctx):
        if self.clipViewport:
            old = ctx.inFilter
            ctx.inFilter = None
            ctx.popRenderZone()
            ctx.inFilter = old
        ctx.popCamera()

    def sync(self,ctx,force = None):
        if (force is None):
            force = False
        if (self.scene is None):
            return
        if (self.follow is not None):
            self.posChanged = True
            self.x = self.follow.absX
            self.posChanged = True
            self.y = self.follow.absY
            if self.followRotation:
                self.posChanged = True
                self.rotation = -self.follow.rotation
        if (self.posChanged or force):
            if (self.rotation == 0):
                self.matA = self.scaleX
                self.matB = 0
                self.matC = 0
                self.matD = self.scaleY
            else:
                v = self.rotation
                cr = (Math.NaN if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(v))
                v = self.rotation
                sr = (Math.NaN if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(v))
                self.matA = (self.scaleX * cr)
                self.matB = (self.scaleX * sr)
                self.matC = (self.scaleY * -sr)
                self.matD = (self.scaleY * cr)
            self.absX = Math.floor((((-(((self.x * self.matA) + ((self.y * self.matC)))) + (((self.scene.width * self.anchorX) * self.viewW))) + ((self.scene.width * self.viewX))) + 0.5))
            self.absY = Math.floor((((-(((self.x * self.matB) + ((self.y * self.matD)))) + (((self.scene.height * self.anchorY) * self.viewH))) + ((self.scene.height * self.viewY))) + 0.5))
            self.invDet = (1 / (((self.matA * self.matD) - ((self.matB * self.matC)))))
            self.posChanged = False

    def setScale(self,x,y):
        self.posChanged = True
        self.scaleX = x
        self.posChanged = True
        self.scaleY = y

    def scale(self,x,y):
        self.posChanged = True
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.scaleX
        _hx_local_0.scaleX = (_hx_local_1 * x)
        _hx_local_0.scaleX
        self.posChanged = True
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.scaleY
        _hx_local_2.scaleY = (_hx_local_3 * y)
        _hx_local_2.scaleY

    def setPosition(self,x,y):
        self.posChanged = True
        self.x = x
        self.posChanged = True
        self.y = y

    def move(self,dx,dy):
        self.posChanged = True
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + dx)
        _hx_local_0.x
        self.posChanged = True
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + dy)
        _hx_local_2.y

    def rotate(self,angle):
        self.posChanged = True
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.rotation
        _hx_local_0.rotation = (_hx_local_1 + angle)
        _hx_local_0.rotation

    def setAnchor(self,x,y):
        self.posChanged = True
        self.anchorX = x
        self.posChanged = True
        self.anchorY = y

    def setViewport(self,x = None,y = None,w = None,h = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        if (w is None):
            w = 0
        if (h is None):
            h = 0
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewX = (Math.floor(x) / self.scene.width)
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewY = (Math.floor(y) / self.scene.height)
        v = (self.scene.width if ((w == 0)) else w)
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewW = (Math.ceil(v) / self.scene.width)
        v = (self.scene.height if ((h == 0)) else h)
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewH = (Math.ceil(v) / self.scene.height)

    def setRawViewport(self,x = None,y = None,w = None,h = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        if (w is None):
            w = 1
        if (h is None):
            h = 1
        self.viewX = x
        self.viewY = y
        self.viewW = w
        self.viewH = h
        self.posChanged = True

    def screenXToCamera(self,mx,my):
        return (((((((((mx - self.scene.offsetX)) / self.scene.viewportScaleX) - self.absX)) * self.matD) - (((((((my - self.scene.offsetY)) / self.scene.viewportScaleY) - self.absY)) * self.matC)))) * self.invDet)

    def screenYToCamera(self,mx,my):
        return ((((-(((((mx - self.scene.offsetX)) / self.scene.viewportScaleX) - self.absX)) * self.matB) + (((((((my - self.scene.offsetY)) / self.scene.viewportScaleY) - self.absY)) * self.matA)))) * self.invDet)

    def cameraXToScreen(self,mx,my):
        return ((((((mx * self.matA) + ((my * self.matC))) + self.absX)) * self.scene.viewportScaleX) + self.scene.offsetX)

    def cameraYToScreen(self,mx,my):
        return ((((((mx * self.matB) + ((my * self.matD))) + self.absY)) * self.scene.viewportScaleY) + self.scene.offsetY)

    def sceneXToCamera(self,mx,my):
        return ((((((mx - self.absX)) * self.matD) - ((((my - self.absY)) * self.matC)))) * self.invDet)

    def sceneYToCamera(self,mx,my):
        return ((((-((mx - self.absX)) * self.matB) + ((((my - self.absY)) * self.matA)))) * self.invDet)

    def cameraXToScene(self,mx,my):
        return (((mx * self.matA) + ((my * self.matC))) + self.absX)

    def cameraYToScene(self,mx,my):
        return (((mx * self.matB) + ((my * self.matD))) + self.absY)

    def eventToCamera(self,e):
        x = ((((e.relX - self.scene.offsetX)) / self.scene.viewportScaleX) - self.absX)
        y = ((((e.relY - self.scene.offsetY)) / self.scene.viewportScaleY) - self.absY)
        e.relX = ((((x * self.matD) - ((y * self.matC)))) * self.invDet)
        e.relY = ((((-x * self.matB) + ((y * self.matA)))) * self.invDet)

    def screenToCamera(self,pt):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        x = ((((pt.x - self.scene.offsetX)) / self.scene.viewportScaleX) - self.absX)
        y = ((((pt.y - self.scene.offsetY)) / self.scene.viewportScaleY) - self.absY)
        pt.x = ((((x * self.matD) - ((y * self.matC)))) * self.invDet)
        pt.y = ((((-x * self.matB) + ((y * self.matA)))) * self.invDet)

    def cameraToScreen(self,pt):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        x = pt.x
        y = pt.y
        pt.x = ((((((x * self.matA) + ((y * self.matC))) + self.absX)) * self.scene.viewportScaleX) + self.scene.offsetX)
        pt.y = ((((((x * self.matB) + ((y * self.matD))) + self.absY)) * self.scene.viewportScaleY) + self.scene.offsetY)

    def sceneToCamera(self,pt):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        x = (pt.x - self.absX)
        y = (pt.y - self.absY)
        pt.x = ((((x * self.matD) - ((y * self.matC)))) * self.invDet)
        pt.y = ((((-x * self.matB) + ((y * self.matA)))) * self.invDet)

    def cameraToScene(self,pt):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        x = pt.x
        y = pt.y
        pt.x = (((x * self.matA) + ((y * self.matC))) + self.absX)
        pt.y = (((x * self.matB) + ((y * self.matD))) + self.absY)

    def checkScene(self):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")

    def set_x(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.x = v
                return self.x
            return _hx_local_0()
        return _hx_local_1()

    def set_y(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.y = v
                return self.y
            return _hx_local_0()
        return _hx_local_1()

    def set_scaleX(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scaleX = v
                return self.scaleX
            return _hx_local_0()
        return _hx_local_1()

    def set_scaleY(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scaleY = v
                return self.scaleY
            return _hx_local_0()
        return _hx_local_1()

    def set_rotation(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.rotation = v
                return self.rotation
            return _hx_local_0()
        return _hx_local_1()

    def get_viewportX(self):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        return (self.viewX * self.scene.width)

    def set_viewportX(self,v):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewX = (Math.floor(v) / self.scene.width)
        return v

    def get_viewportY(self):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        return (self.viewY * self.scene.height)

    def set_viewportY(self,v):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewY = (Math.floor(v) / self.scene.height)
        return v

    def get_viewportWidth(self):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        return (self.viewW * self.scene.width)

    def set_viewportWidth(self,v):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewW = (Math.ceil(v) / self.scene.width)
        return v

    def get_viewportHeight(self):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        return (self.viewH * self.scene.height)

    def set_viewportHeight(self,v):
        if (self.scene is None):
            raise haxe_Exception.thrown("This method requires Camera to be added to the Scene")
        self.posChanged = True
        self.viewH = (Math.ceil(v) / self.scene.height)
        return v

    def set_anchorX(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.anchorX = v
                return self.anchorX
            return _hx_local_0()
        return _hx_local_1()

    def set_anchorY(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.anchorY = v
                return self.anchorY
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.scaleX = None
        _hx_o.scaleY = None
        _hx_o.rotation = None
        _hx_o.clipViewport = None
        _hx_o.anchorX = None
        _hx_o.anchorY = None
        _hx_o.visible = None
        _hx_o.follow = None
        _hx_o.followRotation = None
        _hx_o.posChanged = None
        _hx_o.viewX = None
        _hx_o.viewY = None
        _hx_o.viewW = None
        _hx_o.viewH = None
        _hx_o.matA = None
        _hx_o.matB = None
        _hx_o.matC = None
        _hx_o.matD = None
        _hx_o.absX = None
        _hx_o.absY = None
        _hx_o.invDet = None
        _hx_o.scene = None
h2d_Camera._hx_class = h2d_Camera
_hx_classes["h2d.Camera"] = h2d_Camera


class h2d_Kerning:
    _hx_class_name = "h2d.Kerning"
    _hx_is_interface = "False"
    __slots__ = ("prevChar", "offset", "next")
    _hx_fields = ["prevChar", "offset", "next"]

    def __init__(self,c,o):
        self.next = None
        self.prevChar = c
        self.offset = o

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.prevChar = None
        _hx_o.offset = None
        _hx_o.next = None
h2d_Kerning._hx_class = h2d_Kerning
_hx_classes["h2d.Kerning"] = h2d_Kerning


class h2d_FontChar:
    _hx_class_name = "h2d.FontChar"
    _hx_is_interface = "False"
    __slots__ = ("t", "width", "kerning")
    _hx_fields = ["t", "width", "kerning"]
    _hx_methods = ["addKerning", "getKerningOffset", "clone"]

    def __init__(self,t,w):
        self.kerning = None
        self.t = t
        self.width = w

    def addKerning(self,prevChar,offset):
        k = h2d_Kerning(prevChar,offset)
        k.next = self.kerning
        self.kerning = k

    def getKerningOffset(self,prevChar):
        k = self.kerning
        while (k is not None):
            if (k.prevChar == prevChar):
                return k.offset
            k = k.next
        return 0

    def clone(self):
        c = h2d_FontChar(self.t.clone(),self.width)
        k = self.kerning
        if (k is not None):
            kc = h2d_Kerning(k.prevChar,k.offset)
            c.kerning = kc
            k = k.next
            while (k is not None):
                kn = h2d_Kerning(k.prevChar,k.offset)
                def _hx_local_0():
                    kc.next = kn
                    return kc.next
                kc = _hx_local_0()
                k = k.next
        return c

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.t = None
        _hx_o.width = None
        _hx_o.kerning = None
h2d_FontChar._hx_class = h2d_FontChar
_hx_classes["h2d.FontChar"] = h2d_FontChar

class h2d_FontType(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.FontType"
    _hx_constructs = ["BitmapFont", "SignedDistanceField"]

    @staticmethod
    def SignedDistanceField(channel,alphaCutoff,smoothing):
        return h2d_FontType("SignedDistanceField", 1, (channel,alphaCutoff,smoothing))
h2d_FontType.BitmapFont = h2d_FontType("BitmapFont", 0, ())
h2d_FontType._hx_class = h2d_FontType
_hx_classes["h2d.FontType"] = h2d_FontType


class h2d_Font:
    _hx_class_name = "h2d.Font"
    _hx_is_interface = "False"
    __slots__ = ("name", "size", "baseLine", "lineHeight", "tile", "tilePath", "type", "charset", "glyphs", "nullChar", "defaultChar", "initSize", "offsetX", "offsetY")
    _hx_fields = ["name", "size", "baseLine", "lineHeight", "tile", "tilePath", "type", "charset", "glyphs", "nullChar", "defaultChar", "initSize", "offsetX", "offsetY"]
    _hx_methods = ["getChar", "setOffset", "clone", "resizeTo", "hasChar", "dispose"]

    def __init__(self,name,size,_hx_type = None):
        self.type = None
        self.tilePath = None
        self.tile = None
        self.lineHeight = None
        self.baseLine = None
        self.offsetY = 0
        self.offsetX = 0
        self.name = name
        self.size = size
        self.initSize = size
        self.glyphs = haxe_ds_IntMap()
        def _hx_local_0():
            self.nullChar = h2d_FontChar(h2d_Tile(None,0,0,0,0),0)
            return self.nullChar
        self.defaultChar = _hx_local_0()
        self.charset = hxd_Charset.getDefault()
        if (name is not None):
            self.tilePath = haxe_io_Path.withExtension(name,"png")
        if (_hx_type is None):
            self.type = h2d_FontType.BitmapFont
        else:
            self.type = _hx_type

    def getChar(self,code):
        c = self.glyphs.h.get(code,None)
        if (c is None):
            c = self.charset.resolveChar(code,self.glyphs)
            if (c is None):
                c = (self.nullChar if (((code == 13) or ((code == 10)))) else self.defaultChar)
        return c

    def setOffset(self,x,y):
        dx = (x - self.offsetX)
        dy = (y - self.offsetY)
        if ((dx == 0) and ((dy == 0))):
            return
        g = self.glyphs.iterator()
        while g.hasNext():
            g1 = g.next()
            _hx_local_0 = g1.t
            _hx_local_1 = _hx_local_0.dx
            _hx_local_0.dx = (_hx_local_1 + dx)
            _hx_local_0.dx
            _hx_local_2 = g1.t
            _hx_local_3 = _hx_local_2.dy
            _hx_local_2.dy = (_hx_local_3 + dy)
            _hx_local_2.dy
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.offsetX
        _hx_local_4.offsetX = (_hx_local_5 + dx)
        _hx_local_4.offsetX
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.offsetY
        _hx_local_6.offsetY = (_hx_local_7 + dy)
        _hx_local_6.offsetY

    def clone(self):
        f = h2d_Font(self.name,self.size)
        f.baseLine = self.baseLine
        f.lineHeight = self.lineHeight
        f.tile = self.tile.clone()
        f.charset = self.charset
        f.defaultChar = self.defaultChar.clone()
        f.type = self.type
        g = self.glyphs.keys()
        while g.hasNext():
            g1 = g.next()
            c = self.glyphs.h.get(g1,None)
            c2 = c.clone()
            if (c == self.defaultChar):
                f.defaultChar = c2
            f.glyphs.set(g1,c2)
        return f

    def resizeTo(self,size):
        ratio = (size / self.initSize)
        c = self.glyphs.iterator()
        while c.hasNext():
            c1 = c.next()
            c1.width = (c1.width * ratio)
            c1.t.scaleToSize((c1.t.width * ratio),(c1.t.height * ratio))
            _hx_local_1 = c1.t
            _hx_local_2 = _hx_local_1.dx
            _hx_local_1.dx = (_hx_local_2 * ratio)
            _hx_local_1.dx
            _hx_local_3 = c1.t
            _hx_local_4 = _hx_local_3.dy
            _hx_local_3.dy = (_hx_local_4 * ratio)
            _hx_local_3.dy
            k = c1.kerning
            while (k is not None):
                k.offset = (k.offset * ratio)
                k = k.next
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.lineHeight
        _hx_local_6.lineHeight = (_hx_local_7 * ratio)
        _hx_local_6.lineHeight
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.baseLine
        _hx_local_8.baseLine = (_hx_local_9 * ratio)
        _hx_local_8.baseLine
        self.size = size

    def hasChar(self,code):
        return (self.glyphs.h.get(code,None) is not None)

    def dispose(self):
        self.tile.dispose()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.size = None
        _hx_o.baseLine = None
        _hx_o.lineHeight = None
        _hx_o.tile = None
        _hx_o.tilePath = None
        _hx_o.type = None
        _hx_o.charset = None
        _hx_o.glyphs = None
        _hx_o.nullChar = None
        _hx_o.defaultChar = None
        _hx_o.initSize = None
        _hx_o.offsetX = None
        _hx_o.offsetY = None
h2d_Font._hx_class = h2d_Font
_hx_classes["h2d.Font"] = h2d_Font


class hxd_Interactive:
    _hx_class_name = "hxd.Interactive"
    _hx_is_interface = "True"
    __slots__ = ("propagateEvents", "cursor")
    _hx_fields = ["propagateEvents", "cursor"]
    _hx_methods = ["set_cursor", "handleEvent", "getInteractiveScene"]
hxd_Interactive._hx_class = hxd_Interactive
_hx_classes["hxd.Interactive"] = hxd_Interactive


class h2d_Interactive(h2d_Drawable):
    _hx_class_name = "h2d.Interactive"
    _hx_is_interface = "False"
    _hx_fields = ["width", "height", "cursor", "isEllipse", "cancelEvents", "propagateEvents", "backgroundColor", "enableRightButton", "scene", "mouseDownButton", "parentMask", "invDet", "shape", "shapeX", "shapeY"]
    _hx_methods = ["onAdd", "draw", "getBoundsRec", "onHierarchyMoved", "updateMask", "onRemove", "checkBounds", "preventClick", "getInteractiveScene", "handleEvent", "calcAbsPos", "set_cursor", "eventToLocal", "startCapture", "stopCapture", "startDrag", "stopDrag", "focus", "blur", "isOver", "hasFocus", "onOver", "onOut", "onPush", "onRelease", "onReleaseOutside", "onClick", "onMove", "onWheel", "onFocus", "onFocusLost", "onKeyUp", "onKeyDown", "onCheck", "onTextInput"]
    _hx_statics = []
    _hx_interfaces = [hxd_Interactive]
    _hx_super = h2d_Drawable


    def __init__(self,width,height,parent = None,shape = None):
        self.shape = None
        self.invDet = None
        self.parentMask = None
        self.scene = None
        self.backgroundColor = None
        self.isEllipse = None
        self.height = None
        self.width = None
        self.shapeY = 0
        self.shapeX = 0
        self.mouseDownButton = -1
        self.enableRightButton = False
        self.propagateEvents = False
        self.cancelEvents = False
        self.cursor = hxd_Cursor.Button
        super().__init__(parent)
        self.width = width
        self.height = height
        self.shape = shape

    def onAdd(self):
        self.scene = self.getScene()
        if (self.scene is not None):
            self.scene.addEventTarget(self)
        self.updateMask()
        super().onAdd()

    def draw(self,ctx):
        if (self.backgroundColor is not None):
            tmp = self.backgroundColor
            x = self.width
            tmp1 = None
            try:
                tmp1 = int(x)
            except BaseException as _g:
                None
                tmp1 = None
            x = self.height
            tmp2 = None
            try:
                tmp2 = int(x)
            except BaseException as _g:
                None
                tmp2 = None
            self.emitTile(ctx,h2d_Tile.fromColor(tmp,tmp1,tmp2,((HxOverrides.rshift(self.backgroundColor, 24)) / 255)))

    def getBoundsRec(self,relativeTo,out,forSize):
        super().getBoundsRec(relativeTo,out,forSize)
        if ((self.backgroundColor is not None) or forSize):
            x = self.width
            tmp = None
            try:
                tmp = int(x)
            except BaseException as _g:
                None
                tmp = None
            x = self.height
            tmp1 = None
            try:
                tmp1 = int(x)
            except BaseException as _g:
                None
                tmp1 = None
            self.addBounds(relativeTo,out,0,0,tmp,tmp1)

    def onHierarchyMoved(self,parentChanged):
        super().onHierarchyMoved(parentChanged)
        if (self.scene is not None):
            self.scene.removeEventTarget(self)
            self.scene = self.getScene()
            if (self.scene is not None):
                self.scene.addEventTarget(self)
        if parentChanged:
            self.updateMask()

    def updateMask(self):
        self.parentMask = None
        p = self.parent
        while (p is not None):
            m = Std.downcast(p,h2d_Mask)
            if (m is not None):
                self.parentMask = m
                break
            p = p.parent

    def onRemove(self):
        if (self.scene is not None):
            self.scene.removeEventTarget(self,True)
            self.scene = None
        super().onRemove()

    def checkBounds(self,e):
        tmp = e.kind.index
        if ((((tmp == 10) or ((tmp == 7))) or ((tmp == 6))) or ((tmp == 4))):
            return False
        else:
            return True

    def preventClick(self):
        self.mouseDownButton = -1

    def getInteractiveScene(self):
        return self.scene

    def handleEvent(self,e):
        if ((self.parentMask is not None) and self.checkBounds(e)):
            p = self.parentMask
            pt = h2d_col_Point(e.relX,e.relY)
            self.localToGlobal(pt)
            saveX = pt.x
            saveY = pt.y
            while (p is not None):
                pt.x = saveX
                pt.y = saveY
                pt1 = p.globalToLocal(pt)
                if ((((pt1.x < 0) or ((pt1.y < 0))) or ((pt1.x > p.width))) or ((pt1.y > p.height))):
                    e.cancel = True
                    return
                p = p.parentMask
        if (((self.shape is None) and self.isEllipse) and self.checkBounds(e)):
            cx = (self.width * 0.5)
            cy = (self.height * 0.5)
            dx = (((e.relX - cx)) / cx)
            dy = (((e.relY - cy)) / cy)
            if (((dx * dx) + ((dy * dy))) > 1):
                e.cancel = True
                return
        if self.propagateEvents:
            e.propagate = True
        if self.cancelEvents:
            e.cancel = True
        tmp = e.kind.index
        if (tmp == 0):
            if (self.enableRightButton or ((e.button == 0))):
                self.mouseDownButton = e.button
                self.onPush(e)
                if e.cancel:
                    self.mouseDownButton = -1
        elif (tmp == 1):
            if (self.enableRightButton or ((e.button == 0))):
                self.onRelease(e)
                if (self.mouseDownButton == e.button):
                    self.onClick(e)
            self.mouseDownButton = -1
        elif (tmp == 2):
            self.onMove(e)
        elif (tmp == 3):
            self.onOver(e)
        elif (tmp == 4):
            self.onOut(e)
        elif (tmp == 5):
            self.onWheel(e)
        elif (tmp == 6):
            self.onFocus(e)
        elif (tmp == 7):
            self.onFocusLost(e)
        elif (tmp == 8):
            self.onKeyDown(e)
        elif (tmp == 9):
            self.onKeyUp(e)
        elif (tmp == 10):
            if (self.enableRightButton or ((e.button == 0))):
                self.onRelease(e)
                if (self.mouseDownButton == e.button):
                    self.onReleaseOutside(e)
            self.mouseDownButton = -1
        elif (tmp == 11):
            self.onTextInput(e)
        elif (tmp == 12):
            self.onCheck(e)
        else:
            pass

    def calcAbsPos(self):
        super().calcAbsPos()
        self.invDet = (1 / (((self.matA * self.matD) - ((self.matB * self.matC)))))

    def set_cursor(self,c):
        self.cursor = c
        if ((self.scene is not None) and ((self.scene.events is not None))):
            self.scene.events.updateCursor(self)
        return c

    def eventToLocal(self,e):
        i = self
        dx = (e.relX - i.absX)
        dy = (e.relY - i.absY)
        e.relX = ((((dx * i.matD) - ((dy * i.matC)))) * i.invDet)
        e.relY = ((((-dx * i.matB) + ((dy * i.matA)))) * i.invDet)

    def startCapture(self,callb,onCancel = None,touchId = None):
        _gthis = self
        def _hx_local_0(event):
            x = event.relX
            y = event.relY
            _gthis.eventToLocal(event)
            callb(event)
            event.relX = x
            event.relY = y
        self.scene.startCapture(_hx_local_0,onCancel,touchId)

    def stopCapture(self):
        self.scene.stopCapture()

    def startDrag(self,callb,onCancel = None):
        self.startCapture(callb,onCancel)

    def stopDrag(self):
        self.stopCapture()

    def focus(self):
        if ((self.scene is None) or ((self.scene.events is None))):
            return
        self.scene.events.focus(self)

    def blur(self):
        if self.hasFocus():
            self.scene.events.blur()

    def isOver(self):
        if ((self.scene is not None) and ((self.scene.events is not None))):
            return (python_internal_ArrayImpl.indexOf(self.scene.events.overList,self,None) != -1)
        else:
            return False

    def hasFocus(self):
        if ((self.scene is not None) and ((self.scene.events is not None))):
            return (self.scene.events.currentFocus == self)
        else:
            return False

    def onOver(self,e):
        pass

    def onOut(self,e):
        pass

    def onPush(self,e):
        pass

    def onRelease(self,e):
        pass

    def onReleaseOutside(self,e):
        pass

    def onClick(self,e):
        pass

    def onMove(self,e):
        pass

    def onWheel(self,e):
        pass

    def onFocus(self,e):
        pass

    def onFocusLost(self,e):
        pass

    def onKeyUp(self,e):
        pass

    def onKeyDown(self,e):
        pass

    def onCheck(self,e):
        pass

    def onTextInput(self,e):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.cursor = None
        _hx_o.isEllipse = None
        _hx_o.cancelEvents = None
        _hx_o.propagateEvents = None
        _hx_o.backgroundColor = None
        _hx_o.enableRightButton = None
        _hx_o.scene = None
        _hx_o.mouseDownButton = None
        _hx_o.parentMask = None
        _hx_o.invDet = None
        _hx_o.shape = None
        _hx_o.shapeX = None
        _hx_o.shapeY = None
h2d_Interactive._hx_class = h2d_Interactive
_hx_classes["h2d.Interactive"] = h2d_Interactive


class h2d_Layers(h2d_Object):
    _hx_class_name = "h2d.Layers"
    _hx_is_interface = "False"
    __slots__ = ("layersIndexes", "layerCount")
    _hx_fields = ["layersIndexes", "layerCount"]
    _hx_methods = ["addChild", "add", "addChildAt", "removeChild", "under", "over", "getLayer", "getChildLayer", "drawLayer", "ysort"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Object


    def __init__(self,parent = None):
        self.layerCount = None
        self.layersIndexes = None
        super().__init__(parent)
        self.layersIndexes = []
        self.layerCount = 0

    def addChild(self,s):
        self.addChildAt(s,0)

    def add(self,s,layer):
        self.addChildAt(s,layer)

    def addChildAt(self,s,layer):
        if (s.parent == self):
            old = s.allocated
            s.allocated = False
            self.removeChild(s)
            s.allocated = old
        while (layer >= self.layerCount):
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.layerCount
                _hx_local_0.layerCount = (_hx_local_1 + 1)
                return _hx_local_1
            python_internal_ArrayImpl._set(self.layersIndexes, _hx_local_2(), len(self.children))
        super().addChildAt(s,(self.layersIndexes[layer] if layer >= 0 and layer < len(self.layersIndexes) else None))
        _g = layer
        _g1 = self.layerCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _hx_local_3 = self.layersIndexes
            _hx_local_4 = i
            _hx_local_5 = (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
            python_internal_ArrayImpl._set(_hx_local_3, _hx_local_4, (_hx_local_5 + 1))
            _hx_local_5

    def removeChild(self,s):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == s):
                _this = self.children
                pos = i
                if (pos < 0):
                    pos = (len(_this) + pos)
                if (pos < 0):
                    pos = 0
                res = _this[pos:(pos + 1)]
                del _this[pos:(pos + 1)]
                if s.allocated:
                    s.onRemove()
                s.parent = None
                s.posChanged = True
                if (s.parentContainer is not None):
                    s.setParentContainer(None)
                k = (self.layerCount - 1)
                while ((k >= 0) and (((self.layersIndexes[k] if k >= 0 and k < len(self.layersIndexes) else None) > i))):
                    _hx_local_0 = self.layersIndexes
                    _hx_local_1 = k
                    _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
                    python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 - 1))
                    _hx_local_2
                    k = (k - 1)
                if (self.parentContainer is not None):
                    self.parentContainer.contentChanged(self)
                break

    def under(self,s):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == s):
                pos = 0
                _g2 = 0
                _g3 = self.layersIndexes
                while (_g2 < len(_g3)):
                    l = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if (l > i):
                        break
                    else:
                        pos = l
                p = i
                while (p > pos):
                    python_internal_ArrayImpl._set(self.children, p, python_internal_ArrayImpl._get(self.children, (p - 1)))
                    p = (p - 1)
                python_internal_ArrayImpl._set(self.children, pos, s)
                if s.allocated:
                    s.onHierarchyMoved(False)
                return

    def over(self,s):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == s):
                _g2 = 0
                _g3 = self.layersIndexes
                while (_g2 < len(_g3)):
                    l = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if (l > i):
                        _g4 = i
                        _g5 = (l - 1)
                        while (_g4 < _g5):
                            p = _g4
                            _g4 = (_g4 + 1)
                            python_internal_ArrayImpl._set(self.children, p, python_internal_ArrayImpl._get(self.children, (p + 1)))
                        python_internal_ArrayImpl._set(self.children, (l - 1), s)
                        if s.allocated:
                            s.onHierarchyMoved(False)
                        return
                return

    def getLayer(self,layer):
        a = None
        if (layer >= self.layerCount):
            a = []
        else:
            start = (0 if ((layer == 0)) else python_internal_ArrayImpl._get(self.layersIndexes, (layer - 1)))
            _hx_max = (self.layersIndexes[layer] if layer >= 0 and layer < len(self.layersIndexes) else None)
            a = self.children[start:_hx_max]
        return hxd_impl_ArrayIterator_h2d_Object(a)

    def getChildLayer(self,s):
        if (s.parent != self):
            return -1
        index = python_internal_ArrayImpl.indexOf(self.children,s,None)
        _g = 0
        _g1 = self.layerCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.layersIndexes[i] if i >= 0 and i < len(self.layersIndexes) else None) > index):
                return i
        return -1

    def drawLayer(self,ctx,layer):
        if (layer >= self.layerCount):
            return
        old = ctx.globalAlpha
        ctx.globalAlpha = (ctx.globalAlpha * self.alpha)
        start = (0 if ((layer == 0)) else python_internal_ArrayImpl._get(self.layersIndexes, (layer - 1)))
        _hx_max = (self.layersIndexes[layer] if layer >= 0 and layer < len(self.layersIndexes) else None)
        if ctx.front2back:
            _g = start
            _g1 = _hx_max
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                python_internal_ArrayImpl._get(self.children, ((_hx_max - 1) - i)).drawRec(ctx)
        else:
            _g = start
            _g1 = _hx_max
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                (self.children[i] if i >= 0 and i < len(self.children) else None).drawRec(ctx)
        ctx.globalAlpha = old

    def ysort(self,layer):
        if (layer >= self.layerCount):
            return
        start = (0 if ((layer == 0)) else python_internal_ArrayImpl._get(self.layersIndexes, (layer - 1)))
        _hx_max = (self.layersIndexes[layer] if layer >= 0 and layer < len(self.layersIndexes) else None)
        if (start == _hx_max):
            return
        pos = start
        ymax = pos
        pos = (pos + 1)
        ymax1 = (self.children[ymax] if ymax >= 0 and ymax < len(self.children) else None).y
        while (pos < _hx_max):
            c = (self.children[pos] if pos >= 0 and pos < len(self.children) else None)
            if (c.y < ymax1):
                p = (pos - 1)
                while (p >= start):
                    c2 = (self.children[p] if p >= 0 and p < len(self.children) else None)
                    if (c.y >= c2.y):
                        break
                    python_internal_ArrayImpl._set(self.children, (p + 1), c2)
                    p = (p - 1)
                python_internal_ArrayImpl._set(self.children, (p + 1), c)
                if c.allocated:
                    c.onHierarchyMoved(False)
            else:
                ymax1 = c.y
            pos = (pos + 1)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.layersIndexes = None
        _hx_o.layerCount = None
h2d_Layers._hx_class = h2d_Layers
_hx_classes["h2d.Layers"] = h2d_Layers


class h2d_Mask(h2d_Object):
    _hx_class_name = "h2d.Mask"
    _hx_is_interface = "False"
    __slots__ = ("width", "height", "parentMask", "scrollX", "scrollY", "scrollBounds")
    _hx_fields = ["width", "height", "parentMask", "scrollX", "scrollY", "scrollBounds"]
    _hx_methods = ["scrollTo", "scrollBy", "onHierarchyMoved", "onAdd", "updateMask", "set_scrollX", "set_scrollY", "calcAbsPos", "getBoundsRec", "drawRec"]
    _hx_statics = ["maskWith", "unmask"]
    _hx_interfaces = []
    _hx_super = h2d_Object


    def __init__(self,width,height,parent = None):
        self.scrollBounds = None
        self.parentMask = None
        self.height = None
        self.width = None
        self.scrollY = 0
        self.scrollX = 0
        super().__init__(parent)
        self.width = width
        self.height = height

    def scrollTo(self,x,y):
        self.set_scrollX(x)
        self.set_scrollY(y)

    def scrollBy(self,x,y):
        self.set_scrollX((self.scrollX + x))
        self.set_scrollY((self.scrollY + y))

    def onHierarchyMoved(self,parentChanged):
        super().onHierarchyMoved(parentChanged)
        if parentChanged:
            self.updateMask()

    def onAdd(self):
        super().onAdd()
        self.updateMask()

    def updateMask(self):
        self.parentMask = None
        p = self.parent
        while (p is not None):
            m = Std.downcast(p,h2d_Mask)
            if (m is not None):
                self.parentMask = m
                break
            p = p.parent

    def set_scrollX(self,v):
        if (self.scrollBounds is not None):
            _hx_min = self.scrollBounds.xMin
            _hx_max = (self.scrollBounds.xMax - self.width)
            if (_hx_max is None):
                _hx_max = 1.
            if (_hx_min is None):
                _hx_min = 0.
            if (v < _hx_min):
                v = _hx_min
            elif (v > _hx_max):
                v = _hx_max
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scrollX = v
                return self.scrollX
            return _hx_local_0()
        return _hx_local_1()

    def set_scrollY(self,v):
        if (self.scrollBounds is not None):
            _hx_min = self.scrollBounds.yMin
            _hx_max = (self.scrollBounds.yMax - self.height)
            if (_hx_max is None):
                _hx_max = 1.
            if (_hx_min is None):
                _hx_min = 0.
            if (v < _hx_min):
                v = _hx_min
            elif (v > _hx_max):
                v = _hx_max
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scrollY = v
                return self.scrollY
            return _hx_local_0()
        return _hx_local_1()

    def calcAbsPos(self):
        super().calcAbsPos()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.absX
        _hx_local_0.absX = (_hx_local_1 - self.scrollX)
        _hx_local_0.absX
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.absY
        _hx_local_2.absY = (_hx_local_3 - self.scrollY)
        _hx_local_2.absY

    def getBoundsRec(self,relativeTo,out,forSize):
        xMin = out.xMin
        yMin = out.yMin
        xMax = out.xMax
        yMax = out.yMax
        out.xMin = 1e20
        out.yMin = 1e20
        out.xMax = -1e20
        out.yMax = -1e20
        if self.posChanged:
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.posChanged = True
            self.posChanged = False
        self.addBounds(relativeTo,out,self.scrollX,self.scrollY,self.width,self.height)
        bxMin = out.xMin
        byMin = out.yMin
        bxMax = out.xMax
        byMax = out.yMax
        out.xMin = xMin
        out.xMax = xMax
        out.yMin = yMin
        out.yMax = yMax
        super().getBoundsRec(relativeTo,out,forSize)
        if (out.xMin < bxMin):
            out.xMin = (bxMin if ((xMin > bxMin)) else xMin)
        if (out.yMin < byMin):
            out.yMin = (byMin if ((yMin > byMin)) else yMin)
        if (out.xMax > bxMax):
            out.xMax = (bxMax if ((xMax < bxMax)) else xMax)
        if (out.yMax > byMax):
            out.yMax = (byMax if ((yMax < byMax)) else yMax)

    def drawRec(self,ctx):
        h2d_Mask.maskWith(ctx,self,self.width,self.height,self.scrollX,self.scrollY)
        super().drawRec(ctx)
        h2d_Mask.unmask(ctx)

    @staticmethod
    def maskWith(ctx,object,width,height,scrollX = None,scrollY = None):
        if (scrollX is None):
            scrollX = 0
        if (scrollY is None):
            scrollY = 0
        x1 = (object.absX + scrollX)
        y1 = (object.absY + scrollY)
        x2 = (((width * object.matA) + ((height * object.matC))) + x1)
        y2 = (((width * object.matB) + ((height * object.matD))) + y1)
        tmp = None
        if (x1 > x2):
            tmp = x1
            x1 = x2
            x2 = tmp
        if (y1 > y2):
            tmp = y1
            y1 = y2
            y2 = tmp
        ctx.pushRenderZone(x1,y1,(x2 - x1),(y2 - y1))

    @staticmethod
    def unmask(ctx):
        ctx.popRenderZone()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.parentMask = None
        _hx_o.scrollX = None
        _hx_o.scrollY = None
        _hx_o.scrollBounds = None
h2d_Mask._hx_class = h2d_Mask
_hx_classes["h2d.Mask"] = h2d_Mask


class h3d_impl_RenderContext:
    _hx_class_name = "h3d.impl.RenderContext"
    _hx_is_interface = "False"
    __slots__ = ("engine", "time", "elapsedTime", "frame", "textures")
    _hx_fields = ["engine", "time", "elapsedTime", "frame", "textures"]
    _hx_methods = ["dispose"]

    def __init__(self):
        self.textures = None
        self.engine = h3d_Engine.CURRENT
        self.frame = 0
        self.time = 0.
        self.elapsedTime = (1. / hxd_System.getDefaultFrameRate())
        self.textures = h3d_impl_TextureCache(self)

    def dispose(self):
        self.textures.dispose()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.engine = None
        _hx_o.time = None
        _hx_o.elapsedTime = None
        _hx_o.frame = None
        _hx_o.textures = None
h3d_impl_RenderContext._hx_class = h3d_impl_RenderContext
_hx_classes["h3d.impl.RenderContext"] = h3d_impl_RenderContext


class h2d_RenderContext(h3d_impl_RenderContext):
    _hx_class_name = "h2d.RenderContext"
    _hx_is_interface = "False"
    __slots__ = ("globalAlpha", "buffer", "bufPos", "scene", "defaultSmooth", "killAlpha", "front2back", "onBeginDraw", "onEnterFilter", "onLeaveFilter", "tmpBounds", "texture", "baseShader", "manager", "compiledShader", "buffers", "fixedBuffer", "_hx_pass", "currentShaders", "baseShaderList", "currentObj", "stride", "targetsStack", "targetsStackIndex", "cameraStack", "cameraStackIndex", "curTarget", "renderZoneStack", "renderZoneIndex", "hasUVPos", "filterStack", "inFilter", "inFilterBlend", "viewA", "viewB", "viewC", "viewD", "viewX", "viewY", "hasRenderZone", "renderX", "renderY", "renderW", "renderH", "currentBlend", "baseFlipY", "targetFlipY")
    _hx_fields = ["globalAlpha", "buffer", "bufPos", "scene", "defaultSmooth", "killAlpha", "front2back", "onBeginDraw", "onEnterFilter", "onLeaveFilter", "tmpBounds", "texture", "baseShader", "manager", "compiledShader", "buffers", "fixedBuffer", "pass", "currentShaders", "baseShaderList", "currentObj", "stride", "targetsStack", "targetsStackIndex", "cameraStack", "cameraStackIndex", "curTarget", "renderZoneStack", "renderZoneIndex", "hasUVPos", "filterStack", "inFilter", "inFilterBlend", "viewA", "viewB", "viewC", "viewD", "viewX", "viewY", "hasRenderZone", "renderX", "renderY", "renderW", "renderH", "currentBlend", "baseFlipY", "targetFlipY"]
    _hx_methods = ["dispose", "hasBuffering", "begin", "allocTarget", "clear", "initShaders", "end", "pushCamera", "popCamera", "pushFilter", "popFilter", "pushTarget", "pushTargets", "popTarget", "pushRenderZone", "popRenderZone", "clipRenderZone", "setRZ", "clearRZ", "setRenderZone", "clearRenderZone", "drawLayer", "drawScene", "flush", "_flush", "beforeDraw", "setupColor", "beginDrawBatchState", "swapTexture", "beginDrawObject", "beginDrawBatch", "drawTile", "beginDraw"]
    _hx_statics = ["BUFFERING"]
    _hx_interfaces = []
    _hx_super = h3d_impl_RenderContext


    def __init__(self,scene):
        self.targetFlipY = None
        self.baseFlipY = None
        self.currentBlend = None
        self.renderH = None
        self.renderW = None
        self.renderY = None
        self.renderX = None
        self.hasRenderZone = None
        self.viewY = None
        self.viewX = None
        self.viewD = None
        self.viewC = None
        self.viewB = None
        self.viewA = None
        self.inFilterBlend = None
        self.inFilter = None
        self.filterStack = None
        self.hasUVPos = None
        self.curTarget = None
        self.cameraStackIndex = None
        self.cameraStack = None
        self.targetsStackIndex = None
        self.targetsStack = None
        self.stride = None
        self.currentObj = None
        self.baseShaderList = None
        self.currentShaders = None
        self._hx_pass = None
        self.fixedBuffer = None
        self.buffers = None
        self.compiledShader = None
        self.manager = None
        self.baseShader = None
        self.texture = None
        self.onLeaveFilter = None
        self.onEnterFilter = None
        self.onBeginDraw = None
        self.front2back = None
        self.killAlpha = None
        self.scene = None
        self.bufPos = None
        self.buffer = None
        self.renderZoneIndex = 0
        self.renderZoneStack = []
        self.tmpBounds = h2d_col_Bounds()
        self.defaultSmooth = False
        self.globalAlpha = 1.
        super().__init__()
        self.scene = scene
        self.bufPos = 0
        self.manager = h3d_pass_ShaderManager()
        self._hx_pass = h3d_mat_Pass("",None)
        self._hx_pass.depth(True,h3d_mat_Compare.Always)
        self._hx_pass.set_culling(h3d_mat_Face._hx_None)
        self.baseShader = h3d_shader_Base2d()
        self.baseShader.setPriority(100)
        self.baseShader.zValue__ = 0.
        self.baseShaderList = hxsl_ShaderList(self.baseShader)
        self.targetsStack = []
        self.targetsStackIndex = 0
        self.cameraStack = []
        self.cameraStackIndex = 0
        self.filterStack = []

    def dispose(self):
        super().dispose()
        if (self.fixedBuffer is not None):
            self.fixedBuffer.dispose()

    def hasBuffering(self):
        return False

    def begin(self):
        self.texture = None
        self.currentObj = None
        self.bufPos = 0
        self.stride = 0
        self.viewA = self.scene.viewportA
        self.viewB = 0
        self.viewC = 0
        self.viewD = self.scene.viewportD
        self.viewX = self.scene.viewportX
        self.viewY = self.scene.viewportY
        self.targetFlipY = (-1 if (self.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords)) else 1)
        self.baseFlipY = (self.targetFlipY if ((self.engine.getCurrentTarget() is not None)) else 1)
        self.inFilter = None
        self.manager.globals.set("time",self.time)
        self.manager.globals.set("global.time",self.time)
        _this = self.baseShader
        _this.constModified = True
        _this.pixelAlign__ = False
        _this = self.baseShader.halfPixelInverse__
        x = (0.5 / self.engine.width)
        y = (0.5 / self.engine.height)
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        _this = self.baseShader.viewportA__
        x = self.scene.viewportA
        y = 0
        z = self.scene.viewportX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.viewportB__
        x = 0
        y = (self.scene.viewportD * -self.baseFlipY)
        z = (self.scene.viewportY * -self.baseFlipY)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.filterMatrixA__
        x = 1
        y = 0
        z = 0
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.filterMatrixB__
        x = 0
        y = 1
        z = 0
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        self.baseShaderList.next = None
        self.initShaders(self.baseShaderList)
        self.engine.selectMaterial(self._hx_pass)
        self.textures.begin()

    def allocTarget(self,name,_hx_filter = None):
        if (_hx_filter is None):
            _hx_filter = False
        t = self.textures.allocTarget(name,self.scene.width,self.scene.height,False)
        t.set_filter((h3d_mat_Filter.Linear if _hx_filter else h3d_mat_Filter.Nearest))
        return t

    def clear(self,color):
        self.engine.clear(color)

    def initShaders(self,shaders):
        self.currentShaders = shaders
        self.compiledShader = self.manager.compileShaders(shaders)
        if (self.buffers is None):
            self.buffers = h3d_shader_Buffers(self.compiledShader)
        else:
            _this = self.buffers
            s = self.compiledShader
            _this.vertex.grow(s.vertex)
            _this.fragment.grow(s.fragment)
        self.manager.fillGlobals(self.buffers,self.compiledShader)
        self.engine.selectShader(self.compiledShader)
        self.engine.uploadShaderBuffers(self.buffers,0)

    def end(self):
        self.texture = None
        self.currentObj = None
        self.baseShaderList.next = None
        if (self.targetsStackIndex != 0):
            raise haxe_Exception.thrown("Missing popTarget()")
        if (self.cameraStackIndex != 0):
            raise haxe_Exception.thrown("Missing popCamera()")

    def pushCamera(self,cam):
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.cameraStackIndex
            _hx_local_0.cameraStackIndex = (_hx_local_1 + 1)
            return _hx_local_1
        entry = python_internal_ArrayImpl._get(self.cameraStack, _hx_local_2())
        if (entry is None):
            entry = _hx_AnonObject({'va': 0, 'vb': 0, 'vc': 0, 'vd': 0, 'vx': 0, 'vy': 0})
            _this = self.cameraStack
            _this.append(entry)
        tmpA = self.viewA
        tmpB = self.viewB
        tmpC = self.viewC
        tmpD = self.viewD
        entry.va = tmpA
        entry.vb = tmpB
        entry.vc = tmpC
        entry.vd = tmpD
        entry.vx = self.viewX
        entry.vy = self.viewY
        self.viewA = ((cam.matA * tmpA) + ((cam.matB * tmpC)))
        self.viewB = ((cam.matA * tmpB) + ((cam.matB * tmpD)))
        self.viewC = ((cam.matC * tmpA) + ((cam.matD * tmpC)))
        self.viewD = ((cam.matC * tmpB) + ((cam.matD * tmpD)))
        self.viewX = (((cam.absX * tmpA) + ((cam.absY * tmpC))) + self.viewX)
        self.viewY = (((cam.absX * tmpB) + ((cam.absY * tmpD))) + self.viewY)
        flipY = (-self.targetFlipY if ((self.curTarget is not None)) else -self.baseFlipY)
        _this = self.baseShader.viewportA__
        x = self.viewA
        y = self.viewC
        z = self.viewX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.viewportB__
        x = (self.viewB * flipY)
        y = (self.viewD * flipY)
        z = (self.viewY * flipY)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.

    def popCamera(self):
        if (self.cameraStackIndex == 0):
            raise haxe_Exception.thrown("Too many popCamera()")
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.cameraStackIndex
            _hx_local_0.cameraStackIndex = (_hx_local_1 - 1)
            return _hx_local_0.cameraStackIndex
        inf = python_internal_ArrayImpl._get(self.cameraStack, _hx_local_2())
        self.viewA = inf.va
        self.viewB = inf.vb
        self.viewC = inf.vc
        self.viewD = inf.vd
        self.viewX = inf.vx
        self.viewY = inf.vy
        flipY = (-self.targetFlipY if ((self.curTarget is not None)) else -self.baseFlipY)
        _this = self.baseShader.viewportA__
        x = self.viewA
        y = self.viewC
        z = self.viewX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.viewportB__
        x = (self.viewB * flipY)
        y = (self.viewD * flipY)
        z = (self.viewY * flipY)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.

    def pushFilter(self,spr):
        if ((len(self.filterStack) == 0) and ((self.onEnterFilter is not None))):
            if (not self.onEnterFilter(spr)):
                return False
        _this = self.filterStack
        _this.append(spr)
        self.inFilter = spr
        return True

    def popFilter(self):
        _this = self.filterStack
        spr = (None if ((len(_this) == 0)) else _this.pop())
        if (len(self.filterStack) > 0):
            self.inFilter = python_internal_ArrayImpl._get(self.filterStack, (len(self.filterStack) - 1))
        else:
            self.inFilter = None
            if (self.onLeaveFilter is not None):
                self.onLeaveFilter(spr)

    def pushTarget(self,t,startX = None,startY = None,width = None,height = None):
        if (startX is None):
            startX = 0
        if (startY is None):
            startY = 0
        if (width is None):
            width = -1
        if (height is None):
            height = -1
        self.engine.pushTarget(t)
        self.initShaders(self.baseShaderList)
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.targetsStackIndex
            _hx_local_0.targetsStackIndex = (_hx_local_1 + 1)
            return _hx_local_1
        entry = python_internal_ArrayImpl._get(self.targetsStack, _hx_local_2())
        if (entry is None):
            entry = _hx_AnonObject({'t': None, 'va': 0, 'vb': 0, 'vc': 0, 'vd': 0, 'vx': 0, 'vy': 0, 'hasRZ': False, 'rzX': 0, 'rzY': 0, 'rzW': 0, 'rzH': 0})
            _this = self.targetsStack
            _this.append(entry)
        entry.t = self.curTarget
        entry.va = self.viewA
        entry.vb = self.viewB
        entry.vc = self.viewC
        entry.vd = self.viewD
        entry.vx = self.viewX
        entry.vy = self.viewY
        entry.hasRZ = self.hasRenderZone
        entry.rzX = self.renderX
        entry.rzY = self.renderY
        entry.rzW = self.renderW
        entry.rzH = self.renderH
        if (width < 0):
            width = (self.scene.width if ((t is None)) else t.width)
        if (height < 0):
            height = (self.scene.height if ((t is None)) else t.height)
        self.viewA = (2 / width)
        self.viewB = 0
        self.viewC = 0
        self.viewD = (2 / height)
        self.viewX = (-1 - ((startX * self.viewA)))
        self.viewY = (-1 - ((startY * self.viewD)))
        _this = self.baseShader.halfPixelInverse__
        x = (0.5 / ((self.engine.width if ((t is None)) else t.width)))
        y = (0.5 / ((self.engine.height if ((t is None)) else t.height)))
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        _this = self.baseShader.viewportA__
        x = self.viewA
        y = self.viewC
        z = self.viewX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.viewportB__
        x = (self.viewB * -self.targetFlipY)
        y = (self.viewD * -self.targetFlipY)
        z = (self.viewY * -self.targetFlipY)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        self.curTarget = t
        self.currentBlend = None
        if self.hasRenderZone:
            self.hasRenderZone = False
            self.engine.setRenderZone()

    def pushTargets(self,texs):
        self.pushTarget((texs[0] if 0 < len(texs) else None))
        if (len(texs) > 1):
            self.engine.popTarget()
            self.engine.pushTargets(texs)

    def popTarget(self):
        if (self.targetsStackIndex <= 0):
            raise haxe_Exception.thrown("Too many popTarget()")
        self.engine.popTarget()
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.targetsStackIndex
            _hx_local_0.targetsStackIndex = (_hx_local_1 - 1)
            return _hx_local_0.targetsStackIndex
        tinf = python_internal_ArrayImpl._get(self.targetsStack, _hx_local_2())
        def _hx_local_3():
            self.curTarget = tinf.t
            return self.curTarget
        t = _hx_local_3()
        self.viewA = tinf.va
        self.viewB = tinf.vb
        self.viewC = tinf.vc
        self.viewD = tinf.vd
        self.viewX = tinf.vx
        self.viewY = tinf.vy
        flipY = (-self.baseFlipY if ((t is None)) else -self.targetFlipY)
        self.initShaders(self.baseShaderList)
        _this = self.baseShader.halfPixelInverse__
        x = (0.5 / ((self.engine.width if ((t is None)) else t.width)))
        y = (0.5 / ((self.engine.height if ((t is None)) else t.height)))
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        _this = self.baseShader.viewportA__
        x = self.viewA
        y = self.viewC
        z = self.viewX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.viewportB__
        x = (self.viewB * flipY)
        y = (self.viewD * flipY)
        z = (self.viewY * flipY)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        if tinf.hasRZ:
            self.setRZ(tinf.rzX,tinf.rzY,tinf.rzW,tinf.rzH)

    def pushRenderZone(self,x,y,w,h):
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.renderZoneIndex
            _hx_local_0.renderZoneIndex = (_hx_local_1 + 1)
            return _hx_local_1
        inf = python_internal_ArrayImpl._get(self.renderZoneStack, _hx_local_2())
        if (inf is None):
            inf = _hx_AnonObject({'hasRZ': self.hasRenderZone, 'x': self.renderX, 'y': self.renderY, 'w': self.renderW, 'h': self.renderH})
            python_internal_ArrayImpl._set(self.renderZoneStack, (self.renderZoneIndex - 1), inf)
        elif self.hasRenderZone:
            inf.hasRZ = True
            inf.x = self.renderX
            inf.y = self.renderY
            inf.w = self.renderW
            inf.h = self.renderH
        else:
            inf.hasRZ = False
        self.setRZ(x,y,w,h)

    def popRenderZone(self):
        if (self.renderZoneIndex == 0):
            raise haxe_Exception.thrown("Too many popRenderZone()")
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.renderZoneIndex
            _hx_local_0.renderZoneIndex = (_hx_local_1 - 1)
            return _hx_local_0.renderZoneIndex
        inf = python_internal_ArrayImpl._get(self.renderZoneStack, _hx_local_2())
        if inf.hasRZ:
            self.setRZ(inf.x,inf.y,inf.w,inf.h)
        else:
            self.hasRenderZone = False
            self.engine.setRenderZone()

    def clipRenderZone(self,x,y,w,h):
        if (not self.hasRenderZone):
            self.pushRenderZone(x,y,w,h)
            return
        b = self.renderX
        if (not python_lib_Math.isnan(x)):
            x = (b if (python_lib_Math.isnan(b)) else max(x,b))
        b = self.renderY
        if (not python_lib_Math.isnan(y)):
            y = (b if (python_lib_Math.isnan(b)) else max(y,b))
        a = (x + w)
        b = (self.renderX + self.renderW)
        x2 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        a = (y + h)
        b = (self.renderY + self.renderH)
        y2 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        if (x2 < x):
            x2 = x
        if (y2 < y):
            y2 = y
        self.pushRenderZone(x,y,(x2 - x),(y2 - y))

    def setRZ(self,x,y,w,h):
        self.hasRenderZone = True
        self.renderX = x
        self.renderY = y
        self.renderW = w
        self.renderH = h
        scaleX = ((self.scene.viewportA * self.engine.width) / 2)
        scaleY = ((self.scene.viewportD * self.engine.height) / 2)
        if (self.inFilter is not None):
            fa = self.baseShader.filterMatrixA__
            fb = self.baseShader.filterMatrixB__
            x2 = (x + w)
            y2 = (y + h)
            rx1 = (((x * fa.x) + ((y * fa.y))) + fa.z)
            ry1 = (((x * fb.x) + ((y * fb.y))) + fb.z)
            rx2 = (((x2 * fa.x) + ((y2 * fa.y))) + fa.z)
            ry2 = (((x2 * fb.x) + ((y2 * fb.y))) + fb.z)
            x = rx1
            y = ry1
            w = (rx2 - rx1)
            h = (ry2 - ry1)
        tmp = self.engine
        x1 = (((x * scaleX) + ((((self.scene.viewportX + 1)) * ((self.engine.width / 2))))) + 1e-10)
        tmp1 = None
        try:
            tmp1 = int(x1)
        except BaseException as _g:
            None
            tmp1 = None
        x = (((y * scaleY) + ((((self.scene.viewportY + 1)) * ((self.engine.height / 2))))) + 1e-10)
        tmp2 = None
        try:
            tmp2 = int(x)
        except BaseException as _g:
            None
            tmp2 = None
        tmp3 = None
        try:
            tmp3 = int(((w * scaleX) + 1e-10))
        except BaseException as _g:
            None
            tmp3 = None
        tmp4 = tmp3
        tmp3 = None
        try:
            tmp3 = int(((h * scaleY) + 1e-10))
        except BaseException as _g:
            None
            tmp3 = None
        tmp.setRenderZone(tmp1,tmp2,tmp4,tmp3)

    def clearRZ(self):
        self.hasRenderZone = False
        self.engine.setRenderZone()

    def setRenderZone(self,x,y,w,h):
        self.pushRenderZone(x,y,w,h)

    def clearRenderZone(self):
        self.popRenderZone()

    def drawLayer(self,layer):
        self.scene.drawLayer(self,layer)

    def drawScene(self):
        self.scene.drawRec(self)

    def flush(self):
        pass

    def _flush(self):
        if (self.bufPos == 0):
            return
        self.beforeDraw()
        x = (self.bufPos / self.stride)
        nverts = None
        try:
            nverts = int(x)
        except BaseException as _g:
            None
            nverts = None
        tmp = h3d_Buffer(nverts,self.stride,[h3d_BufferFlag.Quads, h3d_BufferFlag.Dynamic, h3d_BufferFlag.RawFormat])
        tmp.uploadVector(self.buffer,0,nverts)
        _this = self.engine
        _this.renderBuffer(tmp,_this.mem.quadIndexes,2,0,-1)
        tmp.dispose()
        self.bufPos = 0
        self.texture = None

    def beforeDraw(self):
        if (self.texture is None):
            self.texture = h3d_mat_Texture.fromColor(16711935)
        self.baseShader.texture__ = self.texture
        self.texture.set_filter((h3d_mat_Filter.Linear if ((self.defaultSmooth if ((self.currentObj.smooth is None)) else self.currentObj.smooth)) else h3d_mat_Filter.Nearest))
        self.texture.set_wrap((h3d_mat_Wrap.Repeat if ((self.currentObj.tileWrap and (((self.currentObj.filter is None) or ((self.inFilter is not None)))))) else h3d_mat_Wrap.Clamp))
        blend = self.currentObj.blendMode
        if ((self.inFilter == self.currentObj) and ((blend == h2d_BlendMode.Erase))):
            blend = h2d_BlendMode.Add
        if (self.inFilterBlend is not None):
            blend = self.inFilterBlend
        if (blend != self.currentBlend):
            self.currentBlend = blend
            self._hx_pass.setBlendMode(blend)
            if ((blend == h2d_BlendMode.Alpha) or ((blend == h2d_BlendMode.Add))):
                self._hx_pass.set_blendAlphaSrc(h3d_mat_Blend.One)
                if (self.inFilterBlend is not None):
                    self._hx_pass.set_blendSrc(h3d_mat_Blend.One)
        self.manager.fillParams(self.buffers,self.compiledShader,self.currentShaders)
        self.engine.selectMaterial(self._hx_pass)
        self.engine.uploadShaderBuffers(self.buffers,1)
        self.engine.uploadShaderBuffers(self.buffers,2)
        self.engine.uploadShaderBuffers(self.buffers,3)

    def setupColor(self,obj):
        if (self.inFilter == obj):
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = obj.color.w
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        elif (self.inFilterBlend is not None):
            _this = self.baseShader.color__
            x = self.globalAlpha
            y = self.globalAlpha
            z = self.globalAlpha
            w = self.globalAlpha
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        else:
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = (obj.color.w * self.globalAlpha)
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w

    def beginDrawBatchState(self,obj):
        if (not self.beginDraw(obj,None,True)):
            return False
        if (self.inFilter == obj):
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = obj.color.w
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        elif (self.inFilterBlend is not None):
            _this = self.baseShader.color__
            x = self.globalAlpha
            y = self.globalAlpha
            z = self.globalAlpha
            w = self.globalAlpha
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        else:
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = (obj.color.w * self.globalAlpha)
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        _this = self.baseShader.absoluteMatrixA__
        x = obj.matA
        y = obj.matC
        z = obj.absX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.absoluteMatrixB__
        x = obj.matB
        y = obj.matD
        z = obj.absY
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        return True

    def swapTexture(self,texture):
        self.texture = texture
        self.beforeDraw()

    def beginDrawObject(self,obj,texture):
        if (not self.beginDraw(obj,texture,True)):
            return False
        if (self.inFilter == obj):
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = obj.color.w
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        elif (self.inFilterBlend is not None):
            _this = self.baseShader.color__
            x = self.globalAlpha
            y = self.globalAlpha
            z = self.globalAlpha
            w = self.globalAlpha
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        else:
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = (obj.color.w * self.globalAlpha)
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        _this = self.baseShader.absoluteMatrixA__
        x = obj.matA
        y = obj.matC
        z = obj.absX
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.absoluteMatrixB__
        x = obj.matB
        y = obj.matD
        z = obj.absY
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        self.beforeDraw()
        return True

    def beginDrawBatch(self,obj,texture):
        return self.beginDraw(obj,texture,False)

    def drawTile(self,obj,tile):
        matA = None
        matB = None
        matC = None
        matD = None
        absX = None
        absY = None
        if (self.inFilter is not None):
            f1 = self.baseShader.filterMatrixA__
            f2 = self.baseShader.filterMatrixB__
            tmpA = ((obj.matA * f1.x) + ((obj.matB * f1.y)))
            tmpB = ((obj.matA * f2.x) + ((obj.matB * f2.y)))
            tmpC = ((obj.matC * f1.x) + ((obj.matD * f1.y)))
            tmpD = ((obj.matC * f2.x) + ((obj.matD * f2.y)))
            tmpX = (((obj.absX * f1.x) + ((obj.absY * f1.y))) + f1.z)
            tmpY = (((obj.absX * f2.x) + ((obj.absY * f2.y))) + f2.z)
            matA = ((tmpA * self.viewA) + ((tmpB * self.viewC)))
            matB = ((tmpA * self.viewB) + ((tmpB * self.viewD)))
            matC = ((tmpC * self.viewA) + ((tmpD * self.viewC)))
            matD = ((tmpC * self.viewB) + ((tmpD * self.viewD)))
            absX = (((tmpX * self.viewA) + ((tmpY * self.viewC))) + self.viewX)
            absY = (((tmpX * self.viewB) + ((tmpY * self.viewD))) + self.viewY)
        else:
            matA = ((obj.matA * self.viewA) + ((obj.matB * self.viewC)))
            matB = ((obj.matA * self.viewB) + ((obj.matB * self.viewD)))
            matC = ((obj.matC * self.viewA) + ((obj.matD * self.viewC)))
            matD = ((obj.matC * self.viewB) + ((obj.matD * self.viewD)))
            absX = (((obj.absX * self.viewA) + ((obj.absY * self.viewC))) + self.viewX)
            absY = (((obj.absX * self.viewB) + ((obj.absY * self.viewD))) + self.viewY)
        if ((matB == 0) and ((matC == 0))):
            tx = (tile.dx + ((tile.width * 0.5)))
            ty = (tile.dy + ((tile.height * 0.5)))
            a = (-matA if ((matA < 0)) else matA)
            b = (-matD if ((matD < 0)) else matD)
            tr = ((((tile.width if ((tile.width > tile.height)) else tile.height)) * 1.5) * ((b if ((a < b)) else a)))
            cx = (absX + ((tx * matA)))
            cy = (absY + ((ty * matD)))
            if (((((cx + tr) < -1) or (((cx - tr) > 1))) or (((cy + tr) < -1))) or (((cy - tr) > 1))):
                return False
        else:
            xMin = 1e20
            yMin = 1e20
            xMax = -1e20
            yMax = -1e20
            hw = (tile.width * 0.5)
            hh = (tile.height * 0.5)
            px = ((tile.dx * matA) + ((tile.dy * matC)))
            py = ((tile.dx * matB) + ((tile.dy * matD)))
            if (px < xMin):
                xMin = px
            if (px > xMax):
                xMax = px
            if (py < yMin):
                yMin = py
            if (py > yMax):
                yMax = py
            x = tile.width
            px = ((((x + tile.dx)) * matA) + ((tile.dy * matC)))
            py = ((((x + tile.dx)) * matB) + ((tile.dy * matD)))
            if (px < xMin):
                xMin = px
            if (px > xMax):
                xMax = px
            if (py < yMin):
                yMin = py
            if (py > yMax):
                yMax = py
            y = tile.height
            px = ((tile.dx * matA) + ((((y + tile.dy)) * matC)))
            py = ((tile.dx * matB) + ((((y + tile.dy)) * matD)))
            if (px < xMin):
                xMin = px
            if (px > xMax):
                xMax = px
            if (py < yMin):
                yMin = py
            if (py > yMax):
                yMax = py
            x = tile.width
            y = tile.height
            px = ((((x + tile.dx)) * matA) + ((((y + tile.dy)) * matC)))
            py = ((((x + tile.dx)) * matB) + ((((y + tile.dy)) * matD)))
            if (px < xMin):
                xMin = px
            if (px > xMax):
                xMax = px
            if (py < yMin):
                yMin = py
            if (py > yMax):
                yMax = py
            if (((((absX + xMax) < -1) or (((absY + yMax) < -1))) or (((absX + xMin) > 1))) or (((absY + yMin) > 1))):
                return False
        if (not self.beginDraw(obj,tile.innerTex,True,True)):
            return False
        if (self.inFilter == obj):
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = obj.color.w
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        elif (self.inFilterBlend is not None):
            _this = self.baseShader.color__
            x = self.globalAlpha
            y = self.globalAlpha
            z = self.globalAlpha
            w = self.globalAlpha
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        else:
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = (obj.color.w * self.globalAlpha)
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        _this = self.baseShader.absoluteMatrixA__
        x = (tile.width * obj.matA)
        y = (tile.height * obj.matC)
        z = ((obj.absX + ((tile.dx * obj.matA))) + ((tile.dy * obj.matC)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.absoluteMatrixB__
        x = (tile.width * obj.matB)
        y = (tile.height * obj.matD)
        z = ((obj.absY + ((tile.dx * obj.matB))) + ((tile.dy * obj.matD)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.baseShader.uvPos__
        x = tile.u
        y = tile.v
        z = (tile.u2 - tile.u)
        w = (tile.v2 - tile.v)
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = w
        self.beforeDraw()
        tmp = None
        if (self.fixedBuffer is not None):
            _this = self.fixedBuffer
            tmp = ((_this.buffer is None) or ((_this.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            self.fixedBuffer = h3d_Buffer(4,8,[h3d_BufferFlag.Quads, h3d_BufferFlag.RawFormat])
            this1 = list()
            k = this1
            v = 0
            k.append(v)
            v = 0
            k.append(v)
            v = 0
            k.append(v)
            v = 0
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 0
            k.append(v)
            v = 1
            k.append(v)
            v = 0
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 0
            k.append(v)
            v = 1
            k.append(v)
            v = 0
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            v = 1
            k.append(v)
            self.fixedBuffer.uploadVector(k,0,4)
        _this = self.engine
        _this.renderBuffer(self.fixedBuffer,_this.mem.quadIndexes,2,0,-1)
        return True

    def beginDraw(self,obj,texture,isRelative,hasUVPos = None):
        if (hasUVPos is None):
            hasUVPos = False
        if ((self.onBeginDraw is not None) and (not self.onBeginDraw(obj))):
            return False
        stride = 8
        shaderChanged = False
        paramsChanged = False
        objShaders = obj.shaders
        curShaders = self.currentShaders.next
        while ((objShaders is not None) and ((curShaders is not None))):
            s = objShaders.s
            t = curShaders.s
            objShaders = objShaders.next
            curShaders = curShaders.next
            prevInst = t.instance
            if (s != t):
                paramsChanged = True
            s.updateConstants(self.manager.globals)
            if (s.instance != prevInst):
                shaderChanged = True
        if (((((objShaders is not None) or ((curShaders is not None))) or ((self.baseShader.isRelative__ != isRelative))) or ((self.baseShader.hasUVPos__ != hasUVPos))) or ((self.baseShader.killAlpha__ != self.killAlpha))):
            shaderChanged = True
        if shaderChanged:
            _this = self.baseShader
            _this.constModified = True
            _this.hasUVPos__ = hasUVPos
            _this = self.baseShader
            _this.constModified = True
            _this.isRelative__ = isRelative
            _this = self.baseShader
            _this.constModified = True
            _this.killAlpha__ = self.killAlpha
            self.baseShader.updateConstants(self.manager.globals)
            self.baseShaderList.next = obj.shaders
            self.initShaders(self.baseShaderList)
        elif paramsChanged:
            if (self.currentShaders != self.baseShaderList):
                raise haxe_Exception.thrown("!")
            self.currentShaders.next = obj.shaders
        self.texture = texture
        self.stride = stride
        self.currentObj = obj
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.globalAlpha = None
        _hx_o.buffer = None
        _hx_o.bufPos = None
        _hx_o.scene = None
        _hx_o.defaultSmooth = None
        _hx_o.killAlpha = None
        _hx_o.front2back = None
        _hx_o.onBeginDraw = None
        _hx_o.onEnterFilter = None
        _hx_o.onLeaveFilter = None
        _hx_o.tmpBounds = None
        _hx_o.texture = None
        _hx_o.baseShader = None
        _hx_o.manager = None
        _hx_o.compiledShader = None
        _hx_o.buffers = None
        _hx_o.fixedBuffer = None
        _hx_o._hx_pass = None
        _hx_o.currentShaders = None
        _hx_o.baseShaderList = None
        _hx_o.currentObj = None
        _hx_o.stride = None
        _hx_o.targetsStack = None
        _hx_o.targetsStackIndex = None
        _hx_o.cameraStack = None
        _hx_o.cameraStackIndex = None
        _hx_o.curTarget = None
        _hx_o.renderZoneStack = None
        _hx_o.renderZoneIndex = None
        _hx_o.hasUVPos = None
        _hx_o.filterStack = None
        _hx_o.inFilter = None
        _hx_o.inFilterBlend = None
        _hx_o.viewA = None
        _hx_o.viewB = None
        _hx_o.viewC = None
        _hx_o.viewD = None
        _hx_o.viewX = None
        _hx_o.viewY = None
        _hx_o.hasRenderZone = None
        _hx_o.renderX = None
        _hx_o.renderY = None
        _hx_o.renderW = None
        _hx_o.renderH = None
        _hx_o.currentBlend = None
        _hx_o.baseFlipY = None
        _hx_o.targetFlipY = None
h2d_RenderContext._hx_class = h2d_RenderContext
_hx_classes["h2d.RenderContext"] = h2d_RenderContext

class h2d_ScaleModeAlign(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.ScaleModeAlign"
    _hx_constructs = ["Left", "Right", "Center", "Top", "Bottom"]
h2d_ScaleModeAlign.Left = h2d_ScaleModeAlign("Left", 0, ())
h2d_ScaleModeAlign.Right = h2d_ScaleModeAlign("Right", 1, ())
h2d_ScaleModeAlign.Center = h2d_ScaleModeAlign("Center", 2, ())
h2d_ScaleModeAlign.Top = h2d_ScaleModeAlign("Top", 3, ())
h2d_ScaleModeAlign.Bottom = h2d_ScaleModeAlign("Bottom", 4, ())
h2d_ScaleModeAlign._hx_class = h2d_ScaleModeAlign
_hx_classes["h2d.ScaleModeAlign"] = h2d_ScaleModeAlign

class h2d_ScaleMode(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.ScaleMode"
    _hx_constructs = ["Resize", "Stretch", "LetterBox", "Fixed", "Zoom", "AutoZoom"]

    @staticmethod
    def Stretch(width,height):
        return h2d_ScaleMode("Stretch", 1, (width,height))

    @staticmethod
    def LetterBox(width,height,integerScale = None,horizontalAlign= None,verticalAlign= None):
        return h2d_ScaleMode("LetterBox", 2, (width,height,integerScale,horizontalAlign,verticalAlign))

    @staticmethod
    def Fixed(width,height,zoom,horizontalAlign = None,verticalAlign= None):
        return h2d_ScaleMode("Fixed", 3, (width,height,zoom,horizontalAlign,verticalAlign))

    @staticmethod
    def Zoom(level):
        return h2d_ScaleMode("Zoom", 4, (level,))

    @staticmethod
    def AutoZoom(minWidth,minHeight,integerScaling = None):
        return h2d_ScaleMode("AutoZoom", 5, (minWidth,minHeight,integerScaling))
h2d_ScaleMode.Resize = h2d_ScaleMode("Resize", 0, ())
h2d_ScaleMode._hx_class = h2d_ScaleMode
_hx_classes["h2d.ScaleMode"] = h2d_ScaleMode


class hxd_InteractiveScene:
    _hx_class_name = "hxd.InteractiveScene"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["setEvents", "handleEvent", "dispatchEvent", "dispatchListeners", "isInteractiveVisible"]
hxd_InteractiveScene._hx_class = hxd_InteractiveScene
_hx_classes["hxd.InteractiveScene"] = hxd_InteractiveScene


class h2d_Scene(h2d_Layers):
    _hx_class_name = "h2d.Scene"
    _hx_is_interface = "False"
    __slots__ = ("width", "height", "viewportA", "viewportD", "viewportX", "viewportY", "offsetX", "offsetY", "viewportScaleX", "viewportScaleY", "mouseX", "mouseY", "scaleMode", "_cameras", "interactiveCamera", "interactive", "eventListeners", "ctx", "window", "events", "shapePoint")
    _hx_fields = ["width", "height", "viewportA", "viewportD", "viewportX", "viewportY", "offsetX", "offsetY", "viewportScaleX", "viewportScaleY", "scaleMode", "_cameras", "interactiveCamera", "interactive", "eventListeners", "ctx", "window", "events", "shapePoint"]
    _hx_methods = ["get_defaultSmooth", "set_defaultSmooth", "setEvents", "get_zoom", "set_zoom", "set_scaleMode", "get_renderer", "set_renderer", "get_camera", "get_cameras", "set_interactiveCamera", "addCamera", "removeCamera", "setFixedSize", "checkResize", "screenXToViewport", "screenYToViewport", "get_mouseX", "get_mouseY", "dispatchListeners", "isInteractiveVisible", "getInteractive", "screenToViewport", "dispatchEvent", "handleEvent", "addEventListener", "removeEventListener", "startCapture", "stopCapture", "startDrag", "stopDrag", "getFocus", "addEventTarget", "removeEventTarget", "dispose", "setElapsedTime", "drawImplTo", "syncOnly", "render", "sync", "clipBounds", "drawContent", "onAdd", "onRemove", "captureBitmap"]
    _hx_statics = []
    _hx_interfaces = [hxd_InteractiveScene, h3d_IDrawable]
    _hx_super = h2d_Layers


    def __init__(self):
        self.shapePoint = None
        self.events = None
        self.window = None
        self.ctx = None
        self.eventListeners = None
        self.interactive = None
        self.interactiveCamera = None
        self._cameras = None
        self.mouseY = None
        self.mouseX = None
        self.viewportScaleY = None
        self.viewportScaleX = None
        self.offsetY = None
        self.offsetX = None
        self.viewportY = None
        self.viewportX = None
        self.viewportD = None
        self.viewportA = None
        self.height = None
        self.width = None
        self.scaleMode = h2d_ScaleMode.Resize
        super().__init__(None)
        e = h3d_Engine.CURRENT
        self.ctx = h2d_RenderContext(self)
        self._cameras = []
        h2d_Camera(self)
        self.set_interactiveCamera((self._cameras[0] if 0 < len(self._cameras) else None))
        self.width = e.width
        self.height = e.height
        self.viewportA = (2 / e.width)
        self.viewportD = (2 / e.height)
        self.viewportX = -1
        self.viewportY = -1
        self.viewportScaleX = 1
        self.viewportScaleY = 1
        self.offsetX = 0
        self.offsetY = 0
        self.interactive = list()
        self.eventListeners = list()
        self.shapePoint = h2d_col_Point()
        self.window = hxd_Window.getInstance()
        self.posChanged = True

    def get_defaultSmooth(self):
        return self.ctx.defaultSmooth

    def set_defaultSmooth(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.ctx.defaultSmooth = v
                return self.ctx.defaultSmooth
            return _hx_local_0()
        return _hx_local_1()

    def setEvents(self,events):
        self.events = events

    def get_zoom(self):
        _g = self.scaleMode
        if (_g.index == 4):
            level = _g.params[0]
            tmp = None
            try:
                tmp = int(level)
            except BaseException as _g:
                None
                tmp = None
            return tmp
        else:
            return 0

    def set_zoom(self,v):
        self.set_scaleMode(h2d_ScaleMode.Zoom(v))
        return v

    def set_scaleMode(self,v):
        self.scaleMode = v
        self.checkResize()
        return v

    def get_renderer(self):
        return self.ctx

    def set_renderer(self,v):
        self.ctx = v
        return v

    def get_camera(self):
        return (self._cameras[0] if 0 < len(self._cameras) else None)

    def get_cameras(self):
        return self._cameras

    def set_interactiveCamera(self,cam):
        if (cam is None):
            raise haxe_Exception.thrown("Interactive cammera cannot be null!")
        if (cam.scene != self):
            self.addCamera(cam)
        def _hx_local_1():
            def _hx_local_0():
                self.interactiveCamera = cam
                return self.interactiveCamera
            return _hx_local_0()
        return _hx_local_1()

    def addCamera(self,cam,pos = None):
        if (cam.scene is not None):
            cam.scene.removeCamera(cam)
        cam.scene = self
        cam.posChanged = True
        if (pos is not None):
            self._cameras.insert(pos, cam)
        else:
            _this = self._cameras
            _this.append(cam)

    def removeCamera(self,cam):
        if (cam == self.interactiveCamera):
            raise haxe_Exception.thrown("Current interactive Camera cannot be removed from camera list!")
        cam.scene = None
        python_internal_ArrayImpl.remove(self._cameras,cam)

    def setFixedSize(self,w,h):
        self.set_scaleMode(h2d_ScaleMode.Stretch(w,h))

    def checkResize(self):
        _gthis = self
        engine = h3d_Engine.CURRENT
        _g = self.scaleMode
        tmp = _g.index
        if (tmp == 0):
            w = engine.width
            h = engine.height
            if ((w != _gthis.width) or ((h != _gthis.height))):
                _gthis.width = w
                _gthis.height = h
                _gthis.posChanged = True
            _gthis.viewportScaleX = 1
            _gthis.viewportScaleY = 1
            _gthis.viewportA = (2 / _gthis.width)
            _gthis.viewportD = (2 / _gthis.height)
            _gthis.viewportX = -1
            _gthis.viewportY = -1
        elif (tmp == 1):
            _width = _g.params[0]
            _height = _g.params[1]
            if ((_width != _gthis.width) or ((_height != _gthis.height))):
                _gthis.width = _width
                _gthis.height = _height
                _gthis.posChanged = True
            _gthis.viewportScaleX = (engine.width / _width)
            _gthis.viewportScaleY = (engine.height / _height)
            _gthis.viewportA = (2 / _gthis.width)
            _gthis.viewportD = (2 / _gthis.height)
            _gthis.viewportX = -1
            _gthis.viewportY = -1
        elif (tmp == 2):
            _width = _g.params[0]
            _height = _g.params[1]
            integerScale = _g.params[2]
            horizontalAlign = _g.params[3]
            verticalAlign = _g.params[4]
            if ((_width != _gthis.width) or ((_height != _gthis.height))):
                _gthis.width = _width
                _gthis.height = _height
                _gthis.posChanged = True
            a = (engine.width / _width)
            b = (engine.height / _height)
            zoom = (b if ((a > b)) else a)
            if integerScale:
                zoom1 = None
                try:
                    zoom1 = int(zoom)
                except BaseException as _g1:
                    None
                    zoom1 = None
                zoom = zoom1
                if (zoom == 0):
                    zoom = 1
            horizontal = horizontalAlign
            vertical = verticalAlign
            _gthis.viewportA = ((zoom * 2) / engine.width)
            _gthis.viewportD = ((zoom * 2) / engine.height)
            _gthis.viewportScaleX = zoom
            _gthis.viewportScaleY = zoom
            if (horizontal is None):
                horizontal = h2d_ScaleModeAlign.Center
            tmp = horizontal.index
            if (tmp == 0):
                _gthis.viewportX = -1
                _gthis.offsetX = 0
            elif (tmp == 1):
                _gthis.viewportX = (1 - ((_gthis.width * _gthis.viewportA)))
                _gthis.offsetX = (engine.width - ((_gthis.width * zoom)))
            else:
                _gthis.viewportX = ((Math.floor((((engine.width - ((_gthis.width * zoom)))) / ((zoom * 2)))) * _gthis.viewportA) - 1.)
                _gthis.offsetX = Math.floor((((engine.width - ((_gthis.width * zoom)))) / 2))
            if (vertical is None):
                vertical = h2d_ScaleModeAlign.Center
            tmp = vertical.index
            if (tmp == 3):
                _gthis.viewportY = -1
                _gthis.offsetY = 0
            elif (tmp == 4):
                _gthis.viewportY = (1 - ((_gthis.height * _gthis.viewportD)))
                _gthis.offsetY = (engine.height - ((_gthis.height * zoom)))
            else:
                _gthis.viewportY = ((Math.floor((((engine.height - ((_gthis.height * zoom)))) / ((zoom * 2)))) * _gthis.viewportD) - 1.)
                _gthis.offsetY = Math.floor((((engine.height - ((_gthis.height * zoom)))) / 2))
        elif (tmp == 3):
            _width = _g.params[0]
            _height = _g.params[1]
            zoom = _g.params[2]
            horizontalAlign = _g.params[3]
            verticalAlign = _g.params[4]
            if ((_width != _gthis.width) or ((_height != _gthis.height))):
                _gthis.width = _width
                _gthis.height = _height
                _gthis.posChanged = True
            horizontal = horizontalAlign
            vertical = verticalAlign
            _gthis.viewportA = ((zoom * 2) / engine.width)
            _gthis.viewportD = ((zoom * 2) / engine.height)
            _gthis.viewportScaleX = zoom
            _gthis.viewportScaleY = zoom
            if (horizontal is None):
                horizontal = h2d_ScaleModeAlign.Center
            tmp = horizontal.index
            if (tmp == 0):
                _gthis.viewportX = -1
                _gthis.offsetX = 0
            elif (tmp == 1):
                _gthis.viewportX = (1 - ((_gthis.width * _gthis.viewportA)))
                _gthis.offsetX = (engine.width - ((_gthis.width * zoom)))
            else:
                _gthis.viewportX = ((Math.floor((((engine.width - ((_gthis.width * zoom)))) / ((zoom * 2)))) * _gthis.viewportA) - 1.)
                _gthis.offsetX = Math.floor((((engine.width - ((_gthis.width * zoom)))) / 2))
            if (vertical is None):
                vertical = h2d_ScaleModeAlign.Center
            tmp = vertical.index
            if (tmp == 3):
                _gthis.viewportY = -1
                _gthis.offsetY = 0
            elif (tmp == 4):
                _gthis.viewportY = (1 - ((_gthis.height * _gthis.viewportD)))
                _gthis.offsetY = (engine.height - ((_gthis.height * zoom)))
            else:
                _gthis.viewportY = ((Math.floor((((engine.height - ((_gthis.height * zoom)))) / ((zoom * 2)))) * _gthis.viewportD) - 1.)
                _gthis.offsetY = Math.floor((((engine.height - ((_gthis.height * zoom)))) / 2))
        elif (tmp == 4):
            level = _g.params[0]
            w = Math.ceil((engine.width / level))
            h = Math.ceil((engine.height / level))
            if ((w != _gthis.width) or ((h != _gthis.height))):
                _gthis.width = w
                _gthis.height = h
                _gthis.posChanged = True
            _gthis.viewportScaleX = level
            _gthis.viewportScaleY = level
            _gthis.viewportA = (2 / _gthis.width)
            _gthis.viewportD = (2 / _gthis.height)
            _gthis.viewportX = -1
            _gthis.viewportY = -1
        elif (tmp == 5):
            minWidth = _g.params[0]
            minHeight = _g.params[1]
            integerScaling = _g.params[2]
            a = (engine.width / minWidth)
            b = (engine.height / minHeight)
            zoom = (b if ((a > b)) else a)
            if integerScaling:
                zoom1 = None
                try:
                    zoom1 = int(zoom)
                except BaseException as _g:
                    None
                    zoom1 = None
                zoom = zoom1
                if (zoom == 0):
                    zoom = 1
            w = Math.ceil((engine.width / zoom))
            h = Math.ceil((engine.height / zoom))
            if ((w != _gthis.width) or ((h != _gthis.height))):
                _gthis.width = w
                _gthis.height = h
                _gthis.posChanged = True
            _gthis.viewportScaleX = zoom
            _gthis.viewportScaleY = zoom
            _gthis.viewportA = (2 / _gthis.width)
            _gthis.viewportD = (2 / _gthis.height)
            _gthis.viewportX = -1
            _gthis.viewportY = -1
        else:
            pass

    def screenXToViewport(self,mx):
        _this = self.interactiveCamera
        mx = self.window.get_mouseX()
        my = self.window.get_mouseY()
        return (((((((((mx - _this.scene.offsetX)) / _this.scene.viewportScaleX) - _this.absX)) * _this.matD) - (((((((my - _this.scene.offsetY)) / _this.scene.viewportScaleY) - _this.absY)) * _this.matC)))) * _this.invDet)

    def screenYToViewport(self,my):
        _this = self.interactiveCamera
        mx = self.window.get_mouseX()
        my = self.window.get_mouseY()
        return ((((-(((((mx - _this.scene.offsetX)) / _this.scene.viewportScaleX) - _this.absX)) * _this.matB) + (((((((my - _this.scene.offsetY)) / _this.scene.viewportScaleY) - _this.absY)) * _this.matA)))) * _this.invDet)

    def get_mouseX(self):
        self.syncPos()
        mx = self.window.get_mouseX()
        _this = self.interactiveCamera
        mx = self.window.get_mouseX()
        my = self.window.get_mouseY()
        dx = ((((((((((mx - _this.scene.offsetX)) / _this.scene.viewportScaleX) - _this.absX)) * _this.matD) - (((((((my - _this.scene.offsetY)) / _this.scene.viewportScaleY) - _this.absY)) * _this.matC)))) * _this.invDet) - self.absX)
        if (self.matC == 0):
            return (dx / self.matA)
        my = self.window.get_mouseY()
        _this = self.interactiveCamera
        mx = self.window.get_mouseX()
        my = self.window.get_mouseY()
        dy = (((((-(((((mx - _this.scene.offsetX)) / _this.scene.viewportScaleX) - _this.absX)) * _this.matB) + (((((((my - _this.scene.offsetY)) / _this.scene.viewportScaleY) - _this.absY)) * _this.matA)))) * _this.invDet) - self.absY)
        return ((((dx * self.matD) - ((dy * self.matC)))) / (((self.matA * self.matD) - ((self.matB * self.matC)))))

    def get_mouseY(self):
        self.syncPos()
        my = self.window.get_mouseY()
        _this = self.interactiveCamera
        mx = self.window.get_mouseX()
        my = self.window.get_mouseY()
        dy = (((((-(((((mx - _this.scene.offsetX)) / _this.scene.viewportScaleX) - _this.absX)) * _this.matB) + (((((((my - _this.scene.offsetY)) / _this.scene.viewportScaleY) - _this.absY)) * _this.matA)))) * _this.invDet) - self.absY)
        if (self.matB == 0):
            return (dy / self.matD)
        mx = self.window.get_mouseX()
        _this = self.interactiveCamera
        mx = self.window.get_mouseX()
        my = self.window.get_mouseY()
        dx = ((((((((((mx - _this.scene.offsetX)) / _this.scene.viewportScaleX) - _this.absX)) * _this.matD) - (((((((my - _this.scene.offsetY)) / _this.scene.viewportScaleY) - _this.absY)) * _this.matC)))) * _this.invDet) - self.absX)
        return ((((dy * self.matA) - ((dx * self.matB)))) / (((self.matA * self.matD) - ((self.matB * self.matC)))))

    def dispatchListeners(self,event):
        self.screenToViewport(event)
        _g = 0
        _g1 = self.eventListeners
        while (_g < len(_g1)):
            l = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            l(event)
            if (not event.propagate):
                break

    def isInteractiveVisible(self,i):
        s = i
        while (s != self):
            if ((s is None) or (not s.visible)):
                return False
            s = s.parent
        return True

    def getInteractive(self,x,y):
        pt = self.shapePoint
        _g = 0
        _g1 = self.interactive
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if i.posChanged:
                i.syncPos()
            dx = (x - i.absX)
            dy = (y - i.absY)
            rx = ((((dx * i.matD) - ((dy * i.matC)))) * i.invDet)
            ry = ((((dy * i.matA) - ((dx * i.matB)))) * i.invDet)
            if (i.shape is not None):
                x1 = (rx + i.shapeX)
                y1 = (ry + i.shapeY)
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                pt.x = x1
                pt.y = y1
                if (not i.shape.contains(pt)):
                    continue
            elif ((((ry < 0) or ((rx < 0))) or ((rx >= i.width))) or ((ry >= i.height))):
                continue
            visible = True
            p = i
            while (p is not None):
                if (not p.visible):
                    visible = False
                    break
                p = p.parent
            if (not visible):
                continue
            return i
        return None

    def screenToViewport(self,e):
        self.interactiveCamera.eventToCamera(e)

    def dispatchEvent(self,event,to):
        i = to
        self.screenToViewport(event)
        dx = (event.relX - i.absX)
        dy = (event.relY - i.absY)
        rx = ((((dx * i.matD) - ((dy * i.matC)))) * i.invDet)
        ry = ((((dy * i.matA) - ((dx * i.matB)))) * i.invDet)
        event.relX = rx
        event.relY = ry
        i.handleEvent(event)

    def handleEvent(self,event,last):
        self.screenToViewport(event)
        ex = event.relX
        ey = event.relY
        index = (0 if ((last is None)) else (python_internal_ArrayImpl.indexOf(self.interactive,last,None) + 1))
        pt = self.shapePoint
        _g = index
        _g1 = len(self.interactive)
        while (_g < _g1):
            idx = _g
            _g = (_g + 1)
            i = (self.interactive[idx] if idx >= 0 and idx < len(self.interactive) else None)
            if (i is None):
                break
            if (i.invDet == 0):
                continue
            dx = (ex - i.absX)
            dy = (ey - i.absY)
            rx = ((((dx * i.matD) - ((dy * i.matC)))) * i.invDet)
            ry = ((((dy * i.matA) - ((dx * i.matB)))) * i.invDet)
            if (i.shape is not None):
                x = (rx + i.shapeX)
                y = (ry + i.shapeY)
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                pt.x = x
                pt.y = y
                if (not i.shape.contains(pt)):
                    continue
            elif ((((ry < 0) or ((rx < 0))) or ((rx >= i.width))) or ((ry >= i.height))):
                continue
            visible = True
            p = i
            while (p is not None):
                if (not p.visible):
                    visible = False
                    break
                p = p.parent
            if (not visible):
                continue
            event.relX = rx
            event.relY = ry
            i.handleEvent(event)
            if event.cancel:
                event.cancel = False
                event.propagate = False
                continue
            return i
        return None

    def addEventListener(self,f):
        _this = self.eventListeners
        _this.append(f)

    def removeEventListener(self,f):
        _g = 0
        _g1 = self.eventListeners
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if Reflect.compareMethods(e,f):
                python_internal_ArrayImpl.remove(self.eventListeners,e)
                return True
        return False

    def startCapture(self,onEvent,onCancel = None,touchId = None):
        _gthis = self
        def _hx_local_0(e):
            _gthis.screenToViewport(e)
            onEvent(e)
        self.events.startCapture(_hx_local_0,onCancel,touchId)

    def stopCapture(self):
        self.events.stopCapture()

    def startDrag(self,onEvent,onCancel = None,refEvent = None):
        self.startCapture(onEvent,onCancel,(refEvent.touchId if ((refEvent is not None)) else None))

    def stopDrag(self):
        self.stopCapture()

    def getFocus(self):
        if (self.events is None):
            return None
        f = self.events.getFocus()
        if (f is None):
            return None
        i = Std.downcast(f,h2d_Interactive)
        if (i is None):
            return None
        return python_internal_ArrayImpl._get(self.interactive, python_internal_ArrayImpl.indexOf(self.interactive,i,None))

    def addEventTarget(self,i):
        i1 = i
        lv = 0
        while (i1 is not None):
            i1 = i1.parent
            lv = (lv + 1)
        level = lv
        _g = 0
        _g1 = len(self.interactive)
        while (_g < _g1):
            index = _g
            _g = (_g + 1)
            i1 = i
            i2 = (self.interactive[index] if index >= 0 and index < len(self.interactive) else None)
            lv1 = level
            i3 = i2
            lv = 0
            while (i3 is not None):
                i3 = i3.parent
                lv = (lv + 1)
            lv2 = lv
            p1 = i1
            p2 = i2
            while (lv1 > lv2):
                i1 = p1
                p1 = p1.parent
                lv1 = (lv1 - 1)
            while (lv2 > lv1):
                i2 = p2
                p2 = p2.parent
                lv2 = (lv2 - 1)
            while (p1 != p2):
                i1 = p1
                p1 = p1.parent
                i2 = p2
                p2 = p2.parent
            id = -1
            _g2 = 0
            _g3 = len(p1.children)
            while (_g2 < _g3):
                k = _g2
                _g2 = (_g2 + 1)
                if ((p1.children[k] if k >= 0 and k < len(p1.children) else None) == i1):
                    id = k
                    break
            tmp = id
            id1 = -1
            _g4 = 0
            _g5 = len(p2.children)
            while (_g4 < _g5):
                k1 = _g4
                _g4 = (_g4 + 1)
                if ((p2.children[k1] if k1 >= 0 and k1 < len(p2.children) else None) == i2):
                    id1 = k1
                    break
            if (tmp > id1):
                self.interactive.insert(index, i)
                return
        _this = self.interactive
        _this.append(i)

    def removeEventTarget(self,i,notify = None):
        if (notify is None):
            notify = False
        python_internal_ArrayImpl.remove(self.interactive,i)
        if (notify and ((self.events is not None))):
            self.events.onRemove(i)

    def dispose(self):
        if self.allocated:
            self.onRemove()
        self.ctx.dispose()

    def setElapsedTime(self,v):
        self.ctx.elapsedTime = v

    def drawImplTo(self,s,texs,outputs = None):
        _g = 0
        while (_g < len(texs)):
            t = (texs[_g] if _g >= 0 and _g < len(texs) else None)
            _g = (_g + 1)
            if (((t.flags & ((1 << h3d_mat_TextureFlags.Target.index)))) == 0):
                raise haxe_Exception.thrown("Can only draw to texture created with Target flag")
        self.ctx.engine = h3d_Engine.CURRENT
        oldBG = self.ctx.engine.backgroundColor
        self.ctx.engine.backgroundColor = None
        if (not self.ctx.engine.inRender):
            self.ctx.begin()
        self.ctx.globalAlpha = self.alpha
        self.ctx.begin()
        self.ctx.pushTargets(texs)
        if (outputs is not None):
            self.ctx.manager.setOutput(outputs)
        s.drawRec(self.ctx)
        if (outputs is not None):
            self.ctx.manager.setOutput()
        self.ctx.popTarget()
        self.ctx.engine.backgroundColor = oldBG

    def syncOnly(self,et):
        engine = h3d_Engine.CURRENT
        self.setElapsedTime(et)
        self.ctx.engine = engine
        _hx_local_0 = self.ctx
        _hx_local_1 = _hx_local_0.frame
        _hx_local_0.frame = (_hx_local_1 + 1)
        _hx_local_1
        _hx_local_2 = self.ctx
        _hx_local_3 = _hx_local_2.time
        _hx_local_2.time = (_hx_local_3 + self.ctx.elapsedTime)
        _hx_local_2.time
        self.ctx.globalAlpha = self.alpha
        self.sync(self.ctx)

    def render(self,engine):
        self.ctx.engine = engine
        _hx_local_0 = self.ctx
        _hx_local_1 = _hx_local_0.frame
        _hx_local_0.frame = (_hx_local_1 + 1)
        _hx_local_1
        _hx_local_2 = self.ctx
        _hx_local_3 = _hx_local_2.time
        _hx_local_2.time = (_hx_local_3 + self.ctx.elapsedTime)
        _hx_local_2.time
        self.ctx.globalAlpha = self.alpha
        self.sync(self.ctx)
        if (len(self.children) == 0):
            return
        self.ctx.begin()
        self.ctx.drawScene()
        self.ctx.end()

    def sync(self,ctx):
        forceCamSync = self.posChanged
        if (not self.allocated):
            self.onAdd()
        super().sync(ctx)
        _g = 0
        _g1 = self._cameras
        while (_g < len(_g1)):
            cam = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            cam.sync(ctx,forceCamSync)

    def clipBounds(self,ctx,bounds):
        _gthis = self
        if (self.rotation == 0):
            x = -self.absX
            y = -self.absY
            if (x < bounds.xMin):
                bounds.xMin = x
            if (x > bounds.xMax):
                bounds.xMax = x
            if (y < bounds.yMin):
                bounds.yMin = y
            if (y > bounds.yMax):
                bounds.yMax = y
            x = ((self.window.get_width() / self.matA) - self.absX)
            y = ((self.window.get_height() / self.matD) - self.absY)
            if (x < bounds.xMin):
                bounds.xMin = x
            if (x > bounds.xMax):
                bounds.xMax = x
            if (y < bounds.yMin):
                bounds.yMin = y
            if (y > bounds.yMax):
                bounds.yMax = y
        else:
            ww = ((self.window.get_width() / self.matA) - self.absX)
            wh = ((self.window.get_height() / self.matD) - self.absY)
            x = -self.absX
            y = -self.absY
            x1 = ((x * _gthis.matA) + ((y * _gthis.matC)))
            y1 = ((x * _gthis.matB) + ((y * _gthis.matD)))
            if (x1 < bounds.xMin):
                bounds.xMin = x1
            if (x1 > bounds.xMax):
                bounds.xMax = x1
            if (y1 < bounds.yMin):
                bounds.yMin = y1
            if (y1 > bounds.yMax):
                bounds.yMax = y1
            x = (ww - self.absX)
            y = -self.absY
            x1 = ((x * _gthis.matA) + ((y * _gthis.matC)))
            y1 = ((x * _gthis.matB) + ((y * _gthis.matD)))
            if (x1 < bounds.xMin):
                bounds.xMin = x1
            if (x1 > bounds.xMax):
                bounds.xMax = x1
            if (y1 < bounds.yMin):
                bounds.yMin = y1
            if (y1 > bounds.yMax):
                bounds.yMax = y1
            x = -self.absX
            y = (wh - self.absY)
            x1 = ((x * _gthis.matA) + ((y * _gthis.matC)))
            y1 = ((x * _gthis.matB) + ((y * _gthis.matD)))
            if (x1 < bounds.xMin):
                bounds.xMin = x1
            if (x1 > bounds.xMax):
                bounds.xMax = x1
            if (y1 < bounds.yMin):
                bounds.yMin = y1
            if (y1 > bounds.yMax):
                bounds.yMax = y1
            x = (ww - self.absX)
            y = (wh - self.absY)
            x1 = ((x * _gthis.matA) + ((y * _gthis.matC)))
            y1 = ((x * _gthis.matB) + ((y * _gthis.matD)))
            if (x1 < bounds.xMin):
                bounds.xMin = x1
            if (x1 > bounds.xMax):
                bounds.xMax = x1
            if (y1 < bounds.yMin):
                bounds.yMin = y1
            if (y1 > bounds.yMax):
                bounds.yMax = y1
        super().clipBounds(ctx,bounds)

    def drawContent(self,ctx):
        if ctx.front2back:
            _g = 0
            _g1 = self._cameras
            while (_g < len(_g1)):
                cam = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (not cam.visible):
                    continue
                i = len(self.children)
                l = self.layerCount
                cam.enter(ctx)
                while True:
                    tmp = l
                    l = (l - 1)
                    if (not ((tmp > 0))):
                        break
                    top = (0 if ((l == 0)) else python_internal_ArrayImpl._get(self.layersIndexes, (l - 1)))
                    if cam.layerVisible(l):
                        while (i >= top):
                            tmp1 = i
                            i = (i - 1)
                            (self.children[tmp1] if tmp1 >= 0 and tmp1 < len(self.children) else None).drawRec(ctx)
                    else:
                        i = (top - 1)
                cam.exit(ctx)
            self.draw(ctx)
        else:
            self.draw(ctx)
            _g = 0
            _g1 = self._cameras
            while (_g < len(_g1)):
                cam = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (not cam.visible):
                    continue
                i = 0
                l = 0
                cam.enter(ctx)
                while (l < self.layerCount):
                    top = l
                    l = (l + 1)
                    top1 = (self.layersIndexes[top] if top >= 0 and top < len(self.layersIndexes) else None)
                    if cam.layerVisible((l - 1)):
                        while (i < top1):
                            tmp = i
                            i = (i + 1)
                            (self.children[tmp] if tmp >= 0 and tmp < len(self.children) else None).drawRec(ctx)
                    else:
                        i = top1
                cam.exit(ctx)

    def onAdd(self):
        self.checkResize()
        super().onAdd()
        self.window.addResizeEvent(self.checkResize)

    def onRemove(self):
        super().onRemove()
        self.window.removeResizeEvent(self.checkResize)

    def captureBitmap(self,target = None):
        engine = h3d_Engine.CURRENT
        if (target is None):
            tex = h3d_mat_Texture(self.width,self.height,[h3d_mat_TextureFlags.Target])
            target = h2d_Tile(tex,0,0,self.width,self.height)
        engine.begin()
        x = target.x
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        x = target.y
        tmp1 = None
        try:
            tmp1 = int(x)
        except BaseException as _g:
            None
            tmp1 = None
        engine.setRenderZone(tmp,tmp1,Math.ceil(target.width),Math.ceil(target.height))
        tex = target.innerTex
        engine.pushTarget(tex)
        ow = self.width
        oh = self.height
        ova = self.viewportA
        ovd = self.viewportD
        ovx = self.viewportX
        ovy = self.viewportY
        self.width = tex.width
        self.height = tex.height
        self.viewportA = (2 / self.width)
        self.viewportD = (2 / self.height)
        self.viewportX = -1
        self.viewportY = -1
        self.posChanged = True
        self.render(engine)
        engine.popTarget()
        self.width = ow
        self.height = oh
        self.viewportA = ova
        self.viewportD = ovd
        self.viewportX = ovx
        self.viewportY = ovy
        self.posChanged = True
        engine.setRenderZone()
        engine.end()
        return h2d_Bitmap(target)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.viewportA = None
        _hx_o.viewportD = None
        _hx_o.viewportX = None
        _hx_o.viewportY = None
        _hx_o.offsetX = None
        _hx_o.offsetY = None
        _hx_o.viewportScaleX = None
        _hx_o.viewportScaleY = None
        _hx_o.scaleMode = None
        _hx_o._cameras = None
        _hx_o.interactiveCamera = None
        _hx_o.interactive = None
        _hx_o.eventListeners = None
        _hx_o.ctx = None
        _hx_o.window = None
        _hx_o.events = None
        _hx_o.shapePoint = None
h2d_Scene._hx_class = h2d_Scene
_hx_classes["h2d.Scene"] = h2d_Scene

class h2d_Align(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.Align"
    _hx_constructs = ["Left", "Right", "Center", "MultilineRight", "MultilineCenter"]
h2d_Align.Left = h2d_Align("Left", 0, ())
h2d_Align.Right = h2d_Align("Right", 1, ())
h2d_Align.Center = h2d_Align("Center", 2, ())
h2d_Align.MultilineRight = h2d_Align("MultilineRight", 3, ())
h2d_Align.MultilineCenter = h2d_Align("MultilineCenter", 4, ())
h2d_Align._hx_class = h2d_Align
_hx_classes["h2d.Align"] = h2d_Align


class h2d_Text(h2d_Drawable):
    _hx_class_name = "h2d.Text"
    _hx_is_interface = "False"
    __slots__ = ("font", "text", "textColor", "maxWidth", "dropShadow", "textWidth", "textHeight", "textAlign", "letterSpacing", "lineSpacing", "glyphs", "needsRebuild", "currentText", "textChanged", "calcDone", "calcXMin", "calcYMin", "calcWidth", "calcHeight", "calcSizeHeight", "constraintWidth", "realMaxWidth", "sdfShader")
    _hx_fields = ["font", "text", "textColor", "maxWidth", "dropShadow", "textAlign", "letterSpacing", "lineSpacing", "glyphs", "needsRebuild", "currentText", "textChanged", "calcDone", "calcXMin", "calcYMin", "calcWidth", "calcHeight", "calcSizeHeight", "constraintWidth", "realMaxWidth", "sdfShader"]
    _hx_methods = ["set_font", "set_textAlign", "set_letterSpacing", "set_lineSpacing", "constraintSize", "onAdd", "checkText", "sync", "draw", "set_text", "validateText", "rebuild", "calcTextWidth", "splitText", "splitRawText", "getTextProgress", "initGlyphs", "updateSize", "get_textHeight", "get_textWidth", "set_maxWidth", "updateConstraint", "set_textColor", "getBoundsRec"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Drawable


    def __init__(self,font,parent = None):
        self.sdfShader = None
        self.calcSizeHeight = None
        self.calcHeight = None
        self.calcWidth = None
        self.calcYMin = None
        self.calcXMin = None
        self.calcDone = None
        self.textChanged = None
        self.currentText = None
        self.needsRebuild = None
        self.glyphs = None
        self.textAlign = None
        self.textHeight = None
        self.textWidth = None
        self.dropShadow = None
        self.maxWidth = None
        self.textColor = None
        self.text = None
        self.font = None
        self.realMaxWidth = -1
        self.constraintWidth = -1
        self.lineSpacing = 0
        self.letterSpacing = 0
        super().__init__(parent)
        self.set_font(font)
        self.set_textAlign(h2d_Align.Left)
        self.set_text("")
        self.currentText = ""
        self.set_textColor(16777215)

    def set_font(self,font):
        if (self.font == font):
            return font
        self.font = font
        if (font is not None):
            _g = font.type
            tmp = _g.index
            if (tmp == 0):
                if (self.sdfShader is not None):
                    self.removeShader(self.sdfShader)
                    self.sdfShader = None
            elif (tmp == 1):
                channel = _g.params[0]
                alphaCutoff = _g.params[1]
                smoothing = _g.params[2]
                if (self.sdfShader is None):
                    self.sdfShader = h3d_shader_SignedDistanceField()
                    self.addShader(self.sdfShader)
                self.sdfShader.alphaCutoff__ = alphaCutoff
                self.sdfShader.smoothing__ = smoothing
                _this = self.sdfShader
                _this.constModified = True
                _this.channel__ = channel
            else:
                pass
        if (self.glyphs is not None):
            _this = self.glyphs
            if ((_this is not None) and ((_this.parent is not None))):
                _this.parent.removeChild(_this)
        self.glyphs = h2d_TileGroup((None if ((font is None)) else font.tile),self)
        self.glyphs.set_visible(False)
        self.rebuild()
        return font

    def set_textAlign(self,a):
        if (self.textAlign == a):
            return a
        self.textAlign = a
        self.rebuild()
        return a

    def set_letterSpacing(self,s):
        if (self.letterSpacing == s):
            return s
        self.letterSpacing = s
        self.rebuild()
        return s

    def set_lineSpacing(self,s):
        if (self.lineSpacing == s):
            return s
        self.lineSpacing = s
        self.rebuild()
        return s

    def constraintSize(self,width,height):
        self.constraintWidth = width
        self.updateConstraint()

    def onAdd(self):
        super().onAdd()
        self.rebuild()

    def checkText(self):
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True

    def sync(self,ctx):
        super().sync(ctx)
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True
        if self.needsRebuild:
            self.initGlyphs(self.currentText)

    def draw(self,ctx):
        if (self.glyphs is None):
            self.emitTile(ctx,h2d_Tile.fromColor(16711935,16,16))
            return
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True
        if self.needsRebuild:
            self.initGlyphs(self.currentText)
        if (self.dropShadow is not None):
            oldX = self.absX
            oldY = self.absY
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.absX
            _hx_local_0.absX = (_hx_local_1 + (((self.dropShadow.dx * self.matA) + ((self.dropShadow.dy * self.matC)))))
            _hx_local_0.absX
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.absY
            _hx_local_2.absY = (_hx_local_3 + (((self.dropShadow.dx * self.matB) + ((self.dropShadow.dy * self.matD)))))
            _hx_local_2.absY
            oldR = self.color.x
            oldG = self.color.y
            oldB = self.color.z
            oldA = self.color.w
            _this = self.color
            c = self.dropShadow.color
            _this.x = ((((c >> 16) & 255)) / 255)
            _this.y = ((((c >> 8) & 255)) / 255)
            _this.z = (((c & 255)) / 255)
            _this.w = ((HxOverrides.rshift(c, 24)) / 255)
            self.color.w = (self.dropShadow.alpha * oldA)
            self.glyphs.drawWith(ctx,self)
            self.absX = oldX
            self.absY = oldY
            _this = self.color
            x = oldR
            y = oldG
            z = oldB
            w = oldA
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        self.glyphs.drawWith(ctx,self)

    def set_text(self,t):
        t1 = ("null" if ((t is None)) else t)
        if (t1 == self.text):
            return t1
        self.text = t1
        self.textChanged = True
        self.validateText()
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return t1

    def validateText(self):
        pass

    def rebuild(self):
        self.calcDone = False
        self.needsRebuild = True
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)

    def calcTextWidth(self,text):
        if self.calcDone:
            ow = self.calcWidth
            oh = self.calcHeight
            osh = self.calcSizeHeight
            ox = self.calcXMin
            oy = self.calcYMin
            self.initGlyphs(text,False)
            w = self.calcWidth
            self.calcWidth = ow
            self.calcHeight = oh
            self.calcSizeHeight = osh
            self.calcXMin = ox
            self.calcYMin = oy
            return w
        else:
            self.initGlyphs(text,False)
            self.calcDone = False
            return self.calcWidth

    def splitText(self,text):
        return self.splitRawText(text,0,0)

    def splitRawText(self,text,leftMargin = None,afterData = None,font = None,sizes = None,prevChar = None):
        if (leftMargin is None):
            leftMargin = 0.
        if (afterData is None):
            afterData = 0.
        if (prevChar is None):
            prevChar = -1
        maxWidth = self.realMaxWidth
        if (maxWidth < 0):
            if (sizes is None):
                return text
            else:
                maxWidth = Math.POSITIVE_INFINITY
        if (font is None):
            font = self.font
        lines = []
        restPos = 0
        x = leftMargin
        _g = 0
        _g1 = len(text)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            cc = HxString.charCodeAt(text,i)
            c = font.glyphs.h.get(cc,None)
            if (c is None):
                c = font.charset.resolveChar(cc,font.glyphs)
                if (c is None):
                    c = (font.nullChar if (((cc == 13) or ((cc == 10)))) else font.defaultChar)
            e = c
            newline = (cc == 10)
            esize = (e.width + e.getKerningOffset(prevChar))
            nc = HxString.charCodeAt(text,(i + 1))
            if (font.charset.isBreakChar(cc) and (((nc is None) or (not font.charset.isComplementChar(nc))))):
                if (((len(lines) == 0) and ((leftMargin > 0))) and ((x > maxWidth))):
                    lines.append("")
                    if (sizes is not None):
                        sizes.append(leftMargin)
                    x = (x - leftMargin)
                size = ((x + esize) + self.letterSpacing)
                k = (i + 1)
                _hx_max = len(text)
                prevChar1 = prevChar
                breakFound = False
                while ((size <= maxWidth) and ((k < _hx_max))):
                    index = k
                    k = (k + 1)
                    cc1 = HxString.charCodeAt(text,index)
                    if (font.charset.isSpace(cc1) or ((cc1 == 10))):
                        breakFound = True
                        break
                    c1 = font.glyphs.h.get(cc1,None)
                    if (c1 is None):
                        c1 = font.charset.resolveChar(cc1,font.glyphs)
                        if (c1 is None):
                            c1 = (font.nullChar if (((cc1 == 13) or ((cc1 == 10)))) else font.defaultChar)
                    e1 = c1
                    size = (size + (((e1.width + self.letterSpacing) + e1.getKerningOffset(prevChar1))))
                    prevChar1 = cc1
                    nc1 = HxString.charCodeAt(text,(k + 1))
                    if (font.charset.isBreakChar(cc1) and (((nc1 is None) or (not font.charset.isComplementChar(nc1))))):
                        break
                if ((size > maxWidth) or (((not breakFound) and (((size + afterData) > maxWidth))))):
                    newline = True
                    if font.charset.isSpace(cc):
                        x1 = HxString.substr(text,restPos,(i - restPos))
                        lines.append(x1)
                        e = None
                    else:
                        x2 = HxString.substr(text,restPos,((i + 1) - restPos))
                        lines.append(x2)
                    restPos = (i + 1)
            if ((e is not None) and ((cc != 10))):
                x = (x + ((esize + self.letterSpacing)))
            if newline:
                if (sizes is not None):
                    sizes.append(x)
                x = 0
                prevChar = -1
            else:
                prevChar = cc
        if (restPos < len(text)):
            if (((len(lines) == 0) and ((leftMargin > 0))) and ((((x + afterData) - self.letterSpacing) > maxWidth))):
                lines.append("")
                if (sizes is not None):
                    sizes.append(leftMargin)
                x = (x - leftMargin)
            x1 = HxString.substr(text,restPos,(len(text) - restPos))
            lines.append(x1)
            if (sizes is not None):
                sizes.append(x)
        return "\n".join([python_Boot.toString1(x1,'') for x1 in lines])

    def getTextProgress(self,text,progress):
        if (progress >= len(text)):
            return text
        _hx_len = None
        try:
            _hx_len = int(progress)
        except BaseException as _g:
            None
            _hx_len = None
        return HxString.substr(text,0,_hx_len)

    def initGlyphs(self,text,rebuild = None):
        if (rebuild is None):
            rebuild = True
        if rebuild:
            self.glyphs.clear()
        x = 0.
        y = 0.
        xMax = 0.
        xMin = 0.
        yMin = 0.
        prevChar = -1
        linei = 0
        align = self.textAlign
        lines = list()
        dl = (self.font.lineHeight + self.lineSpacing)
        t = self.splitRawText(text,0,0,None,lines)
        _g = 0
        while (_g < len(lines)):
            lw = (lines[_g] if _g >= 0 and _g < len(lines) else None)
            _g = (_g + 1)
            if (lw > x):
                x = lw
        self.calcWidth = x
        tmp = align.index
        if (tmp == 0):
            x = 0
        elif ((((tmp == 4) or ((tmp == 3))) or ((tmp == 2))) or ((tmp == 1))):
            _hx_max = (Math.ceil(self.calcWidth) if (((align == h2d_Align.MultilineCenter) or ((align == h2d_Align.MultilineRight)))) else (0 if ((self.realMaxWidth < 0)) else Math.ceil(self.realMaxWidth)))
            k = (0.5 if (((align == h2d_Align.Center) or ((align == h2d_Align.MultilineCenter)))) else 1)
            _g = 0
            _g1 = len(lines)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                v = (((_hx_max - (lines[i] if i >= 0 and i < len(lines) else None))) * k)
                python_internal_ArrayImpl._set(lines, i, (v if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v)) else Math.floor(v))))
            x = (lines[0] if 0 < len(lines) else None)
            xMin = x
        else:
            pass
        _g = 0
        _g1 = len(t)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            cc = HxString.charCodeAt(t,i)
            _this = self.font
            c = _this.glyphs.h.get(cc,None)
            if (c is None):
                c = _this.charset.resolveChar(cc,_this.glyphs)
                if (c is None):
                    c = (_this.nullChar if (((cc == 13) or ((cc == 10)))) else _this.defaultChar)
            e = c
            offs = e.getKerningOffset(prevChar)
            esize = (e.width + offs)
            if (cc == 10):
                if (x > xMax):
                    xMax = x
                tmp = align.index
                if (tmp == 0):
                    x = 0
                elif ((((tmp == 4) or ((tmp == 3))) or ((tmp == 2))) or ((tmp == 1))):
                    linei = (linei + 1)
                    x1 = linei
                    x = (lines[x1] if x1 >= 0 and x1 < len(lines) else None)
                    if (x < xMin):
                        xMin = x
                else:
                    pass
                y = (y + dl)
                prevChar = -1
            else:
                if (e is not None):
                    if rebuild:
                        _this1 = self.glyphs
                        _this1.content.add((x + offs),y,_this1.curColor.x,_this1.curColor.y,_this1.curColor.z,_this1.curColor.w,e.t)
                    if ((y == 0) and ((e.t.dy < yMin))):
                        yMin = e.t.dy
                    x = (x + ((esize + self.letterSpacing)))
                prevChar = cc
        if (x > xMax):
            xMax = x
        self.calcXMin = xMin
        self.calcYMin = yMin
        self.calcWidth = (xMax - xMin)
        self.calcHeight = (y + self.font.lineHeight)
        self.calcSizeHeight = (y + ((self.font.baseLine if ((self.font.baseLine > 0)) else self.font.lineHeight)))
        self.calcDone = True
        if rebuild:
            self.needsRebuild = False

    def updateSize(self):
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True
        if (not self.calcDone):
            self.initGlyphs(self.text,self.needsRebuild)

    def get_textHeight(self):
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True
        if (not self.calcDone):
            self.initGlyphs(self.text,self.needsRebuild)
        return self.calcHeight

    def get_textWidth(self):
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True
        if (not self.calcDone):
            self.initGlyphs(self.text,self.needsRebuild)
        return self.calcWidth

    def set_maxWidth(self,w):
        if (self.maxWidth == w):
            return w
        self.maxWidth = w
        self.updateConstraint()
        return w

    def updateConstraint(self):
        old = self.realMaxWidth
        if (self.maxWidth is None):
            self.realMaxWidth = self.constraintWidth
        elif (self.constraintWidth < 0):
            self.realMaxWidth = self.maxWidth
        else:
            a = self.maxWidth
            b = self.constraintWidth
            self.realMaxWidth = (b if ((a > b)) else a)
        if (self.realMaxWidth != old):
            self.rebuild()

    def set_textColor(self,c):
        if (self.textColor == c):
            return c
        self.textColor = c
        a = self.color.w
        _this = self.color
        _this.x = ((((c >> 16) & 255)) / 255)
        _this.y = ((((c >> 8) & 255)) / 255)
        _this.z = (((c & 255)) / 255)
        _this.w = ((HxOverrides.rshift(c, 24)) / 255)
        self.color.w = a
        return c

    def getBoundsRec(self,relativeTo,out,forSize):
        super().getBoundsRec(relativeTo,out,forSize)
        if (self.textChanged and ((self.text != self.currentText))):
            self.textChanged = False
            self.currentText = self.text
            self.calcDone = False
            self.needsRebuild = True
        if (not self.calcDone):
            self.initGlyphs(self.text,self.needsRebuild)
        x = None
        y = None
        w = None
        h = None
        if forSize:
            x = self.calcXMin
            y = 0.
            w = self.calcWidth
            h = self.calcSizeHeight
        else:
            x = self.calcXMin
            y = self.calcYMin
            w = self.calcWidth
            h = (self.calcHeight - self.calcYMin)
        self.addBounds(relativeTo,out,x,y,w,h)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.font = None
        _hx_o.text = None
        _hx_o.textColor = None
        _hx_o.maxWidth = None
        _hx_o.dropShadow = None
        _hx_o.textAlign = None
        _hx_o.letterSpacing = None
        _hx_o.lineSpacing = None
        _hx_o.glyphs = None
        _hx_o.needsRebuild = None
        _hx_o.currentText = None
        _hx_o.textChanged = None
        _hx_o.calcDone = None
        _hx_o.calcXMin = None
        _hx_o.calcYMin = None
        _hx_o.calcWidth = None
        _hx_o.calcHeight = None
        _hx_o.calcSizeHeight = None
        _hx_o.constraintWidth = None
        _hx_o.realMaxWidth = None
        _hx_o.sdfShader = None
h2d_Text._hx_class = h2d_Text
_hx_classes["h2d.Text"] = h2d_Text


class h2d_Tile:
    _hx_class_name = "h2d.Tile"
    _hx_is_interface = "False"
    __slots__ = ("innerTex", "u", "v", "u2", "v2", "dx", "dy", "x", "y", "width", "height")
    _hx_fields = ["innerTex", "u", "v", "u2", "v2", "dx", "dy", "x", "y", "width", "height"]
    _hx_methods = ["get_ix", "get_iy", "get_iwidth", "get_iheight", "getTexture", "isDisposed", "setTexture", "switchTexture", "sub", "center", "setCenterRatio", "flipX", "flipY", "setPosition", "setSize", "scaleToSize", "scrollDiscrete", "dispose", "clone", "get_xFlip", "get_yFlip", "set_xFlip", "set_yFlip", "split", "gridFlatten", "grid", "toString", "upload"]
    _hx_statics = ["fromColor", "fromBitmap", "autoCut", "fromTexture", "fromPixels", "isEmpty"]

    def __init__(self,tex,x,y,w,h,dx = None,dy = None):
        if (dx is None):
            dx = 0
        if (dy is None):
            dy = 0
        self.v2 = None
        self.u2 = None
        self.v = None
        self.u = None
        self.innerTex = tex
        self.x = x
        self.y = y
        self.width = w
        self.height = h
        self.dx = dx
        self.dy = dy
        if (tex is not None):
            self.setTexture(tex)

    def get_ix(self):
        return Math.floor(self.x)

    def get_iy(self):
        return Math.floor(self.y)

    def get_iwidth(self):
        return (Math.ceil((self.width + self.x)) - Math.floor(self.x))

    def get_iheight(self):
        return (Math.ceil((self.height + self.y)) - Math.floor(self.y))

    def getTexture(self):
        return self.innerTex

    def isDisposed(self):
        if (self.innerTex is not None):
            _this = self.innerTex
            if (_this.t is None):
                return (_this.realloc is None)
            else:
                return False
        else:
            return True

    def setTexture(self,tex):
        self.innerTex = tex
        if (tex is not None):
            self.u = (self.x / tex.width)
            self.v = (self.y / tex.height)
            self.u2 = (((self.x + self.width)) / tex.width)
            self.v2 = (((self.y + self.height)) / tex.height)

    def switchTexture(self,t):
        self.setTexture(t.innerTex)

    def sub(self,x,y,w,h,dx = None,dy = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        return h2d_Tile(self.innerTex,(self.x + x),(self.y + y),w,h,dx,dy)

    def center(self):
        return self.sub(0,0,self.width,self.height,-((self.width * .5)),-((self.height * .5)))

    def setCenterRatio(self,px = None,py = None):
        if (px is None):
            px = 0.5
        if (py is None):
            py = 0.5
        self.dx = -((px * self.width))
        self.dy = -((py * self.height))

    def flipX(self):
        tmp = self.u
        self.u = self.u2
        self.u2 = tmp
        self.dx = (-self.dx - self.width)

    def flipY(self):
        tmp = self.v
        self.v = self.v2
        self.v2 = tmp
        self.dy = (-self.dy - self.height)

    def setPosition(self,x,y):
        self.x = x
        self.y = y
        tex = self.innerTex
        if (tex is not None):
            self.u = (x / tex.width)
            self.v = (y / tex.height)
            self.u2 = (((x + self.width)) / tex.width)
            self.v2 = (((y + self.height)) / tex.height)

    def setSize(self,w,h):
        self.width = w
        self.height = h
        tex = self.innerTex
        if (tex is not None):
            self.u2 = (((self.x + w)) / tex.width)
            self.v2 = (((self.y + h)) / tex.height)

    def scaleToSize(self,w,h):
        self.width = w
        self.height = h

    def scrollDiscrete(self,dx,dy):
        tex = self.innerTex
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.u
        _hx_local_0.u = (_hx_local_1 + ((dx / tex.width)))
        _hx_local_0.u
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.v
        _hx_local_2.v = (_hx_local_3 - ((dy / tex.height)))
        _hx_local_2.v
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.u2
        _hx_local_4.u2 = (_hx_local_5 + ((dx / tex.width)))
        _hx_local_4.u2
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.v2
        _hx_local_6.v2 = (_hx_local_7 - ((dy / tex.height)))
        _hx_local_6.v2
        self.x = (self.u * tex.width)
        self.y = (self.v * tex.height)

    def dispose(self):
        if (self.innerTex is not None):
            self.innerTex.dispose()
        self.innerTex = None

    def clone(self):
        t = h2d_Tile(None,self.x,self.y,self.width,self.height,self.dx,self.dy)
        t.innerTex = self.innerTex
        t.u = self.u
        t.u2 = self.u2
        t.v = self.v
        t.v2 = self.v2
        return t

    def get_xFlip(self):
        return (self.u2 < self.u)

    def get_yFlip(self):
        return (self.v2 < self.v)

    def set_xFlip(self,v):
        if (v != self.get_xFlip()):
            self.flipX()
        return v

    def set_yFlip(self,v):
        if (v != self.get_yFlip()):
            self.flipY()
        return v

    def split(self,frames = None,vertical = None,subpixel = None):
        if (frames is None):
            frames = 0
        if (vertical is None):
            vertical = False
        if (subpixel is None):
            subpixel = False
        tl = []
        if vertical:
            if (frames == 0):
                x = (self.height / self.width)
                try:
                    frames = int(x)
                except BaseException as _g:
                    None
                    frames = None
            stride = None
            if subpixel:
                stride = (self.height / frames)
            else:
                x = (self.height / frames)
                try:
                    stride = int(x)
                except BaseException as _g:
                    None
                    stride = None
            _g = 0
            _g1 = frames
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                x = self.sub(0,(i * stride),self.width,stride)
                tl.append(x)
        else:
            if (frames == 0):
                x = (self.width / self.height)
                try:
                    frames = int(x)
                except BaseException as _g:
                    None
                    frames = None
            stride = None
            if subpixel:
                stride = (self.width / frames)
            else:
                x = (self.width / frames)
                try:
                    stride = int(x)
                except BaseException as _g:
                    None
                    stride = None
            _g = 0
            _g1 = frames
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                x = self.sub((i * stride),0,stride,self.height)
                tl.append(x)
        return tl

    def gridFlatten(self,size,dx = None,dy = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        _g = []
        _g1 = 0
        x = (self.height / size)
        _g2 = None
        try:
            _g2 = int(x)
        except BaseException as _g3:
            None
            _g2 = None
        while (_g1 < _g2):
            y = _g1
            _g1 = (_g1 + 1)
            _g3 = 0
            x = (self.width / size)
            _g4 = None
            try:
                _g4 = int(x)
            except BaseException as _g5:
                None
                _g4 = None
            while (_g3 < _g4):
                x1 = _g3
                _g3 = (_g3 + 1)
                x2 = self.sub((x1 * size),(y * size),size,size,dx,dy)
                _g.append(x2)
        return _g

    def grid(self,size,dx = None,dy = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        _g = []
        _g1 = 0
        x = (self.width / size)
        _g2 = None
        try:
            _g2 = int(x)
        except BaseException as _g3:
            None
            _g2 = None
        while (_g1 < _g2):
            x = _g1
            _g1 = (_g1 + 1)
            _g3 = []
            _g4 = 0
            x1 = (self.height / size)
            _g5 = None
            try:
                _g5 = int(x1)
            except BaseException as _g6:
                None
                _g5 = None
            while (_g4 < _g5):
                y = _g4
                _g4 = (_g4 + 1)
                x2 = self.sub((x * size),(y * size),size,size,dx,dy)
                _g3.append(x2)
            _g.append(_g3)
        return _g

    def toString(self):
        return ((((((((("Tile(" + Std.string(self.x)) + ",") + Std.string(self.y)) + ",") + Std.string(self.width)) + "x") + Std.string(self.height)) + HxOverrides.stringOrNull(((((("," + Std.string(self.dx)) + ":") + Std.string(self.dy)) if (((self.dx != 0) or ((self.dy != 0)))) else "")))) + ")")

    def upload(self,bmp):
        w = self.innerTex.width
        h = self.innerTex.height
        self.innerTex.uploadBitmap(bmp)

    @staticmethod
    def fromColor(color,width = None,height = None,alpha = None):
        if (width is None):
            width = 1
        if (height is None):
            height = 1
        if (alpha is None):
            alpha = 1.
        t = h2d_Tile(h3d_mat_Texture.fromColor(color,alpha),0,0,1,1)
        t.width = width
        t.height = height
        return t

    @staticmethod
    def fromBitmap(bmp):
        tex = h3d_mat_Texture.fromBitmap(bmp)
        return h2d_Tile(tex,0,0,bmp.data.width,bmp.data.height)

    @staticmethod
    def autoCut(bmp,width,height = None):
        if (height is None):
            height = width
        colorBG = bmp.getPixel((bmp.data.width - 1),(bmp.data.height - 1))
        tl = list()
        w = 1
        h = 1
        while (w < bmp.data.width):
            w = (w << 1)
        while (h < bmp.data.height):
            h = (h << 1)
        tex = h3d_mat_Texture(w,h)
        _g = 0
        x = (bmp.data.height / height)
        _g1 = None
        try:
            _g1 = int(x)
        except BaseException as _g2:
            None
            _g1 = None
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            a = []
            python_internal_ArrayImpl._set(tl, y, a)
            _g2 = 0
            x = (bmp.data.width / width)
            _g3 = None
            try:
                _g3 = int(x)
            except BaseException as _g4:
                None
                _g3 = None
            while (_g2 < _g3):
                x1 = _g2
                _g2 = (_g2 + 1)
                sz = h2d_Tile.isEmpty(bmp,(x1 * width),(y * height),width,height,colorBG)
                if (sz is None):
                    break
                x2 = h2d_Tile(tex,((x1 * width) + sz.dx),((y * height) + sz.dy),sz.w,sz.h,sz.dx,sz.dy)
                a.append(x2)
        main = h2d_Tile(tex,0,0,bmp.data.width,bmp.data.height)
        main.upload(bmp)
        return _hx_AnonObject({'main': main, 'tiles': tl})

    @staticmethod
    def fromTexture(t):
        return h2d_Tile(t,0,0,t.width,t.height)

    @staticmethod
    def fromPixels(pixels):
        pix2 = pixels.makeSquare(True)
        t = h3d_mat_Texture.fromPixels(pix2)
        if (pix2 != pixels):
            pix2.dispose()
        return h2d_Tile(t,0,0,pixels.width,pixels.height)

    @staticmethod
    def isEmpty(b,px,py,width,height,bg):
        empty = True
        xmin = width
        ymin = height
        xmax = 0
        ymax = 0
        _g = 0
        _g1 = width
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = height
            while (_g2 < _g3):
                y = _g2
                _g2 = (_g2 + 1)
                color = b.getPixel((x + px),(y + py))
                if (((color & -16777216)) == 0):
                    if (color != 0):
                        b.setPixel((x + px),(y + py),0)
                    continue
                if (color != bg):
                    empty = False
                    if (x < xmin):
                        xmin = x
                    if (y < ymin):
                        ymin = y
                    if (x > xmax):
                        xmax = x
                    if (y > ymax):
                        ymax = y
                if ((color == bg) and ((color != 0))):
                    b.setPixel((x + px),(y + py),0)
        if empty:
            return None
        else:
            return _hx_AnonObject({'dx': xmin, 'dy': ymin, 'w': ((xmax - xmin) + 1), 'h': ((ymax - ymin) + 1)})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.innerTex = None
        _hx_o.u = None
        _hx_o.v = None
        _hx_o.u2 = None
        _hx_o.v2 = None
        _hx_o.dx = None
        _hx_o.dy = None
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.width = None
        _hx_o.height = None
h2d_Tile._hx_class = h2d_Tile
_hx_classes["h2d.Tile"] = h2d_Tile


class hxd_impl__Serializable_NoSerializeSupport:
    _hx_class_name = "hxd.impl._Serializable.NoSerializeSupport"
    _hx_is_interface = "True"
    __slots__ = ()
hxd_impl__Serializable_NoSerializeSupport._hx_class = hxd_impl__Serializable_NoSerializeSupport
_hx_classes["hxd.impl._Serializable.NoSerializeSupport"] = hxd_impl__Serializable_NoSerializeSupport


class h3d_prim_Primitive:
    _hx_class_name = "h3d.prim.Primitive"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "indexes", "refCount")
    _hx_fields = ["buffer", "indexes", "refCount"]
    _hx_methods = ["triCount", "vertexCount", "getCollider", "getBounds", "incref", "decref", "alloc", "selectMaterial", "buildNormalsDisplay", "render", "dispose", "toString"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self):
        self.indexes = None
        self.buffer = None
        self.refCount = 0

    def triCount(self):
        if (self.indexes is not None):
            x = (self.indexes.count / 3)
            try:
                return int(x)
            except BaseException as _g:
                None
                return None
        elif (self.buffer is None):
            return 0
        else:
            x = (self.buffer.totalVertices() / 3)
            try:
                return int(x)
            except BaseException as _g:
                None
                return None

    def vertexCount(self):
        return 0

    def getCollider(self):
        raise haxe_Exception.thrown(("not implemented for " + Std.string(self)))

    def getBounds(self):
        raise haxe_Exception.thrown(("not implemented for " + Std.string(self)))

    def incref(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.refCount
        _hx_local_0.refCount = (_hx_local_1 + 1)
        _hx_local_1

    def decref(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.refCount
        _hx_local_0.refCount = (_hx_local_1 - 1)
        _hx_local_1
        if (self.refCount <= 0):
            self.refCount = 0
            self.dispose()

    def alloc(self,engine):
        raise haxe_Exception.thrown("not implemented")

    def selectMaterial(self,material):
        pass

    def buildNormalsDisplay(self):
        raise haxe_Exception.thrown(("not implemented for " + Std.string(self)))

    def render(self,engine):
        tmp = None
        if (self.buffer is not None):
            _this = self.buffer
            tmp = ((_this.buffer is None) or ((_this.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            self.alloc(engine)
        if (self.indexes is None):
            if (((self.buffer.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0):
                engine.renderBuffer(self.buffer,engine.mem.quadIndexes,2,0,-1)
            else:
                engine.renderBuffer(self.buffer,engine.mem.triIndexes,3,0,-1)
        else:
            engine.renderIndexed(self.buffer,self.indexes)

    def dispose(self):
        if (self.buffer is not None):
            self.buffer.dispose()
            self.buffer = None
        if (self.indexes is not None):
            self.indexes.dispose()
            self.indexes = None

    def toString(self):
        _this = Type.getClassName(Type.getClass(self))
        _this1 = _this.split(".")
        return (None if ((len(_this1) == 0)) else _this1.pop())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.indexes = None
        _hx_o.refCount = None
h3d_prim_Primitive._hx_class = h3d_prim_Primitive
_hx_classes["h3d.prim.Primitive"] = h3d_prim_Primitive


class h2d_TileLayerContent(h3d_prim_Primitive):
    _hx_class_name = "h2d.TileLayerContent"
    _hx_is_interface = "False"
    __slots__ = ("tmp", "xMin", "yMin", "xMax", "yMax", "useAllocator", "state")
    _hx_fields = ["tmp", "xMin", "yMin", "xMax", "yMax", "useAllocator", "state"]
    _hx_methods = ["clear", "isEmpty", "triCount", "addColor", "add", "addTransform", "addPoint", "insertColor", "rectColor", "rectGradient", "fillArc", "fillCircle", "circle", "arc", "alloc", "dispose", "flush", "doRender"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self):
        self.state = None
        self.yMax = None
        self.xMax = None
        self.yMin = None
        self.xMin = None
        self.tmp = None
        self.useAllocator = False
        super().__init__()
        self.state = h2d_impl_BatchDrawState()
        self.clear()

    def clear(self):
        this1 = list()
        self.tmp = this1
        if (self.buffer is not None):
            if self.useAllocator:
                hxd_impl_Allocator.get().disposeBuffer(self.buffer)
            else:
                self.buffer.dispose()
        self.buffer = None
        self.xMin = Math.POSITIVE_INFINITY
        self.yMin = Math.POSITIVE_INFINITY
        self.xMax = Math.NEGATIVE_INFINITY
        self.yMax = Math.NEGATIVE_INFINITY
        self.state.clear()

    def isEmpty(self):
        return (self.triCount() == 0)

    def triCount(self):
        if (self.buffer is None):
            return (len(self.tmp) >> 4)
        else:
            return (self.buffer.totalVertices() >> 1)

    def addColor(self,x,y,color,t):
        self.add(x,y,color.x,color.y,color.z,color.w,t)

    def add(self,x,y,r,g,b,a,t):
        sx = (x + t.dx)
        sy = (y + t.dy)
        this1 = self.tmp
        this1.append(sx)
        this1 = self.tmp
        this1.append(sy)
        this1 = self.tmp
        v = t.u
        this1.append(v)
        this1 = self.tmp
        v = t.v
        this1.append(v)
        this1 = self.tmp
        this1.append(r)
        this1 = self.tmp
        this1.append(g)
        this1 = self.tmp
        this1.append(b)
        this1 = self.tmp
        this1.append(a)
        this1 = self.tmp
        v = (sx + t.width)
        this1.append(v)
        this1 = self.tmp
        this1.append(sy)
        this1 = self.tmp
        v = t.u2
        this1.append(v)
        this1 = self.tmp
        v = t.v
        this1.append(v)
        this1 = self.tmp
        this1.append(r)
        this1 = self.tmp
        this1.append(g)
        this1 = self.tmp
        this1.append(b)
        this1 = self.tmp
        this1.append(a)
        this1 = self.tmp
        this1.append(sx)
        this1 = self.tmp
        v = (sy + t.height)
        this1.append(v)
        this1 = self.tmp
        v = t.u
        this1.append(v)
        this1 = self.tmp
        v = t.v2
        this1.append(v)
        this1 = self.tmp
        this1.append(r)
        this1 = self.tmp
        this1.append(g)
        this1 = self.tmp
        this1.append(b)
        this1 = self.tmp
        this1.append(a)
        this1 = self.tmp
        v = (sx + t.width)
        this1.append(v)
        this1 = self.tmp
        v = (sy + t.height)
        this1.append(v)
        this1 = self.tmp
        v = t.u2
        this1.append(v)
        this1 = self.tmp
        v = t.v2
        this1.append(v)
        this1 = self.tmp
        this1.append(r)
        this1 = self.tmp
        this1.append(g)
        this1 = self.tmp
        this1.append(b)
        this1 = self.tmp
        this1.append(a)
        x1 = (x + t.dx)
        y1 = (y + t.dy)
        if (x1 < self.xMin):
            self.xMin = x1
        if (y1 < self.yMin):
            self.yMin = y1
        x1 = (x1 + t.width)
        y1 = (y1 + t.height)
        if (x1 > self.xMax):
            self.xMax = x1
        if (y1 > self.yMax):
            self.yMax = y1
        if (t is not None):
            self.state.setTexture(t.innerTex)
        _this = self.state
        _hx_local_2 = _this.tail
        _hx_local_3 = _hx_local_2.count
        _hx_local_2.count = (_hx_local_3 + 4)
        _hx_local_2.count
        _this.totalCount = (_this.totalCount + 4)

    def addTransform(self,x,y,sx,sy,r,c,t):
        _gthis = self
        ca = (Math.NaN if (((r == Math.POSITIVE_INFINITY) or ((r == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(r))
        sa = (Math.NaN if (((r == Math.POSITIVE_INFINITY) or ((r == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(r))
        hx = t.width
        hy = t.height
        dx = (t.dx * sx)
        dy = (t.dy * sy)
        px = (((dx * ca) - ((dy * sa))) + x)
        py = (((dy * ca) + ((dx * sa))) + y)
        this1 = self.tmp
        this1.append(px)
        this1 = self.tmp
        this1.append(py)
        this1 = self.tmp
        v = t.u
        this1.append(v)
        this1 = self.tmp
        v = t.v
        this1.append(v)
        this1 = self.tmp
        v = c.x
        this1.append(v)
        this1 = self.tmp
        v = c.y
        this1.append(v)
        this1 = self.tmp
        v = c.z
        this1.append(v)
        this1 = self.tmp
        v = c.w
        this1.append(v)
        if (px < _gthis.xMin):
            _gthis.xMin = px
        if (py < _gthis.yMin):
            _gthis.yMin = py
        if (px > _gthis.xMax):
            _gthis.xMax = px
        if (py > _gthis.yMax):
            _gthis.yMax = py
        dx = (((t.dx + hx)) * sx)
        dy = (t.dy * sy)
        px = (((dx * ca) - ((dy * sa))) + x)
        py = (((dy * ca) + ((dx * sa))) + y)
        this1 = self.tmp
        this1.append(px)
        this1 = self.tmp
        this1.append(py)
        this1 = self.tmp
        v = t.u2
        this1.append(v)
        this1 = self.tmp
        v = t.v
        this1.append(v)
        this1 = self.tmp
        v = c.x
        this1.append(v)
        this1 = self.tmp
        v = c.y
        this1.append(v)
        this1 = self.tmp
        v = c.z
        this1.append(v)
        this1 = self.tmp
        v = c.w
        this1.append(v)
        if (px < _gthis.xMin):
            _gthis.xMin = px
        if (py < _gthis.yMin):
            _gthis.yMin = py
        if (px > _gthis.xMax):
            _gthis.xMax = px
        if (py > _gthis.yMax):
            _gthis.yMax = py
        dx = (t.dx * sx)
        dy = (((t.dy + hy)) * sy)
        px = (((dx * ca) - ((dy * sa))) + x)
        py = (((dy * ca) + ((dx * sa))) + y)
        this1 = self.tmp
        this1.append(px)
        this1 = self.tmp
        this1.append(py)
        this1 = self.tmp
        v = t.u
        this1.append(v)
        this1 = self.tmp
        v = t.v2
        this1.append(v)
        this1 = self.tmp
        v = c.x
        this1.append(v)
        this1 = self.tmp
        v = c.y
        this1.append(v)
        this1 = self.tmp
        v = c.z
        this1.append(v)
        this1 = self.tmp
        v = c.w
        this1.append(v)
        if (px < _gthis.xMin):
            _gthis.xMin = px
        if (py < _gthis.yMin):
            _gthis.yMin = py
        if (px > _gthis.xMax):
            _gthis.xMax = px
        if (py > _gthis.yMax):
            _gthis.yMax = py
        dx = (((t.dx + hx)) * sx)
        dy = (((t.dy + hy)) * sy)
        px = (((dx * ca) - ((dy * sa))) + x)
        py = (((dy * ca) + ((dx * sa))) + y)
        this1 = self.tmp
        this1.append(px)
        this1 = self.tmp
        this1.append(py)
        this1 = self.tmp
        v = t.u2
        this1.append(v)
        this1 = self.tmp
        v = t.v2
        this1.append(v)
        this1 = self.tmp
        v = c.x
        this1.append(v)
        this1 = self.tmp
        v = c.y
        this1.append(v)
        this1 = self.tmp
        v = c.z
        this1.append(v)
        this1 = self.tmp
        v = c.w
        this1.append(v)
        if (px < _gthis.xMin):
            _gthis.xMin = px
        if (py < _gthis.yMin):
            _gthis.yMin = py
        if (px > _gthis.xMax):
            _gthis.xMax = px
        if (py > _gthis.yMax):
            _gthis.yMax = py
        if (t is not None):
            self.state.setTexture(t.innerTex)
        _this = self.state
        _hx_local_0 = _this.tail
        _hx_local_1 = _hx_local_0.count
        _hx_local_0.count = (_hx_local_1 + 4)
        _hx_local_0.count
        _this.totalCount = (_this.totalCount + 4)

    def addPoint(self,x,y,color):
        this1 = self.tmp
        this1.append(x)
        this1 = self.tmp
        this1.append(y)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(((((color >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((color >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((color & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(color, 24)) / 255.))
        if (x < self.xMin):
            self.xMin = x
        if (y < self.yMin):
            self.yMin = y
        if (x > self.xMax):
            self.xMax = x
        if (y > self.yMax):
            self.yMax = y

    def insertColor(self,c):
        this1 = self.tmp
        this1.append(((((c >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((c >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((c & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(c, 24)) / 255.))

    def rectColor(self,x,y,w,h,color):
        this1 = self.tmp
        this1.append(x)
        this1 = self.tmp
        this1.append(y)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(((((color >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((color >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((color & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(color, 24)) / 255.))
        this1 = self.tmp
        this1.append((x + w))
        this1 = self.tmp
        this1.append(y)
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(((((color >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((color >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((color & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(color, 24)) / 255.))
        this1 = self.tmp
        this1.append(x)
        this1 = self.tmp
        this1.append((y + h))
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(((((color >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((color >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((color & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(color, 24)) / 255.))
        this1 = self.tmp
        this1.append((x + w))
        this1 = self.tmp
        this1.append((y + h))
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(((((color >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((color >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((color & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(color, 24)) / 255.))
        if (x < self.xMin):
            self.xMin = x
        if (y < self.yMin):
            self.yMin = y
        x = (x + w)
        y = (y + h)
        if (x > self.xMax):
            self.xMax = x
        if (y > self.yMax):
            self.yMax = y
        _this = self.state
        _hx_local_2 = _this.tail
        _hx_local_3 = _hx_local_2.count
        _hx_local_2.count = (_hx_local_3 + 4)
        _hx_local_2.count
        _this.totalCount = (_this.totalCount + 4)

    def rectGradient(self,x,y,w,h,ctl,ctr,cbl,cbr):
        this1 = self.tmp
        this1.append(x)
        this1 = self.tmp
        this1.append(y)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(((((ctl >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((ctl >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((ctl & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(ctl, 24)) / 255.))
        this1 = self.tmp
        this1.append((x + w))
        this1 = self.tmp
        this1.append(y)
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(((((ctr >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((ctr >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((ctr & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(ctr, 24)) / 255.))
        this1 = self.tmp
        this1.append(x)
        this1 = self.tmp
        this1.append((y + h))
        this1 = self.tmp
        this1.append(0)
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(((((cbl >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((cbl >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((cbl & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(cbl, 24)) / 255.))
        this1 = self.tmp
        this1.append((x + w))
        this1 = self.tmp
        this1.append((y + h))
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(1)
        this1 = self.tmp
        this1.append(((((cbr >> 16) & 255)) / 255.))
        this1 = self.tmp
        this1.append(((((cbr >> 8) & 255)) / 255.))
        this1 = self.tmp
        this1.append((((cbr & 255)) / 255.))
        this1 = self.tmp
        this1.append(((HxOverrides.rshift(cbr, 24)) / 255.))
        if (x < self.xMin):
            self.xMin = x
        if (y < self.yMin):
            self.yMin = y
        x = (x + w)
        y = (y + h)
        if (x > self.xMax):
            self.xMax = x
        if (y > self.yMax):
            self.yMax = y
        _this = self.state
        _hx_local_2 = _this.tail
        _hx_local_3 = _hx_local_2.count
        _hx_local_2.count = (_hx_local_3 + 4)
        _hx_local_2.count
        _this.totalCount = (_this.totalCount + 4)

    def fillArc(self,x,y,ray,c,start,end):
        if (end <= start):
            return
        arcLength = (end - start)
        nsegments = Math.ceil((((ray * 3.14) * 2) / 4))
        if (nsegments < 4):
            nsegments = 4
        angle = (arcLength / nsegments)
        prevX = Math.NEGATIVE_INFINITY
        prevY = Math.NEGATIVE_INFINITY
        _x = 0.
        _y = 0.
        i = 0
        count = 0
        while (i < nsegments):
            a = (start + ((i * angle)))
            _x = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray)))
            _y = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray)))
            if (prevX != Math.NEGATIVE_INFINITY):
                self.addPoint(x,y,c)
                self.addPoint(_x,_y,c)
                self.addPoint(prevX,prevY,c)
                self.addPoint(prevX,prevY,c)
                count = (count + 4)
            prevX = _x
            prevY = _y
            i = (i + 1)
        a = end
        _x = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray)))
        _y = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray)))
        self.addPoint(x,y,c)
        self.addPoint(_x,_y,c)
        self.addPoint(prevX,prevY,c)
        self.addPoint(prevX,prevY,c)
        _this = self.state
        count1 = (count + 4)
        _hx_local_2 = _this.tail
        _hx_local_3 = _hx_local_2.count
        _hx_local_2.count = (_hx_local_3 + count1)
        _hx_local_2.count
        _this.totalCount = (_this.totalCount + count1)

    def fillCircle(self,x,y,radius,c):
        nsegments = Math.ceil((((radius * 3.14) * 2) / 2))
        if (nsegments < 3):
            nsegments = 3
        angle = ((Math.PI * 2) / nsegments)
        prevX = Math.NEGATIVE_INFINITY
        prevY = Math.NEGATIVE_INFINITY
        firstX = Math.NEGATIVE_INFINITY
        firstY = Math.NEGATIVE_INFINITY
        curX = 0.
        curY = 0.
        count = 0
        _g = 0
        _g1 = nsegments
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            a = (i * angle)
            curX = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * radius)))
            curY = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * radius)))
            if (prevX != Math.NEGATIVE_INFINITY):
                self.addPoint(x,y,c)
                self.addPoint(curX,curY,c)
                self.addPoint(prevX,prevY,c)
                self.addPoint(x,y,c)
                count = (count + 4)
            if (firstX == Math.NEGATIVE_INFINITY):
                firstX = curX
                firstY = curY
            prevX = curX
            prevY = curY
        self.addPoint(x,y,c)
        self.addPoint(curX,curY,c)
        self.addPoint(firstX,firstY,c)
        self.addPoint(x,y,c)
        _this = self.state
        count1 = (count + 4)
        _hx_local_1 = _this.tail
        _hx_local_2 = _hx_local_1.count
        _hx_local_1.count = (_hx_local_2 + count1)
        _hx_local_1.count
        _this.totalCount = (_this.totalCount + count1)

    def circle(self,x,y,ray,size,c):
        if (size > ray):
            return
        nsegments = Math.ceil((((ray * 3.14) * 2) / 2))
        if (nsegments < 3):
            nsegments = 3
        ray1 = (ray - size)
        angle = ((Math.PI * 2) / nsegments)
        prevX = Math.NEGATIVE_INFINITY
        prevY = Math.NEGATIVE_INFINITY
        prevX1 = Math.NEGATIVE_INFINITY
        prevY1 = Math.NEGATIVE_INFINITY
        count = 0
        _g = 0
        _g1 = nsegments
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            a = (i * angle)
            _x = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray)))
            _y = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray)))
            _x1 = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray1)))
            _y1 = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray1)))
            if (prevX != Math.NEGATIVE_INFINITY):
                self.addPoint(_x,_y,c)
                self.addPoint(prevX,prevY,c)
                self.addPoint(_x1,_y1,c)
                self.addPoint(prevX1,prevY1,c)
                count = (count + 4)
            prevX = _x
            prevY = _y
            prevX1 = _x1
            prevY1 = _y1
        _this = self.state
        _hx_local_1 = _this.tail
        _hx_local_2 = _hx_local_1.count
        _hx_local_1.count = (_hx_local_2 + count)
        _hx_local_1.count
        _this.totalCount = (_this.totalCount + count)

    def arc(self,x,y,ray,size,start,end,c):
        if (size > ray):
            return
        if (end <= start):
            return
        arcLength = (end - start)
        nsegments = Math.ceil((((ray * 3.14) * 2) / 4))
        if (nsegments < 3):
            nsegments = 3
        ray1 = (ray - size)
        angle = (arcLength / nsegments)
        prevX = Math.NEGATIVE_INFINITY
        prevY = Math.NEGATIVE_INFINITY
        prevX1 = Math.NEGATIVE_INFINITY
        prevY1 = Math.NEGATIVE_INFINITY
        _x = 0.
        _y = 0.
        _x1 = 0.
        _y1 = 0.
        count = 0
        _g = 0
        _g1 = nsegments
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            a = (start + ((i * angle)))
            _x = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray)))
            _y = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray)))
            _x1 = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray1)))
            _y1 = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray1)))
            if (prevX != Math.NEGATIVE_INFINITY):
                self.addPoint(_x,_y,c)
                self.addPoint(prevX,prevY,c)
                self.addPoint(_x1,_y1,c)
                self.addPoint(prevX1,prevY1,c)
                count = (count + 4)
            prevX = _x
            prevY = _y
            prevX1 = _x1
            prevY1 = _y1
        a = end
        _x = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray)))
        _y = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray)))
        _x1 = (x + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * ray1)))
        _y1 = (y + ((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * ray1)))
        self.addPoint(_x,_y,c)
        self.addPoint(prevX,prevY,c)
        self.addPoint(_x1,_y1,c)
        self.addPoint(prevX1,prevY1,c)
        _this = self.state
        count1 = (count + 4)
        _hx_local_1 = _this.tail
        _hx_local_2 = _hx_local_1.count
        _hx_local_1.count = (_hx_local_2 + count1)
        _hx_local_1.count
        _this.totalCount = (_this.totalCount + count1)

    def alloc(self,engine):
        if (self.tmp is None):
            self.clear()
        if (len(self.tmp) > 0):
            self.buffer = (hxd_impl_Allocator.get().ofFloats(self.tmp,8,3) if (self.useAllocator) else h3d_Buffer.ofFloats(self.tmp,8,[h3d_BufferFlag.Quads, h3d_BufferFlag.RawFormat]))

    def dispose(self):
        if (self.buffer is not None):
            if self.useAllocator:
                hxd_impl_Allocator.get().disposeBuffer(self.buffer)
            else:
                self.buffer.dispose()
            self.buffer = None
        super().dispose()

    def flush(self):
        tmp = None
        if (self.buffer is not None):
            _this = self.buffer
            tmp = ((_this.buffer is None) or ((_this.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            self.alloc(h3d_Engine.CURRENT)

    def doRender(self,ctx,_hx_min,_hx_len):
        tmp = None
        if (self.buffer is not None):
            _this = self.buffer
            tmp = ((_this.buffer is None) or ((_this.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            self.alloc(h3d_Engine.CURRENT)
        self.state.drawQuads(ctx,self.buffer,_hx_min,_hx_len)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tmp = None
        _hx_o.xMin = None
        _hx_o.yMin = None
        _hx_o.xMax = None
        _hx_o.yMax = None
        _hx_o.useAllocator = None
        _hx_o.state = None
h2d_TileLayerContent._hx_class = h2d_TileLayerContent
_hx_classes["h2d.TileLayerContent"] = h2d_TileLayerContent


class h2d_TileGroup(h2d_Drawable):
    _hx_class_name = "h2d.TileGroup"
    _hx_is_interface = "False"
    __slots__ = ("content", "curColor", "tile", "rangeMin", "rangeMax")
    _hx_fields = ["content", "curColor", "tile", "rangeMin", "rangeMax"]
    _hx_methods = ["getBoundsRec", "clear", "invalidate", "count", "onRemove", "setDefaultColor", "add", "addColor", "addAlpha", "addTransform", "draw", "sync", "drawWith"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Drawable


    def __init__(self,t = None,parent = None):
        self.rangeMax = None
        self.rangeMin = None
        self.tile = None
        self.curColor = None
        self.content = None
        super().__init__(parent)
        self.tile = t
        def _hx_local_0():
            self.rangeMax = -1
            return self.rangeMax
        self.rangeMin = _hx_local_0()
        self.curColor = h3d_Vector(1,1,1,1)
        self.content = h2d_TileLayerContent()

    def getBoundsRec(self,relativeTo,out,forSize):
        super().getBoundsRec(relativeTo,out,forSize)
        self.addBounds(relativeTo,out,self.content.xMin,self.content.yMin,(self.content.xMax - self.content.xMin),(self.content.yMax - self.content.yMin))

    def clear(self):
        self.content.clear()

    def invalidate(self):
        self.content.dispose()

    def count(self):
        return (self.content.triCount() >> 1)

    def onRemove(self):
        self.content.dispose()
        super().onRemove()

    def setDefaultColor(self,rgb,alpha = None):
        if (alpha is None):
            alpha = 1.0
        self.curColor.x = ((((rgb >> 16) & 255)) / 255)
        self.curColor.y = ((((rgb >> 8) & 255)) / 255)
        self.curColor.z = (((rgb & 255)) / 255)
        self.curColor.w = alpha

    def add(self,x,y,t):
        self.content.add(x,y,self.curColor.x,self.curColor.y,self.curColor.z,self.curColor.w,t)

    def addColor(self,x,y,r,g,b,a,t):
        self.content.add(x,y,r,g,b,a,t)

    def addAlpha(self,x,y,a,t):
        self.content.add(x,y,self.curColor.x,self.curColor.y,self.curColor.z,a,t)

    def addTransform(self,x,y,sx,sy,r,t):
        self.content.addTransform(x,y,sx,sy,r,self.curColor,t)

    def draw(self,ctx):
        self.drawWith(ctx,self)

    def sync(self,ctx):
        super().sync(ctx)
        if self.visible:
            _this = self.content
            tmp = None
            if (_this.buffer is not None):
                _this1 = _this.buffer
                tmp = ((_this1.buffer is None) or ((_this1.buffer.vbuf is None)))
            else:
                tmp = True
            if tmp:
                _this.alloc(h3d_Engine.CURRENT)

    def drawWith(self,ctx,obj):
        _hx_max = self.content.triCount()
        if (_hx_max == 0):
            return
        if (not ctx.beginDrawBatchState(obj)):
            return
        _hx_min = (0 if ((self.rangeMin < 0)) else (self.rangeMin * 2))
        if ((self.rangeMax > 0) and ((self.rangeMax < ((_hx_max * 2))))):
            _hx_max = (self.rangeMax * 2)
        _this = self.content
        tmp = None
        if (_this.buffer is not None):
            _this1 = _this.buffer
            tmp = ((_this1.buffer is None) or ((_this1.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            _this.alloc(h3d_Engine.CURRENT)
        _this.state.drawQuads(ctx,_this.buffer,_hx_min,(_hx_max - _hx_min))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.content = None
        _hx_o.curColor = None
        _hx_o.tile = None
        _hx_o.rangeMin = None
        _hx_o.rangeMax = None
h2d_TileGroup._hx_class = h2d_TileGroup
_hx_classes["h2d.TileGroup"] = h2d_TileGroup


class h2d_col_Bounds:
    _hx_class_name = "h2d.col.Bounds"
    _hx_is_interface = "False"
    __slots__ = ("xMin", "yMin", "xMax", "yMax")
    _hx_fields = ["xMin", "yMin", "xMax", "yMax"]
    _hx_methods = ["toIBounds", "intersects", "contains", "distanceSq", "distance", "addBounds", "addPoint", "addPos", "set", "setMin", "setMax", "doIntersect", "doUnion", "intersection", "union", "load", "scalePivot", "scaleCenter", "rotate", "offset", "getMin", "getCenter", "getSize", "getMax", "isEmpty", "empty", "all", "clone", "get_x", "get_y", "set_x", "set_y", "get_width", "get_height", "set_width", "set_height", "toString", "toCircle"]
    _hx_statics = ["fromValues", "fromPoints"]

    def __init__(self):
        self.xMin = 1e20
        self.yMin = 1e20
        self.xMax = -1e20
        self.yMax = -1e20

    def toIBounds(self,scale = None):
        if (scale is None):
            scale = 1.
        ix = Math.floor((self.xMin * scale))
        iy = Math.floor((self.yMin * scale))
        width = (Math.ceil((self.xMax * scale)) - ix)
        height = (Math.ceil((self.yMax * scale)) - iy)
        b = h2d_col_IBounds()
        b.xMin = ix
        b.yMin = iy
        b.xMax = (ix + width)
        b.yMax = (iy + height)
        return b

    def intersects(self,b):
        return (not (((((self.xMin > b.xMax) or ((self.yMin > b.yMax))) or ((self.xMax < b.xMin))) or ((self.yMax < b.yMin)))))

    def contains(self,p):
        if (((p.x >= self.xMin) and ((p.x < self.xMax))) and ((p.y >= self.yMin))):
            return (p.y < self.yMax)
        else:
            return False

    def distanceSq(self,p):
        dx = ((self.xMin - p.x) if ((p.x < self.xMin)) else ((p.x - self.xMax) if ((p.x > self.xMax)) else 0.))
        dy = ((self.yMin - p.y) if ((p.y < self.yMin)) else ((p.y - self.yMax) if ((p.y > self.yMax)) else 0.))
        return ((dx * dx) + ((dy * dy)))

    def distance(self,p):
        dx = ((self.xMin - p.x) if ((p.x < self.xMin)) else ((p.x - self.xMax) if ((p.x > self.xMax)) else 0.))
        dy = ((self.yMin - p.y) if ((p.y < self.yMin)) else ((p.y - self.yMax) if ((p.y > self.yMax)) else 0.))
        f = ((dx * dx) + ((dy * dy)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def addBounds(self,b):
        if (b.xMin < self.xMin):
            self.xMin = b.xMin
        if (b.xMax > self.xMax):
            self.xMax = b.xMax
        if (b.yMin < self.yMin):
            self.yMin = b.yMin
        if (b.yMax > self.yMax):
            self.yMax = b.yMax

    def addPoint(self,p):
        if (p.x < self.xMin):
            self.xMin = p.x
        if (p.x > self.xMax):
            self.xMax = p.x
        if (p.y < self.yMin):
            self.yMin = p.y
        if (p.y > self.yMax):
            self.yMax = p.y

    def addPos(self,x,y):
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y

    def set(self,x,y,width,height):
        self.xMin = x
        self.yMin = y
        self.xMax = (x + width)
        self.yMax = (y + height)

    def setMin(self,p):
        self.xMin = p.x
        self.yMin = p.y

    def setMax(self,p):
        self.xMax = p.x
        self.yMax = p.y

    def doIntersect(self,b):
        a = self.xMin
        b1 = b.xMin
        self.xMin = (b1 if ((a < b1)) else a)
        a = self.yMin
        b1 = b.yMin
        self.yMin = (b1 if ((a < b1)) else a)
        a = self.xMax
        b1 = b.xMax
        self.xMax = (b1 if ((a > b1)) else a)
        a = self.yMax
        b1 = b.yMax
        self.yMax = (b1 if ((a > b1)) else a)

    def doUnion(self,b):
        a = self.xMin
        b1 = b.xMin
        self.xMin = (b1 if ((a > b1)) else a)
        a = self.yMin
        b1 = b.yMin
        self.yMin = (b1 if ((a > b1)) else a)
        a = self.xMax
        b1 = b.xMax
        self.xMax = (b1 if ((a < b1)) else a)
        a = self.yMax
        b1 = b.yMax
        self.yMax = (b1 if ((a < b1)) else a)

    def intersection(self,b):
        i = h2d_col_Bounds()
        a = self.xMin
        b1 = b.xMin
        i.xMin = (b1 if ((a < b1)) else a)
        a = self.yMin
        b1 = b.yMin
        i.yMin = (b1 if ((a < b1)) else a)
        a = self.xMax
        b1 = b.xMax
        i.xMax = (b1 if ((a > b1)) else a)
        a = self.yMax
        b1 = b.yMax
        i.yMax = (b1 if ((a > b1)) else a)
        if (i.xMax < i.xMin):
            i.xMax = i.xMin
        if (i.yMax < i.yMin):
            i.yMax = i.yMin
        return i

    def union(self,b):
        i = h2d_col_Bounds()
        a = self.xMin
        b1 = b.xMin
        i.xMin = (b1 if ((a > b1)) else a)
        a = self.yMin
        b1 = b.yMin
        i.yMin = (b1 if ((a > b1)) else a)
        a = self.xMax
        b1 = b.xMax
        i.xMax = (b1 if ((a < b1)) else a)
        a = self.yMax
        b1 = b.yMax
        i.yMax = (b1 if ((a < b1)) else a)
        return i

    def load(self,b):
        self.xMin = b.xMin
        self.yMin = b.yMin
        self.xMax = b.xMax
        self.yMax = b.yMax

    def scalePivot(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 * v)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.yMin
        _hx_local_2.yMin = (_hx_local_3 * v)
        _hx_local_2.yMin
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.xMax
        _hx_local_4.xMax = (_hx_local_5 * v)
        _hx_local_4.xMax
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.yMax
        _hx_local_6.yMax = (_hx_local_7 * v)
        _hx_local_6.yMax

    def scaleCenter(self,v):
        dx = ((((self.xMax - self.xMin)) * 0.5) * v)
        dy = ((((self.yMax - self.yMin)) * 0.5) * v)
        mx = (((self.xMax + self.xMin)) * 0.5)
        my = (((self.yMax + self.yMin)) * 0.5)
        self.xMin = (mx - dx)
        self.yMin = (my - dy)
        self.xMax = (mx + dx)
        self.yMax = (my + dy)

    def rotate(self,angle):
        cos = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sin = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        x0 = self.xMin
        y0 = self.yMin
        x1 = self.xMax
        y1 = self.yMax
        self.xMin = 1e20
        self.yMin = 1e20
        self.xMax = -1e20
        self.yMax = -1e20
        x = ((x0 * cos) - ((y0 * sin)))
        y = ((x0 * sin) + ((y0 * cos)))
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y
        x = ((x1 * cos) - ((y0 * sin)))
        y = ((x1 * sin) + ((y0 * cos)))
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y
        x = ((x0 * cos) - ((y1 * sin)))
        y = ((x0 * sin) + ((y1 * cos)))
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y
        x = ((x1 * cos) - ((y1 * sin)))
        y = ((x1 * sin) + ((y1 * cos)))
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y

    def offset(self,dx,dy):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 + dx)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.xMax
        _hx_local_2.xMax = (_hx_local_3 + dx)
        _hx_local_2.xMax
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.yMin
        _hx_local_4.yMin = (_hx_local_5 + dy)
        _hx_local_4.yMin
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.yMax
        _hx_local_6.yMax = (_hx_local_7 + dy)
        _hx_local_6.yMax

    def getMin(self):
        return h2d_col_Point(self.xMin,self.yMin)

    def getCenter(self):
        return h2d_col_Point((((self.xMin + self.xMax)) * 0.5),(((self.yMin + self.yMax)) * 0.5))

    def getSize(self):
        return h2d_col_Point((self.xMax - self.xMin),(self.yMax - self.yMin))

    def getMax(self):
        return h2d_col_Point(self.xMax,self.yMax)

    def isEmpty(self):
        if (not ((self.xMax <= self.xMin))):
            return (self.yMax <= self.yMin)
        else:
            return True

    def empty(self):
        self.xMin = 1e20
        self.yMin = 1e20
        self.xMax = -1e20
        self.yMax = -1e20

    def all(self):
        self.xMin = -1e20
        self.yMin = -1e20
        self.xMax = 1e20
        self.yMax = 1e20

    def clone(self):
        b = h2d_col_Bounds()
        b.xMin = self.xMin
        b.yMin = self.yMin
        b.xMax = self.xMax
        b.yMax = self.yMax
        return b

    def get_x(self):
        return self.xMin

    def get_y(self):
        return self.yMin

    def set_x(self,x):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMax
        _hx_local_0.xMax = (_hx_local_1 + ((x - self.xMin)))
        _hx_local_0.xMax
        def _hx_local_3():
            def _hx_local_2():
                self.xMin = x
                return self.xMin
            return _hx_local_2()
        return _hx_local_3()

    def set_y(self,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.yMax
        _hx_local_0.yMax = (_hx_local_1 + ((y - self.yMin)))
        _hx_local_0.yMax
        def _hx_local_3():
            def _hx_local_2():
                self.yMin = y
                return self.yMin
            return _hx_local_2()
        return _hx_local_3()

    def get_width(self):
        return (self.xMax - self.xMin)

    def get_height(self):
        return (self.yMax - self.yMin)

    def set_width(self,w):
        self.xMax = (self.xMin + w)
        return w

    def set_height(self,h):
        self.yMax = (self.yMin + h)
        return h

    def toString(self):
        return (((("{" + Std.string(h2d_col_Point(self.xMin,self.yMin))) + ",") + Std.string(h2d_col_Point((self.xMax - self.xMin),(self.yMax - self.yMin)))) + "}")

    def toCircle(self):
        dx = (self.xMax - self.xMin)
        dy = (self.yMax - self.yMin)
        f = ((dx * dx) + ((dy * dy)))
        return h2d_col_Circle((((self.xMin + self.xMax)) * 0.5),(((self.yMin + self.yMax)) * 0.5),(((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 0.5))

    @staticmethod
    def fromValues(x0,y0,width,height):
        b = h2d_col_Bounds()
        b.xMin = x0
        b.yMin = y0
        b.xMax = (x0 + width)
        b.yMax = (y0 + height)
        return b

    @staticmethod
    def fromPoints(_hx_min,_hx_max):
        b = h2d_col_Bounds()
        b.xMin = _hx_min.x
        b.yMin = _hx_min.y
        b.xMax = _hx_max.x
        b.yMax = _hx_max.y
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.xMin = None
        _hx_o.yMin = None
        _hx_o.xMax = None
        _hx_o.yMax = None
h2d_col_Bounds._hx_class = h2d_col_Bounds
_hx_classes["h2d.col.Bounds"] = h2d_col_Bounds


class h2d_col_Collider:
    _hx_class_name = "h2d.col.Collider"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["contains"]
h2d_col_Collider._hx_class = h2d_col_Collider
_hx_classes["h2d.col.Collider"] = h2d_col_Collider


class h2d_col_Circle:
    _hx_class_name = "h2d.col.Circle"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "ray")
    _hx_fields = ["x", "y", "ray"]
    _hx_methods = ["distanceSq", "side", "collideCircle", "collideBounds", "lineIntersect", "toString", "contains"]
    _hx_interfaces = [h2d_col_Collider]

    def __init__(self,x,y,ray):
        self.x = x
        self.y = y
        self.ray = ray

    def distanceSq(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        d = (((dx * dx) + ((dy * dy))) - ((self.ray * self.ray)))
        if (d < 0):
            return 0
        else:
            return d

    def side(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        return ((self.ray * self.ray) - (((dx * dx) + ((dy * dy)))))

    def collideCircle(self,c):
        dx = (self.x - c.x)
        dy = (self.y - c.y)
        return (((dx * dx) + ((dy * dy))) < ((((self.ray + c.ray)) * ((self.ray + c.ray)))))

    def collideBounds(self,b):
        if (self.x < ((b.xMin - self.ray))):
            return False
        if (self.x > ((b.xMax + self.ray))):
            return False
        if (self.y < ((b.yMin - self.ray))):
            return False
        if (self.y > ((b.yMax + self.ray))):
            return False
        tmp = None
        if ((self.x < b.xMin) and ((self.y < b.yMin))):
            dx = (self.x - b.xMin)
            dy = (self.y - b.yMin)
            tmp = (((dx * dx) + ((dy * dy))) > ((self.ray * self.ray)))
        else:
            tmp = False
        if tmp:
            return False
        tmp = None
        if ((self.x > b.xMax) and ((self.y < b.yMin))):
            dx = (self.x - b.xMax)
            dy = (self.y - b.yMin)
            tmp = (((dx * dx) + ((dy * dy))) > ((self.ray * self.ray)))
        else:
            tmp = False
        if tmp:
            return False
        tmp = None
        if ((self.x < b.xMin) and ((self.y > b.yMax))):
            dx = (self.x - b.xMin)
            dy = (self.y - b.yMax)
            tmp = (((dx * dx) + ((dy * dy))) > ((self.ray * self.ray)))
        else:
            tmp = False
        if tmp:
            return False
        tmp = None
        if ((self.x > b.xMax) and ((self.y > b.yMax))):
            dx = (self.x - b.xMax)
            dy = (self.y - b.yMax)
            tmp = (((dx * dx) + ((dy * dy))) > ((self.ray * self.ray)))
        else:
            tmp = False
        if tmp:
            return False
        return True

    def lineIntersect(self,p1,p2):
        dx = (p2.x - p1.x)
        dy = (p2.y - p1.y)
        a = ((dx * dx) + ((dy * dy)))
        if (a < 1e-8):
            return None
        b = (2 * (((dx * ((p1.x - self.x))) + ((dy * ((p1.y - self.y)))))))
        dx1 = (p1.x - self.x)
        dy1 = (p1.y - self.y)
        c = (((dx1 * dx1) + ((dy1 * dy1))) - ((self.ray * self.ray)))
        d = ((b * b) - (((4 * a) * c)))
        if (d < 0):
            return None
        if (d == 0):
            t = (-b / ((2 * a)))
            return [h2d_col_Point((p1.x + ((t * dx))),(p1.y + ((t * dy))))]
        t1 = (((-b - ((Math.NaN if ((d < 0)) else python_lib_Math.sqrt(d))))) / ((2 * a)))
        t2 = (((-b + ((Math.NaN if ((d < 0)) else python_lib_Math.sqrt(d))))) / ((2 * a)))
        return [h2d_col_Point((p1.x + ((t1 * dx))),(p1.y + ((t1 * dy)))), h2d_col_Point((p1.x + ((t2 * dx))),(p1.y + ((t2 * dy))))]

    def toString(self):
        return (((((("{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.ray))) + "}")

    def contains(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        d = (((dx * dx) + ((dy * dy))) - ((self.ray * self.ray)))
        return (((0 if ((d < 0)) else d)) == 0)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.ray = None
h2d_col_Circle._hx_class = h2d_col_Circle
_hx_classes["h2d.col.Circle"] = h2d_col_Circle


class h2d_col_IBounds:
    _hx_class_name = "h2d.col.IBounds"
    _hx_is_interface = "False"
    __slots__ = ("xMin", "yMin", "xMax", "yMax")
    _hx_fields = ["xMin", "yMin", "xMax", "yMax"]
    _hx_methods = ["toBounds", "intersects", "contains", "addBounds", "addPoint", "addPos", "set", "setMin", "setMax", "doIntersect", "doUnion", "intersection", "union", "load", "offset", "getMin", "getCenter", "getSize", "getMax", "isEmpty", "empty", "all", "clone", "get_x", "get_y", "set_x", "set_y", "get_width", "get_height", "set_width", "set_height", "toString"]
    _hx_statics = ["fromValues", "fromPoints"]

    def __init__(self):
        self.xMin = 2147483647
        self.yMin = 2147483647
        self.xMax = -2147483648
        self.yMax = -2147483648

    def toBounds(self,scale = None):
        if (scale is None):
            scale = 1.
        x0 = (self.xMin * scale)
        y0 = (self.yMin * scale)
        width = (((self.xMax - self.xMin)) * scale)
        height = (((self.yMax - self.yMin)) * scale)
        b = h2d_col_Bounds()
        b.xMin = x0
        b.yMin = y0
        b.xMax = (x0 + width)
        b.yMax = (y0 + height)
        return b

    def intersects(self,b):
        return (not (((((self.xMin > b.xMax) or ((self.yMin > b.yMax))) or ((self.xMax < b.xMin))) or ((self.yMax < b.yMin)))))

    def contains(self,p):
        if (((p.x >= self.xMin) and ((p.x < self.xMax))) and ((p.y >= self.yMin))):
            return (p.y < self.yMax)
        else:
            return False

    def addBounds(self,b):
        if (b.xMin < self.xMin):
            self.xMin = b.xMin
        if (b.xMax > self.xMax):
            self.xMax = b.xMax
        if (b.yMin < self.yMin):
            self.yMin = b.yMin
        if (b.yMax > self.yMax):
            self.yMax = b.yMax

    def addPoint(self,p):
        if (p.x < self.xMin):
            self.xMin = p.x
        if (p.x > self.xMax):
            self.xMax = p.x
        if (p.y < self.yMin):
            self.yMin = p.y
        if (p.y > self.yMax):
            self.yMax = p.y

    def addPos(self,x,y):
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y

    def set(self,x,y,width,height):
        self.xMin = x
        self.yMin = y
        self.xMax = (x + width)
        self.yMax = (y + height)

    def setMin(self,p):
        self.xMin = p.x
        self.yMin = p.y

    def setMax(self,p):
        self.xMax = p.x
        self.yMax = p.y

    def doIntersect(self,b):
        a = self.xMin
        b1 = b.xMin
        self.xMin = (b1 if ((a < b1)) else a)
        a = self.yMin
        b1 = b.yMin
        self.yMin = (b1 if ((a < b1)) else a)
        a = self.xMax
        b1 = b.xMax
        self.xMax = (b1 if ((a > b1)) else a)
        a = self.yMax
        b1 = b.yMax
        self.yMax = (b1 if ((a > b1)) else a)

    def doUnion(self,b):
        a = self.xMin
        b1 = b.xMin
        self.xMin = (b1 if ((a > b1)) else a)
        a = self.yMin
        b1 = b.yMin
        self.yMin = (b1 if ((a > b1)) else a)
        a = self.xMax
        b1 = b.xMax
        self.xMax = (b1 if ((a < b1)) else a)
        a = self.yMax
        b1 = b.yMax
        self.yMax = (b1 if ((a < b1)) else a)

    def intersection(self,b):
        i = h2d_col_IBounds()
        a = self.xMin
        b1 = b.xMin
        i.xMin = (b1 if ((a < b1)) else a)
        a = self.yMin
        b1 = b.yMin
        i.yMin = (b1 if ((a < b1)) else a)
        a = self.xMax
        b1 = b.xMax
        i.xMax = (b1 if ((a > b1)) else a)
        a = self.yMax
        b1 = b.yMax
        i.yMax = (b1 if ((a > b1)) else a)
        if (i.xMax < i.xMin):
            i.xMax = i.xMin
        if (i.yMax < i.yMin):
            i.yMax = i.yMin
        return i

    def union(self,b):
        i = h2d_col_IBounds()
        a = self.xMin
        b1 = b.xMin
        i.xMin = (b1 if ((a > b1)) else a)
        a = self.yMin
        b1 = b.yMin
        i.yMin = (b1 if ((a > b1)) else a)
        a = self.xMax
        b1 = b.xMax
        i.xMax = (b1 if ((a < b1)) else a)
        a = self.yMax
        b1 = b.yMax
        i.yMax = (b1 if ((a < b1)) else a)
        return i

    def load(self,b):
        self.xMin = b.xMin
        self.yMin = b.yMin
        self.xMax = b.xMax
        self.yMax = b.yMax

    def offset(self,dx,dy):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 + dx)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.xMax
        _hx_local_2.xMax = (_hx_local_3 + dx)
        _hx_local_2.xMax
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.yMin
        _hx_local_4.yMin = (_hx_local_5 + dy)
        _hx_local_4.yMin
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.yMax
        _hx_local_6.yMax = (_hx_local_7 + dy)
        _hx_local_6.yMax

    def getMin(self):
        return h2d_col_IPoint(self.xMin,self.yMin)

    def getCenter(self):
        return h2d_col_IPoint(((self.xMin + self.xMax) >> 1),((self.yMin + self.yMax) >> 1))

    def getSize(self):
        return h2d_col_IPoint((self.xMax - self.xMin),(self.yMax - self.yMin))

    def getMax(self):
        return h2d_col_IPoint(self.xMax,self.yMax)

    def isEmpty(self):
        if (self.xMax > self.xMin):
            return (self.yMax <= self.yMin)
        else:
            return True

    def empty(self):
        self.xMin = 2147483647
        self.yMin = 2147483647
        self.xMax = -2147483648
        self.yMax = -2147483648

    def all(self):
        self.xMin = -2147483648
        self.yMin = -2147483648
        self.xMax = 2147483647
        self.yMax = 2147483647

    def clone(self):
        b = h2d_col_IBounds()
        b.xMin = self.xMin
        b.yMin = self.yMin
        b.xMax = self.xMax
        b.yMax = self.yMax
        return b

    def get_x(self):
        return self.xMin

    def get_y(self):
        return self.yMin

    def set_x(self,x):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMax
        _hx_local_0.xMax = (_hx_local_1 + ((x - self.xMin)))
        _hx_local_0.xMax
        def _hx_local_3():
            def _hx_local_2():
                self.xMin = x
                return self.xMin
            return _hx_local_2()
        return _hx_local_3()

    def set_y(self,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.yMax
        _hx_local_0.yMax = (_hx_local_1 + ((y - self.yMin)))
        _hx_local_0.yMax
        def _hx_local_3():
            def _hx_local_2():
                self.yMin = y
                return self.yMin
            return _hx_local_2()
        return _hx_local_3()

    def get_width(self):
        return (self.xMax - self.xMin)

    def get_height(self):
        return (self.yMax - self.yMin)

    def set_width(self,w):
        self.xMax = (self.xMin + w)
        return w

    def set_height(self,h):
        self.yMax = (self.yMin + h)
        return h

    def toString(self):
        return (((("{" + Std.string(h2d_col_IPoint(self.xMin,self.yMin))) + ",") + Std.string(h2d_col_IPoint((self.xMax - self.xMin),(self.yMax - self.yMin)))) + "}")

    @staticmethod
    def fromValues(x0,y0,width,height):
        b = h2d_col_IBounds()
        b.xMin = x0
        b.yMin = y0
        b.xMax = (x0 + width)
        b.yMax = (y0 + height)
        return b

    @staticmethod
    def fromPoints(_hx_min,_hx_max):
        b = h2d_col_IBounds()
        b.xMin = _hx_min.x
        b.yMin = _hx_min.y
        b.xMax = _hx_max.x
        b.yMax = _hx_max.y
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.xMin = None
        _hx_o.yMin = None
        _hx_o.xMax = None
        _hx_o.yMax = None
h2d_col_IBounds._hx_class = h2d_col_IBounds
_hx_classes["h2d.col.IBounds"] = h2d_col_IBounds


class h2d_col_IPoint:
    _hx_class_name = "h2d.col.IPoint"
    _hx_is_interface = "False"
    __slots__ = ("x", "y")
    _hx_fields = ["x", "y"]
    _hx_methods = ["load", "scale", "multiply", "distanceSq", "distance", "toString", "sub", "add", "equals", "dot", "lengthSq", "length", "set", "clone", "cross", "toPoint"]

    def __init__(self,x = None,y = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        self.x = x
        self.y = y

    def load(self,p):
        self.x = p.x
        self.y = p.y

    def scale(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * v)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * v)
        _hx_local_2.y

    def multiply(self,v):
        return h2d_col_IPoint((self.x * v),(self.y * v))

    def distanceSq(self,p):
        dx = (self.x - p.x)
        dy = (self.y - p.y)
        return ((dx * dx) + ((dy * dy)))

    def distance(self,p):
        dx = (self.x - p.x)
        dy = (self.y - p.y)
        f = ((dx * dx) + ((dy * dy)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def toString(self):
        return (((("{" + Std.string(self.x)) + ",") + Std.string(self.y)) + "}")

    def sub(self,p):
        return h2d_col_IPoint((self.x - p.x),(self.y - p.y))

    def add(self,p):
        return h2d_col_IPoint((self.x + p.x),(self.y + p.y))

    def equals(self,other):
        if (self.x == other.x):
            return (self.y == other.y)
        else:
            return False

    def dot(self,p):
        return ((self.x * p.x) + ((self.y * p.y)))

    def lengthSq(self):
        return ((self.x * self.x) + ((self.y * self.y)))

    def length(self):
        f = ((self.x * self.x) + ((self.y * self.y)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def set(self,x = None,y = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        self.x = x
        self.y = y

    def clone(self):
        return h2d_col_IPoint(self.x,self.y)

    def cross(self,p):
        return ((self.x * p.y) - ((self.y * p.x)))

    def toPoint(self,scale = None):
        if (scale is None):
            scale = 1.
        return h2d_col_Point((self.x * scale),(self.y * scale))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
h2d_col_IPoint._hx_class = h2d_col_IPoint
_hx_classes["h2d.col.IPoint"] = h2d_col_IPoint

class h2d_col_OffsetKind(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.col.OffsetKind"
    _hx_constructs = ["Square", "Miter", "Round"]

    @staticmethod
    def Round(arc):
        return h2d_col_OffsetKind("Round", 2, (arc,))
h2d_col_OffsetKind.Square = h2d_col_OffsetKind("Square", 0, ())
h2d_col_OffsetKind.Miter = h2d_col_OffsetKind("Miter", 1, ())
h2d_col_OffsetKind._hx_class = h2d_col_OffsetKind
_hx_classes["h2d.col.OffsetKind"] = h2d_col_OffsetKind


class h2d_col__IPolygon_IPolygon_Impl_:
    _hx_class_name = "h2d.col._IPolygon.IPolygon_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_length", "get_points", "_new", "iterator", "toPolygon", "getBounds", "union", "intersection", "subtraction", "offset", "clipperOp", "convexHull", "isClockwise", "area", "side", "isConvex", "reverse", "contains", "optimize", "optimizeRec"]
    points = None
    length = None

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def get_points(this1):
        return this1

    @staticmethod
    def _new(points = None):
        this1 = ([] if ((points is None)) else points)
        return this1

    @staticmethod
    def iterator(this1):
        return hxd_impl_ArrayIterator_h2d_col_IPoint(this1)

    @staticmethod
    def toPolygon(this1,scale = None):
        if (scale is None):
            scale = 1.
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            p = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            scale1 = scale
            if (scale1 is None):
                scale1 = 1.
            x = h2d_col_Point((p.x * scale1),(p.y * scale1))
            _g.append(x)
        return _g

    @staticmethod
    def getBounds(this1,b = None):
        if (b is None):
            b = h2d_col_IBounds()
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (p.x < b.xMin):
                b.xMin = p.x
            if (p.x > b.xMax):
                b.xMax = p.x
            if (p.y < b.yMin):
                b.yMin = p.y
            if (p.y > b.yMax):
                b.yMax = p.y
        return b

    @staticmethod
    def union(this1,p,withHoles = None):
        if (withHoles is None):
            withHoles = True
        c = hxd_clipper_Clipper()
        if (not withHoles):
            c.resultKind = hxd_clipper_ResultKind.NoHoles
        c.addPolygon(this1,hxd_clipper_PolyType.Clip)
        c.addPolygon(p,hxd_clipper_PolyType.Clip)
        return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    @staticmethod
    def intersection(this1,p,withHoles = None):
        if (withHoles is None):
            withHoles = True
        return h2d_col__IPolygon_IPolygon_Impl_.clipperOp(this1,p,hxd_clipper_ClipType.Intersection,withHoles)

    @staticmethod
    def subtraction(this1,p,withHoles = None):
        if (withHoles is None):
            withHoles = True
        return h2d_col__IPolygon_IPolygon_Impl_.clipperOp(this1,p,hxd_clipper_ClipType.Difference,withHoles)

    @staticmethod
    def offset(this1,delta,kind,withHoles = None):
        if (withHoles is None):
            withHoles = True
        c = hxd_clipper_ClipperOffset()
        tmp = kind.index
        if (tmp == 0):
            c.addPolygon(this1,hxd_clipper_JoinType.Square,hxd_clipper_EndType.ClosedPol)
        elif (tmp == 1):
            c.addPolygon(this1,hxd_clipper_JoinType.Miter,hxd_clipper_EndType.ClosedPol)
        elif (tmp == 2):
            arc = kind.params[0]
            c.ArcTolerance = arc
            c.addPolygon(this1,hxd_clipper_JoinType.Round,hxd_clipper_EndType.ClosedPol)
        else:
            pass
        if (not withHoles):
            c.resultKind = hxd_clipper_ResultKind.NoHoles
        return c.execute(delta)

    @staticmethod
    def clipperOp(this1,p,op,withHoles):
        c = hxd_clipper_Clipper()
        if (not withHoles):
            c.resultKind = hxd_clipper_ResultKind.NoHoles
        c.addPolygon(this1,hxd_clipper_PolyType.Subject)
        c.addPolygon(p,hxd_clipper_PolyType.Clip)
        return c.execute(op,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    @staticmethod
    def convexHull(this1):
        _hx_len = len(this1)
        if (_hx_len < 3):
            raise haxe_Exception.thrown("convexHull() needs at least 3 points")
        first = 0
        firstX = python_internal_ArrayImpl._get(this1, first).x
        _g = 1
        _g1 = len(this1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            px = python_internal_ArrayImpl._get(this1, i).x
            if (px < firstX):
                first = i
                firstX = px
        hull = []
        curr = first
        next = 0
        while True:
            hull.append(python_internal_ArrayImpl._get(this1, curr))
            next = HxOverrides.mod(((curr + 1)), _hx_len)
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p1 = python_internal_ArrayImpl._get(this1, i)
                p2 = python_internal_ArrayImpl._get(this1, curr)
                t = python_internal_ArrayImpl._get(this1, next)
                if (((((p2.x - p1.x)) * ((t.y - p1.y))) - ((((p2.y - p1.y)) * ((t.x - p1.x))))) < 0):
                    next = i
            curr = next
            if (not ((curr != first))):
                break
        return hull

    @staticmethod
    def isClockwise(this1):
        sum = 0.
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            sum = (sum + ((((p2.x - p1.x)) * ((p2.y + p1.y)))))
            p1 = p2
        return (sum < 0)

    @staticmethod
    def area(this1):
        sum = 0.
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            sum = (sum + (((p1.x * p2.y) - ((p2.x * p1.y)))))
            p1 = p2
        return (((-sum if ((sum < 0)) else sum)) * 0.5)

    @staticmethod
    def side(this1,p1,p2,t):
        return ((((p2.x - p1.x)) * ((t.y - p1.y))) - ((((p2.y - p1.y)) * ((t.x - p1.x)))))

    @staticmethod
    def isConvex(this1):
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 2))
        p2 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        p3 = python_internal_ArrayImpl._get(this1, 0)
        s = (((((p2.x - p1.x)) * ((p3.y - p1.y))) - ((((p2.y - p1.y)) * ((p3.x - p1.x))))) > 0)
        _g = 1
        _g1 = len(this1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p1 = p2
            p2 = p3
            p3 = python_internal_ArrayImpl._get(this1, i)
            if ((((((p2.x - p1.x)) * ((p3.y - p1.y))) - ((((p2.y - p1.y)) * ((p3.x - p1.x))))) > 0) != s):
                return False
        return True

    @staticmethod
    def reverse(this1):
        this1.reverse()

    @staticmethod
    def contains(this1,p,isConvex = None):
        if (isConvex is None):
            isConvex = False
        if isConvex:
            p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
            _g = 0
            _g1 = this1
            while (_g < len(_g1)):
                p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (((((p2.x - p1.x)) * ((p.y - p1.y))) - ((((p2.y - p1.y)) * ((p.x - p1.x))))) < 0):
                    return False
                p1 = p2
            return True
        else:
            w = 0
            p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
            _g = 0
            _g1 = this1
            while (_g < len(_g1)):
                p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (p2.y <= p.y):
                    if ((p1.y > p.y) and ((((((p1.x - p2.x)) * ((p.y - p2.y))) - ((((p1.y - p2.y)) * ((p.x - p2.x))))) > 0))):
                        w = (w + 1)
                elif ((p1.y <= p.y) and ((((((p1.x - p2.x)) * ((p.y - p2.y))) - ((((p1.y - p2.y)) * ((p.x - p2.x))))) < 0))):
                    w = (w - 1)
                p1 = p2
            return (w != 0)

    @staticmethod
    def optimize(this1,epsilon):
        out = []
        h2d_col__IPolygon_IPolygon_Impl_.optimizeRec(this1,0,len(this1),out,epsilon)
        return out

    @staticmethod
    def optimizeRec(points,index,_hx_len,out,epsilon):
        dmax = 0.
        pfirst = (points[index] if index >= 0 and index < len(points) else None)
        plast = python_internal_ArrayImpl._get(points, (_hx_len - 1))
        _g = (index + 1)
        _g1 = (_hx_len - 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p0 = (points[i] if i >= 0 and i < len(points) else None)
            A = (p0.x - pfirst.x)
            B = (p0.y - pfirst.y)
            C = (plast.x - pfirst.x)
            D = (plast.y - pfirst.y)
            dot = ((A * C) + ((B * D)))
            dist = ((C * C) + ((D * D)))
            param = -1.
            if (dist != 0):
                param = (dot / dist)
            xx = None
            yy = None
            if (param < 0):
                xx = pfirst.x
                yy = pfirst.y
            elif (param > 1):
                xx = plast.x
                yy = plast.y
            else:
                xx = (pfirst.x + ((param * C)))
                yy = (pfirst.y + ((param * D)))
            dx = (p0.x - xx)
            dy = (p0.y - yy)
            d = ((dx * dx) + ((dy * dy)))
            if (d > dmax):
                index = i
                dmax = d
        if (dmax >= epsilon):
            h2d_col__IPolygon_IPolygon_Impl_.optimizeRec(points,0,index,out,epsilon)
            if (len(out) != 0):
                out.pop()
            h2d_col__IPolygon_IPolygon_Impl_.optimizeRec(points,index,_hx_len,out,epsilon)
        else:
            out.append((points[index] if index >= 0 and index < len(points) else None))
            out.append(python_internal_ArrayImpl._get(points, (_hx_len - 1)))
h2d_col__IPolygon_IPolygon_Impl_._hx_class = h2d_col__IPolygon_IPolygon_Impl_
_hx_classes["h2d.col._IPolygon.IPolygon_Impl_"] = h2d_col__IPolygon_IPolygon_Impl_


class h2d_col__IPolygons_IPolygons_Impl_:
    _hx_class_name = "h2d.col._IPolygons.IPolygons_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_length", "get_polygons", "_new", "iterator", "toPolygons", "getBounds", "union", "intersection", "subtraction", "offset", "clipperOp", "contains", "optimize"]
    polygons = None
    length = None

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def get_polygons(this1):
        return this1

    @staticmethod
    def _new(polygons = None):
        this1 = ([] if ((polygons is None)) else polygons)
        return this1

    @staticmethod
    def iterator(this1):
        return hxd_impl_ArrayIterator_h2d_col_IPolygon(this1)

    @staticmethod
    def toPolygons(this1,scale = None):
        if (scale is None):
            scale = 1.
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            p = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = h2d_col__IPolygon_IPolygon_Impl_.toPolygon(p,scale)
            _g.append(x)
        return _g

    @staticmethod
    def getBounds(this1,b = None):
        if (b is None):
            b = h2d_col_IBounds()
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            h2d_col__IPolygon_IPolygon_Impl_.getBounds(p,b)
        return b

    @staticmethod
    def union(this1,p = None,withHoles = None):
        if (withHoles is None):
            withHoles = True
        c = hxd_clipper_Clipper()
        if (not withHoles):
            c.resultKind = hxd_clipper_ResultKind.NoHoles
        c.addPolygons(this1,hxd_clipper_PolyType.Clip)
        if (p is not None):
            c.addPolygons(p,hxd_clipper_PolyType.Clip)
        return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    @staticmethod
    def intersection(this1,p,withHoles = None):
        if (withHoles is None):
            withHoles = True
        return h2d_col__IPolygons_IPolygons_Impl_.clipperOp(this1,p,hxd_clipper_ClipType.Intersection,withHoles)

    @staticmethod
    def subtraction(this1,p,withHoles = None):
        if (withHoles is None):
            withHoles = True
        return h2d_col__IPolygons_IPolygons_Impl_.clipperOp(this1,p,hxd_clipper_ClipType.Difference,withHoles)

    @staticmethod
    def offset(this1,delta,kind,withHoles = None):
        if (withHoles is None):
            withHoles = True
        if (len(this1) == 0):
            polygons = None
            this2 = ([] if ((polygons is None)) else polygons)
            return this2
        c = hxd_clipper_ClipperOffset()
        tmp = kind.index
        if (tmp == 0):
            c.addPolygons(this1,hxd_clipper_JoinType.Square,hxd_clipper_EndType.ClosedPol)
        elif (tmp == 1):
            c.addPolygons(this1,hxd_clipper_JoinType.Miter,hxd_clipper_EndType.ClosedPol)
        elif (tmp == 2):
            arc = kind.params[0]
            c.ArcTolerance = arc
            c.addPolygons(this1,hxd_clipper_JoinType.Round,hxd_clipper_EndType.ClosedPol)
        else:
            pass
        if (not withHoles):
            c.resultKind = hxd_clipper_ResultKind.NoHoles
        return c.execute(delta)

    @staticmethod
    def clipperOp(this1,p,op,withHoles):
        c = hxd_clipper_Clipper()
        if (not withHoles):
            c.resultKind = hxd_clipper_ResultKind.NoHoles
        c.addPolygons(this1,hxd_clipper_PolyType.Subject)
        c.addPolygons(p,hxd_clipper_PolyType.Clip)
        return c.execute(op,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    @staticmethod
    def contains(this1,p,isConvex = None):
        if (isConvex is None):
            isConvex = False
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            pl = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if h2d_col__IPolygon_IPolygon_Impl_.contains(pl,p,isConvex):
                return True
        return False

    @staticmethod
    def optimize(this1,epsilon):
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            p = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = h2d_col__IPolygon_IPolygon_Impl_.optimize(p,epsilon)
            _g.append(x)
        return _g
h2d_col__IPolygons_IPolygons_Impl_._hx_class = h2d_col__IPolygons_IPolygons_Impl_
_hx_classes["h2d.col._IPolygons.IPolygons_Impl_"] = h2d_col__IPolygons_IPolygons_Impl_


class h2d_col_Matrix:
    _hx_class_name = "h2d.col.Matrix"
    _hx_is_interface = "False"
    __slots__ = ("a", "b", "c", "d", "x", "y")
    _hx_fields = ["a", "b", "c", "d", "x", "y"]
    _hx_methods = ["identity", "initTranslate", "initScale", "initRotate", "initSkew", "invert", "getDeterminant", "inverse", "transform", "translate", "translateX", "translateY", "prependTranslate", "prependTranslateX", "prependTranslateY", "multiply", "getScale", "scale", "scaleX", "scaleY", "rotate", "skew", "skewX", "skewY", "clone", "getPosition", "toString"]
    _hx_statics = ["tmp"]

    def __init__(self):
        self.a = 1
        self.b = 0
        self.c = 0
        self.d = 1
        self.x = 0
        self.y = 0

    def identity(self):
        self.a = 1
        self.b = 0
        self.c = 0
        self.d = 1
        self.x = 0
        self.y = 0

    def initTranslate(self,x,y):
        self.a = 1
        self.b = 0
        self.c = 0
        self.d = 1
        self.x = x
        self.y = y

    def initScale(self,sx,sy):
        self.a = sx
        self.b = 0
        self.c = 0
        self.d = sy
        self.x = 0
        self.y = 0

    def initRotate(self,angle):
        cos = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sin = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        self.a = cos
        self.b = sin
        self.c = -sin
        self.d = cos
        self.x = 0
        self.y = 0

    def initSkew(self,sx,sy):
        tanX = Math.tan(sx)
        tanY = Math.tan(sy)
        self.a = 1
        self.b = tanY
        self.c = tanX
        self.d = 1
        self.x = 0
        self.y = 0

    def invert(self):
        self.inverse(self)

    def getDeterminant(self):
        return ((self.a * self.d) - ((self.b * self.c)))

    def inverse(self,m):
        a = m.a
        b = m.b
        c = m.c
        d = m.d
        x = m.x
        y = m.y
        invDet = (1 / (((self.a * self.d) - ((self.b * self.c)))))
        self.a = (d * invDet)
        self.b = (-b * invDet)
        self.c = (-c * invDet)
        self.d = (a * invDet)
        self.x = ((((-x * d) + ((c * y)))) * invDet)
        self.y = ((((x * b) - ((a * y)))) * invDet)

    def transform(self,pt):
        return h2d_col_Point((((pt.x * self.a) + ((pt.y * self.c))) + self.x),(((pt.x * self.b) + ((pt.y * self.d))) + self.y))

    def translate(self,x,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + x)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + y)
        _hx_local_2.y

    def translateX(self,x):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + x)
        _hx_local_0.x

    def translateY(self,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.y
        _hx_local_0.y = (_hx_local_1 + y)
        _hx_local_0.y

    def prependTranslate(self,x,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + (((self.a * x) + ((self.c * y)))))
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + (((self.b * x) + ((self.d * y)))))
        _hx_local_2.y

    def prependTranslateX(self,x):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + ((self.a * x)))
        _hx_local_0.x

    def prependTranslateY(self,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.y
        _hx_local_0.y = (_hx_local_1 + ((self.d * y)))
        _hx_local_0.y

    def multiply(self,a,b):
        aa = a.a
        ab = a.b
        ac = a.c
        ad = a.d
        ax = a.x
        ay = a.y
        ba = b.a
        bb = b.b
        bc = b.c
        bd = b.d
        bx = b.x
        by = b.y
        self.a = ((aa * ba) + ((ab * bc)))
        self.b = ((aa * bb) + ((ab * bd)))
        self.c = ((ac * ba) + ((ad * bc)))
        self.d = ((ac * bb) + ((ad * bd)))
        self.x = (((ax * ba) + ((ay * bc))) + bx)
        self.y = (((ax * bb) + ((ay * bd))) + by)

    def getScale(self,p = None):
        if (p is None):
            p = h2d_col_Point()
        f = ((self.a * self.a) + ((self.b * self.b)))
        p.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = ((self.c * self.c) + ((self.d * self.d)))
        p.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if (((self.a * self.d) - ((self.b * self.c))) < 0):
            p.x = (p.x * -1)
            p.y = (p.y * -1)
        return p

    def scale(self,sx,sy):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.a
        _hx_local_0.a = (_hx_local_1 * sx)
        _hx_local_0.a
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.c
        _hx_local_2.c = (_hx_local_3 * sx)
        _hx_local_2.c
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.x
        _hx_local_4.x = (_hx_local_5 * sx)
        _hx_local_4.x
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.b
        _hx_local_6.b = (_hx_local_7 * sy)
        _hx_local_6.b
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.d
        _hx_local_8.d = (_hx_local_9 * sy)
        _hx_local_8.d
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.y
        _hx_local_10.y = (_hx_local_11 * sy)
        _hx_local_10.y

    def scaleX(self,sx):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.a
        _hx_local_0.a = (_hx_local_1 * sx)
        _hx_local_0.a
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.c
        _hx_local_2.c = (_hx_local_3 * sx)
        _hx_local_2.c
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.x
        _hx_local_4.x = (_hx_local_5 * sx)
        _hx_local_4.x

    def scaleY(self,sy):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.b
        _hx_local_0.b = (_hx_local_1 * sy)
        _hx_local_0.b
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.d
        _hx_local_2.d = (_hx_local_3 * sy)
        _hx_local_2.d
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.y
        _hx_local_4.y = (_hx_local_5 * sy)
        _hx_local_4.y

    def rotate(self,angle):
        _this = h2d_col_Matrix.tmp
        cos = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sin = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        _this.a = cos
        _this.b = sin
        _this.c = -sin
        _this.d = cos
        _this.x = 0
        _this.y = 0
        self.multiply(self,h2d_col_Matrix.tmp)

    def skew(self,sx,sy):
        aa = self.a
        ab = self.b
        ac = self.c
        ad = self.d
        ax = self.x
        ay = self.y
        bb = Math.tan(sy)
        bc = Math.tan(sx)
        self.a = (aa + ((ab * bc)))
        self.b = ((aa * bb) + ab)
        self.c = (ac + ((ad * bc)))
        self.d = ((ac * bb) + ad)
        self.x = (ax + ((ay * bc)))
        self.y = ((ax * bb) + ay)

    def skewX(self,sx):
        bc = Math.tan(sx)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.a
        _hx_local_0.a = (_hx_local_1 + ((self.b * bc)))
        _hx_local_0.a
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.c
        _hx_local_2.c = (_hx_local_3 + ((self.d * bc)))
        _hx_local_2.c
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.x
        _hx_local_4.x = (_hx_local_5 + ((self.y * bc)))
        _hx_local_4.x

    def skewY(self,sy):
        bb = Math.tan(sy)
        self.b = ((self.a * bb) + self.b)
        self.d = ((self.c * bb) + self.d)
        self.y = ((self.x * bb) + self.y)

    def clone(self):
        m = h2d_col_Matrix()
        m.a = self.a
        m.b = self.b
        m.c = self.c
        m.d = self.d
        m.x = self.x
        m.y = self.y
        return m

    def getPosition(self,p = None):
        if (p is None):
            p = h2d_col_Point()
        x = self.x
        y = self.y
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p.x = x
        p.y = y
        return p

    def toString(self):
        return (((((((((((((((("MAT=[\n" + "  [ ") + Std.string(hxd_Math.fmt(self.a))) + ", ") + Std.string(hxd_Math.fmt(self.b))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self.c))) + ", ") + Std.string(hxd_Math.fmt(self.d))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self.x))) + ", ") + Std.string(hxd_Math.fmt(self.y))) + " ]\n") + "]")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a = None
        _hx_o.b = None
        _hx_o.c = None
        _hx_o.d = None
        _hx_o.x = None
        _hx_o.y = None
h2d_col_Matrix._hx_class = h2d_col_Matrix
_hx_classes["h2d.col.Matrix"] = h2d_col_Matrix


class h2d_col_Point:
    _hx_class_name = "h2d.col.Point"
    _hx_is_interface = "False"
    __slots__ = ("x", "y")
    _hx_fields = ["x", "y"]
    _hx_methods = ["distanceSq", "distance", "toString", "sub", "add", "multiply", "equals", "dot", "lengthSq", "length", "normalize", "normalized", "set", "load", "scale", "clone", "cross", "lerp", "transform", "transformed", "transform2x2", "transformed2x2", "toIPoint", "rotate"]

    def __init__(self,x = None,y = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        self.x = x
        self.y = y

    def distanceSq(self,p):
        dx = (self.x - p.x)
        dy = (self.y - p.y)
        return ((dx * dx) + ((dy * dy)))

    def distance(self,p):
        dx = (self.x - p.x)
        dy = (self.y - p.y)
        f = ((dx * dx) + ((dy * dy)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def toString(self):
        return (((("{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + "}")

    def sub(self,p):
        return h2d_col_Point((self.x - p.x),(self.y - p.y))

    def add(self,p):
        return h2d_col_Point((self.x + p.x),(self.y + p.y))

    def multiply(self,v):
        return h2d_col_Point((self.x * v),(self.y * v))

    def equals(self,other):
        if (self.x == other.x):
            return (self.y == other.y)
        else:
            return False

    def dot(self,p):
        return ((self.x * p.x) + ((self.y * p.y)))

    def lengthSq(self):
        return ((self.x * self.x) + ((self.y * self.y)))

    def length(self):
        f = ((self.x * self.x) + ((self.y * self.y)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def normalize(self):
        k = ((self.x * self.x) + ((self.y * self.y)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y

    def normalized(self):
        k = ((self.x * self.x) + ((self.y * self.y)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        return h2d_col_Point((self.x * k),(self.y * k))

    def set(self,x = None,y = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        self.x = x
        self.y = y

    def load(self,p):
        self.x = p.x
        self.y = p.y

    def scale(self,f):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * f)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * f)
        _hx_local_2.y

    def clone(self):
        return h2d_col_Point(self.x,self.y)

    def cross(self,p):
        return ((self.x * p.y) - ((self.y * p.x)))

    def lerp(self,a,b,k):
        a1 = a.x
        self.x = (a1 + ((k * ((b.x - a1)))))
        a1 = a.y
        self.y = (a1 + ((k * ((a.y - a1)))))

    def transform(self,m):
        mx = (((m.a * self.x) + ((m.c * self.y))) + m.x)
        my = (((m.b * self.x) + ((m.d * self.y))) + m.y)
        self.x = mx
        self.y = my

    def transformed(self,m):
        mx = (((m.a * self.x) + ((m.c * self.y))) + m.x)
        my = (((m.b * self.x) + ((m.d * self.y))) + m.y)
        return h2d_col_Point(mx,my)

    def transform2x2(self,m):
        mx = ((m.a * self.x) + ((m.c * self.y)))
        my = ((m.b * self.x) + ((m.d * self.y)))
        self.x = mx
        self.y = my

    def transformed2x2(self,m):
        mx = ((m.a * self.x) + ((m.c * self.y)))
        my = ((m.b * self.x) + ((m.d * self.y)))
        return h2d_col_Point(mx,my)

    def toIPoint(self,scale = None):
        if (scale is None):
            scale = 1.
        return h2d_col_IPoint(Math.floor(((self.x * scale) + 0.5)),Math.floor(((self.y * scale) + 0.5)))

    def rotate(self,angle):
        c = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        s = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        x2 = ((self.x * c) - ((self.y * s)))
        y2 = ((self.x * s) + ((self.y * c)))
        self.x = x2
        self.y = y2

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
h2d_col_Point._hx_class = h2d_col_Point
_hx_classes["h2d.col.Point"] = h2d_col_Point


class h2d_col__Polygon_Polygon_Impl_:
    _hx_class_name = "h2d.col._Polygon.Polygon_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_length", "get_points", "_new", "iterator", "fastTriangulate", "toSegments", "toIPolygon", "getBounds", "getCollider", "xSort", "convexHull", "isClockwise", "area", "centroid", "side", "isConvex", "reverse", "transform", "contains", "findClosestPoint", "projectPoint", "distance", "distanceSq", "rayIntersection", "orientation", "onSegment", "intersect", "selfIntersecting", "optimize", "optimizeRec", "makeCircle"]
    points = None
    length = None

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def get_points(this1):
        return this1

    @staticmethod
    def _new(points = None):
        this1 = ([] if ((points is None)) else points)
        return this1

    @staticmethod
    def iterator(this1):
        return hxd_impl_ArrayIterator_h2d_col_Point(this1)

    @staticmethod
    def fastTriangulate(this1):
        return hxd_earcut_Earcut().triangulate_h2d_col_Point(this1)

    @staticmethod
    def toSegments(this1):
        segments = []
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            s = h2d_col_Segment(p1,p2)
            segments.append(s)
            p1 = p2
        return segments

    @staticmethod
    def toIPolygon(this1,scale = None):
        if (scale is None):
            scale = 1.
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            p = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            scale1 = scale
            if (scale1 is None):
                scale1 = 1.
            x = h2d_col_IPoint(Math.floor(((p.x * scale1) + 0.5)),Math.floor(((p.y * scale1) + 0.5)))
            _g.append(x)
        return _g

    @staticmethod
    def getBounds(this1,b = None):
        if (b is None):
            b = h2d_col_Bounds()
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (p.x < b.xMin):
                b.xMin = p.x
            if (p.x > b.xMax):
                b.xMax = p.x
            if (p.y < b.yMin):
                b.yMin = p.y
            if (p.y > b.yMax):
                b.yMax = p.y
        return b

    @staticmethod
    def getCollider(this1,isConvex = None):
        if (isConvex is None):
            isConvex = False
        return h2d_col_PolygonCollider([this1],isConvex)

    @staticmethod
    def xSort(this1,a,b):
        if (a.x == b.x):
            if (a.y < b.y):
                return -1
            else:
                return 1
        if (a.x < b.x):
            return -1
        else:
            return 1

    @staticmethod
    def convexHull(this1):
        _hx_len = len(this1)
        if (len(this1) < 3):
            return this1
        def _hx_local_0(a,b):
            if (a.x == b.x):
                if (a.y < b.y):
                    return -1
                else:
                    return 1
            elif (a.x < b.x):
                return -1
            else:
                return 1
        this1.sort(key= python_lib_Functools.cmp_to_key(_hx_local_0))
        hull = []
        k = 0
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            while True:
                tmp = None
                if (k >= 2):
                    p1 = python_internal_ArrayImpl._get(hull, (k - 2))
                    p2 = python_internal_ArrayImpl._get(hull, (k - 1))
                    tmp = (((((p2.x - p1.x)) * ((p.y - p1.y))) - ((((p2.y - p1.y)) * ((p.x - p1.x))))) <= 0)
                else:
                    tmp = False
                if (not tmp):
                    break
                k = (k - 1)
            tmp1 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(hull, tmp1, p)
        i = (len(this1) - 2)
        _hx_len = (k + 1)
        while (i >= 0):
            p = python_internal_ArrayImpl._get(this1, i)
            while True:
                tmp = None
                if (k >= _hx_len):
                    p1 = python_internal_ArrayImpl._get(hull, (k - 2))
                    p2 = python_internal_ArrayImpl._get(hull, (k - 1))
                    tmp = (((((p2.x - p1.x)) * ((p.y - p1.y))) - ((((p2.y - p1.y)) * ((p.x - p1.x))))) <= 0)
                else:
                    tmp = False
                if (not tmp):
                    break
                k = (k - 1)
            tmp1 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(hull, tmp1, p)
            i = (i - 1)
        while (len(hull) >= k):
            if (len(hull) != 0):
                hull.pop()
        return hull

    @staticmethod
    def isClockwise(this1):
        sum = 0.
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            sum = (sum + ((((p2.x - p1.x)) * ((p2.y + p1.y)))))
            p1 = p2
        return (sum < 0)

    @staticmethod
    def area(this1):
        sum = 0.
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            sum = (sum + (((p2.x * p1.y) - ((p1.x * p2.y)))))
            p1 = p2
        return (((-sum if ((sum < 0)) else sum)) * 0.5)

    @staticmethod
    def centroid(this1):
        A = 0.
        cx = 0.
        cy = 0.
        p0 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            a = ((p0.x * p.y) - ((p.x * p0.y)))
            cx = (cx + ((((p0.x + p.x)) * a)))
            cy = (cy + ((((p0.y + p.y)) * a)))
            A = (A + a)
            p0 = p
        A = (A * 0.5)
        cx = (cx * ((1 / ((6 * A)))))
        cy = (cy * ((1 / ((6 * A)))))
        return h2d_col_Point(cx,cy)

    @staticmethod
    def side(this1,p1,p2,t):
        return ((((p2.x - p1.x)) * ((t.y - p1.y))) - ((((p2.y - p1.y)) * ((t.x - p1.x)))))

    @staticmethod
    def isConvex(this1):
        if (len(this1) < 4):
            return True
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 2))
        p2 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        p3 = python_internal_ArrayImpl._get(this1, 0)
        s = (((((p2.x - p1.x)) * ((p3.y - p1.y))) - ((((p2.y - p1.y)) * ((p3.x - p1.x))))) > 0)
        _g = 1
        _g1 = len(this1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p1 = p2
            p2 = p3
            p3 = python_internal_ArrayImpl._get(this1, i)
            if ((((((p2.x - p1.x)) * ((p3.y - p1.y))) - ((((p2.y - p1.y)) * ((p3.x - p1.x))))) > 0) != s):
                return False
        return True

    @staticmethod
    def reverse(this1):
        this1.reverse()

    @staticmethod
    def transform(this1,mat):
        _g = 0
        _g1 = len(this1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pt = python_internal_ArrayImpl._get(this1, i)
            python_internal_ArrayImpl._set(this1, i, h2d_col_Point((((pt.x * mat.a) + ((pt.y * mat.c))) + mat.x),(((pt.x * mat.b) + ((pt.y * mat.d))) + mat.y)))

    @staticmethod
    def contains(this1,p,isConvex = None):
        if (isConvex is None):
            isConvex = False
        if isConvex:
            p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
            _g = 0
            _g1 = this1
            while (_g < len(_g1)):
                p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (((((p2.x - p1.x)) * ((p.y - p1.y))) - ((((p2.y - p1.y)) * ((p.x - p1.x))))) < 0):
                    return False
                p1 = p2
            return True
        else:
            w = 0
            p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
            _g = 0
            _g1 = this1
            while (_g < len(_g1)):
                p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (p2.y <= p.y):
                    if ((p1.y > p.y) and ((((((p1.x - p2.x)) * ((p.y - p2.y))) - ((((p1.y - p2.y)) * ((p.x - p2.x))))) > 0))):
                        w = (w + 1)
                elif ((p1.y <= p.y) and ((((((p1.x - p2.x)) * ((p.y - p2.y))) - ((((p1.y - p2.y)) * ((p.x - p2.x))))) < 0))):
                    w = (w - 1)
                p1 = p2
            return (w != 0)

    @staticmethod
    def findClosestPoint(this1,pt,maxDist):
        closest = None
        minDist = (maxDist * maxDist)
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            cp = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            dx = (cp.x - pt.x)
            dy = (cp.y - pt.y)
            sqDist = ((dx * dx) + ((dy * dy)))
            if (sqDist < minDist):
                closest = cp
                minDist = sqDist
        return closest

    @staticmethod
    def projectPoint(this1,pt):
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        closestProj = None
        minDistSq = 1e10
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p11 = p1
            p21 = p2
            _this_x = p11.x
            _this_y = p11.y
            _this_dx = (p21.x - _this_x)
            _this_dy = (p21.y - _this_y)
            _this_lenSq = ((_this_dx * _this_dx) + ((_this_dy * _this_dy)))
            _this_invLenSq = (1 / _this_lenSq)
            px = (pt.x - _this_x)
            py = (pt.y - _this_y)
            t = ((px * _this_dx) + ((py * _this_dy)))
            proj = None
            if (t < 0):
                proj = h2d_col_Point(_this_x,_this_y)
            elif (t > _this_lenSq):
                proj = h2d_col_Point((_this_x + _this_dx),(_this_y + _this_dy))
            else:
                tl2 = (t * _this_invLenSq)
                proj = h2d_col_Point((_this_x + ((tl2 * _this_dx))),(_this_y + ((tl2 * _this_dy))))
            dx = (proj.x - pt.x)
            dy = (proj.y - pt.y)
            distSq = ((dx * dx) + ((dy * dy)))
            if (distSq < minDistSq):
                closestProj = proj
                minDistSq = distSq
            p1 = p2
        return closestProj

    @staticmethod
    def distance(this1,pt,outside = None):
        f = h2d_col__Polygon_Polygon_Impl_.distanceSq(this1,pt,outside)
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    @staticmethod
    def distanceSq(this1,pt,outside = None):
        p1 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        minDistSq = 1e10
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p11 = p1
            p21 = p2
            s_x = p11.x
            s_y = p11.y
            s_dx = (p21.x - s_x)
            s_dy = (p21.y - s_y)
            s_lenSq = ((s_dx * s_dx) + ((s_dy * s_dy)))
            s_invLenSq = (1 / s_lenSq)
            if ((outside is None) or (((((s_dx * ((pt.y - s_y))) - ((s_dy * ((pt.x - s_x))))) < 0) == outside))):
                px = (pt.x - s_x)
                py = (pt.y - s_y)
                t = ((px * s_dx) + ((py * s_dy)))
                dist = None
                if (t < 0):
                    dist = ((px * px) + ((py * py)))
                elif (t > s_lenSq):
                    kx = (pt.x - ((s_x + s_dx)))
                    ky = (pt.y - ((s_y + s_dy)))
                    dist = ((kx * kx) + ((ky * ky)))
                else:
                    tl2 = (t * s_invLenSq)
                    pdx = ((s_x + ((tl2 * s_dx))) - pt.x)
                    pdy = ((s_y + ((tl2 * s_dy))) - pt.y)
                    dist = ((pdx * pdx) + ((pdy * pdy)))
                if (dist < minDistSq):
                    minDistSq = dist
            p1 = p2
        if (minDistSq == 1e10):
            return 0.
        else:
            return minDistSq

    @staticmethod
    def rayIntersection(this1,r,bestMatch):
        dmin = -1.
        p0 = python_internal_ArrayImpl._get(this1, (len(this1) - 1))
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((((r.lx * ((p0.y - r.py))) - ((r.ly * ((p0.x - r.px)))))) * (((r.lx * ((p.y - r.py))) - ((r.ly * ((p.x - r.px))))))) > 0):
                p0 = p
                continue
            u = ((((r.lx * ((p0.y - r.py))) - ((r.ly * ((p0.x - r.px)))))) / (((r.ly * ((p.x - p0.x))) - ((r.lx * ((p.y - p0.y)))))))
            x = (p0.x + ((u * ((p.x - p0.x)))))
            y = (p0.y + ((u * ((p.y - p0.y)))))
            dx = (x - r.px)
            dy = (y - r.py)
            d = ((dx * dx) + ((dy * dy)))
            if ((d < dmin) or ((dmin < 0))):
                if (not bestMatch):
                    if (d < 0):
                        return Math.NaN
                    else:
                        return python_lib_Math.sqrt(d)
                dmin = d
            p0 = p
        if (dmin < 0):
            return dmin
        elif (dmin < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(dmin)

    @staticmethod
    def orientation(this1,p,q,r):
        v = ((((q.x - p.x)) * ((r.y - p.y))) - ((((q.y - p.y)) * ((r.x - p.x)))))
        if (v == 0):
            return 0
        if (v > 0):
            return 1
        else:
            return -1

    @staticmethod
    def onSegment(this1,p,q,r):
        a = p.x
        b = q.x
        if (r.x > ((b if ((a < b)) else a))):
            return False
        a = p.x
        b = q.x
        if (r.x < ((b if ((a > b)) else a))):
            return False
        a = p.y
        b = q.y
        if (r.y > ((b if ((a < b)) else a))):
            return False
        a = p.y
        b = q.y
        if (r.y < ((b if ((a > b)) else a))):
            return False
        return True

    @staticmethod
    def intersect(this1,p1,q1,p2,q2):
        v = ((((q1.x - p1.x)) * ((p2.y - p1.y))) - ((((q1.y - p1.y)) * ((p2.x - p1.x)))))
        s1 = (0 if ((v == 0)) else (1 if ((v > 0)) else -1))
        v = ((((q1.x - p1.x)) * ((q2.y - p1.y))) - ((((q1.y - p1.y)) * ((q2.x - p1.x)))))
        s2 = (0 if ((v == 0)) else (1 if ((v > 0)) else -1))
        v = ((((q2.x - p2.x)) * ((p1.y - p2.y))) - ((((q2.y - p2.y)) * ((p1.x - p2.x)))))
        s3 = (0 if ((v == 0)) else (1 if ((v > 0)) else -1))
        v = ((((q2.x - p2.x)) * ((q1.y - p2.y))) - ((((q2.y - p2.y)) * ((q1.x - p2.x)))))
        s4 = (0 if ((v == 0)) else (1 if ((v > 0)) else -1))
        if ((s1 != s2) and ((s3 != s4))):
            return True
        tmp = None
        tmp1 = None
        tmp2 = None
        tmp3 = None
        if (s1 == 0):
            a = p1.x
            b = q1.x
            if (p2.x > ((b if ((a < b)) else a))):
                tmp3 = False
            else:
                a = p1.x
                b = q1.x
                if (p2.x < ((b if ((a > b)) else a))):
                    tmp3 = False
                else:
                    a = p1.y
                    b = q1.y
                    if (p2.y > ((b if ((a < b)) else a))):
                        tmp3 = False
                    else:
                        a = p1.y
                        b = q1.y
                        tmp3 = (False if ((p2.y < ((b if ((a > b)) else a)))) else True)
        else:
            tmp3 = False
        if (not tmp3):
            if (s2 == 0):
                a = p1.x
                b = q1.x
                if (q2.x > ((b if ((a < b)) else a))):
                    tmp2 = False
                else:
                    a = p1.x
                    b = q1.x
                    if (q2.x < ((b if ((a > b)) else a))):
                        tmp2 = False
                    else:
                        a = p1.y
                        b = q1.y
                        if (q2.y > ((b if ((a < b)) else a))):
                            tmp2 = False
                        else:
                            a = p1.y
                            b = q1.y
                            tmp2 = (False if ((q2.y < ((b if ((a > b)) else a)))) else True)
            else:
                tmp2 = False
        else:
            tmp2 = True
        if (not tmp2):
            if (s3 == 0):
                a = p2.x
                b = q2.x
                if (p1.x > ((b if ((a < b)) else a))):
                    tmp1 = False
                else:
                    a = p2.x
                    b = q2.x
                    if (p1.x < ((b if ((a > b)) else a))):
                        tmp1 = False
                    else:
                        a = p2.y
                        b = q2.y
                        if (p1.y > ((b if ((a < b)) else a))):
                            tmp1 = False
                        else:
                            a = p2.y
                            b = q2.y
                            tmp1 = (False if ((p1.y < ((b if ((a > b)) else a)))) else True)
            else:
                tmp1 = False
        else:
            tmp1 = True
        if (not tmp1):
            if (s4 == 0):
                a = p2.x
                b = q2.x
                if (q1.x > ((b if ((a < b)) else a))):
                    tmp = False
                else:
                    a = p2.x
                    b = q2.x
                    if (q1.x < ((b if ((a > b)) else a))):
                        tmp = False
                    else:
                        a = p2.y
                        b = q2.y
                        if (q1.y > ((b if ((a < b)) else a))):
                            tmp = False
                        else:
                            a = p2.y
                            b = q2.y
                            tmp = (False if ((q1.y < ((b if ((a > b)) else a)))) else True)
            else:
                tmp = False
        else:
            tmp = True
        if tmp:
            return True
        return False

    @staticmethod
    def selfIntersecting(this1):
        if (len(this1) < 4):
            return False
        _g = 0
        _g1 = (len(this1) - 2)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p1 = python_internal_ArrayImpl._get(this1, i)
            q1 = python_internal_ArrayImpl._get(this1, (i + 1))
            _g2 = (i + 2)
            _g3 = len(this1)
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                p2 = python_internal_ArrayImpl._get(this1, j)
                q2 = python_internal_ArrayImpl._get(this1, HxOverrides.mod(((j + 1)), len(this1)))
                if ((q2 != p1) and h2d_col__Polygon_Polygon_Impl_.intersect(this1,p1,q1,p2,q2)):
                    return True
        return False

    @staticmethod
    def optimize(this1,epsilon):
        out = []
        h2d_col__Polygon_Polygon_Impl_.optimizeRec(this1,0,(len(this1) - 1),out,epsilon)
        return out

    @staticmethod
    def optimizeRec(points,start,end,out,epsilon):
        dmax = 0.
        pfirst = (points[start] if start >= 0 and start < len(points) else None)
        plast = (points[end] if end >= 0 and end < len(points) else None)
        index = 0
        _g = (start + 1)
        _g1 = end
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p0 = (points[i] if i >= 0 and i < len(points) else None)
            A = (p0.x - pfirst.x)
            B = (p0.y - pfirst.y)
            C = (plast.x - pfirst.x)
            D = (plast.y - pfirst.y)
            dot = ((A * C) + ((B * D)))
            dist = ((C * C) + ((D * D)))
            param = -1.
            if (dist != 0):
                param = (dot / dist)
            xx = None
            yy = None
            if (param < 0):
                xx = pfirst.x
                yy = pfirst.y
            elif (param > 1):
                xx = plast.x
                yy = plast.y
            else:
                xx = (pfirst.x + ((param * C)))
                yy = (pfirst.y + ((param * D)))
            dx = (p0.x - xx)
            dy = (p0.y - yy)
            d = ((dx * dx) + ((dy * dy)))
            if (d > dmax):
                index = i
                dmax = d
        if (dmax >= ((epsilon * epsilon))):
            h2d_col__Polygon_Polygon_Impl_.optimizeRec(points,start,index,out,epsilon)
            if (len(out) != 0):
                out.pop()
            h2d_col__Polygon_Polygon_Impl_.optimizeRec(points,index,end,out,epsilon)
        else:
            out.append((points[start] if start >= 0 and start < len(points) else None))
            out.append((points[end] if end >= 0 and end < len(points) else None))

    @staticmethod
    def makeCircle(x,y,radius,npoints = None):
        if (npoints is None):
            npoints = 0
        if (npoints == 0):
            f = (((radius * 3.14) * 2) / 4)
            npoints = Math.ceil((-f if ((f < 0)) else f))
        if (npoints < 3):
            npoints = 3
        angle = (6.28318530717958623 / npoints)
        points = []
        _g = 0
        _g1 = npoints
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            a = (i * angle)
            x1 = h2d_col_Point(((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))) * radius) + x),((((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))) * radius) + y))
            points.append(x1)
        this1 = ([] if ((points is None)) else points)
        return this1
h2d_col__Polygon_Polygon_Impl_._hx_class = h2d_col__Polygon_Polygon_Impl_
_hx_classes["h2d.col._Polygon.Polygon_Impl_"] = h2d_col__Polygon_Polygon_Impl_


class h2d_col_PolygonCollider:
    _hx_class_name = "h2d.col.PolygonCollider"
    _hx_is_interface = "False"
    __slots__ = ("polygons", "isConvex")
    _hx_fields = ["polygons", "isConvex"]
    _hx_methods = ["contains"]
    _hx_interfaces = [h2d_col_Collider]

    def __init__(self,polygons,isConvex = None):
        if (isConvex is None):
            isConvex = False
        self.polygons = polygons
        self.isConvex = isConvex

    def contains(self,p):
        if (self.polygons is None):
            return False
        return h2d_col__Polygons_Polygons_Impl_.contains(self.polygons,p,self.isConvex)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.polygons = None
        _hx_o.isConvex = None
h2d_col_PolygonCollider._hx_class = h2d_col_PolygonCollider
_hx_classes["h2d.col.PolygonCollider"] = h2d_col_PolygonCollider


class h2d_col__Polygons_Polygons_Impl_:
    _hx_class_name = "h2d.col._Polygons.Polygons_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_length", "get_polygons", "_new", "iterator", "toIPolygons", "getBounds", "getCollider", "contains", "optimize"]
    polygons = None
    length = None

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def get_polygons(this1):
        return this1

    @staticmethod
    def _new(polygons = None):
        this1 = ([] if ((polygons is None)) else polygons)
        return this1

    @staticmethod
    def iterator(this1):
        return hxd_impl_ArrayIterator_h2d_col_Polygon(this1)

    @staticmethod
    def toIPolygons(this1,scale = None):
        if (scale is None):
            scale = 1.
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            p = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = h2d_col__Polygon_Polygon_Impl_.toIPolygon(p,scale)
            _g.append(x)
        return _g

    @staticmethod
    def getBounds(this1,b = None):
        if (b is None):
            b = h2d_col_Bounds()
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            h2d_col__Polygon_Polygon_Impl_.getBounds(p,b)
        return b

    @staticmethod
    def getCollider(this1,isConvex = None):
        if (isConvex is None):
            isConvex = False
        return h2d_col_PolygonCollider(this1,isConvex)

    @staticmethod
    def contains(this1,p,isConvex = None):
        if (isConvex is None):
            isConvex = False
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            pl = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if h2d_col__Polygon_Polygon_Impl_.contains(pl,p,isConvex):
                return True
        return False

    @staticmethod
    def optimize(this1,epsilon):
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            p = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = h2d_col__Polygon_Polygon_Impl_.optimize(p,epsilon)
            _g.append(x)
        return _g
h2d_col__Polygons_Polygons_Impl_._hx_class = h2d_col__Polygons_Polygons_Impl_
_hx_classes["h2d.col._Polygons.Polygons_Impl_"] = h2d_col__Polygons_Polygons_Impl_


class h2d_col_Ray:
    _hx_class_name = "h2d.col.Ray"
    _hx_is_interface = "False"
    __slots__ = ("px", "py", "lx", "ly")
    _hx_fields = ["px", "py", "lx", "ly"]
    _hx_methods = ["side", "getPoint", "getPos", "getDir", "normalize"]
    _hx_statics = ["fromPoints", "fromValues"]

    def __init__(self):
        self.ly = None
        self.lx = None
        self.py = None
        self.px = None

    def side(self,p):
        return ((self.lx * ((p.y - self.py))) - ((self.ly * ((p.x - self.px)))))

    def getPoint(self,distance):
        return h2d_col_Point((self.px + ((distance * self.lx))),(self.py + ((distance * self.ly))))

    def getPos(self):
        return h2d_col_Point(self.px,self.py)

    def getDir(self):
        return h2d_col_Point(self.lx,self.ly)

    def normalize(self):
        l = ((self.lx * self.lx) + ((self.ly * self.ly)))
        if (l == 1.):
            return
        if (l < 1e-10):
            l = 0
        else:
            l = (1. / ((Math.NaN if ((l < 0)) else python_lib_Math.sqrt(l))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.lx
        _hx_local_0.lx = (_hx_local_1 * l)
        _hx_local_0.lx
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.ly
        _hx_local_2.ly = (_hx_local_3 * l)
        _hx_local_2.ly

    @staticmethod
    def fromPoints(p1,p2):
        r = h2d_col_Ray()
        r.px = p1.x
        r.py = p1.y
        r.lx = (p2.x - p1.x)
        r.ly = (p2.y - p1.y)
        r.normalize()
        return r

    @staticmethod
    def fromValues(x,y,dx,dy):
        r = h2d_col_Ray()
        r.px = x
        r.py = y
        r.lx = dx
        r.ly = dy
        r.normalize()
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.px = None
        _hx_o.py = None
        _hx_o.lx = None
        _hx_o.ly = None
h2d_col_Ray._hx_class = h2d_col_Ray
_hx_classes["h2d.col.Ray"] = h2d_col_Ray


class h2d_col_Segment:
    _hx_class_name = "h2d.col.Segment"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "dx", "dy", "lenSq", "invLenSq")
    _hx_fields = ["x", "y", "dx", "dy", "lenSq", "invLenSq"]
    _hx_methods = ["setPoints", "side", "distanceSq", "distance", "project", "lineIntersection"]

    def __init__(self,p1,p2):
        self.invLenSq = None
        self.lenSq = None
        self.dy = None
        self.dx = None
        self.x = p1.x
        self.y = p1.y
        self.dx = (p2.x - self.x)
        self.dy = (p2.y - self.y)
        self.lenSq = ((self.dx * self.dx) + ((self.dy * self.dy)))
        self.invLenSq = (1 / self.lenSq)

    def setPoints(self,p1,p2):
        self.x = p1.x
        self.y = p1.y
        self.dx = (p2.x - self.x)
        self.dy = (p2.y - self.y)
        self.lenSq = ((self.dx * self.dx) + ((self.dy * self.dy)))
        self.invLenSq = (1 / self.lenSq)

    def side(self,p):
        return ((self.dx * ((p.y - self.y))) - ((self.dy * ((p.x - self.x)))))

    def distanceSq(self,p):
        px = (p.x - self.x)
        py = (p.y - self.y)
        t = ((px * self.dx) + ((py * self.dy)))
        if (t < 0):
            return ((px * px) + ((py * py)))
        elif (t > self.lenSq):
            kx = (p.x - ((self.x + self.dx)))
            ky = (p.y - ((self.y + self.dy)))
            return ((kx * kx) + ((ky * ky)))
        else:
            tl2 = (t * self.invLenSq)
            pdx = ((self.x + ((tl2 * self.dx))) - p.x)
            pdy = ((self.y + ((tl2 * self.dy))) - p.y)
            return ((pdx * pdx) + ((pdy * pdy)))

    def distance(self,p):
        px = (p.x - self.x)
        py = (p.y - self.y)
        t = ((px * self.dx) + ((py * self.dy)))
        f = None
        if (t < 0):
            f = ((px * px) + ((py * py)))
        elif (t > self.lenSq):
            kx = (p.x - ((self.x + self.dx)))
            ky = (p.y - ((self.y + self.dy)))
            f = ((kx * kx) + ((ky * ky)))
        else:
            tl2 = (t * self.invLenSq)
            pdx = ((self.x + ((tl2 * self.dx))) - p.x)
            pdy = ((self.y + ((tl2 * self.dy))) - p.y)
            f = ((pdx * pdx) + ((pdy * pdy)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def project(self,p):
        px = (p.x - self.x)
        py = (p.y - self.y)
        t = ((px * self.dx) + ((py * self.dy)))
        if (t < 0):
            return h2d_col_Point(self.x,self.y)
        elif (t > self.lenSq):
            return h2d_col_Point((self.x + self.dx),(self.y + self.dy))
        else:
            tl2 = (t * self.invLenSq)
            return h2d_col_Point((self.x + ((tl2 * self.dx))),(self.y + ((tl2 * self.dy))))

    def lineIntersection(self,r,pt = None):
        x = self.x
        y = self.y
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        x = (self.x + self.dx)
        y = (self.y + self.dy)
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x1 = x
        p_y1 = y
        if (((((r.lx * ((p_y - r.py))) - ((r.ly * ((p_x - r.px)))))) * (((r.lx * ((p_y1 - r.py))) - ((r.ly * ((p_x1 - r.px))))))) > 0):
            return None
        u = ((((r.lx * ((self.y - r.py))) - ((r.ly * ((self.x - r.px)))))) / (((r.ly * self.dx) - ((r.lx * self.dy)))))
        if ((u < 0) or ((u > 1))):
            return None
        if (pt is None):
            pt = h2d_col_Point()
        pt.x = (self.x + ((u * self.dx)))
        pt.y = (self.y + ((u * self.dy)))
        return pt

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.dx = None
        _hx_o.dy = None
        _hx_o.lenSq = None
        _hx_o.invLenSq = None
h2d_col_Segment._hx_class = h2d_col_Segment
_hx_classes["h2d.col.Segment"] = h2d_col_Segment


class h2d_col__Segments_Segments_Impl_:
    _hx_class_name = "h2d.col._Segments.Segments_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_segments", "get_length", "iterator", "containsPoint", "toPolygon", "project", "distanceSq", "distance"]
    segments = None
    length = None

    @staticmethod
    def get_segments(this1):
        return this1

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def iterator(this1):
        return hxd_impl_ArrayIterator_h2d_col_Segment(this1)

    @staticmethod
    def containsPoint(this1,p,isConvex):
        if isConvex:
            _g = 0
            _g1 = this1
            while (_g < len(_g1)):
                s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (((s.dx * ((p.y - s.y))) - ((s.dy * ((p.x - s.x))))) < 0):
                    return False
        else:
            raise haxe_Exception.thrown("TODO")
        return True

    @staticmethod
    def toPolygon(this1):
        _g = []
        _g1 = 0
        _g2 = this1
        while (_g1 < len(_g2)):
            s = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = h2d_col_Point(s.x,s.y)
            _g.append(x)
        return _g

    @staticmethod
    def project(this1,p):
        dmin = 1e20
        smin = None
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            px = (p.x - s.x)
            py = (p.y - s.y)
            t = ((px * s.dx) + ((py * s.dy)))
            d = None
            if (t < 0):
                d = ((px * px) + ((py * py)))
            elif (t > s.lenSq):
                kx = (p.x - ((s.x + s.dx)))
                ky = (p.y - ((s.y + s.dy)))
                d = ((kx * kx) + ((ky * ky)))
            else:
                tl2 = (t * s.invLenSq)
                pdx = ((s.x + ((tl2 * s.dx))) - p.x)
                pdy = ((s.y + ((tl2 * s.dy))) - p.y)
                d = ((pdx * pdx) + ((pdy * pdy)))
            if (d < dmin):
                dmin = d
                smin = s
        px = (p.x - smin.x)
        py = (p.y - smin.y)
        t = ((px * smin.dx) + ((py * smin.dy)))
        if (t < 0):
            return h2d_col_Point(smin.x,smin.y)
        elif (t > smin.lenSq):
            return h2d_col_Point((smin.x + smin.dx),(smin.y + smin.dy))
        else:
            tl2 = (t * smin.invLenSq)
            return h2d_col_Point((smin.x + ((tl2 * smin.dx))),(smin.y + ((tl2 * smin.dy))))

    @staticmethod
    def distanceSq(this1,p):
        dmin = 1e20
        _g = 0
        _g1 = this1
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            px = (p.x - s.x)
            py = (p.y - s.y)
            t = ((px * s.dx) + ((py * s.dy)))
            d = None
            if (t < 0):
                d = ((px * px) + ((py * py)))
            elif (t > s.lenSq):
                kx = (p.x - ((s.x + s.dx)))
                ky = (p.y - ((s.y + s.dy)))
                d = ((kx * kx) + ((ky * ky)))
            else:
                tl2 = (t * s.invLenSq)
                pdx = ((s.x + ((tl2 * s.dx))) - p.x)
                pdy = ((s.y + ((tl2 * s.dy))) - p.y)
                d = ((pdx * pdx) + ((pdy * pdy)))
            if (d < dmin):
                dmin = d
        return dmin

    @staticmethod
    def distance(this1,p):
        f = h2d_col__Segments_Segments_Impl_.distanceSq(this1,p)
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)
h2d_col__Segments_Segments_Impl_._hx_class = h2d_col__Segments_Segments_Impl_
_hx_classes["h2d.col._Segments.Segments_Impl_"] = h2d_col__Segments_Segments_Impl_


class h2d_filter_Filter:
    _hx_class_name = "h2d.filter.Filter"
    _hx_is_interface = "False"
    __slots__ = ("autoBounds", "boundsExtend", "smooth", "enable")
    _hx_fields = ["autoBounds", "boundsExtend", "smooth", "enable"]
    _hx_methods = ["get_enable", "set_enable", "sync", "bind", "unbind", "getBounds", "draw"]

    def __init__(self):
        self.enable = True
        self.smooth = False
        self.boundsExtend = 0.
        self.autoBounds = True

    def get_enable(self):
        return self.enable

    def set_enable(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.enable = v
                return self.enable
            return _hx_local_0()
        return _hx_local_1()

    def sync(self,ctx,s):
        pass

    def bind(self,s):
        pass

    def unbind(self,s):
        pass

    def getBounds(self,s,bounds):
        s.getBounds(s,bounds)
        bounds.xMin = (bounds.xMin - self.boundsExtend)
        bounds.yMin = (bounds.yMin - self.boundsExtend)
        bounds.xMax = (bounds.xMax + self.boundsExtend)
        bounds.yMax = (bounds.yMax + self.boundsExtend)

    def draw(self,ctx,input):
        return input

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.autoBounds = None
        _hx_o.boundsExtend = None
        _hx_o.smooth = None
h2d_filter_Filter._hx_class = h2d_filter_Filter
_hx_classes["h2d.filter.Filter"] = h2d_filter_Filter


class h2d_impl_BatchDrawState:
    _hx_class_name = "h2d.impl.BatchDrawState"
    _hx_is_interface = "False"
    __slots__ = ("totalCount", "head", "tail")
    _hx_fields = ["totalCount", "head", "tail"]
    _hx_methods = ["setTile", "setTexture", "add", "clear", "drawQuads", "drawIndexed", "get_currentTexture"]

    def __init__(self):
        def _hx_local_0():
            self.tail = h2d_impl__BatchDrawState_StateEntry(None)
            return self.tail
        self.head = _hx_local_0()
        self.totalCount = 0

    def setTile(self,tile):
        if (tile is not None):
            self.setTexture(tile.innerTex)

    def setTexture(self,texture):
        if (texture is not None):
            if (self.tail.texture is None):
                self.tail.texture = texture
            elif (self.tail.texture != texture):
                cur = self.tail
                if (cur.next is None):
                    def _hx_local_0():
                        self.tail = h2d_impl__BatchDrawState_StateEntry(texture)
                        return self.tail
                    cur.next = _hx_local_0()
                else:
                    self.tail = cur.next.set(texture)

    def add(self,count):
        _hx_local_0 = self.tail
        _hx_local_1 = _hx_local_0.count
        _hx_local_0.count = (_hx_local_1 + count)
        _hx_local_0.count
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.totalCount
        _hx_local_2.totalCount = (_hx_local_3 + count)
        _hx_local_2.totalCount

    def clear(self):
        state = self.head
        while True:
            state.texture = None
            state = state.next
            if (not ((state is not None))):
                break
        self.tail = self.head
        self.tail.count = 0
        self.totalCount = 0

    def drawQuads(self,ctx,buffer,offset = None,length = None):
        if (offset is None):
            offset = 0
        if (length is None):
            length = -1
        state = self.head
        last = self.tail.next
        engine = ctx.engine
        stateLen = None
        if ((offset == 0) and ((length == -1))):
            while True:
                ctx.texture = state.texture
                ctx.beforeDraw()
                stateLen = (state.count >> 1)
                start = offset
                _hx_max = stateLen
                if (_hx_max is None):
                    _hx_max = -1
                if (start is None):
                    start = 0
                engine.renderBuffer(buffer,engine.mem.quadIndexes,2,start,_hx_max)
                offset = (offset + stateLen)
                state = state.next
                if (not ((state != last))):
                    break
        else:
            if (length == -1):
                length = (((self.totalCount >> 1)) - offset)
            caret = 0
            while True:
                stateLen = (state.count >> 1)
                if ((caret + stateLen) >= offset):
                    stateMin = (offset if ((offset >= caret)) else caret)
                    stateLen1 = (stateLen if ((length > stateLen)) else length)
                    ctx.texture = state.texture
                    ctx.beforeDraw()
                    start = stateMin
                    _hx_max = stateLen1
                    if (_hx_max is None):
                        _hx_max = -1
                    if (start is None):
                        start = 0
                    engine.renderBuffer(buffer,engine.mem.quadIndexes,2,start,_hx_max)
                    length = (length - stateLen1)
                    if (length == 0):
                        break
                caret = (caret + stateLen)
                state = state.next
                if (not ((state != last))):
                    break

    def drawIndexed(self,ctx,buffer,indices,offset = None,length = None):
        if (offset is None):
            offset = 0
        if (length is None):
            length = -1
        state = self.head
        last = self.tail.next
        engine = ctx.engine
        stateLen = None
        if ((offset == 0) and ((length == -1))):
            while True:
                ctx.texture = state.texture
                ctx.beforeDraw()
                count = state.count
                stateLen1 = None
                try:
                    stateLen1 = int((count / 3))
                except BaseException as _g:
                    None
                    stateLen1 = None
                stateLen = stateLen1
                engine.renderIndexed(buffer,indices,offset,stateLen)
                offset = (offset + stateLen)
                state = state.next
                if (not ((state != last))):
                    break
        else:
            if (length == -1):
                count = self.totalCount
                length1 = None
                try:
                    length1 = int((count / 3))
                except BaseException as _g:
                    None
                    length1 = None
                length = length1
            caret = 0
            while True:
                count = state.count
                stateLen1 = None
                try:
                    stateLen1 = int((count / 3))
                except BaseException as _g:
                    None
                    stateLen1 = None
                stateLen = stateLen1
                if ((caret + stateLen) >= offset):
                    stateMin = (offset if ((offset >= caret)) else caret)
                    stateLen2 = (stateLen if ((length > stateLen)) else length)
                    ctx.texture = state.texture
                    ctx.beforeDraw()
                    engine.renderIndexed(buffer,indices,stateMin,stateLen2)
                    length = (length - stateLen2)
                    if (length == 0):
                        break
                caret = (caret + stateLen)
                state = state.next
                if (not ((state != last))):
                    break

    def get_currentTexture(self):
        return self.tail.texture

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.totalCount = None
        _hx_o.head = None
        _hx_o.tail = None
h2d_impl_BatchDrawState._hx_class = h2d_impl_BatchDrawState
_hx_classes["h2d.impl.BatchDrawState"] = h2d_impl_BatchDrawState


class h2d_impl__BatchDrawState_StateEntry:
    _hx_class_name = "h2d.impl._BatchDrawState.StateEntry"
    _hx_is_interface = "False"
    __slots__ = ("texture", "count", "next")
    _hx_fields = ["texture", "count", "next"]
    _hx_methods = ["set"]

    def __init__(self,texture):
        self.next = None
        self.texture = texture
        self.count = 0

    def set(self,texture):
        self.texture = texture
        self.count = 0
        return self

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture = None
        _hx_o.count = None
        _hx_o.next = None
h2d_impl__BatchDrawState_StateEntry._hx_class = h2d_impl__BatchDrawState_StateEntry
_hx_classes["h2d.impl._BatchDrawState.StateEntry"] = h2d_impl__BatchDrawState_StateEntry

class h3d_BufferFlag(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.BufferFlag"
    _hx_constructs = ["Dynamic", "Triangles", "Quads", "Managed", "RawFormat", "NoAlloc", "UniformBuffer", "LargeBuffer"]
h3d_BufferFlag.Dynamic = h3d_BufferFlag("Dynamic", 0, ())
h3d_BufferFlag.Triangles = h3d_BufferFlag("Triangles", 1, ())
h3d_BufferFlag.Quads = h3d_BufferFlag("Quads", 2, ())
h3d_BufferFlag.Managed = h3d_BufferFlag("Managed", 3, ())
h3d_BufferFlag.RawFormat = h3d_BufferFlag("RawFormat", 4, ())
h3d_BufferFlag.NoAlloc = h3d_BufferFlag("NoAlloc", 5, ())
h3d_BufferFlag.UniformBuffer = h3d_BufferFlag("UniformBuffer", 6, ())
h3d_BufferFlag.LargeBuffer = h3d_BufferFlag("LargeBuffer", 7, ())
h3d_BufferFlag._hx_class = h3d_BufferFlag
_hx_classes["h3d.BufferFlag"] = h3d_BufferFlag


class h3d_Buffer:
    _hx_class_name = "h3d.Buffer"
    _hx_is_interface = "False"
    __slots__ = ("id", "buffer", "position", "vertices", "next", "flags")
    _hx_fields = ["id", "buffer", "position", "vertices", "next", "flags"]
    _hx_methods = ["isDisposed", "dispose", "totalVertices", "uploadVector", "uploadBytes", "readBytes"]
    _hx_statics = ["GUID", "ofFloats", "ofSubFloats"]

    def __init__(self,vertices,stride,flags = None):
        self.next = None
        self.position = None
        self.buffer = None
        def _hx_local_2():
            _hx_local_0 = h3d_Buffer
            _hx_local_1 = _hx_local_0.GUID
            _hx_local_0.GUID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()
        self.vertices = vertices
        this1 = 0
        self.flags = this1
        if (flags is not None):
            _g = 0
            while (_g < len(flags)):
                f = (flags[_g] if _g >= 0 and _g < len(flags) else None)
                _g = (_g + 1)
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.flags
                _hx_local_4.flags = (_hx_local_5 | ((1 << f.index)))
                _hx_local_4.flags
        if (((self.flags & ((1 << h3d_BufferFlag.NoAlloc.index)))) == 0):
            h3d_Engine.CURRENT.mem.allocBuffer(self,stride)

    def isDisposed(self):
        if (self.buffer is not None):
            return (self.buffer.vbuf is None)
        else:
            return True

    def dispose(self):
        if (self.buffer is not None):
            self.buffer.freeBuffer(self)
            self.buffer = None
            if (self.next is not None):
                self.next.dispose()

    def totalVertices(self):
        count = 0
        b = self
        while (b is not None):
            count = (count + b.vertices)
            b = b.next
        return count

    def uploadVector(self,buf,bufPos,vertices,startVertice = None):
        if (startVertice is None):
            startVertice = 0
        cur = self
        while ((cur is not None) and ((startVertice >= cur.vertices))):
            startVertice = (startVertice - cur.vertices)
            cur = cur.next
        while (vertices > 0):
            if (cur is None):
                raise haxe_Exception.thrown("Too many vertices")
            count = ((cur.vertices - startVertice) if (((vertices + startVertice) > cur.vertices)) else vertices)
            cur.buffer.uploadVertexBuffer((cur.position + startVertice),count,buf,bufPos)
            startVertice = 0
            bufPos = (bufPos + ((count * self.buffer.stride)))
            vertices = (vertices - count)
            cur = cur.next

    def uploadBytes(self,data,dataPos,vertices):
        cur = self
        while (vertices > 0):
            if (cur is None):
                raise haxe_Exception.thrown("Too many vertices")
            count = (cur.vertices if ((vertices > cur.vertices)) else vertices)
            cur.buffer.uploadVertexBytes(cur.position,count,data,dataPos)
            dataPos = (dataPos + (((count * self.buffer.stride) * 4)))
            vertices = (vertices - count)
            cur = cur.next

    def readBytes(self,_hx_bytes,bytesPosition,vertices,startVertice = None):
        if (startVertice is None):
            startVertice = 0
        cur = self
        while ((cur is not None) and ((startVertice >= cur.vertices))):
            startVertice = (startVertice - cur.vertices)
            cur = cur.next
        while (vertices > 0):
            if (cur is None):
                raise haxe_Exception.thrown("Too many vertices")
            count = ((cur.vertices - startVertice) if (((vertices + startVertice) > cur.vertices)) else vertices)
            cur.buffer.readVertexBytes((cur.position + startVertice),count,_hx_bytes,bytesPosition)
            startVertice = 0
            bytesPosition = (bytesPosition + (((count * self.buffer.stride) * 4)))
            vertices = (vertices - count)
            cur = cur.next

    @staticmethod
    def ofFloats(v,stride,flags = None):
        x = (len(v) / stride)
        nvert = None
        try:
            nvert = int(x)
        except BaseException as _g:
            None
            nvert = None
        b = h3d_Buffer(nvert,stride,flags)
        b.uploadVector(v,0,nvert)
        return b

    @staticmethod
    def ofSubFloats(v,stride,vertices,flags = None):
        b = h3d_Buffer(vertices,stride,flags)
        b.uploadVector(v,0,vertices)
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.buffer = None
        _hx_o.position = None
        _hx_o.vertices = None
        _hx_o.next = None
        _hx_o.flags = None
h3d_Buffer._hx_class = h3d_Buffer
_hx_classes["h3d.Buffer"] = h3d_Buffer


class h3d_BufferOffset:
    _hx_class_name = "h3d.BufferOffset"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "offset", "next")
    _hx_fields = ["buffer", "offset", "next"]
    _hx_methods = ["clone", "dispose"]

    def __init__(self,buffer,offset):
        self.next = None
        self.buffer = buffer
        self.offset = offset

    def clone(self):
        b = h3d_BufferOffset(self.buffer,self.offset)
        return b

    def dispose(self):
        if (self.buffer is not None):
            self.buffer.dispose()
            self.buffer = None
        self.next = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.offset = None
        _hx_o.next = None
h3d_BufferOffset._hx_class = h3d_BufferOffset
_hx_classes["h3d.BufferOffset"] = h3d_BufferOffset


class h3d_Camera:
    _hx_class_name = "h3d.Camera"
    _hx_is_interface = "False"
    __slots__ = ("zoom", "screenRatio", "fovY", "zNear", "zFar", "orthoBounds", "rightHanded", "mproj", "mcam", "m", "pos", "up", "target", "viewX", "viewY", "follow", "frustum", "minv", "mcamInv", "mprojInv", "needInv")
    _hx_fields = ["zoom", "screenRatio", "fovY", "zNear", "zFar", "orthoBounds", "rightHanded", "mproj", "mcam", "m", "pos", "up", "target", "viewX", "viewY", "follow", "frustum", "minv", "mcamInv", "mprojInv", "needInv"]
    _hx_methods = ["setFovX", "getFovX", "clone", "getInverseViewProj", "getInverseProj", "getInverseView", "setCubeMap", "unproject", "rayFromScreen", "update", "getFrustumCorners", "lostUp", "getViewDirection", "movePosAxis", "moveTargetAxis", "forward", "backward", "makeCameraMatrix", "setTransform", "makeFrustumMatrix", "project", "load"]

    def __init__(self,fovY = None,zoom = None,screenRatio = None,zNear = None,zFar = None,rightHanded = None):
        if (fovY is None):
            fovY = 25.
        if (zoom is None):
            zoom = 1.
        if (screenRatio is None):
            screenRatio = 1.333333
        if (zNear is None):
            zNear = 0.02
        if (zFar is None):
            zFar = 4000.
        if (rightHanded is None):
            rightHanded = False
        self.needInv = None
        self.mprojInv = None
        self.mcamInv = None
        self.minv = None
        self.follow = None
        self.orthoBounds = None
        self.viewY = 0.
        self.viewX = 0.
        self.fovY = fovY
        self.zoom = zoom
        self.screenRatio = screenRatio
        self.zNear = zNear
        self.zFar = zFar
        self.rightHanded = rightHanded
        self.pos = h3d_Vector(2,3,4)
        self.up = h3d_Vector(0,0,1)
        self.target = h3d_Vector(0,0,0)
        self.m = h3d_Matrix()
        self.mcam = h3d_Matrix()
        self.mproj = h3d_Matrix()
        self.frustum = h3d_col_Frustum()
        self.update()

    def setFovX(self,fovX,withRatio):
        degToRad = (Math.PI / 180)
        self.fovY = ((2 * Math.atan((Math.tan(((fovX * 0.5) * degToRad)) / withRatio))) / degToRad)

    def getFovX(self):
        degToRad = (Math.PI / 180)
        halfFovX = Math.atan((Math.tan(((self.fovY * 0.5) * degToRad)) * self.screenRatio))
        fovX = ((halfFovX * 2) / degToRad)
        return fovX

    def clone(self):
        c = h3d_Camera(self.fovY,self.zoom,self.screenRatio,self.zNear,self.zFar,self.rightHanded)
        _this = self.pos
        c.pos = h3d_Vector(_this.x,_this.y,_this.z,_this.w)
        _this = self.up
        c.up = h3d_Vector(_this.x,_this.y,_this.z,_this.w)
        _this = self.target
        c.target = h3d_Vector(_this.x,_this.y,_this.z,_this.w)
        c.update()
        return c

    def getInverseViewProj(self):
        if (self.minv is None):
            self.minv = h3d_Matrix()
        if self.needInv:
            self.minv.initInverse(self.m)
            self.needInv = False
        return self.minv

    def getInverseProj(self):
        if (self.mprojInv is None):
            self.mprojInv = h3d_Matrix()
            self.mprojInv._44 = 0
        if (self.mprojInv._44 == 0):
            self.mprojInv.initInverse(self.mproj)
        return self.mprojInv

    def getInverseView(self):
        if (self.mcamInv is None):
            self.mcamInv = h3d_Matrix()
            self.mcamInv._44 = 0
        if (self.mcamInv._44 == 0):
            self.mcamInv.initInverse(self.mcam)
        return self.mcamInv

    def setCubeMap(self,face,position = None):
        dx = 0
        dy = 0
        dz = 0
        face1 = face
        if (face1 == 0):
            dx = 1
            _this = self.up
            x = 0
            y = 1
            z = 0
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
        elif (face1 == 1):
            dx = -1
            _this = self.up
            x = 0
            y = 1
            z = 0
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
        elif (face1 == 2):
            dy = 1
            _this = self.up
            x = 0
            y = 0
            z = -1
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
        elif (face1 == 3):
            dy = -1
            _this = self.up
            x = 0
            y = 0
            z = 1
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
        elif (face1 == 4):
            dz = 1
            _this = self.up
            x = 0
            y = 1
            z = 0
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
        elif (face1 == 5):
            dz = -1
            _this = self.up
            x = 0
            y = 1
            z = 0
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
        else:
            pass
        if (position is not None):
            _this = self.pos
            _this.x = position.x
            _this.y = position.y
            _this.z = position.z
            _this.w = position.w
        _this = self.target
        x = (self.pos.x + dx)
        y = (self.pos.y + dy)
        z = (self.pos.z + dz)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.

    def unproject(self,screenX,screenY,camZ):
        p = h3d_Vector(screenX,screenY,camZ)
        m = self.getInverseViewProj()
        px = ((((p.x * m._11) + ((p.y * m._21))) + ((p.z * m._31))) + ((p.w * m._41)))
        py = ((((p.x * m._12) + ((p.y * m._22))) + ((p.z * m._32))) + ((p.w * m._42)))
        pz = ((((p.x * m._13) + ((p.y * m._23))) + ((p.z * m._33))) + ((p.w * m._43)))
        iw = (1 / (((((p.x * m._14) + ((p.y * m._24))) + ((p.z * m._34))) + ((p.w * m._44)))))
        p.x = (px * iw)
        p.y = (py * iw)
        p.z = (pz * iw)
        p.w = 1
        return p

    def rayFromScreen(self,pixelX,pixelY,sceneWidth = None,sceneHeight = None):
        if (sceneWidth is None):
            sceneWidth = -1
        if (sceneHeight is None):
            sceneHeight = -1
        engine = h3d_Engine.CURRENT
        if (sceneWidth < 0):
            sceneWidth = engine.width
        if (sceneHeight < 0):
            sceneHeight = engine.height
        rx = ((((pixelX / sceneWidth) - 0.5)) * 2)
        ry = (((0.5 - ((pixelY / sceneHeight)))) * 2)
        _this = self.unproject(rx,ry,0)
        x = _this.x
        y = _this.y
        z = _this.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p1_x = x
        p1_y = y
        p1_z = z
        _this = self.unproject(rx,ry,1)
        x = _this.x
        y = _this.y
        z = _this.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p2_x = x
        p2_y = y
        p2_z = z
        r = h3d_col_Ray()
        r.px = p1_x
        r.py = p1_y
        r.pz = p1_z
        r.lx = (p2_x - p1_x)
        r.ly = (p2_y - p1_y)
        r.lz = (p2_z - p1_z)
        r.normalize()
        return r

    def update(self):
        if (self.follow is not None):
            fpos = self.follow.pos.localToGlobal()
            ftarget = self.follow.target.localToGlobal()
            _this = self.pos
            x = fpos.x
            y = fpos.y
            z = fpos.z
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
            _this = self.target
            x = ftarget.x
            y = ftarget.y
            z = ftarget.z
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
            if (self.follow.pos.name is not None):
                p = self.follow.pos
                while (p is not None):
                    if (p.currentAnimation is not None):
                        v = p.currentAnimation.getPropValue(self.follow.pos.name,"FOVY")
                        if (v is not None):
                            self.fovY = v
                            break
                    p = p.parent
        self.makeCameraMatrix(self.mcam)
        self.makeFrustumMatrix(self.mproj)
        self.m.multiply(self.mcam,self.mproj)
        self.needInv = True
        if (self.mcamInv is not None):
            self.mcamInv._44 = 0
        if (self.mprojInv is not None):
            self.mprojInv._44 = 0
        self.frustum.loadMatrix(self.m)

    def getFrustumCorners(self,zMax = None,zMin = None):
        if (zMax is None):
            zMax = 1.
        if (zMin is None):
            zMin = 0.
        return [self.unproject(-1,1,zMin), self.unproject(1,1,zMin), self.unproject(1,-1,zMin), self.unproject(-1,-1,zMin), self.unproject(-1,1,zMax), self.unproject(1,1,zMax), self.unproject(1,-1,zMax), self.unproject(-1,-1,zMax)]

    def lostUp(self):
        _this = self.pos
        x = _this.x
        y = _this.y
        z = _this.z
        w = _this.w
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p2_x = x
        p2_y = y
        p2_z = z
        p2_w = w
        k = (((p2_x * p2_x) + ((p2_y * p2_y))) + ((p2_z * p2_z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        p2_x = (p2_x * k)
        p2_y = (p2_y * k)
        p2_z = (p2_z * k)
        v = self.up
        return (Reflect.field(Math,"fabs")((((p2_x * v.x) + ((p2_y * v.y))) + ((p2_z * v.z)))) > 0.999)

    def getViewDirection(self,dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        a = h3d_col_Point(dx,dy,dz)
        m = self.mcam
        px = (((a.x * m._11) + ((a.y * m._21))) + ((a.z * m._31)))
        py = (((a.x * m._12) + ((a.y * m._22))) + ((a.z * m._32)))
        pz = (((a.x * m._13) + ((a.y * m._23))) + ((a.z * m._33)))
        a.x = px
        a.y = py
        a.z = pz
        k = (((a.x * a.x) + ((a.y * a.y))) + ((a.z * a.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        a.x = (a.x * k)
        a.y = (a.y * k)
        a.z = (a.z * k)
        return a

    def movePosAxis(self,dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        x = dx
        y = dy
        z = dz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        m = self.mcam
        px = (((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31)))
        py = (((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32)))
        pz = (((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33)))
        p_x = px
        p_y = py
        p_z = pz
        _hx_local_0 = self.pos
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + p_x)
        _hx_local_0.x
        _hx_local_2 = self.pos
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + p_y)
        _hx_local_2.y
        _hx_local_4 = self.pos
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 + p_z)
        _hx_local_4.z

    def moveTargetAxis(self,dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        x = dx
        y = dy
        z = dz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        m = self.mcam
        px = (((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31)))
        py = (((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32)))
        pz = (((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33)))
        p_x = px
        p_y = py
        p_z = pz
        _hx_local_0 = self.target
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + p_x)
        _hx_local_0.x
        _hx_local_2 = self.target
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + p_y)
        _hx_local_2.y
        _hx_local_4 = self.target
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 + p_z)
        _hx_local_4.z

    def forward(self,speed = None):
        if (speed is None):
            speed = 1.
        c = (1 - ((0.025 * speed)))
        _this = self.pos
        x = (self.target.x + ((((self.pos.x - self.target.x)) * c)))
        y = (self.target.y + ((((self.pos.y - self.target.y)) * c)))
        z = (self.target.z + ((((self.pos.z - self.target.z)) * c)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.

    def backward(self,speed = None):
        if (speed is None):
            speed = 1.
        c = (1 + ((0.025 * speed)))
        _this = self.pos
        x = (self.target.x + ((((self.pos.x - self.target.x)) * c)))
        y = (self.target.y + ((((self.pos.y - self.target.y)) * c)))
        z = (self.target.z + ((((self.pos.z - self.target.z)) * c)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.

    def makeCameraMatrix(self,m):
        _this = self.target
        v = self.pos
        x = (_this.x - v.x)
        y = (_this.y - v.y)
        z = (_this.z - v.z)
        w = (_this.w - v.w)
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        az_x = x
        az_y = y
        az_z = z
        az_w = w
        if self.rightHanded:
            az_x = (az_x * -1)
            az_y = (az_y * -1)
            az_z = (az_z * -1)
        k = (((az_x * az_x) + ((az_y * az_y))) + ((az_z * az_z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        az_x = (az_x * k)
        az_y = (az_y * k)
        az_z = (az_z * k)
        _this = self.up
        x = ((_this.y * az_z) - ((_this.z * az_y)))
        y = ((_this.z * az_x) - ((_this.x * az_z)))
        z = ((_this.x * az_y) - ((_this.y * az_x)))
        w = 1
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ax_x = x
        ax_y = y
        ax_z = z
        ax_w = w
        k = (((ax_x * ax_x) + ((ax_y * ax_y))) + ((ax_z * ax_z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        ax_x = (ax_x * k)
        ax_y = (ax_y * k)
        ax_z = (ax_z * k)
        f = (((ax_x * ax_x) + ((ax_y * ax_y))) + ((ax_z * ax_z)))
        if (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) == 0):
            ax_x = az_y
            ax_y = az_z
            ax_z = az_x
        x = ((az_y * ax_z) - ((az_z * ax_y)))
        y = ((az_z * ax_x) - ((az_x * ax_z)))
        z = ((az_x * ax_y) - ((az_y * ax_x)))
        w = 1
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ay_x = x
        ay_y = y
        ay_z = z
        ay_w = w
        m._11 = ax_x
        m._12 = ay_x
        m._13 = az_x
        m._14 = 0
        m._21 = ax_y
        m._22 = ay_y
        m._23 = az_y
        m._24 = 0
        m._31 = ax_z
        m._32 = ay_z
        m._33 = az_z
        m._34 = 0
        v = self.pos
        m._41 = -((((ax_x * v.x) + ((ax_y * v.y))) + ((ax_z * v.z))))
        v = self.pos
        m._42 = -((((ay_x * v.x) + ((ay_y * v.y))) + ((ay_z * v.z))))
        v = self.pos
        m._43 = -((((az_x * v.x) + ((az_y * v.y))) + ((az_z * v.z))))
        m._44 = 1

    def setTransform(self,m):
        _this = self.pos
        x = m._41
        y = m._42
        z = m._43
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.target
        _this1 = self.pos
        v = m.getDirection()
        x = (_this1.x + v.x)
        y = (_this1.y + v.y)
        z = (_this1.z + v.z)
        w = (_this1.w + v.w)
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        _this.x = v_x
        _this.y = v_y
        _this.z = v_z
        _this.w = v_w

    def makeFrustumMatrix(self,m):
        m.zero()
        bounds = self.orthoBounds
        if (bounds is not None):
            w = (1 / ((bounds.xMax - bounds.xMin)))
            h = (1 / ((bounds.yMax - bounds.yMin)))
            d = (1 / ((bounds.zMax - bounds.zMin)))
            m._11 = (2 * w)
            m._22 = (2 * h)
            m._33 = d
            m._41 = (-((bounds.xMin + bounds.xMax)) * w)
            m._42 = (-((bounds.yMin + bounds.yMax)) * h)
            m._43 = (-bounds.zMin * d)
            m._44 = 1
        else:
            degToRad = (Math.PI / 180)
            halfFovX = Math.atan((Math.tan(((self.fovY * 0.5) * degToRad)) * self.screenRatio))
            scale = (self.zoom / Math.tan(halfFovX))
            m._11 = scale
            m._22 = (scale * self.screenRatio)
            m._33 = (self.zFar / ((self.zFar - self.zNear)))
            m._34 = 1
            m._43 = (-((self.zNear * self.zFar)) / ((self.zFar - self.zNear)))
        m._11 = (m._11 + ((self.viewX * m._14)))
        m._21 = (m._21 + ((self.viewX * m._24)))
        m._31 = (m._31 + ((self.viewX * m._34)))
        m._41 = (m._41 + ((self.viewX * m._44)))
        m._12 = (m._12 + ((self.viewY * m._14)))
        m._22 = (m._22 + ((self.viewY * m._24)))
        m._32 = (m._32 + ((self.viewY * m._34)))
        m._42 = (m._42 + ((self.viewY * m._44)))
        if self.rightHanded:
            m._33 = (m._33 * -1)
            m._34 = (m._34 * -1)

    def project(self,x,y,z,screenWidth,screenHeight,snapToPixel = None,p = None):
        if (snapToPixel is None):
            snapToPixel = True
        if (p is None):
            p = h3d_Vector()
        x1 = x
        y1 = y
        z1 = z
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        p.x = x1
        p.y = y1
        p.z = z1
        p.w = 1.
        m = self.m
        px = ((((p.x * m._11) + ((p.y * m._21))) + ((p.z * m._31))) + ((p.w * m._41)))
        py = ((((p.x * m._12) + ((p.y * m._22))) + ((p.z * m._32))) + ((p.w * m._42)))
        pz = ((((p.x * m._13) + ((p.y * m._23))) + ((p.z * m._33))) + ((p.w * m._43)))
        iw = (1 / (((((p.x * m._14) + ((p.y * m._24))) + ((p.z * m._34))) + ((p.w * m._44)))))
        p.x = (px * iw)
        p.y = (py * iw)
        p.z = (pz * iw)
        p.w = 1
        p.x = ((((p.x + 1)) * 0.5) * screenWidth)
        p.y = ((((-p.y + 1)) * 0.5) * screenHeight)
        if snapToPixel:
            p.x = Math.floor((p.x + 0.5))
            p.y = Math.floor((p.y + 0.5))
        return p

    def load(self,cam):
        _this = self.pos
        v = cam.pos
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        _this = self.target
        v = cam.target
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        _this = self.up
        v = cam.up
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        if (cam.orthoBounds is not None):
            self.orthoBounds = h3d_col_Bounds()
            self.orthoBounds.load(cam.orthoBounds)
        else:
            self.orthoBounds = None
        self.fovY = cam.fovY
        self.screenRatio = cam.screenRatio
        self.zoom = cam.zoom
        self.zNear = cam.zNear
        self.zFar = cam.zFar
        if (cam.follow is not None):
            self.follow = _hx_AnonObject({'pos': cam.follow.pos, 'target': cam.follow.target})
        else:
            self.follow = None
        self.viewX = cam.viewX
        self.viewY = cam.viewY
        self.update()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.zoom = None
        _hx_o.screenRatio = None
        _hx_o.fovY = None
        _hx_o.zNear = None
        _hx_o.zFar = None
        _hx_o.orthoBounds = None
        _hx_o.rightHanded = None
        _hx_o.mproj = None
        _hx_o.mcam = None
        _hx_o.m = None
        _hx_o.pos = None
        _hx_o.up = None
        _hx_o.target = None
        _hx_o.viewX = None
        _hx_o.viewY = None
        _hx_o.follow = None
        _hx_o.frustum = None
        _hx_o.minv = None
        _hx_o.mcamInv = None
        _hx_o.mprojInv = None
        _hx_o.needInv = None
h3d_Camera._hx_class = h3d_Camera
_hx_classes["h3d.Camera"] = h3d_Camera


class h3d__Engine_TargetTmp:
    _hx_class_name = "h3d._Engine.TargetTmp"
    _hx_is_interface = "False"
    __slots__ = ("t", "textures", "next", "layer", "mipLevel")
    _hx_fields = ["t", "textures", "next", "layer", "mipLevel"]

    def __init__(self,t,n,l,m):
        self.textures = None
        self.t = t
        self.next = n
        self.layer = l
        self.mipLevel = m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.t = None
        _hx_o.textures = None
        _hx_o.next = None
        _hx_o.layer = None
        _hx_o.mipLevel = None
h3d__Engine_TargetTmp._hx_class = h3d__Engine_TargetTmp
_hx_classes["h3d._Engine.TargetTmp"] = h3d__Engine_TargetTmp


class h3d_Engine:
    _hx_class_name = "h3d.Engine"
    _hx_is_interface = "False"
    _hx_fields = ["driver", "mem", "hardware", "width", "height", "debug", "drawTriangles", "drawCalls", "shaderSwitches", "backgroundColor", "autoResize", "fullScreen", "realFps", "lastTime", "antiAlias", "tmpVector", "window", "targetTmp", "targetStack", "currentTargetTex", "currentTargetLayer", "currentTargetMip", "needFlushTarget", "nullTexture", "textureColorCache", "inRender", "ready", "resCache"]
    _hx_methods = ["setDriver", "setCurrent", "init", "driverName", "selectShader", "selectMaterial", "uploadShaderBuffers", "selectBuffer", "renderTriBuffer", "renderQuadBuffer", "renderBuffer", "renderIndexed", "renderMultiBuffers", "renderInstanced", "set_debug", "onCreate", "onContextLost", "onReady", "onWindowResize", "set_fullScreen", "onResized", "resize", "begin", "hasFeature", "end", "getCurrentTarget", "pushTarget", "updateNeedFlush", "pushTargets", "popTarget", "flushTarget", "doFlushTarget", "clearF", "clear", "setRenderZone", "render", "dispose", "get_fps"]
    _hx_statics = ["SOFTWARE_DRIVER", "ANTIALIASING", "CURRENT", "getCurrent"]

    def __init__(self):
        self.nullTexture = None
        self.needFlushTarget = None
        self.currentTargetMip = None
        self.currentTargetLayer = None
        self.currentTargetTex = None
        self.targetStack = None
        self.targetTmp = None
        self.window = None
        self.lastTime = None
        self.realFps = None
        self.fullScreen = None
        self.shaderSwitches = None
        self.drawCalls = None
        self.drawTriangles = None
        self.debug = None
        self.height = None
        self.width = None
        self.mem = None
        self.driver = None
        self.resCache = haxe_ds_ObjectMap()
        self.ready = False
        self.inRender = False
        self.textureColorCache = haxe_ds_IntMap()
        self.tmpVector = h3d_Vector()
        self.backgroundColor = -16777216
        self.hardware = (not h3d_Engine.SOFTWARE_DRIVER)
        self.antiAlias = h3d_Engine.ANTIALIASING
        self.autoResize = True
        self.set_fullScreen((not hxd_System.getValue(hxd_SystemValue.IsWindowed)))
        self.window = hxd_Window.getInstance()
        self.realFps = hxd_System.getDefaultFrameRate()
        self.lastTime = python_lib_Timeit.default_timer()
        self.window.addResizeEvent(self.onWindowResize)
        _hx_str = "No output driver available."
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        self.driver = h3d_impl_LogDriver(h3d_impl_NullDriver())
        self.driver.logEnable = True
        h3d_Engine.CURRENT = self

    def setDriver(self,d):
        self.driver = d
        if (self.mem is not None):
            self.mem.driver = d

    def setCurrent(self):
        h3d_Engine.CURRENT = self

    def init(self):
        self.driver.init(self.onCreate,(not self.hardware))

    def driverName(self,details = None):
        if (details is None):
            details = False
        return self.driver.getDriverName(details)

    def selectShader(self,shader):
        if self.needFlushTarget:
            self.doFlushTarget()
        if self.driver.selectShader(shader):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.shaderSwitches
            _hx_local_0.shaderSwitches = (_hx_local_1 + 1)
            _hx_local_1

    def selectMaterial(self,_hx_pass):
        self.driver.selectMaterial(_hx_pass)

    def uploadShaderBuffers(self,buffers,which):
        self.driver.uploadShaderBuffers(buffers,which)

    def selectBuffer(self,buf):
        if ((buf.buffer is None) or ((buf.buffer.vbuf is None))):
            return False
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.selectBuffer(buf)
        return True

    def renderTriBuffer(self,b,start = None,_hx_max = None):
        if (start is None):
            start = 0
        if (_hx_max is None):
            _hx_max = -1
        self.renderBuffer(b,self.mem.triIndexes,3,start,_hx_max)

    def renderQuadBuffer(self,b,start = None,_hx_max = None):
        if (start is None):
            start = 0
        if (_hx_max is None):
            _hx_max = -1
        self.renderBuffer(b,self.mem.quadIndexes,2,start,_hx_max)

    def renderBuffer(self,b,indexes,vertPerTri,startTri = None,drawTri = None):
        if (startTri is None):
            startTri = 0
        if (drawTri is None):
            drawTri = -1
        if indexes.isDisposed():
            return
        while True:
            x = (b.vertices / vertPerTri)
            ntri = None
            try:
                ntri = int(x)
            except BaseException as _g:
                None
                ntri = None
            x1 = (b.position / vertPerTri)
            pos = None
            try:
                pos = int(x1)
            except BaseException as _g1:
                None
                pos = None
            if (startTri > 0):
                if (startTri >= ntri):
                    startTri = (startTri - ntri)
                    b = b.next
                    if (not ((b is not None))):
                        break
                    else:
                        continue
                pos = (pos + startTri)
                ntri = (ntri - startTri)
                startTri = 0
            if (drawTri >= 0):
                if (drawTri == 0):
                    return
                drawTri = (drawTri - ntri)
                if (drawTri < 0):
                    ntri = (ntri + drawTri)
                    drawTri = 0
            if ((ntri > 0) and self.selectBuffer(b)):
                self.driver.draw(indexes.ibuf,(pos * 3),ntri)
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.drawTriangles
                _hx_local_5.drawTriangles = (_hx_local_6 + ntri)
                _hx_local_5.drawTriangles
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.drawCalls
                _hx_local_7.drawCalls = (_hx_local_8 + 1)
                _hx_local_8
            b = b.next
            if (not ((b is not None))):
                break

    def renderIndexed(self,b,indexes,startTri = None,drawTri = None):
        if (startTri is None):
            startTri = 0
        if (drawTri is None):
            drawTri = -1
        if (b.next is not None):
            raise haxe_Exception.thrown("Buffer is split")
        if indexes.isDisposed():
            return
        x = (indexes.count / 3)
        maxTri = None
        try:
            maxTri = int(x)
        except BaseException as _g:
            None
            maxTri = None
        if (drawTri < 0):
            drawTri = (maxTri - startTri)
        if ((drawTri > 0) and self.selectBuffer(b)):
            self.driver.draw(indexes.ibuf,(startTri * 3),drawTri)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.drawTriangles
            _hx_local_0.drawTriangles = (_hx_local_1 + drawTri)
            _hx_local_0.drawTriangles
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.drawCalls
            _hx_local_2.drawCalls = (_hx_local_3 + 1)
            _hx_local_3

    def renderMultiBuffers(self,buffers,indexes,startTri = None,drawTri = None):
        if (startTri is None):
            startTri = 0
        if (drawTri is None):
            drawTri = -1
        x = (indexes.count / 3)
        maxTri = None
        try:
            maxTri = int(x)
        except BaseException as _g:
            None
            maxTri = None
        if (maxTri <= 0):
            return
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.selectMultiBuffers(buffers)
        if indexes.isDisposed():
            return
        if (drawTri < 0):
            drawTri = (maxTri - startTri)
        if (drawTri > 0):
            self.driver.draw(indexes.ibuf,(startTri * 3),drawTri)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.drawTriangles
            _hx_local_0.drawTriangles = (_hx_local_1 + drawTri)
            _hx_local_0.drawTriangles
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.drawCalls
            _hx_local_2.drawCalls = (_hx_local_3 + 1)
            _hx_local_3

    def renderInstanced(self,buffers,indexes,commands):
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.selectMultiBuffers(buffers)
        if indexes.isDisposed():
            return
        if (commands.commandCount > 0):
            self.driver.drawInstanced(indexes.ibuf,commands)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.drawTriangles
            _hx_local_0.drawTriangles = (_hx_local_1 + commands.triCount)
            _hx_local_0.drawTriangles
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.drawCalls
            _hx_local_2.drawCalls = (_hx_local_3 + 1)
            _hx_local_3

    def set_debug(self,d):
        self.debug = d
        self.driver.setDebug(self.debug)
        return d

    def onCreate(self,disposed):
        h3d_Engine.CURRENT = self
        if self.autoResize:
            self.width = self.window.get_width()
            self.height = self.window.get_height()
        if disposed:
            hxd_impl_Allocator.get().onContextLost()
            self.mem.onContextLost()
        else:
            self.mem = h3d_impl_MemoryManager(self.driver)
            self.mem.init()
            self.nullTexture = h3d_mat_Texture(0,0,[h3d_mat_TextureFlags.NoAlloc])
        self.hardware = self.driver.hasFeature(h3d_impl_Feature.HardwareAccelerated)
        self.set_debug(self.debug)
        self.set_fullScreen(self.fullScreen)
        self.resize(self.width,self.height)
        if disposed:
            self.onContextLost()
        else:
            self.onReady()
        self.ready = True

    def onContextLost(self):
        pass

    def onReady(self):
        pass

    def onWindowResize(self):
        if (self.autoResize and (not self.driver.isDisposed())):
            w = self.window.get_width()
            h = self.window.get_height()
            if ((w != self.width) or ((h != self.height))):
                self.resize(w,h)
            self.onResized()

    def set_fullScreen(self,v):
        self.fullScreen = v
        if ((self.mem is not None) and hxd_System.getValue(hxd_SystemValue.IsWindowed)):
            self.window.set_displayMode((hxd_DisplayMode.Borderless if v else hxd_DisplayMode.Windowed))
        return v

    def onResized(self):
        pass

    def resize(self,width,height):
        if (width < 32):
            width = 32
        if (height < 32):
            height = 32
        self.width = width
        self.height = height
        if (not self.driver.isDisposed()):
            self.driver.resize(width,height)

    def begin(self):
        if self.driver.isDisposed():
            return False
        self.inRender = True
        self.drawTriangles = 0
        self.shaderSwitches = 0
        self.drawCalls = 0
        self.targetStack = None
        self.needFlushTarget = (self.currentTargetTex is not None)
        self.driver.begin(hxd_Timer.frameCount)
        if (self.backgroundColor is not None):
            self.clear(self.backgroundColor,1,0)
        return True

    def hasFeature(self,f):
        return self.driver.hasFeature(f)

    def end(self):
        self.inRender = False
        self.driver.end()

    def getCurrentTarget(self):
        if (self.targetStack is None):
            return None
        elif (self.targetStack.t == self.nullTexture):
            return python_internal_ArrayImpl._get(self.targetStack.textures, 0)
        else:
            return self.targetStack.t

    def pushTarget(self,tex,layer = None,mipLevel = None):
        if (layer is None):
            layer = 0
        if (mipLevel is None):
            mipLevel = 0
        c = self.targetTmp
        if (c is None):
            c = h3d__Engine_TargetTmp(tex,self.targetStack,layer,mipLevel)
        else:
            self.targetTmp = c.next
            c.t = tex
            c.next = self.targetStack
            c.mipLevel = mipLevel
            c.layer = layer
        self.targetStack = c
        self.updateNeedFlush()

    def updateNeedFlush(self):
        t = self.targetStack
        if (t is None):
            self.needFlushTarget = (self.currentTargetTex is not None)
        else:
            self.needFlushTarget = ((((self.currentTargetTex != t.t) or ((self.currentTargetLayer != t.layer))) or ((self.currentTargetMip != t.mipLevel))) or ((t.textures is not None)))

    def pushTargets(self,textures):
        self.pushTarget(self.nullTexture)
        self.targetStack.textures = textures
        self.needFlushTarget = True

    def popTarget(self):
        c = self.targetStack
        if (c is None):
            raise haxe_Exception.thrown("popTarget() with no matching pushTarget()")
        self.targetStack = c.next
        self.updateNeedFlush()
        c.t = None
        c.textures = None
        c.next = self.targetTmp
        self.targetTmp = c

    def flushTarget(self):
        if self.needFlushTarget:
            self.doFlushTarget()

    def doFlushTarget(self):
        t = self.targetStack
        if (t is None):
            self.driver.setRenderTarget(None)
            self.currentTargetTex = None
        else:
            if (t.textures is not None):
                self.driver.setRenderTargets(t.textures)
            else:
                self.driver.setRenderTarget(t.t,t.layer,t.mipLevel)
            self.currentTargetTex = t.t
            self.currentTargetLayer = t.layer
            self.currentTargetMip = t.mipLevel
        self.needFlushTarget = False

    def clearF(self,color,depth = None,stencil = None):
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.clear(color,depth,stencil)

    def clear(self,color = None,depth = None,stencil = None):
        if (color is not None):
            _this = self.tmpVector
            _this.x = ((((color >> 16) & 255)) / 255)
            _this.y = ((((color >> 8) & 255)) / 255)
            _this.z = (((color & 255)) / 255)
            _this.w = ((HxOverrides.rshift(color, 24)) / 255)
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.clear((None if ((color is None)) else self.tmpVector),depth,stencil)

    def setRenderZone(self,x = None,y = None,width = None,height = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        if (width is None):
            width = -1
        if (height is None):
            height = -1
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.setRenderZone(x,y,width,height)

    def render(self,obj):
        if (not self.begin()):
            return False
        obj.render(self)
        self.end()
        delta = (python_lib_Timeit.default_timer() - self.lastTime)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.lastTime
        _hx_local_0.lastTime = (_hx_local_1 + delta)
        _hx_local_0.lastTime
        if (delta > 0):
            curFps = (1. / delta)
            if (curFps > ((self.realFps * 2))):
                curFps = (self.realFps * 2)
            elif (curFps < ((self.realFps * 0.5))):
                curFps = (self.realFps * 0.5)
            f = (delta / .5)
            if (f > 0.3):
                f = 0.3
            self.realFps = ((self.realFps * ((1 - f))) + ((curFps * f)))
        return True

    def dispose(self):
        self.driver.dispose()
        self.window.removeResizeEvent(self.onWindowResize)

    def get_fps(self):
        return (Math.ceil((self.realFps * 100)) / 100)

    @staticmethod
    def getCurrent():
        return h3d_Engine.CURRENT

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.driver = None
        _hx_o.mem = None
        _hx_o.hardware = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.debug = None
        _hx_o.drawTriangles = None
        _hx_o.drawCalls = None
        _hx_o.shaderSwitches = None
        _hx_o.backgroundColor = None
        _hx_o.autoResize = None
        _hx_o.fullScreen = None
        _hx_o.realFps = None
        _hx_o.lastTime = None
        _hx_o.antiAlias = None
        _hx_o.tmpVector = None
        _hx_o.window = None
        _hx_o.targetTmp = None
        _hx_o.targetStack = None
        _hx_o.currentTargetTex = None
        _hx_o.currentTargetLayer = None
        _hx_o.currentTargetMip = None
        _hx_o.needFlushTarget = None
        _hx_o.nullTexture = None
        _hx_o.textureColorCache = None
        _hx_o.inRender = None
        _hx_o.ready = None
        _hx_o.resCache = None
h3d_Engine._hx_class = h3d_Engine
_hx_classes["h3d.Engine"] = h3d_Engine


class h3d_Indexes:
    _hx_class_name = "h3d.Indexes"
    _hx_is_interface = "False"
    __slots__ = ("mem", "ibuf", "is32", "count")
    _hx_fields = ["mem", "ibuf", "is32", "count"]
    _hx_methods = ["isDisposed", "upload", "uploadBytes", "readBytes", "dispose"]
    _hx_statics = ["alloc"]

    def __init__(self,count,is32 = None):
        if (is32 is None):
            is32 = False
        self.ibuf = None
        self.mem = h3d_Engine.CURRENT.mem
        self.count = count
        self.is32 = is32
        self.mem.allocIndexes(self)

    def isDisposed(self):
        return (self.ibuf is None)

    def upload(self,indexes,pos,count,bufferPos = None):
        if (bufferPos is None):
            bufferPos = 0
        self.mem.driver.uploadIndexBuffer(self.ibuf,pos,count,indexes,bufferPos)

    def uploadBytes(self,_hx_bytes,dataPos,indices):
        self.mem.driver.uploadIndexBytes(self.ibuf,0,indices,_hx_bytes,dataPos)

    def readBytes(self,_hx_bytes,bytesPosition,indices,startIndice = None):
        if (startIndice is None):
            startIndice = 0
        self.mem.driver.readIndexBytes(self.ibuf,startIndice,indices,_hx_bytes,bytesPosition)

    def dispose(self):
        if (self.ibuf is not None):
            self.mem.deleteIndexes(self)

    @staticmethod
    def alloc(i,startPos = None,length = None):
        if (startPos is None):
            startPos = 0
        if (length is None):
            length = -1
        if (length < 0):
            length = len(i)
        idx = h3d_Indexes(length)
        idx.upload(i,0,length)
        return idx

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mem = None
        _hx_o.ibuf = None
        _hx_o.is32 = None
        _hx_o.count = None
h3d_Indexes._hx_class = h3d_Indexes
_hx_classes["h3d.Indexes"] = h3d_Indexes


class h3d_Matrix:
    _hx_class_name = "h3d.Matrix"
    _hx_is_interface = "False"
    __slots__ = ("_11", "_12", "_13", "_14", "_21", "_22", "_23", "_24", "_31", "_32", "_33", "_34", "_41", "_42", "_43", "_44")
    _hx_fields = ["_11", "_12", "_13", "_14", "_21", "_22", "_23", "_24", "_31", "_32", "_33", "_34", "_41", "_42", "_43", "_44"]
    _hx_methods = ["get_tx", "get_ty", "get_tz", "set_tx", "set_ty", "set_tz", "equal", "zero", "identity", "isIdentity", "isIdentityEpsilon", "initRotationX", "initRotationY", "initRotationZ", "initTranslation", "initScale", "initRotationAxis", "initRotation", "translate", "scale", "rotate", "rotateAxis", "getPosition", "setPosition", "prependTranslation", "getScale", "prependRotation", "prependRotationAxis", "prependScale", "multiply3x4", "multiply3x4inline", "multiply", "multiplyValue", "invert", "getInverse", "getDeterminant", "inverse3x4", "initInverse", "initInverse3x3", "front", "right", "up", "transpose", "clone", "load", "loadValues", "getFloats", "getDirection", "getEulerAngles", "toString", "colorHue", "colorSaturate", "colorContrast", "colorLightness", "colorGain", "colorBits", "colorAdd", "colorSet", "adjustColor", "toMatrix2D"]
    _hx_statics = ["tmp", "lumR", "lumG", "lumB", "SQ13", "I", "L", "T", "R", "S", "lookAtX"]

    def __init__(self):
        self._44 = None
        self._43 = None
        self._42 = None
        self._41 = None
        self._34 = None
        self._33 = None
        self._32 = None
        self._31 = None
        self._24 = None
        self._23 = None
        self._22 = None
        self._21 = None
        self._14 = None
        self._13 = None
        self._12 = None
        self._11 = None

    def get_tx(self):
        return self._41

    def get_ty(self):
        return self._42

    def get_tz(self):
        return self._43

    def set_tx(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self._41 = v
                return self._41
            return _hx_local_0()
        return _hx_local_1()

    def set_ty(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self._42 = v
                return self._42
            return _hx_local_0()
        return _hx_local_1()

    def set_tz(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self._43 = v
                return self._43
            return _hx_local_0()
        return _hx_local_1()

    def equal(self,other):
        if (((((((((((((((self._11 == other._11) and ((self._12 == other._12))) and ((self._13 == other._13))) and ((self._14 == other._14))) and ((self._21 == other._21))) and ((self._22 == other._22))) and ((self._23 == other._23))) and ((self._24 == other._24))) and ((self._31 == other._31))) and ((self._32 == other._32))) and ((self._33 == other._33))) and ((self._34 == other._34))) and ((self._41 == other._41))) and ((self._42 == other._42))) and ((self._43 == other._43))):
            return (self._44 == other._44)
        else:
            return False

    def zero(self):
        self._11 = 0.0
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = 0.0
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = 0.0
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 0.0

    def identity(self):
        self._11 = 1.0
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = 1.0
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = 1.0
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def isIdentity(self):
        if (((self._41 != 0) or ((self._42 != 0))) or ((self._43 != 0))):
            return False
        if (((self._11 != 1) or ((self._22 != 1))) or ((self._33 != 1))):
            return False
        if (((self._12 != 0) or ((self._13 != 0))) or ((self._14 != 0))):
            return False
        if (((self._21 != 0) or ((self._23 != 0))) or ((self._24 != 0))):
            return False
        if (((self._31 != 0) or ((self._32 != 0))) or ((self._34 != 0))):
            return False
        return (self._44 == 1)

    def isIdentityEpsilon(self,e):
        tmp = None
        tmp1 = None
        f = self._41
        if (not ((((-f if ((f < 0)) else f)) > e))):
            f = self._42
            tmp1 = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp1 = True
        if (not tmp1):
            f = self._43
            tmp = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp = True
        if tmp:
            return False
        tmp = None
        tmp1 = None
        f = (self._11 - 1)
        if (not ((((-f if ((f < 0)) else f)) > e))):
            f = (self._22 - 1)
            tmp1 = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp1 = True
        if (not tmp1):
            f = (self._33 - 1)
            tmp = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp = True
        if tmp:
            return False
        tmp = None
        tmp1 = None
        f = self._12
        if (not ((((-f if ((f < 0)) else f)) > e))):
            f = self._13
            tmp1 = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp1 = True
        if (not tmp1):
            f = self._14
            tmp = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp = True
        if tmp:
            return False
        tmp = None
        tmp1 = None
        f = self._21
        if (not ((((-f if ((f < 0)) else f)) > e))):
            f = self._23
            tmp1 = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp1 = True
        if (not tmp1):
            f = self._24
            tmp = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp = True
        if tmp:
            return False
        tmp = None
        tmp1 = None
        f = self._31
        if (not ((((-f if ((f < 0)) else f)) > e))):
            f = self._32
            tmp1 = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp1 = True
        if (not tmp1):
            f = self._34
            tmp = (((-f if ((f < 0)) else f)) > e)
        else:
            tmp = True
        if tmp:
            return False
        f = (self._44 - 1)
        return (((-f if ((f < 0)) else f)) <= e)

    def initRotationX(self,a):
        cos = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))
        sin = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))
        self._11 = 1.0
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = cos
        self._23 = sin
        self._24 = 0.0
        self._31 = 0.0
        self._32 = -sin
        self._33 = cos
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initRotationY(self,a):
        cos = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))
        sin = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))
        self._11 = cos
        self._12 = 0.0
        self._13 = -sin
        self._14 = 0.0
        self._21 = 0.0
        self._22 = 1.0
        self._23 = 0.0
        self._24 = 0.0
        self._31 = sin
        self._32 = 0.0
        self._33 = cos
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initRotationZ(self,a):
        cos = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))
        sin = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))
        self._11 = cos
        self._12 = sin
        self._13 = 0.0
        self._14 = 0.0
        self._21 = -sin
        self._22 = cos
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = 1.0
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initTranslation(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        self._11 = 1.0
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = 1.0
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = 1.0
        self._34 = 0.0
        self._41 = x
        self._42 = y
        self._43 = z
        self._44 = 1.0

    def initScale(self,x = None,y = None,z = None):
        if (x is None):
            x = 1.
        if (y is None):
            y = 1.
        if (z is None):
            z = 1.
        self._11 = x
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = y
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = z
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initRotationAxis(self,axis,angle):
        cos = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sin = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        cos1 = (1 - cos)
        x = -axis.x
        y = -axis.y
        z = -axis.z
        xx = (x * x)
        yy = (y * y)
        zz = (z * z)
        f = ((xx + yy) + zz)
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        x = (x * _hx_len)
        y = (y * _hx_len)
        z = (z * _hx_len)
        xcos1 = (x * cos1)
        zcos1 = (z * cos1)
        self._11 = (cos + ((x * xcos1)))
        self._12 = ((y * xcos1) - ((z * sin)))
        self._13 = ((x * zcos1) + ((y * sin)))
        self._14 = 0.
        self._21 = ((y * xcos1) + ((z * sin)))
        self._22 = (cos + (((y * y) * cos1)))
        self._23 = ((y * zcos1) - ((x * sin)))
        self._24 = 0.
        self._31 = ((x * zcos1) - ((y * sin)))
        self._32 = ((y * zcos1) + ((x * sin)))
        self._33 = (cos + ((z * zcos1)))
        self._34 = 0.
        self._41 = 0.
        self._42 = 0.
        self._43 = 0.
        self._44 = 1.

    def initRotation(self,x,y,z):
        cx = (Math.NaN if (((x == Math.POSITIVE_INFINITY) or ((x == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(x))
        sx = (Math.NaN if (((x == Math.POSITIVE_INFINITY) or ((x == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(x))
        cy = (Math.NaN if (((y == Math.POSITIVE_INFINITY) or ((y == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(y))
        sy = (Math.NaN if (((y == Math.POSITIVE_INFINITY) or ((y == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(y))
        cz = (Math.NaN if (((z == Math.POSITIVE_INFINITY) or ((z == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(z))
        sz = (Math.NaN if (((z == Math.POSITIVE_INFINITY) or ((z == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(z))
        cxsy = (cx * sy)
        sxsy = (sx * sy)
        self._11 = (cy * cz)
        self._12 = (cy * sz)
        self._13 = -sy
        self._14 = 0
        self._21 = ((sxsy * cz) - ((cx * sz)))
        self._22 = ((sxsy * sz) + ((cx * cz)))
        self._23 = (sx * cy)
        self._24 = 0
        self._31 = ((cxsy * cz) + ((sx * sz)))
        self._32 = ((cxsy * sz) - ((sx * cz)))
        self._33 = (cx * cy)
        self._34 = 0
        self._41 = 0
        self._42 = 0
        self._43 = 0
        self._44 = 1

    def translate(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 + ((x * self._14)))
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 + ((y * self._14)))
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 + ((z * self._14)))
        _hx_local_4._13
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._21
        _hx_local_6._21 = (_hx_local_7 + ((x * self._24)))
        _hx_local_6._21
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._22
        _hx_local_8._22 = (_hx_local_9 + ((y * self._24)))
        _hx_local_8._22
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._23
        _hx_local_10._23 = (_hx_local_11 + ((z * self._24)))
        _hx_local_10._23
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._31
        _hx_local_12._31 = (_hx_local_13 + ((x * self._34)))
        _hx_local_12._31
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._32
        _hx_local_14._32 = (_hx_local_15 + ((y * self._34)))
        _hx_local_14._32
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._33
        _hx_local_16._33 = (_hx_local_17 + ((z * self._34)))
        _hx_local_16._33
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._41
        _hx_local_18._41 = (_hx_local_19 + ((x * self._44)))
        _hx_local_18._41
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._42
        _hx_local_20._42 = (_hx_local_21 + ((y * self._44)))
        _hx_local_20._42
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._43
        _hx_local_22._43 = (_hx_local_23 + ((z * self._44)))
        _hx_local_22._43

    def scale(self,x = None,y = None,z = None):
        if (x is None):
            x = 1.
        if (y is None):
            y = 1.
        if (z is None):
            z = 1.
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * x)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._21
        _hx_local_2._21 = (_hx_local_3 * x)
        _hx_local_2._21
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._31
        _hx_local_4._31 = (_hx_local_5 * x)
        _hx_local_4._31
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._41
        _hx_local_6._41 = (_hx_local_7 * x)
        _hx_local_6._41
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._12
        _hx_local_8._12 = (_hx_local_9 * y)
        _hx_local_8._12
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._22
        _hx_local_10._22 = (_hx_local_11 * y)
        _hx_local_10._22
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._32
        _hx_local_12._32 = (_hx_local_13 * y)
        _hx_local_12._32
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._42
        _hx_local_14._42 = (_hx_local_15 * y)
        _hx_local_14._42
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._13
        _hx_local_16._13 = (_hx_local_17 * z)
        _hx_local_16._13
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._23
        _hx_local_18._23 = (_hx_local_19 * z)
        _hx_local_18._23
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._33
        _hx_local_20._33 = (_hx_local_21 * z)
        _hx_local_20._33
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._43
        _hx_local_22._43 = (_hx_local_23 * z)
        _hx_local_22._43

    def rotate(self,x,y,z):
        tmp = h3d_Matrix.tmp
        tmp.initRotation(x,y,z)
        self.multiply(self,tmp)

    def rotateAxis(self,axis,angle):
        tmp = h3d_Matrix.tmp
        tmp.initRotationAxis(axis,angle)
        self.multiply(self,tmp)

    def getPosition(self,v = None):
        if (v is None):
            v = h3d_Vector()
        x = self._41
        y = self._42
        z = self._43
        w = self._44
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v.x = x
        v.y = y
        v.z = z
        v.w = w
        return v

    def setPosition(self,v):
        self._41 = v.x
        self._42 = v.y
        self._43 = v.z
        self._44 = v.w

    def prependTranslation(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        vx = ((((self._11 * x) + ((self._21 * y))) + ((self._31 * z))) + self._41)
        vy = ((((self._12 * x) + ((self._22 * y))) + ((self._32 * z))) + self._42)
        vz = ((((self._13 * x) + ((self._23 * y))) + ((self._33 * z))) + self._43)
        vw = ((((self._14 * x) + ((self._24 * y))) + ((self._34 * z))) + self._44)
        self._41 = vx
        self._42 = vy
        self._43 = vz
        self._44 = vw

    def getScale(self,v = None):
        if (v is None):
            v = h3d_Vector()
        f = (((self._11 * self._11) + ((self._12 * self._12))) + ((self._13 * self._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((self._21 * self._21) + ((self._22 * self._22))) + ((self._23 * self._23)))
        v.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((self._31 * self._31) + ((self._32 * self._32))) + ((self._33 * self._33)))
        v.z = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if ((((self._11 * (((self._22 * self._33) - ((self._23 * self._32))))) + ((self._12 * (((self._23 * self._31) - ((self._21 * self._33))))))) + ((self._13 * (((self._21 * self._32) - ((self._22 * self._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        return v

    def prependRotation(self,x,y,z):
        tmp = h3d_Matrix.tmp
        tmp.initRotation(x,y,z)
        self.multiply(tmp,self)

    def prependRotationAxis(self,axis,angle):
        tmp = h3d_Matrix.tmp
        tmp.initRotationAxis(axis,angle)
        self.multiply(tmp,self)

    def prependScale(self,sx = None,sy = None,sz = None):
        if (sx is None):
            sx = 1.
        if (sy is None):
            sy = 1.
        if (sz is None):
            sz = 1.
        tmp = h3d_Matrix.tmp
        tmp.initScale(sx,sy,sz)
        self.multiply(tmp,self)

    def multiply3x4(self,a,b):
        m11 = a._11
        m12 = a._12
        m13 = a._13
        m21 = a._21
        m22 = a._22
        m23 = a._23
        a31 = a._31
        a32 = a._32
        a33 = a._33
        a41 = a._41
        a42 = a._42
        a43 = a._43
        b11 = b._11
        b12 = b._12
        b13 = b._13
        b21 = b._21
        b22 = b._22
        b23 = b._23
        b31 = b._31
        b32 = b._32
        b33 = b._33
        b41 = b._41
        b42 = b._42
        b43 = b._43
        self._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
        self._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
        self._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
        self._14 = 0
        self._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
        self._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
        self._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
        self._24 = 0
        self._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
        self._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
        self._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
        self._34 = 0
        self._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
        self._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
        self._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
        self._44 = 1

    def multiply3x4inline(self,a,b):
        m11 = a._11
        m12 = a._12
        m13 = a._13
        m21 = a._21
        m22 = a._22
        m23 = a._23
        a31 = a._31
        a32 = a._32
        a33 = a._33
        a41 = a._41
        a42 = a._42
        a43 = a._43
        b11 = b._11
        b12 = b._12
        b13 = b._13
        b21 = b._21
        b22 = b._22
        b23 = b._23
        b31 = b._31
        b32 = b._32
        b33 = b._33
        b41 = b._41
        b42 = b._42
        b43 = b._43
        self._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
        self._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
        self._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
        self._14 = 0
        self._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
        self._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
        self._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
        self._24 = 0
        self._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
        self._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
        self._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
        self._34 = 0
        self._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
        self._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
        self._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
        self._44 = 1

    def multiply(self,a,b):
        a11 = a._11
        a12 = a._12
        a13 = a._13
        a14 = a._14
        a21 = a._21
        a22 = a._22
        a23 = a._23
        a24 = a._24
        a31 = a._31
        a32 = a._32
        a33 = a._33
        a34 = a._34
        a41 = a._41
        a42 = a._42
        a43 = a._43
        a44 = a._44
        b11 = b._11
        b12 = b._12
        b13 = b._13
        b14 = b._14
        b21 = b._21
        b22 = b._22
        b23 = b._23
        b24 = b._24
        b31 = b._31
        b32 = b._32
        b33 = b._33
        b34 = b._34
        b41 = b._41
        b42 = b._42
        b43 = b._43
        b44 = b._44
        self._11 = ((((a11 * b11) + ((a12 * b21))) + ((a13 * b31))) + ((a14 * b41)))
        self._12 = ((((a11 * b12) + ((a12 * b22))) + ((a13 * b32))) + ((a14 * b42)))
        self._13 = ((((a11 * b13) + ((a12 * b23))) + ((a13 * b33))) + ((a14 * b43)))
        self._14 = ((((a11 * b14) + ((a12 * b24))) + ((a13 * b34))) + ((a14 * b44)))
        self._21 = ((((a21 * b11) + ((a22 * b21))) + ((a23 * b31))) + ((a24 * b41)))
        self._22 = ((((a21 * b12) + ((a22 * b22))) + ((a23 * b32))) + ((a24 * b42)))
        self._23 = ((((a21 * b13) + ((a22 * b23))) + ((a23 * b33))) + ((a24 * b43)))
        self._24 = ((((a21 * b14) + ((a22 * b24))) + ((a23 * b34))) + ((a24 * b44)))
        self._31 = ((((a31 * b11) + ((a32 * b21))) + ((a33 * b31))) + ((a34 * b41)))
        self._32 = ((((a31 * b12) + ((a32 * b22))) + ((a33 * b32))) + ((a34 * b42)))
        self._33 = ((((a31 * b13) + ((a32 * b23))) + ((a33 * b33))) + ((a34 * b43)))
        self._34 = ((((a31 * b14) + ((a32 * b24))) + ((a33 * b34))) + ((a34 * b44)))
        self._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + ((a44 * b41)))
        self._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + ((a44 * b42)))
        self._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + ((a44 * b43)))
        self._44 = ((((a41 * b14) + ((a42 * b24))) + ((a43 * b34))) + ((a44 * b44)))

    def multiplyValue(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * v)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * v)
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * v)
        _hx_local_4._13
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._14
        _hx_local_6._14 = (_hx_local_7 * v)
        _hx_local_6._14
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._21
        _hx_local_8._21 = (_hx_local_9 * v)
        _hx_local_8._21
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._22
        _hx_local_10._22 = (_hx_local_11 * v)
        _hx_local_10._22
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._23
        _hx_local_12._23 = (_hx_local_13 * v)
        _hx_local_12._23
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._24
        _hx_local_14._24 = (_hx_local_15 * v)
        _hx_local_14._24
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._31
        _hx_local_16._31 = (_hx_local_17 * v)
        _hx_local_16._31
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._32
        _hx_local_18._32 = (_hx_local_19 * v)
        _hx_local_18._32
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._33
        _hx_local_20._33 = (_hx_local_21 * v)
        _hx_local_20._33
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._34
        _hx_local_22._34 = (_hx_local_23 * v)
        _hx_local_22._34
        _hx_local_24 = self
        _hx_local_25 = _hx_local_24._41
        _hx_local_24._41 = (_hx_local_25 * v)
        _hx_local_24._41
        _hx_local_26 = self
        _hx_local_27 = _hx_local_26._42
        _hx_local_26._42 = (_hx_local_27 * v)
        _hx_local_26._42
        _hx_local_28 = self
        _hx_local_29 = _hx_local_28._43
        _hx_local_28._43 = (_hx_local_29 * v)
        _hx_local_28._43
        _hx_local_30 = self
        _hx_local_31 = _hx_local_30._44
        _hx_local_30._44 = (_hx_local_31 * v)
        _hx_local_30._44

    def invert(self):
        self.initInverse(self)

    def getInverse(self,m = None):
        if (m is None):
            m = h3d_Matrix()
        m.initInverse(self)
        return m

    def getDeterminant(self):
        return (((self._11 * (((self._22 * self._33) - ((self._23 * self._32))))) + ((self._12 * (((self._23 * self._31) - ((self._21 * self._33))))))) + ((self._13 * (((self._21 * self._32) - ((self._22 * self._31)))))))

    def inverse3x4(self,m):
        m11 = m._11
        m12 = m._12
        m13 = m._13
        m21 = m._21
        m22 = m._22
        m23 = m._23
        m31 = m._31
        m32 = m._32
        m33 = m._33
        m41 = m._41
        m42 = m._42
        m43 = m._43
        self._11 = ((m22 * m33) - ((m23 * m32)))
        self._12 = ((m13 * m32) - ((m12 * m33)))
        self._13 = ((m12 * m23) - ((m13 * m22)))
        self._14 = 0
        self._21 = ((m23 * m31) - ((m21 * m33)))
        self._22 = ((m11 * m33) - ((m13 * m31)))
        self._23 = ((m13 * m21) - ((m11 * m23)))
        self._24 = 0
        self._31 = ((m21 * m32) - ((m22 * m31)))
        self._32 = ((m12 * m31) - ((m11 * m32)))
        self._33 = ((m11 * m22) - ((m12 * m21)))
        self._34 = 0
        self._41 = (((((((-m21 * m32) * m43) + (((m21 * m33) * m42))) + (((m31 * m22) * m43))) - (((m31 * m23) * m42))) - (((m41 * m22) * m33))) + (((m41 * m23) * m32)))
        self._42 = (((((((m11 * m32) * m43) - (((m11 * m33) * m42))) - (((m31 * m12) * m43))) + (((m31 * m13) * m42))) + (((m41 * m12) * m33))) - (((m41 * m13) * m32)))
        self._43 = (((((((-m11 * m22) * m43) + (((m11 * m23) * m42))) + (((m21 * m12) * m43))) - (((m21 * m13) * m42))) - (((m41 * m12) * m23))) + (((m41 * m13) * m22)))
        self._44 = (((((((m11 * m22) * m33) - (((m11 * m23) * m32))) - (((m21 * m12) * m33))) + (((m21 * m13) * m32))) + (((m31 * m12) * m23))) - (((m31 * m13) * m22)))
        self._44 = 1
        det = (((m11 * self._11) + ((m12 * self._21))) + ((m13 * self._31)))
        if (((-det if ((det < 0)) else det)) < 1e-10):
            self.zero()
            return
        invDet = (1.0 / det)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * invDet)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * invDet)
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * invDet)
        _hx_local_4._13
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._21
        _hx_local_6._21 = (_hx_local_7 * invDet)
        _hx_local_6._21
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._22
        _hx_local_8._22 = (_hx_local_9 * invDet)
        _hx_local_8._22
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._23
        _hx_local_10._23 = (_hx_local_11 * invDet)
        _hx_local_10._23
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._31
        _hx_local_12._31 = (_hx_local_13 * invDet)
        _hx_local_12._31
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._32
        _hx_local_14._32 = (_hx_local_15 * invDet)
        _hx_local_14._32
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._33
        _hx_local_16._33 = (_hx_local_17 * invDet)
        _hx_local_16._33
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._41
        _hx_local_18._41 = (_hx_local_19 * invDet)
        _hx_local_18._41
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._42
        _hx_local_20._42 = (_hx_local_21 * invDet)
        _hx_local_20._42
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._43
        _hx_local_22._43 = (_hx_local_23 * invDet)
        _hx_local_22._43

    def initInverse(self,m):
        m11 = m._11
        m12 = m._12
        m13 = m._13
        m14 = m._14
        m21 = m._21
        m22 = m._22
        m23 = m._23
        m24 = m._24
        m31 = m._31
        m32 = m._32
        m33 = m._33
        m34 = m._34
        m41 = m._41
        m42 = m._42
        m43 = m._43
        m44 = m._44
        self._11 = (((((((m22 * m33) * m44) - (((m22 * m34) * m43))) - (((m32 * m23) * m44))) + (((m32 * m24) * m43))) + (((m42 * m23) * m34))) - (((m42 * m24) * m33)))
        self._12 = (((((((-m12 * m33) * m44) + (((m12 * m34) * m43))) + (((m32 * m13) * m44))) - (((m32 * m14) * m43))) - (((m42 * m13) * m34))) + (((m42 * m14) * m33)))
        self._13 = (((((((m12 * m23) * m44) - (((m12 * m24) * m43))) - (((m22 * m13) * m44))) + (((m22 * m14) * m43))) + (((m42 * m13) * m24))) - (((m42 * m14) * m23)))
        self._14 = (((((((-m12 * m23) * m34) + (((m12 * m24) * m33))) + (((m22 * m13) * m34))) - (((m22 * m14) * m33))) - (((m32 * m13) * m24))) + (((m32 * m14) * m23)))
        self._21 = (((((((-m21 * m33) * m44) + (((m21 * m34) * m43))) + (((m31 * m23) * m44))) - (((m31 * m24) * m43))) - (((m41 * m23) * m34))) + (((m41 * m24) * m33)))
        self._22 = (((((((m11 * m33) * m44) - (((m11 * m34) * m43))) - (((m31 * m13) * m44))) + (((m31 * m14) * m43))) + (((m41 * m13) * m34))) - (((m41 * m14) * m33)))
        self._23 = (((((((-m11 * m23) * m44) + (((m11 * m24) * m43))) + (((m21 * m13) * m44))) - (((m21 * m14) * m43))) - (((m41 * m13) * m24))) + (((m41 * m14) * m23)))
        self._24 = (((((((m11 * m23) * m34) - (((m11 * m24) * m33))) - (((m21 * m13) * m34))) + (((m21 * m14) * m33))) + (((m31 * m13) * m24))) - (((m31 * m14) * m23)))
        self._31 = (((((((m21 * m32) * m44) - (((m21 * m34) * m42))) - (((m31 * m22) * m44))) + (((m31 * m24) * m42))) + (((m41 * m22) * m34))) - (((m41 * m24) * m32)))
        self._32 = (((((((-m11 * m32) * m44) + (((m11 * m34) * m42))) + (((m31 * m12) * m44))) - (((m31 * m14) * m42))) - (((m41 * m12) * m34))) + (((m41 * m14) * m32)))
        self._33 = (((((((m11 * m22) * m44) - (((m11 * m24) * m42))) - (((m21 * m12) * m44))) + (((m21 * m14) * m42))) + (((m41 * m12) * m24))) - (((m41 * m14) * m22)))
        self._34 = (((((((-m11 * m22) * m34) + (((m11 * m24) * m32))) + (((m21 * m12) * m34))) - (((m21 * m14) * m32))) - (((m31 * m12) * m24))) + (((m31 * m14) * m22)))
        self._41 = (((((((-m21 * m32) * m43) + (((m21 * m33) * m42))) + (((m31 * m22) * m43))) - (((m31 * m23) * m42))) - (((m41 * m22) * m33))) + (((m41 * m23) * m32)))
        self._42 = (((((((m11 * m32) * m43) - (((m11 * m33) * m42))) - (((m31 * m12) * m43))) + (((m31 * m13) * m42))) + (((m41 * m12) * m33))) - (((m41 * m13) * m32)))
        self._43 = (((((((-m11 * m22) * m43) + (((m11 * m23) * m42))) + (((m21 * m12) * m43))) - (((m21 * m13) * m42))) - (((m41 * m12) * m23))) + (((m41 * m13) * m22)))
        self._44 = (((((((m11 * m22) * m33) - (((m11 * m23) * m32))) - (((m21 * m12) * m33))) + (((m21 * m13) * m32))) + (((m31 * m12) * m23))) - (((m31 * m13) * m22)))
        det = ((((m11 * self._11) + ((m12 * self._21))) + ((m13 * self._31))) + ((m14 * self._41)))
        if (((-det if ((det < 0)) else det)) < 1e-10):
            self.zero()
            return
        det = (1.0 / det)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * det)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * det)
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * det)
        _hx_local_4._13
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._14
        _hx_local_6._14 = (_hx_local_7 * det)
        _hx_local_6._14
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._21
        _hx_local_8._21 = (_hx_local_9 * det)
        _hx_local_8._21
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._22
        _hx_local_10._22 = (_hx_local_11 * det)
        _hx_local_10._22
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._23
        _hx_local_12._23 = (_hx_local_13 * det)
        _hx_local_12._23
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._24
        _hx_local_14._24 = (_hx_local_15 * det)
        _hx_local_14._24
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._31
        _hx_local_16._31 = (_hx_local_17 * det)
        _hx_local_16._31
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._32
        _hx_local_18._32 = (_hx_local_19 * det)
        _hx_local_18._32
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._33
        _hx_local_20._33 = (_hx_local_21 * det)
        _hx_local_20._33
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._34
        _hx_local_22._34 = (_hx_local_23 * det)
        _hx_local_22._34
        _hx_local_24 = self
        _hx_local_25 = _hx_local_24._41
        _hx_local_24._41 = (_hx_local_25 * det)
        _hx_local_24._41
        _hx_local_26 = self
        _hx_local_27 = _hx_local_26._42
        _hx_local_26._42 = (_hx_local_27 * det)
        _hx_local_26._42
        _hx_local_28 = self
        _hx_local_29 = _hx_local_28._43
        _hx_local_28._43 = (_hx_local_29 * det)
        _hx_local_28._43
        _hx_local_30 = self
        _hx_local_31 = _hx_local_30._44
        _hx_local_30._44 = (_hx_local_31 * det)
        _hx_local_30._44

    def initInverse3x3(self,m):
        m11 = m._11
        m12 = m._12
        m13 = m._13
        m21 = m._21
        m22 = m._22
        m23 = m._23
        m31 = m._31
        m32 = m._32
        m33 = m._33
        self._11 = ((m22 * m33) - ((m32 * m23)))
        self._12 = ((-m12 * m33) + ((m32 * m13)))
        self._13 = ((m12 * m23) - ((m22 * m13)))
        self._21 = ((-m21 * m33) + ((m31 * m23)))
        self._22 = ((m11 * m33) - ((m31 * m13)))
        self._23 = ((-m11 * m23) + ((m21 * m13)))
        self._31 = ((m21 * m32) - ((m31 * m22)))
        self._32 = ((-m11 * m32) + ((m31 * m12)))
        self._33 = ((m11 * m22) - ((m21 * m12)))
        det = (((m11 * self._11) + ((m12 * self._21))) + ((m13 * self._31)))
        if (((-det if ((det < 0)) else det)) < 1e-10):
            self.zero()
            return
        det = (1.0 / det)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * det)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * det)
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * det)
        _hx_local_4._13
        self._14 = 0
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._21
        _hx_local_6._21 = (_hx_local_7 * det)
        _hx_local_6._21
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._22
        _hx_local_8._22 = (_hx_local_9 * det)
        _hx_local_8._22
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._23
        _hx_local_10._23 = (_hx_local_11 * det)
        _hx_local_10._23
        self._24 = 0
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._31
        _hx_local_12._31 = (_hx_local_13 * det)
        _hx_local_12._31
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._32
        _hx_local_14._32 = (_hx_local_15 * det)
        _hx_local_14._32
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._33
        _hx_local_16._33 = (_hx_local_17 * det)
        _hx_local_16._33
        self._34 = 0
        self._41 = 0
        self._42 = 0
        self._43 = 0
        self._44 = 1

    def front(self):
        v = h3d_Vector(self._11,self._12,self._13)
        k = (((v.x * v.x) + ((v.y * v.y))) + ((v.z * v.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        v.x = (v.x * k)
        v.y = (v.y * k)
        v.z = (v.z * k)
        return v

    def right(self):
        v = h3d_Vector(self._21,self._22,self._23)
        k = (((v.x * v.x) + ((v.y * v.y))) + ((v.z * v.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        v.x = (v.x * k)
        v.y = (v.y * k)
        v.z = (v.z * k)
        return v

    def up(self):
        v = h3d_Vector(self._31,self._32,self._33)
        k = (((v.x * v.x) + ((v.y * v.y))) + ((v.z * v.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        v.x = (v.x * k)
        v.y = (v.y * k)
        v.z = (v.z * k)
        return v

    def transpose(self):
        tmp = self._12
        self._12 = self._21
        self._21 = tmp
        tmp = self._13
        self._13 = self._31
        self._31 = tmp
        tmp = self._14
        self._14 = self._41
        self._41 = tmp
        tmp = self._23
        self._23 = self._32
        self._32 = tmp
        tmp = self._24
        self._24 = self._42
        self._42 = tmp
        tmp = self._34
        self._34 = self._43
        self._43 = tmp

    def clone(self):
        m = h3d_Matrix()
        m._11 = self._11
        m._12 = self._12
        m._13 = self._13
        m._14 = self._14
        m._21 = self._21
        m._22 = self._22
        m._23 = self._23
        m._24 = self._24
        m._31 = self._31
        m._32 = self._32
        m._33 = self._33
        m._34 = self._34
        m._41 = self._41
        m._42 = self._42
        m._43 = self._43
        m._44 = self._44
        return m

    def load(self,m):
        self._11 = m._11
        self._12 = m._12
        self._13 = m._13
        self._14 = m._14
        self._21 = m._21
        self._22 = m._22
        self._23 = m._23
        self._24 = m._24
        self._31 = m._31
        self._32 = m._32
        self._33 = m._33
        self._34 = m._34
        self._41 = m._41
        self._42 = m._42
        self._43 = m._43
        self._44 = m._44

    def loadValues(self,a):
        self._11 = (a[0] if 0 < len(a) else None)
        self._12 = (a[1] if 1 < len(a) else None)
        self._13 = (a[2] if 2 < len(a) else None)
        self._14 = (a[3] if 3 < len(a) else None)
        self._21 = (a[4] if 4 < len(a) else None)
        self._22 = (a[5] if 5 < len(a) else None)
        self._23 = (a[6] if 6 < len(a) else None)
        self._24 = (a[7] if 7 < len(a) else None)
        self._31 = (a[8] if 8 < len(a) else None)
        self._32 = (a[9] if 9 < len(a) else None)
        self._33 = (a[10] if 10 < len(a) else None)
        self._34 = (a[11] if 11 < len(a) else None)
        self._41 = (a[12] if 12 < len(a) else None)
        self._42 = (a[13] if 13 < len(a) else None)
        self._43 = (a[14] if 14 < len(a) else None)
        self._44 = (a[15] if 15 < len(a) else None)

    def getFloats(self):
        return [self._11, self._12, self._13, self._14, self._21, self._22, self._23, self._24, self._31, self._32, self._33, self._34, self._41, self._42, self._43, self._44]

    def getDirection(self):
        q = h3d_Quat()
        q.initRotateMatrix(self)
        q.normalize()
        return h3d_Vector((1 - ((2 * (((q.y * q.y) + ((q.z * q.z))))))),(2 * (((q.x * q.y) + ((q.z * q.w))))),(2 * (((q.x * q.z) - ((q.y * q.w))))))

    def getEulerAngles(self):
        m = self.clone()
        v = None
        if (v is None):
            v = h3d_Vector()
        f = (((self._11 * self._11) + ((self._12 * self._12))) + ((self._13 * self._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((self._21 * self._21) + ((self._22 * self._22))) + ((self._23 * self._23)))
        v.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((self._31 * self._31) + ((self._32 * self._32))) + ((self._33 * self._33)))
        v.z = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if ((((self._11 * (((self._22 * self._33) - ((self._23 * self._32))))) + ((self._12 * (((self._23 * self._31) - ((self._21 * self._33))))))) + ((self._13 * (((self._21 * self._32) - ((self._22 * self._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        s = v
        m.prependScale((1.0 / s.x),(1.0 / s.y),(1.0 / s.z))
        f = ((m._11 * m._11) + ((m._12 * m._12)))
        cy = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if (cy > 0.01):
            v1 = h3d_Vector(Math.atan2(m._23,m._33),Math.atan2(-m._13,cy),Math.atan2(m._12,m._11))
            v2 = h3d_Vector(Math.atan2(-m._23,-m._33),Math.atan2(-m._13,-cy),Math.atan2(-m._12,-m._11))
            if ((((v1.x * v1.x) + ((v1.y * v1.y))) + ((v1.z * v1.z))) < ((((v2.x * v2.x) + ((v2.y * v2.y))) + ((v2.z * v2.z))))):
                return v1
            else:
                return v2
        else:
            return h3d_Vector(Math.atan2(-m._32,m._22),Math.atan2(-m._13,cy),0.0)

    def toString(self):
        return ((((((((((((((((((((((((((((((((((((("MAT=[\n" + "  [ ") + Std.string(hxd_Math.fmt(self._11))) + ", ") + Std.string(hxd_Math.fmt(self._12))) + ", ") + Std.string(hxd_Math.fmt(self._13))) + ", ") + Std.string(hxd_Math.fmt(self._14))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self._21))) + ", ") + Std.string(hxd_Math.fmt(self._22))) + ", ") + Std.string(hxd_Math.fmt(self._23))) + ", ") + Std.string(hxd_Math.fmt(self._24))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self._31))) + ", ") + Std.string(hxd_Math.fmt(self._32))) + ", ") + Std.string(hxd_Math.fmt(self._33))) + ", ") + Std.string(hxd_Math.fmt(self._34))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self._41))) + ", ") + Std.string(hxd_Math.fmt(self._42))) + ", ") + Std.string(hxd_Math.fmt(self._43))) + ", ") + Std.string(hxd_Math.fmt(self._44))) + " ]\n") + "]")

    def colorHue(self,hue):
        if (hue == 0.):
            return
        f = -hue
        cosA = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        f = -hue
        sinA = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        ch = (((1 - cosA)) / 3)
        tmp = h3d_Matrix.tmp
        tmp._11 = (cosA + ch)
        tmp._12 = (ch - ((0.57735026918962576450914878050196 * sinA)))
        tmp._13 = (ch + ((0.57735026918962576450914878050196 * sinA)))
        tmp._21 = (ch + ((0.57735026918962576450914878050196 * sinA)))
        tmp._22 = (cosA + ch)
        tmp._23 = (ch - ((0.57735026918962576450914878050196 * sinA)))
        tmp._31 = (ch - ((0.57735026918962576450914878050196 * sinA)))
        tmp._32 = (ch + ((0.57735026918962576450914878050196 * sinA)))
        tmp._33 = (cosA + ch)
        tmp._34 = 0
        tmp._41 = 0
        tmp._42 = 0
        tmp._43 = 0
        self.multiply3x4(self,tmp)

    def colorSaturate(self,sat):
        sat = (sat + 1)
        ins = (1 - sat)
        r = (ins * 0.212671)
        g = (ins * 0.71516)
        b = (ins * 0.072169)
        tmp = h3d_Matrix.tmp
        tmp._11 = (r + sat)
        tmp._12 = r
        tmp._13 = r
        tmp._21 = g
        tmp._22 = (g + sat)
        tmp._23 = g
        tmp._31 = b
        tmp._32 = b
        tmp._33 = (b + sat)
        tmp._41 = 0
        tmp._42 = 0
        tmp._43 = 0
        self.multiply3x4(self,tmp)

    def colorContrast(self,contrast):
        tmp = h3d_Matrix.tmp
        v = (contrast + 1)
        tmp._11 = v
        tmp._12 = 0
        tmp._13 = 0
        tmp._21 = 0
        tmp._22 = v
        tmp._23 = 0
        tmp._31 = 0
        tmp._32 = 0
        tmp._33 = v
        tmp._41 = (-contrast * 0.5)
        tmp._42 = (-contrast * 0.5)
        tmp._43 = (-contrast * 0.5)
        self.multiply3x4(self,tmp)

    def colorLightness(self,lightness):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._41
        _hx_local_0._41 = (_hx_local_1 + lightness)
        _hx_local_0._41
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._42
        _hx_local_2._42 = (_hx_local_3 + lightness)
        _hx_local_2._42
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._43
        _hx_local_4._43 = (_hx_local_5 + lightness)
        _hx_local_4._43

    def colorGain(self,color,alpha):
        tmp = h3d_Matrix.tmp
        tmp._11 = (1 - alpha)
        tmp._12 = 0
        tmp._13 = 0
        tmp._21 = 0
        tmp._22 = (1 - alpha)
        tmp._23 = 0
        tmp._31 = 0
        tmp._32 = 0
        tmp._33 = (1 - alpha)
        tmp._41 = (((((color >> 16) & 255)) / 255) * alpha)
        tmp._42 = (((((color >> 8) & 255)) / 255) * alpha)
        tmp._43 = ((((color & 255)) / 255) * alpha)
        self.multiply3x4(self,tmp)

    def colorBits(self,bits,blend):
        t11 = 0.
        t12 = 0.
        t13 = 0.
        t21 = 0.
        t22 = 0.
        t23 = 0.
        t31 = 0.
        t32 = 0.
        t33 = 0.
        c = bits
        if (((c & 1)) == 1):
            t11 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t12 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t13 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t21 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t22 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t23 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t31 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t32 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t33 = 1
        c = (c >> 1)
        r = ((t11 + t21) + t31)
        g = ((t12 + t22) + t32)
        b = ((t13 + t23) + t33)
        if (r > 1):
            t11 = (t11 / r)
            t21 = (t21 / r)
            t31 = (t31 / r)
        if (g > 1):
            t12 = (t12 / g)
            t22 = (t22 / g)
            t32 = (t32 / g)
        if (b > 1):
            t13 = (t13 / b)
            t23 = (t23 / b)
            t33 = (t33 / b)
        b11 = (((self._11 * t11) + ((self._12 * t21))) + ((self._13 * t31)))
        b12 = (((self._11 * t12) + ((self._12 * t22))) + ((self._13 * t32)))
        b13 = (((self._11 * t13) + ((self._12 * t23))) + ((self._13 * t33)))
        b21 = (((self._21 * t11) + ((self._22 * t21))) + ((self._23 * t31)))
        b22 = (((self._21 * t12) + ((self._22 * t22))) + ((self._23 * t32)))
        b23 = (((self._21 * t13) + ((self._22 * t23))) + ((self._23 * t33)))
        b31 = (((self._31 * t11) + ((self._32 * t21))) + ((self._33 * t31)))
        b32 = (((self._31 * t12) + ((self._32 * t22))) + ((self._33 * t32)))
        b33 = (((self._31 * t13) + ((self._32 * t23))) + ((self._33 * t33)))
        ik = blend
        k = (1 - ik)
        self._11 = ((self._11 * k) + ((b11 * ik)))
        self._12 = ((self._12 * k) + ((b12 * ik)))
        self._13 = ((self._13 * k) + ((b13 * ik)))
        self._21 = ((self._21 * k) + ((b21 * ik)))
        self._22 = ((self._22 * k) + ((b22 * ik)))
        self._23 = ((self._23 * k) + ((b23 * ik)))
        self._31 = ((self._31 * k) + ((b31 * ik)))
        self._32 = ((self._32 * k) + ((b32 * ik)))
        self._33 = ((self._33 * k) + ((b33 * ik)))

    def colorAdd(self,c):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._41
        _hx_local_0._41 = (_hx_local_1 + (((((c >> 16) & 255)) / 255)))
        _hx_local_0._41
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._42
        _hx_local_2._42 = (_hx_local_3 + (((((c >> 8) & 255)) / 255)))
        _hx_local_2._42
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._43
        _hx_local_4._43 = (_hx_local_5 + ((((c & 255)) / 255)))
        _hx_local_4._43

    def colorSet(self,c,alpha = None):
        if (alpha is None):
            alpha = 1.
        self.zero()
        self._44 = alpha
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._41
        _hx_local_0._41 = (_hx_local_1 + (((((c >> 16) & 255)) / 255)))
        _hx_local_0._41
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._42
        _hx_local_2._42 = (_hx_local_3 + (((((c >> 8) & 255)) / 255)))
        _hx_local_2._42
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._43
        _hx_local_4._43 = (_hx_local_5 + ((((c & 255)) / 255)))
        _hx_local_4._43

    def adjustColor(self,col):
        if (Reflect.field(col,"hue") is not None):
            self.colorHue(Reflect.field(col,"hue"))
        if (Reflect.field(col,"saturation") is not None):
            self.colorSaturate(Reflect.field(col,"saturation"))
        if (Reflect.field(col,"contrast") is not None):
            self.colorContrast(Reflect.field(col,"contrast"))
        if (Reflect.field(col,"lightness") is not None):
            self.colorLightness(Reflect.field(col,"lightness"))
        if (Reflect.field(col,"gain") is not None):
            self.colorGain(Reflect.field(col,"gain").color,Reflect.field(col,"gain").alpha)

    def toMatrix2D(self,m = None):
        if (m is None):
            m = h2d_col_Matrix()
        m.a = self._11
        m.b = self._12
        m.c = self._21
        m.d = self._22
        m.x = self._41
        m.y = self._42
        return m

    @staticmethod
    def I():
        m = h3d_Matrix()
        m.identity()
        return m

    @staticmethod
    def L(a):
        m = h3d_Matrix()
        m.loadValues(a)
        return m

    @staticmethod
    def T(x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        m = h3d_Matrix()
        m.initTranslation(x,y,z)
        return m

    @staticmethod
    def R(x,y,z):
        m = h3d_Matrix()
        m.initRotation(x,y,z)
        return m

    @staticmethod
    def S(x = None,y = None,z = None):
        if (x is None):
            x = 1.
        if (y is None):
            y = 1.
        if (z is None):
            z = 1.0
        m = h3d_Matrix()
        m.initScale(x,y,z)
        return m

    @staticmethod
    def lookAtX(dir,up = None,m = None):
        if (up is None):
            up = h3d_Vector(0,0,1)
        if (m is None):
            m = h3d_Matrix()
        k = (((dir.x * dir.x) + ((dir.y * dir.y))) + ((dir.z * dir.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        x = (dir.x * k)
        y = (dir.y * k)
        z = (dir.z * k)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ax_x = x
        ax_y = y
        ax_z = z
        ax_w = 1.
        x = ((up.y * ax_z) - ((up.z * ax_y)))
        y = ((up.z * ax_x) - ((up.x * ax_z)))
        z = ((up.x * ax_y) - ((up.y * ax_x)))
        w = 1
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this_x = x
        _this_y = y
        _this_z = z
        _this_w = w
        k = (((_this_x * _this_x) + ((_this_y * _this_y))) + ((_this_z * _this_z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        x = (_this_x * k)
        y = (_this_y * k)
        z = (_this_z * k)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ay_x = x
        ay_y = y
        ay_z = z
        ay_w = 1.
        if ((((ay_x * ay_x) + ((ay_y * ay_y))) + ((ay_z * ay_z))) < 1e-10):
            ay_x = ax_y
            ay_y = ax_z
            ay_z = ax_x
        x = ((ax_y * ay_z) - ((ax_z * ay_y)))
        y = ((ax_z * ay_x) - ((ax_x * ay_z)))
        z = ((ax_x * ay_y) - ((ax_y * ay_x)))
        w = 1
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        az_x = x
        az_y = y
        az_z = z
        az_w = w
        m._11 = ax_x
        m._12 = ax_y
        m._13 = ax_z
        m._14 = 0
        m._21 = ay_x
        m._22 = ay_y
        m._23 = ay_z
        m._24 = 0
        m._31 = az_x
        m._32 = az_y
        m._33 = az_z
        m._34 = 0
        m._41 = 0
        m._42 = 0
        m._43 = 0
        m._44 = 1
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._11 = None
        _hx_o._12 = None
        _hx_o._13 = None
        _hx_o._14 = None
        _hx_o._21 = None
        _hx_o._22 = None
        _hx_o._23 = None
        _hx_o._24 = None
        _hx_o._31 = None
        _hx_o._32 = None
        _hx_o._33 = None
        _hx_o._34 = None
        _hx_o._41 = None
        _hx_o._42 = None
        _hx_o._43 = None
        _hx_o._44 = None
h3d_Matrix._hx_class = h3d_Matrix
_hx_classes["h3d.Matrix"] = h3d_Matrix


class h3d_Quat:
    _hx_class_name = "h3d.Quat"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "w")
    _hx_fields = ["x", "y", "z", "w"]
    _hx_methods = ["set", "identity", "lengthSq", "length", "load", "clone", "initMoveTo", "initNormal", "initDirection", "initRotateAxis", "initRotateMatrix", "normalize", "initRotation", "multiply", "toEuler", "lerp", "slerp", "conjugate", "negate", "dot", "getDirection", "toMatrix", "toString"]

    def __init__(self,x = None,y = None,z = None,w = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (w is None):
            w = 1.
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def set(self,x,y,z,w):
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def identity(self):
        def _hx_local_1():
            def _hx_local_0():
                self.z = 0
                return self.z
            self.y = _hx_local_0()
            return self.y
        self.x = _hx_local_1()
        self.w = 1

    def lengthSq(self):
        return ((((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z))) + ((self.w * self.w)))

    def length(self):
        f = ((((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z))) + ((self.w * self.w)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def load(self,q):
        self.x = q.x
        self.y = q.y
        self.z = q.z
        self.w = q.w

    def clone(self):
        return h3d_Quat(self.x,self.y,self.z,self.w)

    def initMoveTo(self,_hx_from,to):
        hx = (_hx_from.x + to.x)
        hy = (_hx_from.y + to.y)
        hz = (_hx_from.z + to.z)
        f = (((hx * hx) + ((hy * hy))) + ((hz * hz)))
        h = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        self.x = ((_hx_from.y * hz) - ((_hx_from.z * hy)))
        self.y = ((_hx_from.z * hx) - ((_hx_from.x * hz)))
        self.z = ((_hx_from.x * hy) - ((_hx_from.y * hx)))
        self.w = (((_hx_from.x * hx) + ((_hx_from.y * hy))) + ((_hx_from.z * hz)))
        self.normalize()

    def initNormal(self,dir):
        k = (((dir.x * dir.x) + ((dir.y * dir.y))) + ((dir.z * dir.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        x = (dir.x * k)
        y = (dir.y * k)
        z = (dir.z * k)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        dir_x = x
        dir_y = y
        dir_z = z
        if (((dir_x * dir_x) + ((dir_y * dir_y))) < 1e-10):
            self.initDirection(h3d_Vector(1,0,0))
        else:
            x = dir_x
            y = dir_y
            z = 0
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this_x = x
            _this_y = y
            _this_z = z
            k = (((_this_x * _this_x) + ((_this_y * _this_y))) + ((_this_z * _this_z)))
            if (k < 1e-10):
                k = 0
            else:
                k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
            x = (_this_x * k)
            y = (_this_y * k)
            z = (_this_z * k)
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            ay_x = x
            ay_y = y
            ay_z = z
            x = ((dir_y * ay_z) - ((dir_z * ay_y)))
            y = ((dir_z * ay_x) - ((dir_x * ay_z)))
            z = ((dir_x * ay_y) - ((dir_y * ay_x)))
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            az_x = x
            az_y = y
            az_z = z
            x = ((dir_y * az_z) - ((dir_z * az_y)))
            y = ((dir_z * az_x) - ((dir_x * az_z)))
            z = ((dir_x * az_y) - ((dir_y * az_x)))
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this_x = x
            _this_y = y
            _this_z = z
            self.initDirection(h3d_Vector(_this_x,_this_y,_this_z))

    def initDirection(self,dir):
        x = dir.x
        y = dir.y
        z = dir.z
        w = dir.w
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this_x = x
        _this_y = y
        _this_z = z
        _this_w = w
        k = (((_this_x * _this_x) + ((_this_y * _this_y))) + ((_this_z * _this_z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        x = (_this_x * k)
        y = (_this_y * k)
        z = (_this_z * k)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ax_x = x
        ax_y = y
        ax_z = z
        ax_w = 1.
        x = -ax_y
        y = ax_x
        z = 0
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this_x = x
        _this_y = y
        _this_z = z
        _this_w = 1.
        k = (((_this_x * _this_x) + ((_this_y * _this_y))) + ((_this_z * _this_z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        x = (_this_x * k)
        y = (_this_y * k)
        z = (_this_z * k)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ay_x = x
        ay_y = y
        ay_z = z
        ay_w = 1.
        if ((((ay_x * ay_x) + ((ay_y * ay_y))) + ((ay_z * ay_z))) < 1e-10):
            ay_x = ax_y
            ay_y = ax_z
            ay_z = ax_x
        x = ((ax_y * ay_z) - ((ax_z * ay_y)))
        y = ((ax_z * ay_x) - ((ax_x * ay_z)))
        z = ((ax_x * ay_y) - ((ax_y * ay_x)))
        w = 1
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        az_x = x
        az_y = y
        az_z = z
        az_w = w
        tr = ((ax_x + ay_y) + az_z)
        if (tr > 0):
            f = (tr + 1.0)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (((ay_z - az_y)) * ins)
            self.y = (((az_x - ax_z)) * ins)
            self.z = (((ax_y - ay_x)) * ins)
            self.w = (0.25 * s)
        elif ((ax_x > ay_y) and ((ax_x > az_z))):
            f = (((1.0 + ax_x) - ay_y) - az_z)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (0.25 * s)
            self.y = (((ay_x + ax_y)) * ins)
            self.z = (((az_x + ax_z)) * ins)
            self.w = (((ay_z - az_y)) * ins)
        elif (ay_y > az_z):
            f = (((1.0 + ay_y) - ax_x) - az_z)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (((ay_x + ax_y)) * ins)
            self.y = (0.25 * s)
            self.z = (((az_y + ay_z)) * ins)
            self.w = (((az_x - ax_z)) * ins)
        else:
            f = (((1.0 + az_z) - ax_x) - ay_y)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (((az_x + ax_z)) * ins)
            self.y = (((az_y + ay_z)) * ins)
            self.z = (0.25 * s)
            self.w = (((ax_y - ay_x)) * ins)

    def initRotateAxis(self,x,y,z,a):
        f = (a / 2)
        sin = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        f = (a / 2)
        cos = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        self.x = (x * sin)
        self.y = (y * sin)
        self.z = (z * sin)
        f = (((x * x) + ((y * y))) + ((z * z)))
        self.w = (cos * ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        self.normalize()

    def initRotateMatrix(self,m):
        tr = ((m._11 + m._22) + m._33)
        if (tr > 0):
            f = (tr + 1.0)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (((m._23 - m._32)) * ins)
            self.y = (((m._31 - m._13)) * ins)
            self.z = (((m._12 - m._21)) * ins)
            self.w = (0.25 * s)
        elif ((m._11 > m._22) and ((m._11 > m._33))):
            f = (((1.0 + m._11) - m._22) - m._33)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (0.25 * s)
            self.y = (((m._21 + m._12)) * ins)
            self.z = (((m._31 + m._13)) * ins)
            self.w = (((m._23 - m._32)) * ins)
        elif (m._22 > m._33):
            f = (((1.0 + m._22) - m._11) - m._33)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (((m._21 + m._12)) * ins)
            self.y = (0.25 * s)
            self.z = (((m._32 + m._23)) * ins)
            self.w = (((m._31 - m._13)) * ins)
        else:
            f = (((1.0 + m._33) - m._11) - m._22)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            ins = (1 / s)
            self.x = (((m._31 + m._13)) * ins)
            self.y = (((m._32 + m._23)) * ins)
            self.z = (0.25 * s)
            self.w = (((m._12 - m._21)) * ins)

    def normalize(self):
        _hx_len = ((((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z))) + ((self.w * self.w)))
        if (_hx_len < 1e-10):
            def _hx_local_1():
                def _hx_local_0():
                    self.z = 0
                    return self.z
                self.y = _hx_local_0()
                return self.y
            self.x = _hx_local_1()
            self.w = 1
        else:
            m = (1. / ((Math.NaN if ((_hx_len < 0)) else python_lib_Math.sqrt(_hx_len))))
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.x
            _hx_local_2.x = (_hx_local_3 * m)
            _hx_local_2.x
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.y
            _hx_local_4.y = (_hx_local_5 * m)
            _hx_local_4.y
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.z
            _hx_local_6.z = (_hx_local_7 * m)
            _hx_local_6.z
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.w
            _hx_local_8.w = (_hx_local_9 * m)
            _hx_local_8.w

    def initRotation(self,ax,ay,az):
        f = (ax * 0.5)
        sinX = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        f = (ax * 0.5)
        cosX = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        f = (ay * 0.5)
        sinY = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        f = (ay * 0.5)
        cosY = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        f = (az * 0.5)
        sinZ = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        f = (az * 0.5)
        cosZ = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        cosYZ = (cosY * cosZ)
        sinYZ = (sinY * sinZ)
        self.x = ((sinX * cosYZ) - ((cosX * sinYZ)))
        self.y = (((cosX * sinY) * cosZ) + (((sinX * cosY) * sinZ)))
        self.z = (((cosX * cosY) * sinZ) - (((sinX * sinY) * cosZ)))
        self.w = ((cosX * cosYZ) + ((sinX * sinYZ)))

    def multiply(self,q1,q2):
        x2 = ((((q1.x * q2.w) + ((q1.w * q2.x))) + ((q1.y * q2.z))) - ((q1.z * q2.y)))
        y2 = ((((q1.w * q2.y) - ((q1.x * q2.z))) + ((q1.y * q2.w))) + ((q1.z * q2.x)))
        z2 = ((((q1.w * q2.z) + ((q1.x * q2.y))) - ((q1.y * q2.x))) + ((q1.z * q2.w)))
        w2 = ((((q1.w * q2.w) - ((q1.x * q2.x))) - ((q1.y * q2.y))) - ((q1.z * q2.z)))
        self.x = x2
        self.y = y2
        self.z = z2
        self.w = w2

    def toEuler(self):
        return self.toMatrix().getEulerAngles()

    def lerp(self,q1,q2,v,nearest = None):
        if (nearest is None):
            nearest = False
        v2 = (1 - v)
        if (nearest and ((((((q1.x * q2.x) + ((q1.y * q2.y))) + ((q1.z * q2.z))) + ((q1.w * q2.w))) < 0))):
            v = -v
        x = ((q1.x * v2) + ((q2.x * v)))
        y = ((q1.y * v2) + ((q2.y * v)))
        z = ((q1.z * v2) + ((q2.z * v)))
        w = ((q1.w * v2) + ((q2.w * v)))
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def slerp(self,q1,q2,v):
        cosHalfTheta = ((((q1.x * q2.x) + ((q1.y * q2.y))) + ((q1.z * q2.z))) + ((q1.w * q2.w)))
        if (((-cosHalfTheta if ((cosHalfTheta < 0)) else cosHalfTheta)) >= 1):
            self.x = q1.x
            self.y = q1.y
            self.z = q1.z
            self.w = q1.w
            return
        halfTheta = Math.acos(cosHalfTheta)
        f = (1 - ((cosHalfTheta * cosHalfTheta)))
        invSinHalfTheta = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        if (((-invSinHalfTheta if ((invSinHalfTheta < 0)) else invSinHalfTheta)) > 1e3):
            v1 = 0.5
            nearest = True
            if (nearest is None):
                nearest = False
            v2 = (1 - v1)
            if (nearest and ((((((q1.x * q2.x) + ((q1.y * q2.y))) + ((q1.z * q2.z))) + ((q1.w * q2.w))) < 0))):
                v1 = -v1
            x = ((q1.x * v2) + ((q2.x * v1)))
            y = ((q1.y * v2) + ((q2.y * v1)))
            z = ((q1.z * v2) + ((q2.z * v1)))
            w = ((q1.w * v2) + ((q2.w * v1)))
            self.x = x
            self.y = y
            self.z = z
            self.w = w
            return
        f = (((1 - v)) * halfTheta)
        a = (((Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))) * invSinHalfTheta)
        f = (v * halfTheta)
        b = ((((Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))) * invSinHalfTheta) * ((-1 if ((cosHalfTheta < 0)) else 1)))
        self.x = ((q1.x * a) + ((q2.x * b)))
        self.y = ((q1.y * a) + ((q2.y * b)))
        self.z = ((q1.z * a) + ((q2.z * b)))
        self.w = ((q1.w * a) + ((q2.w * b)))

    def conjugate(self):
        self.x = -self.x
        self.y = -self.y
        self.z = -self.z

    def negate(self):
        self.x = -self.x
        self.y = -self.y
        self.z = -self.z
        self.w = -self.w

    def dot(self,q):
        return ((((self.x * q.x) + ((self.y * q.y))) + ((self.z * q.z))) + ((self.w * q.w)))

    def getDirection(self):
        return h3d_Vector((1 - ((2 * (((self.y * self.y) + ((self.z * self.z))))))),(2 * (((self.x * self.y) + ((self.z * self.w))))),(2 * (((self.x * self.z) - ((self.y * self.w))))))

    def toMatrix(self,m = None):
        if (m is None):
            m = h3d_Matrix()
        xx = (self.x * self.x)
        xy = (self.x * self.y)
        xz = (self.x * self.z)
        xw = (self.x * self.w)
        yy = (self.y * self.y)
        yz = (self.y * self.z)
        yw = (self.y * self.w)
        zz = (self.z * self.z)
        zw = (self.z * self.w)
        m._11 = (1 - ((2 * ((yy + zz)))))
        m._12 = (2 * ((xy + zw)))
        m._13 = (2 * ((xz - yw)))
        m._14 = 0
        m._21 = (2 * ((xy - zw)))
        m._22 = (1 - ((2 * ((xx + zz)))))
        m._23 = (2 * ((yz + xw)))
        m._24 = 0
        m._31 = (2 * ((xz + yw)))
        m._32 = (2 * ((yz - xw)))
        m._33 = (1 - ((2 * ((xx + yy)))))
        m._34 = 0
        m._41 = 0
        m._42 = 0
        m._43 = 0
        m._44 = 1
        return m

    def toString(self):
        return (((((((("{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.z))) + ",") + Std.string(hxd_Math.fmt(self.w))) + "}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.w = None
h3d_Quat._hx_class = h3d_Quat
_hx_classes["h3d.Quat"] = h3d_Quat


class h3d_Vector:
    _hx_class_name = "h3d.Vector"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "w")
    _hx_fields = ["x", "y", "z", "w"]
    _hx_methods = ["distance", "distanceSq", "sub", "add", "multiply", "equals", "cross", "dot", "lengthSq", "length", "normalize", "normalized", "set", "load", "scale", "lerp", "transform", "transformed", "transform3x4", "transformed3x4", "transform3x3", "transformed3x3", "clone", "toPoint", "toString", "reflect", "dot4", "project", "get_r", "get_g", "get_b", "get_a", "set_r", "set_g", "set_b", "set_a", "setColor", "makeColor", "toColor", "toColorHSL", "scale3", "dot3", "normalizeFast"]
    _hx_statics = ["fromColor", "fromArray"]

    def __init__(self,x = None,y = None,z = None,w = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (w is None):
            w = 1.
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def distance(self,v):
        dx = (v.x - self.x)
        dy = (v.y - self.y)
        dz = (v.z - self.z)
        f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def distanceSq(self,v):
        dx = (v.x - self.x)
        dy = (v.y - self.y)
        dz = (v.z - self.z)
        return (((dx * dx) + ((dy * dy))) + ((dz * dz)))

    def sub(self,v):
        return h3d_Vector((self.x - v.x),(self.y - v.y),(self.z - v.z),(self.w - v.w))

    def add(self,v):
        return h3d_Vector((self.x + v.x),(self.y + v.y),(self.z + v.z),(self.w + v.w))

    def multiply(self,v):
        return h3d_Vector((self.x * v),(self.y * v),(self.z * v),self.w)

    def equals(self,v):
        if (((self.x == v.x) and ((self.y == v.y))) and ((self.z == v.z))):
            return (self.w == v.w)
        else:
            return False

    def cross(self,v):
        return h3d_Vector(((self.y * v.z) - ((self.z * v.y))),((self.z * v.x) - ((self.x * v.z))),((self.x * v.y) - ((self.y * v.x))),1)

    def dot(self,v):
        return (((self.x * v.x) + ((self.y * v.y))) + ((self.z * v.z)))

    def lengthSq(self):
        return (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))

    def length(self):
        f = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def normalize(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * k)
        _hx_local_4.z

    def normalized(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        return h3d_Vector((self.x * k),(self.y * k),(self.z * k))

    def set(self,x = None,y = None,z = None,w = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (w is None):
            w = 1.
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def load(self,v):
        self.x = v.x
        self.y = v.y
        self.z = v.z
        self.w = v.w

    def scale(self,f):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * f)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * f)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * f)
        _hx_local_4.z

    def lerp(self,v1,v2,k):
        a = v1.x
        self.x = (a + ((k * ((v2.x - a)))))
        a = v1.y
        self.y = (a + ((k * ((v2.y - a)))))
        a = v1.z
        self.z = (a + ((k * ((v2.z - a)))))
        a = v1.w
        self.w = (a + ((k * ((v2.w - a)))))

    def transform(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + ((self.w * m._41)))
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + ((self.w * m._42)))
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + ((self.w * m._43)))
        pw = ((((self.x * m._14) + ((self.y * m._24))) + ((self.z * m._34))) + ((self.w * m._44)))
        self.x = px
        self.y = py
        self.z = pz
        self.w = pw

    def transformed(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + ((self.w * m._41)))
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + ((self.w * m._42)))
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + ((self.w * m._43)))
        pw = ((((self.x * m._14) + ((self.y * m._24))) + ((self.z * m._34))) + ((self.w * m._44)))
        return h3d_Vector(px,py,pz,pw)

    def transform3x4(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + ((self.w * m._41)))
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + ((self.w * m._42)))
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + ((self.w * m._43)))
        self.x = px
        self.y = py
        self.z = pz

    def transformed3x4(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + ((self.w * m._41)))
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + ((self.w * m._42)))
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + ((self.w * m._43)))
        return h3d_Vector(px,py,pz)

    def transform3x3(self,m):
        px = (((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31)))
        py = (((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32)))
        pz = (((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33)))
        self.x = px
        self.y = py
        self.z = pz

    def transformed3x3(self,m):
        px = (((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31)))
        py = (((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32)))
        pz = (((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33)))
        return h3d_Vector(px,py,pz)

    def clone(self):
        return h3d_Vector(self.x,self.y,self.z,self.w)

    def toPoint(self):
        return h3d_col_Point(self.x,self.y,self.z)

    def toString(self):
        return (((((((("{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.z))) + ",") + Std.string(hxd_Math.fmt(self.w))) + "}")

    def reflect(self,n):
        k = (2 * ((((self.x * n.x) + ((self.y * n.y))) + ((self.z * n.z)))))
        return h3d_Vector((self.x - ((k * n.x))),(self.y - ((k * n.y))),(self.z - ((k * n.z))),1)

    def dot4(self,v):
        return ((((self.x * v.x) + ((self.y * v.y))) + ((self.z * v.z))) + ((self.w * v.w)))

    def project(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + ((self.w * m._41)))
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + ((self.w * m._42)))
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + ((self.w * m._43)))
        iw = (1 / (((((self.x * m._14) + ((self.y * m._24))) + ((self.z * m._34))) + ((self.w * m._44)))))
        self.x = (px * iw)
        self.y = (py * iw)
        self.z = (pz * iw)
        self.w = 1

    def get_r(self):
        return self.x

    def get_g(self):
        return self.y

    def get_b(self):
        return self.z

    def get_a(self):
        return self.w

    def set_r(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.x = v
                return self.x
            return _hx_local_0()
        return _hx_local_1()

    def set_g(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.y = v
                return self.y
            return _hx_local_0()
        return _hx_local_1()

    def set_b(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.z = v
                return self.z
            return _hx_local_0()
        return _hx_local_1()

    def set_a(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.w = v
                return self.w
            return _hx_local_0()
        return _hx_local_1()

    def setColor(self,c):
        self.x = ((((c >> 16) & 255)) / 255)
        self.y = ((((c >> 8) & 255)) / 255)
        self.z = (((c & 255)) / 255)
        self.w = ((HxOverrides.rshift(c, 24)) / 255)

    def makeColor(self,hue,saturation = None,brightness = None):
        if (saturation is None):
            saturation = 1.
        if (brightness is None):
            brightness = 0.5
        r = HxOverrides.modf(hue, 6.28318530717958623)
        hue = (r if ((r >= 0)) else (r + 6.28318530717958623))
        f = ((2 * brightness) - 1)
        c = (((1 - ((-f if ((f < 0)) else f)))) * saturation)
        f = (HxOverrides.modf(((hue * 3) / 3.14159265358979323), 2.) - 1)
        x = (c * ((1 - ((-f if ((f < 0)) else f)))))
        m = (brightness - ((c / 2)))
        if (hue < 1.04719755119659763):
            self.x = c
            self.y = x
            self.z = 0
        elif (hue < 2.09439510239319526):
            self.x = x
            self.y = c
            self.z = 0
        elif (hue < 3.14159265358979323):
            self.x = 0
            self.y = c
            self.z = x
        elif (hue < 4.18879020478639053):
            self.x = 0
            self.y = x
            self.z = c
        elif (hue < 5.23598775598298882):
            self.x = x
            self.y = 0
            self.z = c
        else:
            self.x = c
            self.y = 0
            self.z = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + m)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + m)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 + m)
        _hx_local_4.z
        self.w = 1

    def toColor(self):
        f = self.w
        x = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        tmp1 = (tmp << 24)
        f = self.x
        x = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        tmp2 = (tmp1 | ((tmp << 16)))
        f = self.y
        x = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        tmp1 = (tmp2 | ((tmp << 8)))
        f = self.z
        x = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        return (tmp1 | tmp)

    def toColorHSL(self):
        a = self.x
        b = self.y
        a1 = (b if ((a < b)) else a)
        b = self.z
        _hx_max = (b if ((a1 < b)) else a1)
        a = self.x
        b = self.y
        a1 = (b if ((a > b)) else a)
        b = self.z
        _hx_min = (b if ((a1 > b)) else a1)
        h = None
        s = None
        l = (((_hx_max + _hx_min)) / 2.0)
        if (_hx_max == _hx_min):
            s = 0.0
            h = s
        else:
            d = (_hx_max - _hx_min)
            s = ((d / (((2 - _hx_max) - _hx_min))) if ((l > 0.5)) else (d / ((_hx_max + _hx_min))))
            if (_hx_max == self.x):
                h = ((((self.y - self.z)) / d) + ((6.0 if ((self.y < self.z)) else 0.0)))
            elif (_hx_max == self.y):
                h = ((((self.z - self.x)) / d) + 2.0)
            else:
                h = ((((self.x - self.y)) / d) + 4.0)
            h = (h * 1.04719755119659763)
        return h3d_Vector(h,s,l,self.w)

    def scale3(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * v)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * v)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * v)
        _hx_local_4.z

    def dot3(self,v):
        return (((self.x * v.x) + ((self.y * v.y))) + ((self.z * v.z)))

    def normalizeFast(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * k)
        _hx_local_4.z

    @staticmethod
    def fromColor(c,scale = None):
        if (scale is None):
            scale = 1.0
        s = (scale / 255)
        return h3d_Vector(((((c >> 16) & 255)) * s),((((c >> 8) & 255)) * s),(((c & 255)) * s),((HxOverrides.rshift(c, 24)) * s))

    @staticmethod
    def fromArray(a):
        r = h3d_Vector()
        if (len(a) > 0):
            r.x = (a[0] if 0 < len(a) else None)
        if (len(a) > 1):
            r.y = (a[1] if 1 < len(a) else None)
        if (len(a) > 2):
            r.z = (a[2] if 2 < len(a) else None)
        if (len(a) > 3):
            r.w = (a[3] if 3 < len(a) else None)
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.w = None
h3d_Vector._hx_class = h3d_Vector
_hx_classes["h3d.Vector"] = h3d_Vector


class h3d_anim_AnimatedObject:
    _hx_class_name = "h3d.anim.AnimatedObject"
    _hx_is_interface = "False"
    __slots__ = ("objectName", "targetObject", "targetSkin", "targetJoint")
    _hx_fields = ["objectName", "targetObject", "targetSkin", "targetJoint"]
    _hx_methods = ["clone"]

    def __init__(self,name):
        self.targetJoint = None
        self.targetSkin = None
        self.targetObject = None
        self.objectName = name

    def clone(self):
        return h3d_anim_AnimatedObject(self.objectName)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.objectName = None
        _hx_o.targetObject = None
        _hx_o.targetSkin = None
        _hx_o.targetJoint = None
h3d_anim_AnimatedObject._hx_class = h3d_anim_AnimatedObject
_hx_classes["h3d.anim.AnimatedObject"] = h3d_anim_AnimatedObject


class h3d_anim_Animation:
    _hx_class_name = "h3d.anim.Animation"
    _hx_is_interface = "False"
    __slots__ = ("name", "resourcePath", "frameCount", "sampling", "frame", "speed", "onAnimEnd", "onEvent", "pause", "loop", "events", "isInstance", "objects", "isSync", "lastEvent")
    _hx_fields = ["name", "resourcePath", "frameCount", "sampling", "frame", "speed", "onAnimEnd", "onEvent", "pause", "loop", "events", "isInstance", "objects", "isSync", "lastEvent"]
    _hx_methods = ["getDuration", "frameToTime", "getIFrame", "unbind", "setEvents", "addEvent", "getEvents", "getObjects", "getEventTime", "setFrame", "clone", "initInstance", "createInstance", "bind", "getPropValue", "sync", "isPlaying", "endFrame", "update", "initAndBind", "toString"]
    _hx_statics = ["EPSILON"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,name,frameCount,sampling):
        self.isSync = None
        self.isInstance = None
        self.events = None
        self.onEvent = None
        self.onAnimEnd = None
        self.resourcePath = None
        self.name = name
        self.frameCount = frameCount
        self.sampling = sampling
        self.objects = []
        self.lastEvent = -1
        self.frame = 0.
        self.speed = 1.
        self.loop = True
        self.pause = False

    def getDuration(self):
        return (self.frameCount / ((self.sampling * self.speed)))

    def frameToTime(self,f):
        return (f / ((self.sampling * self.speed)))

    def getIFrame(self):
        x = self.frame
        f = None
        try:
            f = int(x)
        except BaseException as _g:
            None
            f = None
        _hx_max = self.endFrame()
        if (f == _hx_max):
            f = (f - 1)
        return f

    def unbind(self,objectName):
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (o.objectName == objectName):
                self.isSync = False
                o.targetObject = None
                o.targetSkin = None
                return

    def setEvents(self,el):
        _g = []
        _g1 = 0
        _g2 = self.frameCount
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append(None)
        self.events = _g
        e = HxOverrides.iterator(el)
        while e.hasNext():
            e1 = e.next()
            if (python_internal_ArrayImpl._get(self.events, e1.frame) is None):
                python_internal_ArrayImpl._set(self.events, e1.frame, [])
            _this = python_internal_ArrayImpl._get(self.events, e1.frame)
            x = e1.data
            _this.append(x)

    def addEvent(self,frame,data):
        if (self.events is None):
            self.events = []
        if ((self.events[frame] if frame >= 0 and frame < len(self.events) else None) is None):
            python_internal_ArrayImpl._set(self.events, frame, [data])
        else:
            _this = (self.events[frame] if frame >= 0 and frame < len(self.events) else None)
            _this.append(data)

    def getEvents(self):
        return self.events

    def getObjects(self):
        return self.objects

    def getEventTime(self,id):
        if (self.events is None):
            return None
        _g = 0
        _g1 = len(self.events)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            ev = (self.events[i] if i >= 0 and i < len(self.events) else None)
            if ((ev is not None) and ((python_internal_ArrayImpl.indexOf(ev,id,None) >= 0))):
                return (i / ((self.sampling * self.speed)))
        return None

    def setFrame(self,f):
        self.frame = f
        self.lastEvent = -1
        while (self.frame < 0):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.frame
            _hx_local_0.frame = (_hx_local_1 + self.frameCount)
            _hx_local_0.frame
        while (self.frame > self.frameCount):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.frame
            _hx_local_2.frame = (_hx_local_3 - self.frameCount)
            _hx_local_2.frame

    def clone(self,a = None):
        if (a is None):
            a = h3d_anim_Animation(self.name,self.frameCount,self.sampling)
        a.objects = self.objects
        a.speed = self.speed
        a.loop = self.loop
        a.pause = self.pause
        a.events = self.events
        a.resourcePath = self.resourcePath
        return a

    def initInstance(self):
        self.isInstance = True

    def createInstance(self,base):
        _g = []
        _g1 = 0
        _g2 = self.objects
        while (_g1 < len(_g2)):
            a = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = a.clone()
            _g.append(x)
        objects = _g
        a = self.clone()
        a.objects = objects
        a.bind(base)
        a.initInstance()
        return a

    def bind(self,base):
        currentSkin = None
        _g = 0
        _g1 = list(self.objects)
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (currentSkin is not None):
                j = currentSkin.skinData.namedJoints.h.get(a.objectName,None)
                if (j is not None):
                    a.targetSkin = currentSkin
                    a.targetJoint = j.index
                    continue
            obj = base.getObjectByName(a.objectName)
            if (obj is None):
                python_internal_ArrayImpl.remove(self.objects,a)
                continue
            joint = Std.downcast(obj,h3d_scene_Joint)
            if (joint is not None):
                currentSkin = joint.parent
                a.targetSkin = currentSkin
                a.targetJoint = joint.index
            else:
                a.targetObject = obj
        self.isSync = False

    def getPropValue(self,objectName,propName):
        return None

    def sync(self,decompose = None):
        if (decompose is None):
            decompose = False
        raise haxe_Exception.thrown("assert")

    def isPlaying(self):
        if (not self.pause):
            return (((-self.speed if ((self.speed < 0)) else self.speed)) > 0.000001)
        else:
            return False

    def endFrame(self):
        return self.frameCount

    def update(self,dt):
        if (not self.isInstance):
            raise haxe_Exception.thrown("You must instanciate this animation first")
        if (not self.isPlaying()):
            return 0
        if ((self.events is not None) and ((self.onEvent is not None))):
            x = self.frame
            f0 = None
            try:
                f0 = int(x)
            except BaseException as _g:
                None
                f0 = None
            x = (self.frame + (((dt * self.speed) * self.sampling)))
            f1 = None
            try:
                f1 = int(x)
            except BaseException as _g:
                None
                f1 = None
            if (f1 >= self.frameCount):
                f1 = (self.frameCount - 1)
            _g = f0
            _g1 = (f1 + 1)
            while (_g < _g1):
                f = _g
                _g = (_g + 1)
                if (f == self.lastEvent):
                    continue
                self.lastEvent = f
                if ((self.events[f] if f >= 0 and f < len(self.events) else None) is not None):
                    oldF = self.frame
                    oldDT = dt
                    dt = (dt - ((((f - self.frame)) / ((self.speed * self.sampling)))))
                    self.frame = f
                    _g2 = 0
                    _g3 = (self.events[f] if f >= 0 and f < len(self.events) else None)
                    while (_g2 < len(_g3)):
                        e = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                        _g2 = (_g2 + 1)
                        self.onEvent(e)
                    if ((self.frame == f) and ((f == ((self.frameCount - 1))))):
                        self.frame = oldF
                        dt = oldDT
                        break
                    else:
                        return dt
        if (self.onAnimEnd is not None):
            end = self.endFrame()
            et = (0 if ((self.speed == 0)) else (((end - self.frame)) / ((self.speed * self.sampling))))
            if ((et <= dt) and ((et > 0))):
                self.frame = end
                dt = (dt - et)
                self.onAnimEnd()
                if ((self.frame == end) and self.isPlaying()):
                    if self.loop:
                        self.frame = 0
                    else:
                        dt = 0
                return dt
        _hx_local_3 = self
        _hx_local_4 = _hx_local_3.frame
        _hx_local_3.frame = (_hx_local_4 + (((dt * self.speed) * self.sampling)))
        _hx_local_3.frame
        if (self.frame >= self.frameCount):
            if self.loop:
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.frame
                _hx_local_5.frame = HxOverrides.modf(_hx_local_6, self.frameCount)
                _hx_local_5.frame
            else:
                self.frame = self.frameCount
        return 0

    def initAndBind(self,obj):
        self.bind(obj)
        self.initInstance()
        self.pause = True

    def toString(self):
        return self.name

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.resourcePath = None
        _hx_o.frameCount = None
        _hx_o.sampling = None
        _hx_o.frame = None
        _hx_o.speed = None
        _hx_o.onAnimEnd = None
        _hx_o.onEvent = None
        _hx_o.pause = None
        _hx_o.loop = None
        _hx_o.events = None
        _hx_o.isInstance = None
        _hx_o.objects = None
        _hx_o.isSync = None
        _hx_o.lastEvent = None
h3d_anim_Animation._hx_class = h3d_anim_Animation
_hx_classes["h3d.anim.Animation"] = h3d_anim_Animation

class h3d_anim_DataLayout(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.anim.DataLayout"
    _hx_constructs = ["Position", "Rotation", "Scale", "UV", "Alpha", "Property", "SingleFrame"]
h3d_anim_DataLayout.Position = h3d_anim_DataLayout("Position", 0, ())
h3d_anim_DataLayout.Rotation = h3d_anim_DataLayout("Rotation", 1, ())
h3d_anim_DataLayout.Scale = h3d_anim_DataLayout("Scale", 2, ())
h3d_anim_DataLayout.UV = h3d_anim_DataLayout("UV", 3, ())
h3d_anim_DataLayout.Alpha = h3d_anim_DataLayout("Alpha", 4, ())
h3d_anim_DataLayout.Property = h3d_anim_DataLayout("Property", 5, ())
h3d_anim_DataLayout.SingleFrame = h3d_anim_DataLayout("SingleFrame", 6, ())
h3d_anim_DataLayout._hx_class = h3d_anim_DataLayout
_hx_classes["h3d.anim.DataLayout"] = h3d_anim_DataLayout


class h3d_anim_BufferObject(h3d_anim_AnimatedObject):
    _hx_class_name = "h3d.anim.BufferObject"
    _hx_is_interface = "False"
    __slots__ = ("layout", "dataOffset", "propCurrentValue", "propName", "matrix")
    _hx_fields = ["layout", "dataOffset", "propCurrentValue", "propName", "matrix"]
    _hx_methods = ["getStride", "clone"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_AnimatedObject


    def __init__(self,objectName,dataOffset):
        self.matrix = None
        self.propName = None
        self.propCurrentValue = None
        self.dataOffset = None
        self.layout = None
        super().__init__(objectName)
        self.dataOffset = dataOffset

    def getStride(self):
        stride = 0
        if (((self.layout & ((1 << h3d_anim_DataLayout.Position.index)))) != 0):
            stride = (stride + 3)
        if (((self.layout & ((1 << h3d_anim_DataLayout.Rotation.index)))) != 0):
            stride = (stride + 3)
        if (((self.layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0):
            stride = (stride + 3)
        if (((self.layout & ((1 << h3d_anim_DataLayout.UV.index)))) != 0):
            stride = (stride + 2)
        if (((self.layout & ((1 << h3d_anim_DataLayout.Alpha.index)))) != 0):
            stride = (stride + 1)
        if (((self.layout & ((1 << h3d_anim_DataLayout.Property.index)))) != 0):
            stride = (stride + 1)
        return stride

    def clone(self):
        o = h3d_anim_BufferObject(self.objectName,self.dataOffset)
        o.layout = self.layout
        o.propName = self.propName
        return o

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.layout = None
        _hx_o.dataOffset = None
        _hx_o.propCurrentValue = None
        _hx_o.propName = None
        _hx_o.matrix = None
h3d_anim_BufferObject._hx_class = h3d_anim_BufferObject
_hx_classes["h3d.anim.BufferObject"] = h3d_anim_BufferObject


class h3d_anim_BufferAnimation(h3d_anim_Animation):
    _hx_class_name = "h3d.anim.BufferAnimation"
    _hx_is_interface = "False"
    __slots__ = ("syncFrame", "data", "stride")
    _hx_fields = ["syncFrame", "data", "stride"]
    _hx_methods = ["setData", "addObject", "getPropValue", "getFrames", "clone", "endFrame", "initInstance", "sortByFrameCountDesc", "uvLerp", "sync"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_Animation


    def __init__(self,name,frame,sampling):
        self.stride = None
        self.data = None
        self.syncFrame = None
        super().__init__(name,frame,sampling)
        self.syncFrame = -1

    def setData(self,data,stride):
        self.data = data
        self.stride = stride

    def addObject(self,objName,offset):
        f = h3d_anim_BufferObject(objName,offset)
        _this = self.objects
        _this.append(f)
        return f

    def getPropValue(self,objName,propName):
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((o.objectName == objName) and ((o.propName == propName))):
                return o.propCurrentValue
        return None

    def getFrames(self):
        return self.objects

    def clone(self,a = None):
        if (a is None):
            a = h3d_anim_BufferAnimation(self.name,self.frameCount,self.sampling)
        super().clone(a)
        la = Std.downcast(a,h3d_anim_BufferAnimation)
        la.setData(self.data,self.stride)
        return a

    def endFrame(self):
        if self.loop:
            return self.frameCount
        else:
            return (self.frameCount - 1)

    def initInstance(self):
        super().initInstance()
        frames = self.objects
        _g = 0
        while (_g < len(frames)):
            a = (frames[_g] if _g >= 0 and _g < len(frames) else None)
            _g = (_g + 1)
            if (((a.layout & ((1 << h3d_anim_DataLayout.Property.index)))) != 0):
                a.propCurrentValue = self.data[a.dataOffset]
            if ((((a.layout & ((1 << h3d_anim_DataLayout.Alpha.index)))) != 0) and (((a.targetObject is None) or ((Std.downcast(a.targetObject,h3d_scene_Mesh) is None))))):
                raise haxe_Exception.thrown((HxOverrides.stringOrNull(a.objectName) + " should be a mesh (for alpha animation)"))
            if (((((a.layout & ((1 << h3d_anim_DataLayout.Position.index)))) != 0) or ((((a.layout & ((1 << h3d_anim_DataLayout.Rotation.index)))) != 0))) or ((((a.layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0))):
                a.matrix = h3d_Matrix()
                a.matrix.identity()
                if ((((a.layout & ((1 << h3d_anim_DataLayout.Position.index)))) == 0) and ((a.targetSkin is not None))):
                    m2 = python_internal_ArrayImpl._get(a.targetSkin.getSkinData().allJoints, a.targetJoint).defMat
                    a.matrix._14 = m2._41
                    a.matrix._24 = m2._42
                    a.matrix._34 = m2._43
        frames.sort(key= python_lib_Functools.cmp_to_key(self.sortByFrameCountDesc))

    def sortByFrameCountDesc(self,o1,o2):
        return (((0 if ((((o2.layout & ((1 << h3d_anim_DataLayout.SingleFrame.index)))) != 0)) else 1)) - ((0 if ((((o1.layout & ((1 << h3d_anim_DataLayout.SingleFrame.index)))) != 0)) else 1)))

    def uvLerp(self,v1,v2,k):
        v1 = HxOverrides.modf(v1, 1.)
        v2 = HxOverrides.modf(v2, 1.)
        if (v1 < ((v2 - 0.5))):
            v1 = (v1 + 1)
        elif (v1 > ((v2 + 0.5))):
            v1 = (v1 - 1)
        return ((v1 * ((1 - k))) + ((v2 * k)))

    def sync(self,decompose = None):
        if (decompose is None):
            decompose = False
        _gthis = self
        if ((self.frame == self.syncFrame) and (not decompose)):
            return
        x = self.frame
        f = None
        try:
            f = int(x)
        except BaseException as _g:
            None
            f = None
        _hx_max = self.endFrame()
        if (f == _hx_max):
            f = (f - 1)
        frame1 = f
        frame2 = HxOverrides.mod(((frame1 + 1)), self.frameCount)
        k2 = (self.frame - frame1)
        k1 = (1 - k2)
        if (frame1 < 0):
            frame2 = 0
            frame1 = frame2
        elif (self.frame >= self.frameCount):
            frame2 = (self.frameCount - 1)
            frame1 = frame2
        elif ((not self.loop) and ((frame2 == 0))):
            frame2 = (self.frameCount - 1)
        self.syncFrame = self.frame
        if decompose:
            self.isSync = False
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((o.targetObject is None) and ((o.targetSkin is None))):
                continue
            layout = o.layout
            offset1 = ((self.stride * frame1) + o.dataOffset)
            offset2 = ((self.stride * frame2) + o.dataOffset)
            frame11 = frame1
            frame21 = frame2
            if (((layout & ((1 << h3d_anim_DataLayout.SingleFrame.index)))) != 0):
                if self.isSync:
                    break
                frame21 = 0
                frame11 = frame21
                offset2 = o.dataOffset
                offset1 = offset2
            m = o.matrix
            if (m is not None):
                if (((layout & ((1 << h3d_anim_DataLayout.Position.index)))) != 0):
                    index = offset1
                    offset1 = (offset1 + 1)
                    index1 = offset2
                    offset2 = (offset2 + 1)
                    m._41 = ((_gthis.data[index] * k1) + ((_gthis.data[index1] * k2)))
                    index2 = offset1
                    offset1 = (offset1 + 1)
                    index3 = offset2
                    offset2 = (offset2 + 1)
                    m._42 = ((_gthis.data[index2] * k1) + ((_gthis.data[index3] * k2)))
                    index4 = offset1
                    offset1 = (offset1 + 1)
                    index5 = offset2
                    offset2 = (offset2 + 1)
                    m._43 = ((_gthis.data[index4] * k1) + ((_gthis.data[index5] * k2)))
                else:
                    m._41 = m._14
                    m._42 = m._24
                    m._43 = m._34
                if (((layout & ((1 << h3d_anim_DataLayout.Rotation.index)))) != 0):
                    index6 = offset1
                    offset1 = (offset1 + 1)
                    q1x = self.data[index6]
                    index7 = offset1
                    offset1 = (offset1 + 1)
                    q1y = self.data[index7]
                    index8 = offset1
                    offset1 = (offset1 + 1)
                    q1z = self.data[index8]
                    f = (1 - ((((q1x * q1x) + ((q1y * q1y))) + ((q1z * q1z)))))
                    v = (-f if ((f < 0)) else f)
                    q1w = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
                    index9 = offset2
                    offset2 = (offset2 + 1)
                    q2x = self.data[index9]
                    index10 = offset2
                    offset2 = (offset2 + 1)
                    q2y = self.data[index10]
                    index11 = offset2
                    offset2 = (offset2 + 1)
                    q2z = self.data[index11]
                    f1 = (1 - ((((q2x * q2x) + ((q2y * q2y))) + ((q2z * q2z)))))
                    v1 = (-f1 if ((f1 < 0)) else f1)
                    q2w = (Math.NaN if ((v1 < 0)) else python_lib_Math.sqrt(v1))
                    dot = ((((q1x * q2x) + ((q1y * q2y))) + ((q1z * q2z))) + ((q1w * q2w)))
                    q2 = (-k2 if ((dot < 0)) else k2)
                    qx = ((q1x * k1) + ((q2x * q2)))
                    qy = ((q1y * k1) + ((q2y * q2)))
                    qz = ((q1z * k1) + ((q2z * q2)))
                    qw = ((q1w * k1) + ((q2w * q2)))
                    v2 = ((((qx * qx) + ((qy * qy))) + ((qz * qz))) + ((qw * qw)))
                    ql = (1 / ((Math.NaN if ((v2 < 0)) else python_lib_Math.sqrt(v2))))
                    qx = (qx * ql)
                    qy = (qy * ql)
                    qz = (qz * ql)
                    qw = (qw * ql)
                    if decompose:
                        m._12 = qx
                        m._13 = qy
                        m._21 = qz
                        m._23 = qw
                        if (((layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0):
                            index12 = offset1
                            offset1 = (offset1 + 1)
                            index13 = offset2
                            offset2 = (offset2 + 1)
                            m._11 = ((_gthis.data[index12] * k1) + ((_gthis.data[index13] * k2)))
                            index14 = offset1
                            offset1 = (offset1 + 1)
                            index15 = offset2
                            offset2 = (offset2 + 1)
                            m._22 = ((_gthis.data[index14] * k1) + ((_gthis.data[index15] * k2)))
                            index16 = offset1
                            offset1 = (offset1 + 1)
                            index17 = offset2
                            offset2 = (offset2 + 1)
                            m._33 = ((_gthis.data[index16] * k1) + ((_gthis.data[index17] * k2)))
                        else:
                            m._11 = 1
                            m._22 = 1
                            m._33 = 1
                    else:
                        xx = (qx * qx)
                        xy = (qx * qy)
                        xz = (qx * qz)
                        xw = (qx * qw)
                        yy = (qy * qy)
                        yz = (qy * qz)
                        yw = (qy * qw)
                        zz = (qz * qz)
                        zw = (qz * qw)
                        m._11 = (1 - ((2 * ((yy + zz)))))
                        m._12 = (2 * ((xy + zw)))
                        m._13 = (2 * ((xz - yw)))
                        m._21 = (2 * ((xy - zw)))
                        m._22 = (1 - ((2 * ((xx + zz)))))
                        m._23 = (2 * ((yz + xw)))
                        m._31 = (2 * ((xz + yw)))
                        m._32 = (2 * ((yz - xw)))
                        m._33 = (1 - ((2 * ((xx + yy)))))
                        if (((layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0):
                            index18 = offset1
                            offset1 = (offset1 + 1)
                            index19 = offset2
                            offset2 = (offset2 + 1)
                            sx = ((_gthis.data[index18] * k1) + ((_gthis.data[index19] * k2)))
                            index20 = offset1
                            offset1 = (offset1 + 1)
                            index21 = offset2
                            offset2 = (offset2 + 1)
                            sy = ((_gthis.data[index20] * k1) + ((_gthis.data[index21] * k2)))
                            index22 = offset1
                            offset1 = (offset1 + 1)
                            index23 = offset2
                            offset2 = (offset2 + 1)
                            sz = ((_gthis.data[index22] * k1) + ((_gthis.data[index23] * k2)))
                            m._11 = (m._11 * sx)
                            m._12 = (m._12 * sx)
                            m._13 = (m._13 * sx)
                            m._21 = (m._21 * sy)
                            m._22 = (m._22 * sy)
                            m._23 = (m._23 * sy)
                            m._31 = (m._31 * sz)
                            m._32 = (m._32 * sz)
                            m._33 = (m._33 * sz)
                else:
                    m._12 = 0
                    m._13 = 0
                    m._21 = 0
                    m._23 = (1 if decompose else 0)
                    if (((layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0):
                        index24 = offset1
                        offset1 = (offset1 + 1)
                        index25 = offset2
                        offset2 = (offset2 + 1)
                        m._11 = ((_gthis.data[index24] * k1) + ((_gthis.data[index25] * k2)))
                        index26 = offset1
                        offset1 = (offset1 + 1)
                        index27 = offset2
                        offset2 = (offset2 + 1)
                        m._22 = ((_gthis.data[index26] * k1) + ((_gthis.data[index27] * k2)))
                        index28 = offset1
                        offset1 = (offset1 + 1)
                        index29 = offset2
                        offset2 = (offset2 + 1)
                        m._33 = ((_gthis.data[index28] * k1) + ((_gthis.data[index29] * k2)))
                    else:
                        m._11 = 1
                        m._22 = 1
                        m._33 = 1
                if (o.targetSkin is not None):
                    python_internal_ArrayImpl._set(o.targetSkin.currentRelPose, o.targetJoint, m)
                    o.targetSkin.jointsUpdated = True
                else:
                    _this = o.targetObject
                    _this.defaultTransform = m
                    f2 = 1
                    b = True
                    if b:
                        _this.flags = (_this.flags | f2)
                    else:
                        _this.flags = (_this.flags & ~f2)
            if (((layout & ((1 << h3d_anim_DataLayout.UV.index)))) != 0):
                mat = o.targetObject.toMesh().material
                s = mat.passes.getShader(h3d_shader_UVDelta)
                if (s is None):
                    s = mat.passes.addShader(h3d_shader_UVDelta())
                    mat.get_texture().set_wrap(h3d_mat_Wrap.Repeat)
                index30 = offset1
                offset1 = (offset1 + 1)
                v11 = self.data[index30]
                index31 = offset2
                offset2 = (offset2 + 1)
                v21 = self.data[index31]
                v11 = HxOverrides.modf(v11, 1.)
                v21 = HxOverrides.modf(v21, 1.)
                if (v11 < ((v21 - 0.5))):
                    v11 = (v11 + 1)
                elif (v11 > ((v21 + 0.5))):
                    v11 = (v11 - 1)
                s.uvDelta__.x = ((v11 * ((1 - k2))) + ((v21 * k2)))
                index32 = offset1
                offset1 = (offset1 + 1)
                v12 = self.data[index32]
                index33 = offset2
                offset2 = (offset2 + 1)
                v22 = self.data[index33]
                v12 = HxOverrides.modf(v12, 1.)
                v22 = HxOverrides.modf(v22, 1.)
                if (v12 < ((v22 - 0.5))):
                    v12 = (v12 + 1)
                elif (v12 > ((v22 + 0.5))):
                    v12 = (v12 - 1)
                s.uvDelta__.y = ((v12 * ((1 - k2))) + ((v22 * k2)))
            if (((layout & ((1 << h3d_anim_DataLayout.Alpha.index)))) != 0):
                mat1 = o.targetObject.toMesh().material
                if (mat1.blendMode == h2d_BlendMode._hx_None):
                    mat1.set_blendMode(h2d_BlendMode.Alpha)
                index34 = offset1
                offset1 = (offset1 + 1)
                tmp = (_gthis.data[index34] * k1)
                index35 = offset2
                offset2 = (offset2 + 1)
                tmp1 = (_gthis.data[index35] * k2)
                mat1.mshader.color__.w = (tmp + tmp1)
            if (((layout & ((1 << h3d_anim_DataLayout.Property.index)))) != 0):
                index36 = offset1
                offset1 = (offset1 + 1)
                index37 = offset2
                offset2 = (offset2 + 1)
                o.propCurrentValue = ((_gthis.data[index36] * k1) + ((_gthis.data[index37] * k2)))
        if (not decompose):
            self.isSync = True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.syncFrame = None
        _hx_o.data = None
        _hx_o.stride = None
h3d_anim_BufferAnimation._hx_class = h3d_anim_BufferAnimation
_hx_classes["h3d.anim.BufferAnimation"] = h3d_anim_BufferAnimation


class h3d_anim_LinearFrame:
    _hx_class_name = "h3d.anim.LinearFrame"
    _hx_is_interface = "False"
    __slots__ = ("tx", "ty", "tz", "qx", "qy", "qz", "qw", "sx", "sy", "sz")
    _hx_fields = ["tx", "ty", "tz", "qx", "qy", "qz", "qw", "sx", "sy", "sz"]
    _hx_methods = ["toMatrix"]

    def __init__(self):
        self.sz = None
        self.sy = None
        self.sx = None
        self.qw = None
        self.qz = None
        self.qy = None
        self.qx = None
        self.tz = None
        self.ty = None
        self.tx = None

    def toMatrix(self):
        m = h3d_Matrix()
        h3d_Quat(self.qx,self.qy,self.qz,self.qw).toMatrix(m)
        m.prependScale(self.sx,self.sy,self.sz)
        m.translate(self.tx,self.ty,self.tz)
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tx = None
        _hx_o.ty = None
        _hx_o.tz = None
        _hx_o.qx = None
        _hx_o.qy = None
        _hx_o.qz = None
        _hx_o.qw = None
        _hx_o.sx = None
        _hx_o.sy = None
        _hx_o.sz = None
h3d_anim_LinearFrame._hx_class = h3d_anim_LinearFrame
_hx_classes["h3d.anim.LinearFrame"] = h3d_anim_LinearFrame


class h3d_anim_LinearObject(h3d_anim_AnimatedObject):
    _hx_class_name = "h3d.anim.LinearObject"
    _hx_is_interface = "False"
    __slots__ = ("hasPosition", "hasRotation", "hasScale", "frames", "alphas", "uvs", "propName", "propValues", "matrix", "propCurrentValue")
    _hx_fields = ["hasPosition", "hasRotation", "hasScale", "frames", "alphas", "uvs", "propName", "propValues", "matrix", "propCurrentValue"]
    _hx_methods = ["clone"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_AnimatedObject


    def __init__(self,name):
        self.propCurrentValue = None
        self.matrix = None
        self.propValues = None
        self.propName = None
        self.uvs = None
        self.alphas = None
        self.frames = None
        self.hasScale = None
        self.hasRotation = None
        self.hasPosition = True
        super().__init__(name)

    def clone(self):
        o = h3d_anim_LinearObject(self.objectName)
        o.hasPosition = self.hasPosition
        o.hasRotation = self.hasRotation
        o.hasScale = self.hasScale
        o.frames = self.frames
        o.alphas = self.alphas
        o.uvs = self.uvs
        o.propName = self.propName
        o.propValues = self.propValues
        return o

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.hasPosition = None
        _hx_o.hasRotation = None
        _hx_o.hasScale = None
        _hx_o.frames = None
        _hx_o.alphas = None
        _hx_o.uvs = None
        _hx_o.propName = None
        _hx_o.propValues = None
        _hx_o.matrix = None
        _hx_o.propCurrentValue = None
h3d_anim_LinearObject._hx_class = h3d_anim_LinearObject
_hx_classes["h3d.anim.LinearObject"] = h3d_anim_LinearObject


class h3d_anim_LinearAnimation(h3d_anim_Animation):
    _hx_class_name = "h3d.anim.LinearAnimation"
    _hx_is_interface = "False"
    __slots__ = ("syncFrame",)
    _hx_fields = ["syncFrame"]
    _hx_methods = ["addCurve", "addAlphaCurve", "addUVCurve", "addPropCurve", "getPropValue", "getFrames", "clone", "endFrame", "initInstance", "sortByFrameCountDesc", "uvLerp", "sync"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_Animation


    def __init__(self,name,frame,sampling):
        self.syncFrame = None
        super().__init__(name,frame,sampling)
        self.syncFrame = -1

    def addCurve(self,objName,frames,hasPos,hasRot,hasScale):
        f = h3d_anim_LinearObject(objName)
        f.frames = frames
        f.hasPosition = hasPos
        f.hasRotation = hasRot
        f.hasScale = hasScale
        _this = self.objects
        _this.append(f)

    def addAlphaCurve(self,objName,alphas):
        f = h3d_anim_LinearObject(objName)
        f.alphas = alphas
        _this = self.objects
        _this.append(f)

    def addUVCurve(self,objName,uvs):
        f = h3d_anim_LinearObject(objName)
        f.uvs = uvs
        _this = self.objects
        _this.append(f)

    def addPropCurve(self,objName,propName,values):
        f = h3d_anim_LinearObject(objName)
        f.propName = propName
        f.propValues = values
        _this = self.objects
        _this.append(f)

    def getPropValue(self,objName,propName):
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((o.objectName == objName) and ((o.propName == propName))):
                return o.propCurrentValue
        return None

    def getFrames(self):
        return self.objects

    def clone(self,a = None):
        if (a is None):
            a = h3d_anim_LinearAnimation(self.name,self.frameCount,self.sampling)
        super().clone(a)
        return a

    def endFrame(self):
        if self.loop:
            return self.frameCount
        else:
            return (self.frameCount - 1)

    def initInstance(self):
        super().initInstance()
        frames = self.objects
        _g = 0
        while (_g < len(frames)):
            a = (frames[_g] if _g >= 0 and _g < len(frames) else None)
            _g = (_g + 1)
            if (a.propValues is not None):
                a.propCurrentValue = a.propValues[0]
                continue
            if ((a.alphas is not None) and (((a.targetObject is None) or ((Std.downcast(a.targetObject,h3d_scene_Mesh) is None))))):
                raise haxe_Exception.thrown((HxOverrides.stringOrNull(a.objectName) + " should be a mesh (for alpha animation)"))
            if ((a.uvs is not None) or ((a.alphas is not None))):
                continue
            a.matrix = h3d_Matrix()
            a.matrix.identity()
        frames.sort(key= python_lib_Functools.cmp_to_key(self.sortByFrameCountDesc))

    def sortByFrameCountDesc(self,o1,o2):
        return (((10 if ((o2.frames is None)) else len(o2.frames))) - ((10 if ((o1.frames is None)) else len(o1.frames))))

    def uvLerp(self,v1,v2,k):
        v1 = HxOverrides.modf(v1, 1.)
        v2 = HxOverrides.modf(v2, 1.)
        if (v1 < ((v2 - 0.5))):
            v1 = (v1 + 1)
        elif (v1 > ((v2 + 0.5))):
            v1 = (v1 - 1)
        return ((v1 * ((1 - k))) + ((v2 * k)))

    def sync(self,decompose = None):
        if (decompose is None):
            decompose = False
        if ((self.frame == self.syncFrame) and (not decompose)):
            return
        x = self.frame
        f = None
        try:
            f = int(x)
        except BaseException as _g:
            None
            f = None
        _hx_max = self.endFrame()
        if (f == _hx_max):
            f = (f - 1)
        frame1 = f
        frame2 = HxOverrides.mod(((frame1 + 1)), self.frameCount)
        k2 = (self.frame - frame1)
        k1 = (1 - k2)
        if (frame1 < 0):
            frame2 = 0
            frame1 = frame2
        elif (self.frame >= self.frameCount):
            frame2 = (self.frameCount - 1)
            frame1 = frame2
        elif ((not self.loop) and ((frame2 == 0))):
            frame2 = (self.frameCount - 1)
        self.syncFrame = self.frame
        if decompose:
            self.isSync = False
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((o.targetObject is None) and ((o.targetSkin is None))):
                continue
            if (o.alphas is not None):
                mat = o.targetObject.toMesh().material
                if (mat.blendMode == h2d_BlendMode._hx_None):
                    mat.set_blendMode(h2d_BlendMode.Alpha)
                tmp = (o.alphas[frame1] * k1)
                tmp1 = (o.alphas[frame2] * k2)
                mat.mshader.color__.w = (tmp + tmp1)
                continue
            if (o.uvs is not None):
                mat1 = o.targetObject.toMesh().material
                s = mat1.passes.getShader(h3d_shader_UVDelta)
                if (s is None):
                    s = mat1.passes.addShader(h3d_shader_UVDelta())
                    mat1.get_texture().set_wrap(h3d_mat_Wrap.Repeat)
                v1 = o.uvs[(frame1 << 1)]
                v2 = o.uvs[(frame2 << 1)]
                v1 = HxOverrides.modf(v1, 1.)
                v2 = HxOverrides.modf(v2, 1.)
                if (v1 < ((v2 - 0.5))):
                    v1 = (v1 + 1)
                elif (v1 > ((v2 + 0.5))):
                    v1 = (v1 - 1)
                s.uvDelta__.x = ((v1 * ((1 - k2))) + ((v2 * k2)))
                v11 = o.uvs[((frame1 << 1) | 1)]
                v21 = o.uvs[((frame2 << 1) | 1)]
                v11 = HxOverrides.modf(v11, 1.)
                v21 = HxOverrides.modf(v21, 1.)
                if (v11 < ((v21 - 0.5))):
                    v11 = (v11 + 1)
                elif (v11 > ((v21 + 0.5))):
                    v11 = (v11 - 1)
                s.uvDelta__.y = ((v11 * ((1 - k2))) + ((v21 * k2)))
                continue
            if (o.propValues is not None):
                o.propCurrentValue = ((o.propValues[frame1] * k1) + ((o.propValues[frame2] * k2)))
                continue
            frame11 = frame1
            frame21 = frame2
            if (len(o.frames) == 1):
                if self.isSync:
                    break
                frame21 = 0
                frame11 = frame21
            f1 = o.frames[frame11]
            f2 = o.frames[frame21]
            m = o.matrix
            m._41 = ((f1.tx * k1) + ((f2.tx * k2)))
            m._42 = ((f1.ty * k1) + ((f2.ty * k2)))
            m._43 = ((f1.tz * k1) + ((f2.tz * k2)))
            if o.hasRotation:
                dot = ((((f1.qx * f2.qx) + ((f1.qy * f2.qy))) + ((f1.qz * f2.qz))) + ((f1.qw * f2.qw)))
                q2 = (-k2 if ((dot < 0)) else k2)
                qx = ((f1.qx * k1) + ((f2.qx * q2)))
                qy = ((f1.qy * k1) + ((f2.qy * q2)))
                qz = ((f1.qz * k1) + ((f2.qz * q2)))
                qw = ((f1.qw * k1) + ((f2.qw * q2)))
                v = ((((qx * qx) + ((qy * qy))) + ((qz * qz))) + ((qw * qw)))
                ql = (1 / ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))
                qx = (qx * ql)
                qy = (qy * ql)
                qz = (qz * ql)
                qw = (qw * ql)
                if decompose:
                    m._12 = qx
                    m._13 = qy
                    m._21 = qz
                    m._23 = qw
                    if o.hasScale:
                        m._11 = ((f1.sx * k1) + ((f2.sx * k2)))
                        m._22 = ((f1.sy * k1) + ((f2.sy * k2)))
                        m._33 = ((f1.sz * k1) + ((f2.sz * k2)))
                    else:
                        m._11 = 1
                        m._22 = 1
                        m._33 = 1
                else:
                    xx = (qx * qx)
                    xy = (qx * qy)
                    xz = (qx * qz)
                    xw = (qx * qw)
                    yy = (qy * qy)
                    yz = (qy * qz)
                    yw = (qy * qw)
                    zz = (qz * qz)
                    zw = (qz * qw)
                    m._11 = (1 - ((2 * ((yy + zz)))))
                    m._12 = (2 * ((xy + zw)))
                    m._13 = (2 * ((xz - yw)))
                    m._21 = (2 * ((xy - zw)))
                    m._22 = (1 - ((2 * ((xx + zz)))))
                    m._23 = (2 * ((yz + xw)))
                    m._31 = (2 * ((xz + yw)))
                    m._32 = (2 * ((yz - xw)))
                    m._33 = (1 - ((2 * ((xx + yy)))))
                    if o.hasScale:
                        sx = ((f1.sx * k1) + ((f2.sx * k2)))
                        sy = ((f1.sy * k1) + ((f2.sy * k2)))
                        sz = ((f1.sz * k1) + ((f2.sz * k2)))
                        m._11 = (m._11 * sx)
                        m._12 = (m._12 * sx)
                        m._13 = (m._13 * sx)
                        m._21 = (m._21 * sy)
                        m._22 = (m._22 * sy)
                        m._23 = (m._23 * sy)
                        m._31 = (m._31 * sz)
                        m._32 = (m._32 * sz)
                        m._33 = (m._33 * sz)
            else:
                m._12 = 0
                m._13 = 0
                m._21 = 0
                m._23 = (1 if decompose else 0)
                if o.hasScale:
                    m._11 = ((f1.sx * k1) + ((f2.sx * k2)))
                    m._22 = ((f1.sy * k1) + ((f2.sy * k2)))
                    m._33 = ((f1.sz * k1) + ((f2.sz * k2)))
                else:
                    m._11 = 1
                    m._22 = 1
                    m._33 = 1
            if (o.targetSkin is not None):
                python_internal_ArrayImpl._set(o.targetSkin.currentRelPose, o.targetJoint, o.matrix)
                o.targetSkin.jointsUpdated = True
            else:
                _this = o.targetObject
                v3 = o.matrix
                _this.defaultTransform = v3
                f = 1
                b = True
                if b:
                    _this.flags = (_this.flags | f)
                else:
                    _this.flags = (_this.flags & ~f)
        if (not decompose):
            self.isSync = True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.syncFrame = None
h3d_anim_LinearAnimation._hx_class = h3d_anim_LinearAnimation
_hx_classes["h3d.anim.LinearAnimation"] = h3d_anim_LinearAnimation


class h3d_anim_Joint:
    _hx_class_name = "h3d.anim.Joint"
    _hx_is_interface = "False"
    __slots__ = ("index", "name", "bindIndex", "splitIndex", "defMat", "transPos", "parent", "subs", "offsets", "offsetRay", "retargetAnim")
    _hx_fields = ["index", "name", "bindIndex", "splitIndex", "defMat", "transPos", "parent", "subs", "offsets", "offsetRay", "retargetAnim"]

    def __init__(self):
        self.retargetAnim = None
        self.offsetRay = None
        self.offsets = None
        self.parent = None
        self.transPos = None
        self.defMat = None
        self.name = None
        self.index = None
        self.bindIndex = -1
        self.splitIndex = -1
        self.subs = []

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.name = None
        _hx_o.bindIndex = None
        _hx_o.splitIndex = None
        _hx_o.defMat = None
        _hx_o.transPos = None
        _hx_o.parent = None
        _hx_o.subs = None
        _hx_o.offsets = None
        _hx_o.offsetRay = None
        _hx_o.retargetAnim = None
h3d_anim_Joint._hx_class = h3d_anim_Joint
_hx_classes["h3d.anim.Joint"] = h3d_anim_Joint


class h3d_anim__Skin_Permut:
    _hx_class_name = "h3d.anim._Skin.Permut"
    _hx_is_interface = "False"
    __slots__ = ("joints", "triangles", "material", "indexedJoints")
    _hx_fields = ["joints", "triangles", "material", "indexedJoints"]

    def __init__(self):
        self.indexedJoints = None
        self.material = None
        self.triangles = None
        self.joints = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.joints = None
        _hx_o.triangles = None
        _hx_o.material = None
        _hx_o.indexedJoints = None
h3d_anim__Skin_Permut._hx_class = h3d_anim__Skin_Permut
_hx_classes["h3d.anim._Skin.Permut"] = h3d_anim__Skin_Permut


class h3d_anim__Skin_Influence:
    _hx_class_name = "h3d.anim._Skin.Influence"
    _hx_is_interface = "False"
    __slots__ = ("j", "w")
    _hx_fields = ["j", "w"]

    def __init__(self,j,w):
        self.j = j
        self.w = w

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.j = None
        _hx_o.w = None
h3d_anim__Skin_Influence._hx_class = h3d_anim__Skin_Influence
_hx_classes["h3d.anim._Skin.Influence"] = h3d_anim__Skin_Influence


class h3d_anim_Skin:
    _hx_class_name = "h3d.anim.Skin"
    _hx_is_interface = "False"
    __slots__ = ("name", "vertexCount", "bonesPerVertex", "vertexJoints", "vertexWeights", "rootJoints", "namedJoints", "allJoints", "boundJoints", "primitive", "splitJoints", "triangleGroups", "envelop")
    _hx_fields = ["name", "vertexCount", "bonesPerVertex", "vertexJoints", "vertexWeights", "rootJoints", "namedJoints", "allJoints", "boundJoints", "primitive", "splitJoints", "triangleGroups", "envelop"]
    _hx_methods = ["setJoints", "addInfluence", "sortInfluences", "isSplit", "initWeights", "sortByBindIndex", "isSub", "merge", "jointsDiff", "split"]

    def __init__(self,name,vertexCount,bonesPerVertex):
        self.envelop = None
        self.triangleGroups = None
        self.splitJoints = None
        self.primitive = None
        self.boundJoints = None
        self.allJoints = None
        self.namedJoints = None
        self.rootJoints = None
        self.vertexWeights = None
        self.vertexJoints = None
        self.name = name
        self.vertexCount = vertexCount
        self.bonesPerVertex = bonesPerVertex
        if (vertexCount > 0):
            this1 = [None]*(vertexCount * bonesPerVertex)
            self.vertexJoints = this1
            this1 = [None]*(vertexCount * bonesPerVertex)
            self.vertexWeights = this1
            self.envelop = []

    def setJoints(self,joints,roots):
        self.rootJoints = roots
        self.allJoints = joints
        self.namedJoints = haxe_ds_StringMap()
        _g = 0
        while (_g < len(joints)):
            j = (joints[_g] if _g >= 0 and _g < len(joints) else None)
            _g = (_g + 1)
            if (j.name is not None):
                self.namedJoints.h[j.name] = j

    def addInfluence(self,vid,j,w):
        il = (self.envelop[vid] if vid >= 0 and vid < len(self.envelop) else None)
        if (il is None):
            def _hx_local_0():
                python_internal_ArrayImpl._set(self.envelop, vid, [])
                return (self.envelop[vid] if vid >= 0 and vid < len(self.envelop) else None)
            il = _hx_local_0()
        x = h3d_anim__Skin_Influence(j,w)
        il.append(x)

    def sortInfluences(self,i1,i2):
        if (i2.w > i1.w):
            return 1
        else:
            return -1

    def isSplit(self):
        return (self.splitJoints is not None)

    def initWeights(self):
        self.boundJoints = []
        pos = 0
        _g = 0
        _g1 = self.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            il = (self.envelop[i] if i >= 0 and i < len(self.envelop) else None)
            if (il is None):
                il = []
            haxe_ds_ArraySort.sort(il,self.sortInfluences)
            if (len(il) > self.bonesPerVertex):
                il = il[0:self.bonesPerVertex]
            tw = 0.
            _g2 = 0
            while (_g2 < len(il)):
                i1 = (il[_g2] if _g2 >= 0 and _g2 < len(il) else None)
                _g2 = (_g2 + 1)
                tw = (tw + i1.w)
            tw = (1 / tw)
            _g3 = 0
            _g4 = self.bonesPerVertex
            while (_g3 < _g4):
                i2 = _g3
                _g3 = (_g3 + 1)
                i3 = (il[i2] if i2 >= 0 and i2 < len(il) else None)
                if (i3 is None):
                    self.vertexJoints[pos] = 0
                    self.vertexWeights[pos] = 0
                else:
                    if (i3.j.bindIndex == -1):
                        i3.j.bindIndex = len(self.boundJoints)
                        _this = self.boundJoints
                        x = i3.j
                        _this.append(x)
                    val = i3.j.bindIndex
                    self.vertexJoints[pos] = val
                    val1 = (i3.w * tw)
                    self.vertexWeights[pos] = val1
                pos = (pos + 1)
        self.envelop = None

    def sortByBindIndex(self,j1,j2):
        return (j1.bindIndex - j2.bindIndex)

    def isSub(self,a,b):
        j = 0
        _hx_max = len(b)
        _g = 0
        while (_g < len(a)):
            e = (a[_g] if _g >= 0 and _g < len(a) else None)
            _g = (_g + 1)
            while True:
                b1 = j
                j = (j + 1)
                if (not ((e != (b[b1] if b1 >= 0 and b1 < len(b) else None)))):
                    break
                if (j >= _hx_max):
                    return False
        return True

    def merge(self,permuts):
        _g = 0
        while (_g < len(permuts)):
            p1 = (permuts[_g] if _g >= 0 and _g < len(permuts) else None)
            _g = (_g + 1)
            _g1 = 0
            while (_g1 < len(permuts)):
                p2 = (permuts[_g1] if _g1 >= 0 and _g1 < len(permuts) else None)
                _g1 = (_g1 + 1)
                if (((p1 != p2) and ((p1.material == p2.material))) and self.isSub(p1.joints,p2.joints)):
                    _g2 = 0
                    _g3 = p1.triangles
                    while (_g2 < len(_g3)):
                        t = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                        _g2 = (_g2 + 1)
                        _this = p2.triangles
                        _this.append(t)
                    python_internal_ArrayImpl.remove(permuts,p1)
                    return True
        return False

    def jointsDiff(self,p1,p2):
        diff = 0
        i = 0
        j = 0
        imax = len(p1.joints)
        jmax = len(p2.joints)
        while ((i < imax) and ((j < jmax))):
            j1 = (p1.joints[i] if i >= 0 and i < len(p1.joints) else None)
            j2 = (p2.joints[j] if j >= 0 and j < len(p2.joints) else None)
            if (j1 == j2):
                i = (i + 1)
                j = (j + 1)
            else:
                diff = (diff + 1)
                if (j1.bindIndex < j2.bindIndex):
                    i = (i + 1)
                else:
                    j = (j + 1)
        return ((diff + ((imax - i))) + ((jmax - j)))

    def split(self,maxBones,index,triangleMaterials):
        if (self.splitJoints is not None):
            return True
        if (len(self.boundJoints) <= maxBones):
            return False
        self.splitJoints = []
        x = (len(index) / 3)
        length = None
        try:
            length = int(x)
        except BaseException as _g:
            None
            length = None
        this1 = [None]*length
        self.triangleGroups = this1
        permuts = list()
        _g = 0
        x = (len(index) / 3)
        _g1 = None
        try:
            _g1 = int(x)
        except BaseException as _g2:
            None
            _g1 = None
        while (_g < _g1):
            tri = _g
            _g = (_g + 1)
            iid = (tri * 3)
            mid = (0 if ((triangleMaterials is None)) else (triangleMaterials[tri] if tri >= 0 and tri < len(triangleMaterials) else None))
            jl = []
            _g2 = 0
            while (_g2 < 3):
                i = _g2
                _g2 = (_g2 + 1)
                vid = python_internal_ArrayImpl._get(index, (iid + i))
                _g3 = 0
                _g4 = self.bonesPerVertex
                while (_g3 < _g4):
                    b = _g3
                    _g3 = (_g3 + 1)
                    bidx = ((vid * self.bonesPerVertex) + b)
                    if (self.vertexWeights[bidx] == 0):
                        continue
                    j = python_internal_ArrayImpl._get(self.boundJoints, self.vertexJoints[bidx])
                    if (j.splitIndex != iid):
                        j.splitIndex = iid
                        jl.append(j)
            jl.sort(key= python_lib_Functools.cmp_to_key(self.sortByBindIndex))
            _g5 = 0
            while (_g5 < len(permuts)):
                p2 = (permuts[_g5] if _g5 >= 0 and _g5 < len(permuts) else None)
                _g5 = (_g5 + 1)
                if ((p2.material == mid) and self.isSub(jl,p2.joints)):
                    _this = p2.triangles
                    _this.append(tri)
                    jl = None
                    break
            if (jl is None):
                continue
            _g6 = 0
            while (_g6 < len(permuts)):
                p21 = (permuts[_g6] if _g6 >= 0 and _g6 < len(permuts) else None)
                _g6 = (_g6 + 1)
                if ((p21.material == mid) and self.isSub(p21.joints,jl)):
                    p21.joints = jl
                    _this1 = p21.triangles
                    _this1.append(tri)
                    jl = None
                    break
            if (jl is None):
                continue
            pr = h3d_anim__Skin_Permut()
            pr.joints = jl
            pr.triangles = [tri]
            pr.material = mid
            permuts.append(pr)
        while True:
            while self.merge(permuts):
                pass
            minDif = 100000
            minTot = 100000
            minP1 = None
            minP2 = None
            _g = 0
            _g1 = len(permuts)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p1 = (permuts[i] if i >= 0 and i < len(permuts) else None)
                if (len(p1.joints) == maxBones):
                    continue
                _g2 = (i + 1)
                _g3 = len(permuts)
                while (_g2 < _g3):
                    j = _g2
                    _g2 = (_g2 + 1)
                    p2 = (permuts[j] if j >= 0 and j < len(permuts) else None)
                    if ((len(p2.joints) == maxBones) or ((p1.material != p2.material))):
                        continue
                    count = self.jointsDiff(p1,p2)
                    tot = (count + ((((len(p1.joints) + len(p2.joints)) - count) >> 1)))
                    if (((tot > maxBones) or ((tot > minTot))) or (((tot == minTot) and ((count > minDif))))):
                        continue
                    minDif = count
                    minTot = tot
                    minP1 = p1
                    minP2 = p2
            if (minP1 is None):
                break
            p11 = minP1
            p21 = minP2
            _g4 = 0
            _g5 = p11.joints
            while (_g4 < len(_g5)):
                j1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                python_internal_ArrayImpl.remove(p21.joints,j1)
                _this = p21.joints
                _this.append(j1)
            p21.joints.sort(key= python_lib_Functools.cmp_to_key(self.sortByBindIndex))
            _g6 = 0
            _g7 = p11.triangles
            while (_g6 < len(_g7)):
                t = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                _g6 = (_g6 + 1)
                _this1 = p21.triangles
                _this1.append(t)
            python_internal_ArrayImpl.remove(permuts,p11)
        _g = 0
        _g1 = len(permuts)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = (permuts[i] if i >= 0 and i < len(permuts) else None).triangles
            while (_g2 < len(_g3)):
                tri = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.triangleGroups[tri] = i
        jointsPermuts = []
        _g = 0
        _g1 = self.boundJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            pl = []
            _g2 = 0
            while (_g2 < len(permuts)):
                p = (permuts[_g2] if _g2 >= 0 and _g2 < len(permuts) else None)
                _g2 = (_g2 + 1)
                if (python_internal_ArrayImpl.indexOf(p.joints,j,None) >= 0):
                    pl.append(p)
            jointsPermuts.append(_hx_AnonObject({'j': j, 'pl': pl, 'priority': 0}))
        while True:
            def _hx_local_7(j1,j2):
                return ((len(j2.pl) + ((j2.priority * 100))) - ((len(j1.pl) + ((j1.priority * 100)))))
            jointsPermuts.sort(key= python_lib_Functools.cmp_to_key(_hx_local_7))
            _g = 0
            while (_g < len(permuts)):
                p = (permuts[_g] if _g >= 0 and _g < len(permuts) else None)
                _g = (_g + 1)
                p.indexedJoints = []
            fail = False
            _g1 = 0
            while (_g1 < len(jointsPermuts)):
                j = (jointsPermuts[_g1] if _g1 >= 0 and _g1 < len(jointsPermuts) else None)
                _g1 = (_g1 + 1)
                j.j.splitIndex = -1
                _g2 = 0
                _g3 = maxBones
                while (_g2 < _g3):
                    id = _g2
                    _g2 = (_g2 + 1)
                    ok = True
                    _g4 = 0
                    _g5 = j.pl
                    while (_g4 < len(_g5)):
                        p1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                        _g4 = (_g4 + 1)
                        if ((p1.indexedJoints[id] if id >= 0 and id < len(p1.indexedJoints) else None) is not None):
                            ok = False
                            break
                    if ok:
                        j.j.splitIndex = id
                        _g6 = 0
                        _g7 = j.pl
                        while (_g6 < len(_g7)):
                            p2 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                            _g6 = (_g6 + 1)
                            python_internal_ArrayImpl._set(p2.indexedJoints, id, j.j)
                        break
                if (j.j.splitIndex < 0):
                    j.priority = (j.priority + 1)
                    if (j.priority > 10):
                        raise haxe_Exception.thrown("Failed to assign index while spliting skin")
                    fail = True
                    break
            if (not fail):
                break
        self.splitJoints = []
        _g = 0
        while (_g < len(permuts)):
            p = (permuts[_g] if _g >= 0 and _g < len(permuts) else None)
            _g = (_g + 1)
            jl = []
            _g1 = 0
            _g2 = len(p.indexedJoints)
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                j = (p.indexedJoints[i] if i >= 0 and i < len(p.indexedJoints) else None)
                if (j is None):
                    j = (self.boundJoints[0] if 0 < len(self.boundJoints) else None)
                jl.append(j)
            _this = self.splitJoints
            x = _hx_AnonObject({'material': p.material, 'joints': jl})
            _this.append(x)
        _g = 0
        _g1 = len(self.vertexJoints)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            this1 = self.vertexJoints
            val = python_internal_ArrayImpl._get(self.boundJoints, self.vertexJoints[i]).splitIndex
            this1[i] = val
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.vertexCount = None
        _hx_o.bonesPerVertex = None
        _hx_o.vertexJoints = None
        _hx_o.vertexWeights = None
        _hx_o.rootJoints = None
        _hx_o.namedJoints = None
        _hx_o.allJoints = None
        _hx_o.boundJoints = None
        _hx_o.primitive = None
        _hx_o.splitJoints = None
        _hx_o.triangleGroups = None
        _hx_o.envelop = None
h3d_anim_Skin._hx_class = h3d_anim_Skin
_hx_classes["h3d.anim.Skin"] = h3d_anim_Skin


class h3d_col_Collider:
    _hx_class_name = "h3d.col.Collider"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["rayIntersection", "contains", "inFrustum", "inSphere"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]
h3d_col_Collider._hx_class = h3d_col_Collider
_hx_classes["h3d.col.Collider"] = h3d_col_Collider


class h3d_col_Bounds:
    _hx_class_name = "h3d.col.Bounds"
    _hx_is_interface = "False"
    __slots__ = ("xMin", "xMax", "yMin", "yMax", "zMin", "zMax")
    _hx_fields = ["xMin", "xMax", "yMin", "yMax", "zMin", "zMax"]
    _hx_methods = ["inFrustum", "inSphere", "testPlane", "rayIntersection", "inFrustumDetails", "transform3x3", "transform", "collide", "contains", "containsBounds", "containsSphere", "add", "addPoint", "addPos", "addSphere", "addSpherePos", "intersection", "offset", "setMin", "setMax", "load", "scalePivot", "scaleCenter", "getMin", "getCenter", "getSize", "getMax", "getVolume", "get_xSize", "get_ySize", "get_zSize", "set_xSize", "set_ySize", "set_zSize", "isEmpty", "empty", "all", "clone", "toString", "toSphere"]
    _hx_statics = ["fromPoints", "fromValues"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self):
        self.xMin = 1e20
        self.xMax = -1e20
        self.yMin = 1e20
        self.yMax = -1e20
        self.zMin = 1e20
        self.zMax = -1e20

    def inFrustum(self,f,m = None):
        if (m is not None):
            raise haxe_Exception.thrown("Not implemented")
        return f.hasBounds(self)

    def inSphere(self,s):
        x = s.x
        y = s.y
        z = s.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        c_x = x
        c_y = y
        c_z = z
        a = self.xMin
        a1 = s.x
        b = self.xMax
        b1 = (b if ((a1 > b)) else a1)
        x = (b1 if ((a < b1)) else a)
        a = self.yMin
        a1 = s.y
        b = self.yMax
        b1 = (b if ((a1 > b)) else a1)
        y = (b1 if ((a < b1)) else a)
        a = self.zMin
        a1 = s.z
        b = self.zMax
        b1 = (b if ((a1 > b)) else a1)
        z = (b1 if ((a < b1)) else a)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        dx = (p_x - c_x)
        dy = (p_y - c_y)
        dz = (p_z - c_z)
        return ((((dx * dx) + ((dy * dy))) + ((dz * dz))) < ((s.r * s.r)))

    def testPlane(self,p):
        a = p.nx
        b = p.ny
        c = p.nz
        dd = (((a * ((self.xMax + self.xMin))) + ((b * ((self.yMax + self.yMin))))) + ((c * ((self.zMax + self.zMin)))))
        if (a < 0):
            a = -a
        if (b < 0):
            b = -b
        if (c < 0):
            c = -c
        rr = (((a * ((self.xMax - self.xMin))) + ((b * ((self.yMax - self.yMin))))) + ((c * ((self.zMax - self.zMin)))))
        return ((dd + rr) - ((p.d * 2)))

    def rayIntersection(self,r,bestMatch):
        minTx = (((self.xMin - r.px)) / r.lx)
        minTy = (((self.yMin - r.py)) / r.ly)
        minTz = (((self.zMin - r.pz)) / r.lz)
        maxTx = (((self.xMax - r.px)) / r.lx)
        maxTy = (((self.yMax - r.py)) / r.ly)
        maxTz = (((self.zMax - r.pz)) / r.lz)
        realMinTx = (maxTx if ((minTx > maxTx)) else minTx)
        realMinTy = (maxTy if ((minTy > maxTy)) else minTy)
        realMinTz = (maxTz if ((minTz > maxTz)) else minTz)
        realMaxTx = (maxTx if ((minTx < maxTx)) else minTx)
        realMaxTy = (maxTy if ((minTy < maxTy)) else minTy)
        realMaxTz = (maxTz if ((minTz < maxTz)) else minTz)
        a = (realMaxTy if ((realMaxTx > realMaxTy)) else realMaxTx)
        minmax = (realMaxTz if ((a > realMaxTz)) else a)
        a = (realMinTy if ((realMinTx < realMinTy)) else realMinTx)
        maxmin = (realMinTz if ((a < realMinTz)) else a)
        if (minmax < maxmin):
            return -1
        return maxmin

    def inFrustumDetails(self,mvp,checkZ = None):
        if (checkZ is None):
            checkZ = True
        ret = 1
        p_nx = (mvp._14 + mvp._11)
        p_ny = (mvp._24 + mvp._21)
        p_nz = (mvp._34 + mvp._31)
        p_d = (mvp._44 + mvp._41)
        m = (((p_nx * ((self.xMax if ((p_nx > 0)) else self.xMin))) + ((p_ny * ((self.yMax if ((p_ny > 0)) else self.yMin))))) + ((p_nz * ((self.zMax if ((p_nz > 0)) else self.zMin)))))
        if ((m + p_d) < 0):
            return -1
        n = (((p_nx * ((self.xMin if ((p_nx > 0)) else self.xMax))) + ((p_ny * ((self.yMin if ((p_ny > 0)) else self.yMax))))) + ((p_nz * ((self.zMin if ((p_nz > 0)) else self.zMax)))))
        if ((n + p_d) < 0):
            ret = 0
        p_nx = (mvp._14 - mvp._11)
        p_ny = (mvp._24 - mvp._21)
        p_nz = (mvp._34 - mvp._31)
        p_d = (mvp._44 - mvp._41)
        m = (((p_nx * ((self.xMax if ((p_nx > 0)) else self.xMin))) + ((p_ny * ((self.yMax if ((p_ny > 0)) else self.yMin))))) + ((p_nz * ((self.zMax if ((p_nz > 0)) else self.zMin)))))
        if ((m + p_d) < 0):
            return -1
        n = (((p_nx * ((self.xMin if ((p_nx > 0)) else self.xMax))) + ((p_ny * ((self.yMin if ((p_ny > 0)) else self.yMax))))) + ((p_nz * ((self.zMin if ((p_nz > 0)) else self.zMax)))))
        if ((n + p_d) < 0):
            ret = 0
        p_nx = (mvp._14 + mvp._12)
        p_ny = (mvp._24 + mvp._22)
        p_nz = (mvp._34 + mvp._32)
        p_d = (mvp._44 + mvp._42)
        m = (((p_nx * ((self.xMax if ((p_nx > 0)) else self.xMin))) + ((p_ny * ((self.yMax if ((p_ny > 0)) else self.yMin))))) + ((p_nz * ((self.zMax if ((p_nz > 0)) else self.zMin)))))
        if ((m + p_d) < 0):
            return -1
        n = (((p_nx * ((self.xMin if ((p_nx > 0)) else self.xMax))) + ((p_ny * ((self.yMin if ((p_ny > 0)) else self.yMax))))) + ((p_nz * ((self.zMin if ((p_nz > 0)) else self.zMax)))))
        if ((n + p_d) < 0):
            ret = 0
        p_nx = (mvp._14 - mvp._12)
        p_ny = (mvp._24 - mvp._22)
        p_nz = (mvp._34 - mvp._32)
        p_d = (mvp._44 - mvp._42)
        m = (((p_nx * ((self.xMax if ((p_nx > 0)) else self.xMin))) + ((p_ny * ((self.yMax if ((p_ny > 0)) else self.yMin))))) + ((p_nz * ((self.zMax if ((p_nz > 0)) else self.zMin)))))
        if ((m + p_d) < 0):
            return -1
        n = (((p_nx * ((self.xMin if ((p_nx > 0)) else self.xMax))) + ((p_ny * ((self.yMin if ((p_ny > 0)) else self.yMax))))) + ((p_nz * ((self.zMin if ((p_nz > 0)) else self.zMax)))))
        if ((n + p_d) < 0):
            ret = 0
        if checkZ:
            p_nx = mvp._13
            p_ny = mvp._23
            p_nz = mvp._33
            p_d = mvp._43
            m = (((p_nx * ((self.xMax if ((p_nx > 0)) else self.xMin))) + ((p_ny * ((self.yMax if ((p_ny > 0)) else self.yMin))))) + ((p_nz * ((self.zMax if ((p_nz > 0)) else self.zMin)))))
            if ((m + p_d) < 0):
                return -1
            n = (((p_nx * ((self.xMin if ((p_nx > 0)) else self.xMax))) + ((p_ny * ((self.yMin if ((p_ny > 0)) else self.yMax))))) + ((p_nz * ((self.zMin if ((p_nz > 0)) else self.zMax)))))
            if ((n + p_d) < 0):
                ret = 0
            p_nx = (mvp._14 - mvp._13)
            p_ny = (mvp._24 - mvp._23)
            p_nz = (mvp._34 - mvp._33)
            p_d = (mvp._44 - mvp._43)
            m = (((p_nx * ((self.xMax if ((p_nx > 0)) else self.xMin))) + ((p_ny * ((self.yMax if ((p_ny > 0)) else self.yMin))))) + ((p_nz * ((self.zMax if ((p_nz > 0)) else self.zMin)))))
            if ((m + p_d) < 0):
                return -1
            n = (((p_nx * ((self.xMin if ((p_nx > 0)) else self.xMax))) + ((p_ny * ((self.yMin if ((p_ny > 0)) else self.yMax))))) + ((p_nz * ((self.zMin if ((p_nz > 0)) else self.zMax)))))
            if ((n + p_d) < 0):
                ret = 0
        return ret

    def transform3x3(self,m):
        xMin = self.xMin
        yMin = self.yMin
        zMin = self.zMin
        xMax = self.xMax
        yMax = self.yMax
        zMax = self.zMax
        self.xMin = 1e20
        self.xMax = -1e20
        self.yMin = 1e20
        self.yMax = -1e20
        self.zMin = 1e20
        self.zMax = -1e20
        v_x = 0.
        v_y = 0.
        v_z = 0.
        x = xMin
        y = yMin
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMin
        y = yMin
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMin
        y = yMax
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMin
        y = yMax
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMin
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMin
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMax
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMax
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z

    def transform(self,m):
        xMin = self.xMin
        yMin = self.yMin
        zMin = self.zMin
        xMax = self.xMax
        yMax = self.yMax
        zMax = self.zMax
        self.xMin = 1e20
        self.xMax = -1e20
        self.yMin = 1e20
        self.yMax = -1e20
        self.zMin = 1e20
        self.zMax = -1e20
        if (((xMax < xMin) and ((yMax < yMin))) and ((zMax < zMin))):
            return
        v_x = 0.
        v_y = 0.
        v_z = 0.
        x = xMin
        y = yMin
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMin
        y = yMin
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMin
        y = yMax
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMin
        y = yMax
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMin
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMin
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMax
        z = zMin
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        x = xMax
        y = yMax
        z = zMax
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z

    def collide(self,b):
        return (not (((((((self.xMin > b.xMax) or ((self.yMin > b.yMax))) or ((self.zMin > b.zMax))) or ((self.xMax < b.xMin))) or ((self.yMax < b.yMin))) or ((self.zMax < b.zMin)))))

    def contains(self,p):
        if (((((p.x >= self.xMin) and ((p.x < self.xMax))) and ((p.y >= self.yMin))) and ((p.y < self.yMax))) and ((p.z >= self.zMin))):
            return (p.z < self.zMax)
        else:
            return False

    def containsBounds(self,b):
        if (((((self.xMin <= b.xMin) and ((self.yMin <= b.yMin))) and ((self.zMin <= b.zMin))) and ((self.xMax >= b.xMax))) and ((self.yMax >= b.yMax))):
            return (self.zMax >= b.zMax)
        else:
            return False

    def containsSphere(self,s):
        if (((((self.xMin <= ((s.x - s.r))) and ((self.yMin <= ((s.y - s.r))))) and ((self.zMin <= ((s.z - s.r))))) and ((self.xMax >= ((s.x + s.r))))) and ((self.yMax >= ((s.y + s.r))))):
            return (self.zMax >= ((s.z + s.r)))
        else:
            return False

    def add(self,b):
        if (b.xMin < self.xMin):
            self.xMin = b.xMin
        if (b.xMax > self.xMax):
            self.xMax = b.xMax
        if (b.yMin < self.yMin):
            self.yMin = b.yMin
        if (b.yMax > self.yMax):
            self.yMax = b.yMax
        if (b.zMin < self.zMin):
            self.zMin = b.zMin
        if (b.zMax > self.zMax):
            self.zMax = b.zMax

    def addPoint(self,p):
        if (p.x < self.xMin):
            self.xMin = p.x
        if (p.x > self.xMax):
            self.xMax = p.x
        if (p.y < self.yMin):
            self.yMin = p.y
        if (p.y > self.yMax):
            self.yMax = p.y
        if (p.z < self.zMin):
            self.zMin = p.z
        if (p.z > self.zMax):
            self.zMax = p.z

    def addPos(self,x,y,z):
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y
        if (z < self.zMin):
            self.zMin = z
        if (z > self.zMax):
            self.zMax = z

    def addSphere(self,s):
        x = s.x
        y = s.y
        z = s.z
        r = s.r
        if ((x - r) < self.xMin):
            self.xMin = (x - r)
        if ((x + r) > self.xMax):
            self.xMax = (x + r)
        if ((y - r) < self.yMin):
            self.yMin = (y - r)
        if ((y + r) > self.yMax):
            self.yMax = (y + r)
        if ((z - r) < self.zMin):
            self.zMin = (z - r)
        if ((z + r) > self.zMax):
            self.zMax = (z + r)

    def addSpherePos(self,x,y,z,r):
        if ((x - r) < self.xMin):
            self.xMin = (x - r)
        if ((x + r) > self.xMax):
            self.xMax = (x + r)
        if ((y - r) < self.yMin):
            self.yMin = (y - r)
        if ((y + r) > self.yMax):
            self.yMax = (y + r)
        if ((z - r) < self.zMin):
            self.zMin = (z - r)
        if ((z + r) > self.zMax):
            self.zMax = (z + r)

    def intersection(self,a,b):
        a1 = a.xMin
        b1 = b.xMin
        xMin = (b1 if ((a1 < b1)) else a1)
        a1 = a.yMin
        b1 = b.yMin
        yMin = (b1 if ((a1 < b1)) else a1)
        a1 = a.zMin
        b1 = b.zMin
        zMin = (b1 if ((a1 < b1)) else a1)
        a1 = a.xMax
        b1 = b.xMax
        xMax = (b1 if ((a1 > b1)) else a1)
        a1 = a.yMax
        b1 = b.yMax
        yMax = (b1 if ((a1 > b1)) else a1)
        a1 = a.zMax
        b1 = b.zMax
        zMax = (b1 if ((a1 > b1)) else a1)
        self.xMin = xMin
        self.xMax = xMax
        self.yMin = yMin
        self.yMax = yMax
        self.zMin = zMin
        self.zMax = zMax

    def offset(self,dx,dy,dz):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 + dx)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.xMax
        _hx_local_2.xMax = (_hx_local_3 + dx)
        _hx_local_2.xMax
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.yMin
        _hx_local_4.yMin = (_hx_local_5 + dy)
        _hx_local_4.yMin
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.yMax
        _hx_local_6.yMax = (_hx_local_7 + dy)
        _hx_local_6.yMax
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.zMin
        _hx_local_8.zMin = (_hx_local_9 + dz)
        _hx_local_8.zMin
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.zMax
        _hx_local_10.zMax = (_hx_local_11 + dz)
        _hx_local_10.zMax

    def setMin(self,p):
        self.xMin = p.x
        self.yMin = p.y
        self.zMin = p.z

    def setMax(self,p):
        self.xMax = p.x
        self.yMax = p.y
        self.zMax = p.z

    def load(self,b):
        self.xMin = b.xMin
        self.xMax = b.xMax
        self.yMin = b.yMin
        self.yMax = b.yMax
        self.zMin = b.zMin
        self.zMax = b.zMax

    def scalePivot(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 * v)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.yMin
        _hx_local_2.yMin = (_hx_local_3 * v)
        _hx_local_2.yMin
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.zMin
        _hx_local_4.zMin = (_hx_local_5 * v)
        _hx_local_4.zMin
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.xMax
        _hx_local_6.xMax = (_hx_local_7 * v)
        _hx_local_6.xMax
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.yMax
        _hx_local_8.yMax = (_hx_local_9 * v)
        _hx_local_8.yMax
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.zMax
        _hx_local_10.zMax = (_hx_local_11 * v)
        _hx_local_10.zMax

    def scaleCenter(self,v):
        dx = ((((self.xMax - self.xMin)) * 0.5) * v)
        dy = ((((self.yMax - self.yMin)) * 0.5) * v)
        dz = ((((self.zMax - self.zMin)) * 0.5) * v)
        mx = (((self.xMax + self.xMin)) * 0.5)
        my = (((self.yMax + self.yMin)) * 0.5)
        mz = (((self.zMax + self.zMin)) * 0.5)
        self.xMin = (mx - dx)
        self.yMin = (my - dy)
        self.zMin = (mz - dz)
        self.xMax = (mx + dx)
        self.yMax = (my + dy)
        self.zMax = (mz + dz)

    def getMin(self):
        return h3d_col_Point(self.xMin,self.yMin,self.zMin)

    def getCenter(self):
        return h3d_col_Point((((self.xMin + self.xMax)) * 0.5),(((self.yMin + self.yMax)) * 0.5),(((self.zMin + self.zMax)) * 0.5))

    def getSize(self):
        return h3d_col_Point((self.xMax - self.xMin),(self.yMax - self.yMin),(self.zMax - self.zMin))

    def getMax(self):
        return h3d_col_Point(self.xMax,self.yMax,self.zMax)

    def getVolume(self):
        return ((((self.xMax - self.xMin)) * ((self.yMax - self.yMin))) * ((self.zMax - self.zMin)))

    def get_xSize(self):
        return (self.xMax - self.xMin)

    def get_ySize(self):
        return (self.yMax - self.yMin)

    def get_zSize(self):
        return (self.zMax - self.zMin)

    def set_xSize(self,v):
        self.xMax = (self.xMin + v)
        return v

    def set_ySize(self,v):
        self.yMax = (self.yMin + v)
        return v

    def set_zSize(self,v):
        self.zMax = (self.zMin + v)
        return v

    def isEmpty(self):
        if (not (((self.xMax < self.xMin) or ((self.yMax < self.yMin))))):
            return (self.zMax < self.zMin)
        else:
            return True

    def empty(self):
        self.xMin = 1e20
        self.xMax = -1e20
        self.yMin = 1e20
        self.yMax = -1e20
        self.zMin = 1e20
        self.zMax = -1e20

    def all(self):
        self.xMin = -1e20
        self.xMax = 1e20
        self.yMin = -1e20
        self.yMax = 1e20
        self.zMin = -1e20
        self.zMax = 1e20

    def clone(self):
        b = h3d_col_Bounds()
        b.xMin = self.xMin
        b.xMax = self.xMax
        b.yMin = self.yMin
        b.yMax = self.yMax
        b.zMin = self.zMin
        b.zMax = self.zMax
        return b

    def toString(self):
        return (((("Bounds{" + Std.string(h3d_col_Point(self.xMin,self.yMin,self.zMin))) + ",") + Std.string(h3d_col_Point((self.xMax - self.xMin),(self.yMax - self.yMin),(self.zMax - self.zMin)))) + "}")

    def toSphere(self):
        dx = (self.xMax - self.xMin)
        dy = (self.yMax - self.yMin)
        dz = (self.zMax - self.zMin)
        f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
        return h3d_col_Sphere((((self.xMin + self.xMax)) * 0.5),(((self.yMin + self.yMax)) * 0.5),(((self.zMin + self.zMax)) * 0.5),(((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 0.5))

    @staticmethod
    def fromPoints(_hx_min,_hx_max):
        b = h3d_col_Bounds()
        b.xMin = _hx_min.x
        b.yMin = _hx_min.y
        b.zMin = _hx_min.z
        b.xMax = _hx_max.x
        b.yMax = _hx_max.y
        b.zMax = _hx_max.z
        return b

    @staticmethod
    def fromValues(x,y,z,dx,dy,dz):
        b = h3d_col_Bounds()
        b.xMin = x
        b.yMin = y
        b.zMin = z
        b.xMax = (x + dx)
        b.yMax = (y + dy)
        b.zMax = (z + dz)
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.xMin = None
        _hx_o.xMax = None
        _hx_o.yMin = None
        _hx_o.yMax = None
        _hx_o.zMin = None
        _hx_o.zMax = None
h3d_col_Bounds._hx_class = h3d_col_Bounds
_hx_classes["h3d.col.Bounds"] = h3d_col_Bounds


class h3d_col_OptimizedCollider:
    _hx_class_name = "h3d.col.OptimizedCollider"
    _hx_is_interface = "False"
    __slots__ = ("a", "b")
    _hx_fields = ["a", "b"]
    _hx_methods = ["rayIntersection", "contains", "inFrustum", "inSphere"]
    _hx_interfaces = [h3d_col_Collider, hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,a,b):
        self.a = a
        self.b = b

    def rayIntersection(self,r,bestMatch):
        if (self.a.rayIntersection(r,bestMatch) < 0):
            return -1
        return self.b.rayIntersection(r,bestMatch)

    def contains(self,p):
        if self.a.contains(p):
            return self.b.contains(p)
        else:
            return False

    def inFrustum(self,f,m = None):
        if self.a.inFrustum(f,m):
            return self.b.inFrustum(f,m)
        else:
            return False

    def inSphere(self,s):
        if self.a.inSphere(s):
            return self.b.inSphere(s)
        else:
            return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a = None
        _hx_o.b = None
h3d_col_OptimizedCollider._hx_class = h3d_col_OptimizedCollider
_hx_classes["h3d.col.OptimizedCollider"] = h3d_col_OptimizedCollider


class h3d_col_GroupCollider:
    _hx_class_name = "h3d.col.GroupCollider"
    _hx_is_interface = "False"
    __slots__ = ("colliders",)
    _hx_fields = ["colliders"]
    _hx_methods = ["rayIntersection", "contains", "inFrustum", "inSphere"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self,colliders):
        self.colliders = colliders

    def rayIntersection(self,r,bestMatch):
        best = -1.
        _g = 0
        _g1 = self.colliders
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            d = c.rayIntersection(r,bestMatch)
            if (d >= 0):
                if (not bestMatch):
                    return d
                if ((best < 0) or ((d < best))):
                    best = d
        return best

    def contains(self,p):
        _g = 0
        _g1 = self.colliders
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if c.contains(p):
                return True
        return False

    def inFrustum(self,f,m = None):
        _g = 0
        _g1 = self.colliders
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if c.inFrustum(f,m):
                return True
        return False

    def inSphere(self,s):
        _g = 0
        _g1 = self.colliders
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if c.inSphere(s):
                return True
        return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.colliders = None
h3d_col_GroupCollider._hx_class = h3d_col_GroupCollider
_hx_classes["h3d.col.GroupCollider"] = h3d_col_GroupCollider


class h3d_col_FPoint:
    _hx_class_name = "h3d.col.FPoint"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z")
    _hx_fields = ["x", "y", "z"]
    _hx_methods = ["sub", "add", "cross", "dot", "toString"]

    def __init__(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        self.x = x
        self.y = y
        self.z = z

    def sub(self,p):
        return h3d_col_FPoint((self.x - p.x),(self.y - p.y),(self.z - p.z))

    def add(self,p):
        return h3d_col_FPoint((self.x + p.x),(self.y + p.y),(self.z + p.z))

    def cross(self,p):
        return h3d_col_FPoint(((self.y * p.z) - ((self.z * p.y))),((self.z * p.x) - ((self.x * p.z))),((self.x * p.y) - ((self.y * p.x))))

    def dot(self,p):
        return (((self.x * p.x) + ((self.y * p.y))) + ((self.z * p.z)))

    def toString(self):
        return (((((("FPoint{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.z))) + "}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
h3d_col_FPoint._hx_class = h3d_col_FPoint
_hx_classes["h3d.col.FPoint"] = h3d_col_FPoint


class h3d_col_Frustum:
    _hx_class_name = "h3d.col.Frustum"
    _hx_is_interface = "False"
    __slots__ = ("pleft", "pright", "ptop", "pbottom", "pnear", "pfar", "checkNearFar")
    _hx_fields = ["pleft", "pright", "ptop", "pbottom", "pnear", "pfar", "checkNearFar"]
    _hx_methods = ["clone", "loadMatrix", "transform", "transform3x3", "hasPoint", "hasSphere", "hasBounds"]

    def __init__(self,mvp = None):
        self.checkNearFar = True
        self.pleft = h3d_col_Plane(1,0,0,0.0)
        self.pright = h3d_col_Plane(1,0,0,0.0)
        self.ptop = h3d_col_Plane(1,0,0,0.0)
        self.pbottom = h3d_col_Plane(1,0,0,0.0)
        self.pnear = h3d_col_Plane(1,0,0,0.0)
        self.pfar = h3d_col_Plane(1,0,0,0.0)
        if (mvp is not None):
            self.loadMatrix(mvp)

    def clone(self):
        f = h3d_col_Frustum()
        _this = f.pleft
        p = self.pleft
        _this.nx = p.nx
        _this.ny = p.ny
        _this.nz = p.nz
        _this.d = p.d
        _this = f.pright
        p = self.pright
        _this.nx = p.nx
        _this.ny = p.ny
        _this.nz = p.nz
        _this.d = p.d
        _this = f.ptop
        p = self.ptop
        _this.nx = p.nx
        _this.ny = p.ny
        _this.nz = p.nz
        _this.d = p.d
        _this = f.pbottom
        p = self.pbottom
        _this.nx = p.nx
        _this.ny = p.ny
        _this.nz = p.nz
        _this.d = p.d
        _this = f.pnear
        p = self.pnear
        _this.nx = p.nx
        _this.ny = p.ny
        _this.nz = p.nz
        _this.d = p.d
        _this = f.pfar
        p = self.pfar
        _this.nx = p.nx
        _this.ny = p.ny
        _this.nz = p.nz
        _this.d = p.d
        f.checkNearFar = self.checkNearFar
        return f

    def loadMatrix(self,mvp):
        _this = self.pleft
        p_nx = (mvp._14 + mvp._11)
        p_ny = (mvp._24 + mvp._21)
        p_nz = (mvp._34 + mvp._31)
        p_d = -((mvp._44 + mvp._41))
        _this.nx = p_nx
        _this.ny = p_ny
        _this.nz = p_nz
        _this.d = p_d
        _this = self.pright
        p_nx = (mvp._14 - mvp._11)
        p_ny = (mvp._24 - mvp._21)
        p_nz = (mvp._34 - mvp._31)
        p_d = (mvp._41 - mvp._44)
        _this.nx = p_nx
        _this.ny = p_ny
        _this.nz = p_nz
        _this.d = p_d
        _this = self.ptop
        p_nx = (mvp._14 - mvp._12)
        p_ny = (mvp._24 - mvp._22)
        p_nz = (mvp._34 - mvp._32)
        p_d = (mvp._42 - mvp._44)
        _this.nx = p_nx
        _this.ny = p_ny
        _this.nz = p_nz
        _this.d = p_d
        _this = self.pbottom
        p_nx = (mvp._14 + mvp._12)
        p_ny = (mvp._24 + mvp._22)
        p_nz = (mvp._34 + mvp._32)
        p_d = -((mvp._44 + mvp._42))
        _this.nx = p_nx
        _this.ny = p_ny
        _this.nz = p_nz
        _this.d = p_d
        _this = self.pnear
        p_nx = mvp._13
        p_ny = mvp._23
        p_nz = mvp._33
        p_d = -mvp._43
        _this.nx = p_nx
        _this.ny = p_ny
        _this.nz = p_nz
        _this.d = p_d
        _this = self.pfar
        p_nx = (mvp._14 - mvp._13)
        p_ny = (mvp._24 - mvp._23)
        p_nz = (mvp._34 - mvp._33)
        p_d = (mvp._43 - mvp._44)
        _this.nx = p_nx
        _this.ny = p_ny
        _this.nz = p_nz
        _this.d = p_d
        _this = self.pleft
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pright
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.ptop
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pbottom
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pnear
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pfar
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)

    def transform(self,m):
        m2 = h3d_Matrix()
        m2.initInverse(m)
        m2.transpose()
        _this = self.pleft
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pright
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.ptop
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pbottom
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pfar
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pnear
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pleft
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pright
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.ptop
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pbottom
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pnear
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pfar
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)

    def transform3x3(self,m):
        m2 = h3d_Matrix()
        m2.initInverse3x3(m)
        m2.transpose()
        _this = self.pleft
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pright
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.ptop
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pbottom
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pfar
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pnear
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this = self.pleft
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pright
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.ptop
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pbottom
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pnear
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)
        _this = self.pfar
        f = (((_this.nx * _this.nx) + ((_this.ny * _this.ny))) + ((_this.nz * _this.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this.nx = (_this.nx * _hx_len)
        _this.ny = (_this.ny * _hx_len)
        _this.nz = (_this.nz * _hx_len)
        _this.d = (_this.d * _hx_len)

    def hasPoint(self,p):
        _this = self.pleft
        if (((((_this.nx * p.x) + ((_this.ny * p.y))) + ((_this.nz * p.z))) - _this.d) < 0):
            return False
        _this = self.pright
        if (((((_this.nx * p.x) + ((_this.ny * p.y))) + ((_this.nz * p.z))) - _this.d) < 0):
            return False
        _this = self.ptop
        if (((((_this.nx * p.x) + ((_this.ny * p.y))) + ((_this.nz * p.z))) - _this.d) < 0):
            return False
        _this = self.pbottom
        if (((((_this.nx * p.x) + ((_this.ny * p.y))) + ((_this.nz * p.z))) - _this.d) < 0):
            return False
        if self.checkNearFar:
            _this = self.pnear
            if (((((_this.nx * p.x) + ((_this.ny * p.y))) + ((_this.nz * p.z))) - _this.d) < 0):
                return False
            _this = self.pfar
            if (((((_this.nx * p.x) + ((_this.ny * p.y))) + ((_this.nz * p.z))) - _this.d) < 0):
                return False
        return True

    def hasSphere(self,s):
        x = s.x
        y = s.y
        z = s.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        _this = self.pleft
        if (((((_this.nx * p_x) + ((_this.ny * p_y))) + ((_this.nz * p_z))) - _this.d) < -s.r):
            return False
        _this = self.pright
        if (((((_this.nx * p_x) + ((_this.ny * p_y))) + ((_this.nz * p_z))) - _this.d) < -s.r):
            return False
        _this = self.ptop
        if (((((_this.nx * p_x) + ((_this.ny * p_y))) + ((_this.nz * p_z))) - _this.d) < -s.r):
            return False
        _this = self.pbottom
        if (((((_this.nx * p_x) + ((_this.ny * p_y))) + ((_this.nz * p_z))) - _this.d) < -s.r):
            return False
        if self.checkNearFar:
            _this = self.pnear
            if (((((_this.nx * p_x) + ((_this.ny * p_y))) + ((_this.nz * p_z))) - _this.d) < -s.r):
                return False
            _this = self.pfar
            if (((((_this.nx * p_x) + ((_this.ny * p_y))) + ((_this.nz * p_z))) - _this.d) < -s.r):
                return False
        return True

    def hasBounds(self,b):
        p = self.pleft
        a = p.nx
        b1 = p.ny
        c = p.nz
        dd = (((a * ((b.xMax + b.xMin))) + ((b1 * ((b.yMax + b.yMin))))) + ((c * ((b.zMax + b.zMin)))))
        if (a < 0):
            a = -a
        if (b1 < 0):
            b1 = -b1
        if (c < 0):
            c = -c
        rr = (((a * ((b.xMax - b.xMin))) + ((b1 * ((b.yMax - b.yMin))))) + ((c * ((b.zMax - b.zMin)))))
        if (((dd + rr) - ((p.d * 2))) < 0):
            return False
        p = self.pright
        a = p.nx
        b1 = p.ny
        c = p.nz
        dd = (((a * ((b.xMax + b.xMin))) + ((b1 * ((b.yMax + b.yMin))))) + ((c * ((b.zMax + b.zMin)))))
        if (a < 0):
            a = -a
        if (b1 < 0):
            b1 = -b1
        if (c < 0):
            c = -c
        rr = (((a * ((b.xMax - b.xMin))) + ((b1 * ((b.yMax - b.yMin))))) + ((c * ((b.zMax - b.zMin)))))
        if (((dd + rr) - ((p.d * 2))) < 0):
            return False
        p = self.ptop
        a = p.nx
        b1 = p.ny
        c = p.nz
        dd = (((a * ((b.xMax + b.xMin))) + ((b1 * ((b.yMax + b.yMin))))) + ((c * ((b.zMax + b.zMin)))))
        if (a < 0):
            a = -a
        if (b1 < 0):
            b1 = -b1
        if (c < 0):
            c = -c
        rr = (((a * ((b.xMax - b.xMin))) + ((b1 * ((b.yMax - b.yMin))))) + ((c * ((b.zMax - b.zMin)))))
        if (((dd + rr) - ((p.d * 2))) < 0):
            return False
        p = self.ptop
        a = p.nx
        b1 = p.ny
        c = p.nz
        dd = (((a * ((b.xMax + b.xMin))) + ((b1 * ((b.yMax + b.yMin))))) + ((c * ((b.zMax + b.zMin)))))
        if (a < 0):
            a = -a
        if (b1 < 0):
            b1 = -b1
        if (c < 0):
            c = -c
        rr = (((a * ((b.xMax - b.xMin))) + ((b1 * ((b.yMax - b.yMin))))) + ((c * ((b.zMax - b.zMin)))))
        if (((dd + rr) - ((p.d * 2))) < 0):
            return False
        p = self.pnear
        a = p.nx
        b1 = p.ny
        c = p.nz
        dd = (((a * ((b.xMax + b.xMin))) + ((b1 * ((b.yMax + b.yMin))))) + ((c * ((b.zMax + b.zMin)))))
        if (a < 0):
            a = -a
        if (b1 < 0):
            b1 = -b1
        if (c < 0):
            c = -c
        rr = (((a * ((b.xMax - b.xMin))) + ((b1 * ((b.yMax - b.yMin))))) + ((c * ((b.zMax - b.zMin)))))
        if (((dd + rr) - ((p.d * 2))) < 0):
            return False
        p = self.pfar
        a = p.nx
        b1 = p.ny
        c = p.nz
        dd = (((a * ((b.xMax + b.xMin))) + ((b1 * ((b.yMax + b.yMin))))) + ((c * ((b.zMax + b.zMin)))))
        if (a < 0):
            a = -a
        if (b1 < 0):
            b1 = -b1
        if (c < 0):
            c = -c
        rr = (((a * ((b.xMax - b.xMin))) + ((b1 * ((b.yMax - b.yMin))))) + ((c * ((b.zMax - b.zMin)))))
        if (((dd + rr) - ((p.d * 2))) < 0):
            return False
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pleft = None
        _hx_o.pright = None
        _hx_o.ptop = None
        _hx_o.pbottom = None
        _hx_o.pnear = None
        _hx_o.pfar = None
        _hx_o.checkNearFar = None
h3d_col_Frustum._hx_class = h3d_col_Frustum
_hx_classes["h3d.col.Frustum"] = h3d_col_Frustum


class h3d_col_Ray:
    _hx_class_name = "h3d.col.Ray"
    _hx_is_interface = "False"
    __slots__ = ("px", "py", "pz", "lx", "ly", "lz")
    _hx_fields = ["px", "py", "pz", "lx", "ly", "lz"]
    _hx_methods = ["clone", "load", "normalize", "transform", "getPos", "getDir", "getPoint", "toString", "intersect", "collideFrustum", "collide"]
    _hx_statics = ["fromPoints", "fromValues"]

    def __init__(self):
        self.lz = None
        self.ly = None
        self.lx = None
        self.pz = None
        self.py = None
        self.px = None

    def clone(self):
        r = h3d_col_Ray()
        r.px = self.px
        r.py = self.py
        r.pz = self.pz
        r.lx = self.lx
        r.ly = self.ly
        r.lz = self.lz
        return r

    def load(self,r):
        self.px = r.px
        self.py = r.py
        self.pz = r.pz
        self.lx = r.lx
        self.ly = r.ly
        self.lz = r.lz

    def normalize(self):
        l = (((self.lx * self.lx) + ((self.ly * self.ly))) + ((self.lz * self.lz)))
        if (l == 1.):
            return
        if (l < 1e-10):
            l = 0
        else:
            l = (1. / ((Math.NaN if ((l < 0)) else python_lib_Math.sqrt(l))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.lx
        _hx_local_0.lx = (_hx_local_1 * l)
        _hx_local_0.lx
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.ly
        _hx_local_2.ly = (_hx_local_3 * l)
        _hx_local_2.ly
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.lz
        _hx_local_4.lz = (_hx_local_5 * l)
        _hx_local_4.lz

    def transform(self,m):
        x = self.px
        y = self.py
        z = self.pz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        p_w = 1.
        px = ((((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31))) + ((p_w * m._41)))
        py = ((((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32))) + ((p_w * m._42)))
        pz = ((((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33))) + ((p_w * m._43)))
        p_x = px
        p_y = py
        p_z = pz
        self.px = p_x
        self.py = p_y
        self.pz = p_z
        x = self.lx
        y = self.ly
        z = self.lz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        l_x = x
        l_y = y
        l_z = z
        l_w = 1.
        px = (((l_x * m._11) + ((l_y * m._21))) + ((l_z * m._31)))
        py = (((l_x * m._12) + ((l_y * m._22))) + ((l_z * m._32)))
        pz = (((l_x * m._13) + ((l_y * m._23))) + ((l_z * m._33)))
        l_x = px
        l_y = py
        l_z = pz
        self.lx = l_x
        self.ly = l_y
        self.lz = l_z
        self.normalize()

    def getPos(self):
        return h3d_col_Point(self.px,self.py,self.pz)

    def getDir(self):
        return h3d_col_Point(self.lx,self.ly,self.lz)

    def getPoint(self,distance):
        return h3d_col_Point((self.px + ((distance * self.lx))),(self.py + ((distance * self.ly))),(self.pz + ((distance * self.lz))))

    def toString(self):
        return (((("Ray{" + Std.string(h3d_col_Point(self.px,self.py,self.pz))) + ",") + Std.string(h3d_col_Point(self.lx,self.ly,self.lz))) + "}")

    def intersect(self,p):
        d = (((self.lx * p.nx) + ((self.ly * p.ny))) + ((self.lz * p.nz)))
        nd = (p.d - ((((self.px * p.nx) + ((self.py * p.ny))) + ((self.pz * p.nz)))))
        if (((-d if ((d < 0)) else d)) < 1e-10):
            if (((-nd if ((nd < 0)) else nd)) < 1e-10):
                return h3d_col_Point(self.px,self.py,self.pz)
            else:
                return None
        else:
            k = (nd / d)
            return h3d_col_Point((self.px + ((self.lx * k))),(self.py + ((self.ly * k))),(self.pz + ((self.lz * k))))

    def collideFrustum(self,mvp):
        x = self.px
        y = self.py
        z = self.pz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        a_x = x
        a_y = y
        a_z = z
        a_w = 1.
        px = ((((a_x * mvp._11) + ((a_y * mvp._21))) + ((a_z * mvp._31))) + ((a_w * mvp._41)))
        py = ((((a_x * mvp._12) + ((a_y * mvp._22))) + ((a_z * mvp._32))) + ((a_w * mvp._42)))
        pz = ((((a_x * mvp._13) + ((a_y * mvp._23))) + ((a_z * mvp._33))) + ((a_w * mvp._43)))
        iw = (1 / (((((a_x * mvp._14) + ((a_y * mvp._24))) + ((a_z * mvp._34))) + ((a_w * mvp._44)))))
        a_x = (px * iw)
        a_y = (py * iw)
        a_z = (pz * iw)
        a_w = 1
        x = (self.px + self.lx)
        y = (self.py + self.ly)
        z = (self.pz + self.lz)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        b_x = x
        b_y = y
        b_z = z
        b_w = 1.
        px = ((((b_x * mvp._11) + ((b_y * mvp._21))) + ((b_z * mvp._31))) + ((b_w * mvp._41)))
        py = ((((b_x * mvp._12) + ((b_y * mvp._22))) + ((b_z * mvp._32))) + ((b_w * mvp._42)))
        pz = ((((b_x * mvp._13) + ((b_y * mvp._23))) + ((b_z * mvp._33))) + ((b_w * mvp._43)))
        iw = (1 / (((((b_x * mvp._14) + ((b_y * mvp._24))) + ((b_z * mvp._34))) + ((b_w * mvp._44)))))
        b_x = (px * iw)
        b_y = (py * iw)
        b_z = (pz * iw)
        b_w = 1
        lx = (b_x - a_x)
        ly = (b_y - a_y)
        lz = (b_z - a_z)
        dx = (1 / lx)
        dy = (1 / ly)
        dz = (1 / lz)
        t1 = (((-1 - a_x)) * dx)
        t2 = (((1 - a_x)) * dx)
        t3 = (((-1 - a_y)) * dy)
        t4 = (((1 - a_y)) * dy)
        t5 = (((0 - a_z)) * dz)
        t6 = (((1 - a_z)) * dz)
        a = (t2 if ((t1 > t2)) else t1)
        b = (t4 if ((t3 > t4)) else t3)
        a1 = (b if ((a < b)) else a)
        b = (t6 if ((t5 > t6)) else t5)
        tmin = (b if ((a1 < b)) else a1)
        a = (t2 if ((t1 < t2)) else t1)
        b = (t4 if ((t3 < t4)) else t3)
        a1 = (b if ((a > b)) else a)
        b = (t6 if ((t5 < t6)) else t5)
        tmax = (b if ((a1 > b)) else a1)
        return (not (((tmax < 0) or ((tmin > tmax)))))

    def collide(self,b):
        dx = (1 / self.lx)
        dy = (1 / self.ly)
        dz = (1 / self.lz)
        t1 = (((b.xMin - self.px)) * dx)
        t2 = (((b.xMax - self.px)) * dx)
        t3 = (((b.yMin - self.py)) * dy)
        t4 = (((b.yMax - self.py)) * dy)
        t5 = (((b.zMin - self.pz)) * dz)
        t6 = (((b.zMax - self.pz)) * dz)
        a = (t2 if ((t1 > t2)) else t1)
        b = (t4 if ((t3 > t4)) else t3)
        a1 = (b if ((a < b)) else a)
        b = (t6 if ((t5 > t6)) else t5)
        tmin = (b if ((a1 < b)) else a1)
        a = (t2 if ((t1 < t2)) else t1)
        b = (t4 if ((t3 < t4)) else t3)
        a1 = (b if ((a > b)) else a)
        b = (t6 if ((t5 < t6)) else t5)
        tmax = (b if ((a1 > b)) else a1)
        if (tmax < 0):
            return False
        elif (tmin > tmax):
            return False
        else:
            return True

    @staticmethod
    def fromPoints(p1,p2):
        r = h3d_col_Ray()
        r.px = p1.x
        r.py = p1.y
        r.pz = p1.z
        r.lx = (p2.x - p1.x)
        r.ly = (p2.y - p1.y)
        r.lz = (p2.z - p1.z)
        r.normalize()
        return r

    @staticmethod
    def fromValues(x,y,z,dx,dy,dz):
        r = h3d_col_Ray()
        r.px = x
        r.py = y
        r.pz = z
        r.lx = dx
        r.ly = dy
        r.lz = dz
        r.normalize()
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.px = None
        _hx_o.py = None
        _hx_o.pz = None
        _hx_o.lx = None
        _hx_o.ly = None
        _hx_o.lz = None
h3d_col_Ray._hx_class = h3d_col_Ray
_hx_classes["h3d.col.Ray"] = h3d_col_Ray


class h3d_col_ObjectCollider:
    _hx_class_name = "h3d.col.ObjectCollider"
    _hx_is_interface = "False"
    __slots__ = ("obj", "collider")
    _hx_fields = ["obj", "collider"]
    _hx_methods = ["rayIntersection", "contains", "inFrustum", "inSphere"]
    _hx_statics = ["TMP_RAY", "TMP_MAT"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport, h3d_col_Collider]

    def __init__(self,obj,collider):
        self.obj = obj
        self.collider = collider

    def rayIntersection(self,r,bestMatch):
        tmpRay = h3d_col_ObjectCollider.TMP_RAY
        h3d_col_ObjectCollider.TMP_RAY = None
        tmpRay.px = r.px
        tmpRay.py = r.py
        tmpRay.pz = r.pz
        tmpRay.lx = r.lx
        tmpRay.ly = r.ly
        tmpRay.lz = r.lz
        m = self.obj.getInvPos()
        x = r.px
        y = r.py
        z = r.pz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        p_w = 1.
        px = ((((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31))) + ((p_w * m._41)))
        py = ((((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32))) + ((p_w * m._42)))
        pz = ((((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33))) + ((p_w * m._43)))
        p_x = px
        p_y = py
        p_z = pz
        r.px = p_x
        r.py = p_y
        r.pz = p_z
        x = r.lx
        y = r.ly
        z = r.lz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        l_x = x
        l_y = y
        l_z = z
        l_w = 1.
        px = (((l_x * m._11) + ((l_y * m._21))) + ((l_z * m._31)))
        py = (((l_x * m._12) + ((l_y * m._22))) + ((l_z * m._32)))
        pz = (((l_x * m._13) + ((l_y * m._23))) + ((l_z * m._33)))
        l_x = px
        l_y = py
        l_z = pz
        r.lx = l_x
        r.ly = l_y
        r.lz = l_z
        r.normalize()
        hit = self.collider.rayIntersection(r,bestMatch)
        if (hit < 0):
            r.px = tmpRay.px
            r.py = tmpRay.py
            r.pz = tmpRay.pz
            r.lx = tmpRay.lx
            r.ly = tmpRay.ly
            r.lz = tmpRay.lz
            h3d_col_ObjectCollider.TMP_RAY = tmpRay
            return hit
        x = (r.px + ((hit * r.lx)))
        y = (r.py + ((hit * r.ly)))
        z = (r.pz + ((hit * r.lz)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        pt_x = x
        pt_y = y
        pt_z = z
        m = self.obj.absPos
        px = ((((pt_x * m._11) + ((pt_y * m._21))) + ((pt_z * m._31))) + m._41)
        py = ((((pt_x * m._12) + ((pt_y * m._22))) + ((pt_z * m._32))) + m._42)
        pz = ((((pt_x * m._13) + ((pt_y * m._23))) + ((pt_z * m._33))) + m._43)
        pt_x = px
        pt_y = py
        pt_z = pz
        r.px = tmpRay.px
        r.py = tmpRay.py
        r.pz = tmpRay.pz
        r.lx = tmpRay.lx
        r.ly = tmpRay.ly
        r.lz = tmpRay.lz
        h3d_col_ObjectCollider.TMP_RAY = tmpRay
        dx = (pt_x - r.px)
        dy = (pt_y - r.py)
        dz = (pt_z - r.pz)
        if (dz is None):
            dz = 0.
        dz1 = dz
        if (dz1 is None):
            dz1 = 0.
        f = (((dx * dx) + ((dy * dy))) + ((dz1 * dz1)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def contains(self,p):
        x = p.x
        y = p.y
        z = p.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ptmp_x = x
        ptmp_y = y
        ptmp_z = z
        m = self.obj.getInvPos()
        px = ((((p.x * m._11) + ((p.y * m._21))) + ((p.z * m._31))) + m._41)
        py = ((((p.x * m._12) + ((p.y * m._22))) + ((p.z * m._32))) + m._42)
        pz = ((((p.x * m._13) + ((p.y * m._23))) + ((p.z * m._33))) + m._43)
        p.x = px
        p.y = py
        p.z = pz
        b = self.collider.contains(p)
        p.x = ptmp_x
        p.y = ptmp_y
        p.z = ptmp_z
        return b

    def inFrustum(self,f,m = None):
        if (m is None):
            return self.collider.inFrustum(f,self.obj.getAbsPos())
        mat = h3d_col_ObjectCollider.TMP_MAT
        b = self.obj.getAbsPos()
        m11 = m._11
        m12 = m._12
        m13 = m._13
        m21 = m._21
        m22 = m._22
        m23 = m._23
        a31 = m._31
        a32 = m._32
        a33 = m._33
        a41 = m._41
        a42 = m._42
        a43 = m._43
        b11 = b._11
        b12 = b._12
        b13 = b._13
        b21 = b._21
        b22 = b._22
        b23 = b._23
        b31 = b._31
        b32 = b._32
        b33 = b._33
        b41 = b._41
        b42 = b._42
        b43 = b._43
        mat._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
        mat._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
        mat._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
        mat._14 = 0
        mat._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
        mat._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
        mat._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
        mat._24 = 0
        mat._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
        mat._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
        mat._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
        mat._34 = 0
        mat._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
        mat._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
        mat._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
        mat._44 = 1
        return self.collider.inFrustum(f,mat)

    def inSphere(self,s):
        invMat = self.obj.getInvPos()
        oldX = s.x
        oldY = s.y
        oldZ = s.z
        oldR = s.r
        x = s.x
        y = s.y
        z = s.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        center_x = x
        center_y = y
        center_z = z
        px = ((((center_x * invMat._11) + ((center_y * invMat._21))) + ((center_z * invMat._31))) + invMat._41)
        py = ((((center_x * invMat._12) + ((center_y * invMat._22))) + ((center_z * invMat._32))) + invMat._42)
        pz = ((((center_x * invMat._13) + ((center_y * invMat._23))) + ((center_z * invMat._33))) + invMat._43)
        center_x = px
        center_y = py
        center_z = pz
        v = None
        if (v is None):
            v = h3d_Vector()
        f = (((invMat._11 * invMat._11) + ((invMat._12 * invMat._12))) + ((invMat._13 * invMat._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((invMat._21 * invMat._21) + ((invMat._22 * invMat._22))) + ((invMat._23 * invMat._23)))
        v.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((invMat._31 * invMat._31) + ((invMat._32 * invMat._32))) + ((invMat._33 * invMat._33)))
        v.z = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if ((((invMat._11 * (((invMat._22 * invMat._33) - ((invMat._23 * invMat._32))))) + ((invMat._12 * (((invMat._23 * invMat._31) - ((invMat._21 * invMat._33))))))) + ((invMat._13 * (((invMat._21 * invMat._32) - ((invMat._22 * invMat._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        scale = v
        s.x = center_x
        s.y = center_y
        s.z = center_z
        s1 = s
        s2 = s1.r
        a = scale.x
        b = scale.y
        a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        b = scale.z
        s1.r = (s2 * ((a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else max(a1,b)))))
        res = self.collider.inSphere(s)
        s.x = oldX
        s.y = oldY
        s.z = oldZ
        s.r = oldR
        return res

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.collider = None
h3d_col_ObjectCollider._hx_class = h3d_col_ObjectCollider
_hx_classes["h3d.col.ObjectCollider"] = h3d_col_ObjectCollider


class h3d_col_Plane:
    _hx_class_name = "h3d.col.Plane"
    _hx_is_interface = "False"
    __slots__ = ("nx", "ny", "nz", "d")
    _hx_fields = ["nx", "ny", "nz", "d"]
    _hx_methods = ["getNormal", "getNormalDistance", "load", "transform", "transform3x3", "transformInverseTranspose", "normalize", "toString", "distance", "side", "project", "projectTo"]
    _hx_statics = ["fromPoints", "fromNormalPoint", "X", "Y", "Z", "frustumLeft", "frustumRight", "frustumBottom", "frustumTop", "frustumNear", "frustumFar"]

    def __init__(self,nx,ny,nz,d):
        self.nx = nx
        self.ny = ny
        self.nz = nz
        self.d = d

    def getNormal(self):
        return h3d_col_Point(self.nx,self.ny,self.nz)

    def getNormalDistance(self):
        return self.d

    def load(self,p):
        self.nx = p.nx
        self.ny = p.ny
        self.nz = p.nz
        self.d = p.d

    def transform(self,m):
        m2 = h3d_Matrix()
        m2.initInverse(m)
        m2.transpose()
        x = self.nx
        y = self.ny
        z = self.nz
        w = -self.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        self.nx = v_x
        self.ny = v_y
        self.nz = v_z
        self.d = -v_w

    def transform3x3(self,m):
        m2 = h3d_Matrix()
        m2.initInverse3x3(m)
        m2.transpose()
        x = self.nx
        y = self.ny
        z = self.nz
        w = -self.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        self.nx = v_x
        self.ny = v_y
        self.nz = v_z
        self.d = -v_w

    def transformInverseTranspose(self,m):
        x = self.nx
        y = self.ny
        z = self.nz
        w = -self.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + ((v_w * m._41)))
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + ((v_w * m._42)))
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + ((v_w * m._43)))
        pw = ((((v_x * m._14) + ((v_y * m._24))) + ((v_z * m._34))) + ((v_w * m._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        self.nx = v_x
        self.ny = v_y
        self.nz = v_z
        self.d = -v_w

    def normalize(self):
        f = (((self.nx * self.nx) + ((self.ny * self.ny))) + ((self.nz * self.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nx
        _hx_local_0.nx = (_hx_local_1 * _hx_len)
        _hx_local_0.nx
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.ny
        _hx_local_2.ny = (_hx_local_3 * _hx_len)
        _hx_local_2.ny
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.nz
        _hx_local_4.nz = (_hx_local_5 * _hx_len)
        _hx_local_4.nz
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.d
        _hx_local_6.d = (_hx_local_7 * _hx_len)
        _hx_local_6.d

    def toString(self):
        return (((("Plane{" + Std.string(h3d_col_Point(self.nx,self.ny,self.nz))) + ",") + Std.string(hxd_Math.fmt(self.d))) + "}")

    def distance(self,p):
        return ((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d)

    def side(self,p):
        return (((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d) >= 0)

    def project(self,p):
        d = ((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d)
        return h3d_col_Point((p.x - ((d * self.nx))),(p.y - ((d * self.ny))),(p.z - ((d * self.nz))))

    def projectTo(self,p,out):
        d = ((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d)
        out.x = (p.x - ((d * self.nx)))
        out.y = (p.y - ((d * self.ny)))
        out.z = (p.z - ((d * self.nz)))

    @staticmethod
    def fromPoints(p0,p1,p2):
        x = (p1.x - p0.x)
        y = (p1.y - p0.y)
        z = (p1.z - p0.z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d1_x = x
        d1_y = y
        d1_z = z
        x = (p2.x - p0.x)
        y = (p2.y - p0.y)
        z = (p2.z - p0.z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d2_x = x
        d2_y = y
        d2_z = z
        x = ((d1_y * d2_z) - ((d1_z * d2_y)))
        y = ((d1_z * d2_x) - ((d1_x * d2_z)))
        z = ((d1_x * d2_y) - ((d1_y * d2_x)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        n_x = x
        n_y = y
        n_z = z
        return h3d_col_Plane(n_x,n_y,n_z,(((n_x * p0.x) + ((n_y * p0.y))) + ((n_z * p0.z))))

    @staticmethod
    def fromNormalPoint(n,p):
        return h3d_col_Plane(n.x,n.y,n.z,(((n.x * p.x) + ((n.y * p.y))) + ((n.z * p.z))))

    @staticmethod
    def X(v = None):
        if (v is None):
            v = 0.0
        return h3d_col_Plane(1,0,0,v)

    @staticmethod
    def Y(v = None):
        if (v is None):
            v = 0.0
        return h3d_col_Plane(0,1,0,v)

    @staticmethod
    def Z(v = None):
        if (v is None):
            v = 0.0
        return h3d_col_Plane(0,0,1,v)

    @staticmethod
    def frustumLeft(mvp):
        return h3d_col_Plane((mvp._14 + mvp._11),(mvp._24 + mvp._21),(mvp._34 + mvp._31),-((mvp._44 + mvp._41)))

    @staticmethod
    def frustumRight(mvp):
        return h3d_col_Plane((mvp._14 - mvp._11),(mvp._24 - mvp._21),(mvp._34 - mvp._31),(mvp._41 - mvp._44))

    @staticmethod
    def frustumBottom(mvp):
        return h3d_col_Plane((mvp._14 + mvp._12),(mvp._24 + mvp._22),(mvp._34 + mvp._32),-((mvp._44 + mvp._42)))

    @staticmethod
    def frustumTop(mvp):
        return h3d_col_Plane((mvp._14 - mvp._12),(mvp._24 - mvp._22),(mvp._34 - mvp._32),(mvp._42 - mvp._44))

    @staticmethod
    def frustumNear(mvp):
        return h3d_col_Plane(mvp._13,mvp._23,mvp._33,-mvp._43)

    @staticmethod
    def frustumFar(mvp):
        return h3d_col_Plane((mvp._14 - mvp._13),(mvp._24 - mvp._23),(mvp._34 - mvp._33),(mvp._43 - mvp._44))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nx = None
        _hx_o.ny = None
        _hx_o.nz = None
        _hx_o.d = None
h3d_col_Plane._hx_class = h3d_col_Plane
_hx_classes["h3d.col.Plane"] = h3d_col_Plane


class h3d_col_Point:
    _hx_class_name = "h3d.col.Point"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z")
    _hx_fields = ["x", "y", "z"]
    _hx_methods = ["scale", "set", "sub", "add", "multiply", "cross", "equals", "lengthSq", "length", "dot", "distanceSq", "distance", "normalize", "normalized", "lerp", "transform", "transformed", "transform3x3", "transformed3x3", "clone", "load", "toString", "inFrustum", "toVector"]

    def __init__(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        self.x = x
        self.y = y
        self.z = z

    def scale(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * v)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * v)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * v)
        _hx_local_4.z

    def set(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        self.x = x
        self.y = y
        self.z = z

    def sub(self,p):
        return h3d_col_Point((self.x - p.x),(self.y - p.y),(self.z - p.z))

    def add(self,p):
        return h3d_col_Point((self.x + p.x),(self.y + p.y),(self.z + p.z))

    def multiply(self,v):
        return h3d_col_Point((self.x * v),(self.y * v),(self.z * v))

    def cross(self,p):
        return h3d_col_Point(((self.y * p.z) - ((self.z * p.y))),((self.z * p.x) - ((self.x * p.z))),((self.x * p.y) - ((self.y * p.x))))

    def equals(self,other):
        if ((self.x == other.x) and ((self.y == other.y))):
            return (self.z == other.z)
        else:
            return False

    def lengthSq(self):
        return (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))

    def length(self):
        f = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def dot(self,p):
        return (((self.x * p.x) + ((self.y * p.y))) + ((self.z * p.z)))

    def distanceSq(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        dz = (p.z - self.z)
        return (((dx * dx) + ((dy * dy))) + ((dz * dz)))

    def distance(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        dz = (p.z - self.z)
        f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def normalize(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * k)
        _hx_local_4.z

    def normalized(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        return h3d_col_Point((self.x * k),(self.y * k),(self.z * k))

    def lerp(self,p1,p2,k):
        a = p1.x
        x = (a + ((k * ((p2.x - a)))))
        a = p1.y
        y = (a + ((k * ((p2.y - a)))))
        a = p1.z
        z = (a + ((k * ((p2.z - a)))))
        self.x = x
        self.y = y
        self.z = z

    def transform(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + m._41)
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + m._42)
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + m._43)
        self.x = px
        self.y = py
        self.z = pz

    def transformed(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + m._41)
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + m._42)
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + m._43)
        return h3d_col_Point(px,py,pz)

    def transform3x3(self,m):
        px = (((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31)))
        py = (((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32)))
        pz = (((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33)))
        self.x = px
        self.y = py
        self.z = pz

    def transformed3x3(self,m):
        px = (((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31)))
        py = (((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32)))
        pz = (((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33)))
        return h3d_col_Point(px,py,pz)

    def clone(self):
        return h3d_col_Point(self.x,self.y,self.z)

    def load(self,p):
        self.x = p.x
        self.y = p.y
        self.z = p.z

    def toString(self):
        return (((((("Point{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.z))) + "}")

    def inFrustum(self,f,m = None):
        return f.hasPoint(self)

    def toVector(self):
        return h3d_Vector(self.x,self.y,self.z)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
h3d_col_Point._hx_class = h3d_col_Point
_hx_classes["h3d.col.Point"] = h3d_col_Point


class h3d_col_TriPlane:
    _hx_class_name = "h3d.col.TriPlane"
    _hx_is_interface = "False"
    __slots__ = ("next", "p0x", "p0y", "p0z", "d1x", "d1y", "d1z", "d2x", "d2y", "d2z", "dot00", "dot01", "dot11", "invDenom", "nx", "ny", "nz", "d")
    _hx_fields = ["next", "p0x", "p0y", "p0z", "d1x", "d1y", "d1z", "d2x", "d2y", "d2z", "dot00", "dot01", "dot11", "invDenom", "nx", "ny", "nz", "d"]
    _hx_methods = ["init", "clone", "load", "transform", "contains", "side", "inFrustum", "inSphere", "rayIntersection", "isPointInTriangle", "getPoints"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self):
        self.d = None
        self.nz = None
        self.ny = None
        self.nx = None
        self.invDenom = None
        self.dot11 = None
        self.dot01 = None
        self.dot00 = None
        self.d2z = None
        self.d2y = None
        self.d2x = None
        self.d1z = None
        self.d1y = None
        self.d1x = None
        self.p0z = None
        self.p0y = None
        self.p0x = None
        self.next = None

    def init(self,p0,p1,p2):
        self.p0x = p0.x
        self.p0y = p0.y
        self.p0z = p0.z
        x = (p1.x - p0.x)
        y = (p1.y - p0.y)
        z = (p1.z - p0.z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d1_x = x
        d1_y = y
        d1_z = z
        x = (p2.x - p0.x)
        y = (p2.y - p0.y)
        z = (p2.z - p0.z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d2_x = x
        d2_y = y
        d2_z = z
        x = ((d1_y * d2_z) - ((d1_z * d2_y)))
        y = ((d1_z * d2_x) - ((d1_x * d2_z)))
        z = ((d1_x * d2_y) - ((d1_y * d2_x)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        n_x = x
        n_y = y
        n_z = z
        self.d = (((n_x * p0.x) + ((n_y * p0.y))) + ((n_z * p0.z)))
        self.nx = n_x
        self.ny = n_y
        self.nz = n_z
        self.d1x = d1_x
        self.d1y = d1_y
        self.d1z = d1_z
        self.d2x = d2_x
        self.d2y = d2_y
        self.d2z = d2_z
        self.dot00 = (((d1_x * d1_x) + ((d1_y * d1_y))) + ((d1_z * d1_z)))
        self.dot01 = (((d1_x * d2_x) + ((d1_y * d2_y))) + ((d1_z * d2_z)))
        self.dot11 = (((d2_x * d2_x) + ((d2_y * d2_y))) + ((d2_z * d2_z)))
        self.invDenom = (1 / (((self.dot00 * self.dot11) - ((self.dot01 * self.dot01)))))

    def clone(self):
        clone = h3d_col_TriPlane()
        clone.p0x = self.p0x
        clone.p0y = self.p0y
        clone.p0z = self.p0z
        clone.d1x = self.d1x
        clone.d1y = self.d1y
        clone.d1z = self.d1z
        clone.d2x = self.d2x
        clone.d2y = self.d2y
        clone.d2z = self.d2z
        clone.dot00 = self.dot00
        clone.dot01 = self.dot01
        clone.dot11 = self.dot11
        clone.invDenom = self.invDenom
        clone.nx = self.nx
        clone.ny = self.ny
        clone.nz = self.nz
        clone.d = self.d
        if (self.next is not None):
            clone.next = self.next.clone()
        return clone

    def load(self,tp):
        self.p0x = tp.p0x
        self.p0y = tp.p0y
        self.p0z = tp.p0z
        self.d1x = tp.d1x
        self.d1y = tp.d1y
        self.d1z = tp.d1z
        self.d2x = tp.d2x
        self.d2y = tp.d2y
        self.d2z = tp.d2z
        self.dot00 = tp.dot00
        self.dot01 = tp.dot01
        self.dot11 = tp.dot11
        self.invDenom = tp.invDenom
        self.nx = tp.nx
        self.ny = tp.ny
        self.nz = tp.nz
        self.d = tp.d

    def transform(self,m):
        x = self.p0x
        y = self.p0y
        z = self.p0z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p0_x = x
        p0_y = y
        p0_z = z
        x = (self.d1x + self.p0x)
        y = (self.d1y + self.p0y)
        z = (self.d1z + self.p0z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p1_x = x
        p1_y = y
        p1_z = z
        x = (self.d2x + self.p0x)
        y = (self.d2y + self.p0y)
        z = (self.d2z + self.p0z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p2_x = x
        p2_y = y
        p2_z = z
        px = ((((p0_x * m._11) + ((p0_y * m._21))) + ((p0_z * m._31))) + m._41)
        py = ((((p0_x * m._12) + ((p0_y * m._22))) + ((p0_z * m._32))) + m._42)
        pz = ((((p0_x * m._13) + ((p0_y * m._23))) + ((p0_z * m._33))) + m._43)
        p0_x = px
        p0_y = py
        p0_z = pz
        px = ((((p1_x * m._11) + ((p1_y * m._21))) + ((p1_z * m._31))) + m._41)
        py = ((((p1_x * m._12) + ((p1_y * m._22))) + ((p1_z * m._32))) + m._42)
        pz = ((((p1_x * m._13) + ((p1_y * m._23))) + ((p1_z * m._33))) + m._43)
        p1_x = px
        p1_y = py
        p1_z = pz
        px = ((((p2_x * m._11) + ((p2_y * m._21))) + ((p2_z * m._31))) + m._41)
        py = ((((p2_x * m._12) + ((p2_y * m._22))) + ((p2_z * m._32))) + m._42)
        pz = ((((p2_x * m._13) + ((p2_y * m._23))) + ((p2_z * m._33))) + m._43)
        p2_x = px
        p2_y = py
        p2_z = pz
        self.p0x = p0_x
        self.p0y = p0_y
        self.p0z = p0_z
        x = (p1_x - p0_x)
        y = (p1_y - p0_y)
        z = (p1_z - p0_z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d1_x = x
        d1_y = y
        d1_z = z
        x = (p2_x - p0_x)
        y = (p2_y - p0_y)
        z = (p2_z - p0_z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d2_x = x
        d2_y = y
        d2_z = z
        x = ((d1_y * d2_z) - ((d1_z * d2_y)))
        y = ((d1_z * d2_x) - ((d1_x * d2_z)))
        z = ((d1_x * d2_y) - ((d1_y * d2_x)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        n_x = x
        n_y = y
        n_z = z
        self.d = (((n_x * p0_x) + ((n_y * p0_y))) + ((n_z * p0_z)))
        self.nx = n_x
        self.ny = n_y
        self.nz = n_z
        self.d1x = d1_x
        self.d1y = d1_y
        self.d1z = d1_z
        self.d2x = d2_x
        self.d2y = d2_y
        self.d2z = d2_z
        self.dot00 = (((d1_x * d1_x) + ((d1_y * d1_y))) + ((d1_z * d1_z)))
        self.dot01 = (((d1_x * d2_x) + ((d1_y * d2_y))) + ((d1_z * d2_z)))
        self.dot11 = (((d2_x * d2_x) + ((d2_y * d2_y))) + ((d2_z * d2_z)))
        self.invDenom = (1 / (((self.dot00 * self.dot11) - ((self.dot01 * self.dot01)))))

    def contains(self,p):
        x = (p.x - self.p0x)
        y = (p.y - self.p0y)
        z = (p.z - self.p0z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v2_x = x
        v2_y = y
        v2_z = z
        dot02 = (((self.d1x * v2_x) + ((self.d1y * v2_y))) + ((self.d1z * v2_z)))
        dot12 = (((self.d2x * v2_x) + ((self.d2y * v2_y))) + ((self.d2z * v2_z)))
        u = ((((self.dot11 * dot02) - ((self.dot01 * dot12)))) * self.invDenom)
        v = ((((self.dot00 * dot12) - ((self.dot01 * dot02)))) * self.invDenom)
        if ((u >= 0) and ((v >= 0))):
            return ((u + v) < 1)
        else:
            return False

    def side(self,p):
        return (((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d) >= 0)

    def inFrustum(self,f,m = None):
        raise haxe_Exception.thrown("Not implemented")

    def inSphere(self,s):
        raise haxe_Exception.thrown("Not implemented")

    def rayIntersection(self,r,bestMatch):
        dr = (((r.lx * self.nx) + ((r.ly * self.ny))) + ((r.lz * self.nz)))
        if (dr >= 0):
            return -1.
        nd = (self.d - ((((r.px * self.nx) + ((r.py * self.ny))) + ((r.pz * self.nz)))))
        k = (nd / dr)
        if (k < 0):
            return -1
        px = (r.px + ((r.lx * k)))
        py = (r.py + ((r.ly * k)))
        pz = (r.pz + ((r.lz * k)))
        x = (px - self.p0x)
        y = (py - self.p0y)
        z = (pz - self.p0z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v2_x = x
        v2_y = y
        v2_z = z
        dot02 = (((self.d1x * v2_x) + ((self.d1y * v2_y))) + ((self.d1z * v2_z)))
        dot12 = (((self.d2x * v2_x) + ((self.d2y * v2_y))) + ((self.d2z * v2_z)))
        u = ((((self.dot11 * dot02) - ((self.dot01 * dot12)))) * self.invDenom)
        v = ((((self.dot00 * dot12) - ((self.dot01 * dot02)))) * self.invDenom)
        if (not ((((u >= 0) and ((v >= 0))) and (((u + v) < 1))))):
            return -1
        return k

    def isPointInTriangle(self,x,y,z):
        x1 = (x - self.p0x)
        y1 = (y - self.p0y)
        z1 = (z - self.p0z)
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        v2_x = x1
        v2_y = y1
        v2_z = z1
        dot02 = (((self.d1x * v2_x) + ((self.d1y * v2_y))) + ((self.d1z * v2_z)))
        dot12 = (((self.d2x * v2_x) + ((self.d2y * v2_y))) + ((self.d2z * v2_z)))
        u = ((((self.dot11 * dot02) - ((self.dot01 * dot12)))) * self.invDenom)
        v = ((((self.dot00 * dot12) - ((self.dot01 * dot02)))) * self.invDenom)
        if ((u >= 0) and ((v >= 0))):
            return ((u + v) < 1)
        else:
            return False

    def getPoints(self):
        return [h3d_col_Point(self.p0x,self.p0y,self.p0z), h3d_col_Point((self.d1x + self.p0x),(self.d1y + self.p0y),(self.d1z + self.p0z)), h3d_col_Point((self.d2x + self.p0x),(self.d2y + self.p0y),(self.d2z + self.p0z))]

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.p0x = None
        _hx_o.p0y = None
        _hx_o.p0z = None
        _hx_o.d1x = None
        _hx_o.d1y = None
        _hx_o.d1z = None
        _hx_o.d2x = None
        _hx_o.d2y = None
        _hx_o.d2z = None
        _hx_o.dot00 = None
        _hx_o.dot01 = None
        _hx_o.dot11 = None
        _hx_o.invDenom = None
        _hx_o.nx = None
        _hx_o.ny = None
        _hx_o.nz = None
        _hx_o.d = None
h3d_col_TriPlane._hx_class = h3d_col_TriPlane
_hx_classes["h3d.col.TriPlane"] = h3d_col_TriPlane


class h3d_col_Polygon:
    _hx_class_name = "h3d.col.Polygon"
    _hx_is_interface = "False"
    __slots__ = ("triPlanes",)
    _hx_fields = ["triPlanes"]
    _hx_methods = ["addBuffers", "isConvex", "clone", "transform", "getPoints", "getBounds", "contains", "rayIntersection", "inFrustum", "inSphere"]
    _hx_statics = ["fromPolygon2D"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self):
        self.triPlanes = None

    def addBuffers(self,vertexes,indexes,stride = None):
        if (stride is None):
            stride = 3
        _g = 0
        x = (len(indexes) / 3)
        _g1 = None
        try:
            _g1 = int(x)
        except BaseException as _g2:
            None
            _g1 = None
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            k = (i * 3)
            t = h3d_col_TriPlane()
            i0 = (indexes[k] * stride)
            i1 = (indexes[(k + 1)] * stride)
            i2 = (indexes[(k + 2)] * stride)
            x = python_Syntax._arrayAccess(vertexes,[i0])
            y = python_Syntax._arrayAccess(vertexes,[(i0 + 1)])
            z = python_Syntax._arrayAccess(vertexes,[(i0 + 2)])
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p0_x = x
            p0_y = y
            p0_z = z
            x1 = python_Syntax._arrayAccess(vertexes,[i1])
            y1 = python_Syntax._arrayAccess(vertexes,[(i1 + 1)])
            z1 = python_Syntax._arrayAccess(vertexes,[(i1 + 2)])
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            p1_x = x1
            p1_y = y1
            p1_z = z1
            x2 = python_Syntax._arrayAccess(vertexes,[i2])
            y2 = python_Syntax._arrayAccess(vertexes,[(i2 + 1)])
            z2 = python_Syntax._arrayAccess(vertexes,[(i2 + 2)])
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            p2_x = x2
            p2_y = y2
            p2_z = z2
            t.p0x = p0_x
            t.p0y = p0_y
            t.p0z = p0_z
            x3 = (p1_x - p0_x)
            y3 = (p1_y - p0_y)
            z3 = (p1_z - p0_z)
            if (z3 is None):
                z3 = 0.
            if (y3 is None):
                y3 = 0.
            if (x3 is None):
                x3 = 0.
            d1_x = x3
            d1_y = y3
            d1_z = z3
            x4 = (p2_x - p0_x)
            y4 = (p2_y - p0_y)
            z4 = (p2_z - p0_z)
            if (z4 is None):
                z4 = 0.
            if (y4 is None):
                y4 = 0.
            if (x4 is None):
                x4 = 0.
            d2_x = x4
            d2_y = y4
            d2_z = z4
            x5 = ((d1_y * d2_z) - ((d1_z * d2_y)))
            y5 = ((d1_z * d2_x) - ((d1_x * d2_z)))
            z5 = ((d1_x * d2_y) - ((d1_y * d2_x)))
            if (z5 is None):
                z5 = 0.
            if (y5 is None):
                y5 = 0.
            if (x5 is None):
                x5 = 0.
            n_x = x5
            n_y = y5
            n_z = z5
            t.d = (((n_x * p0_x) + ((n_y * p0_y))) + ((n_z * p0_z)))
            t.nx = n_x
            t.ny = n_y
            t.nz = n_z
            t.d1x = d1_x
            t.d1y = d1_y
            t.d1z = d1_z
            t.d2x = d2_x
            t.d2y = d2_y
            t.d2z = d2_z
            t.dot00 = (((d1_x * d1_x) + ((d1_y * d1_y))) + ((d1_z * d1_z)))
            t.dot01 = (((d1_x * d2_x) + ((d1_y * d2_y))) + ((d1_z * d2_z)))
            t.dot11 = (((d2_x * d2_x) + ((d2_y * d2_y))) + ((d2_z * d2_z)))
            t.invDenom = (1 / (((t.dot00 * t.dot11) - ((t.dot01 * t.dot01)))))
            t.next = self.triPlanes
            self.triPlanes = t

    def isConvex(self):
        return True

    def clone(self):
        clone = h3d_col_Polygon()
        clone.triPlanes = h3d_col_TriPlane()
        _this = self.triPlanes
        clone1 = h3d_col_TriPlane()
        clone1.p0x = _this.p0x
        clone1.p0y = _this.p0y
        clone1.p0z = _this.p0z
        clone1.d1x = _this.d1x
        clone1.d1y = _this.d1y
        clone1.d1z = _this.d1z
        clone1.d2x = _this.d2x
        clone1.d2y = _this.d2y
        clone1.d2z = _this.d2z
        clone1.dot00 = _this.dot00
        clone1.dot01 = _this.dot01
        clone1.dot11 = _this.dot11
        clone1.invDenom = _this.invDenom
        clone1.nx = _this.nx
        clone1.ny = _this.ny
        clone1.nz = _this.nz
        clone1.d = _this.d
        if (_this.next is not None):
            _this1 = _this.next
            clone2 = h3d_col_TriPlane()
            clone2.p0x = _this1.p0x
            clone2.p0y = _this1.p0y
            clone2.p0z = _this1.p0z
            clone2.d1x = _this1.d1x
            clone2.d1y = _this1.d1y
            clone2.d1z = _this1.d1z
            clone2.d2x = _this1.d2x
            clone2.d2y = _this1.d2y
            clone2.d2z = _this1.d2z
            clone2.dot00 = _this1.dot00
            clone2.dot01 = _this1.dot01
            clone2.dot11 = _this1.dot11
            clone2.invDenom = _this1.invDenom
            clone2.nx = _this1.nx
            clone2.ny = _this1.ny
            clone2.nz = _this1.nz
            clone2.d = _this1.d
            if (_this1.next is not None):
                clone2.next = _this1.next.clone()
            clone1.next = clone2
        clone.triPlanes = clone1
        return clone

    def transform(self,m):
        t = self.triPlanes
        while (t is not None):
            t.transform(m)
            t = t.next

    def getPoints(self):
        ret = []
        t = self.triPlanes
        while (t is not None):
            ret = (ret + t.getPoints())
            t = t.next
        return ret

    def getBounds(self,bnds = None):
        if (bnds is None):
            bnds = h3d_col_Bounds()
        bnds.xMin = 1e20
        bnds.xMax = -1e20
        bnds.yMin = 1e20
        bnds.yMax = -1e20
        bnds.zMin = 1e20
        bnds.zMax = -1e20
        t = self.triPlanes
        while (t is not None):
            x = t.p0x
            y = t.p0y
            z = t.p0z
            if (x < bnds.xMin):
                bnds.xMin = x
            if (x > bnds.xMax):
                bnds.xMax = x
            if (y < bnds.yMin):
                bnds.yMin = y
            if (y > bnds.yMax):
                bnds.yMax = y
            if (z < bnds.zMin):
                bnds.zMin = z
            if (z > bnds.zMax):
                bnds.zMax = z
            x1 = (t.d1x + t.p0x)
            y1 = (t.d1y + t.p0y)
            z1 = (t.d1z + t.p0z)
            if (x1 < bnds.xMin):
                bnds.xMin = x1
            if (x1 > bnds.xMax):
                bnds.xMax = x1
            if (y1 < bnds.yMin):
                bnds.yMin = y1
            if (y1 > bnds.yMax):
                bnds.yMax = y1
            if (z1 < bnds.zMin):
                bnds.zMin = z1
            if (z1 > bnds.zMax):
                bnds.zMax = z1
            x2 = (t.d2x + t.p0x)
            y2 = (t.d2y + t.p0y)
            z2 = (t.d2z + t.p0z)
            if (x2 < bnds.xMin):
                bnds.xMin = x2
            if (x2 > bnds.xMax):
                bnds.xMax = x2
            if (y2 < bnds.yMin):
                bnds.yMin = y2
            if (y2 > bnds.yMax):
                bnds.yMax = y2
            if (z2 < bnds.zMin):
                bnds.zMin = z2
            if (z2 > bnds.zMax):
                bnds.zMax = z2
            t = t.next
        return bnds

    def contains(self,p):
        if (not self.isConvex()):
            raise haxe_Exception.thrown("Not implemented for concave polygon")
        t = self.triPlanes
        while (t is not None):
            if (((((t.nx * p.x) + ((t.ny * p.y))) + ((t.nz * p.z))) - t.d) >= 0):
                return False
            t = t.next
        return True

    def rayIntersection(self,r,bestMatch):
        t = self.triPlanes
        best = -1.
        while (t is not None):
            dr = (((r.lx * t.nx) + ((r.ly * t.ny))) + ((r.lz * t.nz)))
            d = None
            if (dr >= 0):
                d = -1.
            else:
                nd = (t.d - ((((r.px * t.nx) + ((r.py * t.ny))) + ((r.pz * t.nz)))))
                k = (nd / dr)
                if (k < 0):
                    d = -1
                else:
                    px = (r.px + ((r.lx * k)))
                    py = (r.py + ((r.ly * k)))
                    pz = (r.pz + ((r.lz * k)))
                    x = (px - t.p0x)
                    y = (py - t.p0y)
                    z = (pz - t.p0z)
                    if (z is None):
                        z = 0.
                    if (y is None):
                        y = 0.
                    if (x is None):
                        x = 0.
                    v2_x = x
                    v2_y = y
                    v2_z = z
                    dot02 = (((t.d1x * v2_x) + ((t.d1y * v2_y))) + ((t.d1z * v2_z)))
                    dot12 = (((t.d2x * v2_x) + ((t.d2y * v2_y))) + ((t.d2z * v2_z)))
                    u = ((((t.dot11 * dot02) - ((t.dot01 * dot12)))) * t.invDenom)
                    v = ((((t.dot00 * dot12) - ((t.dot01 * dot02)))) * t.invDenom)
                    d = (-1 if ((not ((((u >= 0) and ((v >= 0))) and (((u + v) < 1)))))) else k)
            if (d >= 0):
                if (not bestMatch):
                    return d
                if ((best < 0) or ((d < best))):
                    best = d
            t = t.next
        return best

    def inFrustum(self,f,m = None):
        raise haxe_Exception.thrown("Not implemented")

    def inSphere(self,s):
        raise haxe_Exception.thrown("Not implemented")

    @staticmethod
    def fromPolygon2D(p,z = None):
        if (z is None):
            z = 0.
        pout = h3d_col_Polygon()
        if h2d_col__Polygon_Polygon_Impl_.isConvex(p):
            p0 = (p[0] if 0 < len(p) else None)
            _g = 0
            _g1 = (len(p) - 2)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p1 = python_internal_ArrayImpl._get(p, (i + 1))
                p2 = python_internal_ArrayImpl._get(p, (i + 2))
                t = h3d_col_TriPlane()
                x = p0.x
                y = p0.y
                z1 = z
                if (z1 is None):
                    z1 = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p0_x = x
                p0_y = y
                p0_z = z1
                x1 = p1.x
                y1 = p1.y
                z2 = z
                if (z2 is None):
                    z2 = 0.
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                p1_x = x1
                p1_y = y1
                p1_z = z2
                x2 = p2.x
                y2 = p2.y
                z3 = z
                if (z3 is None):
                    z3 = 0.
                if (y2 is None):
                    y2 = 0.
                if (x2 is None):
                    x2 = 0.
                p2_x = x2
                p2_y = y2
                p2_z = z3
                t.p0x = p0_x
                t.p0y = p0_y
                t.p0z = p0_z
                x3 = (p1_x - p0_x)
                y3 = (p1_y - p0_y)
                z4 = (p1_z - p0_z)
                if (z4 is None):
                    z4 = 0.
                if (y3 is None):
                    y3 = 0.
                if (x3 is None):
                    x3 = 0.
                d1_x = x3
                d1_y = y3
                d1_z = z4
                x4 = (p2_x - p0_x)
                y4 = (p2_y - p0_y)
                z5 = (p2_z - p0_z)
                if (z5 is None):
                    z5 = 0.
                if (y4 is None):
                    y4 = 0.
                if (x4 is None):
                    x4 = 0.
                d2_x = x4
                d2_y = y4
                d2_z = z5
                x5 = ((d1_y * d2_z) - ((d1_z * d2_y)))
                y5 = ((d1_z * d2_x) - ((d1_x * d2_z)))
                z6 = ((d1_x * d2_y) - ((d1_y * d2_x)))
                if (z6 is None):
                    z6 = 0.
                if (y5 is None):
                    y5 = 0.
                if (x5 is None):
                    x5 = 0.
                n_x = x5
                n_y = y5
                n_z = z6
                t.d = (((n_x * p0_x) + ((n_y * p0_y))) + ((n_z * p0_z)))
                t.nx = n_x
                t.ny = n_y
                t.nz = n_z
                t.d1x = d1_x
                t.d1y = d1_y
                t.d1z = d1_z
                t.d2x = d2_x
                t.d2y = d2_y
                t.d2z = d2_z
                t.dot00 = (((d1_x * d1_x) + ((d1_y * d1_y))) + ((d1_z * d1_z)))
                t.dot01 = (((d1_x * d2_x) + ((d1_y * d2_y))) + ((d1_z * d2_z)))
                t.dot11 = (((d2_x * d2_x) + ((d2_y * d2_y))) + ((d2_z * d2_z)))
                t.invDenom = (1 / (((t.dot00 * t.dot11) - ((t.dot01 * t.dot01)))))
                t.next = pout.triPlanes
                pout.triPlanes = t
        else:
            idx = h2d_col__Polygon_Polygon_Impl_.fastTriangulate(p)
            _g = 0
            x = (len(idx) / 3)
            _g1 = None
            try:
                _g1 = int(x)
            except BaseException as _g2:
                None
                _g1 = None
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p0 = python_internal_ArrayImpl._get(p, python_internal_ArrayImpl._get(idx, (i * 3)))
                p1 = python_internal_ArrayImpl._get(p, python_internal_ArrayImpl._get(idx, ((i * 3) + 1)))
                p2 = python_internal_ArrayImpl._get(p, python_internal_ArrayImpl._get(idx, ((i * 3) + 2)))
                t = h3d_col_TriPlane()
                x = p0.x
                y = p0.y
                z1 = z
                if (z1 is None):
                    z1 = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p0_x = x
                p0_y = y
                p0_z = z1
                x1 = p1.x
                y1 = p1.y
                z2 = z
                if (z2 is None):
                    z2 = 0.
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                p1_x = x1
                p1_y = y1
                p1_z = z2
                x2 = p2.x
                y2 = p2.y
                z3 = z
                if (z3 is None):
                    z3 = 0.
                if (y2 is None):
                    y2 = 0.
                if (x2 is None):
                    x2 = 0.
                p2_x = x2
                p2_y = y2
                p2_z = z3
                t.p0x = p0_x
                t.p0y = p0_y
                t.p0z = p0_z
                x3 = (p1_x - p0_x)
                y3 = (p1_y - p0_y)
                z4 = (p1_z - p0_z)
                if (z4 is None):
                    z4 = 0.
                if (y3 is None):
                    y3 = 0.
                if (x3 is None):
                    x3 = 0.
                d1_x = x3
                d1_y = y3
                d1_z = z4
                x4 = (p2_x - p0_x)
                y4 = (p2_y - p0_y)
                z5 = (p2_z - p0_z)
                if (z5 is None):
                    z5 = 0.
                if (y4 is None):
                    y4 = 0.
                if (x4 is None):
                    x4 = 0.
                d2_x = x4
                d2_y = y4
                d2_z = z5
                x5 = ((d1_y * d2_z) - ((d1_z * d2_y)))
                y5 = ((d1_z * d2_x) - ((d1_x * d2_z)))
                z6 = ((d1_x * d2_y) - ((d1_y * d2_x)))
                if (z6 is None):
                    z6 = 0.
                if (y5 is None):
                    y5 = 0.
                if (x5 is None):
                    x5 = 0.
                n_x = x5
                n_y = y5
                n_z = z6
                t.d = (((n_x * p0_x) + ((n_y * p0_y))) + ((n_z * p0_z)))
                t.nx = n_x
                t.ny = n_y
                t.nz = n_z
                t.d1x = d1_x
                t.d1y = d1_y
                t.d1z = d1_z
                t.d2x = d2_x
                t.d2y = d2_y
                t.d2z = d2_z
                t.dot00 = (((d1_x * d1_x) + ((d1_y * d1_y))) + ((d1_z * d1_z)))
                t.dot01 = (((d1_x * d2_x) + ((d1_y * d2_y))) + ((d1_z * d2_z)))
                t.dot11 = (((d2_x * d2_x) + ((d2_y * d2_y))) + ((d2_z * d2_z)))
                t.invDenom = (1 / (((t.dot00 * t.dot11) - ((t.dot01 * t.dot01)))))
                t.next = pout.triPlanes
                pout.triPlanes = t
        return pout

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.triPlanes = None
h3d_col_Polygon._hx_class = h3d_col_Polygon
_hx_classes["h3d.col.Polygon"] = h3d_col_Polygon


class h3d_col_PolygonBuffer:
    _hx_class_name = "h3d.col.PolygonBuffer"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "indexes", "startIndex", "triCount", "source")
    _hx_fields = ["buffer", "indexes", "startIndex", "triCount", "source"]
    _hx_methods = ["setData", "contains", "inFrustum", "inSphere", "rayIntersection"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self):
        self.source = None
        self.triCount = None
        self.startIndex = None
        self.indexes = None
        self.buffer = None

    def setData(self,buffer,indexes,startIndex = None,triCount = None):
        if (startIndex is None):
            startIndex = 0
        if (triCount is None):
            triCount = -1
        self.buffer = buffer
        self.indexes = indexes
        self.startIndex = startIndex
        tmp = None
        if (triCount >= 0):
            tmp = triCount
        else:
            x = (((len(indexes) - startIndex)) / 3)
            try:
                tmp = int(x)
            except BaseException as _g:
                None
                tmp = None
        self.triCount = tmp

    def contains(self,p):
        i = self.startIndex
        x = p.x
        y = p.y
        z = p.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        _g = 0
        _g1 = self.triCount
        while (_g < _g1):
            t = _g
            _g = (_g + 1)
            index = i
            i = (i + 1)
            i0 = (self.indexes[index] * 3)
            index1 = i0
            i0 = (i0 + 1)
            x = python_Syntax._arrayAccess(self.buffer,[index1])
            index2 = i0
            i0 = (i0 + 1)
            y = python_Syntax._arrayAccess(self.buffer,[index2])
            z = python_Syntax._arrayAccess(self.buffer,[i0])
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p0_x = x
            p0_y = y
            p0_z = z
            index3 = i
            i = (i + 1)
            i1 = (self.indexes[index3] * 3)
            index4 = i1
            i1 = (i1 + 1)
            x1 = python_Syntax._arrayAccess(self.buffer,[index4])
            index5 = i1
            i1 = (i1 + 1)
            y1 = python_Syntax._arrayAccess(self.buffer,[index5])
            z1 = python_Syntax._arrayAccess(self.buffer,[i1])
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            p1_x = x1
            p1_y = y1
            p1_z = z1
            index6 = i
            i = (i + 1)
            i2 = (self.indexes[index6] * 3)
            index7 = i2
            i2 = (i2 + 1)
            x2 = python_Syntax._arrayAccess(self.buffer,[index7])
            index8 = i2
            i2 = (i2 + 1)
            y2 = python_Syntax._arrayAccess(self.buffer,[index8])
            z2 = python_Syntax._arrayAccess(self.buffer,[i2])
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            p2_x = x2
            p2_y = y2
            p2_z = z2
            x3 = (p1_x - p0_x)
            y3 = (p1_y - p0_y)
            z3 = (p1_z - p0_z)
            if (z3 is None):
                z3 = 0.
            if (y3 is None):
                y3 = 0.
            if (x3 is None):
                x3 = 0.
            d1_x = x3
            d1_y = y3
            d1_z = z3
            x4 = (p2_x - p0_x)
            y4 = (p2_y - p0_y)
            z4 = (p2_z - p0_z)
            if (z4 is None):
                z4 = 0.
            if (y4 is None):
                y4 = 0.
            if (x4 is None):
                x4 = 0.
            d2_x = x4
            d2_y = y4
            d2_z = z4
            x5 = ((d1_y * d2_z) - ((d1_z * d2_y)))
            y5 = ((d1_z * d2_x) - ((d1_x * d2_z)))
            z5 = ((d1_x * d2_y) - ((d1_y * d2_x)))
            if (z5 is None):
                z5 = 0.
            if (y5 is None):
                y5 = 0.
            if (x5 is None):
                x5 = 0.
            n_x = x5
            n_y = y5
            n_z = z5
            d = (((n_x * p0_x) + ((n_y * p0_y))) + ((n_z * p0_z)))
            if ((((n_x * p_x) + ((n_y * p_y))) + ((n_z * p_z))) >= d):
                return False
        return True

    def inFrustum(self,f,m = None):
        raise haxe_Exception.thrown("Not implemented")

    def inSphere(self,s):
        raise haxe_Exception.thrown("Not implemented")

    def rayIntersection(self,r,bestMatch):
        i = self.startIndex
        x = r.lx
        y = r.ly
        z = r.lz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        rdir_x = x
        rdir_y = y
        rdir_z = z
        x = r.px
        y = r.py
        z = r.pz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        r0_x = x
        r0_y = y
        r0_z = z
        best = -1.
        _g = 0
        _g1 = self.triCount
        while (_g < _g1):
            t = _g
            _g = (_g + 1)
            index = i
            i = (i + 1)
            i0 = (self.indexes[index] * 3)
            index1 = i0
            i0 = (i0 + 1)
            x = python_Syntax._arrayAccess(self.buffer,[index1])
            index2 = i0
            i0 = (i0 + 1)
            y = python_Syntax._arrayAccess(self.buffer,[index2])
            z = python_Syntax._arrayAccess(self.buffer,[i0])
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p0_x = x
            p0_y = y
            p0_z = z
            index3 = i
            i = (i + 1)
            i1 = (self.indexes[index3] * 3)
            index4 = i1
            i1 = (i1 + 1)
            x1 = python_Syntax._arrayAccess(self.buffer,[index4])
            index5 = i1
            i1 = (i1 + 1)
            y1 = python_Syntax._arrayAccess(self.buffer,[index5])
            z1 = python_Syntax._arrayAccess(self.buffer,[i1])
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            p1_x = x1
            p1_y = y1
            p1_z = z1
            index6 = i
            i = (i + 1)
            i2 = (self.indexes[index6] * 3)
            index7 = i2
            i2 = (i2 + 1)
            x2 = python_Syntax._arrayAccess(self.buffer,[index7])
            index8 = i2
            i2 = (i2 + 1)
            y2 = python_Syntax._arrayAccess(self.buffer,[index8])
            z2 = python_Syntax._arrayAccess(self.buffer,[i2])
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            p2_x = x2
            p2_y = y2
            p2_z = z2
            x3 = (p1_x - p0_x)
            y3 = (p1_y - p0_y)
            z3 = (p1_z - p0_z)
            if (z3 is None):
                z3 = 0.
            if (y3 is None):
                y3 = 0.
            if (x3 is None):
                x3 = 0.
            e1_x = x3
            e1_y = y3
            e1_z = z3
            x4 = (p2_x - p0_x)
            y4 = (p2_y - p0_y)
            z4 = (p2_z - p0_z)
            if (z4 is None):
                z4 = 0.
            if (y4 is None):
                y4 = 0.
            if (x4 is None):
                x4 = 0.
            e2_x = x4
            e2_y = y4
            e2_z = z4
            x5 = ((rdir_y * e2_z) - ((rdir_z * e2_y)))
            y5 = ((rdir_z * e2_x) - ((rdir_x * e2_z)))
            z5 = ((rdir_x * e2_y) - ((rdir_y * e2_x)))
            if (z5 is None):
                z5 = 0.
            if (y5 is None):
                y5 = 0.
            if (x5 is None):
                x5 = 0.
            p_x = x5
            p_y = y5
            p_z = z5
            det = (((e1_x * p_x) + ((e1_y * p_y))) + ((e1_z * p_z)))
            if (det < 1e-10):
                continue
            invDet = (1 / det)
            x6 = (r0_x - p0_x)
            y6 = (r0_y - p0_y)
            z6 = (r0_z - p0_z)
            if (z6 is None):
                z6 = 0.
            if (y6 is None):
                y6 = 0.
            if (x6 is None):
                x6 = 0.
            T_x = x6
            T_y = y6
            T_z = z6
            u = (((((T_x * p_x) + ((T_y * p_y))) + ((T_z * p_z)))) * invDet)
            if ((u < 0) or ((u > 1))):
                continue
            x7 = ((T_y * e1_z) - ((T_z * e1_y)))
            y7 = ((T_z * e1_x) - ((T_x * e1_z)))
            z7 = ((T_x * e1_y) - ((T_y * e1_x)))
            if (z7 is None):
                z7 = 0.
            if (y7 is None):
                y7 = 0.
            if (x7 is None):
                x7 = 0.
            q_x = x7
            q_y = y7
            q_z = z7
            v = (((((rdir_x * q_x) + ((rdir_y * q_y))) + ((rdir_z * q_z)))) * invDet)
            if ((v < 0) or (((u + v) > 1))):
                continue
            t1 = (((((e2_x * q_x) + ((e2_y * q_y))) + ((e2_z * q_z)))) * invDet)
            if (t1 < 1e-10):
                continue
            if (not bestMatch):
                return t1
            if ((best < 0) or ((t1 < best))):
                best = t1
        return best

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.indexes = None
        _hx_o.startIndex = None
        _hx_o.triCount = None
        _hx_o.source = None
h3d_col_PolygonBuffer._hx_class = h3d_col_PolygonBuffer
_hx_classes["h3d.col.PolygonBuffer"] = h3d_col_PolygonBuffer


class h3d_col_SkinCollider:
    _hx_class_name = "h3d.col.SkinCollider"
    _hx_is_interface = "False"
    __slots__ = ("obj", "col", "currentBounds", "transform", "lastFrame", "lastBoundsFrame")
    _hx_fields = ["obj", "col", "currentBounds", "transform", "lastFrame", "lastBoundsFrame"]
    _hx_methods = ["contains", "inFrustum", "inSphere", "rayIntersection", "checkBounds", "applyTransform"]
    _hx_interfaces = [h3d_col_Collider, hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,obj,col):
        self.currentBounds = None
        self.lastBoundsFrame = -1
        self.lastFrame = -1
        self.obj = obj
        self.col = col
        self.transform = h3d_col_PolygonBuffer()
        tmp = self.transform
        this1 = col.buffer
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        tmp.setData(r,col.indexes,col.startIndex,col.triCount)
        self.currentBounds = h3d_col_Bounds()

    def contains(self,p):
        self.checkBounds()
        _this = self.currentBounds
        if (not (((((((p.x >= _this.xMin) and ((p.x < _this.xMax))) and ((p.y >= _this.yMin))) and ((p.y < _this.yMax))) and ((p.z >= _this.zMin))) and ((p.z < _this.zMax))))):
            return False
        self.applyTransform()
        return self.transform.contains(p)

    def inFrustum(self,p,m = None):
        self.checkBounds()
        _this = self.currentBounds
        if (m is not None):
            raise haxe_Exception.thrown("Not implemented")
        if (not p.hasBounds(_this)):
            return False
        if (m is not None):
            raise haxe_Exception.thrown("Not implemented")
        self.applyTransform()
        return self.transform.inFrustum(p)

    def inSphere(self,s):
        self.checkBounds()
        _this = self.currentBounds
        x = s.x
        y = s.y
        z = s.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        c_x = x
        c_y = y
        c_z = z
        a = _this.xMin
        a1 = s.x
        b = _this.xMax
        b1 = (b if ((a1 > b)) else a1)
        x = (b1 if ((a < b1)) else a)
        a = _this.yMin
        a1 = s.y
        b = _this.yMax
        b1 = (b if ((a1 > b)) else a1)
        y = (b1 if ((a < b1)) else a)
        a = _this.zMin
        a1 = s.z
        b = _this.zMax
        b1 = (b if ((a1 > b)) else a1)
        z = (b1 if ((a < b1)) else a)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        dx = (p_x - c_x)
        dy = (p_y - c_y)
        dz = (p_z - c_z)
        if (not (((((dx * dx) + ((dy * dy))) + ((dz * dz))) < ((s.r * s.r))))):
            return False
        self.applyTransform()
        raise haxe_Exception.thrown("Not implemented")

    def rayIntersection(self,r,bestMatch):
        self.checkBounds()
        if (self.currentBounds.rayIntersection(r,False) < 0):
            return -1.
        self.applyTransform()
        return self.transform.rayIntersection(r,bestMatch)

    def checkBounds(self):
        if ((not self.obj.jointsUpdated) and ((self.lastBoundsFrame == self.obj.lastFrame))):
            return
        self.lastBoundsFrame = self.obj.lastFrame
        self.obj.syncJoints()
        _this = self.currentBounds
        _this.xMin = 1e20
        _this.xMax = -1e20
        _this.yMin = 1e20
        _this.yMax = -1e20
        _this.zMin = 1e20
        _this.zMax = -1e20
        self.obj.getBoundsRec(self.currentBounds)

    def applyTransform(self):
        if ((not self.obj.jointsUpdated) and ((self.lastFrame == self.obj.lastFrame))):
            return
        self.lastFrame = self.obj.lastFrame
        self.obj.syncJoints()
        j = 0
        v = 0
        nbones = self.obj.skinData.bonesPerVertex
        _g = 0
        _g1 = self.obj.skinData.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            px = 0.
            py = 0.
            pz = 0.
            x = python_Syntax._arrayAccess(self.col.buffer,[v])
            y = python_Syntax._arrayAccess(self.col.buffer,[(v + 1)])
            z = python_Syntax._arrayAccess(self.col.buffer,[(v + 2)])
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p_x = x
            p_y = y
            p_z = z
            _g2 = 0
            _g3 = nbones
            while (_g2 < _g3):
                k = _g2
                _g2 = (_g2 + 1)
                w = self.obj.skinData.vertexWeights[j]
                if (w == 0):
                    j = (j + 1)
                    continue
                index = j
                j = (j + 1)
                bid = self.obj.skinData.vertexJoints[index]
                x1 = p_x
                y1 = p_y
                z1 = p_z
                if (z1 is None):
                    z1 = 0.
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                p2_x = x1
                p2_y = y1
                p2_z = z1
                m = python_internal_ArrayImpl._get(self.obj.currentPalette, bid)
                px1 = ((((p2_x * m._11) + ((p2_y * m._21))) + ((p2_z * m._31))) + m._41)
                py1 = ((((p2_x * m._12) + ((p2_y * m._22))) + ((p2_z * m._32))) + m._42)
                pz1 = ((((p2_x * m._13) + ((p2_y * m._23))) + ((p2_z * m._33))) + m._43)
                p2_x = px1
                p2_y = py1
                p2_z = pz1
                px = (px + ((p2_x * w)))
                py = (py + ((p2_y * w)))
                pz = (pz + ((p2_z * w)))
            index1 = v
            v = (v + 1)
            self.transform.buffer[index1] = px
            index2 = v
            v = (v + 1)
            self.transform.buffer[index2] = py
            index3 = v
            v = (v + 1)
            self.transform.buffer[index3] = pz

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.col = None
        _hx_o.currentBounds = None
        _hx_o.transform = None
        _hx_o.lastFrame = None
        _hx_o.lastBoundsFrame = None
h3d_col_SkinCollider._hx_class = h3d_col_SkinCollider
_hx_classes["h3d.col.SkinCollider"] = h3d_col_SkinCollider


class h3d_col_Sphere:
    _hx_class_name = "h3d.col.Sphere"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "r")
    _hx_fields = ["x", "y", "z", "r"]
    _hx_methods = ["load", "getCenter", "distance", "distanceSq", "contains", "rayIntersection", "inFrustum", "inFrustumMatrix", "inSphere", "toString"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self,x = None,y = None,z = None,r = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (r is None):
            r = 0.
        sx = x
        sy = y
        sz = z
        sr = r
        if (sr is None):
            sr = 0.
        if (sz is None):
            sz = 0.
        if (sy is None):
            sy = 0.
        if (sx is None):
            sx = 0.
        self.x = sx
        self.y = sy
        self.z = sz
        self.r = sr

    def load(self,sx = None,sy = None,sz = None,sr = None):
        if (sx is None):
            sx = 0.
        if (sy is None):
            sy = 0.
        if (sz is None):
            sz = 0.
        if (sr is None):
            sr = 0.
        self.x = sx
        self.y = sy
        self.z = sz
        self.r = sr

    def getCenter(self):
        return h3d_col_Point(self.x,self.y,self.z)

    def distance(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        dz = (p.z - self.z)
        d = ((((dx * dx) + ((dy * dy))) + ((dz * dz))) - ((self.r * self.r)))
        if (d < 0):
            v = -d
            return -((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v)))
        elif (d < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(d)

    def distanceSq(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        dz = (p.z - self.z)
        return ((((dx * dx) + ((dy * dy))) + ((dz * dz))) - ((self.r * self.r)))

    def contains(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        dz = (p.z - self.z)
        return (((((dx * dx) + ((dy * dy))) + ((dz * dz))) - ((self.r * self.r))) < 0)

    def rayIntersection(self,r,bestMatch):
        r2 = (self.r * self.r)
        px = (r.px + r.lx)
        py = (r.py + r.ly)
        pz = (r.pz + r.lz)
        a = (((r.lx * r.lx) + ((r.ly * r.ly))) + ((r.lz * r.lz)))
        b = ((((2 * r.lx) * ((self.x - px))) + (((2 * r.ly) * ((self.y - py))))) + (((2 * r.lz) * ((self.z - pz)))))
        c = ((((((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z))) + ((((px * px) + ((py * py))) + ((pz * pz))))) - ((2 * ((((self.x * px) + ((self.y * py))) + ((self.z * pz))))))) - r2)
        d = ((b * b) - (((4 * a) * c)))
        if (d < 0):
            return -1
        d = (Math.NaN if ((d < 0)) else python_lib_Math.sqrt(d))
        t = (((-b + d)) / ((2 * a)))
        return (1 - t)

    def inFrustum(self,f,m = None):
        if (m is not None):
            return self.inFrustumMatrix(f,m)
        return f.hasSphere(self)

    def inFrustumMatrix(self,f,m):
        oldX = self.x
        oldY = self.y
        oldZ = self.z
        oldR = self.r
        x = self.x
        y = self.y
        z = self.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        self.x = v_x
        self.y = v_y
        self.z = v_z
        v = None
        if (v is None):
            v = h3d_Vector()
        f1 = (((m._11 * m._11) + ((m._12 * m._12))) + ((m._13 * m._13)))
        v.x = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        f1 = (((m._21 * m._21) + ((m._22 * m._22))) + ((m._23 * m._23)))
        v.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        f1 = (((m._31 * m._31) + ((m._32 * m._32))) + ((m._33 * m._33)))
        v.z = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        if ((((m._11 * (((m._22 * m._33) - ((m._23 * m._32))))) + ((m._12 * (((m._23 * m._31) - ((m._21 * m._33))))))) + ((m._13 * (((m._21 * m._32) - ((m._22 * m._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        scale = v
        tmp = self
        tmp1 = tmp.r
        a = scale.x
        b = scale.y
        a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        b = scale.z
        tmp.r = (tmp1 * ((a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else max(a1,b)))))
        res = f.hasSphere(self)
        self.x = oldX
        self.y = oldY
        self.z = oldZ
        self.r = oldR
        return res

    def inSphere(self,s):
        x = self.x
        y = self.y
        z = self.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this_x = x
        _this_y = y
        _this_z = z
        x = s.x
        y = s.y
        z = s.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        dx = (p_x - _this_x)
        dy = (p_y - _this_y)
        dz = (p_z - _this_z)
        return ((((dx * dx) + ((dy * dy))) + ((dz * dz))) < ((((s.r + self.r)) * ((s.r + self.r)))))

    def toString(self):
        return (((("Sphere{" + Std.string(h3d_col_Point(self.x,self.y,self.z))) + ",") + Std.string(hxd_Math.fmt(self.r))) + "}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.r = None
h3d_col_Sphere._hx_class = h3d_col_Sphere
_hx_classes["h3d.col.Sphere"] = h3d_col_Sphere

class h3d_impl_Feature(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.impl.Feature"
    _hx_constructs = ["StandardDerivatives", "FloatTextures", "AllocDepthBuffer", "HardwareAccelerated", "MultipleRenderTargets", "Queries", "SRGBTextures", "ShaderModel3", "BottomLeftCoords", "Wireframe", "InstancedRendering"]
h3d_impl_Feature.StandardDerivatives = h3d_impl_Feature("StandardDerivatives", 0, ())
h3d_impl_Feature.FloatTextures = h3d_impl_Feature("FloatTextures", 1, ())
h3d_impl_Feature.AllocDepthBuffer = h3d_impl_Feature("AllocDepthBuffer", 2, ())
h3d_impl_Feature.HardwareAccelerated = h3d_impl_Feature("HardwareAccelerated", 3, ())
h3d_impl_Feature.MultipleRenderTargets = h3d_impl_Feature("MultipleRenderTargets", 4, ())
h3d_impl_Feature.Queries = h3d_impl_Feature("Queries", 5, ())
h3d_impl_Feature.SRGBTextures = h3d_impl_Feature("SRGBTextures", 6, ())
h3d_impl_Feature.ShaderModel3 = h3d_impl_Feature("ShaderModel3", 7, ())
h3d_impl_Feature.BottomLeftCoords = h3d_impl_Feature("BottomLeftCoords", 8, ())
h3d_impl_Feature.Wireframe = h3d_impl_Feature("Wireframe", 9, ())
h3d_impl_Feature.InstancedRendering = h3d_impl_Feature("InstancedRendering", 10, ())
h3d_impl_Feature._hx_class = h3d_impl_Feature
_hx_classes["h3d.impl.Feature"] = h3d_impl_Feature

class h3d_impl_QueryKind(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.impl.QueryKind"
    _hx_constructs = ["TimeStamp", "Samples"]
h3d_impl_QueryKind.TimeStamp = h3d_impl_QueryKind("TimeStamp", 0, ())
h3d_impl_QueryKind.Samples = h3d_impl_QueryKind("Samples", 1, ())
h3d_impl_QueryKind._hx_class = h3d_impl_QueryKind
_hx_classes["h3d.impl.QueryKind"] = h3d_impl_QueryKind

class h3d_impl_RenderFlag(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.impl.RenderFlag"
    _hx_constructs = ["CameraHandness"]
h3d_impl_RenderFlag.CameraHandness = h3d_impl_RenderFlag("CameraHandness", 0, ())
h3d_impl_RenderFlag._hx_class = h3d_impl_RenderFlag
_hx_classes["h3d.impl.RenderFlag"] = h3d_impl_RenderFlag


class h3d_impl_InputNames:
    _hx_class_name = "h3d.impl.InputNames"
    _hx_is_interface = "False"
    __slots__ = ("id", "names")
    _hx_fields = ["id", "names"]
    _hx_statics = ["UID", "CACHE", "get"]

    def __init__(self,names):
        def _hx_local_2():
            _hx_local_0 = h3d_impl_InputNames
            _hx_local_1 = _hx_local_0.UID
            _hx_local_0.UID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()
        self.names = names

    @staticmethod
    def get(names):
        key = "|".join([python_Boot.toString1(x1,'') for x1 in names])
        i = h3d_impl_InputNames.CACHE.h.get(key,None)
        if (i is None):
            i = h3d_impl_InputNames(list(names))
            h3d_impl_InputNames.CACHE.h[key] = i
        return i

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.names = None
h3d_impl_InputNames._hx_class = h3d_impl_InputNames
_hx_classes["h3d.impl.InputNames"] = h3d_impl_InputNames


class h3d_impl_Driver:
    _hx_class_name = "h3d.impl.Driver"
    _hx_is_interface = "False"
    __slots__ = ("logEnable",)
    _hx_fields = ["logEnable"]
    _hx_methods = ["hasFeature", "setRenderFlag", "isSupportedFormat", "isDisposed", "dispose", "begin", "log", "generateMipMaps", "getNativeShaderCode", "logImpl", "clear", "captureRenderBuffer", "capturePixels", "getDriverName", "init", "resize", "selectShader", "selectMaterial", "uploadShaderBuffers", "getShaderInputNames", "selectBuffer", "selectMultiBuffers", "draw", "drawInstanced", "setRenderZone", "setRenderTarget", "setRenderTargets", "allocDepthBuffer", "disposeDepthBuffer", "getDefaultDepthBuffer", "present", "end", "setDebug", "allocTexture", "allocIndexes", "allocVertexes", "allocInstanceBuffer", "disposeTexture", "disposeIndexes", "disposeVertexes", "disposeInstanceBuffer", "uploadIndexBuffer", "uploadIndexBytes", "uploadVertexBuffer", "uploadVertexBytes", "uploadTextureBitmap", "uploadTexturePixels", "readVertexBytes", "readIndexBytes", "copyTexture", "allocQuery", "deleteQuery", "beginQuery", "endQuery", "queryResultAvailable", "queryResult"]

    def hasFeature(self,f):
        return False

    def setRenderFlag(self,r,value):
        pass

    def isSupportedFormat(self,fmt):
        return False

    def isDisposed(self):
        return True

    def dispose(self):
        pass

    def begin(self,frame):
        pass

    def log(self,_hx_str):
        pass

    def generateMipMaps(self,texture):
        raise haxe_Exception.thrown("Mipmaps auto generation is not supported on this platform")

    def getNativeShaderCode(self,shader):
        return None

    def logImpl(self,_hx_str):
        pass

    def clear(self,color = None,depth = None,stencil = None):
        pass

    def captureRenderBuffer(self,pixels):
        pass

    def capturePixels(self,tex,layer,mipLevel,region = None):
        raise haxe_Exception.thrown("Can't capture pixels on this platform")

    def getDriverName(self,details):
        return "Not available"

    def init(self,onCreate,forceSoftware = None):
        if (forceSoftware is None):
            forceSoftware = False

    def resize(self,width,height):
        pass

    def selectShader(self,shader):
        return False

    def selectMaterial(self,_hx_pass):
        pass

    def uploadShaderBuffers(self,buffers,which):
        pass

    def getShaderInputNames(self):
        return None

    def selectBuffer(self,buffer):
        pass

    def selectMultiBuffers(self,buffers):
        pass

    def draw(self,ibuf,startIndex,ntriangles):
        pass

    def drawInstanced(self,ibuf,commands):
        pass

    def setRenderZone(self,x,y,width,height):
        pass

    def setRenderTarget(self,tex,layer = None,mipLevel = None):
        if (layer is None):
            layer = 0
        if (mipLevel is None):
            mipLevel = 0

    def setRenderTargets(self,textures):
        pass

    def allocDepthBuffer(self,b):
        return None

    def disposeDepthBuffer(self,b):
        pass

    def getDefaultDepthBuffer(self):
        return None

    def present(self):
        pass

    def end(self):
        pass

    def setDebug(self,b):
        pass

    def allocTexture(self,t):
        return None

    def allocIndexes(self,count,is32):
        return None

    def allocVertexes(self,m):
        return None

    def allocInstanceBuffer(self,b,_hx_bytes):
        pass

    def disposeTexture(self,t):
        pass

    def disposeIndexes(self,i):
        pass

    def disposeVertexes(self,v):
        pass

    def disposeInstanceBuffer(self,b):
        pass

    def uploadIndexBuffer(self,i,startIndice,indiceCount,buf,bufPos):
        pass

    def uploadIndexBytes(self,i,startIndice,indiceCount,buf,bufPos):
        pass

    def uploadVertexBuffer(self,v,startVertex,vertexCount,buf,bufPos):
        pass

    def uploadVertexBytes(self,v,startVertex,vertexCount,buf,bufPos):
        pass

    def uploadTextureBitmap(self,t,bmp,mipLevel,side):
        pass

    def uploadTexturePixels(self,t,pixels,mipLevel,side):
        pass

    def readVertexBytes(self,v,startVertex,vertexCount,buf,bufPos):
        raise haxe_Exception.thrown("Driver does not allow to read vertex bytes")

    def readIndexBytes(self,v,startVertex,vertexCount,buf,bufPos):
        raise haxe_Exception.thrown("Driver does not allow to read index bytes")

    def copyTexture(self,_hx_from,to):
        return False

    def allocQuery(self,queryKind):
        return None

    def deleteQuery(self,q):
        pass

    def beginQuery(self,q):
        pass

    def endQuery(self,q):
        pass

    def queryResultAvailable(self,q):
        return True

    def queryResult(self,q):
        return 0.

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.logEnable = None
h3d_impl_Driver._hx_class = h3d_impl_Driver
_hx_classes["h3d.impl.Driver"] = h3d_impl_Driver


class h3d_impl_InstanceBuffer:
    _hx_class_name = "h3d.impl.InstanceBuffer"
    _hx_is_interface = "False"
    __slots__ = ("data", "driver", "indexCount", "triCount", "commandCount")
    _hx_fields = ["data", "driver", "indexCount", "triCount", "commandCount"]
    _hx_methods = ["setCommand", "setBuffer", "dispose"]

    def __init__(self):
        self.commandCount = None
        self.driver = None
        self.data = None
        self.triCount = 0
        self.indexCount = 0

    def setCommand(self,commandCount,indexCount):
        self.commandCount = commandCount
        self.indexCount = indexCount
        tmp = None
        try:
            tmp = int(((commandCount * indexCount) / 3))
        except BaseException as _g:
            None
            tmp = None
        self.triCount = tmp

    def setBuffer(self,commandCount,_hx_bytes):
        self.dispose()
        _g = 0
        _g1 = commandCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i * 20)
            v = (((_hx_bytes.b[pos] | ((_hx_bytes.b[(pos + 1)] << 8))) | ((_hx_bytes.b[(pos + 2)] << 16))) | ((_hx_bytes.b[(pos + 3)] << 24)))
            idxCount = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            pos1 = ((i * 20) + 4)
            v1 = (((_hx_bytes.b[pos1] | ((_hx_bytes.b[(pos1 + 1)] << 8))) | ((_hx_bytes.b[(pos1 + 2)] << 16))) | ((_hx_bytes.b[(pos1 + 3)] << 24)))
            instCount = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
            tri = None
            try:
                tri = int(((idxCount * instCount) / 3))
            except BaseException as _g2:
                None
                tri = None
            tri1 = tri
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.triCount
            _hx_local_0.triCount = (_hx_local_1 + tri1)
            _hx_local_0.triCount
        self.commandCount = commandCount
        self.indexCount = 0
        self.driver = h3d_Engine.CURRENT.driver
        self.driver.allocInstanceBuffer(self,_hx_bytes)

    def dispose(self):
        if (self.data is not None):
            self.driver.disposeInstanceBuffer(self)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
        _hx_o.driver = None
        _hx_o.indexCount = None
        _hx_o.triCount = None
        _hx_o.commandCount = None
h3d_impl_InstanceBuffer._hx_class = h3d_impl_InstanceBuffer
_hx_classes["h3d.impl.InstanceBuffer"] = h3d_impl_InstanceBuffer


class h3d_impl_LogDriver(h3d_impl_Driver):
    _hx_class_name = "h3d.impl.LogDriver"
    _hx_is_interface = "False"
    __slots__ = ("d", "loggedShaders", "currentShader", "logLines")
    _hx_fields = ["d", "loggedShaders", "currentShader", "logLines"]
    _hx_methods = ["logImpl", "hasFeature", "isSupportedFormat", "isDisposed", "dispose", "begin", "clear", "captureRenderBuffer", "getDriverName", "init", "resize", "selectShader", "getNativeShaderCode", "selectMaterial", "sizeOf", "uploadShaderBuffers", "textureInfos", "getShaderInputNames", "selectBuffer", "selectMultiBuffers", "draw", "setRenderZone", "setRenderTarget", "setRenderTargets", "end", "present", "setDebug", "allocTexture", "allocIndexes", "allocVertexes", "disposeTexture", "disposeIndexes", "disposeVertexes", "uploadIndexBuffer", "uploadIndexBytes", "uploadVertexBuffer", "uploadVertexBytes", "uploadTextureBitmap", "uploadTexturePixels"]
    _hx_statics = ["debug"]
    _hx_interfaces = []
    _hx_super = h3d_impl_Driver


    def __init__(self,driver):
        self.currentShader = None
        self.logLines = None
        self.loggedShaders = haxe_ds_IntMap()
        self.d = driver
        self.logEnable = True
        driver.logEnable = True

    def logImpl(self,_hx_str):
        if (self.logLines is None):
            self.d.logImpl(_hx_str)
        else:
            _this = self.logLines
            _this.append(_hx_str)

    def hasFeature(self,f):
        return self.d.hasFeature(f)

    def isSupportedFormat(self,fmt):
        return self.d.isSupportedFormat(fmt)

    def isDisposed(self):
        return self.d.isDisposed()

    def dispose(self):
        self.d.dispose()

    def begin(self,frame):
        self.d.begin(frame)

    def clear(self,color = None,depth = None,stencil = None):
        _hx_str = ((((("Clear color=" + Std.string(color)) + " depth=") + Std.string(depth)) + " stencil=") + Std.string(stencil))
        self.d.clear(color,depth,stencil)

    def captureRenderBuffer(self,pixels):
        self.d.captureRenderBuffer(pixels)

    def getDriverName(self,details):
        return self.d.getDriverName(details)

    def init(self,onCreate,forceSoftware = None):
        if (forceSoftware is None):
            forceSoftware = False
        _gthis = self
        def _hx_local_0(b):
            _hx_str = ("OnCreate " + Std.string(b))
            onCreate(b)
        self.d.init(_hx_local_0,forceSoftware)

    def resize(self,width,height):
        self.d.resize(width,height)

    def selectShader(self,shader):
        self.currentShader = shader
        ret = self.d.selectShader(shader)
        if (not self.loggedShaders.h.get(shader.id,None)):
            def _hx_local_8(shader):
                _hx_str = hxsl_Printer.shaderToString(shader.data)
                def _hx_local_2(r):
                    name = None
                    cid = (Std.parseInt(r.matchObj.group(4)) << 2)
                    swiz = r.matchObj.group(5)
                    if (swiz is not None):
                        d = (HxString.charCodeAt(swiz,1) - 120)
                        cid = (cid + d)
                        _g = []
                        _g1 = 1
                        _g2 = len(swiz)
                        while (_g1 < _g2):
                            i = _g1
                            _g1 = (_g1 + 1)
                            code = (HxString.charCodeAt(swiz,i) - d)
                            x = "".join(map(chr,[code]))
                            _g.append(x)
                        swiz = ("." + HxOverrides.stringOrNull("".join([python_Boot.toString1(x1,'') for x1 in _g])))
                    g = shader.globals
                    while (g is not None):
                        _hx_str = None
                        if ((g.path == "__consts__") and ((cid >= g.pos))):
                            _g = g.type
                            str1 = None
                            if (_g.index == 15):
                                _g1 = _g.params[1]
                                if (_g.params[0].index == 3):
                                    if (_g1.index == 0):
                                        n = _g1.params[0]
                                        str1 = n
                                    else:
                                        str1 = 0
                                else:
                                    str1 = 0
                            else:
                                str1 = 0
                            _hx_str = (cid < ((g.pos + str1)))
                        else:
                            _hx_str = False
                        if (_hx_str and ((swiz == ".x"))):
                            swiz = None
                            name = ("" + Std.string(python_internal_ArrayImpl._get(shader.consts, (cid - g.pos))))
                            break
                        if (g.pos == cid):
                            name = g.path
                            break
                        g = g.next
                    if (name is None):
                        return r.matchObj.group(0)
                    if (swiz is not None):
                        name = (("null" if name is None else name) + ("null" if swiz is None else swiz))
                    return name
                _hx_str = EReg("((fragment)|(vertex))Globals\\[([0-9]+)\\](.[xyz]+)?","g").map(_hx_str,_hx_local_2)
                def _hx_local_5(r):
                    name = None
                    cid = (Std.parseInt(r.matchObj.group(4)) << 2)
                    swiz = r.matchObj.group(5)
                    if (swiz is not None):
                        d = (HxString.charCodeAt(swiz,1) - 120)
                        cid = (cid + d)
                        _g = []
                        _g1 = 1
                        _g2 = len(swiz)
                        while (_g1 < _g2):
                            i = _g1
                            _g1 = (_g1 + 1)
                            code = (HxString.charCodeAt(swiz,i) - d)
                            x = "".join(map(chr,[code]))
                            _g.append(x)
                        swiz = ("." + HxOverrides.stringOrNull("".join([python_Boot.toString1(x1,'') for x1 in _g])))
                    p = shader.params
                    while (p is not None):
                        if (p.pos == cid):
                            name = p.name
                            break
                        p = p.next
                    if (name is None):
                        return r.matchObj.group(0)
                    if (swiz is not None):
                        name = (("null" if name is None else name) + ("null" if swiz is None else swiz))
                    return name
                _hx_str = EReg("((fragment)|(vertex))Params\\[([0-9]+)\\](.[xyz]+)?","g").map(_hx_str,_hx_local_5)
                def _hx_local_6(r):
                    name = None
                    cid = Std.parseInt(r.matchObj.group(4))
                    t = shader.textures
                    while (t is not None):
                        if ((t.pos == cid) and ((t.type == hxsl_Type.TSampler2D))):
                            return t.name
                        t = t.next
                    return r.matchObj.group(0)
                _hx_str = EReg("((fragment)|(vertex))Textures\\[([0-9]+)\\]","g").map(_hx_str,_hx_local_6)
                def _hx_local_7(r):
                    name = None
                    cid = Std.parseInt(r.matchObj.group(4))
                    t = shader.textures
                    while (t is not None):
                        if ((t.pos == cid) and ((t.type == hxsl_Type.TSamplerCube))):
                            return t.name
                        t = t.next
                    return r.matchObj.group(0)
                _hx_str = EReg("((fragment)|(vertex))TexturesCube\\[([0-9]+)\\]","g").map(_hx_str,_hx_local_7)
                return _hx_str
            fmt = _hx_local_8
            _hx_str = ((HxOverrides.stringOrNull(fmt(shader.vertex)) + "\n") + HxOverrides.stringOrNull(fmt(shader.fragment)))
            _this = _hx_str.split("\n")
            _hx_str = ("\t" + HxOverrides.stringOrNull("\n\t".join([python_Boot.toString1(x1,'') for x1 in _this])))
            _hx_str = self.getNativeShaderCode(shader)
            if (_hx_str is not None):
                _this = _hx_str.split("\n")
                _hx_str = ("\t" + HxOverrides.stringOrNull("\n\t".join([python_Boot.toString1(x1,'') for x1 in _this])))
            self.loggedShaders.set(shader.id,True)
        return ret

    def getNativeShaderCode(self,shader):
        return self.d.getNativeShaderCode(shader)

    def selectMaterial(self,_hx_pass):
        _hx_str = (((((((((("Select Material Cull=" + Std.string(_hx_pass.culling)) + " depth=") + Std.string(_hx_pass.depthTest)) + HxOverrides.stringOrNull((("" if (_hx_pass.depthWrite) else " nowrite")))) + " blend=") + Std.string(_hx_pass.blendSrc)) + ",") + Std.string(_hx_pass.blendDst)) + " color=") + Std.string(_hx_pass.colorMask))
        self.d.selectMaterial(_hx_pass)

    def sizeOf(self,t):
        tmp = t.index
        if (tmp == 0):
            return 0
        elif ((tmp == 3) or ((tmp == 1))):
            return 1
        elif (tmp == 5):
            _g = t.params[1]
            n = t.params[0]
            return n
        elif (tmp == 6):
            return 9
        elif (tmp == 7):
            return 16
        elif (tmp == 8):
            return 12
        elif (tmp == 15):
            _g = t.params[1]
            if (_g.index == 0):
                n = _g.params[0]
                t1 = t.params[0]
                return (self.sizeOf(t1) * n)
            else:
                raise haxe_Exception.thrown(("assert " + Std.string(t)))
        else:
            raise haxe_Exception.thrown(("assert " + Std.string(t)))

    def uploadShaderBuffers(self,buffers,which):
        _gthis = self
        which1 = which
        if (which1 == 0):
            s = self.currentShader.vertex
            buf = buffers.vertex
            if (s.globalsSize != 0):
                g = s.globals
                while (g is not None):
                    _hx_str = (((("\t@" + Std.string(g.pos)) + " ") + HxOverrides.stringOrNull(g.path)) + "=")
                    _g = []
                    _g1 = 0
                    _g2 = _gthis.sizeOf(g.type)
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        x = hxd_Math.fmt(buf.globals[(g.pos + i)])
                        _g.append(x)
                    str1 = (("null" if _hx_str is None else _hx_str) + Std.string(_g))
                    g = g.next
            s = self.currentShader.fragment
            buf = buffers.fragment
            if (s.globalsSize != 0):
                g = s.globals
                while (g is not None):
                    _hx_str = (((("\t@" + Std.string(g.pos)) + " ") + HxOverrides.stringOrNull(g.path)) + "=")
                    _g = []
                    _g1 = 0
                    _g2 = _gthis.sizeOf(g.type)
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        x = hxd_Math.fmt(buf.globals[(g.pos + i)])
                        _g.append(x)
                    str1 = (("null" if _hx_str is None else _hx_str) + Std.string(_g))
                    g = g.next
        elif (which1 == 1):
            s = self.currentShader.vertex
            buf = buffers.vertex
            if (s.paramsSize != 0):
                p = s.params
                while (p is not None):
                    pos = p.pos
                    _hx_str = (((("\t@" + Std.string(pos)) + " ") + HxOverrides.stringOrNull(p.name)) + "=")
                    _g = []
                    _g1 = 0
                    _g2 = _gthis.sizeOf(p.type)
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        x = hxd_Math.fmt(buf.params[(p.pos + i)])
                        _g.append(x)
                    str1 = (("null" if _hx_str is None else _hx_str) + Std.string(_g))
                    p = p.next
            s = self.currentShader.fragment
            buf = buffers.fragment
            if (s.paramsSize != 0):
                p = s.params
                while (p is not None):
                    pos = p.pos
                    _hx_str = (((("\t@" + Std.string(pos)) + " ") + HxOverrides.stringOrNull(p.name)) + "=")
                    _g = []
                    _g1 = 0
                    _g2 = _gthis.sizeOf(p.type)
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        x = hxd_Math.fmt(buf.params[(p.pos + i)])
                        _g.append(x)
                    str1 = (("null" if _hx_str is None else _hx_str) + Std.string(_g))
                    p = p.next
        elif (which1 == 2):
            s = self.currentShader.vertex
            buf = buffers.vertex
            t = s.textures
            while (t is not None):
                _hx_str = ((((((("Set " + HxOverrides.stringOrNull((("Vertex" if (s.vertex) else "Fragment")))) + " Texture@") + Std.string(t.pos)) + " ") + HxOverrides.stringOrNull(t.name)) + "=") + HxOverrides.stringOrNull(_gthis.textureInfos(buf.tex,t.pos)))
                t = t.next
            s = self.currentShader.fragment
            buf = buffers.fragment
            t = s.textures
            while (t is not None):
                _hx_str = ((((((("Set " + HxOverrides.stringOrNull((("Vertex" if (s.vertex) else "Fragment")))) + " Texture@") + Std.string(t.pos)) + " ") + HxOverrides.stringOrNull(t.name)) + "=") + HxOverrides.stringOrNull(_gthis.textureInfos(buf.tex,t.pos)))
                t = t.next
        elif (which1 == 3):
            pass
        else:
            pass
        self.d.uploadShaderBuffers(buffers,which)

    def textureInfos(self,buf,tid):
        if ((tid < 0) or ((tid >= len(buf)))):
            return "OUT OF BOUNDS"
        t = buf[tid]
        if (t is None):
            return "NULL"
        inf = ("" + Std.string(t))
        if (t.wrap != h3d_mat_Wrap.Clamp):
            inf = (("null" if inf is None else inf) + ((" wrap=" + Std.string(t.wrap))))
        if (t.mipMap != h3d_mat_MipMap._hx_None):
            inf = (("null" if inf is None else inf) + ((" mip=" + Std.string(t.mipMap))))
        return inf

    def getShaderInputNames(self):
        return self.d.getShaderInputNames()

    def selectBuffer(self,buffer):
        self.d.selectBuffer(buffer)

    def selectMultiBuffers(self,buffers):
        self.d.selectMultiBuffers(buffers)

    def draw(self,ibuf,startIndex,ntriangles):
        self.d.draw(ibuf,startIndex,ntriangles)

    def setRenderZone(self,x,y,width,height):
        self.d.setRenderZone(x,y,width,height)

    def setRenderTarget(self,tex,face = None,mipMap = None):
        if (face is None):
            face = 0
        if (mipMap is None):
            mipMap = 0
        _hx_str = ((((("SetRenderTarget " + Std.string(tex)) + " ") + Std.string(face)) + " ") + Std.string(mipMap))
        self.d.setRenderTarget(tex,face)

    def setRenderTargets(self,textures):
        _hx_str = ("SetRenderTargets " + Std.string(textures))
        self.d.setRenderTargets(textures)

    def end(self):
        self.d.end()

    def present(self):
        self.d.present()

    def setDebug(self,b):
        _hx_str = ("SetDebug " + Std.string(b))
        self.d.setDebug(b)

    def allocTexture(self,t):
        _hx_str = ("AllocTexture " + Std.string(t))
        return self.d.allocTexture(t)

    def allocIndexes(self,count,is32):
        _hx_str = ((("AllocIndexes " + Std.string(count)) + " ") + Std.string(is32))
        return self.d.allocIndexes(count,is32)

    def allocVertexes(self,m):
        return self.d.allocVertexes(m)

    def disposeTexture(self,t):
        self.d.disposeTexture(t)

    def disposeIndexes(self,i):
        self.d.disposeIndexes(i)

    def disposeVertexes(self,v):
        self.d.disposeVertexes(v)

    def uploadIndexBuffer(self,i,startIndice,indiceCount,buf,bufPos):
        self.d.uploadIndexBuffer(i,startIndice,indiceCount,buf,bufPos)

    def uploadIndexBytes(self,i,startIndice,indiceCount,buf,bufPos):
        self.d.uploadIndexBytes(i,startIndice,indiceCount,buf,bufPos)

    def uploadVertexBuffer(self,v,startVertex,vertexCount,buf,bufPos):
        self.d.uploadVertexBuffer(v,startVertex,vertexCount,buf,bufPos)

    def uploadVertexBytes(self,v,startVertex,vertexCount,buf,bufPos):
        self.d.uploadVertexBytes(v,startVertex,vertexCount,buf,bufPos)

    def uploadTextureBitmap(self,t,bmp,mipLevel,side):
        _hx_str = ((((("UploadTextureBitmap " + Std.string(t)) + " mip=") + Std.string(mipLevel)) + " side=") + Std.string(side))
        self.d.uploadTextureBitmap(t,bmp,mipLevel,side)

    def uploadTexturePixels(self,t,pixels,mipLevel,side):
        _hx_str = ((((("UploadTexturePixels " + Std.string(t)) + " mip=") + Std.string(mipLevel)) + " side=") + Std.string(side))
        self.d.uploadTexturePixels(t,pixels,mipLevel,side)

    @staticmethod
    def debug(f):
        raise haxe_Exception.thrown("Requires -debug")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.d = None
        _hx_o.loggedShaders = None
        _hx_o.currentShader = None
        _hx_o.logLines = None
h3d_impl_LogDriver._hx_class = h3d_impl_LogDriver
_hx_classes["h3d.impl.LogDriver"] = h3d_impl_LogDriver


class h3d_impl__ManagedBuffer_FreeCell:
    _hx_class_name = "h3d.impl._ManagedBuffer.FreeCell"
    _hx_is_interface = "False"
    __slots__ = ("pos", "count", "next")
    _hx_fields = ["pos", "count", "next"]

    def __init__(self,pos,count,next):
        self.pos = pos
        self.count = count
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pos = None
        _hx_o.count = None
        _hx_o.next = None
h3d_impl__ManagedBuffer_FreeCell._hx_class = h3d_impl__ManagedBuffer_FreeCell
_hx_classes["h3d.impl._ManagedBuffer.FreeCell"] = h3d_impl__ManagedBuffer_FreeCell


class h3d_impl_ManagedBuffer:
    _hx_class_name = "h3d.impl.ManagedBuffer"
    _hx_is_interface = "False"
    __slots__ = ("mem", "stride", "size", "flags", "vbuf", "freeList", "next")
    _hx_fields = ["mem", "stride", "size", "flags", "vbuf", "freeList", "next"]
    _hx_methods = ["uploadVertexBuffer", "uploadVertexBytes", "readVertexBytes", "alloc", "getFreeVertices", "allocPosition", "allocBuffer", "freeBuffer", "dispose", "isDisposed"]

    def __init__(self,stride,size,flags = None):
        self.next = None
        self.vbuf = None
        this1 = 0
        self.flags = this1
        if (flags is not None):
            _g = 0
            while (_g < len(flags)):
                f = (flags[_g] if _g >= 0 and _g < len(flags) else None)
                _g = (_g + 1)
                _hx_local_1 = self
                _hx_local_2 = _hx_local_1.flags
                _hx_local_1.flags = (_hx_local_2 | ((1 << f.index)))
                _hx_local_1.flags
        self.size = size
        self.stride = stride
        self.freeList = h3d_impl__ManagedBuffer_FreeCell(0,size,None)
        self.mem = h3d_Engine.CURRENT.mem
        self.mem.allocManaged(self)

    def uploadVertexBuffer(self,start,vertices,buf,bufPos = None):
        if (bufPos is None):
            bufPos = 0
        self.mem.driver.uploadVertexBuffer(self.vbuf,start,vertices,buf,bufPos)

    def uploadVertexBytes(self,start,vertices,data,dataPos = None):
        if (dataPos is None):
            dataPos = 0
        self.mem.driver.uploadVertexBytes(self.vbuf,start,vertices,data,dataPos)

    def readVertexBytes(self,start,vertices,data,dataPos = None):
        if (dataPos is None):
            dataPos = 0
        self.mem.driver.readVertexBytes(self.vbuf,start,vertices,data,dataPos)

    def alloc(self,vertices,align):
        p = self.allocPosition(vertices,align)
        if (p < 0):
            return None
        b = h3d_Buffer(vertices,self.stride,[h3d_BufferFlag.NoAlloc])
        b.position = p
        b.buffer = self
        return b

    def getFreeVertices(self):
        m = 0
        l = self.freeList
        while (l is not None):
            m = (m + l.count)
            l = l.next
        return m

    def allocPosition(self,nvert,align):
        free = self.freeList
        while (free is not None):
            if (free.count >= nvert):
                d = HxOverrides.mod(((align - (HxOverrides.mod(free.pos, align)))), align)
                if (d == 0):
                    break
                if (free.count >= ((nvert + d))):
                    free.next = h3d_impl__ManagedBuffer_FreeCell((free.pos + d),(free.count - d),free.next)
                    free.count = d
                    free = free.next
                    break
            free = free.next
        if (free is None):
            return -1
        pos = free.pos
        free.pos = (free.pos + nvert)
        free.count = (free.count - nvert)
        return pos

    def allocBuffer(self,b):
        align = (4 if ((((b.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0)) else (3 if ((((b.flags & ((1 << h3d_BufferFlag.Triangles.index)))) != 0)) else 1))
        p = self.allocPosition(b.vertices,align)
        if (p < 0):
            return False
        b.position = p
        b.buffer = self
        return True

    def freeBuffer(self,b):
        prev = None
        f = self.freeList
        nvert = b.vertices
        end = (b.position + nvert)
        while (f is not None):
            if (f.pos == end):
                f.pos = (f.pos - nvert)
                f.count = (f.count + nvert)
                if ((prev is not None) and (((prev.pos + prev.count) == f.pos))):
                    prev.count = (prev.count + f.count)
                    prev.next = f.next
                nvert = 0
                break
            if (f.pos > end):
                if ((prev is not None) and (((prev.pos + prev.count) == b.position))):
                    prev.count = (prev.count + nvert)
                else:
                    n = h3d_impl__ManagedBuffer_FreeCell(b.position,nvert,f)
                    if (prev is None):
                        self.freeList = n
                    else:
                        prev.next = n
                nvert = 0
                break
            prev = f
            f = f.next
        if (nvert != 0):
            raise haxe_Exception.thrown("assert")
        if ((self.freeList.count == self.size) and ((((self.flags & ((1 << h3d_BufferFlag.Managed.index)))) == 0))):
            self.dispose()

    def dispose(self):
        self.mem.freeManaged(self)

    def isDisposed(self):
        return (self.vbuf is None)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mem = None
        _hx_o.stride = None
        _hx_o.size = None
        _hx_o.flags = None
        _hx_o.vbuf = None
        _hx_o.freeList = None
        _hx_o.next = None
h3d_impl_ManagedBuffer._hx_class = h3d_impl_ManagedBuffer
_hx_classes["h3d.impl.ManagedBuffer"] = h3d_impl_ManagedBuffer


class python_Boot:
    _hx_class_name = "python.Boot"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "hasField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def hasField(o,field):
        if isinstance(o,_hx_AnonObject):
            return o._hx_hasattr(field)
        return hasattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)))

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 4):
                if (field1 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 5):
                if (field1 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 3):
                if (field1 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 8):
                if (field1 == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 6):
                if (field1 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            if hasattr(o,field1):
                return getattr(o,field1)
            else:
                return None

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot
_hx_classes["python.Boot"] = python_Boot


class HxString:
    _hx_class_name = "HxString"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString
_hx_classes["HxString"] = HxString


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    _hx_is_interface = "False"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.func = None
python_internal_MethodClosure._hx_class = python_internal_MethodClosure
_hx_classes["python.internal.MethodClosure"] = python_internal_MethodClosure


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl
_hx_classes["python.internal.ArrayImpl"] = python_internal_ArrayImpl


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    _hx_is_interface = "False"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.it = None
        _hx_o.x = None
        _hx_o.has = None
        _hx_o.checked = None
python_HaxeIterator._hx_class = python_HaxeIterator
_hx_classes["python.HaxeIterator"] = python_HaxeIterator


class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    _hx_is_interface = "False"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.current = None
        _hx_o.array = None
haxe_iterators_ArrayKeyValueIterator._hx_class = haxe_iterators_ArrayKeyValueIterator
_hx_classes["haxe.iterators.ArrayKeyValueIterator"] = haxe_iterators_ArrayKeyValueIterator


class h3d_impl_MemoryManager:
    _hx_class_name = "h3d.impl.MemoryManager"
    _hx_is_interface = "False"
    _hx_fields = ["driver", "buffers", "indexes", "textures", "depths", "triIndexes", "quadIndexes", "usedMemory", "texMemory", "bufferCount"]
    _hx_methods = ["init", "initIndexes", "garbage", "cleanManagedBuffers", "allocManaged", "freeManaged", "allocBuffer", "deleteIndexes", "allocIndexes", "bpp", "cleanTextures", "sortByLRU", "deleteTexture", "allocTexture", "allocDepth", "deleteDepth", "onContextLost", "dispose", "freeMemorySize", "stats", "allocStats"]
    _hx_statics = ["MAX_MEMORY", "MAX_BUFFERS", "SIZE", "ALL_FLAGS"]

    def __init__(self,driver):
        self.quadIndexes = None
        self.triIndexes = None
        self.depths = None
        self.textures = None
        self.indexes = None
        self.buffers = None
        self.bufferCount = 0
        self.texMemory = 0
        self.usedMemory = 0
        self.driver = driver

    def init(self):
        self.indexes = list()
        self.textures = list()
        self.buffers = list()
        self.depths = list()
        self.initIndexes()

    def initIndexes(self):
        this1 = list()
        indices = this1
        _g = 0
        while (_g < 65533):
            i = _g
            _g = (_g + 1)
            indices.append(i)
        self.triIndexes = h3d_Indexes.alloc(indices)
        this1 = list()
        indices = this1
        p = 0
        _g = 0
        _g1 = 16383
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            k = (i << 2)
            indices.append(k)
            indices.append((k + 1))
            indices.append((k + 2))
            indices.append((k + 2))
            indices.append((k + 1))
            indices.append((k + 3))
        indices.append(65533)
        self.quadIndexes = h3d_Indexes.alloc(indices)

    def garbage(self):
        pass

    def cleanManagedBuffers(self):
        _g = 1
        _g1 = len(self.buffers)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            b = (self.buffers[i] if i >= 0 and i < len(self.buffers) else None)
            prev = None
            while (b is not None):
                if (b.freeList.count == b.size):
                    b.dispose()
                    if (prev is None):
                        python_internal_ArrayImpl._set(self.buffers, i, b.next)
                    else:
                        prev.next = b.next
                else:
                    prev = b
                b = b.next

    def allocManaged(self,m):
        if (m.vbuf is not None):
            return
        mem = ((m.size * m.stride) * 4)
        if (mem == 0):
            return
        def _hx_local_0():
            m.vbuf = self.driver.allocVertexes(m)
            return m.vbuf
        while ((((self.usedMemory + mem) > 4294967296.) or ((self.bufferCount >= 65536))) or (((_hx_local_0()) is None))):
            if self.driver.isDisposed():
                return
            size = (self.usedMemory - self.freeMemorySize())
            self.garbage()
            self.cleanManagedBuffers()
            if ((self.usedMemory - self.freeMemorySize()) == size):
                if (self.bufferCount >= 65536):
                    raise haxe_Exception.thrown("Too many buffers")
                v = (size / 1024)
                raise haxe_Exception.thrown((((("Memory full (" + Std.string(((v if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v)) else Math.ceil(v)))))) + " KB,") + Std.string(self.bufferCount)) + " buffers)"))
        _hx_local_1 = self
        _hx_local_2 = _hx_local_1.usedMemory
        _hx_local_1.usedMemory = (_hx_local_2 + mem)
        _hx_local_1.usedMemory
        _hx_local_3 = self
        _hx_local_4 = _hx_local_3.bufferCount
        _hx_local_3.bufferCount = (_hx_local_4 + 1)
        _hx_local_4

    def freeManaged(self,m):
        if (m.vbuf is None):
            return
        self.driver.disposeVertexes(m.vbuf)
        m.vbuf = None
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.usedMemory
        _hx_local_0.usedMemory = (_hx_local_1 - (((m.size * m.stride) * 4)))
        _hx_local_0.usedMemory
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.bufferCount
        _hx_local_2.bufferCount = (_hx_local_3 - 1)
        _hx_local_3
        if (((m.flags & ((1 << h3d_BufferFlag.Managed.index)))) == 0):
            c = (self.buffers[0] if 0 < len(self.buffers) else None)
            prev = None
            while (c is not None):
                if (c == m):
                    if (prev is None):
                        python_internal_ArrayImpl._set(self.buffers, 0, m.next)
                    else:
                        prev.next = m.next
                    break
                prev = c
                c = c.next

    def allocBuffer(self,b,stride):
        _hx_max = (65532 if ((((b.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0)) else (65533 if ((((b.flags & ((1 << h3d_BufferFlag.Triangles.index)))) != 0)) else 65534))
        if (((b.vertices > _hx_max) and ((((b.flags & ((1 << h3d_BufferFlag.UniformBuffer.index)))) == 0))) and ((((b.flags & ((1 << h3d_BufferFlag.LargeBuffer.index)))) == 0))):
            if (_hx_max == 65534):
                raise haxe_Exception.thrown((("Cannot split buffer with " + Std.string(b.vertices)) + " vertices if it's not Quads/Triangles"))
            rem = (b.vertices - _hx_max)
            b.vertices = _hx_max
            self.allocBuffer(b,stride)
            n = b
            while (n.next is not None):
                n = n.next
            flags = []
            _g = 0
            _g1 = h3d_impl_MemoryManager.ALL_FLAGS
            while (_g < len(_g1)):
                f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (((b.flags & ((1 << f.index)))) != 0):
                    flags.append(f)
            n.next = h3d_Buffer(rem,stride,flags)
            return
        if (((b.flags & ((1 << h3d_BufferFlag.Managed.index)))) == 0):
            flags = None
            if (((b.flags & ((1 << h3d_BufferFlag.Dynamic.index)))) != 0):
                if (flags is None):
                    flags = []
                flags.append(h3d_BufferFlag.Dynamic)
            if (((b.flags & ((1 << h3d_BufferFlag.UniformBuffer.index)))) != 0):
                if (flags is None):
                    flags = []
                flags.append(h3d_BufferFlag.UniformBuffer)
            m = h3d_impl_ManagedBuffer(stride,b.vertices,flags)
            m.next = (self.buffers[0] if 0 < len(self.buffers) else None)
            python_internal_ArrayImpl._set(self.buffers, 0, m)
            if (not m.allocBuffer(b)):
                raise haxe_Exception.thrown("assert")
            return
        m = (self.buffers[stride] if stride >= 0 and stride < len(self.buffers) else None)
        prev = None
        while (m is not None):
            if m.allocBuffer(b):
                return
            prev = m
            m = m.next
        align = (3 if ((((b.flags & ((1 << h3d_BufferFlag.Triangles.index)))) != 0)) else (4 if ((((b.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0)) else 0))
        if ((m is None) and ((align > 0))):
            total = b.vertices
            size = total
            while (size > 2048):
                m = (self.buffers[stride] if stride >= 0 and stride < len(self.buffers) else None)
                size = (size >> 1)
                size = (size - (HxOverrides.mod(size, align)))
                b.vertices = size
                while (m is not None):
                    if m.allocBuffer(b):
                        flags = []
                        _g = 0
                        _g1 = h3d_impl_MemoryManager.ALL_FLAGS
                        while (_g < len(_g1)):
                            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                            _g = (_g + 1)
                            if (((b.flags & ((1 << f.index)))) != 0):
                                flags.append(f)
                        b.next = h3d_Buffer((total - size),stride,flags)
                        return
                    m = m.next
            b.vertices = total
        m = h3d_impl_ManagedBuffer(stride,65533,[h3d_BufferFlag.Managed])
        if (prev is None):
            python_internal_ArrayImpl._set(self.buffers, stride, m)
        else:
            prev.next = m
        if (not m.allocBuffer(b)):
            raise haxe_Exception.thrown("assert")

    def deleteIndexes(self,i):
        python_internal_ArrayImpl.remove(self.indexes,i)
        self.driver.disposeIndexes(i.ibuf)
        i.ibuf = None
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.usedMemory
        _hx_local_0.usedMemory = (_hx_local_1 - ((i.count * ((4 if (i.is32) else 2)))))
        _hx_local_0.usedMemory

    def allocIndexes(self,i):
        i.ibuf = self.driver.allocIndexes(i.count,i.is32)
        _this = self.indexes
        _this.append(i)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.usedMemory
        _hx_local_0.usedMemory = (_hx_local_1 + ((i.count * ((4 if (i.is32) else 2)))))
        _hx_local_0.usedMemory

    def bpp(self,t):
        return 4

    def cleanTextures(self,force = None):
        if (force is None):
            force = True
        self.textures.sort(key= python_lib_Functools.cmp_to_key(self.sortByLRU))
        _g = 0
        _g1 = self.textures
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((t.realloc is None) or (((t.t is None) and ((t.realloc is None))))):
                continue
            if (force or ((t.get_lastFrame() < ((hxd_Timer.frameCount - 3600))))):
                t.dispose()
                return True
        return False

    def sortByLRU(self,t1,t2):
        return (t1.get_lastFrame() - t2.get_lastFrame())

    def deleteTexture(self,t):
        if (not python_internal_ArrayImpl.remove(self.textures,t)):
            return
        self.driver.disposeTexture(t)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 - (((t.width * t.height) * self.bpp(t))))
        _hx_local_0.texMemory

    def allocTexture(self,t):
        free = self.cleanTextures(False)
        t.t = self.driver.allocTexture(t)
        if (t.t is None):
            if self.driver.isDisposed():
                return
            if (not self.cleanTextures(True)):
                raise haxe_Exception.thrown("Maximum texture memory reached")
            self.allocTexture(t)
            return
        _this = self.textures
        _this.append(t)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 + (((t.width * t.height) * self.bpp(t))))
        _hx_local_0.texMemory

    def allocDepth(self,b):
        free = self.cleanTextures(False)
        b.b = self.driver.allocDepthBuffer(b)
        if (b.b is None):
            if self.driver.isDisposed():
                return
            if (not self.cleanTextures(True)):
                raise haxe_Exception.thrown("Maximum texture memory reached")
            self.allocDepth(b)
            return
        _this = self.depths
        _this.append(b)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 + (((b.width * b.height) * 4)))
        _hx_local_0.texMemory

    def deleteDepth(self,b):
        if (not python_internal_ArrayImpl.remove(self.depths,b)):
            return
        self.driver.disposeDepthBuffer(b)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 - (((b.width * b.height) * 4)))
        _hx_local_0.texMemory

    def onContextLost(self):
        self.dispose()
        self.initIndexes()

    def dispose(self):
        if (self.triIndexes is not None):
            self.triIndexes.dispose()
        if (self.quadIndexes is not None):
            self.quadIndexes.dispose()
        self.triIndexes = None
        self.quadIndexes = None
        _g = 0
        _g1 = list(self.textures)
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            t.dispose()
        _g = 0
        _g1 = list(self.depths)
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b.dispose()
        _g = 0
        _g1 = list(self.buffers)
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b1 = b
            while (b1 is not None):
                b1.dispose()
                b1 = b1.next
        _g = 0
        _g1 = list(self.indexes)
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            i.dispose()
        self.buffers = []
        self.indexes = []
        self.textures = []
        self.bufferCount = 0
        self.usedMemory = 0
        self.texMemory = 0

    def freeMemorySize(self):
        size = 0
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b1 = b
            while (b1 is not None):
                free = b1.freeList
                while (free is not None):
                    size = (size + (((free.count * b1.stride) * 4)))
                    free = free.next
                b1 = b1.next
        return size

    def stats(self):
        total = 0
        free = 0
        count = 0
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b1 = b
            while (b1 is not None):
                total = (total + (((b1.stride * b1.size) * 4)))
                f = b1.freeList
                while (f is not None):
                    free = (free + (((f.count * b1.stride) * 4)))
                    f = f.next
                count = (count + 1)
                b1 = b1.next
        return _hx_AnonObject({'bufferCount': self.bufferCount, 'freeManagedMemory': free, 'managedMemory': total, 'totalMemory': (self.usedMemory + self.texMemory), 'textureCount': len(self.textures), 'textureMemory': self.texMemory})

    def allocStats(self):
        return []

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.driver = None
        _hx_o.buffers = None
        _hx_o.indexes = None
        _hx_o.textures = None
        _hx_o.depths = None
        _hx_o.triIndexes = None
        _hx_o.quadIndexes = None
        _hx_o.usedMemory = None
        _hx_o.texMemory = None
        _hx_o.bufferCount = None
h3d_impl_MemoryManager._hx_class = h3d_impl_MemoryManager
_hx_classes["h3d.impl.MemoryManager"] = h3d_impl_MemoryManager


class h3d_impl_NullDriver(h3d_impl_Driver):
    _hx_class_name = "h3d.impl.NullDriver"
    _hx_is_interface = "False"
    __slots__ = ("cur",)
    _hx_fields = ["cur"]
    _hx_methods = ["hasFeature", "isSupportedFormat", "logImpl", "isDisposed", "getDriverName", "init", "selectShader", "getShaderInputNames", "allocTexture", "allocIndexes", "allocVertexes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_impl_Driver


    def __init__(self):
        self.cur = None

    def hasFeature(self,f):
        return True

    def isSupportedFormat(self,fmt):
        return True

    def logImpl(self,_hx_str):
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    def isDisposed(self):
        return False

    def getDriverName(self,details):
        return "NullDriver"

    def init(self,onCreate,forceSoftware = None):
        if (forceSoftware is None):
            forceSoftware = False
        onCreate(False)

    def selectShader(self,shader):
        if (self.cur == shader):
            return False
        self.cur = shader
        return True

    def getShaderInputNames(self):
        names = []
        _g = 0
        _g1 = self.cur.vertex.data.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (v.kind == hxsl_VarKind.Input):
                x = v.name
                names.append(x)
        return h3d_impl_InputNames.get(names)

    def allocTexture(self,t):
        return _hx_AnonObject({})

    def allocIndexes(self,count,is32):
        return _hx_AnonObject({})

    def allocVertexes(self,m):
        return _hx_AnonObject({})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cur = None
h3d_impl_NullDriver._hx_class = h3d_impl_NullDriver
_hx_classes["h3d.impl.NullDriver"] = h3d_impl_NullDriver

class h3d_impl_Step(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.impl.Step"
    _hx_constructs = ["MainDraw", "Decals", "Shadows", "Lighting", "Forward", "BeforeTonemapping", "AfterTonemapping", "Overlay"]
h3d_impl_Step.MainDraw = h3d_impl_Step("MainDraw", 0, ())
h3d_impl_Step.Decals = h3d_impl_Step("Decals", 1, ())
h3d_impl_Step.Shadows = h3d_impl_Step("Shadows", 2, ())
h3d_impl_Step.Lighting = h3d_impl_Step("Lighting", 3, ())
h3d_impl_Step.Forward = h3d_impl_Step("Forward", 4, ())
h3d_impl_Step.BeforeTonemapping = h3d_impl_Step("BeforeTonemapping", 5, ())
h3d_impl_Step.AfterTonemapping = h3d_impl_Step("AfterTonemapping", 6, ())
h3d_impl_Step.Overlay = h3d_impl_Step("Overlay", 7, ())
h3d_impl_Step._hx_class = h3d_impl_Step
_hx_classes["h3d.impl.Step"] = h3d_impl_Step


class h3d_impl_RendererFX:
    _hx_class_name = "h3d.impl.RendererFX"
    _hx_is_interface = "True"
    __slots__ = ("enabled",)
    _hx_fields = ["enabled"]
    _hx_methods = ["begin", "end", "dispose"]
h3d_impl_RendererFX._hx_class = h3d_impl_RendererFX
_hx_classes["h3d.impl.RendererFX"] = h3d_impl_RendererFX


class h3d_impl_TextureCache:
    _hx_class_name = "h3d.impl.TextureCache"
    _hx_is_interface = "False"
    __slots__ = ("cache", "position", "defaultDepthBuffer", "ctx", "defaultFormat")
    _hx_fields = ["cache", "position", "defaultDepthBuffer", "ctx", "defaultFormat"]
    _hx_methods = ["get", "getNamed", "set", "begin", "lookupTarget", "allocTarget", "allocTargetScale", "allocTileTarget", "dispose"]

    def __init__(self,ctx):
        self.position = 0
        self.ctx = ctx
        self.cache = []
        engine = h3d_Engine.CURRENT
        self.defaultFormat = h3d_mat_Texture.nativeFormat
        self.defaultDepthBuffer = h3d_mat_DepthBuffer.getDefault()

    def get(self,index = None):
        if (index is None):
            index = 0
        return (self.cache[index] if index >= 0 and index < len(self.cache) else None)

    def getNamed(self,name):
        _g = 0
        _g1 = self.position
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.cache[i] if i >= 0 and i < len(self.cache) else None).name == name):
                return (self.cache[i] if i >= 0 and i < len(self.cache) else None)
        return None

    def set(self,t,index):
        python_internal_ArrayImpl._set(self.cache, index, t)

    def begin(self):
        while (len(self.cache) > self.position):
            _this = self.cache
            t = (None if ((len(_this) == 0)) else _this.pop())
            if (t is not None):
                t.dispose()
        self.position = 0

    def lookupTarget(self,name,width,height,format,isCube):
        t = python_internal_ArrayImpl._get(self.cache, self.position)
        _g = (self.position + 1)
        _g1 = len(self.cache)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            t2 = (self.cache[i] if i >= 0 and i < len(self.cache) else None)
            if ((((((t2 is not None) and (not (((t2.t is None) and ((t2.realloc is None)))))) and ((t2.width == width))) and ((t2.height == height))) and ((t2.format == format))) and ((isCube == ((((t2.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0))))):
                python_internal_ArrayImpl._set(self.cache, self.position, t2)
                python_internal_ArrayImpl._set(self.cache, i, t)
                return t2
        if ((t is not None) and ((t.name == name))):
            t.dispose()
            t = None
        flags = [h3d_mat_TextureFlags.Target]
        if isCube:
            flags.append(h3d_mat_TextureFlags.Cube)
        newt = h3d_mat_Texture(width,height,flags,format)
        if (t is not None):
            pos = self.position
            self.cache.insert(pos, newt)
        else:
            python_internal_ArrayImpl._set(self.cache, self.position, newt)
        return newt

    def allocTarget(self,name,width,height,defaultDepth = None,format = None,isCube = None):
        if (defaultDepth is None):
            defaultDepth = True
        if (isCube is None):
            isCube = False
        t = python_internal_ArrayImpl._get(self.cache, self.position)
        if (format is None):
            format = self.defaultFormat
        if ((((((t is None) or (((t.t is None) and ((t.realloc is None))))) or ((t.width != width))) or ((t.height != height))) or ((t.format != format))) or ((isCube != ((((t.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0))))):
            t = self.lookupTarget(name,width,height,format,isCube)
        t.depthBuffer = (self.defaultDepthBuffer if defaultDepth else None)
        t.setName(name)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.position
        _hx_local_0.position = (_hx_local_1 + 1)
        _hx_local_1
        return t

    def allocTargetScale(self,name,scale,defaultDepth = None,format = None):
        if (defaultDepth is None):
            defaultDepth = True
        e = h3d_Engine.CURRENT
        return self.allocTarget(name,Math.ceil((e.width * scale)),Math.ceil((e.height * scale)),defaultDepth,format)

    def allocTileTarget(self,name,tile,defaultDepth = None,format = None):
        if (defaultDepth is None):
            defaultDepth = False
        return self.allocTarget(name,(Math.ceil((tile.width + tile.x)) - Math.floor(tile.x)),(Math.ceil((tile.height + tile.y)) - Math.floor(tile.y)),defaultDepth,format)

    def dispose(self):
        _g = 0
        _g1 = self.cache
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            t.dispose()
        self.cache = []

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cache = None
        _hx_o.position = None
        _hx_o.defaultDepthBuffer = None
        _hx_o.ctx = None
        _hx_o.defaultFormat = None
h3d_impl_TextureCache._hx_class = h3d_impl_TextureCache
_hx_classes["h3d.impl.TextureCache"] = h3d_impl_TextureCache


class hxd_impl_AnyProps:
    _hx_class_name = "hxd.impl.AnyProps"
    _hx_is_interface = "False"
    __slots__ = ("props",)
    _hx_fields = ["props"]
    _hx_methods = ["set_props", "setDefaultProps", "getDefaultProps", "refreshProps"]

    def set_props(self,p):
        self.props = p
        self.refreshProps()
        return p

    def setDefaultProps(self,kind):
        self.set_props(self.getDefaultProps(kind))

    def getDefaultProps(self,kind = None):
        return _hx_AnonObject({})

    def refreshProps(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.props = None
hxd_impl_AnyProps._hx_class = hxd_impl_AnyProps
_hx_classes["hxd.impl.AnyProps"] = hxd_impl_AnyProps


class h3d_mat_BaseMaterial(hxd_impl_AnyProps):
    _hx_class_name = "h3d.mat.BaseMaterial"
    _hx_is_interface = "False"
    __slots__ = ("passes", "name")
    _hx_fields = ["passes", "name"]
    _hx_methods = ["addPass", "removePass", "get_mainPass", "getPasses", "getPass", "allocPass", "clone"]
    _hx_statics = []
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]
    _hx_super = hxd_impl_AnyProps


    def __init__(self,shader = None):
        self.name = None
        self.passes = None
        if (shader is not None):
            self.addPass(h3d_mat_Pass("default",None)).addShader(shader)

    def addPass(self,p):
        prev = None
        cur = self.passes
        while (cur is not None):
            prev = cur
            cur = cur.nextPass
        if (prev is None):
            self.passes = p
        else:
            prev.nextPass = p
        p.nextPass = None
        return p

    def removePass(self,p):
        prev = None
        cur = self.passes
        while (cur is not None):
            if (cur == p):
                if (prev is None):
                    self.passes = p.nextPass
                else:
                    prev.nextPass = p.nextPass
                p.nextPass = None
                return True
            prev = cur
            cur = cur.nextPass
        return False

    def get_mainPass(self):
        return self.passes

    def getPasses(self):
        p = self.passes
        out = []
        while (p is not None):
            out.append(p)
            p = p.nextPass
        return out

    def getPass(self,name):
        p = self.passes
        while (p is not None):
            if (p.name == name):
                return p
            p = p.nextPass
        return None

    def allocPass(self,name,inheritMain = None):
        if (inheritMain is None):
            inheritMain = True
        p = self.getPass(name)
        if (p is not None):
            return p
        p = h3d_mat_Pass(name,None,(self.passes if inheritMain else None))
        if (inheritMain and ((self.passes is not None))):
            p.set_batchMode(self.passes.batchMode)
        self.addPass(p)
        return p

    def clone(self,m = None):
        if (m is None):
            m = h3d_mat_BaseMaterial()
        m.passes.load(self.passes)
        m.name = self.name
        m.set_props(self.props)
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.passes = None
        _hx_o.name = None
h3d_mat_BaseMaterial._hx_class = h3d_mat_BaseMaterial
_hx_classes["h3d.mat.BaseMaterial"] = h3d_mat_BaseMaterial

class h3d_mat_Face(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Face"
    _hx_constructs = ["None", "Back", "Front", "Both"]
h3d_mat_Face._hx_None = h3d_mat_Face("None", 0, ())
h3d_mat_Face.Back = h3d_mat_Face("Back", 1, ())
h3d_mat_Face.Front = h3d_mat_Face("Front", 2, ())
h3d_mat_Face.Both = h3d_mat_Face("Both", 3, ())
h3d_mat_Face._hx_class = h3d_mat_Face
_hx_classes["h3d.mat.Face"] = h3d_mat_Face

class h3d_mat_Blend(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Blend"
    _hx_constructs = ["One", "Zero", "SrcAlpha", "SrcColor", "DstAlpha", "DstColor", "OneMinusSrcAlpha", "OneMinusSrcColor", "OneMinusDstAlpha", "OneMinusDstColor", "ConstantColor", "ConstantAlpha", "OneMinusConstantColor", "OneMinusConstantAlpha", "SrcAlphaSaturate"]
h3d_mat_Blend.One = h3d_mat_Blend("One", 0, ())
h3d_mat_Blend.Zero = h3d_mat_Blend("Zero", 1, ())
h3d_mat_Blend.SrcAlpha = h3d_mat_Blend("SrcAlpha", 2, ())
h3d_mat_Blend.SrcColor = h3d_mat_Blend("SrcColor", 3, ())
h3d_mat_Blend.DstAlpha = h3d_mat_Blend("DstAlpha", 4, ())
h3d_mat_Blend.DstColor = h3d_mat_Blend("DstColor", 5, ())
h3d_mat_Blend.OneMinusSrcAlpha = h3d_mat_Blend("OneMinusSrcAlpha", 6, ())
h3d_mat_Blend.OneMinusSrcColor = h3d_mat_Blend("OneMinusSrcColor", 7, ())
h3d_mat_Blend.OneMinusDstAlpha = h3d_mat_Blend("OneMinusDstAlpha", 8, ())
h3d_mat_Blend.OneMinusDstColor = h3d_mat_Blend("OneMinusDstColor", 9, ())
h3d_mat_Blend.ConstantColor = h3d_mat_Blend("ConstantColor", 10, ())
h3d_mat_Blend.ConstantAlpha = h3d_mat_Blend("ConstantAlpha", 11, ())
h3d_mat_Blend.OneMinusConstantColor = h3d_mat_Blend("OneMinusConstantColor", 12, ())
h3d_mat_Blend.OneMinusConstantAlpha = h3d_mat_Blend("OneMinusConstantAlpha", 13, ())
h3d_mat_Blend.SrcAlphaSaturate = h3d_mat_Blend("SrcAlphaSaturate", 14, ())
h3d_mat_Blend._hx_class = h3d_mat_Blend
_hx_classes["h3d.mat.Blend"] = h3d_mat_Blend

class h3d_mat_Compare(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Compare"
    _hx_constructs = ["Always", "Never", "Equal", "NotEqual", "Greater", "GreaterEqual", "Less", "LessEqual"]
h3d_mat_Compare.Always = h3d_mat_Compare("Always", 0, ())
h3d_mat_Compare.Never = h3d_mat_Compare("Never", 1, ())
h3d_mat_Compare.Equal = h3d_mat_Compare("Equal", 2, ())
h3d_mat_Compare.NotEqual = h3d_mat_Compare("NotEqual", 3, ())
h3d_mat_Compare.Greater = h3d_mat_Compare("Greater", 4, ())
h3d_mat_Compare.GreaterEqual = h3d_mat_Compare("GreaterEqual", 5, ())
h3d_mat_Compare.Less = h3d_mat_Compare("Less", 6, ())
h3d_mat_Compare.LessEqual = h3d_mat_Compare("LessEqual", 7, ())
h3d_mat_Compare._hx_class = h3d_mat_Compare
_hx_classes["h3d.mat.Compare"] = h3d_mat_Compare

class h3d_mat_StencilOp(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.StencilOp"
    _hx_constructs = ["Keep", "Zero", "Replace", "Increment", "IncrementWrap", "Decrement", "DecrementWrap", "Invert"]
h3d_mat_StencilOp.Keep = h3d_mat_StencilOp("Keep", 0, ())
h3d_mat_StencilOp.Zero = h3d_mat_StencilOp("Zero", 1, ())
h3d_mat_StencilOp.Replace = h3d_mat_StencilOp("Replace", 2, ())
h3d_mat_StencilOp.Increment = h3d_mat_StencilOp("Increment", 3, ())
h3d_mat_StencilOp.IncrementWrap = h3d_mat_StencilOp("IncrementWrap", 4, ())
h3d_mat_StencilOp.Decrement = h3d_mat_StencilOp("Decrement", 5, ())
h3d_mat_StencilOp.DecrementWrap = h3d_mat_StencilOp("DecrementWrap", 6, ())
h3d_mat_StencilOp.Invert = h3d_mat_StencilOp("Invert", 7, ())
h3d_mat_StencilOp._hx_class = h3d_mat_StencilOp
_hx_classes["h3d.mat.StencilOp"] = h3d_mat_StencilOp

class h3d_mat_MipMap(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.MipMap"
    _hx_constructs = ["None", "Nearest", "Linear"]
h3d_mat_MipMap._hx_None = h3d_mat_MipMap("None", 0, ())
h3d_mat_MipMap.Nearest = h3d_mat_MipMap("Nearest", 1, ())
h3d_mat_MipMap.Linear = h3d_mat_MipMap("Linear", 2, ())
h3d_mat_MipMap._hx_class = h3d_mat_MipMap
_hx_classes["h3d.mat.MipMap"] = h3d_mat_MipMap

class h3d_mat_Filter(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Filter"
    _hx_constructs = ["Nearest", "Linear"]
h3d_mat_Filter.Nearest = h3d_mat_Filter("Nearest", 0, ())
h3d_mat_Filter.Linear = h3d_mat_Filter("Linear", 1, ())
h3d_mat_Filter._hx_class = h3d_mat_Filter
_hx_classes["h3d.mat.Filter"] = h3d_mat_Filter

class h3d_mat_Wrap(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Wrap"
    _hx_constructs = ["Clamp", "Repeat"]
h3d_mat_Wrap.Clamp = h3d_mat_Wrap("Clamp", 0, ())
h3d_mat_Wrap.Repeat = h3d_mat_Wrap("Repeat", 1, ())
h3d_mat_Wrap._hx_class = h3d_mat_Wrap
_hx_classes["h3d.mat.Wrap"] = h3d_mat_Wrap

class h3d_mat_Operation(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Operation"
    _hx_constructs = ["Add", "Sub", "ReverseSub", "Min", "Max"]
h3d_mat_Operation.Add = h3d_mat_Operation("Add", 0, ())
h3d_mat_Operation.Sub = h3d_mat_Operation("Sub", 1, ())
h3d_mat_Operation.ReverseSub = h3d_mat_Operation("ReverseSub", 2, ())
h3d_mat_Operation.Min = h3d_mat_Operation("Min", 3, ())
h3d_mat_Operation.Max = h3d_mat_Operation("Max", 4, ())
h3d_mat_Operation._hx_class = h3d_mat_Operation
_hx_classes["h3d.mat.Operation"] = h3d_mat_Operation

class h3d_mat_TextureFlags(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.TextureFlags"
    _hx_constructs = ["Target", "Cube", "MipMapped", "ManualMipMapGen", "IsNPOT", "NoAlloc", "Dynamic", "AlphaPremultiplied", "WasCleared", "Loading", "Serialize", "IsArray"]
h3d_mat_TextureFlags.Target = h3d_mat_TextureFlags("Target", 0, ())
h3d_mat_TextureFlags.Cube = h3d_mat_TextureFlags("Cube", 1, ())
h3d_mat_TextureFlags.MipMapped = h3d_mat_TextureFlags("MipMapped", 2, ())
h3d_mat_TextureFlags.ManualMipMapGen = h3d_mat_TextureFlags("ManualMipMapGen", 3, ())
h3d_mat_TextureFlags.IsNPOT = h3d_mat_TextureFlags("IsNPOT", 4, ())
h3d_mat_TextureFlags.NoAlloc = h3d_mat_TextureFlags("NoAlloc", 5, ())
h3d_mat_TextureFlags.Dynamic = h3d_mat_TextureFlags("Dynamic", 6, ())
h3d_mat_TextureFlags.AlphaPremultiplied = h3d_mat_TextureFlags("AlphaPremultiplied", 7, ())
h3d_mat_TextureFlags.WasCleared = h3d_mat_TextureFlags("WasCleared", 8, ())
h3d_mat_TextureFlags.Loading = h3d_mat_TextureFlags("Loading", 9, ())
h3d_mat_TextureFlags.Serialize = h3d_mat_TextureFlags("Serialize", 10, ())
h3d_mat_TextureFlags.IsArray = h3d_mat_TextureFlags("IsArray", 11, ())
h3d_mat_TextureFlags._hx_class = h3d_mat_TextureFlags
_hx_classes["h3d.mat.TextureFlags"] = h3d_mat_TextureFlags


class h3d_mat_Defaults:
    _hx_class_name = "h3d.mat.Defaults"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["defaultKillAlphaThreshold", "loadingTextureColor", "shadowShader", "get_shadowShader", "set_shadowShader", "makeVolumeDecal"]
    shadowShader = None

    @staticmethod
    def get_shadowShader():
        s = h3d_mat_Defaults.shadowShader
        if (s is None):
            s = h3d_shader_Shadow()
            h3d_mat_Defaults.set_shadowShader(s)
            h3d_mat_Defaults.shadowShader.setPriority(-1)
        return s

    @staticmethod
    def set_shadowShader(s):
        def _hx_local_1():
            def _hx_local_0():
                h3d_mat_Defaults.shadowShader = s
                return h3d_mat_Defaults.shadowShader
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def makeVolumeDecal(bounds):
        return h3d_shader_VolumeDecal((bounds.xMax - bounds.xMin),(bounds.yMax - bounds.yMin))
h3d_mat_Defaults._hx_class = h3d_mat_Defaults
_hx_classes["h3d.mat.Defaults"] = h3d_mat_Defaults

class h3d_mat_DepthFormat(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.DepthFormat"
    _hx_constructs = ["Depth16", "Depth24", "Depth24Stencil8"]
h3d_mat_DepthFormat.Depth16 = h3d_mat_DepthFormat("Depth16", 0, ())
h3d_mat_DepthFormat.Depth24 = h3d_mat_DepthFormat("Depth24", 1, ())
h3d_mat_DepthFormat.Depth24Stencil8 = h3d_mat_DepthFormat("Depth24Stencil8", 2, ())
h3d_mat_DepthFormat._hx_class = h3d_mat_DepthFormat
_hx_classes["h3d.mat.DepthFormat"] = h3d_mat_DepthFormat


class h3d_mat_DepthBuffer:
    _hx_class_name = "h3d.mat.DepthBuffer"
    _hx_is_interface = "False"
    __slots__ = ("b", "width", "height", "format")
    _hx_fields = ["b", "width", "height", "format"]
    _hx_methods = ["hasStencil", "alloc", "dispose", "isDisposed"]
    _hx_statics = ["getDefault"]

    def __init__(self,width,height,format = None):
        self.b = None
        self.width = width
        self.height = height
        self.format = format
        if (width > 0):
            self.alloc()

    def hasStencil(self):
        tmp = self.format.index
        if ((tmp == 1) or ((tmp == 0))):
            return False
        elif (tmp == 2):
            return True
        else:
            pass

    def alloc(self):
        h3d_Engine.CURRENT.mem.allocDepth(self)

    def dispose(self):
        if (self.b is not None):
            h3d_Engine.CURRENT.mem.deleteDepth(self)
            self.b = None

    def isDisposed(self):
        return (self.b is None)

    @staticmethod
    def getDefault():
        return h3d_Engine.CURRENT.driver.getDefaultDepthBuffer()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.format = None
h3d_mat_DepthBuffer._hx_class = h3d_mat_DepthBuffer
_hx_classes["h3d.mat.DepthBuffer"] = h3d_mat_DepthBuffer


class h3d_mat_Material(h3d_mat_BaseMaterial):
    _hx_class_name = "h3d.mat.Material"
    _hx_is_interface = "False"
    __slots__ = ("mshader", "normalShader", "model", "castShadows", "receiveShadows", "staticShadows", "textureShader", "specularShader", "blendMode")
    _hx_fields = ["mshader", "normalShader", "model", "castShadows", "receiveShadows", "staticShadows", "textureShader", "specularShader", "blendMode"]
    _hx_methods = ["get_specularPower", "set_specularPower", "get_specularAmount", "set_specularAmount", "get_color", "set_color", "get_shadows", "set_shadows", "set_castShadows", "set_receiveShadows", "set_staticShadows", "clone", "set_blendMode", "get_specularTexture", "get_texture", "set_texture", "get_normalMap", "set_normalMap", "set_specularTexture", "getDefaultModelProps", "getDefaultProps", "refreshProps"]
    _hx_statics = ["create"]
    _hx_interfaces = []
    _hx_super = h3d_mat_BaseMaterial


    def __init__(self,texture = None):
        self.blendMode = None
        self.specularShader = None
        self.textureShader = None
        self.staticShadows = None
        self.receiveShadows = None
        self.castShadows = None
        self.model = None
        self.normalShader = None
        self.mshader = h3d_shader_BaseMesh()
        self.set_blendMode(h2d_BlendMode._hx_None)
        super().__init__(self.mshader)
        self.set_texture(texture)

    def get_specularPower(self):
        return self.mshader.specularPower__

    def set_specularPower(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.mshader.specularPower__ = v
                return self.mshader.specularPower__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularAmount(self):
        return self.mshader.specularAmount__

    def set_specularAmount(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.mshader.specularAmount__ = v
                return self.mshader.specularAmount__
            return _hx_local_0()
        return _hx_local_1()

    def get_color(self):
        return self.mshader.color__

    def set_color(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.mshader.color__ = v
                return self.mshader.color__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadows(self):
        if self.castShadows:
            return self.receiveShadows
        else:
            return False

    def set_shadows(self,v):
        self.set_castShadows(v)
        self.set_receiveShadows(v)
        return v

    def set_castShadows(self,v):
        if (self.castShadows == v):
            return v
        if (self.passes is not None):
            if v:
                self.addPass(h3d_mat_Pass("shadow",None,self.passes)).set_isStatic(self.staticShadows)
            else:
                self.removePass(self.getPass("shadow"))
        def _hx_local_1():
            def _hx_local_0():
                self.castShadows = v
                return self.castShadows
            return _hx_local_0()
        return _hx_local_1()

    def set_receiveShadows(self,v):
        if (v == self.receiveShadows):
            return v
        if (self.passes is not None):
            shadows = h3d_mat_Defaults.get_shadowShader()
            if v:
                self.passes.addShader(shadows)
            else:
                self.passes.removeShader(shadows)
        def _hx_local_1():
            def _hx_local_0():
                self.receiveShadows = v
                return self.receiveShadows
            return _hx_local_0()
        return _hx_local_1()

    def set_staticShadows(self,v):
        p = self.getPass("shadow")
        if (p is not None):
            p.set_isStatic(v)
        def _hx_local_1():
            def _hx_local_0():
                self.staticShadows = v
                return self.staticShadows
            return _hx_local_0()
        return _hx_local_1()

    def clone(self,m = None):
        m1 = (h3d_mat_Material() if ((m is None)) else m)
        super().clone(m1)
        m1.set_castShadows(self.castShadows)
        m1.set_receiveShadows(self.receiveShadows)
        m1.set_texture(self.get_texture())
        m1.set_specularTexture(self.get_specularTexture())
        m1.set_normalMap(self.get_normalMap())
        if (self.textureShader is not None):
            _this = m1.textureShader
            _this.constModified = True
            _this.additive__ = self.textureShader.additive__
            _this = m1.textureShader
            _this.constModified = True
            _this.killAlpha__ = self.textureShader.killAlpha__
            m1.textureShader.killAlphaThreshold__ = self.textureShader.killAlphaThreshold__
        m1.mshader.color__ = self.mshader.color__
        m1.set_blendMode(self.blendMode)
        return m1

    def set_blendMode(self,v):
        if (self.passes is not None):
            self.passes.setBlendMode(v)
            tmp = v.index
            if (tmp == 0):
                self.passes.set_depthWrite(True)
                self.passes.setPassName("default")
            elif (tmp == 1):
                self.passes.set_depthWrite(True)
                self.passes.setPassName("alpha")
            elif ((((((((((tmp == 11) or ((tmp == 10))) or ((tmp == 9))) or ((tmp == 8))) or ((tmp == 7))) or ((tmp == 6))) or ((tmp == 5))) or ((tmp == 4))) or ((tmp == 3))) or ((tmp == 2))):
                self.passes.set_depthWrite(False)
                self.passes.setPassName("additive")
            else:
                pass
        def _hx_local_1():
            def _hx_local_0():
                self.blendMode = v
                return self.blendMode
            return _hx_local_0()
        return _hx_local_1()

    def get_specularTexture(self):
        if (self.specularShader is None):
            return None
        else:
            return self.specularShader.texture__

    def get_texture(self):
        if (self.textureShader is None):
            return None
        else:
            return self.textureShader.texture__

    def set_texture(self,t):
        if (t is None):
            if (self.textureShader is not None):
                self.passes.removeShader(self.textureShader)
                self.textureShader = None
        else:
            if (self.textureShader is None):
                self.textureShader = h3d_shader_Texture()
                self.passes.addShader(self.textureShader)
            self.textureShader.texture__ = t
        return t

    def get_normalMap(self):
        if (self.normalShader is None):
            return None
        else:
            return self.normalShader.texture__

    def set_normalMap(self,t):
        if (t is None):
            if (self.normalShader is not None):
                self.passes.removeShader(self.normalShader)
                self.normalShader = None
        else:
            if (self.normalShader is None):
                self.normalShader = h3d_shader_NormalMap()
                if (self.textureShader is not None):
                    self.passes.addShaderAtIndex(self.normalShader,(self.passes.getShaderIndex(self.textureShader) + 1))
                else:
                    self.passes.addShader(self.normalShader)
            self.normalShader.texture__ = t
        return t

    def set_specularTexture(self,t):
        if (t is None):
            if (self.specularShader is not None):
                self.passes.removeShader(self.specularShader)
                self.specularShader = None
        else:
            if (self.specularShader is None):
                self.specularShader = h3d_shader_SpecularTexture()
                self.passes.addShader(self.specularShader)
            self.specularShader.texture__ = t
        return t

    def getDefaultModelProps(self):
        props = self.getDefaultProps()
        tmp = self.blendMode.index
        if (tmp == 0):
            pass
        elif (tmp == 1):
            props.kind = "Alpha"
        elif (tmp == 2):
            props.kind = "Add"
            props.culling = False
            props.shadows = False
            props.light = False
        else:
            raise haxe_Exception.thrown(("Unsupported HMD material " + Std.string(self.blendMode)))
        return props

    def getDefaultProps(self,_hx_type = None):
        props = None
        if (_hx_type is None):
            props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
        else:
            type1 = _hx_type
            _hx_local_0 = len(type1)
            if (_hx_local_0 == 11):
                if (type1 == "particles3D"):
                    props = _hx_AnonObject({'kind': "Alpha", 'shadows': False, 'culling': False, 'light': True})
                else:
                    props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
            elif (_hx_local_0 == 7):
                if (type1 == "trail3D"):
                    props = _hx_AnonObject({'kind': "Alpha", 'shadows': False, 'culling': False, 'light': True})
                else:
                    props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
            elif (_hx_local_0 == 2):
                if (type1 == "ui"):
                    props = _hx_AnonObject({'kind': "Alpha", 'shadows': False, 'culling': False, 'light': False})
                else:
                    props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
            else:
                props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
        return props

    def refreshProps(self):
        if ((self.props is None) or ((self.passes is None))):
            return
        props = self.props
        _g = props.kind
        if (_g == "Add"):
            self.set_blendMode(h2d_BlendMode.Add)
        elif (_g == "Alpha"):
            self.set_blendMode(h2d_BlendMode.Alpha)
        elif (((_g == "Opaque") or ((_g == "Hidden"))) or ((_g == "AlphaKill"))):
            self.set_blendMode(h2d_BlendMode._hx_None)
        elif (_g == "SoftAdd"):
            self.set_blendMode(h2d_BlendMode.SoftAdd)
        else:
            pass
        tshader = self.textureShader
        if (tshader is not None):
            tshader.constModified = True
            tshader.killAlpha__ = (props.kind == "AlphaKill")
            tshader.killAlphaThreshold__ = 0.5
        self.passes.set_culling((h3d_mat_Face.Both if ((props.kind == "Hidden")) else (h3d_mat_Face.Back if (props.culling) else h3d_mat_Face._hx_None)))
        self.passes.set_enableLights(props.light)
        v = props.shadows
        self.set_castShadows(v)
        self.set_receiveShadows(v)
        if (self.castShadows and self.receiveShadows):
            self.getPass("shadow").set_culling(self.passes.culling)

    @staticmethod
    def create(tex = None):
        mat = h3d_mat_MaterialSetup.current.createMaterial()
        mat.set_texture(tex)
        mat.set_props(mat.getDefaultProps())
        return mat

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mshader = None
        _hx_o.normalShader = None
        _hx_o.model = None
        _hx_o.castShadows = None
        _hx_o.receiveShadows = None
        _hx_o.staticShadows = None
        _hx_o.textureShader = None
        _hx_o.specularShader = None
        _hx_o.blendMode = None
h3d_mat_Material._hx_class = h3d_mat_Material
_hx_classes["h3d.mat.Material"] = h3d_mat_Material


class h3d_mat_MaterialDatabase:
    _hx_class_name = "h3d.mat.MaterialDatabase"
    _hx_is_interface = "False"
    __slots__ = ("db",)
    _hx_fields = ["db"]
    _hx_methods = ["getFilePath", "getModelData", "saveData", "loadMatProps", "saveMatProps"]

    def __init__(self):
        self.db = haxe_ds_StringMap()

    def getFilePath(self,model):
        return (HxOverrides.stringOrNull(model.entry.get_directory()) + "/materials.props")

    def getModelData(self,model):
        if (model is None):
            return None
        this1 = self.db
        key = model.entry.get_directory()
        cached = this1.h.get(key,None)
        if (cached is not None):
            return cached.v
        file = self.getFilePath(model)
        value = None
        try:
            value = python_lib_Json.loads(hxd_res_Loader.currentInstance.load(file).toText(),**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),hxd_fs_NotFound):
                value = _hx_AnonObject({})
            else:
                raise _g
        this1 = self.db
        key = model.entry.get_directory()
        this1.h[key] = _hx_AnonObject({'v': value})
        return value

    def saveData(self,model,data):
        file = self.getFilePath(model)
        fs = Std.downcast(hxd_res_Loader.currentInstance.fs,hxd_fs_LocalFileSystem)
        if ((fs is not None) and (not haxe_io_Path.isAbsolute(file))):
            file = (HxOverrides.stringOrNull(fs.baseDir) + ("null" if file is None else file))
        if (data is None):
            try:
                sys_FileSystem.deleteFile(file)
            except BaseException as _g:
                None
        else:
            sys_io_File.saveContent(file,haxe_format_JsonPrinter.print(data,None,"\t"))

    def loadMatProps(self,material,setup):
        p = self.getModelData(material.model)
        if (p is None):
            return p
        p = Reflect.field(p,"materials")
        if (p is None):
            return p
        p = Reflect.field(p,setup.name)
        if (p is None):
            return p
        return Reflect.field(p,material.name)

    def saveMatProps(self,material,setup):
        path = ["materials", setup.name, material.name]
        root = self.getModelData(material.model)
        if (root is None):
            return
        realRoot = root
        prevs = []
        _g = 0
        _g1 = (len(path) - 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            next = Reflect.field(root,(path[i] if i >= 0 and i < len(path) else None))
            if (next is None):
                next = _hx_AnonObject({})
                field = (path[i] if i >= 0 and i < len(path) else None)
                setattr(root,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),next)
            prevs.append(root)
            root = next
        name = (None if ((len(path) == 0)) else path.pop())
        Reflect.deleteField(root,name)
        currentProps = material.props
        defaultProps = material.getDefaultProps()
        if ((currentProps is None) or ((Std.string(defaultProps) == Std.string(currentProps)))):
            while (len(path) > 0):
                name1 = (None if ((len(path) == 0)) else path.pop())
                root1 = (None if ((len(prevs) == 0)) else prevs.pop())
                if (len(python_Boot.fields(Reflect.field(root1,name1))) != 0):
                    break
                Reflect.deleteField(root1,name1)
        else:
            setattr(root,(("_hx_" + name) if ((name in python_Boot.keywords)) else (("_hx_" + name) if (((((len(name) > 2) and ((ord(name[0]) == 95))) and ((ord(name[1]) == 95))) and ((ord(name[(len(name) - 1)]) != 95)))) else name)),currentProps)
        file = self.getFilePath(material.model)
        if (len(python_Boot.fields(realRoot)) == 0):
            realRoot = None
        self.saveData(material.model,realRoot)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.db = None
h3d_mat_MaterialDatabase._hx_class = h3d_mat_MaterialDatabase
_hx_classes["h3d.mat.MaterialDatabase"] = h3d_mat_MaterialDatabase


class h3d_mat_MaterialSetup:
    _hx_class_name = "h3d.mat.MaterialSetup"
    _hx_is_interface = "False"
    __slots__ = ("name", "displayName", "database", "emptyMat")
    _hx_fields = ["name", "displayName", "database", "emptyMat"]
    _hx_methods = ["createRenderer", "createLightSystem", "createMaterial", "getDefaults", "loadMaterialProps", "saveMaterialProps", "customMeshInit"]
    _hx_statics = ["current"]

    def __init__(self,name):
        self.emptyMat = None
        self.database = None
        self.displayName = None
        self.name = None
        if (self.database is None):
            self.database = h3d_mat_MaterialDatabase()
        self.name = name

    def createRenderer(self):
        return h3d_scene_fwd_Renderer()

    def createLightSystem(self):
        return h3d_scene_fwd_LightSystem()

    def createMaterial(self):
        return h3d_mat_Material()

    def getDefaults(self,kind = None):
        if (self.emptyMat is None):
            self.emptyMat = self.createMaterial()
        return self.emptyMat.getDefaultProps(kind)

    def loadMaterialProps(self,material):
        return self.database.loadMatProps(material,self)

    def saveMaterialProps(self,material):
        self.database.saveMatProps(material,self)

    def customMeshInit(self,mesh):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.displayName = None
        _hx_o.database = None
        _hx_o.emptyMat = None
h3d_mat_MaterialSetup._hx_class = h3d_mat_MaterialSetup
_hx_classes["h3d.mat.MaterialSetup"] = h3d_mat_MaterialSetup


class h3d_mat_Pass:
    _hx_class_name = "h3d.mat.Pass"
    _hx_is_interface = "False"
    __slots__ = ("name", "flags", "passId", "bits", "parentPass", "parentShaders", "shaders", "nextPass", "enableLights", "dynamicParameters", "isStatic", "batchMode", "culling", "depthWrite", "depthTest", "blendSrc", "blendDst", "blendAlphaSrc", "blendAlphaDst", "blendOp", "blendAlphaOp", "wireframe", "colorMask", "stencil", "reserved")
    _hx_fields = ["name", "flags", "passId", "bits", "parentPass", "parentShaders", "shaders", "nextPass", "enableLights", "dynamicParameters", "isStatic", "batchMode", "culling", "depthWrite", "depthTest", "blendSrc", "blendDst", "blendAlphaSrc", "blendAlphaDst", "blendOp", "blendAlphaOp", "wireframe", "colorMask", "stencil", "reserved"]
    _hx_methods = ["load", "setPassName", "blend", "setBlendMode", "depth", "setColorMask", "setColorChannel", "addShader", "addShaderAtIndex", "getShaderIndex", "removeShader", "getShader", "getShaderByName", "getShaders", "getShadersRec", "clone", "getDebugShaderCode", "set_enableLights", "set_dynamicParameters", "set_isStatic", "set_batchMode", "set_culling", "set_depthWrite", "set_depthTest", "set_blendSrc", "set_blendDst", "set_blendAlphaSrc", "set_blendAlphaDst", "set_blendOp", "set_blendAlphaOp", "set_wireframe", "set_reserved", "loadFlags", "loadBits"]
    _hx_statics = ["getEnableLights", "enableLights_bits", "enableLights_offset", "enableLights_mask", "getDynamicParameters", "dynamicParameters_bits", "dynamicParameters_offset", "dynamicParameters_mask", "getIsStatic", "isStatic_bits", "isStatic_offset", "isStatic_mask", "getBatchMode", "batchMode_bits", "batchMode_offset", "batchMode_mask", "getCulling", "culling_bits", "culling_offset", "culling_mask", "getDepthWrite", "depthWrite_bits", "depthWrite_offset", "depthWrite_mask", "getDepthTest", "depthTest_bits", "depthTest_offset", "depthTest_mask", "getBlendSrc", "blendSrc_bits", "blendSrc_offset", "blendSrc_mask", "getBlendDst", "blendDst_bits", "blendDst_offset", "blendDst_mask", "getBlendAlphaSrc", "blendAlphaSrc_bits", "blendAlphaSrc_offset", "blendAlphaSrc_mask", "getBlendAlphaDst", "blendAlphaDst_bits", "blendAlphaDst_offset", "blendAlphaDst_mask", "getBlendOp", "blendOp_bits", "blendOp_offset", "blendOp_mask", "getBlendAlphaOp", "blendAlphaOp_bits", "blendAlphaOp_offset", "blendAlphaOp_mask", "getWireframe", "wireframe_bits", "wireframe_offset", "wireframe_mask", "getReserved", "reserved_bits", "reserved_offset", "reserved_mask"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,name,shaders = None,parent = None):
        self.reserved = None
        self.stencil = None
        self.colorMask = None
        self.wireframe = None
        self.blendAlphaOp = None
        self.blendOp = None
        self.blendAlphaDst = None
        self.blendAlphaSrc = None
        self.blendDst = None
        self.blendSrc = None
        self.depthTest = None
        self.depthWrite = None
        self.culling = None
        self.batchMode = None
        self.isStatic = None
        self.dynamicParameters = None
        self.enableLights = None
        self.nextPass = None
        self.parentShaders = None
        self.passId = None
        self.flags = None
        self.name = None
        self.bits = 0
        self.parentPass = parent
        self.shaders = shaders
        self.setPassName(name)
        self.set_culling(h3d_mat_Face.Back)
        src = h3d_mat_Blend.One
        dst = h3d_mat_Blend.Zero
        self.set_blendSrc(src)
        self.set_blendAlphaSrc(src)
        self.set_blendDst(dst)
        self.set_blendAlphaDst(dst)
        self.depth(True,h3d_mat_Compare.Less)
        self.set_blendOp(self.set_blendAlphaOp(h3d_mat_Operation.Add))
        self.colorMask = 15

    def load(self,p):
        self.name = p.name
        self.passId = p.passId
        self.bits = p.bits
        self.set_enableLights(p.enableLights)
        self.set_dynamicParameters(p.dynamicParameters)
        self.set_culling(p.culling)
        self.set_depthWrite(p.depthWrite)
        self.set_depthTest(p.depthTest)
        self.set_blendSrc(p.blendSrc)
        self.set_blendDst(p.blendDst)
        self.set_blendOp(p.blendOp)
        self.set_blendAlphaSrc(p.blendAlphaSrc)
        self.set_blendAlphaDst(p.blendAlphaDst)
        self.set_blendAlphaOp(p.blendAlphaOp)
        self.colorMask = p.colorMask
        if (p.stencil is not None):
            if (self.stencil is None):
                self.stencil = h3d_mat_Stencil()
            self.stencil.load(p.stencil)

    def setPassName(self,name):
        self.name = name
        self.passId = hxsl_Globals.allocID(name)

    def blend(self,src,dst):
        self.set_blendSrc(src)
        self.set_blendAlphaSrc(src)
        self.set_blendDst(dst)
        self.set_blendAlphaDst(dst)

    def setBlendMode(self,b):
        tmp = b.index
        if (tmp == 0):
            src = h3d_mat_Blend.One
            dst = h3d_mat_Blend.Zero
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 1):
            src = h3d_mat_Blend.SrcAlpha
            dst = h3d_mat_Blend.OneMinusSrcAlpha
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 2):
            src = h3d_mat_Blend.SrcAlpha
            dst = h3d_mat_Blend.One
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 3):
            src = h3d_mat_Blend.One
            dst = h3d_mat_Blend.OneMinusSrcAlpha
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 4):
            src = h3d_mat_Blend.OneMinusDstColor
            dst = h3d_mat_Blend.One
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 5):
            src = h3d_mat_Blend.DstColor
            dst = h3d_mat_Blend.Zero
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 6):
            src = h3d_mat_Blend.DstColor
            dst = h3d_mat_Blend.OneMinusSrcAlpha
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 7):
            src = h3d_mat_Blend.Zero
            dst = h3d_mat_Blend.OneMinusSrcColor
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 8):
            src = h3d_mat_Blend.One
            dst = h3d_mat_Blend.OneMinusSrcColor
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 9):
            src = h3d_mat_Blend.SrcAlpha
            dst = h3d_mat_Blend.One
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.ReverseSub)
            self.set_blendAlphaOp(h3d_mat_Operation.ReverseSub)
        elif (tmp == 10):
            self.set_blendSrc(h3d_mat_Blend.Zero)
            self.set_blendAlphaSrc(h3d_mat_Blend.Zero)
            self.set_blendDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaSrc(h3d_mat_Blend.Zero)
            self.set_blendAlphaDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaOp(h3d_mat_Operation.Max)
            self.set_blendOp(h3d_mat_Operation.Max)
        elif (tmp == 11):
            self.set_blendSrc(h3d_mat_Blend.Zero)
            self.set_blendAlphaSrc(h3d_mat_Blend.Zero)
            self.set_blendDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaSrc(h3d_mat_Blend.Zero)
            self.set_blendAlphaDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaOp(h3d_mat_Operation.Min)
            self.set_blendOp(h3d_mat_Operation.Min)
        else:
            pass

    def depth(self,write,test):
        self.set_depthWrite(write)
        self.set_depthTest(test)

    def setColorMask(self,r,g,b,a):
        self.colorMask = (((((1 if r else 0)) | ((2 if g else 0))) | ((4 if b else 0))) | ((8 if a else 0)))

    def setColorChannel(self,c):
        tmp = c.index
        if (tmp == 1):
            self.setColorMask(True,False,False,False)
        elif (tmp == 2):
            self.setColorMask(False,True,False,False)
        elif (tmp == 3):
            self.setColorMask(False,False,True,False)
        elif (tmp == 4):
            self.setColorMask(False,False,False,True)
        else:
            raise haxe_Exception.thrown(("Unsupported channel " + Std.string(c)))

    def addShader(self,s):
        if (s is None):
            return None
        self.shaders = hxsl_ShaderList.addSort(s,self.shaders)
        return s

    def addShaderAtIndex(self,s,index):
        prev = None
        cur = self.shaders
        while ((index > 0) and ((cur != self.parentShaders))):
            prev = cur
            cur = cur.next
            index = (index - 1)
        if (prev is None):
            self.shaders = hxsl_ShaderList(s,cur)
        else:
            prev.next = hxsl_ShaderList(s,cur)
        return s

    def getShaderIndex(self,s):
        index = 0
        cur = self.shaders
        while (cur != self.parentShaders):
            if (cur.s == s):
                return index
            cur = cur.next
            index = (index + 1)
        return -1

    def removeShader(self,s):
        sl = self.shaders
        prev = None
        while (sl is not None):
            if (sl.s == s):
                if (prev is None):
                    self.shaders = sl.next
                else:
                    prev.next = sl.next
                return True
            prev = sl
            sl = sl.next
        return False

    def getShader(self,t):
        s = self.shaders
        while (s != self.parentShaders):
            sh = Std.downcast(s.s,t)
            if (sh is not None):
                return sh
            s = s.next
        return None

    def getShaderByName(self,name):
        s = self.shaders
        while (s != self.parentShaders):
            if (s.s.shader.data.name == name):
                return s.s
            s = s.next
        return None

    def getShaders(self):
        return hxsl__ShaderList_ShaderIterator(self.shaders,self.parentShaders)

    def getShadersRec(self):
        if ((self.parentPass is None) or ((self.parentShaders == self.parentPass.shaders))):
            return self.shaders
        s = self.shaders
        prev = None
        while ((s is not None) and ((s != self.parentShaders))):
            prev = s
            s = s.next
        self.parentShaders = self.parentPass.shaders
        if (prev is None):
            self.shaders = self.parentShaders
        else:
            prev.next = self.parentShaders
        return self.shaders

    def clone(self):
        p = h3d_mat_Pass(self.name,self.shaders.clone())
        p.bits = self.bits
        p.set_enableLights(self.enableLights)
        if (self.stencil is not None):
            p.stencil = self.stencil.clone()
        return p

    def getDebugShaderCode(self,scene,toHxsl = None):
        if (toHxsl is None):
            toHxsl = True
        shader = scene.renderer.debugCompileShader(self)
        if toHxsl:
            varId = True
            def _hx_local_0(s):
                return hxsl_Printer.shaderToString(s,varId)
            toString = _hx_local_0
            return ((("// vertex:\n" + HxOverrides.stringOrNull(toString(shader.vertex.data))) + "\n\nfragment:\n") + HxOverrides.stringOrNull(toString(shader.fragment.data)))
        else:
            return h3d_Engine.CURRENT.driver.getNativeShaderCode(shader)

    def set_enableLights(self,v):
        self.flags = ((self.flags & -2) | ((1 if v else 0)))
        def _hx_local_1():
            def _hx_local_0():
                self.enableLights = v
                return self.enableLights
            return _hx_local_0()
        return _hx_local_1()

    def set_dynamicParameters(self,v):
        self.flags = ((self.flags & -3) | ((((1 if v else 0)) << 1)))
        def _hx_local_1():
            def _hx_local_0():
                self.dynamicParameters = v
                return self.dynamicParameters
            return _hx_local_0()
        return _hx_local_1()

    def set_isStatic(self,v):
        self.flags = ((self.flags & -5) | ((((1 if v else 0)) << 2)))
        def _hx_local_1():
            def _hx_local_0():
                self.isStatic = v
                return self.isStatic
            return _hx_local_0()
        return _hx_local_1()

    def set_batchMode(self,v):
        self.flags = ((self.flags & -9) | ((((1 if v else 0)) << 3)))
        def _hx_local_1():
            def _hx_local_0():
                self.batchMode = v
                return self.batchMode
            return _hx_local_0()
        return _hx_local_1()

    def set_culling(self,v):
        self.bits = ((self.bits & -4) | v.index)
        def _hx_local_1():
            def _hx_local_0():
                self.culling = v
                return self.culling
            return _hx_local_0()
        return _hx_local_1()

    def set_depthWrite(self,v):
        self.bits = ((self.bits & -5) | ((((1 if v else 0)) << 2)))
        def _hx_local_1():
            def _hx_local_0():
                self.depthWrite = v
                return self.depthWrite
            return _hx_local_0()
        return _hx_local_1()

    def set_depthTest(self,v):
        self.bits = ((self.bits & -57) | ((v.index << 3)))
        def _hx_local_1():
            def _hx_local_0():
                self.depthTest = v
                return self.depthTest
            return _hx_local_0()
        return _hx_local_1()

    def set_blendSrc(self,v):
        self.bits = ((self.bits & -961) | ((v.index << 6)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendSrc = v
                return self.blendSrc
            return _hx_local_0()
        return _hx_local_1()

    def set_blendDst(self,v):
        self.bits = ((self.bits & -15361) | ((v.index << 10)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendDst = v
                return self.blendDst
            return _hx_local_0()
        return _hx_local_1()

    def set_blendAlphaSrc(self,v):
        self.bits = ((self.bits & -245761) | ((v.index << 14)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendAlphaSrc = v
                return self.blendAlphaSrc
            return _hx_local_0()
        return _hx_local_1()

    def set_blendAlphaDst(self,v):
        self.bits = ((self.bits & -3932161) | ((v.index << 18)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendAlphaDst = v
                return self.blendAlphaDst
            return _hx_local_0()
        return _hx_local_1()

    def set_blendOp(self,v):
        self.bits = ((self.bits & -29360129) | ((v.index << 22)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendOp = v
                return self.blendOp
            return _hx_local_0()
        return _hx_local_1()

    def set_blendAlphaOp(self,v):
        self.bits = ((self.bits & -234881025) | ((v.index << 25)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendAlphaOp = v
                return self.blendAlphaOp
            return _hx_local_0()
        return _hx_local_1()

    def set_wireframe(self,v):
        self.bits = ((self.bits & -268435457) | ((((1 if v else 0)) << 28)))
        def _hx_local_1():
            def _hx_local_0():
                self.wireframe = v
                return self.wireframe
            return _hx_local_0()
        return _hx_local_1()

    def set_reserved(self,v):
        self.bits = ((self.bits & -536870913) | ((((1 if v else 0)) << 29)))
        def _hx_local_1():
            def _hx_local_0():
                self.reserved = v
                return self.reserved
            return _hx_local_0()
        return _hx_local_1()

    def loadFlags(self,bits):
        self.flags = bits
        self.set_enableLights((((self.flags & 1)) != 0))
        self.set_dynamicParameters(((((self.flags >> 1) & 1)) != 0))
        self.set_isStatic(((((self.flags >> 2) & 1)) != 0))
        self.set_batchMode(((((self.flags >> 3) & 1)) != 0))

    def loadBits(self,bits):
        self.bits = bits
        self.set_culling(Type.createEnumIndex(h3d_mat_Face,(self.bits & 3)))
        self.set_depthWrite(((((self.bits >> 2) & 1)) != 0))
        self.set_depthTest(Type.createEnumIndex(h3d_mat_Compare,((self.bits >> 3) & 7)))
        self.set_blendSrc(Type.createEnumIndex(h3d_mat_Blend,((self.bits >> 6) & 15)))
        self.set_blendDst(Type.createEnumIndex(h3d_mat_Blend,((self.bits >> 10) & 15)))
        self.set_blendAlphaSrc(Type.createEnumIndex(h3d_mat_Blend,((self.bits >> 14) & 15)))
        self.set_blendAlphaDst(Type.createEnumIndex(h3d_mat_Blend,((self.bits >> 18) & 15)))
        self.set_blendOp(Type.createEnumIndex(h3d_mat_Operation,((self.bits >> 22) & 7)))
        self.set_blendAlphaOp(Type.createEnumIndex(h3d_mat_Operation,((self.bits >> 25) & 7)))
        self.set_wireframe(((((self.bits >> 28) & 1)) != 0))
        self.set_reserved(((((self.bits >> 29) & 1)) != 0))

    @staticmethod
    def getEnableLights(v):
        return (v & 1)

    @staticmethod
    def getDynamicParameters(v):
        return ((v >> 1) & 1)

    @staticmethod
    def getIsStatic(v):
        return ((v >> 2) & 1)

    @staticmethod
    def getBatchMode(v):
        return ((v >> 3) & 1)

    @staticmethod
    def getCulling(v):
        return (v & 3)

    @staticmethod
    def getDepthWrite(v):
        return ((v >> 2) & 1)

    @staticmethod
    def getDepthTest(v):
        return ((v >> 3) & 7)

    @staticmethod
    def getBlendSrc(v):
        return ((v >> 6) & 15)

    @staticmethod
    def getBlendDst(v):
        return ((v >> 10) & 15)

    @staticmethod
    def getBlendAlphaSrc(v):
        return ((v >> 14) & 15)

    @staticmethod
    def getBlendAlphaDst(v):
        return ((v >> 18) & 15)

    @staticmethod
    def getBlendOp(v):
        return ((v >> 22) & 7)

    @staticmethod
    def getBlendAlphaOp(v):
        return ((v >> 25) & 7)

    @staticmethod
    def getWireframe(v):
        return ((v >> 28) & 1)

    @staticmethod
    def getReserved(v):
        return ((v >> 29) & 1)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.flags = None
        _hx_o.passId = None
        _hx_o.bits = None
        _hx_o.parentPass = None
        _hx_o.parentShaders = None
        _hx_o.shaders = None
        _hx_o.nextPass = None
        _hx_o.enableLights = None
        _hx_o.dynamicParameters = None
        _hx_o.isStatic = None
        _hx_o.batchMode = None
        _hx_o.culling = None
        _hx_o.depthWrite = None
        _hx_o.depthTest = None
        _hx_o.blendSrc = None
        _hx_o.blendDst = None
        _hx_o.blendAlphaSrc = None
        _hx_o.blendAlphaDst = None
        _hx_o.blendOp = None
        _hx_o.blendAlphaOp = None
        _hx_o.wireframe = None
        _hx_o.colorMask = None
        _hx_o.stencil = None
        _hx_o.reserved = None
h3d_mat_Pass._hx_class = h3d_mat_Pass
_hx_classes["h3d.mat.Pass"] = h3d_mat_Pass


class h3d_mat_Stencil:
    _hx_class_name = "h3d.mat.Stencil"
    _hx_is_interface = "False"
    __slots__ = ("maskBits", "opBits", "readMask", "writeMask", "reference", "frontTest", "frontPass", "frontSTfail", "frontDPfail", "backTest", "backPass", "backSTfail", "backDPfail")
    _hx_fields = ["maskBits", "opBits", "readMask", "writeMask", "reference", "frontTest", "frontPass", "frontSTfail", "frontDPfail", "backTest", "backPass", "backSTfail", "backDPfail"]
    _hx_methods = ["setFront", "setBack", "setOp", "setFunc", "clone", "load", "set_readMask", "set_writeMask", "set_reference", "set_frontTest", "set_frontPass", "set_frontSTfail", "set_frontDPfail", "set_backTest", "set_backPass", "set_backSTfail", "set_backDPfail", "loadOpBits", "loadMaskBits"]
    _hx_statics = ["getReadMask", "readMask_bits", "readMask_offset", "readMask_mask", "getWriteMask", "writeMask_bits", "writeMask_offset", "writeMask_mask", "getReference", "reference_bits", "reference_offset", "reference_mask", "getFrontTest", "frontTest_bits", "frontTest_offset", "frontTest_mask", "getFrontPass", "frontPass_bits", "frontPass_offset", "frontPass_mask", "getFrontSTfail", "frontSTfail_bits", "frontSTfail_offset", "frontSTfail_mask", "getFrontDPfail", "frontDPfail_bits", "frontDPfail_offset", "frontDPfail_mask", "getBackTest", "backTest_bits", "backTest_offset", "backTest_mask", "getBackPass", "backPass_bits", "backPass_offset", "backPass_mask", "getBackSTfail", "backSTfail_bits", "backSTfail_offset", "backSTfail_mask", "getBackDPfail", "backDPfail_bits", "backDPfail_offset", "backDPfail_mask"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self):
        self.backDPfail = None
        self.backSTfail = None
        self.backPass = None
        self.backTest = None
        self.frontDPfail = None
        self.frontSTfail = None
        self.frontPass = None
        self.frontTest = None
        self.reference = None
        self.writeMask = None
        self.readMask = None
        self.opBits = 0
        self.maskBits = 0
        self.setOp(h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep)
        self.setFunc(h3d_mat_Compare.Always)

    def setFront(self,stfail,dpfail,_hx_pass):
        self.set_frontSTfail(stfail)
        self.set_frontDPfail(dpfail)
        self.set_frontPass(_hx_pass)

    def setBack(self,stfail,dpfail,_hx_pass):
        self.set_backSTfail(stfail)
        self.set_backDPfail(dpfail)
        self.set_backPass(_hx_pass)

    def setOp(self,stfail,dpfail,_hx_pass):
        self.setFront(stfail,dpfail,_hx_pass)
        self.setBack(stfail,dpfail,_hx_pass)

    def setFunc(self,f,reference = None,readMask = None,writeMask = None):
        if (reference is None):
            reference = 0
        if (readMask is None):
            readMask = 255
        if (writeMask is None):
            writeMask = 255
        self.set_frontTest(self.set_backTest(f))
        self.set_reference(reference)
        self.set_readMask(readMask)
        self.set_writeMask(writeMask)

    def clone(self):
        s = h3d_mat_Stencil()
        s.opBits = self.opBits
        s.maskBits = self.maskBits
        return s

    def load(self,s):
        self.opBits = s.opBits
        self.maskBits = s.maskBits

    def set_readMask(self,v):
        self.maskBits = ((self.maskBits & -256) | ((v & 255)))
        def _hx_local_1():
            def _hx_local_0():
                self.readMask = v
                return self.readMask
            return _hx_local_0()
        return _hx_local_1()

    def set_writeMask(self,v):
        self.maskBits = ((self.maskBits & -65281) | ((((v & 255)) << 8)))
        def _hx_local_1():
            def _hx_local_0():
                self.writeMask = v
                return self.writeMask
            return _hx_local_0()
        return _hx_local_1()

    def set_reference(self,v):
        self.maskBits = ((self.maskBits & -16711681) | ((((v & 255)) << 16)))
        def _hx_local_1():
            def _hx_local_0():
                self.reference = v
                return self.reference
            return _hx_local_0()
        return _hx_local_1()

    def set_frontTest(self,v):
        self.opBits = ((self.opBits & -8) | v.index)
        def _hx_local_1():
            def _hx_local_0():
                self.frontTest = v
                return self.frontTest
            return _hx_local_0()
        return _hx_local_1()

    def set_frontPass(self,v):
        self.opBits = ((self.opBits & -57) | ((v.index << 3)))
        def _hx_local_1():
            def _hx_local_0():
                self.frontPass = v
                return self.frontPass
            return _hx_local_0()
        return _hx_local_1()

    def set_frontSTfail(self,v):
        self.opBits = ((self.opBits & -449) | ((v.index << 6)))
        def _hx_local_1():
            def _hx_local_0():
                self.frontSTfail = v
                return self.frontSTfail
            return _hx_local_0()
        return _hx_local_1()

    def set_frontDPfail(self,v):
        self.opBits = ((self.opBits & -3585) | ((v.index << 9)))
        def _hx_local_1():
            def _hx_local_0():
                self.frontDPfail = v
                return self.frontDPfail
            return _hx_local_0()
        return _hx_local_1()

    def set_backTest(self,v):
        self.opBits = ((self.opBits & -28673) | ((v.index << 12)))
        def _hx_local_1():
            def _hx_local_0():
                self.backTest = v
                return self.backTest
            return _hx_local_0()
        return _hx_local_1()

    def set_backPass(self,v):
        self.opBits = ((self.opBits & -229377) | ((v.index << 15)))
        def _hx_local_1():
            def _hx_local_0():
                self.backPass = v
                return self.backPass
            return _hx_local_0()
        return _hx_local_1()

    def set_backSTfail(self,v):
        self.opBits = ((self.opBits & -1835009) | ((v.index << 18)))
        def _hx_local_1():
            def _hx_local_0():
                self.backSTfail = v
                return self.backSTfail
            return _hx_local_0()
        return _hx_local_1()

    def set_backDPfail(self,v):
        self.opBits = ((self.opBits & -14680065) | ((v.index << 21)))
        def _hx_local_1():
            def _hx_local_0():
                self.backDPfail = v
                return self.backDPfail
            return _hx_local_0()
        return _hx_local_1()

    def loadOpBits(self,bits):
        self.opBits = bits
        self.set_frontTest(Type.createEnumIndex(h3d_mat_Compare,(self.opBits & 7)))
        self.set_frontPass(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 3) & 7)))
        self.set_frontSTfail(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 6) & 7)))
        self.set_frontDPfail(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 9) & 7)))
        self.set_backTest(Type.createEnumIndex(h3d_mat_Compare,((self.opBits >> 12) & 7)))
        self.set_backPass(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 15) & 7)))
        self.set_backSTfail(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 18) & 7)))
        self.set_backDPfail(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 21) & 7)))

    def loadMaskBits(self,bits):
        self.maskBits = bits
        self.set_readMask((self.maskBits & 255))
        self.set_writeMask(((self.maskBits >> 8) & 255))
        self.set_reference(((self.maskBits >> 16) & 255))

    @staticmethod
    def getReadMask(v):
        return (v & 255)

    @staticmethod
    def getWriteMask(v):
        return ((v >> 8) & 255)

    @staticmethod
    def getReference(v):
        return ((v >> 16) & 255)

    @staticmethod
    def getFrontTest(v):
        return (v & 7)

    @staticmethod
    def getFrontPass(v):
        return ((v >> 3) & 7)

    @staticmethod
    def getFrontSTfail(v):
        return ((v >> 6) & 7)

    @staticmethod
    def getFrontDPfail(v):
        return ((v >> 9) & 7)

    @staticmethod
    def getBackTest(v):
        return ((v >> 12) & 7)

    @staticmethod
    def getBackPass(v):
        return ((v >> 15) & 7)

    @staticmethod
    def getBackSTfail(v):
        return ((v >> 18) & 7)

    @staticmethod
    def getBackDPfail(v):
        return ((v >> 21) & 7)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.maskBits = None
        _hx_o.opBits = None
        _hx_o.readMask = None
        _hx_o.writeMask = None
        _hx_o.reference = None
        _hx_o.frontTest = None
        _hx_o.frontPass = None
        _hx_o.frontSTfail = None
        _hx_o.frontDPfail = None
        _hx_o.backTest = None
        _hx_o.backPass = None
        _hx_o.backSTfail = None
        _hx_o.backDPfail = None
h3d_mat_Stencil._hx_class = h3d_mat_Stencil
_hx_classes["h3d.mat.Stencil"] = h3d_mat_Stencil

class hxd_PixelFormat(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.PixelFormat"
    _hx_constructs = ["ARGB", "BGRA", "RGBA", "RGBA16F", "RGBA32F", "R8", "R16F", "R32F", "RG8", "RG16F", "RG32F", "RGB8", "RGB16F", "RGB32F", "SRGB", "SRGB_ALPHA", "RGB10A2", "RG11B10UF", "R16U", "RGB16U", "RGBA16U", "S3TC"]

    @staticmethod
    def S3TC(v):
        return hxd_PixelFormat("S3TC", 21, (v,))
hxd_PixelFormat.ARGB = hxd_PixelFormat("ARGB", 0, ())
hxd_PixelFormat.BGRA = hxd_PixelFormat("BGRA", 1, ())
hxd_PixelFormat.RGBA = hxd_PixelFormat("RGBA", 2, ())
hxd_PixelFormat.RGBA16F = hxd_PixelFormat("RGBA16F", 3, ())
hxd_PixelFormat.RGBA32F = hxd_PixelFormat("RGBA32F", 4, ())
hxd_PixelFormat.R8 = hxd_PixelFormat("R8", 5, ())
hxd_PixelFormat.R16F = hxd_PixelFormat("R16F", 6, ())
hxd_PixelFormat.R32F = hxd_PixelFormat("R32F", 7, ())
hxd_PixelFormat.RG8 = hxd_PixelFormat("RG8", 8, ())
hxd_PixelFormat.RG16F = hxd_PixelFormat("RG16F", 9, ())
hxd_PixelFormat.RG32F = hxd_PixelFormat("RG32F", 10, ())
hxd_PixelFormat.RGB8 = hxd_PixelFormat("RGB8", 11, ())
hxd_PixelFormat.RGB16F = hxd_PixelFormat("RGB16F", 12, ())
hxd_PixelFormat.RGB32F = hxd_PixelFormat("RGB32F", 13, ())
hxd_PixelFormat.SRGB = hxd_PixelFormat("SRGB", 14, ())
hxd_PixelFormat.SRGB_ALPHA = hxd_PixelFormat("SRGB_ALPHA", 15, ())
hxd_PixelFormat.RGB10A2 = hxd_PixelFormat("RGB10A2", 16, ())
hxd_PixelFormat.RG11B10UF = hxd_PixelFormat("RG11B10UF", 17, ())
hxd_PixelFormat.R16U = hxd_PixelFormat("R16U", 18, ())
hxd_PixelFormat.RGB16U = hxd_PixelFormat("RGB16U", 19, ())
hxd_PixelFormat.RGBA16U = hxd_PixelFormat("RGBA16U", 20, ())
hxd_PixelFormat._hx_class = hxd_PixelFormat
_hx_classes["hxd.PixelFormat"] = hxd_PixelFormat


class h3d_mat_Texture:
    _hx_class_name = "h3d.mat.Texture"
    _hx_is_interface = "False"
    __slots__ = ("t", "mem", "id", "name", "width", "height", "flags", "format", "bits", "waitLoads", "mipMap", "filter", "wrap", "lodBias", "realloc", "depthBuffer", "_lastFrame")
    _hx_fields = ["t", "mem", "id", "name", "width", "height", "flags", "format", "bits", "waitLoads", "mipMap", "filter", "wrap", "lodBias", "realloc", "depthBuffer", "_lastFrame"]
    _hx_methods = ["set_lastFrame", "get_lastFrame", "get_mipLevels", "get_layerCount", "alloc", "isSRGB", "checkAlloc", "clone", "preventAutoDispose", "waitLoad", "toString", "setName", "set_mipMap", "set_filter", "set_wrap", "isDisposed", "resize", "clearF", "clear", "checkSize", "checkMipMapGen", "uploadBitmap", "uploadPixels", "dispose", "swapTexture", "capturePixels"]
    _hx_statics = ["UID", "PREVENT_AUTO_DISPOSE", "nativeFormat", "fromBitmap", "fromPixels", "fromColor", "genDisc", "genTexture", "drawGenTexture", "defaultCubeTexture", "genChecker", "checkerTextureKeys", "noiseTextureKeys", "genTextureKeys", "genNoise", "allocNoise", "allocChecker"]

    def __init__(self,w,h,flags = None,format = None):
        self._lastFrame = None
        self.depthBuffer = None
        self.realloc = None
        self.wrap = None
        self.filter = None
        self.mipMap = None
        self.waitLoads = None
        self.bits = None
        self.height = None
        self.width = None
        self.name = None
        self.t = None
        self.lodBias = 0.
        engine = h3d_Engine.CURRENT
        self.mem = engine.mem
        if (format is None):
            format = h3d_mat_Texture.nativeFormat
        def _hx_local_2():
            _hx_local_0 = h3d_mat_Texture
            _hx_local_1 = _hx_local_0.UID
            _hx_local_0.UID = (_hx_local_1 + 1)
            return _hx_local_0.UID
        self.id = _hx_local_2()
        self.format = format
        this1 = 0
        self.flags = this1
        if (flags is not None):
            _g = 0
            while (_g < len(flags)):
                f = (flags[_g] if _g >= 0 and _g < len(flags) else None)
                _g = (_g + 1)
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.flags
                _hx_local_4.flags = (_hx_local_5 | ((1 << f.index)))
                _hx_local_4.flags
        tw = 1
        th = 1
        while (tw < w):
            tw = (tw << 1)
        while (th < h):
            th = (th << 1)
        if ((tw != w) or ((th != h))):
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | ((1 << h3d_mat_TextureFlags.IsNPOT.index)))
            _hx_local_8.flags
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Target.index)))) != 0):
            def _hx_local_10():
                pass
            self.realloc = _hx_local_10
        self.width = w
        self.height = h
        self.set_mipMap((h3d_mat_MipMap.Nearest if ((((self.flags & ((1 << h3d_mat_TextureFlags.MipMapped.index)))) != 0)) else h3d_mat_MipMap._hx_None))
        self.set_filter(h3d_mat_Filter.Linear)
        self.set_wrap(h3d_mat_Wrap.Clamp)
        _hx_local_11 = self
        _hx_local_12 = _hx_local_11.bits
        _hx_local_11.bits = (_hx_local_12 & 32767)
        _hx_local_11.bits
        if (((self.flags & ((1 << h3d_mat_TextureFlags.NoAlloc.index)))) == 0):
            self.alloc()

    def set_lastFrame(self,lf):
        if (self._lastFrame != h3d_mat_Texture.PREVENT_AUTO_DISPOSE):
            self._lastFrame = lf
        return self._lastFrame

    def get_lastFrame(self):
        return self._lastFrame

    def get_mipLevels(self):
        if (((self.flags & ((1 << h3d_mat_TextureFlags.MipMapped.index)))) == 0):
            return 1
        lv = 1
        w = self.width
        h = self.height
        while (((w >> lv) >= 1) or (((h >> lv) >= 1))):
            lv = (lv + 1)
        return lv

    def get_layerCount(self):
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0):
            return 6
        else:
            return 1

    def alloc(self):
        if (self.t is None):
            self.mem.allocTexture(self)

    def isSRGB(self):
        tmp = self.format.index
        if ((tmp == 15) or ((tmp == 14))):
            return True
        else:
            return False

    def checkAlloc(self):
        if ((self.t is None) and ((self.realloc is not None))):
            self.alloc()
            self.realloc()

    def clone(self):
        self.checkAlloc()
        if (self.t is None):
            raise haxe_Exception.thrown("Can't clone disposed texture")
        old = self.get_lastFrame()
        self.preventAutoDispose()
        flags = []
        f = h3d_mat_TextureFlags.Target
        if (((self.flags & ((1 << f.index)))) != 0):
            flags.append(f)
        f = h3d_mat_TextureFlags.Cube
        if (((self.flags & ((1 << f.index)))) != 0):
            flags.append(f)
        f = h3d_mat_TextureFlags.MipMapped
        if (((self.flags & ((1 << f.index)))) != 0):
            flags.append(f)
        f = h3d_mat_TextureFlags.IsArray
        if (((self.flags & ((1 << f.index)))) != 0):
            flags.append(f)
        t = h3d_mat_Texture(self.width,self.height,flags,self.format)
        t.name = self.name
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0):
            h3d_pass_CubeCopy.run(self,t)
        else:
            h3d_pass_Copy.run(self,t)
        self.set_lastFrame(old)
        return t

    def preventAutoDispose(self):
        self.set_lastFrame(h3d_mat_Texture.PREVENT_AUTO_DISPOSE)

    def waitLoad(self,f):
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Loading.index)))) == 0):
            f()
            return
        if (self.waitLoads is None):
            self.waitLoads = []
        _this = self.waitLoads
        _this.append(f)

    def toString(self):
        _hx_str = self.name
        if (self.name is None):
            _hx_str = ("Texture_" + Std.string(self.id))
        return (((((("null" if _hx_str is None else _hx_str) + "(") + Std.string(self.width)) + "x") + Std.string(self.height)) + ")")

    def setName(self,n):
        self.name = n

    def set_mipMap(self,m):
        self.bits = ((self.bits & -4) | m.index)
        def _hx_local_1():
            def _hx_local_0():
                self.mipMap = m
                return self.mipMap
            return _hx_local_0()
        return _hx_local_1()

    def set_filter(self,f):
        self.bits = ((self.bits & -25) | ((f.index << 3)))
        def _hx_local_1():
            def _hx_local_0():
                self.filter = f
                return self.filter
            return _hx_local_0()
        return _hx_local_1()

    def set_wrap(self,w):
        self.bits = ((self.bits & -193) | ((w.index << 6)))
        def _hx_local_1():
            def _hx_local_0():
                self.wrap = w
                return self.wrap
            return _hx_local_0()
        return _hx_local_1()

    def isDisposed(self):
        if (self.t is None):
            return (self.realloc is None)
        else:
            return False

    def resize(self,width,height):
        self.dispose()
        tw = 1
        th = 1
        while (tw < width):
            tw = (tw << 1)
        while (th < height):
            th = (th << 1)
        if ((tw != width) or ((th != height))):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 | ((1 << h3d_mat_TextureFlags.IsNPOT.index)))
            _hx_local_2.flags
        else:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 & ((-1 - ((1 << h3d_mat_TextureFlags.IsNPOT.index)))))
            _hx_local_4.flags
        self.width = width
        self.height = height
        if (((self.flags & ((1 << h3d_mat_TextureFlags.NoAlloc.index)))) == 0):
            self.alloc()

    def clearF(self,r = None,g = None,b = None,a = None,layer = None):
        if (r is None):
            r = 0.
        if (g is None):
            g = 0.
        if (b is None):
            b = 0.
        if (a is None):
            a = 0.
        if (layer is None):
            layer = -1
        self.alloc()
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Target.index)))) == 0):
            raise haxe_Exception.thrown("Texture should be target")
        engine = h3d_Engine.CURRENT
        color = h3d_Vector(r,g,b,a)
        if (layer < 0):
            _g = 0
            _g1 = self.get_layerCount()
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                engine.pushTarget(self,i)
                engine.clearF(color)
                engine.popTarget()
        else:
            engine.pushTarget(self,layer)
            engine.clearF(color)
            engine.popTarget()

    def clear(self,color,alpha = None,layer = None):
        if (alpha is None):
            alpha = 1.
        if (layer is None):
            layer = -1
        self.alloc()
        if ((self.width == 0) or ((self.height == 0))):
            return
        if ((((self.flags & ((1 << h3d_mat_TextureFlags.Target.index)))) != 0) and (((self.width != 1) or ((self.height != 1))))):
            engine = h3d_Engine.CURRENT
            color1 = None
            try:
                color1 = int((((0. if ((alpha < 0.)) else (1. if ((alpha > 1.)) else alpha))) * 255))
            except BaseException as _g:
                None
                color1 = None
            color = (color | ((color1 << 24)))
            if (layer < 0):
                _g = 0
                _g1 = self.get_layerCount()
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    engine.pushTarget(self,i)
                    engine.clear(color)
                    engine.popTarget()
            else:
                engine.pushTarget(self,layer)
                engine.clear(color)
                engine.popTarget()
        else:
            p = hxd_Pixels.alloc(self.width,self.height,h3d_mat_Texture.nativeFormat)
            k = 0
            b = (color & 255)
            g = ((color >> 8) & 255)
            r = ((color >> 16) & 255)
            a = None
            try:
                a = int((alpha * 255))
            except BaseException as _g:
                None
                a = None
            a1 = a
            if (a1 < 0):
                a1 = 0
            elif (a1 > 255):
                a1 = 255
            tmp = h3d_mat_Texture.nativeFormat.index
            if (tmp == 1):
                tmp = r
                r = b
                b = tmp
            elif (tmp == 2):
                pass
            else:
                raise haxe_Exception.thrown("TODO")
            _g = 0
            _g1 = (self.width * self.height)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                pos = k
                k = (k + 1)
                p.bytes.b[pos] = (r & 255)
                pos1 = k
                k = (k + 1)
                p.bytes.b[pos1] = (g & 255)
                pos2 = k
                k = (k + 1)
                p.bytes.b[pos2] = (b & 255)
                pos3 = k
                k = (k + 1)
                p.bytes.b[pos3] = (a1 & 255)
            if (layer < 0):
                _g = 0
                _g1 = self.get_layerCount()
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    self.uploadPixels(p,0,i)
            else:
                self.uploadPixels(p,0,layer)
            p.dispose()

    def checkSize(self,width,height,mip):
        mw = (self.width >> mip)
        if (mw == 0):
            mw = 1
        mh = (self.height >> mip)
        if (mh == 0):
            mh = 1
        if ((width != mw) or ((height != mh))):
            raise haxe_Exception.thrown(((((((("Invalid upload size : " + Std.string(width)) + "x") + Std.string(height)) + " should be ") + Std.string(mw)) + "x") + Std.string(mh)))

    def checkMipMapGen(self,mipLevel,layer):
        if ((((mipLevel == 0) and ((((self.flags & ((1 << h3d_mat_TextureFlags.MipMapped.index)))) != 0))) and ((((self.flags & ((1 << h3d_mat_TextureFlags.ManualMipMapGen.index)))) == 0))) and ((layer == ((self.get_layerCount() - 1))))):
            self.mem.driver.generateMipMaps(self)

    def uploadBitmap(self,bmp,mipLevel = None,layer = None):
        if (mipLevel is None):
            mipLevel = 0
        if (layer is None):
            layer = 0
        self.alloc()
        self.checkSize(bmp.data.width,bmp.data.height,mipLevel)
        self.mem.driver.uploadTextureBitmap(self,bmp,mipLevel,layer)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 | ((1 << h3d_mat_TextureFlags.WasCleared.index)))
        _hx_local_0.flags
        self.checkMipMapGen(mipLevel,layer)

    def uploadPixels(self,pixels,mipLevel = None,layer = None):
        if (mipLevel is None):
            mipLevel = 0
        if (layer is None):
            layer = 0
        self.alloc()
        self.checkSize(pixels.width,pixels.height,mipLevel)
        self.mem.driver.uploadTexturePixels(self,pixels,mipLevel,layer)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 | ((1 << h3d_mat_TextureFlags.WasCleared.index)))
        _hx_local_0.flags
        self.checkMipMapGen(mipLevel,layer)

    def dispose(self):
        if (self.t is not None):
            self.mem.deleteTexture(self)

    def swapTexture(self,t):
        self.checkAlloc()
        t.checkAlloc()
        if (((self.t is None) and ((self.realloc is None))) or (((t.t is None) and ((t.realloc is None))))):
            raise haxe_Exception.thrown("One of the two texture is disposed")
        tmp = self.t
        self.t = t.t
        t.t = tmp

    def capturePixels(self,face = None,mipLevel = None,region = None):
        if (face is None):
            face = 0
        if (mipLevel is None):
            mipLevel = 0
        old = self.get_lastFrame()
        self.preventAutoDispose()
        pix = self.mem.driver.capturePixels(self,face,mipLevel,region)
        self.set_lastFrame(old)
        return pix

    @staticmethod
    def fromBitmap(bmp):
        t = h3d_mat_Texture(bmp.data.width,bmp.data.height)
        t.uploadBitmap(bmp)
        return t

    @staticmethod
    def fromPixels(pixels):
        t = h3d_mat_Texture(pixels.width,pixels.height)
        t.uploadPixels(pixels)
        return t

    @staticmethod
    def fromColor(color,alpha = None):
        if (alpha is None):
            alpha = 1.
        engine = h3d_Engine.CURRENT
        aval = None
        try:
            aval = int((alpha * 255))
        except BaseException as _g:
            None
            aval = None
        aval1 = aval
        if (aval1 < 0):
            aval1 = 0
        elif (aval1 > 255):
            aval1 = 255
        key = ((color & 16777215) | ((aval1 << 24)))
        t = engine.textureColorCache.h.get(key,None)
        if (t is not None):
            return t
        t = h3d_mat_Texture(1,1,None)
        t.clear(color,alpha)
        def _hx_local_0():
            t.clear(color,alpha)
        t.realloc = _hx_local_0
        engine.textureColorCache.set(key,t)
        return t

    @staticmethod
    def genDisc(size,color,alpha = None):
        if (alpha is None):
            alpha = 1.
        return h3d_mat_Texture.genTexture(0,size,color,alpha)

    @staticmethod
    def genTexture(mode,size,color,alpha):
        engine = h3d_Engine.CURRENT
        aval = None
        try:
            aval = int((alpha * 255))
        except BaseException as _g:
            None
            aval = None
        aval1 = aval
        if (aval1 < 0):
            aval1 = 0
        elif (aval1 > 255):
            aval1 = 255
        color = ((color & 16777215) | ((aval1 << 24)))
        key = ((Std.string((((size << 16) | mode))) + ",") + Std.string(color))
        k = h3d_mat_Texture.genTextureKeys.h.get(key,None)
        t = (None if ((k is None)) else engine.resCache.h.get(k,None))
        if (t is not None):
            return t
        if (k is None):
            k = _hx_AnonObject({})
            h3d_mat_Texture.genTextureKeys.h[key] = k
        t = h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.Target])
        def _hx_local_0():
            h3d_mat_Texture.drawGenTexture(t,color,mode)
        t.realloc = _hx_local_0
        h3d_mat_Texture.drawGenTexture(t,color,mode)
        engine.resCache.set(k,t)
        return t

    @staticmethod
    def drawGenTexture(t,color,mode):
        s = h3d_pass_ScreenFx(h3d_shader_GenTexture())
        engine = h3d_Engine.CURRENT
        _this = s.shader
        _this.constModified = True
        _this.mode__ = mode
        _this = s.shader.color__
        _this.x = ((((color >> 16) & 255)) / 255)
        _this.y = ((((color >> 8) & 255)) / 255)
        _this.z = (((color & 255)) / 255)
        _this.w = ((HxOverrides.rshift(color, 24)) / 255)
        engine.pushTarget(t)
        s.render()
        engine.popTarget()

    @staticmethod
    def defaultCubeTexture():
        engine = h3d_Engine.CURRENT
        t = engine.resCache.h.get(h3d_mat_Texture,None)
        if (t is not None):
            return t
        t = h3d_mat_Texture(1,1,[h3d_mat_TextureFlags.Cube])
        t.clear(2105376)
        def _hx_local_0():
            t.clear(2105376)
        t.realloc = _hx_local_0
        engine.resCache.set(h3d_mat_Texture,t)
        return t

    @staticmethod
    def genChecker(size):
        engine = h3d_Engine.CURRENT
        k = h3d_mat_Texture.checkerTextureKeys.h.get(size,None)
        t = (None if ((k is None)) else engine.resCache.h.get(k,None))
        if ((t is not None) and (not (((t.t is None) and ((t.realloc is None)))))):
            return t
        if (k is None):
            k = _hx_AnonObject({})
            h3d_mat_Texture.checkerTextureKeys.set(size,k)
        t = h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.NoAlloc])
        t1 = t
        size1 = size
        def _hx_local_0():
            h3d_mat_Texture.allocChecker(t1,size1)
        t.realloc = _hx_local_0
        engine.resCache.set(k,t)
        return t

    @staticmethod
    def genNoise(size):
        engine = h3d_Engine.CURRENT
        k = h3d_mat_Texture.noiseTextureKeys.h.get(size,None)
        t = (None if ((k is None)) else engine.resCache.h.get(k,None))
        if ((t is not None) and (not (((t.t is None) and ((t.realloc is None)))))):
            return t
        if (k is None):
            k = _hx_AnonObject({})
            h3d_mat_Texture.noiseTextureKeys.set(size,k)
        t = h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.NoAlloc])
        t1 = t
        size1 = size
        def _hx_local_0():
            h3d_mat_Texture.allocNoise(t1,size1)
        t.realloc = _hx_local_0
        engine.resCache.set(k,t)
        return t

    @staticmethod
    def allocNoise(t,size):
        b = hxd_BitmapData(size,size)
        _g = 0
        _g1 = size
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = size
            while (_g2 < _g3):
                y = _g2
                _g2 = (_g2 + 1)
                n = int((python_lib_Random.random() * 256))
                b.setPixel(x,y,(((-16777216 | n) | ((n << 8))) | ((n << 16))))
        t.uploadBitmap(b)
        b.data = None

    @staticmethod
    def allocChecker(t,size):
        b = hxd_BitmapData(size,size)
        b.clear(-1)
        _g = 0
        _g1 = (size >> 1)
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = (size >> 1)
            while (_g2 < _g3):
                y = _g2
                _g2 = (_g2 + 1)
                b.setPixel(x,y,-16777216)
                b.setPixel((x + ((size >> 1))),(y + ((size >> 1))),-16777216)
        t.uploadBitmap(b)
        b.data = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.t = None
        _hx_o.mem = None
        _hx_o.id = None
        _hx_o.name = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.flags = None
        _hx_o.format = None
        _hx_o.bits = None
        _hx_o.waitLoads = None
        _hx_o.mipMap = None
        _hx_o.filter = None
        _hx_o.wrap = None
        _hx_o.lodBias = None
        _hx_o.realloc = None
        _hx_o.depthBuffer = None
        _hx_o._lastFrame = None
h3d_mat_Texture._hx_class = h3d_mat_Texture
_hx_classes["h3d.mat.Texture"] = h3d_mat_Texture


class h3d_mat_TextureArray(h3d_mat_Texture):
    _hx_class_name = "h3d.mat.TextureArray"
    _hx_is_interface = "False"
    __slots__ = ("layers",)
    _hx_fields = ["layers"]
    _hx_methods = ["get_layerCount", "clone", "toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_mat_Texture


    def __init__(self,w,h,layers,flags = None,format = None):
        self.layers = layers
        if (flags is None):
            flags = []
        flags.append(h3d_mat_TextureFlags.IsArray)
        super().__init__(w,h,flags,format)

    def get_layerCount(self):
        return self.layers

    def clone(self):
        old = self.get_lastFrame()
        self.preventAutoDispose()
        t = h3d_mat_TextureArray(self.width,self.height,self.layers,None,self.format)
        h3d_pass_Copy.run(self,t)
        self.set_lastFrame(old)
        return t

    def toString(self):
        return (((HxOverrides.stringOrNull(super().toString()) + "[") + Std.string(self.layers)) + "]")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.layers = None
h3d_mat_TextureArray._hx_class = h3d_mat_TextureArray
_hx_classes["h3d.mat.TextureArray"] = h3d_mat_TextureArray


class h3d_pass_Base:
    _hx_class_name = "h3d.pass.Base"
    _hx_is_interface = "False"
    __slots__ = ("ctx", "name")
    _hx_fields = ["ctx", "name"]
    _hx_methods = ["compileShader", "setContext", "dispose", "draw"]

    def __init__(self,name):
        self.ctx = None
        self.name = name

    def compileShader(self,p):
        raise haxe_Exception.thrown("Not implemented for this pass")

    def setContext(self,ctx):
        self.ctx = ctx

    def dispose(self):
        pass

    def draw(self,passes,sort = None):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.ctx = None
        _hx_o.name = None
h3d_pass_Base._hx_class = h3d_pass_Base
_hx_classes["h3d.pass.Base"] = h3d_pass_Base


class h3d_pass_ScreenFx:
    _hx_class_name = "h3d.pass.ScreenFx"
    _hx_is_interface = "False"
    __slots__ = ("shader", "_hx_pass", "primitive", "manager", "_engine", "shaders", "buffers")
    _hx_fields = ["shader", "pass", "primitive", "manager", "_engine", "shaders", "buffers"]
    _hx_methods = ["get_engine", "copy", "setGlobals", "addShader", "removeShader", "getShader", "render", "dispose"]
    _hx_statics = ["run"]

    def __init__(self,shader,output = None):
        self.buffers = None
        self._engine = None
        self.primitive = None
        self.shader = shader
        self.shaders = hxsl_ShaderList(shader)
        self.manager = h3d_pass_ShaderManager(output)
        self._hx_pass = h3d_mat_Pass("screenfx",hxsl_ShaderList(shader))
        self._hx_pass.set_culling(h3d_mat_Face._hx_None)
        self._hx_pass.depth(False,h3d_mat_Compare.Always)

    def get_engine(self):
        if (self._engine is None):
            self._engine = h3d_Engine.CURRENT
        return self._engine

    def copy(self,src,dst):
        h3d_pass_Copy.run(src,dst)

    def setGlobals(self,ctx):
        _g = 0
        _g1 = ctx.sharedGlobals
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.manager.globals.map.set(g.gid,g.value)

    def addShader(self,s):
        self.shaders = hxsl_ShaderList.addSort(s,self.shaders)
        return self._hx_pass.addShader(s)

    def removeShader(self,s):
        prev = None
        cur = self.shaders
        while (cur is not None):
            if (cur.s == s):
                if (prev is None):
                    self.shaders = cur.next
                else:
                    prev.next = cur.next
                return True
            prev = cur
            cur = cur.next
        return False

    def getShader(self,cl):
        _g_l = self.shaders
        _g_last = None
        while (_g_l != _g_last):
            s = _g_l.s
            _g_l = _g_l.next
            s1 = s
            si = Std.downcast(s1,cl)
            if (si is not None):
                return si
        return None

    def render(self):
        if (self.primitive is None):
            self.primitive = h3d_prim_Plane2D.get()
        self.shader.flipY__ = (-1 if ((self.get_engine().driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) and ((self.get_engine().getCurrentTarget() is not None)))) else 1)
        rts = self.manager.compileShaders(self.shaders)
        self.get_engine().selectMaterial(self._hx_pass)
        self.get_engine().selectShader(rts)
        if (self.buffers is None):
            self.buffers = h3d_shader_Buffers(rts)
        else:
            _this = self.buffers
            _this.vertex.grow(rts.vertex)
            _this.fragment.grow(rts.fragment)
        self.manager.fillGlobals(self.buffers,rts)
        self.manager.fillParams(self.buffers,rts,self.shaders)
        self.get_engine().uploadShaderBuffers(self.buffers,0)
        self.get_engine().uploadShaderBuffers(self.buffers,1)
        self.get_engine().uploadShaderBuffers(self.buffers,2)
        self.primitive.render(self.get_engine())

    def dispose(self):
        pass

    @staticmethod
    def run(shader,output,layer = None):
        engine = h3d_Engine.CURRENT
        engine.pushTarget(output,layer)
        h3d_pass_ScreenFx(shader).render()
        engine.popTarget()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shader = None
        _hx_o._hx_pass = None
        _hx_o.primitive = None
        _hx_o.manager = None
        _hx_o._engine = None
        _hx_o.shaders = None
        _hx_o.buffers = None
h3d_pass_ScreenFx._hx_class = h3d_pass_ScreenFx
_hx_classes["h3d.pass.ScreenFx"] = h3d_pass_ScreenFx


class h3d_pass_Blur(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.Blur"
    _hx_is_interface = "False"
    __slots__ = ("cubeDir", "radius", "gain", "linear", "quality", "values", "offsets")
    _hx_fields = ["cubeDir", "radius", "gain", "linear", "quality", "values", "offsets"]
    _hx_methods = ["set_radius", "set_quality", "set_gain", "set_linear", "gauss", "calcValues", "getKernelSize", "apply"]
    _hx_statics = ["__meta__"]
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self,radius = None,gain = None,linear = None,quality = None):
        if (radius is None):
            radius = 1.
        if (gain is None):
            gain = 1.
        if (linear is None):
            linear = 0.
        if (quality is None):
            quality = 1.
        self.offsets = None
        self.values = None
        self.quality = None
        self.linear = None
        self.gain = None
        self.radius = None
        self.cubeDir = [h3d_Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d_Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0]), h3d_Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]
        super().__init__(h3d_shader_Blur())
        self.set_radius(radius)
        self.set_quality(quality)
        self.set_gain(gain)
        self.set_linear(linear)

    def set_radius(self,r):
        if (self.radius == r):
            return r
        self.values = None
        def _hx_local_1():
            def _hx_local_0():
                self.radius = r
                return self.radius
            return _hx_local_0()
        return _hx_local_1()

    def set_quality(self,q):
        if (self.quality == q):
            return q
        self.values = None
        def _hx_local_1():
            def _hx_local_0():
                self.quality = q
                return self.quality
            return _hx_local_0()
        return _hx_local_1()

    def set_gain(self,s):
        if (self.gain == s):
            return s
        self.values = None
        def _hx_local_1():
            def _hx_local_0():
                self.gain = s
                return self.gain
            return _hx_local_0()
        return _hx_local_1()

    def set_linear(self,b):
        if (self.linear == b):
            return b
        self.values = None
        def _hx_local_1():
            def _hx_local_0():
                self.linear = b
                return self.linear
            return _hx_local_0()
        return _hx_local_1()

    def gauss(self,x,s):
        if (s <= 0):
            if (x == 0):
                return 1
            else:
                return 0
        sq = (s * s)
        p = Math.pow(2.718281828459,(-((x * x)) / ((2 * sq))))
        v = ((2 * Math.PI) * sq)
        return (p / ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))

    def calcValues(self):
        self.values = []
        self.offsets = []
        tot = 0.
        f = self.quality
        qadj = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 0.7) + 0.3)
        width = None
        if (self.radius > 0):
            a = (self.radius - 1)
            width = Math.ceil(((((1 if ((a < 1)) else a)) * qadj) / 2))
        else:
            width = 0
        v = self.radius
        sigma = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        _g = 0
        _g1 = (width + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            i1 = (i * 2)
            i2 = (0 if ((i == 0)) else ((i * 2) - 1))
            g1 = self.gauss(i1,sigma)
            g2 = self.gauss(i2,sigma)
            g = (g1 + g2)
            python_internal_ArrayImpl._set(self.values, i, g)
            python_internal_ArrayImpl._set(self.offsets, i, (0 if ((i == 0)) else ((((g1 * i1) + ((g2 * i2)))) / (((g * i) * ((Math.NaN if ((qadj < 0)) else python_lib_Math.sqrt(qadj))))))))
            tot = (tot + g)
            if (i > 0):
                tot = (tot + g)
        minVal = ((self.values[0] if 0 < len(self.values) else None) * ((0.01 / qadj)))
        while (len(self.values) > 2):
            last = python_internal_ArrayImpl._get(self.values, (len(self.values) - 1))
            if (last > minVal):
                break
            tot = (tot - ((last * 2)))
            _this = self.values
            if (len(_this) != 0):
                _this.pop()
        tot = (tot / self.gain)
        _g = 0
        _g1 = len(self.values)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _hx_local_4 = self.values
            _hx_local_5 = i
            _hx_local_6 = (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
            python_internal_ArrayImpl._set(_hx_local_4, _hx_local_5, (_hx_local_6 / tot))
            (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        if (self.linear > 0):
            m = (self.gain / (((len(self.values) * 2) - 1)))
            _g = 0
            _g1 = len(self.values)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                a = (self.values[i] if i >= 0 and i < len(self.values) else None)
                python_internal_ArrayImpl._set(self.values, i, (a + ((self.linear * ((m - a))))))
                a1 = (self.offsets[i] if i >= 0 and i < len(self.offsets) else None)
                python_internal_ArrayImpl._set(self.offsets, i, (a1 + ((self.linear * ((((0 if ((i == 0)) else ((((i * 2) - 0.5)) / ((i * qadj))))) - a1))))))

    def getKernelSize(self):
        if (self.values is None):
            self.calcValues()
        if (self.radius <= 0):
            return 0
        else:
            return ((len(self.values) * 2) - 1)

    def apply(self,ctx,src,output = None):
        if ((self.radius <= 0) and ((self.shader.fixedColor__ is None))):
            if (output is not None):
                h3d_pass_Copy.run(src,output)
            return
        if (output is None):
            output = src
        if (self.values is None):
            self.calcValues()
        isCube = (((src.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0)
        faceCount = (6 if isCube else 1)
        tmp = ctx.textures.allocTarget((HxOverrides.stringOrNull(src.name) + "BlurTmp"),src.width,src.height,False,src.format,isCube)
        _this = self.shader
        _this.constModified = True
        _this.Quality__ = len(self.values)
        self.shader.values__ = self.values
        self.shader.offsets__ = self.offsets
        if isCube:
            self.shader.cubeTexture__ = src
            _this = self.shader
            _this.constModified = True
            _this.isCube__ = True
        else:
            self.shader.texture__ = src
            _this = self.shader
            _this.constModified = True
            _this.isCube__ = False
        _this = self.shader.pixel__
        x = (1 / src.width)
        y = 0
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        _g = 0
        _g1 = faceCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.get_engine().pushTarget(tmp,i)
            if isCube:
                self.shader.cubeDir__ = (self.cubeDir[i] if i >= 0 and i < len(self.cubeDir) else None)
            self.render()
            self.get_engine().popTarget()
        if isCube:
            self.shader.cubeTexture__ = tmp
        else:
            self.shader.texture__ = tmp
        _this = self.shader.pixel__
        x = 0
        y = (1 / src.height)
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        outDepth = output.depthBuffer
        output.depthBuffer = None
        _g = 0
        _g1 = faceCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.get_engine().pushTarget(output,i)
            if isCube:
                self.shader.cubeDir__ = (self.cubeDir[i] if i >= 0 and i < len(self.cubeDir) else None)
            self.render()
            self.get_engine().popTarget()
        output.depthBuffer = outDepth

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cubeDir = None
        _hx_o.radius = None
        _hx_o.gain = None
        _hx_o.linear = None
        _hx_o.quality = None
        _hx_o.values = None
        _hx_o.offsets = None
h3d_pass_Blur._hx_class = h3d_pass_Blur
_hx_classes["h3d.pass.Blur"] = h3d_pass_Blur


class hxsl_Shader:
    _hx_class_name = "hxsl.Shader"
    _hx_is_interface = "False"
    __slots__ = ("priority", "shader", "instance", "constBits", "constModified")
    _hx_fields = ["priority", "shader", "instance", "constBits", "constModified"]
    _hx_methods = ["initialize", "setPriority", "getParamValue", "getParamFloatValue", "updateConstants", "updateConstantsFinal", "clone", "toString"]

    def __init__(self):
        self.constModified = None
        self.constBits = None
        self.instance = None
        self.shader = None
        self.priority = 0
        self.initialize()

    def initialize(self):
        self.constModified = True
        if (self.shader is not None):
            return
        cl = Type.getClass(self)
        self.shader = Reflect.field(cl,"_SHADER")
        if (self.shader is None):
            curClass = cl
            while ((curClass is not None) and ((Reflect.field(curClass,"SRC") is None))):
                curClass = Type.getSuperClass(curClass)
            if (curClass is None):
                raise haxe_Exception.thrown((HxOverrides.stringOrNull(Type.getClassName(cl)) + " has no shader source"))
            self.shader = Reflect.field(curClass,"_SHADER")
            if (self.shader is None):
                self.shader = hxsl_SharedShader(Reflect.field(curClass,"SRC"))
                Reflect.setField(curClass,"_SHADER",self.shader)

    def setPriority(self,v):
        self.priority = v

    def getParamValue(self,index):
        raise haxe_Exception.thrown("assert")

    def getParamFloatValue(self,index):
        raise haxe_Exception.thrown("assert")

    def updateConstants(self,globals):
        raise haxe_Exception.thrown("assert")

    def updateConstantsFinal(self,globals):
        c = self.shader.consts
        while (c is not None):
            if (c.globalId == 0):
                c = c.next
                continue
            v = globals.map.h.get(c.globalId,None)
            _g = c.v.type
            tmp = _g.index
            if (tmp == 1):
                v1 = v
                if (HxOverrides.rshift(v1, c.bits) != 0):
                    raise haxe_Exception.thrown((((((("Constant " + HxOverrides.stringOrNull(c.v.name)) + " is outside range (") + Std.string(v1)) + " > ") + Std.string(((((1 << c.bits)) - 1)))) + ")"))
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.constBits
                _hx_local_0.constBits = (_hx_local_1 | ((v1 << c.pos)))
                _hx_local_0.constBits
            elif (tmp == 2):
                v2 = v
                if v2:
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2.constBits
                    _hx_local_2.constBits = (_hx_local_3 | ((1 << c.pos)))
                    _hx_local_2.constBits
            elif (tmp == 17):
                count = _g.params[0]
                if (v is None):
                    c = c.next
                    continue
                v3 = v
                sel = v3.channel
                if (v3.texture is None):
                    sel = hxsl_Channel.Unknown
                elif ((sel is None) or ((sel == hxsl_Channel.Unknown))):
                    count1 = count
                    if (count1 == 1):
                        if (v3.texture.format == h3d_mat_Texture.nativeFormat):
                            sel = hxsl_Channel.PackedFloat
                        else:
                            raise haxe_Exception.thrown((("Constant " + HxOverrides.stringOrNull(c.v.name)) + " does not define channel select value"))
                    elif (count1 == 3):
                        if (v3.texture.format == h3d_mat_Texture.nativeFormat):
                            sel = hxsl_Channel.PackedNormal
                        else:
                            raise haxe_Exception.thrown((("Constant " + HxOverrides.stringOrNull(c.v.name)) + " does not define channel select value"))
                    else:
                        raise haxe_Exception.thrown((("Constant " + HxOverrides.stringOrNull(c.v.name)) + " does not define channel select value"))
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.constBits
                _hx_local_4.constBits = (_hx_local_5 | (((((globals.allocChannelID(v3.texture) << 3) | sel.index)) << c.pos)))
                _hx_local_4.constBits
            else:
                raise haxe_Exception.thrown("assert")
            c = c.next
        _this = self.shader
        constBits = self.constBits
        i = _this.instanceCache.h.get(constBits,None)
        self.instance = (_this.makeInstance(constBits) if ((i is None)) else i)

    def clone(self):
        return self

    def toString(self):
        return Type.getClassName(Type.getClass(self))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.priority = None
        _hx_o.shader = None
        _hx_o.instance = None
        _hx_o.constBits = None
        _hx_o.constModified = None
hxsl_Shader._hx_class = hxsl_Shader
_hx_classes["hxsl.Shader"] = hxsl_Shader


class h3d_shader_ScreenShader(hxsl_Shader):
    _hx_class_name = "h3d.shader.ScreenShader"
    _hx_is_interface = "False"
    __slots__ = ("flipY__",)
    _hx_fields = ["flipY__"]
    _hx_methods = ["get_flipY", "set_flipY", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.flipY__ = 0
        super().__init__()

    def get_flipY(self):
        return self.flipY__

    def set_flipY(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.flipY__ = _v
                return self.flipY__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.flipY__
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_ScreenShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.flipY__ = None
h3d_shader_ScreenShader._hx_class = h3d_shader_ScreenShader
_hx_classes["h3d.shader.ScreenShader"] = h3d_shader_ScreenShader


class h3d_pass__Border_BorderShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.pass._Border.BorderShader"
    _hx_is_interface = "False"
    __slots__ = ("color__",)
    _hx_fields = ["color__"]
    _hx_methods = ["get_color", "set_color", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.color__ = h3d_Vector()
        super().__init__()

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.color__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__Border_BorderShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.color__ = self.color__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color__ = None
h3d_pass__Border_BorderShader._hx_class = h3d_pass__Border_BorderShader
_hx_classes["h3d.pass._Border.BorderShader"] = h3d_pass__Border_BorderShader


class h3d_pass_Border(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.Border"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["dispose"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self,width,height,size = None):
        if (size is None):
            size = 1
        super().__init__(h3d_pass__Border_BorderShader())
        this1 = list()
        bbuf = this1
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((size / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((size / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((size / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((size / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((((height - size)) / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((((height - size)) / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((((width - size)) / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((((width - size)) / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        self.primitive = h3d_prim_RawPrimitive(_hx_AnonObject({'vbuf': bbuf, 'stride': 2, 'quads': True}),True)
        _this = self.shader.color__
        x = 1
        y = 1
        z = 1
        w = 1
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = w

    def dispose(self):
        super().dispose()
        self.primitive.dispose()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_pass_Border._hx_class = h3d_pass_Border
_hx_classes["h3d.pass.Border"] = h3d_pass_Border


class h3d_pass__Copy_ArrayCopyShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.pass._Copy.ArrayCopyShader"
    _hx_is_interface = "False"
    __slots__ = ("texture__", "layer__")
    _hx_fields = ["texture__", "layer__"]
    _hx_methods = ["get_texture", "set_texture", "get_layer", "set_layer", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.texture__ = None
        self.layer__ = 0
        super().__init__()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def get_layer(self):
        return self.layer__

    def set_layer(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.layer__ = _v
                return self.layer__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texture__
        elif (index1 == 2):
            return self.layer__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__Copy_ArrayCopyShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texture__ = self.texture__
        s.layer__ = self.layer__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
        _hx_o.layer__ = None
h3d_pass__Copy_ArrayCopyShader._hx_class = h3d_pass__Copy_ArrayCopyShader
_hx_classes["h3d.pass._Copy.ArrayCopyShader"] = h3d_pass__Copy_ArrayCopyShader


class h3d_pass_ArrayCopy(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.ArrayCopy"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["apply"]
    _hx_statics = ["run"]
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self):
        super().__init__(h3d_pass__Copy_ArrayCopyShader())

    def apply(self,_hx_from,fromLayer,to,blend = None,customPass = None,layer = None):
        if (to is not None):
            self.get_engine().pushTarget(to,(layer if ((layer is not None)) else 0))
        self.shader.texture__ = _hx_from
        self.shader.layer__ = fromLayer
        if (customPass is not None):
            old = self._hx_pass
            self._hx_pass = customPass
            if (blend is not None):
                self._hx_pass.setBlendMode(blend)
            h = self.shaders
            while (h.next is not None):
                h = h.next
            h.next = self._hx_pass.shaders
            self.render()
            self._hx_pass = old
            h.next = None
        else:
            self._hx_pass.setBlendMode((h2d_BlendMode._hx_None if ((blend is None)) else blend))
            self.render()
        self.shader.texture__ = None
        self.shader.layer__ = 0
        if (to is not None):
            self.get_engine().popTarget()

    @staticmethod
    def run(_hx_from,fromLayer,to,blend = None,_hx_pass = None,layer = None):
        engine = h3d_Engine.CURRENT
        if (((((to is not None) and ((_hx_from is not None))) and (((blend is None) or ((blend == h2d_BlendMode._hx_None))))) and ((_hx_pass is None))) and engine.driver.copyTexture(_hx_from,to)):
            return
        inst = engine.resCache.h.get(h3d_pass_ArrayCopy,None)
        if (inst is None):
            inst = h3d_pass_ArrayCopy()
            engine.resCache.set(h3d_pass_ArrayCopy,inst)
        inst.apply(_hx_from,fromLayer,to,blend,_hx_pass,layer)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_pass_ArrayCopy._hx_class = h3d_pass_ArrayCopy
_hx_classes["h3d.pass.ArrayCopy"] = h3d_pass_ArrayCopy


class h3d_pass__Copy_CopyShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.pass._Copy.CopyShader"
    _hx_is_interface = "False"
    __slots__ = ("texture__",)
    _hx_fields = ["texture__"]
    _hx_methods = ["get_texture", "set_texture", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.texture__ = None
        super().__init__()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texture__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__Copy_CopyShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texture__ = self.texture__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
h3d_pass__Copy_CopyShader._hx_class = h3d_pass__Copy_CopyShader
_hx_classes["h3d.pass._Copy.CopyShader"] = h3d_pass__Copy_CopyShader


class h3d_pass_Copy(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.Copy"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["apply"]
    _hx_statics = ["run"]
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self):
        super().__init__(h3d_pass__Copy_CopyShader())

    def apply(self,_hx_from,to,blend = None,customPass = None,layer = None):
        if (to is not None):
            self.get_engine().pushTarget(to,(layer if ((layer is not None)) else 0))
        self.shader.texture__ = _hx_from
        if (customPass is not None):
            old = self._hx_pass
            self._hx_pass = customPass
            if (blend is not None):
                self._hx_pass.setBlendMode(blend)
            h = self.shaders
            while (h.next is not None):
                h = h.next
            h.next = self._hx_pass.shaders
            self.render()
            self._hx_pass = old
            h.next = None
        else:
            self._hx_pass.setBlendMode((h2d_BlendMode._hx_None if ((blend is None)) else blend))
            self.render()
        self.shader.texture__ = None
        if (to is not None):
            self.get_engine().popTarget()

    @staticmethod
    def run(_hx_from,to,blend = None,_hx_pass = None,layer = None):
        engine = h3d_Engine.CURRENT
        if ((((((to is not None) and ((_hx_from is not None))) and (((blend is None) or ((blend == h2d_BlendMode._hx_None))))) and ((_hx_pass is None))) and ((layer is None))) and engine.driver.copyTexture(_hx_from,to)):
            return
        inst = engine.resCache.h.get(h3d_pass_Copy,None)
        if (inst is None):
            inst = h3d_pass_Copy()
            engine.resCache.set(h3d_pass_Copy,inst)
        inst.apply(_hx_from,to,blend,_hx_pass,layer)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_pass_Copy._hx_class = h3d_pass_Copy
_hx_classes["h3d.pass.Copy"] = h3d_pass_Copy


class h3d_pass__CubeCopy_CubeCopyShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.pass._CubeCopy.CubeCopyShader"
    _hx_is_interface = "False"
    __slots__ = ("texture__", "mat__")
    _hx_fields = ["texture__", "mat__"]
    _hx_methods = ["get_texture", "set_texture", "get_mat", "set_mat", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.texture__ = None
        self.mat__ = h3d_Matrix()
        super().__init__()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def get_mat(self):
        return self.mat__

    def set_mat(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.mat__ = _v
                return self.mat__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texture__
        elif (index1 == 2):
            return self.mat__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__CubeCopy_CubeCopyShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texture__ = self.texture__
        s.mat__ = self.mat__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
        _hx_o.mat__ = None
h3d_pass__CubeCopy_CubeCopyShader._hx_class = h3d_pass__CubeCopy_CubeCopyShader
_hx_classes["h3d.pass._CubeCopy.CubeCopyShader"] = h3d_pass__CubeCopy_CubeCopyShader


class h3d_pass_CubeCopy(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.CubeCopy"
    _hx_is_interface = "False"
    __slots__ = ("cubeDir",)
    _hx_fields = ["cubeDir"]
    _hx_methods = ["apply"]
    _hx_statics = ["run"]
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self):
        self.cubeDir = [h3d_Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d_Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0]), h3d_Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]
        super().__init__(h3d_pass__CubeCopy_CubeCopyShader())

    def apply(self,_hx_from,to,blend = None,customPass = None):
        self.shader.texture__ = _hx_from
        _g = 0
        while (_g < 6):
            i = _g
            _g = (_g + 1)
            if (to is not None):
                self.get_engine().pushTarget(to,i)
            self.shader.mat__ = (self.cubeDir[i] if i >= 0 and i < len(self.cubeDir) else None)
            if (customPass is not None):
                old = self._hx_pass
                self._hx_pass = customPass
                if (blend is not None):
                    self._hx_pass.setBlendMode(blend)
                h = self.shaders
                while (h.next is not None):
                    h = h.next
                h.next = self._hx_pass.shaders
                self.render()
                self._hx_pass = old
                h.next = None
            else:
                self._hx_pass.setBlendMode((h2d_BlendMode._hx_None if ((blend is None)) else blend))
                self.render()
            if (to is not None):
                self.get_engine().popTarget()
        self.shader.texture__ = None

    @staticmethod
    def run(_hx_from,to,blend = None,_hx_pass = None):
        engine = h3d_Engine.CURRENT
        if (((((to is not None) and ((_hx_from is not None))) and (((blend is None) or ((blend == h2d_BlendMode._hx_None))))) and ((_hx_pass is None))) and engine.driver.copyTexture(_hx_from,to)):
            return
        inst = engine.resCache.h.get(h3d_pass_CubeCopy,None)
        if (inst is None):
            inst = h3d_pass_CubeCopy()
            engine.resCache.set(h3d_pass_CubeCopy,inst)
        inst.apply(_hx_from,to,blend,_hx_pass)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cubeDir = None
h3d_pass_CubeCopy._hx_class = h3d_pass_CubeCopy
_hx_classes["h3d.pass.CubeCopy"] = h3d_pass_CubeCopy


class h3d_pass_Default(h3d_pass_Base):
    _hx_class_name = "h3d.pass.Default"
    _hx_is_interface = "False"
    __slots__ = ("manager", "defaultSort", "cameraView_id", "cameraNear_id", "cameraFar_id", "cameraProj_id", "cameraPos_id", "cameraProjDiag_id", "cameraProjFlip_id", "cameraViewProj_id", "cameraInverseViewProj_id", "globalTime_id", "pixelSize_id", "globalModelView_id", "globalModelViewInverse_id")
    _hx_fields = ["manager", "defaultSort", "cameraView_id", "cameraNear_id", "cameraFar_id", "cameraProj_id", "cameraPos_id", "cameraProjDiag_id", "cameraProjFlip_id", "cameraViewProj_id", "cameraInverseViewProj_id", "globalTime_id", "pixelSize_id", "globalModelView_id", "globalModelViewInverse_id"]
    _hx_methods = ["get_globals", "getCurrentPixelSize", "getOutputs", "compileShader", "processShaders", "setupShaders", "log", "drawObject", "draw", "get_cameraView", "set_cameraView", "get_cameraNear", "set_cameraNear", "get_cameraFar", "set_cameraFar", "get_cameraProj", "set_cameraProj", "get_cameraPos", "set_cameraPos", "get_cameraProjDiag", "set_cameraProjDiag", "get_cameraProjFlip", "set_cameraProjFlip", "get_cameraViewProj", "set_cameraViewProj", "get_cameraInverseViewProj", "set_cameraInverseViewProj", "get_globalTime", "set_globalTime", "get_pixelSize", "set_pixelSize", "get_globalModelView", "set_globalModelView", "get_globalModelViewInverse", "set_globalModelViewInverse", "initGlobals", "setGlobals"]
    _hx_statics = ["__meta__"]
    _hx_interfaces = []
    _hx_super = h3d_pass_Base


    def __init__(self,name):
        self.globalModelViewInverse_id = None
        self.globalModelView_id = None
        self.pixelSize_id = None
        self.globalTime_id = None
        self.cameraInverseViewProj_id = None
        self.cameraViewProj_id = None
        self.cameraProjFlip_id = None
        self.cameraProjDiag_id = None
        self.cameraPos_id = None
        self.cameraProj_id = None
        self.cameraFar_id = None
        self.cameraNear_id = None
        self.cameraView_id = None
        self.manager = None
        self.defaultSort = h3d_pass_SortByMaterial().sort
        super().__init__(name)
        self.manager = h3d_pass_ShaderManager(self.getOutputs())
        self.initGlobals()

    def get_globals(self):
        return self.manager.globals

    def getCurrentPixelSize(self):
        t = self.ctx.engine.getCurrentTarget()
        return h3d_Vector((2 / ((self.ctx.engine.width if ((t is None)) else t.width))),(2 / ((self.ctx.engine.height if ((t is None)) else t.height))))

    def getOutputs(self):
        return [hxsl_Output.Value("output.color")]

    def compileShader(self,p):
        o = h3d_pass_PassObject()
        o._hx_pass = p
        self.setupShaders(h3d_pass_PassList(o))
        return self.manager.compileShaders(o.shaders,p.batchMode)

    def processShaders(self,p,shaders):
        p = self.ctx.extraShaders
        while (p is not None):
            shaders = self.ctx.allocShaderList(p.s,shaders)
            p = p.next
        return shaders

    def setupShaders(self,passes):
        lightInit = False
        _g_o = passes.current
        while (_g_o is not None):
            tmp = _g_o
            _g_o = _g_o.next
            p = tmp
            shaders = p._hx_pass.getShadersRec()
            shaders = self.processShaders(p,shaders)
            if (p._hx_pass.enableLights and ((self.ctx.lightSystem is not None))):
                if (not lightInit):
                    self.ctx.lightSystem.initGlobals(self.manager.globals)
                    lightInit = True
                shaders = self.ctx.lightSystem.computeLight(p.obj,shaders)
            p.shader = self.manager.compileShaders(shaders,p._hx_pass.batchMode)
            p.shaders = shaders
            t = p.shader.fragment.textures
            if (t is None):
                p.texture = 0
            else:
                _this = self.manager
                opt = True
                if (opt is None):
                    opt = False
                t1 = None
                if (t.perObjectGlobal is not None):
                    v = _this.globals.map.h.get(t.perObjectGlobal.gid,None)
                    if (v is None):
                        raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(t.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_this.shaderInfo(shaders,t.perObjectGlobal.path))))
                    _g = t.type
                    t2 = None
                    if (_g.index == 17):
                        _g1 = _g.params[0]
                        t2 = True
                    else:
                        t2 = False
                    t1 = (Reflect.field(v,"texture") if t2 else v)
                else:
                    si = shaders
                    n = t.instance
                    while True:
                        n = (n - 1)
                        t3 = n
                        if (not ((t3 > 0))):
                            break
                        si = si.next
                    v1 = si.s.getParamValue(t.index)
                    if ((v1 is None) and (not opt)):
                        raise haxe_Exception.thrown(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(t.name)))
                    t1 = v1
                p.texture = (0 if ((t1 is None)) else t1.id)

    def log(self,_hx_str):
        pass

    def drawObject(self,p):
        self.ctx.drawPass = p
        self.ctx.engine.selectMaterial(p._hx_pass)
        p.obj.draw(self.ctx)

    def draw(self,passes,sort = None):
        if (passes.current is None):
            return
        _g = 0
        _g1 = self.ctx.sharedGlobals
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.manager.globals.map.set(g.gid,g.value)
        self.setGlobals()
        self.setupShaders(passes)
        if (sort is None):
            self.defaultSort(passes)
        else:
            sort(passes)
        self.ctx.currentManager = self.manager
        buf = self.ctx.shaderBuffers
        prevShader = None
        _g2_o = passes.current
        while (_g2_o is not None):
            tmp = _g2_o
            _g2_o = _g2_o.next
            p = tmp
            v = p.obj.absPos
            self.manager.globals.map.set(self.globalModelView_id,v)
            if (self.globalModelViewInverse_id in p.shader.globals.h):
                v1 = p.obj.getInvPos()
                self.manager.globals.map.set(self.globalModelViewInverse_id,v1)
            if (prevShader != p.shader):
                prevShader = p.shader
                self.ctx.engine.selectShader(p.shader)
                if (buf is None):
                    def _hx_local_1():
                        self.ctx.shaderBuffers = h3d_shader_Buffers(p.shader)
                        return self.ctx.shaderBuffers
                    buf = _hx_local_1()
                else:
                    s = p.shader
                    buf.vertex.grow(s.vertex)
                    buf.fragment.grow(s.fragment)
                self.manager.fillGlobals(buf,p.shader)
                self.ctx.engine.uploadShaderBuffers(buf,0)
            if (not p._hx_pass.dynamicParameters):
                self.manager.fillParams(buf,p.shader,p.shaders)
                self.ctx.engine.uploadShaderBuffers(buf,1)
                self.ctx.engine.uploadShaderBuffers(buf,2)
                self.ctx.engine.uploadShaderBuffers(buf,3)
            self.drawObject(p)
        _this = self.ctx
        _this.cachedPos = 0
        _this.drawPass = None

    def get_cameraView(self):
        return self.manager.globals.map.h.get(self.cameraView_id,None)

    def set_cameraView(self,v):
        self.manager.globals.map.set(self.cameraView_id,v)
        return v

    def get_cameraNear(self):
        return self.manager.globals.map.h.get(self.cameraNear_id,None)

    def set_cameraNear(self,v):
        self.manager.globals.map.set(self.cameraNear_id,v)
        return v

    def get_cameraFar(self):
        return self.manager.globals.map.h.get(self.cameraFar_id,None)

    def set_cameraFar(self,v):
        self.manager.globals.map.set(self.cameraFar_id,v)
        return v

    def get_cameraProj(self):
        return self.manager.globals.map.h.get(self.cameraProj_id,None)

    def set_cameraProj(self,v):
        self.manager.globals.map.set(self.cameraProj_id,v)
        return v

    def get_cameraPos(self):
        return self.manager.globals.map.h.get(self.cameraPos_id,None)

    def set_cameraPos(self,v):
        self.manager.globals.map.set(self.cameraPos_id,v)
        return v

    def get_cameraProjDiag(self):
        return self.manager.globals.map.h.get(self.cameraProjDiag_id,None)

    def set_cameraProjDiag(self,v):
        self.manager.globals.map.set(self.cameraProjDiag_id,v)
        return v

    def get_cameraProjFlip(self):
        return self.manager.globals.map.h.get(self.cameraProjFlip_id,None)

    def set_cameraProjFlip(self,v):
        self.manager.globals.map.set(self.cameraProjFlip_id,v)
        return v

    def get_cameraViewProj(self):
        return self.manager.globals.map.h.get(self.cameraViewProj_id,None)

    def set_cameraViewProj(self,v):
        self.manager.globals.map.set(self.cameraViewProj_id,v)
        return v

    def get_cameraInverseViewProj(self):
        return self.manager.globals.map.h.get(self.cameraInverseViewProj_id,None)

    def set_cameraInverseViewProj(self,v):
        self.manager.globals.map.set(self.cameraInverseViewProj_id,v)
        return v

    def get_globalTime(self):
        return self.manager.globals.map.h.get(self.globalTime_id,None)

    def set_globalTime(self,v):
        self.manager.globals.map.set(self.globalTime_id,v)
        return v

    def get_pixelSize(self):
        return self.manager.globals.map.h.get(self.pixelSize_id,None)

    def set_pixelSize(self,v):
        self.manager.globals.map.set(self.pixelSize_id,v)
        return v

    def get_globalModelView(self):
        return self.manager.globals.map.h.get(self.globalModelView_id,None)

    def set_globalModelView(self,v):
        self.manager.globals.map.set(self.globalModelView_id,v)
        return v

    def get_globalModelViewInverse(self):
        return self.manager.globals.map.h.get(self.globalModelViewInverse_id,None)

    def set_globalModelViewInverse(self,v):
        self.manager.globals.map.set(self.globalModelViewInverse_id,v)
        return v

    def initGlobals(self):
        this1 = hxsl_Globals.allocID("camera.view")
        self.cameraView_id = this1
        this1 = hxsl_Globals.allocID("camera.zNear")
        self.cameraNear_id = this1
        this1 = hxsl_Globals.allocID("camera.zFar")
        self.cameraFar_id = this1
        this1 = hxsl_Globals.allocID("camera.proj")
        self.cameraProj_id = this1
        this1 = hxsl_Globals.allocID("camera.position")
        self.cameraPos_id = this1
        this1 = hxsl_Globals.allocID("camera.projDiag")
        self.cameraProjDiag_id = this1
        this1 = hxsl_Globals.allocID("camera.projFlip")
        self.cameraProjFlip_id = this1
        this1 = hxsl_Globals.allocID("camera.viewProj")
        self.cameraViewProj_id = this1
        this1 = hxsl_Globals.allocID("camera.inverseViewProj")
        self.cameraInverseViewProj_id = this1
        this1 = hxsl_Globals.allocID("global.time")
        self.globalTime_id = this1
        this1 = hxsl_Globals.allocID("global.pixelSize")
        self.pixelSize_id = this1
        this1 = hxsl_Globals.allocID("global.modelView")
        self.globalModelView_id = this1
        this1 = hxsl_Globals.allocID("global.modelViewInverse")
        self.globalModelViewInverse_id = this1

    def setGlobals(self):
        v = self.ctx.camera.mcam
        self.manager.globals.map.set(self.cameraView_id,v)
        v = self.ctx.camera.zNear
        self.manager.globals.map.set(self.cameraNear_id,v)
        v = self.ctx.camera.zFar
        self.manager.globals.map.set(self.cameraFar_id,v)
        v = self.ctx.camera.mproj
        self.manager.globals.map.set(self.cameraProj_id,v)
        v = self.ctx.camera.pos
        self.manager.globals.map.set(self.cameraPos_id,v)
        v = h3d_Vector(self.ctx.camera.mproj._11,self.ctx.camera.mproj._22,self.ctx.camera.mproj._33,self.ctx.camera.mproj._44)
        self.manager.globals.map.set(self.cameraProjDiag_id,v)
        v = (-1 if ((self.ctx.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) and ((self.ctx.engine.getCurrentTarget() is not None)))) else 1)
        self.manager.globals.map.set(self.cameraProjFlip_id,v)
        v = self.ctx.camera.m
        self.manager.globals.map.set(self.cameraViewProj_id,v)
        v = self.ctx.camera.getInverseViewProj()
        self.manager.globals.map.set(self.cameraInverseViewProj_id,v)
        v = self.ctx.time
        self.manager.globals.map.set(self.globalTime_id,v)
        v = self.getCurrentPixelSize()
        self.manager.globals.map.set(self.pixelSize_id,v)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.manager = None
        _hx_o.defaultSort = None
        _hx_o.cameraView_id = None
        _hx_o.cameraNear_id = None
        _hx_o.cameraFar_id = None
        _hx_o.cameraProj_id = None
        _hx_o.cameraPos_id = None
        _hx_o.cameraProjDiag_id = None
        _hx_o.cameraProjFlip_id = None
        _hx_o.cameraViewProj_id = None
        _hx_o.cameraInverseViewProj_id = None
        _hx_o.globalTime_id = None
        _hx_o.pixelSize_id = None
        _hx_o.globalModelView_id = None
        _hx_o.globalModelViewInverse_id = None
h3d_pass_Default._hx_class = h3d_pass_Default
_hx_classes["h3d.pass.Default"] = h3d_pass_Default


class h3d_pass_Shadows(h3d_pass_Default):
    _hx_class_name = "h3d.pass.Shadows"
    _hx_is_interface = "False"
    __slots__ = ("lightCamera", "format", "staticTexture", "light", "enabled", "mode", "size", "shader", "blur", "samplingKind", "power", "bias", "pcfQuality", "pcfScale")
    _hx_fields = ["lightCamera", "format", "staticTexture", "light", "enabled", "mode", "size", "shader", "blur", "samplingKind", "power", "bias", "pcfQuality", "pcfScale"]
    _hx_methods = ["set_mode", "set_enabled", "set_size", "dispose", "getShadowProj", "getShadowTex", "isUsingWorldDist", "getOutputs", "loadStaticData", "saveStaticData", "computeStatic", "createDefaultShadowMap", "syncShader", "filterPasses", "cullPasses"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Default


    def __init__(self,light):
        self.blur = None
        self.shader = None
        self.light = None
        self.staticTexture = None
        self.format = None
        self.lightCamera = None
        self.pcfScale = 1.0
        self.pcfQuality = 1
        self.bias = 0.01
        self.power = 30.0
        self.samplingKind = h3d_pass_ShadowSamplingKind._hx_None
        self.size = 1024
        self.mode = h3d_pass_RenderMode._hx_None
        self.enabled = True
        if (self.format is None):
            self.format = hxd_PixelFormat.R16F
        if (not h3d_Engine.CURRENT.driver.isSupportedFormat(self.format)):
            self.format = h3d_mat_Texture.nativeFormat
        super().__init__("shadow")
        self.light = light
        self.blur = h3d_pass_Blur(5)
        self.blur.set_quality(0.5)
        _this = self.blur.shader
        _this.constModified = True
        _this.isDepth__ = (self.format == h3d_mat_Texture.nativeFormat)

    def set_mode(self,m):
        if (m != h3d_pass_RenderMode._hx_None):
            raise haxe_Exception.thrown(((("Shadow mode " + Std.string(m)) + " not supported for ") + Std.string(self.light)))
        def _hx_local_1():
            def _hx_local_0():
                self.mode = m
                return self.mode
            return _hx_local_0()
        return _hx_local_1()

    def set_enabled(self,b):
        def _hx_local_1():
            def _hx_local_0():
                self.enabled = b
                return self.enabled
            return _hx_local_0()
        return _hx_local_1()

    def set_size(self,s):
        if ((s != self.size) and ((self.staticTexture is not None))):
            self.staticTexture.dispose()
            self.staticTexture = None
        def _hx_local_1():
            def _hx_local_0():
                self.size = s
                return self.size
            return _hx_local_0()
        return _hx_local_1()

    def dispose(self):
        super().dispose()
        self.blur.dispose()
        if (self.staticTexture is not None):
            self.staticTexture.dispose()

    def getShadowProj(self):
        return self.lightCamera.m

    def getShadowTex(self):
        return None

    def isUsingWorldDist(self):
        return False

    def getOutputs(self):
        if self.isUsingWorldDist():
            return [hxsl_Output.Swiz(hxsl_Output.Value("output.worldDist",1),[hxsl_Component.X, hxsl_Component.X, hxsl_Component.X, hxsl_Component.X])]
        if (self.format == h3d_mat_Texture.nativeFormat):
            return [hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))]
        return [hxsl_Output.Swiz(hxsl_Output.Value("output.depth",1),[hxsl_Component.X, hxsl_Component.X, hxsl_Component.X, hxsl_Component.X])]

    def loadStaticData(self,_hx_bytes):
        return False

    def saveStaticData(self):
        return None

    def computeStatic(self,passes):
        raise haxe_Exception.thrown("Not implemented")

    def createDefaultShadowMap(self):
        tex = h3d_mat_Texture.fromColor(16777215)
        tex.name = "defaultShadowMap"
        return tex

    def syncShader(self,texture):
        pass

    def filterPasses(self,passes):
        if (not self.ctx.computingStatic):
            tmp = self.mode.index
            if (tmp == 0):
                return False
            elif (tmp == 1):
                tmp = None
                if (self.staticTexture is not None):
                    _this = self.staticTexture
                    tmp = ((_this.t is None) and ((_this.realloc is None)))
                else:
                    tmp = True
                if tmp:
                    self.staticTexture = self.createDefaultShadowMap()
                self.syncShader(self.staticTexture)
                return False
            elif (tmp == 2):
                return True
            elif (tmp == 3):
                tmp = None
                if (self.staticTexture is not None):
                    _this = self.staticTexture
                    tmp = ((_this.t is None) and ((_this.realloc is None)))
                else:
                    tmp = True
                if tmp:
                    self.staticTexture = self.createDefaultShadowMap()
                return True
            else:
                pass
        else:
            tmp = self.mode.index
            if (tmp == 0):
                return False
            elif (tmp == 1):
                head = None
                prev = None
                disc = passes.discarded
                discQueue = passes.lastDisc
                cur = passes.current
                while (cur is not None):
                    if (cur._hx_pass.isStatic == True):
                        if (head is None):
                            prev = cur
                            head = prev
                        else:
                            prev.next = cur
                            prev = cur
                    elif (disc is None):
                        discQueue = cur
                        disc = discQueue
                    else:
                        discQueue.next = cur
                        discQueue = cur
                    cur = cur.next
                if (prev is not None):
                    prev.next = None
                if (discQueue is not None):
                    discQueue.next = None
                passes.current = head
                passes.discarded = disc
                passes.lastDisc = discQueue
                return True
            elif (tmp == 2):
                return False
            elif (tmp == 3):
                head = None
                prev = None
                disc = passes.discarded
                discQueue = passes.lastDisc
                cur = passes.current
                while (cur is not None):
                    if (cur._hx_pass.isStatic == True):
                        if (head is None):
                            prev = cur
                            head = prev
                        else:
                            prev.next = cur
                            prev = cur
                    elif (disc is None):
                        discQueue = cur
                        disc = discQueue
                    else:
                        discQueue.next = cur
                        discQueue = cur
                    cur = cur.next
                if (prev is not None):
                    prev.next = None
                if (discQueue is not None):
                    discQueue.next = None
                passes.current = head
                passes.discarded = disc
                passes.lastDisc = discQueue
                return True
            else:
                pass

    def cullPasses(self,passes,f):
        prevCollider = None
        prevResult = True
        head = None
        prev = None
        disc = passes.discarded
        discQueue = passes.lastDisc
        cur = passes.current
        while (cur is not None):
            col = cur.obj.cullingCollider
            tmp = None
            if (col is None):
                tmp = True
            else:
                if (col != prevCollider):
                    prevCollider = col
                    prevResult = f(col)
                tmp = prevResult
            if tmp:
                if (head is None):
                    prev = cur
                    head = prev
                else:
                    prev.next = cur
                    prev = cur
            elif (disc is None):
                discQueue = cur
                disc = discQueue
            else:
                discQueue.next = cur
                discQueue = cur
            cur = cur.next
        if (prev is not None):
            prev.next = None
        if (discQueue is not None):
            discQueue.next = None
        passes.current = head
        passes.discarded = disc
        passes.lastDisc = discQueue

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lightCamera = None
        _hx_o.format = None
        _hx_o.staticTexture = None
        _hx_o.light = None
        _hx_o.enabled = None
        _hx_o.mode = None
        _hx_o.size = None
        _hx_o.shader = None
        _hx_o.blur = None
        _hx_o.samplingKind = None
        _hx_o.power = None
        _hx_o.bias = None
        _hx_o.pcfQuality = None
        _hx_o.pcfScale = None
h3d_pass_Shadows._hx_class = h3d_pass_Shadows
_hx_classes["h3d.pass.Shadows"] = h3d_pass_Shadows


class h3d_pass_DirShadowMap(h3d_pass_Shadows):
    _hx_class_name = "h3d.pass.DirShadowMap"
    _hx_is_interface = "False"
    _hx_fields = ["customDepth", "depth", "dshader", "border", "mergePass", "autoShrink", "maxDist", "minDist"]
    _hx_methods = ["set_mode", "set_enabled", "set_size", "dispose", "getShadowTex", "calcShadowBounds", "setGlobals", "syncShader", "saveStaticData", "loadStaticData", "draw", "computeStatic"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Shadows


    def __init__(self,light):
        self.border = None
        self.dshader = None
        self.depth = None
        self.customDepth = None
        self.minDist = -1.0
        self.maxDist = -1.0
        self.autoShrink = True
        self.mergePass = h3d_pass_ScreenFx(h3d_shader_MinMaxShader())
        super().__init__(light)
        self.lightCamera = h3d_Camera()
        self.lightCamera.orthoBounds = h3d_col_Bounds()
        def _hx_local_0():
            self.dshader = h3d_shader_DirShadow()
            return self.dshader
        self.shader = _hx_local_0()
        self.border = h3d_pass_Border(self.size,self.size)
        self.customDepth = h3d_Engine.CURRENT.driver.hasFeature(h3d_impl_Feature.AllocDepthBuffer)
        if (not self.customDepth):
            self.depth = h3d_mat_DepthBuffer.getDefault()

    def set_mode(self,m):
        _this = self.dshader
        _this.constModified = True
        _this.enable__ = (m != h3d_pass_RenderMode._hx_None)
        def _hx_local_1():
            def _hx_local_0():
                self.mode = m
                return self.mode
            return _hx_local_0()
        return _hx_local_1()

    def set_enabled(self,b):
        _this = self.dshader
        _this.constModified = True
        _this.enable__ = (b and ((self.mode != h3d_pass_RenderMode._hx_None)))
        def _hx_local_1():
            def _hx_local_0():
                self.enabled = b
                return self.enabled
            return _hx_local_0()
        return _hx_local_1()

    def set_size(self,s):
        if ((self.border is not None) and ((self.size != s))):
            self.border.dispose()
            self.border = h3d_pass_Border(s,s)
        return super().set_size(s)

    def dispose(self):
        super().dispose()
        if (self.customDepth and ((self.depth is not None))):
            self.depth.dispose()
        self.border.dispose()

    def getShadowTex(self):
        return self.dshader.shadowMap__

    def calcShadowBounds(self,camera):
        bounds = camera.orthoBounds
        if self.autoShrink:
            mtmp = h3d_Matrix()
            def _hx_local_0(m):
                if ((m.primitive is None) or (not m.material.castShadows)):
                    return
                b = m.primitive.getBounds()
                if (b.xMin > b.xMax):
                    return
                mtmp.multiply3x4(m.getAbsPos(),camera.mcam)
                x = b.xMin
                y = b.yMin
                z = b.zMin
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMin
                y = b.yMin
                z = b.zMax
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMin
                y = b.yMax
                z = b.zMin
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMin
                y = b.yMax
                z = b.zMax
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMax
                y = b.yMin
                z = b.zMin
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMax
                y = b.yMin
                z = b.zMax
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMax
                y = b.yMax
                z = b.zMin
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
                x = b.xMax
                y = b.yMax
                z = b.zMax
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
                py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
                pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
                p_x = px
                p_y = py
                p_z = pz
                if (p_x < bounds.xMin):
                    bounds.xMin = p_x
                if (p_x > bounds.xMax):
                    bounds.xMax = p_x
                if (p_y < bounds.yMin):
                    bounds.yMin = p_y
                if (p_y > bounds.yMax):
                    bounds.yMax = p_y
                if (p_z < bounds.zMin):
                    bounds.zMin = p_z
                if (p_z > bounds.zMax):
                    bounds.zMax = p_z
            self.ctx.scene.iterVisibleMeshes(_hx_local_0)
        elif (self.mode == h3d_pass_RenderMode.Dynamic):
            bounds.xMin = -1e20
            bounds.xMax = 1e20
            bounds.yMin = -1e20
            bounds.yMax = 1e20
            bounds.zMin = -1e20
            bounds.zMax = 1e20
        if (self.mode == h3d_pass_RenderMode.Dynamic):
            cameraBounds = h3d_col_Bounds()
            zMax = 1.0
            zMin = 0.0
            n = self.ctx.camera.zNear
            f = self.ctx.camera.zFar
            if (self.maxDist > 0):
                f1 = self.maxDist
                _hx_min = n
                _hx_max = f
                if (_hx_max is None):
                    _hx_max = 1.
                if (_hx_min is None):
                    _hx_min = 0.
                zMax = (((((((f + n) - ((((2.0 * n) * f) / ((_hx_min if ((f1 < _hx_min)) else (_hx_max if ((f1 > _hx_max)) else f1))))))) / ((f - n))) + 1.0)) / 2.0)
            if (self.minDist > 0):
                f1 = self.minDist
                _hx_min = n
                _hx_max = f
                if (_hx_max is None):
                    _hx_max = 1.
                if (_hx_min is None):
                    _hx_min = 0.
                zMin = (((((((f + n) - ((((2.0 * n) * f) / ((_hx_min if ((f1 < _hx_min)) else (_hx_max if ((f1 > _hx_max)) else f1))))))) / ((f - n))) + 1.0)) / 2.0)
            _g = 0
            _g1 = self.ctx.camera.getFrustumCorners(zMax,zMin)
            while (_g < len(_g1)):
                pt = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                m = camera.mcam
                px = ((((pt.x * m._11) + ((pt.y * m._21))) + ((pt.z * m._31))) + ((pt.w * m._41)))
                py = ((((pt.x * m._12) + ((pt.y * m._22))) + ((pt.z * m._32))) + ((pt.w * m._42)))
                pz = ((((pt.x * m._13) + ((pt.y * m._23))) + ((pt.z * m._33))) + ((pt.w * m._43)))
                pw = ((((pt.x * m._14) + ((pt.y * m._24))) + ((pt.z * m._34))) + ((pt.w * m._44)))
                pt.x = px
                pt.y = py
                pt.z = pz
                pt.w = pw
                x = pt.x
                y = pt.y
                z = pt.z
                if (x < cameraBounds.xMin):
                    cameraBounds.xMin = x
                if (x > cameraBounds.xMax):
                    cameraBounds.xMax = x
                if (y < cameraBounds.yMin):
                    cameraBounds.yMin = y
                if (y > cameraBounds.yMax):
                    cameraBounds.yMax = y
                if (z < cameraBounds.zMin):
                    cameraBounds.zMin = z
                if (z > cameraBounds.zMax):
                    cameraBounds.zMax = z
            if self.autoShrink:
                cameraBounds.zMin = bounds.zMin
                bounds.intersection(bounds,cameraBounds)
            else:
                bounds.load(cameraBounds)
        bounds.scaleCenter(1.01)

    def setGlobals(self):
        super().setGlobals()
        if ((self.mode != h3d_pass_RenderMode.Mixed) or self.ctx.computingStatic):
            _this = self.lightCamera.orthoBounds
            _this.xMin = 1e20
            _this.xMax = -1e20
            _this.yMin = 1e20
            _this.yMax = -1e20
            _this.zMin = 1e20
            _this.zMax = -1e20
            self.calcShadowBounds(self.lightCamera)
            self.lightCamera.update()
        v = self.getShadowProj()
        self.manager.globals.map.set(self.cameraViewProj_id,v)

    def syncShader(self,texture):
        _this = self.dshader
        _this.constModified = True
        _this.shadowMap__ = texture
        _this = self.dshader
        _this.constModified = True
        _this.shadowMapChannel__ = (hxsl_Channel.PackedFloat if ((self.format == h3d_mat_Texture.nativeFormat)) else hxsl_Channel.R)
        self.dshader.shadowBias__ = self.bias
        self.dshader.shadowPower__ = self.power
        self.dshader.shadowProj__ = self.getShadowProj()
        _this = self.dshader
        _this.constModified = True
        _this.USE_ESM__ = (self.samplingKind == h3d_pass_ShadowSamplingKind.ESM)
        self.dshader.shadowPower__ = self.power
        _this = self.dshader
        _this.constModified = True
        _this.USE_PCF__ = (self.samplingKind == h3d_pass_ShadowSamplingKind.PCF)
        _this = self.dshader.shadowRes__
        x = texture.width
        y = texture.height
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        self.dshader.pcfScale__ = self.pcfScale
        _this = self.dshader
        _this.constModified = True
        _this.pcfQuality__ = self.pcfQuality

    def saveStaticData(self):
        if ((self.mode != h3d_pass_RenderMode.Mixed) and ((self.mode != h3d_pass_RenderMode.Static))):
            return None
        if (self.staticTexture is None):
            raise haxe_Exception.thrown("Data not computed")
        _hx_bytes = haxe_zip_Compress.run(self.staticTexture.capturePixels().bytes,9)
        buffer = haxe_io_BytesBuffer()
        buffer.addInt32(self.staticTexture.width)
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.pos.x))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.pos.y))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.pos.z))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.target.x))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.target.y))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.target.z))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.xMin))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.yMin))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.zMin))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.xMax))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.yMax))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.zMax))
        buffer.addInt32(_hx_bytes.length)
        buffer.b.extend(_hx_bytes.b)
        return buffer.getBytes()

    def loadStaticData(self,_hx_bytes):
        if (((self.mode != h3d_pass_RenderMode.Mixed) and ((self.mode != h3d_pass_RenderMode.Static))) or ((_hx_bytes is None))):
            return False
        buffer = haxe_io_BytesInput(_hx_bytes)
        size = buffer.readInt32()
        if (size != self.size):
            return False
        self.lightCamera.pos.x = buffer.readFloat()
        self.lightCamera.pos.y = buffer.readFloat()
        self.lightCamera.pos.z = buffer.readFloat()
        self.lightCamera.target.x = buffer.readFloat()
        self.lightCamera.target.y = buffer.readFloat()
        self.lightCamera.target.z = buffer.readFloat()
        self.lightCamera.orthoBounds.xMin = buffer.readFloat()
        self.lightCamera.orthoBounds.yMin = buffer.readFloat()
        self.lightCamera.orthoBounds.zMin = buffer.readFloat()
        self.lightCamera.orthoBounds.xMax = buffer.readFloat()
        self.lightCamera.orthoBounds.yMax = buffer.readFloat()
        self.lightCamera.orthoBounds.zMax = buffer.readFloat()
        self.lightCamera.update()
        _hx_len = buffer.readInt32()
        pixels = hxd_Pixels(size,size,haxe_zip_Uncompress.run(buffer.read(_hx_len)),self.format)
        if (self.staticTexture is not None):
            self.staticTexture.dispose()
        self.staticTexture = h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.Target],self.format)
        self.staticTexture.uploadPixels(pixels)
        self.staticTexture.name = "staticTexture"
        self.staticTexture.preventAutoDispose()
        self.syncShader(self.staticTexture)
        return True

    def draw(self,passes,sort = None):
        _gthis = self
        if (not self.enabled):
            return
        if (not self.filterPasses(passes)):
            return
        def _hx_local_0(col):
            return col.inFrustum(_gthis.lightCamera.frustum)
        f = _hx_local_0
        prevCollider = None
        prevResult = True
        head = None
        prev = None
        disc = passes.discarded
        discQueue = passes.lastDisc
        cur = passes.current
        while (cur is not None):
            col = cur.obj.cullingCollider
            tmp = None
            if (col is None):
                tmp = True
            else:
                if (col != prevCollider):
                    prevCollider = col
                    prevResult = f(col)
                tmp = prevResult
            if tmp:
                if (head is None):
                    prev = cur
                    head = prev
                else:
                    prev.next = cur
                    prev = cur
            elif (disc is None):
                discQueue = cur
                disc = discQueue
            else:
                discQueue.next = cur
                discQueue = cur
            cur = cur.next
        if (prev is not None):
            prev.next = None
        if (discQueue is not None):
            discQueue.next = None
        passes.current = head
        passes.discarded = disc
        passes.lastDisc = discQueue
        texture = self.ctx.textures.allocTarget("dirShadowMap",self.size,self.size,False,self.format)
        if (self.customDepth and (((((self.depth is None) or ((self.depth.width != self.size))) or ((self.depth.height != self.size))) or self.depth.isDisposed()))):
            if (self.depth is not None):
                self.depth.dispose()
            self.depth = h3d_mat_DepthBuffer(self.size,self.size)
        texture.depthBuffer = self.depth
        if ((self.mode != h3d_pass_RenderMode.Mixed) or self.ctx.computingStatic):
            ct = self.ctx.camera.target
            slight = (self.ctx.lightSystem.shadowLight if ((self.light is None)) else self.light)
            ldir = (None if ((slight is None)) else slight.getShadowDirection())
            if (ldir is None):
                _this = self.lightCamera.target
                x = 0
                y = 0
                z = -1
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                _this.x = x
                _this.y = y
                _this.z = z
                _this.w = 1.
            else:
                _this = self.lightCamera.target
                x = ldir.x
                y = ldir.y
                z = ldir.z
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                _this.x = x
                _this.y = y
                _this.z = z
                _this.w = 1.
                _this = self.lightCamera.target
                k = (((_this.x * _this.x) + ((_this.y * _this.y))) + ((_this.z * _this.z)))
                if (k < 1e-10):
                    k = 0
                else:
                    k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
                _this.x = (_this.x * k)
                _this.y = (_this.y * k)
                _this.z = (_this.z * k)
            _hx_local_4 = self.lightCamera.target
            _hx_local_5 = _hx_local_4.x
            _hx_local_4.x = (_hx_local_5 + ct.x)
            _hx_local_4.x
            _hx_local_6 = self.lightCamera.target
            _hx_local_7 = _hx_local_6.y
            _hx_local_6.y = (_hx_local_7 + ct.y)
            _hx_local_6.y
            _hx_local_8 = self.lightCamera.target
            _hx_local_9 = _hx_local_8.z
            _hx_local_8.z = (_hx_local_9 + ct.z)
            _hx_local_8.z
            _this = self.lightCamera.pos
            _this.x = ct.x
            _this.y = ct.y
            _this.z = ct.z
            _this.w = ct.w
            self.lightCamera.update()
        self.ctx.engine.pushTarget(texture)
        self.ctx.engine.clear(16777215,1)
        super().draw(passes,sort)
        if (self.border is not None):
            self.border.render()
        self.ctx.engine.popTarget()
        if ((self.mode == h3d_pass_RenderMode.Mixed) and (not self.ctx.computingStatic)):
            merge = self.ctx.textures.allocTarget("mergedDirShadowMap",self.size,self.size,False,self.format)
            self.mergePass.shader.texA__ = texture
            self.mergePass.shader.texB__ = self.staticTexture
            self.ctx.engine.pushTarget(merge)
            self.mergePass.render()
            self.ctx.engine.popTarget()
            texture = merge
        if ((self.blur.radius > 0) and (((self.mode != h3d_pass_RenderMode.Mixed) or (not self.ctx.computingStatic)))):
            self.blur.apply(self.ctx,texture)
        self.syncShader(texture)

    def computeStatic(self,passes):
        if ((self.mode != h3d_pass_RenderMode.Static) and ((self.mode != h3d_pass_RenderMode.Mixed))):
            return
        self.draw(passes)
        texture = self.dshader.shadowMap__
        old = self.staticTexture
        self.staticTexture = texture.clone()
        self.staticTexture.name = "StaticDirShadowMap"
        self.staticTexture.preventAutoDispose()
        _this = self.dshader
        _this.constModified = True
        _this.shadowMap__ = self.staticTexture
        if (old is not None):
            old.dispose()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.customDepth = None
        _hx_o.depth = None
        _hx_o.dshader = None
        _hx_o.border = None
        _hx_o.mergePass = None
        _hx_o.autoShrink = None
        _hx_o.maxDist = None
        _hx_o.minDist = None
h3d_pass_DirShadowMap._hx_class = h3d_pass_DirShadowMap
_hx_classes["h3d.pass.DirShadowMap"] = h3d_pass_DirShadowMap


class h3d_pass_DefaultShadowMap(h3d_pass_DirShadowMap):
    _hx_class_name = "h3d.pass.DefaultShadowMap"
    _hx_is_interface = "False"
    __slots__ = ("shadowMapId", "shadowProjId", "shadowColorId", "shadowPowerId", "shadowBiasId", "color")
    _hx_fields = ["shadowMapId", "shadowProjId", "shadowColorId", "shadowPowerId", "shadowBiasId", "color"]
    _hx_methods = ["draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_DirShadowMap


    def __init__(self,size = None,format = None):
        if (size is None):
            size = 1024
        self.color = None
        self.shadowBiasId = None
        self.shadowPowerId = None
        self.shadowColorId = None
        self.shadowProjId = None
        self.shadowMapId = None
        if (format is not None):
            self.format = format
        super().__init__(None)
        self.set_size(size)
        self.color = h3d_Vector()
        self.set_mode(h3d_pass_RenderMode.Dynamic)
        self.shadowMapId = hxsl_Globals.allocID("shadow.map")
        self.shadowProjId = hxsl_Globals.allocID("shadow.proj")
        self.shadowColorId = hxsl_Globals.allocID("shadow.color")
        self.shadowPowerId = hxsl_Globals.allocID("shadow.power")
        self.shadowBiasId = hxsl_Globals.allocID("shadow.bias")

    def draw(self,passes,sort = None):
        super().draw(passes,sort)
        self.ctx.setGlobalID(self.shadowMapId,_hx_AnonObject({'texture': self.dshader.shadowMap__, 'channel': (hxsl_Channel.PackedFloat if ((self.format == h3d_mat_Texture.nativeFormat)) else hxsl_Channel.R)}))
        self.ctx.setGlobalID(self.shadowProjId,self.getShadowProj())
        self.ctx.setGlobalID(self.shadowColorId,self.color)
        self.ctx.setGlobalID(self.shadowPowerId,self.power)
        self.ctx.setGlobalID(self.shadowBiasId,self.bias)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shadowMapId = None
        _hx_o.shadowProjId = None
        _hx_o.shadowColorId = None
        _hx_o.shadowPowerId = None
        _hx_o.shadowBiasId = None
        _hx_o.color = None
h3d_pass_DefaultShadowMap._hx_class = h3d_pass_DefaultShadowMap
_hx_classes["h3d.pass.DefaultShadowMap"] = h3d_pass_DefaultShadowMap


class h3d_pass__HardwarePick_FixedColor(hxsl_Shader):
    _hx_class_name = "h3d.pass._HardwarePick.FixedColor"
    _hx_is_interface = "False"
    __slots__ = ("colorID__", "viewport__")
    _hx_fields = ["colorID__", "viewport__"]
    _hx_methods = ["get_colorID", "set_colorID", "get_viewport", "set_viewport", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.viewport__ = h3d_Vector()
        self.colorID__ = h3d_Vector()
        super().__init__()

    def get_colorID(self):
        return self.colorID__

    def set_colorID(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.colorID__ = _v
                return self.colorID__
            return _hx_local_0()
        return _hx_local_1()

    def get_viewport(self):
        return self.viewport__

    def set_viewport(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.viewport__ = _v
                return self.viewport__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.colorID__
        elif (index1 == 1):
            return self.viewport__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__HardwarePick_FixedColor)
        s.shader = self.shader
        s.colorID__ = self.colorID__
        s.viewport__ = self.viewport__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.colorID__ = None
        _hx_o.viewport__ = None
h3d_pass__HardwarePick_FixedColor._hx_class = h3d_pass__HardwarePick_FixedColor
_hx_classes["h3d.pass._HardwarePick.FixedColor"] = h3d_pass__HardwarePick_FixedColor


class h3d_pass_HardwarePick(h3d_pass_Default):
    _hx_class_name = "h3d.pass.HardwarePick"
    _hx_is_interface = "False"
    __slots__ = ("pickX", "pickY", "fixedColor", "colorID", "texOut", "material", "pickedIndex")
    _hx_fields = ["pickX", "pickY", "fixedColor", "colorID", "texOut", "material", "pickedIndex"]
    _hx_methods = ["dispose", "getOutputs", "drawObject", "nextID", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Default


    def __init__(self):
        self.material = None
        self.texOut = None
        self.colorID = None
        self.pickY = None
        self.pickX = None
        self.pickedIndex = -1
        self.fixedColor = h3d_pass__HardwarePick_FixedColor()
        super().__init__("hwpick")
        self.material = h3d_mat_Pass("")
        _this = self.material
        src = h3d_mat_Blend.One
        dst = h3d_mat_Blend.Zero
        _this.set_blendSrc(src)
        _this.set_blendAlphaSrc(src)
        _this.set_blendDst(dst)
        _this.set_blendAlphaDst(dst)
        self.texOut = h3d_mat_Texture(3,3,[h3d_mat_TextureFlags.Target])
        self.texOut.depthBuffer = h3d_mat_DepthBuffer(3,3)

    def dispose(self):
        super().dispose()
        self.texOut.dispose()
        self.texOut.depthBuffer.dispose()

    def getOutputs(self):
        return [hxsl_Output.Value("output.colorID")]

    def drawObject(self,p):
        super().drawObject(p)
        _this = self.fixedColor.colorID__
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.colorID
            _hx_local_0.colorID = (_hx_local_1 + 1)
            return _hx_local_0.colorID
        c = (-16777216 | _hx_local_2())
        _this.x = ((((c >> 16) & 255)) / 255)
        _this.y = ((((c >> 8) & 255)) / 255)
        _this.z = (((c & 255)) / 255)
        _this.w = ((HxOverrides.rshift(c, 24)) / 255)

    def nextID(self):
        _this = self.fixedColor.colorID__
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.colorID
            _hx_local_0.colorID = (_hx_local_1 + 1)
            return _hx_local_0.colorID
        c = (-16777216 | _hx_local_2())
        _this.x = ((((c >> 16) & 255)) / 255)
        _this.y = ((((c >> 8) & 255)) / 255)
        _this.z = (((c & 255)) / 255)
        _this.w = ((HxOverrides.rshift(c, 24)) / 255)

    def draw(self,passes,sort = None):
        _g_o = passes.current
        while (_g_o is not None):
            tmp = _g_o
            _g_o = _g_o.next
            cur = tmp
            mask = 268435392
            _hx_local_0 = cur._hx_pass
            _hx_local_1 = _hx_local_0.bits
            _hx_local_0.bits = (_hx_local_1 & ~mask)
            _hx_local_0.bits
            _hx_local_2 = cur._hx_pass
            _hx_local_3 = _hx_local_2.bits
            _hx_local_2.bits = (_hx_local_3 | ((self.material.bits & mask)))
            _hx_local_2.bits
        self.colorID = 0
        _this = self.fixedColor.colorID__
        def _hx_local_6():
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.colorID
            _hx_local_4.colorID = (_hx_local_5 + 1)
            return _hx_local_4.colorID
        c = (-16777216 | _hx_local_6())
        _this.x = ((((c >> 16) & 255)) / 255)
        _this.y = ((((c >> 8) & 255)) / 255)
        _this.z = (((c & 255)) / 255)
        _this.w = ((HxOverrides.rshift(c, 24)) / 255)
        _this = self.fixedColor.viewport__
        x = -((((self.pickX * 2) / self.ctx.engine.width) - 1))
        y = (((self.pickY * 2) / self.ctx.engine.height) - 1)
        z = (self.ctx.engine.width / self.texOut.width)
        w = (self.ctx.engine.height / self.texOut.height)
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = w
        self.ctx.engine.pushTarget(self.texOut)
        self.ctx.engine.clear(-16777216,1)
        self.ctx.extraShaders = self.ctx.allocShaderList(self.fixedColor)
        super().draw(passes,sort)
        self.ctx.extraShaders = None
        self.ctx.engine.popTarget()
        _g1_o = passes.current
        while (_g1_o is not None):
            tmp = _g1_o
            _g1_o = _g1_o.next
            cur = tmp
            cur._hx_pass.set_blendSrc(cur._hx_pass.blendSrc)
            cur._hx_pass.set_blendDst(cur._hx_pass.blendDst)
            cur._hx_pass.set_blendOp(cur._hx_pass.blendOp)
            cur._hx_pass.set_blendAlphaSrc(cur._hx_pass.blendAlphaSrc)
            cur._hx_pass.set_blendAlphaDst(cur._hx_pass.blendAlphaDst)
            cur._hx_pass.set_blendAlphaOp(cur._hx_pass.blendAlphaOp)
            cur._hx_pass.colorMask = cur._hx_pass.colorMask
        self.ctx.engine.clear(None,None,0)
        pix = self.texOut.capturePixels()
        self.pickedIndex = (((pix.getPixel((pix.width >> 1),(pix.height >> 1)) & 16777215)) - 1)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pickX = None
        _hx_o.pickY = None
        _hx_o.fixedColor = None
        _hx_o.colorID = None
        _hx_o.texOut = None
        _hx_o.material = None
        _hx_o.pickedIndex = None
h3d_pass_HardwarePick._hx_class = h3d_pass_HardwarePick
_hx_classes["h3d.pass.HardwarePick"] = h3d_pass_HardwarePick


class h3d_pass_PassListIterator:
    _hx_class_name = "h3d.pass.PassListIterator"
    _hx_is_interface = "False"
    __slots__ = ("o",)
    _hx_fields = ["o"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,o):
        self.o = o

    def hasNext(self):
        return (self.o is not None)

    def next(self):
        tmp = self.o
        self.o = self.o.next
        return tmp

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.o = None
h3d_pass_PassListIterator._hx_class = h3d_pass_PassListIterator
_hx_classes["h3d.pass.PassListIterator"] = h3d_pass_PassListIterator


class h3d_pass_PassList:
    _hx_class_name = "h3d.pass.PassList"
    _hx_is_interface = "False"
    __slots__ = ("current", "discarded", "lastDisc")
    _hx_fields = ["current", "discarded", "lastDisc"]
    _hx_methods = ["init", "reset", "save", "load", "isEmpty", "clear", "sort", "filter", "iterator", "getFiltered"]

    def __init__(self,current = None):
        self.current = current
        def _hx_local_0():
            self.lastDisc = None
            return self.lastDisc
        self.discarded = _hx_local_0()

    def init(self,_hx_pass):
        self.current = _hx_pass
        def _hx_local_0():
            self.lastDisc = None
            return self.lastDisc
        self.discarded = _hx_local_0()

    def reset(self):
        if (self.discarded is not None):
            self.lastDisc.next = self.current
            self.current = self.discarded
            def _hx_local_0():
                self.lastDisc = None
                return self.lastDisc
            self.discarded = _hx_local_0()

    def save(self):
        return self.lastDisc

    def load(self,p):
        if (self.lastDisc != p):
            self.lastDisc.next = self.current
            if (p is None):
                self.current = self.discarded
                self.discarded = None
            else:
                self.current = p.next
                p.next = None
            self.lastDisc = p

    def isEmpty(self):
        return (self.current is None)

    def clear(self):
        if (self.current is None):
            return
        if (self.discarded is None):
            self.discarded = self.current
        else:
            self.lastDisc.next = self.current
        p = self.current
        while (p.next is not None):
            p = p.next
        self.lastDisc = p
        self.current = None

    def sort(self,f):
        _hx_list = self.current
        tmp = None
        if (_hx_list is None):
            tmp = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p = None
            q = None
            e = None
            tail = None
            while True:
                p = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p is not None):
                    nmerges = (nmerges + 1)
                    q = p
                    psize = 0
                    _g = 0
                    _g1 = insize
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        elif (((qsize == 0) or ((q is None))) or ((f(p,q) <= 0))):
                            e = p
                            p = p.next
                            psize = (psize - 1)
                        else:
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            tmp = _hx_list
        self.current = tmp

    def filter(self,f):
        head = None
        prev = None
        disc = self.discarded
        discQueue = self.lastDisc
        cur = self.current
        while (cur is not None):
            if f(cur):
                if (head is None):
                    prev = cur
                    head = prev
                else:
                    prev.next = cur
                    prev = cur
            elif (disc is None):
                discQueue = cur
                disc = discQueue
            else:
                discQueue.next = cur
                discQueue = cur
            cur = cur.next
        if (prev is not None):
            prev.next = None
        if (discQueue is not None):
            discQueue.next = None
        self.current = head
        self.discarded = disc
        self.lastDisc = discQueue

    def iterator(self):
        return h3d_pass_PassListIterator(self.current)

    def getFiltered(self):
        return h3d_pass_PassListIterator(self.discarded)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.current = None
        _hx_o.discarded = None
        _hx_o.lastDisc = None
h3d_pass_PassList._hx_class = h3d_pass_PassList
_hx_classes["h3d.pass.PassList"] = h3d_pass_PassList


class h3d_pass_PassObject:
    _hx_class_name = "h3d.pass.PassObject"
    _hx_is_interface = "False"
    __slots__ = ("next", "nextAlloc", "_hx_pass", "obj", "index", "shaders", "shader", "depth", "texture")
    _hx_fields = ["next", "nextAlloc", "pass", "obj", "index", "shaders", "shader", "depth", "texture"]

    def __init__(self):
        self.depth = None
        self.shader = None
        self.shaders = None
        self.index = None
        self.obj = None
        self._hx_pass = None
        self.nextAlloc = None
        self.next = None
        self.texture = 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.nextAlloc = None
        _hx_o._hx_pass = None
        _hx_o.obj = None
        _hx_o.index = None
        _hx_o.shaders = None
        _hx_o.shader = None
        _hx_o.depth = None
        _hx_o.texture = None
h3d_pass_PassObject._hx_class = h3d_pass_PassObject
_hx_classes["h3d.pass.PassObject"] = h3d_pass_PassObject


class h3d_pass_ShaderManager:
    _hx_class_name = "h3d.pass.ShaderManager"
    _hx_is_interface = "False"
    __slots__ = ("globals", "shaderCache", "currentOutput")
    _hx_fields = ["globals", "shaderCache", "currentOutput"]
    _hx_methods = ["setOutput", "fillRec", "shaderInfo", "getPtr", "getParamValue", "fillGlobals", "fillParams", "compileShaders"]
    _hx_statics = ["STRICT"]

    def __init__(self,output = None):
        self.shaderCache = hxsl_Cache.get()
        self.globals = hxsl_Globals()
        self.currentOutput = hxsl_ShaderList(None)
        self.setOutput(output)

    def setOutput(self,output = None):
        if (output is None):
            output = [hxsl_Output.Value("output.color")]
        self.currentOutput.s = self.shaderCache.getLinkShader(output)

    def fillRec(self,v,_hx_type,out,pos):
        tmp = _hx_type.index
        if (tmp == 1):
            val = v
            out[pos] = val
            return 1
        elif (tmp == 3):
            val = v
            out[pos] = val
            return 1
        elif (tmp == 5):
            _g = _hx_type.params[1]
            n = _hx_type.params[0]
            v1 = v
            index = pos
            pos = (pos + 1)
            val = v1.x
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = v1.y
            out[index] = val
            n1 = n
            if (n1 == 3):
                index = pos
                pos = (pos + 1)
                val = v1.z
                out[index] = val
            elif (n1 == 4):
                index = pos
                pos = (pos + 1)
                val = v1.z
                out[index] = val
                index = pos
                pos = (pos + 1)
                val = v1.w
                out[index] = val
            else:
                pass
            return n
        elif (tmp == 6):
            m = v
            index = pos
            pos = (pos + 1)
            val = m._11
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._21
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._31
            out[index] = val
            index = pos
            pos = (pos + 1)
            out[index] = 0
            index = pos
            pos = (pos + 1)
            val = m._12
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._22
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._32
            out[index] = val
            index = pos
            pos = (pos + 1)
            out[index] = 0
            index = pos
            pos = (pos + 1)
            val = m._13
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._23
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._33
            out[index] = val
            index = pos
            pos = (pos + 1)
            out[index] = 0
            return 12
        elif (tmp == 7):
            m = v
            index = pos
            pos = (pos + 1)
            val = m._11
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._21
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._31
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._41
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._12
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._22
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._32
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._42
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._13
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._23
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._33
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._43
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._14
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._24
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._34
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._44
            out[index] = val
            return 16
        elif (tmp == 8):
            m = v
            index = pos
            pos = (pos + 1)
            val = m._11
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._21
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._31
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._41
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._12
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._22
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._32
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._42
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._13
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._23
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._33
            out[index] = val
            index = pos
            pos = (pos + 1)
            val = m._43
            out[index] = val
            return 12
        elif (tmp == 13):
            vl = _hx_type.params[0]
            tot = 0
            _g = 0
            while (_g < len(vl)):
                vv = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                tot = (tot + self.fillRec(Reflect.field(v,vv.name),vv.type,out,(pos + tot)))
            return tot
        elif (tmp == 15):
            _g = _hx_type.params[0]
            _g1 = _hx_type.params[1]
            tmp = _g.index
            if (tmp == 3):
                if (_g1.index == 0):
                    _hx_len = _g1.params[0]
                    v1 = v
                    size = 0
                    count = (len(v1) if ((len(v1) < _hx_len)) else _hx_len)
                    _g2 = 0
                    _g3 = count
                    while (_g2 < _g3):
                        i = _g2
                        _g2 = (_g2 + 1)
                        index = pos
                        pos = (pos + 1)
                        val = (v1[i] if i >= 0 and i < len(v1) else None)
                        out[index] = val
                    return _hx_len
                else:
                    raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))
            elif (tmp == 5):
                if (_g.params[0] == 4):
                    if (_g.params[1].index == 1):
                        if (_g1.index == 0):
                            _hx_len = _g1.params[0]
                            v1 = v
                            _g2 = 0
                            _g3 = _hx_len
                            while (_g2 < _g3):
                                i = _g2
                                _g2 = (_g2 + 1)
                                n = (v1[i] if i >= 0 and i < len(v1) else None)
                                if (n is None):
                                    break
                                index = pos
                                pos = (pos + 1)
                                val = n.x
                                out[index] = val
                                index1 = pos
                                pos = (pos + 1)
                                val1 = n.y
                                out[index1] = val1
                                index2 = pos
                                pos = (pos + 1)
                                val2 = n.z
                                out[index2] = val2
                                index3 = pos
                                pos = (pos + 1)
                                val3 = n.w
                                out[index3] = val3
                            return (_hx_len * 4)
                        else:
                            raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))
                    elif (_g1.index == 0):
                        t = _g
                        _hx_len = _g1.params[0]
                        v1 = v
                        size = 0
                        _g2 = 0
                        _g3 = _hx_len
                        while (_g2 < _g3):
                            i = _g2
                            _g2 = (_g2 + 1)
                            n = (v1[i] if i >= 0 and i < len(v1) else None)
                            if (n is None):
                                break
                            size = self.fillRec(n,t,out,pos)
                            pos = (pos + size)
                        return (_hx_len * size)
                    else:
                        raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))
                elif (_g1.index == 0):
                    t = _g
                    _hx_len = _g1.params[0]
                    v1 = v
                    size = 0
                    _g2 = 0
                    _g3 = _hx_len
                    while (_g2 < _g3):
                        i = _g2
                        _g2 = (_g2 + 1)
                        n = (v1[i] if i >= 0 and i < len(v1) else None)
                        if (n is None):
                            break
                        size = self.fillRec(n,t,out,pos)
                        pos = (pos + size)
                    return (_hx_len * size)
                else:
                    raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))
            elif (tmp == 8):
                if (_g1.index == 0):
                    _hx_len = _g1.params[0]
                    v1 = v
                    _g2 = 0
                    _g3 = _hx_len
                    while (_g2 < _g3):
                        i = _g2
                        _g2 = (_g2 + 1)
                        m = (v1[i] if i >= 0 and i < len(v1) else None)
                        if (m is None):
                            break
                        index = pos
                        pos = (pos + 1)
                        val = m._11
                        out[index] = val
                        index1 = pos
                        pos = (pos + 1)
                        val1 = m._21
                        out[index1] = val1
                        index2 = pos
                        pos = (pos + 1)
                        val2 = m._31
                        out[index2] = val2
                        index3 = pos
                        pos = (pos + 1)
                        val3 = m._41
                        out[index3] = val3
                        index4 = pos
                        pos = (pos + 1)
                        val4 = m._12
                        out[index4] = val4
                        index5 = pos
                        pos = (pos + 1)
                        val5 = m._22
                        out[index5] = val5
                        index6 = pos
                        pos = (pos + 1)
                        val6 = m._32
                        out[index6] = val6
                        index7 = pos
                        pos = (pos + 1)
                        val7 = m._42
                        out[index7] = val7
                        index8 = pos
                        pos = (pos + 1)
                        val8 = m._13
                        out[index8] = val8
                        index9 = pos
                        pos = (pos + 1)
                        val9 = m._23
                        out[index9] = val9
                        index10 = pos
                        pos = (pos + 1)
                        val10 = m._33
                        out[index10] = val10
                        index11 = pos
                        pos = (pos + 1)
                        val11 = m._43
                        out[index11] = val11
                    return (_hx_len * 12)
                else:
                    raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))
            elif (_g1.index == 0):
                t = _g
                _hx_len = _g1.params[0]
                v1 = v
                size = 0
                _g = 0
                _g1 = _hx_len
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    n = (v1[i] if i >= 0 and i < len(v1) else None)
                    if (n is None):
                        break
                    size = self.fillRec(n,t,out,pos)
                    pos = (pos + size)
                return (_hx_len * size)
            else:
                raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))
        else:
            raise haxe_Exception.thrown(("assert " + Std.string(_hx_type)))

    def shaderInfo(self,shaders,path):
        _this = path.split(".")
        name = (None if ((len(_this) == 0)) else _this.pop())
        while (shaders is not None):
            inst = shaders.s.instance
            _g = 0
            _g1 = inst.shader.vars
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v.name == name):
                    return shaders.s.toString()
            shaders = shaders.next
        return "(not found)"

    def getPtr(self,data):
        return data

    def getParamValue(self,p,shaders,opt = None):
        if (opt is None):
            opt = False
        if (p.perObjectGlobal is not None):
            v = self.globals.map.h.get(p.perObjectGlobal.gid,None)
            if (v is None):
                raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(self.shaderInfo(shaders,p.perObjectGlobal.path))))
            _g = p.type
            tmp = None
            if (_g.index == 17):
                _g1 = _g.params[0]
                tmp = True
            else:
                tmp = False
            if tmp:
                return Reflect.field(v,"texture")
            return v
        si = shaders
        n = p.instance
        while True:
            n = (n - 1)
            tmp = n
            if (not ((tmp > 0))):
                break
            si = si.next
        v = si.s.getParamValue(p.index)
        if ((v is None) and (not opt)):
            raise haxe_Exception.thrown(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(p.name)))
        return v

    def fillGlobals(self,buf,s):
        _gthis = self
        s1 = s.vertex
        g = s1.globals
        ptr = buf.vertex.globals
        while (g is not None):
            v = _gthis.globals.map.h.get(g.gid,None)
            if (v is None):
                if (g.path == "__consts__"):
                    _gthis.fillRec(s1.consts,g.type,ptr,g.pos)
                    g = g.next
                    continue
                raise haxe_Exception.thrown(("Missing global value " + HxOverrides.stringOrNull(g.path)))
            _gthis.fillRec(v,g.type,ptr,g.pos)
            g = g.next
        s1 = s.fragment
        g = s1.globals
        ptr = buf.fragment.globals
        while (g is not None):
            v = _gthis.globals.map.h.get(g.gid,None)
            if (v is None):
                if (g.path == "__consts__"):
                    _gthis.fillRec(s1.consts,g.type,ptr,g.pos)
                    g = g.next
                    continue
                raise haxe_Exception.thrown(("Missing global value " + HxOverrides.stringOrNull(g.path)))
            _gthis.fillRec(v,g.type,ptr,g.pos)
            g = g.next

    def fillParams(self,buf,s,shaders):
        _gthis = self
        curInstance = -1
        curInstanceValue = None
        buf1 = buf.vertex
        s1 = s.vertex
        p = s1.params
        ptr = buf1.params
        while (p is not None):
            v = None
            if (p.perObjectGlobal is None):
                if (p.type == hxsl_Type.TFloat):
                    index = p.instance
                    i = None
                    if (curInstance == index):
                        i = curInstanceValue
                    else:
                        si = shaders
                        curInstance = index
                        while True:
                            index = (index - 1)
                            i1 = index
                            if (not ((i1 > 0))):
                                break
                            si = si.next
                        curInstanceValue = si.s
                        i = curInstanceValue
                    index1 = p.pos
                    val = i.getParamFloatValue(p.index)
                    ptr[index1] = val
                    p = p.next
                    continue
                index2 = p.instance
                v1 = None
                if (curInstance == index2):
                    v1 = curInstanceValue
                else:
                    si1 = shaders
                    curInstance = index2
                    while True:
                        index2 = (index2 - 1)
                        v2 = index2
                        if (not ((v2 > 0))):
                            break
                        si1 = si1.next
                    curInstanceValue = si1.s
                    v1 = curInstanceValue
                v = v1.getParamValue(p.index)
                if (v is None):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(curInstanceValue)) + ".") + HxOverrides.stringOrNull(p.name)))
            elif (p.perObjectGlobal is not None):
                v3 = _gthis.globals.map.h.get(p.perObjectGlobal.gid,None)
                if (v3 is None):
                    raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p.perObjectGlobal.path))))
                _g = p.type
                v4 = None
                if (_g.index == 17):
                    _g1 = _g.params[0]
                    v4 = True
                else:
                    v4 = False
                v = (Reflect.field(v3,"texture") if v4 else v3)
            else:
                si2 = shaders
                n = p.instance
                while True:
                    n = (n - 1)
                    v5 = n
                    if (not ((v5 > 0))):
                        break
                    si2 = si2.next
                v6 = si2.s.getParamValue(p.index)
                if (v6 is None):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(si2.s)) + ".") + HxOverrides.stringOrNull(p.name)))
                v = v6
            _gthis.fillRec(v,p.type,ptr,p.pos)
            p = p.next
        tid = 0
        p = s1.textures
        while (p is not None):
            opt = (not h3d_pass_ShaderManager.STRICT)
            if (opt is None):
                opt = False
            t = None
            if (p.perObjectGlobal is not None):
                v = _gthis.globals.map.h.get(p.perObjectGlobal.gid,None)
                if (v is None):
                    raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p.perObjectGlobal.path))))
                _g = p.type
                t1 = None
                if (_g.index == 17):
                    _g1 = _g.params[0]
                    t1 = True
                else:
                    t1 = False
                t = (Reflect.field(v,"texture") if t1 else v)
            else:
                si = shaders
                n = p.instance
                while True:
                    n = (n - 1)
                    t2 = n
                    if (not ((t2 > 0))):
                        break
                    si = si.next
                v1 = si.s.getParamValue(p.index)
                if ((v1 is None) and (not opt)):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(p.name)))
                t = v1
            if (p.pos < 0):
                arr = t
                _g2 = 0
                _g3 = -p.pos
                while (_g2 < _g3):
                    i = _g2
                    _g2 = (_g2 + 1)
                    index = tid
                    tid = (tid + 1)
                    val = (arr[i] if i >= 0 and i < len(arr) else None)
                    buf1.tex[index] = val
            else:
                index1 = tid
                tid = (tid + 1)
                val1 = t
                buf1.tex[index1] = val1
            p = p.next
        p = s1.buffers
        bid = 0
        while (p is not None):
            opt = (not h3d_pass_ShaderManager.STRICT)
            if (opt is None):
                opt = False
            b = None
            if (p.perObjectGlobal is not None):
                v = _gthis.globals.map.h.get(p.perObjectGlobal.gid,None)
                if (v is None):
                    raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p.perObjectGlobal.path))))
                _g = p.type
                b1 = None
                if (_g.index == 17):
                    _g1 = _g.params[0]
                    b1 = True
                else:
                    b1 = False
                b = (Reflect.field(v,"texture") if b1 else v)
            else:
                si = shaders
                n = p.instance
                while True:
                    n = (n - 1)
                    b2 = n
                    if (not ((b2 > 0))):
                        break
                    si = si.next
                v1 = si.s.getParamValue(p.index)
                if ((v1 is None) and (not opt)):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(p.name)))
                b = v1
            index = bid
            bid = (bid + 1)
            buf1.buffers[index] = b
            p = p.next
        buf1 = buf.fragment
        s1 = s.fragment
        p = s1.params
        ptr = buf1.params
        while (p is not None):
            v = None
            if (p.perObjectGlobal is None):
                if (p.type == hxsl_Type.TFloat):
                    index = p.instance
                    i = None
                    if (curInstance == index):
                        i = curInstanceValue
                    else:
                        si = shaders
                        curInstance = index
                        while True:
                            index = (index - 1)
                            i1 = index
                            if (not ((i1 > 0))):
                                break
                            si = si.next
                        curInstanceValue = si.s
                        i = curInstanceValue
                    index1 = p.pos
                    val = i.getParamFloatValue(p.index)
                    ptr[index1] = val
                    p = p.next
                    continue
                index2 = p.instance
                v1 = None
                if (curInstance == index2):
                    v1 = curInstanceValue
                else:
                    si1 = shaders
                    curInstance = index2
                    while True:
                        index2 = (index2 - 1)
                        v2 = index2
                        if (not ((v2 > 0))):
                            break
                        si1 = si1.next
                    curInstanceValue = si1.s
                    v1 = curInstanceValue
                v = v1.getParamValue(p.index)
                if (v is None):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(curInstanceValue)) + ".") + HxOverrides.stringOrNull(p.name)))
            elif (p.perObjectGlobal is not None):
                v3 = _gthis.globals.map.h.get(p.perObjectGlobal.gid,None)
                if (v3 is None):
                    raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p.perObjectGlobal.path))))
                _g = p.type
                v4 = None
                if (_g.index == 17):
                    _g1 = _g.params[0]
                    v4 = True
                else:
                    v4 = False
                v = (Reflect.field(v3,"texture") if v4 else v3)
            else:
                si2 = shaders
                n = p.instance
                while True:
                    n = (n - 1)
                    v5 = n
                    if (not ((v5 > 0))):
                        break
                    si2 = si2.next
                v6 = si2.s.getParamValue(p.index)
                if (v6 is None):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(si2.s)) + ".") + HxOverrides.stringOrNull(p.name)))
                v = v6
            _gthis.fillRec(v,p.type,ptr,p.pos)
            p = p.next
        tid = 0
        p = s1.textures
        while (p is not None):
            opt = (not h3d_pass_ShaderManager.STRICT)
            if (opt is None):
                opt = False
            t = None
            if (p.perObjectGlobal is not None):
                v = _gthis.globals.map.h.get(p.perObjectGlobal.gid,None)
                if (v is None):
                    raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p.perObjectGlobal.path))))
                _g = p.type
                t1 = None
                if (_g.index == 17):
                    _g1 = _g.params[0]
                    t1 = True
                else:
                    t1 = False
                t = (Reflect.field(v,"texture") if t1 else v)
            else:
                si = shaders
                n = p.instance
                while True:
                    n = (n - 1)
                    t2 = n
                    if (not ((t2 > 0))):
                        break
                    si = si.next
                v1 = si.s.getParamValue(p.index)
                if ((v1 is None) and (not opt)):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(p.name)))
                t = v1
            if (p.pos < 0):
                arr = t
                _g2 = 0
                _g3 = -p.pos
                while (_g2 < _g3):
                    i = _g2
                    _g2 = (_g2 + 1)
                    index = tid
                    tid = (tid + 1)
                    val = (arr[i] if i >= 0 and i < len(arr) else None)
                    buf1.tex[index] = val
            else:
                index1 = tid
                tid = (tid + 1)
                val1 = t
                buf1.tex[index1] = val1
            p = p.next
        p = s1.buffers
        bid = 0
        while (p is not None):
            opt = (not h3d_pass_ShaderManager.STRICT)
            if (opt is None):
                opt = False
            b = None
            if (p.perObjectGlobal is not None):
                v = _gthis.globals.map.h.get(p.perObjectGlobal.gid,None)
                if (v is None):
                    raise haxe_Exception.thrown(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p.perObjectGlobal.path))))
                _g = p.type
                b1 = None
                if (_g.index == 17):
                    _g1 = _g.params[0]
                    b1 = True
                else:
                    b1 = False
                b = (Reflect.field(v,"texture") if b1 else v)
            else:
                si = shaders
                n = p.instance
                while True:
                    n = (n - 1)
                    b2 = n
                    if (not ((b2 > 0))):
                        break
                    si = si.next
                v1 = si.s.getParamValue(p.index)
                if ((v1 is None) and (not opt)):
                    raise haxe_Exception.thrown(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(p.name)))
                b = v1
            index = bid
            bid = (bid + 1)
            buf1.buffers[index] = b
            p = p.next

    def compileShaders(self,shaders,batchMode = None):
        if (batchMode is None):
            batchMode = False
        self.globals.maxChannels = 0
        _g_l = shaders
        _g_last = None
        while (_g_l != _g_last):
            s = _g_l.s
            _g_l = _g_l.next
            s1 = s
            s1.updateConstants(self.globals)
        self.currentOutput.next = shaders
        s = self.shaderCache.link(self.currentOutput,batchMode)
        self.currentOutput.next = None
        return s

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.globals = None
        _hx_o.shaderCache = None
        _hx_o.currentOutput = None
h3d_pass_ShaderManager._hx_class = h3d_pass_ShaderManager
_hx_classes["h3d.pass.ShaderManager"] = h3d_pass_ShaderManager

class h3d_pass_RenderMode(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.pass.RenderMode"
    _hx_constructs = ["None", "Static", "Dynamic", "Mixed"]
h3d_pass_RenderMode._hx_None = h3d_pass_RenderMode("None", 0, ())
h3d_pass_RenderMode.Static = h3d_pass_RenderMode("Static", 1, ())
h3d_pass_RenderMode.Dynamic = h3d_pass_RenderMode("Dynamic", 2, ())
h3d_pass_RenderMode.Mixed = h3d_pass_RenderMode("Mixed", 3, ())
h3d_pass_RenderMode._hx_class = h3d_pass_RenderMode
_hx_classes["h3d.pass.RenderMode"] = h3d_pass_RenderMode

class h3d_pass_ShadowSamplingKind(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.pass.ShadowSamplingKind"
    _hx_constructs = ["None", "PCF", "ESM"]
h3d_pass_ShadowSamplingKind._hx_None = h3d_pass_ShadowSamplingKind("None", 0, ())
h3d_pass_ShadowSamplingKind.PCF = h3d_pass_ShadowSamplingKind("PCF", 1, ())
h3d_pass_ShadowSamplingKind.ESM = h3d_pass_ShadowSamplingKind("ESM", 2, ())
h3d_pass_ShadowSamplingKind._hx_class = h3d_pass_ShadowSamplingKind
_hx_classes["h3d.pass.ShadowSamplingKind"] = h3d_pass_ShadowSamplingKind


class h3d_pass_SortByMaterial:
    _hx_class_name = "h3d.pass.SortByMaterial"
    _hx_is_interface = "False"
    __slots__ = ("shaderCount", "textureCount", "shaderIdMap", "textureIdMap")
    _hx_fields = ["shaderCount", "textureCount", "shaderIdMap", "textureIdMap"]
    _hx_methods = ["sort"]

    def __init__(self):
        self.textureCount = 1
        self.shaderCount = 1
        self.shaderIdMap = []
        self.textureIdMap = []

    def sort(self,passes):
        _gthis = self
        shaderStart = self.shaderCount
        textureStart = self.textureCount
        _g_o = passes.current
        while (_g_o is not None):
            tmp = _g_o
            _g_o = _g_o.next
            p = tmp
            if (python_internal_ArrayImpl._get(self.shaderIdMap, p.shader.id) < shaderStart):
                def _hx_local_2():
                    _hx_local_0 = self
                    _hx_local_1 = _hx_local_0.shaderCount
                    _hx_local_0.shaderCount = (_hx_local_1 + 1)
                    return _hx_local_1
                python_internal_ArrayImpl._set(self.shaderIdMap, p.shader.id, _hx_local_2())
            if (python_internal_ArrayImpl._get(self.textureIdMap, p.texture) < textureStart):
                def _hx_local_5():
                    _hx_local_3 = self
                    _hx_local_4 = _hx_local_3.textureCount
                    _hx_local_3.textureCount = (_hx_local_4 + 1)
                    return _hx_local_4
                python_internal_ArrayImpl._set(self.textureIdMap, p.texture, _hx_local_5())
        _hx_list = passes.current
        tmp = None
        if (_hx_list is None):
            tmp = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p = None
            q = None
            e = None
            tail = None
            while True:
                p = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p is not None):
                    nmerges = (nmerges + 1)
                    q = p
                    psize = 0
                    _g = 0
                    _g1 = insize
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        else:
                            tmp1 = None
                            if (not (((qsize == 0) or ((q is None))))):
                                d = (python_internal_ArrayImpl._get(_gthis.shaderIdMap, p.shader.id) - python_internal_ArrayImpl._get(_gthis.shaderIdMap, q.shader.id))
                                tmp1 = (((d if ((d != 0)) else (python_internal_ArrayImpl._get(_gthis.textureIdMap, p.texture) - python_internal_ArrayImpl._get(_gthis.textureIdMap, q.texture)))) <= 0)
                            else:
                                tmp1 = True
                            if tmp1:
                                e = p
                                p = p.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            tmp = _hx_list
        passes.current = tmp

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shaderCount = None
        _hx_o.textureCount = None
        _hx_o.shaderIdMap = None
        _hx_o.textureIdMap = None
h3d_pass_SortByMaterial._hx_class = h3d_pass_SortByMaterial
_hx_classes["h3d.pass.SortByMaterial"] = h3d_pass_SortByMaterial


class h3d_prim_BigPrimitive(h3d_prim_Primitive):
    _hx_class_name = "h3d.prim.BigPrimitive"
    _hx_is_interface = "False"
    __slots__ = ("isRaw", "stride", "buffers", "allIndexes", "tmpBuf", "tmpIdx", "bounds", "bufPos", "idxPos", "startIndex", "flushing", "hasTangents", "isStatic")
    _hx_fields = ["isRaw", "stride", "buffers", "allIndexes", "tmpBuf", "tmpIdx", "bounds", "bufPos", "idxPos", "startIndex", "flushing", "hasTangents", "isStatic"]
    _hx_methods = ["begin", "addPoint", "addBounds", "addVertexValue", "addIndex", "triCount", "vertexCount", "flush", "render", "getBounds", "dispose", "clear", "add", "addSub"]
    _hx_statics = ["PREV_BUFFER", "PREV_INDEX"]
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self,stride,isRaw = None):
        if (isRaw is None):
            isRaw = False
        self.flushing = None
        self.bounds = None
        self.tmpIdx = None
        self.tmpBuf = None
        self.allIndexes = None
        self.buffers = None
        self.stride = None
        self.isRaw = None
        self.isStatic = True
        self.hasTangents = False
        self.startIndex = 0
        self.idxPos = 0
        self.bufPos = 0
        super().__init__()
        self.isRaw = isRaw
        self.buffers = []
        self.allIndexes = []
        self.bounds = h3d_col_Bounds()
        self.stride = stride
        if (stride < 3):
            raise haxe_Exception.thrown("Minimum stride = 3")

    def begin(self,vcount,icount):
        x = (self.bufPos / self.stride)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        self.startIndex = tmp
        if ((self.startIndex + vcount) >= 65535):
            if (vcount >= 65535):
                raise haxe_Exception.thrown("Too many vertices in begin()")
            self.flush()
        if (self.tmpBuf is None):
            self.tmpBuf = h3d_prim_BigPrimitive.PREV_BUFFER
            if (self.tmpBuf is None):
                this1 = list()
                self.tmpBuf = this1
            else:
                h3d_prim_BigPrimitive.PREV_BUFFER = None
            if self.isStatic:
                this1 = self.tmpBuf
                v = (65535 * self.stride)
                if (v > len(this1)):
                    python_internal_ArrayImpl._set(this1, (v - 1), 0.)
        if (not self.isStatic):
            this1 = self.tmpBuf
            v = ((vcount * self.stride) + self.bufPos)
            if (v > len(this1)):
                python_internal_ArrayImpl._set(this1, (v - 1), 0.)
        if (self.tmpIdx is None):
            self.tmpIdx = h3d_prim_BigPrimitive.PREV_INDEX
            if (self.tmpIdx is None):
                this1 = list()
                self.tmpIdx = this1
            else:
                h3d_prim_BigPrimitive.PREV_INDEX = None
        if ((self.idxPos + icount) > len(self.tmpIdx)):
            size = (1024 if ((len(self.tmpIdx) == 0)) else len(self.tmpIdx))
            req = (self.idxPos + icount)
            while (size < req):
                size = (size << 1)
            this1 = self.tmpIdx
            if (size > len(this1)):
                python_internal_ArrayImpl._set(this1, (size - 1), 0)

    def addPoint(self,x,y,z):
        key = self.bufPos
        self.bufPos = (self.bufPos + 1)
        python_internal_ArrayImpl._set(self.tmpBuf, key, x)
        key = self.bufPos
        self.bufPos = (self.bufPos + 1)
        python_internal_ArrayImpl._set(self.tmpBuf, key, y)
        key = self.bufPos
        self.bufPos = (self.bufPos + 1)
        python_internal_ArrayImpl._set(self.tmpBuf, key, z)
        _this = self.bounds
        if (x < _this.xMin):
            _this.xMin = x
        if (x > _this.xMax):
            _this.xMax = x
        if (y < _this.yMin):
            _this.yMin = y
        if (y > _this.yMax):
            _this.yMax = y
        if (z < _this.zMin):
            _this.zMin = z
        if (z > _this.zMax):
            _this.zMax = z

    def addBounds(self,x,y,z):
        _this = self.bounds
        if (x < _this.xMin):
            _this.xMin = x
        if (x > _this.xMax):
            _this.xMax = x
        if (y < _this.yMin):
            _this.yMin = y
        if (y > _this.yMax):
            _this.yMax = y
        if (z < _this.zMin):
            _this.zMin = z
        if (z > _this.zMax):
            _this.zMax = z

    def addVertexValue(self,v):
        key = self.bufPos
        self.bufPos = (self.bufPos + 1)
        python_internal_ArrayImpl._set(self.tmpBuf, key, v)

    def addIndex(self,i):
        key = self.idxPos
        self.idxPos = (self.idxPos + 1)
        python_internal_ArrayImpl._set(self.tmpIdx, key, (i + self.startIndex))

    def triCount(self):
        count = 0
        _g = 0
        _g1 = self.allIndexes
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            count = (count + i.count)
        count = (count + self.idxPos)
        tmp = None
        try:
            tmp = int((count / 3))
        except BaseException as _g:
            None
            tmp = None
        return tmp

    def vertexCount(self):
        count = 0
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            count = (count + b.vertices)
        x = (self.bufPos / self.stride)
        count1 = None
        try:
            count1 = int(x)
        except BaseException as _g:
            None
            count1 = None
        count = (count + count1)
        return count

    def flush(self):
        if (self.tmpBuf is not None):
            if ((self.bufPos > 0) and ((self.idxPos > 0))):
                self.flushing = True
                b = self.tmpBuf
                b1 = self.stride
                x = (self.bufPos / self.stride)
                b2 = None
                try:
                    b2 = int(x)
                except BaseException as _g:
                    None
                    b2 = None
                b3 = h3d_Buffer.ofSubFloats(b,b1,b2)
                if self.isRaw:
                    b3.flags = (b3.flags | ((1 << h3d_BufferFlag.RawFormat.index)))
                _this = self.buffers
                _this.append(b3)
                idx = h3d_Indexes.alloc(self.tmpIdx,0,self.idxPos)
                _this = self.allIndexes
                _this.append(idx)
                self.flushing = False
            if ((h3d_prim_BigPrimitive.PREV_BUFFER is None) or ((len(h3d_prim_BigPrimitive.PREV_BUFFER) < len(self.tmpBuf)))):
                h3d_prim_BigPrimitive.PREV_BUFFER = self.tmpBuf
            if ((h3d_prim_BigPrimitive.PREV_INDEX is None) or ((len(h3d_prim_BigPrimitive.PREV_INDEX) < len(self.tmpIdx)))):
                h3d_prim_BigPrimitive.PREV_INDEX = self.tmpIdx
            self.tmpBuf = None
            self.tmpIdx = None
            self.bufPos = 0
            self.idxPos = 0
            self.startIndex = 0

    def render(self,engine):
        if (self.tmpBuf is not None):
            self.flush()
        _g = 0
        _g1 = len(self.buffers)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            engine.renderIndexed((self.buffers[i] if i >= 0 and i < len(self.buffers) else None),(self.allIndexes[i] if i >= 0 and i < len(self.allIndexes) else None))

    def getBounds(self):
        return self.bounds

    def dispose(self):
        self.clear()

    def clear(self):
        if self.flushing:
            raise haxe_Exception.thrown("Cannot clear() BigPrimitive while it's flushing")
        _this = self.bounds
        _this.xMin = 1e20
        _this.xMax = -1e20
        _this.yMin = 1e20
        _this.yMax = -1e20
        _this.zMin = 1e20
        _this.zMax = -1e20
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b.dispose()
        _g = 0
        _g1 = self.allIndexes
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            i.dispose()
        self.buffers = []
        self.allIndexes = []
        self.bufPos = 0
        self.idxPos = 0
        self.tmpBuf = None
        self.tmpIdx = None

    def add(self,buf,idx,dx = None,dy = None,dz = None,rotation = None,scale = None,stride = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        if (dz is None):
            dz = 0.
        if (rotation is None):
            rotation = 0.
        if (scale is None):
            scale = 1.
        if (stride is None):
            stride = -1
        x = (len(buf) / ((self.stride if ((stride < 0)) else stride)))
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        x = (len(idx) / 3)
        tmp1 = None
        try:
            tmp1 = int(x)
        except BaseException as _g:
            None
            tmp1 = None
        self.addSub(buf,idx,0,0,tmp,tmp1,dx,dy,dz,rotation,scale,stride)

    def addSub(self,buf,idx,startVert,startTri,nvert,triCount,dx = None,dy = None,dz = None,rotation = None,scale = None,stride = None,deltaU = None,deltaV = None,color = None,mat = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        if (dz is None):
            dz = 0.
        if (rotation is None):
            rotation = 0.
        if (scale is None):
            scale = 1.
        if (stride is None):
            stride = -1
        if (deltaU is None):
            deltaU = 0.
        if (deltaV is None):
            deltaV = 0.
        if (color is None):
            color = 1.
        if (stride < 0):
            stride = self.stride
        if (stride < self.stride):
            raise haxe_Exception.thrown((("only stride >= " + Std.string(self.stride)) + " allowed"))
        self.begin(nvert,(triCount * 3))
        start = self.startIndex
        cr = (Math.NaN if (((rotation == Math.POSITIVE_INFINITY) or ((rotation == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(rotation))
        sr = (Math.NaN if (((rotation == Math.POSITIVE_INFINITY) or ((rotation == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(rotation))
        pos = self.bufPos
        tmpBuf = self.tmpBuf
        _g = 0
        _g1 = nvert
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p = (((i + startVert)) * stride)
            key = p
            p = (p + 1)
            x = python_internal_ArrayImpl._get(buf, key)
            key1 = p
            p = (p + 1)
            y = python_internal_ArrayImpl._get(buf, key1)
            key2 = p
            p = (p + 1)
            z = python_internal_ArrayImpl._get(buf, key2)
            if (mat is not None):
                x1 = x
                y1 = y
                z1 = z
                if (z1 is None):
                    z1 = 0.
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                pt_x = x1
                pt_y = y1
                pt_z = z1
                px = ((((pt_x * mat._11) + ((pt_y * mat._21))) + ((pt_z * mat._31))) + mat._41)
                py = ((((pt_x * mat._12) + ((pt_y * mat._22))) + ((pt_z * mat._32))) + mat._42)
                pz = ((((pt_x * mat._13) + ((pt_y * mat._23))) + ((pt_z * mat._33))) + mat._43)
                pt_x = px
                pt_y = py
                pt_z = pz
                key3 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key3, pt_x)
                key4 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key4, pt_y)
                key5 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key5, pt_z)
                _this = self.bounds
                if (pt_x < _this.xMin):
                    _this.xMin = pt_x
                if (pt_x > _this.xMax):
                    _this.xMax = pt_x
                if (pt_y < _this.yMin):
                    _this.yMin = pt_y
                if (pt_y > _this.yMax):
                    _this.yMax = pt_y
                if (pt_z < _this.zMin):
                    _this.zMin = pt_z
                if (pt_z > _this.zMax):
                    _this.zMax = pt_z
            else:
                tx = ((((x * cr) - ((y * sr)))) * scale)
                ty = ((((x * sr) + ((y * cr)))) * scale)
                vx = (dx + tx)
                vy = (dy + ty)
                vz = (dz + ((z * scale)))
                key6 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key6, vx)
                key7 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key7, vy)
                key8 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key8, vz)
                _this1 = self.bounds
                if (vx < _this1.xMin):
                    _this1.xMin = vx
                if (vx > _this1.xMax):
                    _this1.xMax = vx
                if (vy < _this1.yMin):
                    _this1.yMin = vy
                if (vy > _this1.yMax):
                    _this1.yMax = vy
                if (vz < _this1.zMin):
                    _this1.zMin = vz
                if (vz > _this1.zMax):
                    _this1.zMax = vz
            if (self.stride >= 6):
                key9 = p
                p = (p + 1)
                nx = python_internal_ArrayImpl._get(buf, key9)
                key10 = p
                p = (p + 1)
                ny = python_internal_ArrayImpl._get(buf, key10)
                key11 = p
                p = (p + 1)
                nz = python_internal_ArrayImpl._get(buf, key11)
                if (mat is not None):
                    x2 = nx
                    y2 = ny
                    z2 = nz
                    if (z2 is None):
                        z2 = 0.
                    if (y2 is None):
                        y2 = 0.
                    if (x2 is None):
                        x2 = 0.
                    pt_x1 = x2
                    pt_y1 = y2
                    pt_z1 = z2
                    px1 = (((pt_x1 * mat._11) + ((pt_y1 * mat._21))) + ((pt_z1 * mat._31)))
                    py1 = (((pt_x1 * mat._12) + ((pt_y1 * mat._22))) + ((pt_z1 * mat._32)))
                    pz1 = (((pt_x1 * mat._13) + ((pt_y1 * mat._23))) + ((pt_z1 * mat._33)))
                    pt_x1 = px1
                    pt_y1 = py1
                    pt_z1 = pz1
                    k = (((pt_x1 * pt_x1) + ((pt_y1 * pt_y1))) + ((pt_z1 * pt_z1)))
                    if (k < 1e-10):
                        k = 0
                    else:
                        k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
                    pt_x1 = (pt_x1 * k)
                    pt_y1 = (pt_y1 * k)
                    pt_z1 = (pt_z1 * k)
                    key12 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key12, pt_x1)
                    key13 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key13, pt_y1)
                    key14 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key14, pt_z1)
                else:
                    tnx = ((nx * cr) - ((ny * sr)))
                    tny = ((nx * sr) + ((ny * cr)))
                    key15 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key15, tnx)
                    key16 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key16, tny)
                    key17 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key17, nz)
            stride1 = self.stride
            if self.hasTangents:
                key18 = p
                p = (p + 1)
                tx1 = python_internal_ArrayImpl._get(buf, key18)
                key19 = p
                p = (p + 1)
                ty1 = python_internal_ArrayImpl._get(buf, key19)
                key20 = p
                p = (p + 1)
                tz = python_internal_ArrayImpl._get(buf, key20)
                if (mat is not None):
                    x3 = tx1
                    y3 = ty1
                    z3 = tz
                    if (z3 is None):
                        z3 = 0.
                    if (y3 is None):
                        y3 = 0.
                    if (x3 is None):
                        x3 = 0.
                    pt_x2 = x3
                    pt_y2 = y3
                    pt_z2 = z3
                    _hx_len = (((pt_x2 * pt_x2) + ((pt_y2 * pt_y2))) + ((pt_z2 * pt_z2)))
                    px2 = (((pt_x2 * mat._11) + ((pt_y2 * mat._21))) + ((pt_z2 * mat._31)))
                    py2 = (((pt_x2 * mat._12) + ((pt_y2 * mat._22))) + ((pt_z2 * mat._32)))
                    pz2 = (((pt_x2 * mat._13) + ((pt_y2 * mat._23))) + ((pt_z2 * mat._33)))
                    pt_x2 = px2
                    pt_y2 = py2
                    pt_z2 = pz2
                    k1 = (((pt_x2 * pt_x2) + ((pt_y2 * pt_y2))) + ((pt_z2 * pt_z2)))
                    if (k1 < 1e-10):
                        k1 = 0
                    else:
                        k1 = (1. / ((Math.NaN if ((k1 < 0)) else python_lib_Math.sqrt(k1))))
                    pt_x2 = (pt_x2 * k1)
                    pt_y2 = (pt_y2 * k1)
                    pt_z2 = (pt_z2 * k1)
                    if (_hx_len < 0.5):
                        pt_x2 = (pt_x2 * 0.5)
                        pt_y2 = (pt_y2 * 0.5)
                        pt_z2 = (pt_z2 * 0.5)
                    key21 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key21, pt_x2)
                    key22 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key22, pt_y2)
                    key23 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key23, pt_z2)
                else:
                    tnx1 = ((tx1 * cr) - ((ty1 * sr)))
                    tny1 = ((tx1 * sr) + ((ty1 * cr)))
                    key24 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key24, tnx1)
                    key25 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key25, tny1)
                    key26 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key26, tz)
                stride1 = (stride1 - 3)
            stride2 = stride1
            if ((stride2 == 6) or ((stride2 == 3))):
                continue
            elif ((stride2 == 7) or ((stride2 == 4))):
                key27 = p
                p = (p + 1)
                key28 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key28, (python_internal_ArrayImpl._get(buf, key27) + deltaU))
            elif ((((stride2 == 10) or ((stride2 == 9))) or ((stride2 == 8))) or ((stride2 == 5))):
                key29 = p
                p = (p + 1)
                key30 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key30, (python_internal_ArrayImpl._get(buf, key29) + deltaU))
                key31 = p
                p = (p + 1)
                key32 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key32, (python_internal_ArrayImpl._get(buf, key31) + deltaV))
                _g2 = 8
                _g3 = stride1
                while (_g2 < _g3):
                    i1 = _g2
                    _g2 = (_g2 + 1)
                    key33 = p
                    p = (p + 1)
                    key34 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key34, python_internal_ArrayImpl._get(buf, key33))
            else:
                key35 = p
                p = (p + 1)
                key36 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key36, (python_internal_ArrayImpl._get(buf, key35) + deltaU))
                key37 = p
                p = (p + 1)
                key38 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key38, (python_internal_ArrayImpl._get(buf, key37) + deltaV))
                key39 = p
                p = (p + 1)
                key40 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key40, (python_internal_ArrayImpl._get(buf, key39) * color))
                key41 = p
                p = (p + 1)
                key42 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key42, (python_internal_ArrayImpl._get(buf, key41) * color))
                key43 = p
                p = (p + 1)
                key44 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key44, (python_internal_ArrayImpl._get(buf, key43) * color))
                _g4 = 11
                _g5 = stride1
                while (_g4 < _g5):
                    i2 = _g4
                    _g4 = (_g4 + 1)
                    key45 = p
                    p = (p + 1)
                    key46 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key46, python_internal_ArrayImpl._get(buf, key45))
        self.bufPos = pos
        start = (start - startVert)
        _g = 0
        _g1 = (triCount * 3)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            key = self.idxPos
            self.idxPos = (self.idxPos + 1)
            python_internal_ArrayImpl._set(self.tmpIdx, key, (python_internal_ArrayImpl._get(idx, (i + ((startTri * 3)))) + start))
    PREV_BUFFER = None
    PREV_INDEX = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.isRaw = None
        _hx_o.stride = None
        _hx_o.buffers = None
        _hx_o.allIndexes = None
        _hx_o.tmpBuf = None
        _hx_o.tmpIdx = None
        _hx_o.bounds = None
        _hx_o.bufPos = None
        _hx_o.idxPos = None
        _hx_o.startIndex = None
        _hx_o.flushing = None
        _hx_o.hasTangents = None
        _hx_o.isStatic = None
h3d_prim_BigPrimitive._hx_class = h3d_prim_BigPrimitive
_hx_classes["h3d.prim.BigPrimitive"] = h3d_prim_BigPrimitive


class h3d_prim_MeshPrimitive(h3d_prim_Primitive):
    _hx_class_name = "h3d.prim.MeshPrimitive"
    _hx_is_interface = "False"
    __slots__ = ("bufferCache", "layouts")
    _hx_fields = ["bufferCache", "layouts"]
    _hx_methods = ["allocBuffer", "hasBuffer", "addBuffer", "dispose", "getBuffers", "render"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self):
        self.layouts = None
        self.bufferCache = None
        super().__init__()

    def allocBuffer(self,engine,name):
        return None

    def hasBuffer(self,name):
        if (self.bufferCache is None):
            return False
        this1 = self.bufferCache
        return (hxsl_Globals.allocID(name) in this1.h)

    def addBuffer(self,name,buf,offset = None):
        if (offset is None):
            offset = 0
        if (self.bufferCache is None):
            self.bufferCache = haxe_ds_IntMap()
        id = hxsl_Globals.allocID(name)
        old = self.bufferCache.h.get(id,None)
        if (old is not None):
            old.dispose()
        self.bufferCache.set(id,h3d_BufferOffset(buf,offset))
        self.layouts = None

    def dispose(self):
        super().dispose()
        if (self.bufferCache is not None):
            b = self.bufferCache.iterator()
            while b.hasNext():
                b1 = b.next()
                b1.dispose()
        self.bufferCache = None
        self.layouts = None

    def getBuffers(self,engine):
        if (self.bufferCache is None):
            self.bufferCache = haxe_ds_IntMap()
        if (self.layouts is None):
            self.layouts = haxe_ds_IntMap()
        inputs = engine.driver.getShaderInputNames()
        buffers = self.layouts.h.get(inputs.id,None)
        if (buffers is not None):
            return buffers
        prev = None
        _g = 0
        _g1 = inputs.names
        while (_g < len(_g1)):
            name = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            id = hxsl_Globals.allocID(name)
            b = self.bufferCache.h.get(id,None)
            if (b is None):
                b = self.allocBuffer(engine,name)
                if (b is None):
                    raise haxe_Exception.thrown((("Buffer " + ("null" if name is None else name)) + " is not available"))
                self.bufferCache.set(id,b)
            b1 = h3d_BufferOffset(b.buffer,b.offset)
            b = b1
            if (prev is None):
                prev = b
                buffers = prev
            else:
                prev.next = b
                prev = b
        self.layouts.set(inputs.id,buffers)
        return buffers

    def render(self,engine):
        if ((self.indexes is None) or self.indexes.isDisposed()):
            self.alloc(engine)
        engine.renderMultiBuffers(self.getBuffers(engine),self.indexes)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bufferCache = None
        _hx_o.layouts = None
h3d_prim_MeshPrimitive._hx_class = h3d_prim_MeshPrimitive
_hx_classes["h3d.prim.MeshPrimitive"] = h3d_prim_MeshPrimitive


class h3d_prim_HMDModel(h3d_prim_MeshPrimitive):
    _hx_class_name = "h3d.prim.HMDModel"
    _hx_is_interface = "False"
    __slots__ = ("data", "dataPosition", "indexCount", "indexesTriPos", "lib", "curMaterial", "collider", "normalsRecomputed", "bufferAliases")
    _hx_fields = ["data", "dataPosition", "indexCount", "indexesTriPos", "lib", "curMaterial", "collider", "normalsRecomputed", "bufferAliases"]
    _hx_methods = ["triCount", "vertexCount", "getBounds", "selectMaterial", "getDataBuffers", "loadSkin", "addAlias", "alloc", "allocAlias", "recomputeNormals", "addTangents", "render", "initCollider", "getCollider"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_MeshPrimitive


    def __init__(self,data,dataPos,lib):
        self.normalsRecomputed = None
        self.collider = None
        self.curMaterial = None
        self.lib = None
        self.indexesTriPos = None
        self.indexCount = None
        self.dataPosition = None
        self.data = None
        self.bufferAliases = haxe_ds_StringMap()
        super().__init__()
        self.data = data
        self.dataPosition = dataPos
        self.lib = lib

    def triCount(self):
        x = (self.data.get_indexCount() / 3)
        try:
            return int(x)
        except BaseException as _g:
            None
            return None

    def vertexCount(self):
        return self.data.vertexCount

    def getBounds(self):
        return self.data.bounds

    def selectMaterial(self,i):
        self.curMaterial = i

    def getDataBuffers(self,fmt,defaults = None,material = None):
        return self.lib.getBuffers(self.data,fmt,defaults,material)

    def loadSkin(self,skin):
        self.lib.loadSkin(self.data,skin)

    def addAlias(self,name,realName,offset = None):
        if (offset is None):
            offset = 0
        old = self.bufferAliases.h.get(name,None)
        if (old is not None):
            if ((old.realName != realName) or ((old.offset != offset))):
                raise haxe_Exception.thrown(("Conflicting alias " + ("null" if name is None else name)))
            return
        self.bufferAliases.h[name] = _hx_AnonObject({'realName': realName, 'offset': offset})
        if (self.bufferCache is not None):
            self.allocAlias(name)

    def alloc(self,engine):
        self.dispose()
        self.buffer = h3d_Buffer(self.data.vertexCount,self.data.vertexStride,[h3d_BufferFlag.LargeBuffer])
        entry = self.lib.resource.entry
        entry.open()
        entry.skip((self.dataPosition + self.data.vertexPosition))
        size = ((self.data.vertexCount * self.data.vertexStride) * 4)
        _hx_bytes = haxe_io_Bytes.alloc(size)
        entry.read(_hx_bytes,0,size)
        self.buffer.uploadBytes(_hx_bytes,0,self.data.vertexCount)
        self.indexCount = 0
        self.indexesTriPos = []
        _g = 0
        _g1 = self.data.indexCounts
        while (_g < len(_g1)):
            n = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _this = self.indexesTriPos
            x = (self.indexCount / 3)
            x1 = None
            try:
                x1 = int(x)
            except BaseException as _g2:
                None
                x1 = None
            _this.append(x1)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.indexCount
            _hx_local_1.indexCount = (_hx_local_2 + n)
            _hx_local_1.indexCount
        is32 = (self.data.vertexCount > 65536)
        self.indexes = h3d_Indexes(self.indexCount,is32)
        entry.skip((self.data.indexPosition - ((self.data.vertexPosition + size))))
        imult = (4 if is32 else 2)
        _hx_bytes = haxe_io_Bytes.alloc((self.indexCount * imult))
        entry.read(_hx_bytes,0,(self.indexCount * imult))
        self.indexes.uploadBytes(_hx_bytes,0,self.indexCount)
        entry.close()
        pos = 0
        _g = 0
        _g1 = self.data.vertexFormat
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.addBuffer(f.name,self.buffer,pos)
            pos = (pos + ((f.format & 7)))
        if (self.normalsRecomputed is not None):
            self.recomputeNormals(self.normalsRecomputed)
        name = self.bufferAliases.keys()
        while name.hasNext():
            name1 = name.next()
            self.allocAlias(name1)

    def allocAlias(self,name):
        alias = self.bufferAliases.h.get(name,None)
        this1 = self.bufferCache
        key = hxsl_Globals.allocID(alias.realName)
        buffer = this1.h.get(key,None)
        if (buffer is None):
            raise haxe_Exception.thrown(((("Buffer " + HxOverrides.stringOrNull(alias.realName)) + " not found for alias ") + ("null" if name is None else name)))
        if ((buffer.offset + alias.offset) > buffer.buffer.buffer.stride):
            raise haxe_Exception.thrown((((("Alias " + ("null" if name is None else name)) + " for buffer ") + HxOverrides.stringOrNull(alias.realName)) + " outside stride"))
        self.addBuffer(name,buffer.buffer,(buffer.offset + alias.offset))

    def recomputeNormals(self,name = None):
        if (name is None):
            name = "normal"
        pos = self.lib.getBuffers(self.data,[hxd_fmt_hmd_GeometryFormat("position",3)])
        ids = list()
        pts = []
        _g = 0
        _g1 = self.data.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            added = False
            px = pos.vertexes[(i * 3)]
            py = pos.vertexes[((i * 3) + 1)]
            pz = pos.vertexes[((i * 3) + 2)]
            _g2 = 0
            _g3 = len(pts)
            while (_g2 < _g3):
                i1 = _g2
                _g2 = (_g2 + 1)
                p = (pts[i1] if i1 >= 0 and i1 < len(pts) else None)
                if (((p.x == px) and ((p.y == py))) and ((p.z == pz))):
                    ids.append(i1)
                    added = True
                    break
            if (not added):
                x = len(pts)
                ids.append(x)
                x1 = h3d_col_Point(px,py,pz)
                pts.append(x1)
        this1 = list()
        idx = this1
        _g = 0
        _g1 = pos.indexes
        while (_g < len(_g1)):
            i = _g1[_g]
            _g = (_g + 1)
            idx.append((ids[i] if i >= 0 and i < len(ids) else None))
        pol = h3d_prim_Polygon(pts,idx)
        pol.addNormals()
        this1 = list()
        v = this1
        v1 = (self.data.vertexCount * 3)
        if (v1 > len(v)):
            python_internal_ArrayImpl._set(v, (v1 - 1), 0.)
        k = 0
        _g = 0
        _g1 = self.data.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            n = python_internal_ArrayImpl._get(pol.normals, (ids[i] if i >= 0 and i < len(ids) else None))
            key = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key, n.x)
            key1 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key1, n.y)
            key2 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key2, n.z)
        buf = h3d_Buffer.ofFloats(v,3)
        self.addBuffer(name,buf,0)
        self.normalsRecomputed = name

    def addTangents(self):
        pos = self.lib.getBuffers(self.data,[hxd_fmt_hmd_GeometryFormat("position",3)])
        ids = list()
        pts = []
        _g = 0
        _g1 = self.data.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            added = False
            px = pos.vertexes[(i * 3)]
            py = pos.vertexes[((i * 3) + 1)]
            pz = pos.vertexes[((i * 3) + 2)]
            _g2 = 0
            _g3 = len(pts)
            while (_g2 < _g3):
                i1 = _g2
                _g2 = (_g2 + 1)
                p = (pts[i1] if i1 >= 0 and i1 < len(pts) else None)
                if (((p.x == px) and ((p.y == py))) and ((p.z == pz))):
                    ids.append(i1)
                    added = True
                    break
            if (not added):
                x = len(pts)
                ids.append(x)
                x1 = h3d_col_Point(px,py,pz)
                pts.append(x1)
        this1 = list()
        idx = this1
        _g = 0
        _g1 = pos.indexes
        while (_g < len(_g1)):
            i = _g1[_g]
            _g = (_g + 1)
            idx.append((ids[i] if i >= 0 and i < len(ids) else None))
        pol = h3d_prim_Polygon(pts,idx)
        pol.addNormals()
        pol.addTangents()
        this1 = list()
        v = this1
        v1 = (self.data.vertexCount * 3)
        if (v1 > len(v)):
            python_internal_ArrayImpl._set(v, (v1 - 1), 0.)
        k = 0
        _g = 0
        _g1 = self.data.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            t = python_internal_ArrayImpl._get(pol.tangents, (ids[i] if i >= 0 and i < len(ids) else None))
            key = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key, t.x)
            key1 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key1, t.y)
            key2 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key2, t.z)
        buf = h3d_Buffer.ofFloats(v,3)
        self.addBuffer("tangent",buf,0)

    def render(self,engine):
        if (self.curMaterial < 0):
            super().render(engine)
            return
        if ((self.indexes is None) or self.indexes.isDisposed()):
            self.alloc(engine)
        tmp = self.getBuffers(engine)
        tmp1 = self.indexes
        tmp2 = python_internal_ArrayImpl._get(self.indexesTriPos, self.curMaterial)
        x = (python_internal_ArrayImpl._get(self.data.indexCounts, self.curMaterial) / 3)
        tmp3 = None
        try:
            tmp3 = int(x)
        except BaseException as _g:
            None
            tmp3 = None
        engine.renderMultiBuffers(tmp,tmp1,tmp2,tmp3)
        self.curMaterial = -1

    def initCollider(self,poly):
        buf = self.lib.getBuffers(self.data,[hxd_fmt_hmd_GeometryFormat("position",3)])
        poly.setData(buf.vertexes,buf.indexes)
        if (self.collider is None):
            _this = self.data.bounds
            dx = (_this.xMax - _this.xMin)
            dy = (_this.yMax - _this.yMin)
            dz = (_this.zMax - _this.zMin)
            f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
            sphere = h3d_col_Sphere((((_this.xMin + _this.xMax)) * 0.5),(((_this.yMin + _this.yMax)) * 0.5),(((_this.zMin + _this.zMax)) * 0.5),(((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 0.5))
            self.collider = h3d_col_OptimizedCollider(sphere,poly)

    def getCollider(self):
        if (self.collider is not None):
            return self.collider
        poly = h3d_col_PolygonBuffer()
        poly.source = _hx_AnonObject({'entry': self.lib.resource.entry, 'geometryName': None})
        _g = 0
        _g1 = self.lib.header.models
        while (_g < len(_g1)):
            h = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (python_internal_ArrayImpl._get(self.lib.header.geometries, h.geometry) == self.data):
                poly.source.geometryName = h.name
                break
        self.initCollider(poly)
        return self.collider

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
        _hx_o.dataPosition = None
        _hx_o.indexCount = None
        _hx_o.indexesTriPos = None
        _hx_o.lib = None
        _hx_o.curMaterial = None
        _hx_o.collider = None
        _hx_o.normalsRecomputed = None
        _hx_o.bufferAliases = None
h3d_prim_HMDModel._hx_class = h3d_prim_HMDModel
_hx_classes["h3d.prim.HMDModel"] = h3d_prim_HMDModel


class h3d_prim_Plane2D(h3d_prim_Primitive):
    _hx_class_name = "h3d.prim.Plane2D"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["triCount", "vertexCount", "alloc", "render"]
    _hx_statics = ["get"]
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self):
        super().__init__()

    def triCount(self):
        return 2

    def vertexCount(self):
        return 4

    def alloc(self,engine):
        this1 = list()
        v = this1
        v.append(-1)
        v.append(-1)
        v.append(0)
        v.append(1)
        v.append(-1)
        v.append(1)
        v.append(0)
        v.append(0)
        v.append(1)
        v.append(-1)
        v.append(1)
        v.append(1)
        v.append(1)
        v.append(1)
        v.append(1)
        v.append(0)
        self.buffer = h3d_Buffer.ofFloats(v,4,[h3d_BufferFlag.Quads, h3d_BufferFlag.RawFormat])

    def render(self,engine):
        tmp = None
        if (self.buffer is not None):
            _this = self.buffer
            tmp = ((_this.buffer is None) or ((_this.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            self.alloc(engine)
        engine.renderBuffer(self.buffer,engine.mem.quadIndexes,2,0,-1)

    @staticmethod
    def get():
        engine = h3d_Engine.CURRENT
        inst = engine.resCache.h.get(h3d_prim_Plane2D,None)
        if (inst is None):
            inst = h3d_prim_Plane2D()
            engine.resCache.set(h3d_prim_Plane2D,inst)
        return inst

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_prim_Plane2D._hx_class = h3d_prim_Plane2D
_hx_classes["h3d.prim.Plane2D"] = h3d_prim_Plane2D


class h3d_prim_Polygon(h3d_prim_MeshPrimitive):
    _hx_class_name = "h3d.prim.Polygon"
    _hx_is_interface = "False"
    __slots__ = ("points", "normals", "tangents", "uvs", "idx", "colors", "scaled", "translatedX", "translatedY", "translatedZ")
    _hx_fields = ["points", "normals", "tangents", "uvs", "idx", "colors", "scaled", "translatedX", "translatedY", "translatedZ"]
    _hx_methods = ["getBounds", "alloc", "unindex", "translate", "scale", "addNormals", "addTangents", "addUVs", "uvScale", "triCount", "vertexCount", "getCollider", "render"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_MeshPrimitive


    def __init__(self,points,idx = None):
        self.colors = None
        self.idx = None
        self.uvs = None
        self.tangents = None
        self.normals = None
        self.points = None
        self.translatedZ = 0.
        self.translatedY = 0.
        self.translatedX = 0.
        self.scaled = 1.
        super().__init__()
        self.points = points
        self.idx = idx

    def getBounds(self):
        b = h3d_col_Bounds()
        _g = 0
        _g1 = self.points
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (p.x < b.xMin):
                b.xMin = p.x
            if (p.x > b.xMax):
                b.xMax = p.x
            if (p.y < b.yMin):
                b.yMin = p.y
            if (p.y > b.yMax):
                b.yMax = p.y
            if (p.z < b.zMin):
                b.zMin = p.z
            if (p.z > b.zMax):
                b.zMax = p.z
        return b

    def alloc(self,engine):
        self.dispose()
        size = 3
        names = ["position"]
        positions = [0]
        if (self.normals is not None):
            names.append("normal")
            positions.append(size)
            size = (size + 3)
        if (self.tangents is not None):
            names.append("tangent")
            positions.append(size)
            size = (size + 3)
        if (self.uvs is not None):
            names.append("uv")
            positions.append(size)
            size = (size + 2)
        if (self.colors is not None):
            names.append("color")
            positions.append(size)
            size = (size + 3)
        this1 = list()
        buf = this1
        _g = 0
        _g1 = len(self.points)
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            p = (self.points[k] if k >= 0 and k < len(self.points) else None)
            v = p.x
            buf.append(v)
            v1 = p.y
            buf.append(v1)
            v2 = p.z
            buf.append(v2)
            if (self.normals is not None):
                n = (self.normals[k] if k >= 0 and k < len(self.normals) else None)
                v3 = n.x
                buf.append(v3)
                v4 = n.y
                buf.append(v4)
                v5 = n.z
                buf.append(v5)
            if (self.tangents is not None):
                t = (self.tangents[k] if k >= 0 and k < len(self.tangents) else None)
                v6 = t.x
                buf.append(v6)
                v7 = t.y
                buf.append(v7)
                v8 = t.z
                buf.append(v8)
            if (self.uvs is not None):
                t1 = (self.uvs[k] if k >= 0 and k < len(self.uvs) else None)
                v9 = t1.u
                buf.append(v9)
                v10 = t1.v
                buf.append(v10)
            if (self.colors is not None):
                c = (self.colors[k] if k >= 0 and k < len(self.colors) else None)
                v11 = c.x
                buf.append(v11)
                v12 = c.y
                buf.append(v12)
                v13 = c.z
                buf.append(v13)
        flags = []
        if (self.idx is None):
            flags.append(h3d_BufferFlag.Triangles)
        if ((self.normals is None) or ((self.tangents is not None))):
            flags.append(h3d_BufferFlag.RawFormat)
        self.buffer = h3d_Buffer.ofFloats(buf,size,flags)
        _g = 0
        _g1 = len(names)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.addBuffer((names[i] if i >= 0 and i < len(names) else None),self.buffer,(positions[i] if i >= 0 and i < len(positions) else None))
        if (self.idx is not None):
            self.indexes = h3d_Indexes.alloc(self.idx)

    def unindex(self):
        if ((self.idx is not None) and ((len(self.points) != len(self.idx)))):
            p = []
            _g = 0
            _g1 = len(self.idx)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this = python_internal_ArrayImpl._get(self.points, python_internal_ArrayImpl._get(self.idx, i))
                x = h3d_col_Point(_this.x,_this.y,_this.z)
                p.append(x)
            if (self.normals is not None):
                n = []
                _g = 0
                _g1 = len(self.idx)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    _this = python_internal_ArrayImpl._get(self.normals, python_internal_ArrayImpl._get(self.idx, i))
                    x = h3d_col_Point(_this.x,_this.y,_this.z)
                    n.append(x)
                self.normals = n
            if (self.tangents is not None):
                t = []
                _g = 0
                _g1 = len(self.idx)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    _this = python_internal_ArrayImpl._get(self.tangents, python_internal_ArrayImpl._get(self.idx, i))
                    x = h3d_col_Point(_this.x,_this.y,_this.z)
                    t.append(x)
                self.tangents = t
            if (self.colors is not None):
                n = []
                _g = 0
                _g1 = len(self.idx)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    _this = python_internal_ArrayImpl._get(self.colors, python_internal_ArrayImpl._get(self.idx, i))
                    x = h3d_col_Point(_this.x,_this.y,_this.z)
                    n.append(x)
                self.colors = n
            if (self.uvs is not None):
                t = []
                _g = 0
                _g1 = len(self.idx)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    x = python_internal_ArrayImpl._get(self.uvs, python_internal_ArrayImpl._get(self.idx, i)).clone()
                    t.append(x)
                self.uvs = t
            self.points = p
            self.idx = None

    def translate(self,dx,dy,dz):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.translatedX
        _hx_local_0.translatedX = (_hx_local_1 + dx)
        _hx_local_0.translatedX
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.translatedY
        _hx_local_2.translatedY = (_hx_local_3 + dy)
        _hx_local_2.translatedY
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.translatedZ
        _hx_local_4.translatedZ = (_hx_local_5 + dz)
        _hx_local_4.translatedZ
        _g = 0
        _g1 = self.points
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.x = (p.x + dx)
            p.y = (p.y + dy)
            p.z = (p.z + dz)

    def scale(self,s):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.scaled
        _hx_local_0.scaled = (_hx_local_1 * s)
        _hx_local_0.scaled
        _g = 0
        _g1 = self.points
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.x = (p.x * s)
            p.y = (p.y * s)
            p.z = (p.z * s)

    def addNormals(self):
        self.normals = list()
        _g = 0
        _g1 = len(self.points)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.normals, i, h3d_col_Point())
        pos = 0
        _g = 0
        _g1 = self.triCount()
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            i0 = None
            i1 = None
            i2 = None
            if (self.idx is None):
                pos = (pos + 1)
                i0 = (pos - 1)
                pos = (pos + 1)
                i1 = (pos - 1)
                pos = (pos + 1)
                i2 = (pos - 1)
            else:
                key = pos
                pos = (pos + 1)
                i0 = python_internal_ArrayImpl._get(self.idx, key)
                key1 = pos
                pos = (pos + 1)
                i1 = python_internal_ArrayImpl._get(self.idx, key1)
                key2 = pos
                pos = (pos + 1)
                i2 = python_internal_ArrayImpl._get(self.idx, key2)
            p0 = (self.points[i0] if i0 >= 0 and i0 < len(self.points) else None)
            p1 = (self.points[i1] if i1 >= 0 and i1 < len(self.points) else None)
            p2 = (self.points[i2] if i2 >= 0 and i2 < len(self.points) else None)
            x = (p1.x - p0.x)
            y = (p1.y - p0.y)
            z = (p1.z - p0.z)
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this_x = x
            _this_y = y
            _this_z = z
            x1 = (p2.x - p0.x)
            y1 = (p2.y - p0.y)
            z1 = (p2.z - p0.z)
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            p_x = x1
            p_y = y1
            p_z = z1
            x2 = ((_this_y * p_z) - ((_this_z * p_y)))
            y2 = ((_this_z * p_x) - ((_this_x * p_z)))
            z2 = ((_this_x * p_y) - ((_this_y * p_x)))
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            n_x = x2
            n_y = y2
            n_z = z2
            _hx_local_3 = (self.normals[i0] if i0 >= 0 and i0 < len(self.normals) else None)
            _hx_local_4 = _hx_local_3.x
            _hx_local_3.x = (_hx_local_4 + n_x)
            _hx_local_3.x
            _hx_local_5 = (self.normals[i0] if i0 >= 0 and i0 < len(self.normals) else None)
            _hx_local_6 = _hx_local_5.y
            _hx_local_5.y = (_hx_local_6 + n_y)
            _hx_local_5.y
            _hx_local_7 = (self.normals[i0] if i0 >= 0 and i0 < len(self.normals) else None)
            _hx_local_8 = _hx_local_7.z
            _hx_local_7.z = (_hx_local_8 + n_z)
            _hx_local_7.z
            _hx_local_9 = (self.normals[i1] if i1 >= 0 and i1 < len(self.normals) else None)
            _hx_local_10 = _hx_local_9.x
            _hx_local_9.x = (_hx_local_10 + n_x)
            _hx_local_9.x
            _hx_local_11 = (self.normals[i1] if i1 >= 0 and i1 < len(self.normals) else None)
            _hx_local_12 = _hx_local_11.y
            _hx_local_11.y = (_hx_local_12 + n_y)
            _hx_local_11.y
            _hx_local_13 = (self.normals[i1] if i1 >= 0 and i1 < len(self.normals) else None)
            _hx_local_14 = _hx_local_13.z
            _hx_local_13.z = (_hx_local_14 + n_z)
            _hx_local_13.z
            _hx_local_15 = (self.normals[i2] if i2 >= 0 and i2 < len(self.normals) else None)
            _hx_local_16 = _hx_local_15.x
            _hx_local_15.x = (_hx_local_16 + n_x)
            _hx_local_15.x
            _hx_local_17 = (self.normals[i2] if i2 >= 0 and i2 < len(self.normals) else None)
            _hx_local_18 = _hx_local_17.y
            _hx_local_17.y = (_hx_local_18 + n_y)
            _hx_local_17.y
            _hx_local_19 = (self.normals[i2] if i2 >= 0 and i2 < len(self.normals) else None)
            _hx_local_20 = _hx_local_19.z
            _hx_local_19.z = (_hx_local_20 + n_z)
            _hx_local_19.z
        _g = 0
        _g1 = self.normals
        while (_g < len(_g1)):
            n = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            k = (((n.x * n.x) + ((n.y * n.y))) + ((n.z * n.z)))
            if (k < 1e-10):
                k = 0
            else:
                k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
            n.x = (n.x * k)
            n.y = (n.y * k)
            n.z = (n.z * k)

    def addTangents(self):
        if (self.normals is None):
            self.addNormals()
        if (self.uvs is None):
            self.addUVs()
        self.tangents = []
        _g = 0
        _g1 = len(self.points)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.tangents, i, h3d_col_Point())
        pos = 0
        _g = 0
        _g1 = self.triCount()
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            i0 = None
            i1 = None
            i2 = None
            if (self.idx is None):
                pos = (pos + 1)
                i0 = (pos - 1)
                pos = (pos + 1)
                i1 = (pos - 1)
                pos = (pos + 1)
                i2 = (pos - 1)
            else:
                key = pos
                pos = (pos + 1)
                i0 = python_internal_ArrayImpl._get(self.idx, key)
                key1 = pos
                pos = (pos + 1)
                i1 = python_internal_ArrayImpl._get(self.idx, key1)
                key2 = pos
                pos = (pos + 1)
                i2 = python_internal_ArrayImpl._get(self.idx, key2)
            p0 = (self.points[i0] if i0 >= 0 and i0 < len(self.points) else None)
            p1 = (self.points[i1] if i1 >= 0 and i1 < len(self.points) else None)
            p2 = (self.points[i2] if i2 >= 0 and i2 < len(self.points) else None)
            uv0 = (self.uvs[i0] if i0 >= 0 and i0 < len(self.uvs) else None)
            uv1 = (self.uvs[i1] if i1 >= 0 and i1 < len(self.uvs) else None)
            uv2 = (self.uvs[i2] if i2 >= 0 and i2 < len(self.uvs) else None)
            n = (self.normals[i0] if i0 >= 0 and i0 < len(self.normals) else None)
            x = (p1.x - p0.x)
            y = (p1.y - p0.y)
            z = (p1.z - p0.z)
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            k0_x = x
            k0_y = y
            k0_z = z
            x1 = (p2.x - p0.x)
            y1 = (p2.y - p0.y)
            z1 = (p2.z - p0.z)
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            k1_x = x1
            k1_y = y1
            k1_z = z1
            v = (uv2.v - uv0.v)
            k0_x = (k0_x * v)
            k0_y = (k0_y * v)
            k0_z = (k0_z * v)
            v1 = (uv1.v - uv0.v)
            k1_x = (k1_x * v1)
            k1_y = (k1_y * v1)
            k1_z = (k1_z * v1)
            t = h3d_col_Point((k0_x - k1_x),(k0_y - k1_y),(k0_z - k1_z))
            x2 = ((n.y * t.z) - ((n.z * t.y)))
            y2 = ((n.z * t.x) - ((n.x * t.z)))
            z2 = ((n.x * t.y) - ((n.y * t.x)))
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            b_x = x2
            b_y = y2
            b_z = z2
            k = (((b_x * b_x) + ((b_y * b_y))) + ((b_z * b_z)))
            if (k < 1e-10):
                k = 0
            else:
                k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
            b_x = (b_x * k)
            b_y = (b_y * k)
            b_z = (b_z * k)
            t = h3d_col_Point(((b_y * n.z) - ((b_z * n.y))),((b_z * n.x) - ((b_x * n.z))),((b_x * n.y) - ((b_y * n.x))))
            k1 = (((t.x * t.x) + ((t.y * t.y))) + ((t.z * t.z)))
            if (k1 < 1e-10):
                k1 = 0
            else:
                k1 = (1. / ((Math.NaN if ((k1 < 0)) else python_lib_Math.sqrt(k1))))
            t.x = (t.x * k1)
            t.y = (t.y * k1)
            t.z = (t.z * k1)
            _hx_local_15 = (self.tangents[i0] if i0 >= 0 and i0 < len(self.tangents) else None)
            _hx_local_16 = _hx_local_15.x
            _hx_local_15.x = (_hx_local_16 + t.x)
            _hx_local_15.x
            _hx_local_17 = (self.tangents[i0] if i0 >= 0 and i0 < len(self.tangents) else None)
            _hx_local_18 = _hx_local_17.y
            _hx_local_17.y = (_hx_local_18 + t.y)
            _hx_local_17.y
            _hx_local_19 = (self.tangents[i0] if i0 >= 0 and i0 < len(self.tangents) else None)
            _hx_local_20 = _hx_local_19.z
            _hx_local_19.z = (_hx_local_20 + t.z)
            _hx_local_19.z
            _hx_local_21 = (self.tangents[i1] if i1 >= 0 and i1 < len(self.tangents) else None)
            _hx_local_22 = _hx_local_21.x
            _hx_local_21.x = (_hx_local_22 + t.x)
            _hx_local_21.x
            _hx_local_23 = (self.tangents[i1] if i1 >= 0 and i1 < len(self.tangents) else None)
            _hx_local_24 = _hx_local_23.y
            _hx_local_23.y = (_hx_local_24 + t.y)
            _hx_local_23.y
            _hx_local_25 = (self.tangents[i1] if i1 >= 0 and i1 < len(self.tangents) else None)
            _hx_local_26 = _hx_local_25.z
            _hx_local_25.z = (_hx_local_26 + t.z)
            _hx_local_25.z
            _hx_local_27 = (self.tangents[i2] if i2 >= 0 and i2 < len(self.tangents) else None)
            _hx_local_28 = _hx_local_27.x
            _hx_local_27.x = (_hx_local_28 + t.x)
            _hx_local_27.x
            _hx_local_29 = (self.tangents[i2] if i2 >= 0 and i2 < len(self.tangents) else None)
            _hx_local_30 = _hx_local_29.y
            _hx_local_29.y = (_hx_local_30 + t.y)
            _hx_local_29.y
            _hx_local_31 = (self.tangents[i2] if i2 >= 0 and i2 < len(self.tangents) else None)
            _hx_local_32 = _hx_local_31.z
            _hx_local_31.z = (_hx_local_32 + t.z)
            _hx_local_31.z
        _g = 0
        _g1 = self.tangents
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            k = (((t.x * t.x) + ((t.y * t.y))) + ((t.z * t.z)))
            if (k < 1e-10):
                k = 0
            else:
                k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
            t.x = (t.x * k)
            t.y = (t.y * k)
            t.z = (t.z * k)

    def addUVs(self):
        self.uvs = []
        _g = 0
        _g1 = len(self.points)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.uvs, i, h3d_prim_UV((self.points[i] if i >= 0 and i < len(self.points) else None).x,(self.points[i] if i >= 0 and i < len(self.points) else None).y))

    def uvScale(self,su,sv):
        if (self.uvs is None):
            raise haxe_Exception.thrown("Missing UVs")
        m = haxe_ds_ObjectMap()
        _g = 0
        _g1 = self.uvs
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (t in m.h):
                continue
            m.set(t,True)
            t.u = (t.u * su)
            t.v = (t.v * sv)

    def triCount(self):
        n = super().triCount()
        if (n != 0):
            return n
        x = (((len(self.points) if ((self.idx is None)) else len(self.idx))) / 3)
        try:
            return int(x)
        except BaseException as _g:
            None
            return None

    def vertexCount(self):
        return len(self.points)

    def getCollider(self):
        this1 = [None]*(len(self.points) * 3)
        vertexes = this1
        this1 = [None]*len(self.idx)
        indexes = this1
        vid = 0
        _g = 0
        _g1 = self.points
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            index = vid
            vid = (vid + 1)
            val = p.x
            vertexes[index] = val
            index1 = vid
            vid = (vid + 1)
            val1 = p.y
            vertexes[index1] = val1
            index2 = vid
            vid = (vid + 1)
            val2 = p.z
            vertexes[index2] = val2
        _g = 0
        _g1 = len(self.idx)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            val = python_internal_ArrayImpl._get(self.idx, i)
            indexes[i] = val
        poly = h3d_col_Polygon()
        poly.addBuffers(vertexes,indexes)
        return poly

    def render(self,engine):
        tmp = None
        if (self.buffer is not None):
            _this = self.buffer
            tmp = ((_this.buffer is None) or ((_this.buffer.vbuf is None)))
        else:
            tmp = True
        if tmp:
            self.alloc(engine)
        bufs = self.getBuffers(engine)
        if (self.indexes is not None):
            engine.renderMultiBuffers(bufs,self.indexes)
        elif (((self.buffer.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0):
            engine.renderMultiBuffers(bufs,engine.mem.quadIndexes,0,self.triCount())
        else:
            engine.renderMultiBuffers(bufs,engine.mem.triIndexes,0,self.triCount())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.points = None
        _hx_o.normals = None
        _hx_o.tangents = None
        _hx_o.uvs = None
        _hx_o.idx = None
        _hx_o.colors = None
        _hx_o.scaled = None
        _hx_o.translatedX = None
        _hx_o.translatedY = None
        _hx_o.translatedZ = None
h3d_prim_Polygon._hx_class = h3d_prim_Polygon
_hx_classes["h3d.prim.Polygon"] = h3d_prim_Polygon


class h3d_prim_RawPrimitive(h3d_prim_Primitive):
    _hx_class_name = "h3d.prim.RawPrimitive"
    _hx_is_interface = "False"
    __slots__ = ("vcount", "tcount", "bounds", "onContextLost")
    _hx_fields = ["vcount", "tcount", "bounds", "onContextLost"]
    _hx_methods = ["alloc", "getBounds", "triCount", "vertexCount"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self,inf,persist = None):
        if (persist is None):
            persist = False
        self.onContextLost = None
        self.bounds = None
        self.tcount = None
        self.vcount = None
        super().__init__()
        def _hx_local_0():
            return inf
        self.onContextLost = _hx_local_0
        self.bounds = Reflect.field(inf,"bounds")
        self.alloc(None)
        if (not persist):
            self.onContextLost = None

    def alloc(self,engine):
        if (self.onContextLost is None):
            raise haxe_Exception.thrown(("Cannot realloc " + Std.string(self)))
        inf = self.onContextLost()
        flags = []
        if (Reflect.field(inf,"ibuf") is None):
            x = (h3d_BufferFlag.Quads if (Reflect.field(inf,"quads")) else h3d_BufferFlag.Triangles)
            flags.append(x)
        if (inf.stride < 8):
            flags.append(h3d_BufferFlag.RawFormat)
        self.buffer = h3d_Buffer.ofFloats(inf.vbuf,inf.stride,flags)
        self.vcount = self.buffer.vertices
        tmp = None
        if (Reflect.field(inf,"ibuf") is not None):
            x = (len(Reflect.field(inf,"ibuf")) / 3)
            try:
                tmp = int(x)
            except BaseException as _g:
                None
                tmp = None
        elif Reflect.field(inf,"quads"):
            tmp = (self.vcount >> 1)
        else:
            x = (self.vcount / 3)
            try:
                tmp = int(x)
            except BaseException as _g:
                None
                tmp = None
        self.tcount = tmp
        if (Reflect.field(inf,"ibuf") is not None):
            self.indexes = h3d_Indexes.alloc(Reflect.field(inf,"ibuf"))
        elif (self.indexes is not None):
            self.indexes.dispose()
            self.indexes = None

    def getBounds(self):
        if (self.bounds is None):
            raise haxe_Exception.thrown(("Bounds not defined for " + Std.string(self)))
        return self.bounds

    def triCount(self):
        return self.tcount

    def vertexCount(self):
        return self.vcount

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vcount = None
        _hx_o.tcount = None
        _hx_o.bounds = None
        _hx_o.onContextLost = None
h3d_prim_RawPrimitive._hx_class = h3d_prim_RawPrimitive
_hx_classes["h3d.prim.RawPrimitive"] = h3d_prim_RawPrimitive


class h3d_prim_UV:
    _hx_class_name = "h3d.prim.UV"
    _hx_is_interface = "False"
    __slots__ = ("u", "v")
    _hx_fields = ["u", "v"]
    _hx_methods = ["clone", "toString"]

    def __init__(self,u,v):
        self.u = u
        self.v = v

    def clone(self):
        return h3d_prim_UV(self.u,self.v)

    def toString(self):
        return (((("{" + Std.string(hxd_Math.fmt(self.u))) + ",") + Std.string(hxd_Math.fmt(self.v))) + "}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.u = None
        _hx_o.v = None
h3d_prim_UV._hx_class = h3d_prim_UV
_hx_classes["h3d.prim.UV"] = h3d_prim_UV


class h3d_scene__Graphics_GPoint:
    _hx_class_name = "h3d.scene._Graphics.GPoint"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "r", "g", "b", "a")
    _hx_fields = ["x", "y", "z", "r", "g", "b", "a"]

    def __init__(self,x,y,z,r,g,b,a):
        self.x = x
        self.y = y
        self.z = z
        self.r = r
        self.g = g
        self.b = b
        self.a = a

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.r = None
        _hx_o.g = None
        _hx_o.b = None
        _hx_o.a = None
h3d_scene__Graphics_GPoint._hx_class = h3d_scene__Graphics_GPoint
_hx_classes["h3d.scene._Graphics.GPoint"] = h3d_scene__Graphics_GPoint


class h3d_scene_Object:
    _hx_class_name = "h3d.scene.Object"
    _hx_is_interface = "False"
    __slots__ = ("flags", "children", "parent", "name", "x", "y", "z", "scaleX", "scaleY", "scaleZ", "follow", "defaultTransform", "currentAnimation", "cullingCollider", "absPos", "invPos", "qRot", "lastFrame")
    _hx_fields = ["flags", "children", "parent", "name", "x", "y", "z", "scaleX", "scaleY", "scaleZ", "follow", "defaultTransform", "currentAnimation", "cullingCollider", "absPos", "invPos", "qRot", "lastFrame"]
    _hx_methods = ["set_cullingCollider", "get_visible", "get_allocated", "get_posChanged", "get_culled", "get_followPositionOnly", "get_lightCameraCenter", "get_alwaysSync", "get_inheritCulled", "get_ignoreBounds", "get_ignoreCollide", "get_allowSerialize", "get_ignoreParentTransform", "get_cullingColliderInherited", "set_posChanged", "set_culled", "set_visible", "set_allocated", "set_followPositionOnly", "set_lightCameraCenter", "set_alwaysSync", "set_ignoreBounds", "set_inheritCulled", "set_ignoreCollide", "set_allowSerialize", "set_ignoreParentTransform", "set_cullingColliderInherited", "playAnimation", "switchToAnimation", "stopAnimation", "applyAnimationTransform", "getObjectsCount", "getMaterialByName", "contains", "find", "findAll", "getMaterials", "localToGlobal", "globalToLocal", "getInvPos", "getBounds", "getBoundsRec", "getMeshes", "getMeshByName", "getObjectByName", "clone", "addChild", "addChildAt", "iterVisibleMeshes", "onParentChanged", "onAdd", "onRemove", "removeChild", "removeChildren", "remove", "getScene", "getAbsPos", "getRelPos", "isMesh", "toMesh", "getCollider", "getGlobalCollider", "getLocalCollider", "draw", "set_follow", "calcAbsPos", "sync", "syncRec", "syncPos", "emit", "emitRec", "set_x", "set_y", "set_z", "set_scaleX", "set_scaleY", "set_scaleZ", "set_defaultTransform", "setPosition", "setTransform", "getTransform", "rotate", "setRotation", "setRotationAxis", "setDirection", "getLocalDirection", "getRotationQuat", "setRotationQuat", "scale", "setScale", "toString", "getChildAt", "getChildIndex", "get_numChildren", "iterator"]
    _hx_statics = ["ROT2RAD", "tmpMat", "tmpVec"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,parent = None):
        self.lastFrame = None
        self.qRot = None
        self.invPos = None
        self.cullingCollider = None
        self.currentAnimation = None
        self.defaultTransform = None
        self.follow = None
        self.scaleZ = None
        self.scaleY = None
        self.scaleX = None
        self.z = None
        self.y = None
        self.x = None
        self.name = None
        self.parent = None
        self.children = None
        this1 = 0
        self.flags = this1
        self.absPos = h3d_Matrix()
        self.absPos.identity()
        self.x = 0
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        self.y = 0
        f = 1
        b = True
        if b:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 | f)
            _hx_local_4.flags
        else:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 & ~f)
            _hx_local_6.flags
        self.z = 0
        f = 1
        b = True
        if b:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | f)
            _hx_local_8.flags
        else:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.flags
            _hx_local_10.flags = (_hx_local_11 & ~f)
            _hx_local_10.flags
        self.scaleX = 1
        f = 1
        b = True
        if b:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.flags
            _hx_local_12.flags = (_hx_local_13 | f)
            _hx_local_12.flags
        else:
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.flags
            _hx_local_14.flags = (_hx_local_15 & ~f)
            _hx_local_14.flags
        self.scaleY = 1
        f = 1
        b = True
        if b:
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.flags
            _hx_local_16.flags = (_hx_local_17 | f)
            _hx_local_16.flags
        else:
            _hx_local_18 = self
            _hx_local_19 = _hx_local_18.flags
            _hx_local_18.flags = (_hx_local_19 & ~f)
            _hx_local_18.flags
        self.scaleZ = 1
        f = 1
        b = True
        if b:
            _hx_local_20 = self
            _hx_local_21 = _hx_local_20.flags
            _hx_local_20.flags = (_hx_local_21 | f)
            _hx_local_20.flags
        else:
            _hx_local_22 = self
            _hx_local_23 = _hx_local_22.flags
            _hx_local_22.flags = (_hx_local_23 & ~f)
            _hx_local_22.flags
        self.qRot = h3d_Quat()
        f = 1
        b = (self.follow is not None)
        if b:
            _hx_local_24 = self
            _hx_local_25 = _hx_local_24.flags
            _hx_local_24.flags = (_hx_local_25 | f)
            _hx_local_24.flags
        else:
            _hx_local_26 = self
            _hx_local_27 = _hx_local_26.flags
            _hx_local_26.flags = (_hx_local_27 & ~f)
            _hx_local_26.flags
        f = 2
        _hx_local_28 = self
        _hx_local_29 = _hx_local_28.flags
        _hx_local_28.flags = (_hx_local_29 | f)
        _hx_local_28.flags
        self.children = []
        if (parent is not None):
            parent.addChild(self)

    def set_cullingCollider(self,c):
        self.cullingCollider = c
        f = 4096
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 & ~f)
        _hx_local_0.flags
        return c

    def get_visible(self):
        return (((self.flags & 2)) != 0)

    def get_allocated(self):
        return (((self.flags & 32)) != 0)

    def get_posChanged(self):
        return (((self.flags & 1)) != 0)

    def get_culled(self):
        return (((self.flags & 4)) != 0)

    def get_followPositionOnly(self):
        return (((self.flags & 8)) != 0)

    def get_lightCameraCenter(self):
        return (((self.flags & 16)) != 0)

    def get_alwaysSync(self):
        return (((self.flags & 64)) != 0)

    def get_inheritCulled(self):
        return (((self.flags & 128)) != 0)

    def get_ignoreBounds(self):
        return (((self.flags & 512)) != 0)

    def get_ignoreCollide(self):
        return (((self.flags & 1024)) != 0)

    def get_allowSerialize(self):
        return (((self.flags & 256)) == 0)

    def get_ignoreParentTransform(self):
        return (((self.flags & 2048)) != 0)

    def get_cullingColliderInherited(self):
        return (((self.flags & 4096)) != 0)

    def set_posChanged(self,b):
        f = 1
        b1 = (b or ((self.follow is not None)))
        if b1:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b1

    def set_culled(self,b):
        f = 4
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_visible(self,b):
        f = 2
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_allocated(self,b):
        f = 32
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_followPositionOnly(self,b):
        f = 8
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_lightCameraCenter(self,b):
        f = 16
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_alwaysSync(self,b):
        f = 64
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_ignoreBounds(self,b):
        f = 512
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_inheritCulled(self,b):
        f = 128
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_ignoreCollide(self,b):
        f = 1024
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_allowSerialize(self,b):
        f = 256
        b1 = (not b)
        if b1:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return (not b1)

    def set_ignoreParentTransform(self,b):
        if (b != ((((self.flags & 2048)) != 0))):
            f = 1
            b1 = True
            if b1:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.flags
                _hx_local_0.flags = (_hx_local_1 | f)
                _hx_local_0.flags
            else:
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.flags
                _hx_local_2.flags = (_hx_local_3 & ~f)
                _hx_local_2.flags
        f = 2048
        if b:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 | f)
            _hx_local_4.flags
        else:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 & ~f)
            _hx_local_6.flags
        return b

    def set_cullingColliderInherited(self,b):
        f = 4096
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def playAnimation(self,a):
        def _hx_local_1():
            def _hx_local_0():
                self.currentAnimation = a.createInstance(self)
                return self.currentAnimation
            return _hx_local_0()
        return _hx_local_1()

    def switchToAnimation(self,a):
        def _hx_local_1():
            def _hx_local_0():
                self.currentAnimation = a
                return self.currentAnimation
            return _hx_local_0()
        return _hx_local_1()

    def stopAnimation(self,recursive = None):
        if (recursive is None):
            recursive = False
        self.currentAnimation = None
        if recursive:
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.stopAnimation(True)

    def applyAnimationTransform(self,recursive = None):
        if (recursive is None):
            recursive = True
        if (self.defaultTransform is not None):
            _this = self.defaultTransform
            v = None
            if (v is None):
                v = h3d_Vector()
            f = (((_this._11 * _this._11) + ((_this._12 * _this._12))) + ((_this._13 * _this._13)))
            v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
            f = (((_this._21 * _this._21) + ((_this._22 * _this._22))) + ((_this._23 * _this._23)))
            v.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
            f = (((_this._31 * _this._31) + ((_this._32 * _this._32))) + ((_this._33 * _this._33)))
            v.z = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
            if ((((_this._11 * (((_this._22 * _this._33) - ((_this._23 * _this._32))))) + ((_this._12 * (((_this._23 * _this._31) - ((_this._21 * _this._33))))))) + ((_this._13 * (((_this._21 * _this._32) - ((_this._22 * _this._31))))))) < 0):
                v.x = (v.x * -1)
                v.y = (v.y * -1)
                v.z = (v.z * -1)
            s = v
            v = s.x
            self.scaleX = v
            f = 1
            b = True
            if b:
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.flags
                _hx_local_3.flags = (_hx_local_4 | f)
                _hx_local_3.flags
            else:
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.flags
                _hx_local_5.flags = (_hx_local_6 & ~f)
                _hx_local_5.flags
            v = s.y
            self.scaleY = v
            f = 1
            b = True
            if b:
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.flags
                _hx_local_7.flags = (_hx_local_8 | f)
                _hx_local_7.flags
            else:
                _hx_local_9 = self
                _hx_local_10 = _hx_local_9.flags
                _hx_local_9.flags = (_hx_local_10 & ~f)
                _hx_local_9.flags
            v = s.z
            self.scaleZ = v
            f = 1
            b = True
            if b:
                _hx_local_11 = self
                _hx_local_12 = _hx_local_11.flags
                _hx_local_11.flags = (_hx_local_12 | f)
                _hx_local_11.flags
            else:
                _hx_local_13 = self
                _hx_local_14 = _hx_local_13.flags
                _hx_local_13.flags = (_hx_local_14 & ~f)
                _hx_local_13.flags
            self.qRot.initRotateMatrix(self.defaultTransform)
            v = self.defaultTransform._41
            self.x = v
            f = 1
            b = True
            if b:
                _hx_local_15 = self
                _hx_local_16 = _hx_local_15.flags
                _hx_local_15.flags = (_hx_local_16 | f)
                _hx_local_15.flags
            else:
                _hx_local_17 = self
                _hx_local_18 = _hx_local_17.flags
                _hx_local_17.flags = (_hx_local_18 & ~f)
                _hx_local_17.flags
            v = self.defaultTransform._42
            self.y = v
            f = 1
            b = True
            if b:
                _hx_local_19 = self
                _hx_local_20 = _hx_local_19.flags
                _hx_local_19.flags = (_hx_local_20 | f)
                _hx_local_19.flags
            else:
                _hx_local_21 = self
                _hx_local_22 = _hx_local_21.flags
                _hx_local_21.flags = (_hx_local_22 & ~f)
                _hx_local_21.flags
            v = self.defaultTransform._43
            self.z = v
            f = 1
            b = True
            if b:
                _hx_local_23 = self
                _hx_local_24 = _hx_local_23.flags
                _hx_local_23.flags = (_hx_local_24 | f)
                _hx_local_23.flags
            else:
                _hx_local_25 = self
                _hx_local_26 = _hx_local_25.flags
                _hx_local_25.flags = (_hx_local_26 & ~f)
                _hx_local_25.flags
            v = None
            self.defaultTransform = v
            f = 1
            b = True
            if b:
                _hx_local_27 = self
                _hx_local_28 = _hx_local_27.flags
                _hx_local_27.flags = (_hx_local_28 | f)
                _hx_local_27.flags
            else:
                _hx_local_29 = self
                _hx_local_30 = _hx_local_29.flags
                _hx_local_29.flags = (_hx_local_30 & ~f)
                _hx_local_29.flags
        if recursive:
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.applyAnimationTransform()

    def getObjectsCount(self):
        k = 0
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            k = (k + ((c.getObjectsCount() + 1)))
        return k

    def getMaterialByName(self,name):
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            m = o.getMaterialByName(name)
            if (m is not None):
                return m
        return None

    def contains(self,o):
        while (o is not None):
            o = o.parent
            if (o == self):
                return True
        return False

    def find(self,f):
        v = f(self)
        if (v is not None):
            return v
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            v = o.find(f)
            if (v is not None):
                return v
        return None

    def findAll(self,f,arr = None):
        if (arr is None):
            arr = []
        v = f(self)
        if (v is not None):
            arr.append(v)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o.findAll(f,arr)
        return arr

    def getMaterials(self,a = None,recursive = None):
        if (recursive is None):
            recursive = True
        if (a is None):
            a = []
        if recursive:
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                o.getMaterials(a)
        return a

    def localToGlobal(self,pt = None):
        self.syncPos()
        if (pt is None):
            pt = h3d_col_Point()
        m = self.absPos
        px = ((((pt.x * m._11) + ((pt.y * m._21))) + ((pt.z * m._31))) + m._41)
        py = ((((pt.x * m._12) + ((pt.y * m._22))) + ((pt.z * m._32))) + m._42)
        pz = ((((pt.x * m._13) + ((pt.y * m._23))) + ((pt.z * m._33))) + m._43)
        pt.x = px
        pt.y = py
        pt.z = pz
        return pt

    def globalToLocal(self,pt):
        m = self.getInvPos()
        px = ((((pt.x * m._11) + ((pt.y * m._21))) + ((pt.z * m._31))) + m._41)
        py = ((((pt.x * m._12) + ((pt.y * m._22))) + ((pt.z * m._32))) + m._42)
        pz = ((((pt.x * m._13) + ((pt.y * m._23))) + ((pt.z * m._33))) + m._43)
        pt.x = px
        pt.y = py
        pt.z = pz
        return pt

    def getInvPos(self):
        self.syncPos()
        if (self.invPos is None):
            self.invPos = h3d_Matrix()
            self.invPos._44 = 0
        if (self.invPos._44 == 0):
            self.invPos.inverse3x4(self.absPos)
        return self.invPos

    def getBounds(self,b = None):
        if (b is None):
            b = h3d_col_Bounds()
        if (self.parent is not None):
            self.parent.syncPos()
        return self.getBoundsRec(b)

    def getBoundsRec(self,b):
        if (((self.flags & 1)) != 0):
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                f = 1
                b1 = True
                if b1:
                    c.flags = (c.flags | f)
                else:
                    c.flags = (c.flags & ~f)
            f = 1
            b1 = (self.follow is not None)
            if b1:
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.flags
                _hx_local_3.flags = (_hx_local_4 | f)
                _hx_local_3.flags
            else:
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.flags
                _hx_local_5.flags = (_hx_local_6 & ~f)
                _hx_local_5.flags
            self.calcAbsPos()
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.getBoundsRec(b)
        return b

    def getMeshes(self,out = None):
        if (out is None):
            out = []
        m = Std.downcast(self,h3d_scene_Mesh)
        if (m is not None):
            out.append(m)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.getMeshes(out)
        return out

    def getMeshByName(self,name):
        return Std.downcast(self.getObjectByName(name),h3d_scene_Mesh)

    def getObjectByName(self,name):
        if (self.name == name):
            return self
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o = c.getObjectByName(name)
            if (o is not None):
                return o
        return None

    def clone(self,o = None):
        if (o is None):
            o = h3d_scene_Object()
        v = self.x
        o.x = v
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        v = self.y
        o.y = v
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        v = self.z
        o.z = v
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        v = self.scaleX
        o.scaleX = v
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        v = self.scaleY
        o.scaleY = v
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        v = self.scaleZ
        o.scaleZ = v
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        _this = o.qRot
        q = self.qRot
        _this.x = q.x
        _this.y = q.y
        _this.z = q.z
        _this.w = q.w
        o.name = self.name
        o.set_follow(self.follow)
        b = (((self.flags & 8)) != 0)
        f = 8
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        b = (((self.flags & 2)) != 0)
        f = 2
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        if (self.defaultTransform is not None):
            v = self.defaultTransform.clone()
            o.defaultTransform = v
            f = 1
            b = True
            if b:
                o.flags = (o.flags | f)
            else:
                o.flags = (o.flags & ~f)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c1 = c.clone()
            c1.parent = o
            _this = o.children
            _this.append(c1)
        return o

    def addChild(self,o):
        self.addChildAt(o,len(self.children))

    def addChildAt(self,o,pos):
        if (pos < 0):
            pos = 0
        if (pos > len(self.children)):
            pos = len(self.children)
        p = self
        while (p is not None):
            if (p == o):
                raise haxe_Exception.thrown("Recursive addChild")
            p = p.parent
        if (o.parent is not None):
            old = (((o.flags & 32)) != 0)
            f = 32
            o.flags = (o.flags & ~f)
            o.parent.removeChild(o)
            f = 32
            if old:
                o.flags = (o.flags | f)
            else:
                o.flags = (o.flags & ~f)
        self.children.insert(pos, o)
        if ((((self.flags & 32)) == 0) and ((((o.flags & 32)) != 0))):
            o.onRemove()
        o.parent = self
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        if (((self.flags & 32)) != 0):
            if (((o.flags & 32)) == 0):
                o.onAdd()
            else:
                o.onParentChanged()

    def iterVisibleMeshes(self,callb):
        if ((((self.flags & 2)) == 0) or (((((self.flags & 4)) != 0) and ((((self.flags & 128)) != 0))))):
            return
        if (((self.flags & 4)) == 0):
            m = Std.downcast(self,h3d_scene_Mesh)
            if (m is not None):
                callb(m)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o.iterVisibleMeshes(callb)

    def onParentChanged(self):
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onParentChanged()

    def onAdd(self):
        f = 32
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 | f)
        _hx_local_0.flags
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onAdd()

    def onRemove(self):
        f = 32
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 & ~f)
        _hx_local_0.flags
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onRemove()

    def removeChild(self,o):
        if python_internal_ArrayImpl.remove(self.children,o):
            if (((o.flags & 32)) != 0):
                o.onRemove()
            o.parent = None
            f = 1
            b = True
            if b:
                o.flags = (o.flags | f)
            else:
                o.flags = (o.flags & ~f)

    def removeChildren(self):
        while (len(self.children) > 0):
            self.removeChild((self.children[0] if 0 < len(self.children) else None))

    def remove(self):
        if (self.parent is not None):
            self.parent.removeChild(self)

    def getScene(self):
        p = self
        while (p.parent is not None):
            p = p.parent
        return Std.downcast(p,h3d_scene_Scene)

    def getAbsPos(self):
        self.syncPos()
        return self.absPos

    def getRelPos(self,obj):
        if (obj is None):
            return self.getAbsPos()
        self.syncPos()
        m = h3d_Matrix()
        m.multiply(self.absPos,obj.getInvPos())
        return m

    def isMesh(self):
        return (Std.downcast(self,h3d_scene_Mesh) is not None)

    def toMesh(self):
        m = Std.downcast(self,h3d_scene_Mesh)
        if (m is not None):
            return m
        raise haxe_Exception.thrown((Std.string(self) + " is not a Mesh"))

    def getCollider(self):
        if (((self.flags & 1024)) != 0):
            return None
        colliders = []
        col = self.getGlobalCollider()
        if (col is not None):
            colliders.append(col)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            obj = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c = obj.getCollider()
            if (c is None):
                continue
            cgrp = Std.downcast(c,h3d_col_GroupCollider)
            if (cgrp is not None):
                _g2 = 0
                _g3 = cgrp.colliders
                while (_g2 < len(_g3)):
                    c1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    colliders.append(c1)
            else:
                colliders.append(c)
        if (len(colliders) == 0):
            return None
        if (len(colliders) == 1):
            return (colliders[0] if 0 < len(colliders) else None)
        return h3d_col_GroupCollider(colliders)

    def getGlobalCollider(self):
        if (((self.flags & 1024)) != 0):
            return None
        col = self.getLocalCollider()
        if (col is None):
            return None
        else:
            return h3d_col_ObjectCollider(self,col)

    def getLocalCollider(self):
        return None

    def draw(self,ctx):
        pass

    def set_follow(self,v):
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        def _hx_local_5():
            def _hx_local_4():
                self.follow = v
                return self.follow
            return _hx_local_4()
        return _hx_local_5()

    def calcAbsPos(self):
        self.qRot.toMatrix(self.absPos)
        _hx_local_0 = self.absPos
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * self.scaleX)
        _hx_local_0._11
        _hx_local_2 = self.absPos
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * self.scaleX)
        _hx_local_2._12
        _hx_local_4 = self.absPos
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * self.scaleX)
        _hx_local_4._13
        _hx_local_6 = self.absPos
        _hx_local_7 = _hx_local_6._21
        _hx_local_6._21 = (_hx_local_7 * self.scaleY)
        _hx_local_6._21
        _hx_local_8 = self.absPos
        _hx_local_9 = _hx_local_8._22
        _hx_local_8._22 = (_hx_local_9 * self.scaleY)
        _hx_local_8._22
        _hx_local_10 = self.absPos
        _hx_local_11 = _hx_local_10._23
        _hx_local_10._23 = (_hx_local_11 * self.scaleY)
        _hx_local_10._23
        _hx_local_12 = self.absPos
        _hx_local_13 = _hx_local_12._31
        _hx_local_12._31 = (_hx_local_13 * self.scaleZ)
        _hx_local_12._31
        _hx_local_14 = self.absPos
        _hx_local_15 = _hx_local_14._32
        _hx_local_14._32 = (_hx_local_15 * self.scaleZ)
        _hx_local_14._32
        _hx_local_16 = self.absPos
        _hx_local_17 = _hx_local_16._33
        _hx_local_16._33 = (_hx_local_17 * self.scaleZ)
        _hx_local_16._33
        self.absPos._41 = self.x
        self.absPos._42 = self.y
        self.absPos._43 = self.z
        if (self.follow is not None):
            self.follow.syncPos()
            if (((self.flags & 8)) != 0):
                _this = self.absPos
                a = self.absPos
                b = self.parent.absPos
                m11 = a._11
                m12 = a._12
                m13 = a._13
                m21 = a._21
                m22 = a._22
                m23 = a._23
                a31 = a._31
                a32 = a._32
                a33 = a._33
                a41 = a._41
                a42 = a._42
                a43 = a._43
                b11 = b._11
                b12 = b._12
                b13 = b._13
                b21 = b._21
                b22 = b._22
                b23 = b._23
                b31 = b._31
                b32 = b._32
                b33 = b._33
                b41 = b._41
                b42 = b._42
                b43 = b._43
                _this._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
                _this._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
                _this._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
                _this._14 = 0
                _this._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
                _this._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
                _this._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
                _this._24 = 0
                _this._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
                _this._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
                _this._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
                _this._34 = 0
                _this._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
                _this._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
                _this._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
                _this._44 = 1
                self.absPos._41 = (self.x + self.follow.absPos._41)
                self.absPos._42 = (self.y + self.follow.absPos._42)
                self.absPos._43 = (self.z + self.follow.absPos._43)
            else:
                self.absPos.multiply3x4(self.absPos,self.follow.absPos)
        elif ((self.parent is not None) and ((((self.flags & 2048)) == 0))):
            _this = self.absPos
            a = self.absPos
            b = self.parent.absPos
            m11 = a._11
            m12 = a._12
            m13 = a._13
            m21 = a._21
            m22 = a._22
            m23 = a._23
            a31 = a._31
            a32 = a._32
            a33 = a._33
            a41 = a._41
            a42 = a._42
            a43 = a._43
            b11 = b._11
            b12 = b._12
            b13 = b._13
            b21 = b._21
            b22 = b._22
            b23 = b._23
            b31 = b._31
            b32 = b._32
            b33 = b._33
            b41 = b._41
            b42 = b._42
            b43 = b._43
            _this._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
            _this._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
            _this._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
            _this._14 = 0
            _this._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
            _this._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
            _this._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
            _this._24 = 0
            _this._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
            _this._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
            _this._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
            _this._34 = 0
            _this._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
            _this._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
            _this._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
            _this._44 = 1
        if (self.defaultTransform is not None):
            _this = self.absPos
            a = self.defaultTransform
            b = self.absPos
            m11 = a._11
            m12 = a._12
            m13 = a._13
            m21 = a._21
            m22 = a._22
            m23 = a._23
            a31 = a._31
            a32 = a._32
            a33 = a._33
            a41 = a._41
            a42 = a._42
            a43 = a._43
            b11 = b._11
            b12 = b._12
            b13 = b._13
            b21 = b._21
            b22 = b._22
            b23 = b._23
            b31 = b._31
            b32 = b._32
            b33 = b._33
            b41 = b._41
            b42 = b._42
            b43 = b._43
            _this._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
            _this._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
            _this._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
            _this._14 = 0
            _this._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
            _this._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
            _this._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
            _this._24 = 0
            _this._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
            _this._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
            _this._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
            _this._34 = 0
            _this._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
            _this._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
            _this._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
            _this._44 = 1
        if (self.invPos is not None):
            self.invPos._44 = 0

    def sync(self,ctx):
        pass

    def syncRec(self,ctx):
        if (self.currentAnimation is not None):
            old = self.parent
            dt = ctx.elapsedTime
            while ((dt > 0) and ((self.currentAnimation is not None))):
                dt = self.currentAnimation.update(dt)
            if ((self.currentAnimation is not None) and ((((ctx.visibleFlag and ((((self.flags & 2)) != 0))) and ((((self.flags & 4)) == 0))) or ((((self.flags & 64)) != 0))))):
                self.currentAnimation.sync()
            if ((self.parent is None) and ((old is not None))):
                return
        old = ctx.visibleFlag
        if ((((self.flags & 2)) == 0) or (((((self.flags & 4)) != 0) and ((((self.flags & 128)) != 0))))):
            ctx.visibleFlag = False
        if ((ctx.cullingCollider is not None) and (((self.cullingCollider is None) or ((((self.flags & 4096)) != 0))))):
            self.set_cullingCollider(ctx.cullingCollider)
            f = 4096
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        elif (((self.flags & 4096)) != 0):
            self.set_cullingCollider(None)
        prevCollider = ctx.cullingCollider
        if (((self.flags & 128)) != 0):
            ctx.cullingCollider = self.cullingCollider
        changed = (((self.flags & 1)) != 0)
        if changed:
            self.calcAbsPos()
        self.sync(ctx)
        f = 1
        b = (self.follow is not None)
        if b:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 | f)
            _hx_local_2.flags
        else:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 & ~f)
            _hx_local_4.flags
        self.lastFrame = ctx.frame
        p = 0
        _hx_len = len(self.children)
        while (p < _hx_len):
            c = (self.children[p] if p >= 0 and p < len(self.children) else None)
            if (c is None):
                break
            if (c.lastFrame != ctx.frame):
                if changed:
                    f = 1
                    b = True
                    if b:
                        c.flags = (c.flags | f)
                    else:
                        c.flags = (c.flags & ~f)
                c.syncRec(ctx)
            if ((self.children[p] if p >= 0 and p < len(self.children) else None) != c):
                p = 0
                _hx_len = len(self.children)
            else:
                p = (p + 1)
        ctx.visibleFlag = old
        ctx.cullingCollider = prevCollider

    def syncPos(self):
        if (self.parent is not None):
            self.parent.syncPos()
        if (((self.flags & 1)) != 0):
            f = 1
            b = (self.follow is not None)
            if b:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.flags
                _hx_local_0.flags = (_hx_local_1 | f)
                _hx_local_0.flags
            else:
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.flags
                _hx_local_2.flags = (_hx_local_3 & ~f)
                _hx_local_2.flags
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                f = 1
                b = True
                if b:
                    c.flags = (c.flags | f)
                else:
                    c.flags = (c.flags & ~f)

    def emit(self,ctx):
        pass

    def emitRec(self,ctx):
        if ((((self.flags & 2)) == 0) or ((((((self.flags & 4)) != 0) and ((((self.flags & 128)) != 0))) and (not ctx.computingStatic)))):
            return
        if (((self.flags & 1)) != 0):
            if (self.currentAnimation is not None):
                self.currentAnimation.sync()
            f = 1
            b = (self.follow is not None)
            if b:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.flags
                _hx_local_0.flags = (_hx_local_1 | f)
                _hx_local_0.flags
            else:
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.flags
                _hx_local_2.flags = (_hx_local_3 & ~f)
                _hx_local_2.flags
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                f = 1
                b = True
                if b:
                    c.flags = (c.flags | f)
                else:
                    c.flags = (c.flags & ~f)
        if ((((self.flags & 4)) == 0) or ctx.computingStatic):
            self.emit(ctx)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.emitRec(ctx)

    def set_x(self,v):
        self.x = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_y(self,v):
        self.y = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_z(self,v):
        self.z = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_scaleX(self,v):
        self.scaleX = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_scaleY(self,v):
        self.scaleY = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_scaleZ(self,v):
        self.scaleZ = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_defaultTransform(self,v):
        self.defaultTransform = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def setPosition(self,x,y,z):
        self.x = x
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        self.y = y
        f = 1
        b = True
        if b:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 | f)
            _hx_local_4.flags
        else:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 & ~f)
            _hx_local_6.flags
        self.z = z
        f = 1
        b = True
        if b:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | f)
            _hx_local_8.flags
        else:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.flags
            _hx_local_10.flags = (_hx_local_11 & ~f)
            _hx_local_10.flags
        f = 1
        b = True
        if b:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.flags
            _hx_local_12.flags = (_hx_local_13 | f)
            _hx_local_12.flags
        else:
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.flags
            _hx_local_14.flags = (_hx_local_15 & ~f)
            _hx_local_14.flags

    def setTransform(self,mat):
        v = h3d_scene_Object.tmpVec
        if (v is None):
            v = h3d_Vector()
        f = (((mat._11 * mat._11) + ((mat._12 * mat._12))) + ((mat._13 * mat._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((mat._21 * mat._21) + ((mat._22 * mat._22))) + ((mat._23 * mat._23)))
        v.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((mat._31 * mat._31) + ((mat._32 * mat._32))) + ((mat._33 * mat._33)))
        v.z = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if ((((mat._11 * (((mat._22 * mat._33) - ((mat._23 * mat._32))))) + ((mat._12 * (((mat._23 * mat._31) - ((mat._21 * mat._33))))))) + ((mat._13 * (((mat._21 * mat._32) - ((mat._22 * mat._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        s = v
        v = mat._41
        self.x = v
        f = 1
        b = True
        if b:
            _hx_local_3 = self
            _hx_local_4 = _hx_local_3.flags
            _hx_local_3.flags = (_hx_local_4 | f)
            _hx_local_3.flags
        else:
            _hx_local_5 = self
            _hx_local_6 = _hx_local_5.flags
            _hx_local_5.flags = (_hx_local_6 & ~f)
            _hx_local_5.flags
        v = mat._42
        self.y = v
        f = 1
        b = True
        if b:
            _hx_local_7 = self
            _hx_local_8 = _hx_local_7.flags
            _hx_local_7.flags = (_hx_local_8 | f)
            _hx_local_7.flags
        else:
            _hx_local_9 = self
            _hx_local_10 = _hx_local_9.flags
            _hx_local_9.flags = (_hx_local_10 & ~f)
            _hx_local_9.flags
        v = mat._43
        self.z = v
        f = 1
        b = True
        if b:
            _hx_local_11 = self
            _hx_local_12 = _hx_local_11.flags
            _hx_local_11.flags = (_hx_local_12 | f)
            _hx_local_11.flags
        else:
            _hx_local_13 = self
            _hx_local_14 = _hx_local_13.flags
            _hx_local_13.flags = (_hx_local_14 & ~f)
            _hx_local_13.flags
        v = s.x
        self.scaleX = v
        f = 1
        b = True
        if b:
            _hx_local_15 = self
            _hx_local_16 = _hx_local_15.flags
            _hx_local_15.flags = (_hx_local_16 | f)
            _hx_local_15.flags
        else:
            _hx_local_17 = self
            _hx_local_18 = _hx_local_17.flags
            _hx_local_17.flags = (_hx_local_18 & ~f)
            _hx_local_17.flags
        v = s.y
        self.scaleY = v
        f = 1
        b = True
        if b:
            _hx_local_19 = self
            _hx_local_20 = _hx_local_19.flags
            _hx_local_19.flags = (_hx_local_20 | f)
            _hx_local_19.flags
        else:
            _hx_local_21 = self
            _hx_local_22 = _hx_local_21.flags
            _hx_local_21.flags = (_hx_local_22 & ~f)
            _hx_local_21.flags
        v = s.z
        self.scaleZ = v
        f = 1
        b = True
        if b:
            _hx_local_23 = self
            _hx_local_24 = _hx_local_23.flags
            _hx_local_23.flags = (_hx_local_24 | f)
            _hx_local_23.flags
        else:
            _hx_local_25 = self
            _hx_local_26 = _hx_local_25.flags
            _hx_local_25.flags = (_hx_local_26 & ~f)
            _hx_local_25.flags
        h3d_scene_Object.tmpMat.load(mat)
        h3d_scene_Object.tmpMat.prependScale((1.0 / s.x),(1.0 / s.y),(1.0 / s.z))
        self.qRot.initRotateMatrix(h3d_scene_Object.tmpMat)
        f = 1
        b = True
        if b:
            _hx_local_27 = self
            _hx_local_28 = _hx_local_27.flags
            _hx_local_27.flags = (_hx_local_28 | f)
            _hx_local_27.flags
        else:
            _hx_local_29 = self
            _hx_local_30 = _hx_local_29.flags
            _hx_local_29.flags = (_hx_local_30 & ~f)
            _hx_local_29.flags

    def getTransform(self,mat = None):
        if (mat is None):
            mat = h3d_Matrix()
        mat.initScale(self.scaleX,self.scaleY,self.scaleZ)
        self.qRot.toMatrix(h3d_scene_Object.tmpMat)
        mat.multiply3x4(mat,h3d_scene_Object.tmpMat)
        mat._41 = self.x
        mat._42 = self.y
        mat._43 = self.z
        return mat

    def rotate(self,rx,ry,rz):
        qTmp = h3d_Quat()
        qTmp.initRotation(rx,ry,rz)
        self.qRot.multiply(qTmp,self.qRot)
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def setRotation(self,rx,ry,rz):
        self.qRot.initRotation(rx,ry,rz)
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def setRotationAxis(self,ax,ay,az,angle):
        self.qRot.initRotateAxis(ax,ay,az,angle)
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def setDirection(self,v):
        self.qRot.initDirection(v)
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def getLocalDirection(self):
        _this = self.qRot
        return h3d_Vector((1 - ((2 * (((_this.y * _this.y) + ((_this.z * _this.z))))))),(2 * (((_this.x * _this.y) + ((_this.z * _this.w))))),(2 * (((_this.x * _this.z) - ((_this.y * _this.w))))))

    def getRotationQuat(self):
        return self.qRot

    def setRotationQuat(self,q):
        self.qRot = q
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def scale(self,v):
        v1 = (self.scaleX * v)
        self.scaleX = v1
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        v1 = (self.scaleY * v)
        self.scaleY = v1
        f = 1
        b = True
        if b:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 | f)
            _hx_local_4.flags
        else:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 & ~f)
            _hx_local_6.flags
        v1 = (self.scaleZ * v)
        self.scaleZ = v1
        f = 1
        b = True
        if b:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | f)
            _hx_local_8.flags
        else:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.flags
            _hx_local_10.flags = (_hx_local_11 & ~f)
            _hx_local_10.flags
        f = 1
        b = True
        if b:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.flags
            _hx_local_12.flags = (_hx_local_13 | f)
            _hx_local_12.flags
        else:
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.flags
            _hx_local_14.flags = (_hx_local_15 & ~f)
            _hx_local_14.flags

    def setScale(self,v):
        self.scaleX = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        self.scaleY = v
        f = 1
        b = True
        if b:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 | f)
            _hx_local_4.flags
        else:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 & ~f)
            _hx_local_6.flags
        self.scaleZ = v
        f = 1
        b = True
        if b:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | f)
            _hx_local_8.flags
        else:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.flags
            _hx_local_10.flags = (_hx_local_11 & ~f)
            _hx_local_10.flags
        f = 1
        b = True
        if b:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.flags
            _hx_local_12.flags = (_hx_local_13 | f)
            _hx_local_12.flags
        else:
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.flags
            _hx_local_14.flags = (_hx_local_15 & ~f)
            _hx_local_14.flags

    def toString(self):
        _this = Type.getClassName(Type.getClass(self))
        _this1 = _this.split(".")
        return (HxOverrides.stringOrNull(((None if ((len(_this1) == 0)) else _this1.pop()))) + HxOverrides.stringOrNull((("" if ((self.name is None)) else (("(" + HxOverrides.stringOrNull(self.name)) + ")")))))

    def getChildAt(self,n):
        return (self.children[n] if n >= 0 and n < len(self.children) else None)

    def getChildIndex(self,o):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == o):
                return i
        return -1

    def get_numChildren(self):
        return len(self.children)

    def iterator(self):
        return hxd_impl_ArrayIterator_h3d_scene_Object(self.children)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.flags = None
        _hx_o.children = None
        _hx_o.parent = None
        _hx_o.name = None
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.scaleX = None
        _hx_o.scaleY = None
        _hx_o.scaleZ = None
        _hx_o.follow = None
        _hx_o.defaultTransform = None
        _hx_o.currentAnimation = None
        _hx_o.cullingCollider = None
        _hx_o.absPos = None
        _hx_o.invPos = None
        _hx_o.qRot = None
        _hx_o.lastFrame = None
h3d_scene_Object._hx_class = h3d_scene_Object
_hx_classes["h3d.scene.Object"] = h3d_scene_Object


class h3d_scene_Mesh(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Mesh"
    _hx_is_interface = "False"
    __slots__ = ("primitive", "material")
    _hx_fields = ["primitive", "material"]
    _hx_methods = ["getMeshMaterials", "getBoundsRec", "clone", "getLocalCollider", "draw", "emit", "getMaterialByName", "getMaterials", "onAdd", "onRemove", "set_primitive"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Object


    def __init__(self,primitive,material = None,parent = None):
        self.material = None
        self.primitive = None
        super().__init__(parent)
        self.set_primitive(primitive)
        if (material is None):
            material = h3d_mat_MaterialSetup.current.createMaterial()
            material.set_props(material.getDefaultProps())
        self.material = material

    def getMeshMaterials(self):
        return [self.material]

    def getBoundsRec(self,b):
        b = super().getBoundsRec(b)
        if ((self.primitive is None) or ((((self.flags & 512)) != 0))):
            return b
        _this = self.primitive.getBounds()
        b1 = h3d_col_Bounds()
        b1.xMin = _this.xMin
        b1.xMax = _this.xMax
        b1.yMin = _this.yMin
        b1.yMax = _this.yMax
        b1.zMin = _this.zMin
        b1.zMax = _this.zMax
        tmp = b1
        tmp.transform(self.absPos)
        if (tmp.xMin < b.xMin):
            b.xMin = tmp.xMin
        if (tmp.xMax > b.xMax):
            b.xMax = tmp.xMax
        if (tmp.yMin < b.yMin):
            b.yMin = tmp.yMin
        if (tmp.yMax > b.yMax):
            b.yMax = tmp.yMax
        if (tmp.zMin < b.zMin):
            b.zMin = tmp.zMin
        if (tmp.zMax > b.zMax):
            b.zMax = tmp.zMax
        return b

    def clone(self,o = None):
        m = (h3d_scene_Mesh(None,self.material) if ((o is None)) else o)
        m.set_primitive(self.primitive)
        m.material = self.material.clone()
        super().clone(m)
        return m

    def getLocalCollider(self):
        return self.primitive.getCollider()

    def draw(self,ctx):
        self.primitive.render(ctx.engine)

    def emit(self,ctx):
        p = self.material.passes
        while (p is not None):
            ctx.emitPass(p,self).index = 0
            p = p.nextPass

    def getMaterialByName(self,name):
        if ((self.material is not None) and ((self.material.name == name))):
            return self.material
        return super().getMaterialByName(name)

    def getMaterials(self,a = None,recursive = None):
        if (recursive is None):
            recursive = True
        if (a is None):
            a = []
        if ((self.material is not None) and ((python_internal_ArrayImpl.indexOf(a,self.material,None) < 0))):
            x = self.material
            a.append(x)
        return super().getMaterials(a,recursive)

    def onAdd(self):
        super().onAdd()
        if (self.primitive is not None):
            self.primitive.incref()

    def onRemove(self):
        if (self.primitive is not None):
            self.primitive.decref()
        super().onRemove()

    def set_primitive(self,prim):
        if ((prim != self.primitive) and ((((self.flags & 32)) != 0))):
            if (self.primitive is not None):
                self.primitive.decref()
            if (prim is not None):
                prim.incref()
        def _hx_local_1():
            def _hx_local_0():
                self.primitive = prim
                return self.primitive
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.primitive = None
        _hx_o.material = None
h3d_scene_Mesh._hx_class = h3d_scene_Mesh
_hx_classes["h3d.scene.Mesh"] = h3d_scene_Mesh


class h3d_scene_Graphics(h3d_scene_Mesh):
    _hx_class_name = "h3d.scene.Graphics"
    _hx_is_interface = "False"
    __slots__ = ("bprim", "curX", "curY", "curZ", "curR", "curG", "curB", "curA", "lineSize", "lineShader", "tmpPoints", "is3D")
    _hx_fields = ["bprim", "curX", "curY", "curZ", "curR", "curG", "curB", "curA", "lineSize", "lineShader", "tmpPoints", "is3D"]
    _hx_methods = ["onRemove", "set_is3D", "flushLine", "flush", "sync", "draw", "clear", "lineStyle", "setColor", "drawLine", "moveTo", "addVertex", "lineTo"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Mesh


    def __init__(self,parent = None):
        self.is3D = None
        self.tmpPoints = None
        self.lineShader = None
        self.curA = None
        self.curB = None
        self.curG = None
        self.lineSize = 0.
        self.curR = 0.
        self.curZ = 0.
        self.curY = 0.
        self.curX = 0.
        self.bprim = h3d_prim_BigPrimitive(12)
        self.bprim.isStatic = False
        super().__init__(self.bprim,None,parent)
        self.tmpPoints = []
        self.lineShader = h3d_shader_LineShader()
        self.lineShader.setPriority(-100)
        _this = self.material
        _this.set_castShadows(False)
        _this.set_receiveShadows(False)
        self.material.passes.set_enableLights(False)
        self.material.passes.addShader(self.lineShader)
        vcolor = h3d_shader_VertexColorAlpha()
        vcolor.setPriority(-100)
        self.material.passes.addShader(vcolor)
        self.material.passes.set_culling(h3d_mat_Face._hx_None)

    def onRemove(self):
        super().onRemove()
        self.bprim.clear()

    def set_is3D(self,v):
        if (self.is3D == v):
            return v
        if v:
            self.material.passes.removeShader(self.lineShader)
        else:
            self.material.passes.addShader(self.lineShader)
        self.bprim.clear()
        self.tmpPoints = []
        def _hx_local_1():
            def _hx_local_0():
                self.is3D = v
                return self.is3D
            return _hx_local_0()
        return _hx_local_1()

    def flushLine(self):
        _gthis = self
        pts = self.tmpPoints
        last = (len(pts) - 1)
        prev = (pts[last] if last >= 0 and last < len(pts) else None)
        p = (pts[0] if 0 < len(pts) else None)
        closed = (((p.x == prev.x) and ((p.y == prev.y))) and ((p.z == prev.z)))
        count = len(pts)
        if (not closed):
            prevLast = python_internal_ArrayImpl._get(pts, (last - 1))
            if (prevLast is None):
                prevLast = p
            x = h3d_scene__Graphics_GPoint(((prev.x * 2) - prevLast.x),((prev.y * 2) - prevLast.y),((prev.z * 2) - prevLast.z),0,0,0,0)
            pts.append(x)
            pNext = (pts[1] if 1 < len(pts) else None)
            if (pNext is None):
                pNext = p
            prev = h3d_scene__Graphics_GPoint(((p.x * 2) - pNext.x),((p.y * 2) - pNext.y),((p.z * 2) - pNext.z),0,0,0,0)
        elif (p != prev):
            count = (count - 1)
            last = (last - 1)
            prev = (pts[last] if last >= 0 and last < len(pts) else None)
        start = self.bprim.vertexCount()
        pindex = start
        v = 0.
        _g = 0
        _g1 = count
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            next = python_internal_ArrayImpl._get(pts, HxOverrides.mod(((i + 1)), len(pts)))
            nx1 = (prev.y - p.y)
            ny1 = (p.x - prev.x)
            f = ((nx1 * nx1) + ((ny1 * ny1)))
            ns1 = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
            nx2 = (p.y - next.y)
            ny2 = (next.x - p.x)
            f1 = ((nx2 * nx2) + ((ny2 * ny2)))
            ns2 = (1. / ((Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))))
            nx = ((nx1 * ns1) + ((nx2 * ns2)))
            ny = ((ny1 * ns1) + ((ny2 * ns2)))
            f2 = ((nx * nx) + ((ny * ny)))
            ns = (1. / ((Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))))
            nx = (nx * ns)
            ny = (ny * ns)
            size = (((nx * nx1) * ns1) + (((ny * ny1) * ns1)))
            d = ((self.lineSize * 0.5) / size)
            nx = (nx * d)
            ny = (ny * d)
            hasIndex = ((i < ((count - 1))) or closed)
            self.bprim.begin(2,(6 if hasIndex else 0))
            _this = _gthis.bprim
            def _hx_local_7():
                _hx_local_6 = _this.bufPos
                _this.bufPos = (_this.bufPos + 1)
                return _hx_local_6
            key = _hx_local_7()
            python_internal_ArrayImpl._set(_this.tmpBuf, key, (p.x + nx))
            _this1 = _gthis.bprim
            def _hx_local_9():
                _hx_local_8 = _this1.bufPos
                _this1.bufPos = (_this1.bufPos + 1)
                return _hx_local_8
            key1 = _hx_local_9()
            python_internal_ArrayImpl._set(_this1.tmpBuf, key1, (p.y + ny))
            _this2 = _gthis.bprim
            def _hx_local_11():
                _hx_local_10 = _this2.bufPos
                _this2.bufPos = (_this2.bufPos + 1)
                return _hx_local_10
            key2 = _hx_local_11()
            python_internal_ArrayImpl._set(_this2.tmpBuf, key2, p.z)
            _this3 = _gthis.bprim
            def _hx_local_13():
                _hx_local_12 = _this3.bufPos
                _this3.bufPos = (_this3.bufPos + 1)
                return _hx_local_12
            key3 = _hx_local_13()
            python_internal_ArrayImpl._set(_this3.tmpBuf, key3, 0)
            _this4 = _gthis.bprim
            def _hx_local_15():
                _hx_local_14 = _this4.bufPos
                _this4.bufPos = (_this4.bufPos + 1)
                return _hx_local_14
            key4 = _hx_local_15()
            python_internal_ArrayImpl._set(_this4.tmpBuf, key4, 0)
            _this5 = _gthis.bprim
            def _hx_local_17():
                _hx_local_16 = _this5.bufPos
                _this5.bufPos = (_this5.bufPos + 1)
                return _hx_local_16
            key5 = _hx_local_17()
            python_internal_ArrayImpl._set(_this5.tmpBuf, key5, 1)
            _this6 = _gthis.bprim
            def _hx_local_19():
                _hx_local_18 = _this6.bufPos
                _this6.bufPos = (_this6.bufPos + 1)
                return _hx_local_18
            key6 = _hx_local_19()
            python_internal_ArrayImpl._set(_this6.tmpBuf, key6, 0)
            _this7 = _gthis.bprim
            def _hx_local_21():
                _hx_local_20 = _this7.bufPos
                _this7.bufPos = (_this7.bufPos + 1)
                return _hx_local_20
            key7 = _hx_local_21()
            python_internal_ArrayImpl._set(_this7.tmpBuf, key7, v)
            _this8 = _gthis.bprim
            def _hx_local_23():
                _hx_local_22 = _this8.bufPos
                _this8.bufPos = (_this8.bufPos + 1)
                return _hx_local_22
            key8 = _hx_local_23()
            python_internal_ArrayImpl._set(_this8.tmpBuf, key8, p.r)
            _this9 = _gthis.bprim
            def _hx_local_25():
                _hx_local_24 = _this9.bufPos
                _this9.bufPos = (_this9.bufPos + 1)
                return _hx_local_24
            key9 = _hx_local_25()
            python_internal_ArrayImpl._set(_this9.tmpBuf, key9, p.g)
            _this10 = _gthis.bprim
            def _hx_local_27():
                _hx_local_26 = _this10.bufPos
                _this10.bufPos = (_this10.bufPos + 1)
                return _hx_local_26
            key10 = _hx_local_27()
            python_internal_ArrayImpl._set(_this10.tmpBuf, key10, p.b)
            _this11 = _gthis.bprim
            def _hx_local_29():
                _hx_local_28 = _this11.bufPos
                _this11.bufPos = (_this11.bufPos + 1)
                return _hx_local_28
            key11 = _hx_local_29()
            python_internal_ArrayImpl._set(_this11.tmpBuf, key11, p.a)
            _this12 = _gthis.bprim
            def _hx_local_31():
                _hx_local_30 = _this12.bufPos
                _this12.bufPos = (_this12.bufPos + 1)
                return _hx_local_30
            key12 = _hx_local_31()
            python_internal_ArrayImpl._set(_this12.tmpBuf, key12, (p.x - nx))
            _this13 = _gthis.bprim
            def _hx_local_33():
                _hx_local_32 = _this13.bufPos
                _this13.bufPos = (_this13.bufPos + 1)
                return _hx_local_32
            key13 = _hx_local_33()
            python_internal_ArrayImpl._set(_this13.tmpBuf, key13, (p.y - ny))
            _this14 = _gthis.bprim
            def _hx_local_35():
                _hx_local_34 = _this14.bufPos
                _this14.bufPos = (_this14.bufPos + 1)
                return _hx_local_34
            key14 = _hx_local_35()
            python_internal_ArrayImpl._set(_this14.tmpBuf, key14, p.z)
            _this15 = _gthis.bprim
            def _hx_local_37():
                _hx_local_36 = _this15.bufPos
                _this15.bufPos = (_this15.bufPos + 1)
                return _hx_local_36
            key15 = _hx_local_37()
            python_internal_ArrayImpl._set(_this15.tmpBuf, key15, 0)
            _this16 = _gthis.bprim
            def _hx_local_39():
                _hx_local_38 = _this16.bufPos
                _this16.bufPos = (_this16.bufPos + 1)
                return _hx_local_38
            key16 = _hx_local_39()
            python_internal_ArrayImpl._set(_this16.tmpBuf, key16, 0)
            _this17 = _gthis.bprim
            def _hx_local_41():
                _hx_local_40 = _this17.bufPos
                _this17.bufPos = (_this17.bufPos + 1)
                return _hx_local_40
            key17 = _hx_local_41()
            python_internal_ArrayImpl._set(_this17.tmpBuf, key17, 1)
            _this18 = _gthis.bprim
            def _hx_local_43():
                _hx_local_42 = _this18.bufPos
                _this18.bufPos = (_this18.bufPos + 1)
                return _hx_local_42
            key18 = _hx_local_43()
            python_internal_ArrayImpl._set(_this18.tmpBuf, key18, 1)
            _this19 = _gthis.bprim
            def _hx_local_45():
                _hx_local_44 = _this19.bufPos
                _this19.bufPos = (_this19.bufPos + 1)
                return _hx_local_44
            key19 = _hx_local_45()
            python_internal_ArrayImpl._set(_this19.tmpBuf, key19, v)
            _this20 = _gthis.bprim
            def _hx_local_47():
                _hx_local_46 = _this20.bufPos
                _this20.bufPos = (_this20.bufPos + 1)
                return _hx_local_46
            key20 = _hx_local_47()
            python_internal_ArrayImpl._set(_this20.tmpBuf, key20, p.r)
            _this21 = _gthis.bprim
            def _hx_local_49():
                _hx_local_48 = _this21.bufPos
                _this21.bufPos = (_this21.bufPos + 1)
                return _hx_local_48
            key21 = _hx_local_49()
            python_internal_ArrayImpl._set(_this21.tmpBuf, key21, p.g)
            _this22 = _gthis.bprim
            def _hx_local_51():
                _hx_local_50 = _this22.bufPos
                _this22.bufPos = (_this22.bufPos + 1)
                return _hx_local_50
            key22 = _hx_local_51()
            python_internal_ArrayImpl._set(_this22.tmpBuf, key22, p.b)
            _this23 = _gthis.bprim
            def _hx_local_53():
                _hx_local_52 = _this23.bufPos
                _this23.bufPos = (_this23.bufPos + 1)
                return _hx_local_52
            key23 = _hx_local_53()
            python_internal_ArrayImpl._set(_this23.tmpBuf, key23, p.a)
            v = (1 - v)
            if hasIndex:
                pnext = ((start - pindex) if ((i == last)) else 2)
                _this24 = self.bprim
                def _hx_local_55():
                    _hx_local_54 = _this24.idxPos
                    _this24.idxPos = (_this24.idxPos + 1)
                    return _hx_local_54
                key24 = _hx_local_55()
                python_internal_ArrayImpl._set(_this24.tmpIdx, key24, _this24.startIndex)
                _this25 = self.bprim
                def _hx_local_57():
                    _hx_local_56 = _this25.idxPos
                    _this25.idxPos = (_this25.idxPos + 1)
                    return _hx_local_56
                key25 = _hx_local_57()
                python_internal_ArrayImpl._set(_this25.tmpIdx, key25, (1 + _this25.startIndex))
                _this26 = self.bprim
                def _hx_local_59():
                    _hx_local_58 = _this26.idxPos
                    _this26.idxPos = (_this26.idxPos + 1)
                    return _hx_local_58
                key26 = _hx_local_59()
                python_internal_ArrayImpl._set(_this26.tmpIdx, key26, (pnext + _this26.startIndex))
                _this27 = self.bprim
                def _hx_local_61():
                    _hx_local_60 = _this27.idxPos
                    _this27.idxPos = (_this27.idxPos + 1)
                    return _hx_local_60
                key27 = _hx_local_61()
                python_internal_ArrayImpl._set(_this27.tmpIdx, key27, (pnext + _this27.startIndex))
                _this28 = self.bprim
                def _hx_local_63():
                    _hx_local_62 = _this28.idxPos
                    _this28.idxPos = (_this28.idxPos + 1)
                    return _hx_local_62
                key28 = _hx_local_63()
                python_internal_ArrayImpl._set(_this28.tmpIdx, key28, (1 + _this28.startIndex))
                _this29 = self.bprim
                def _hx_local_65():
                    _hx_local_64 = _this29.idxPos
                    _this29.idxPos = (_this29.idxPos + 1)
                    return _hx_local_64
                key29 = _hx_local_65()
                python_internal_ArrayImpl._set(_this29.tmpIdx, key29, ((pnext + 1) + _this29.startIndex))
            pindex = (pindex + 2)
            prev = p
            p = next

    def flush(self):
        if (len(self.tmpPoints) == 0):
            return
        if self.is3D:
            self.flushLine()
            self.tmpPoints = []

    def sync(self,ctx):
        super().sync(ctx)
        self.flush()
        self.bprim.flush()

    def draw(self,ctx):
        self.flush()
        self.bprim.flush()
        super().draw(ctx)

    def clear(self):
        self.flush()
        self.bprim.clear()

    def lineStyle(self,size = None,color = None,alpha = None):
        if (size is None):
            size = 0.
        if (color is None):
            color = 0
        if (alpha is None):
            alpha = 1.
        self.flush()
        if ((size > 0) and ((self.lineSize != size))):
            self.lineSize = size
            if (not self.is3D):
                self.lineShader.width__ = self.lineSize
        self.setColor(color,alpha)

    def setColor(self,color,alpha = None):
        if (alpha is None):
            alpha = 1.
        self.curA = alpha
        self.curR = ((((color >> 16) & 255)) / 255.)
        self.curG = ((((color >> 8) & 255)) / 255.)
        self.curB = (((color & 255)) / 255.)

    def drawLine(self,p1,p2):
        self.moveTo(p1.x,p1.y,p1.z)
        self.lineTo(p2.x,p2.y,p2.z)

    def moveTo(self,x,y,z):
        if self.is3D:
            self.flush()
            self.lineTo(x,y,z)
        else:
            self.curX = x
            self.curY = y
            self.curZ = z

    def addVertex(self,x,y,z,r,g,b,a):
        _this = self.tmpPoints
        x1 = h3d_scene__Graphics_GPoint(x,y,z,r,g,b,a)
        _this.append(x1)

    def lineTo(self,x,y,z):
        _gthis = self
        if self.is3D:
            _this = self.tmpPoints
            x1 = h3d_scene__Graphics_GPoint(x,y,z,self.curR,self.curG,self.curB,self.curA)
            _this.append(x1)
            return
        self.bprim.begin(4,6)
        nx = (x - self.curX)
        ny = (y - self.curY)
        nz = (z - self.curZ)
        x1 = self.curX
        y1 = self.curY
        z1 = self.curZ
        _this = self.bprim.bounds
        if (x1 < _this.xMin):
            _this.xMin = x1
        if (x1 > _this.xMax):
            _this.xMax = x1
        if (y1 < _this.yMin):
            _this.yMin = y1
        if (y1 > _this.yMax):
            _this.yMax = y1
        if (z1 < _this.zMin):
            _this.zMin = z1
        if (z1 > _this.zMax):
            _this.zMax = z1
        _this = self.bprim.bounds
        if (x < _this.xMin):
            _this.xMin = x
        if (x > _this.xMax):
            _this.xMax = x
        if (y < _this.yMin):
            _this.yMin = y
        if (y > _this.yMax):
            _this.yMax = y
        if (z < _this.zMin):
            _this.zMin = z
        if (z > _this.zMax):
            _this.zMax = z
        _this = _gthis.bprim
        def _hx_local_1():
            _hx_local_0 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_0
        key = _hx_local_1()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curX)
        _this = _gthis.bprim
        def _hx_local_3():
            _hx_local_2 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_2
        key = _hx_local_3()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curY)
        _this = _gthis.bprim
        def _hx_local_5():
            _hx_local_4 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_4
        key = _hx_local_5()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curZ)
        _this = _gthis.bprim
        def _hx_local_7():
            _hx_local_6 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_6
        key = _hx_local_7()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nx)
        _this = _gthis.bprim
        def _hx_local_9():
            _hx_local_8 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_8
        key = _hx_local_9()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, ny)
        _this = _gthis.bprim
        def _hx_local_11():
            _hx_local_10 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_10
        key = _hx_local_11()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nz)
        _this = _gthis.bprim
        def _hx_local_13():
            _hx_local_12 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_12
        key = _hx_local_13()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 0)
        _this = _gthis.bprim
        def _hx_local_15():
            _hx_local_14 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_14
        key = _hx_local_15()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 0)
        _this = _gthis.bprim
        def _hx_local_17():
            _hx_local_16 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_16
        key = _hx_local_17()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curR)
        _this = _gthis.bprim
        def _hx_local_19():
            _hx_local_18 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_18
        key = _hx_local_19()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curG)
        _this = _gthis.bprim
        def _hx_local_21():
            _hx_local_20 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_20
        key = _hx_local_21()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curB)
        _this = _gthis.bprim
        def _hx_local_23():
            _hx_local_22 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_22
        key = _hx_local_23()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curA)
        _this = _gthis.bprim
        def _hx_local_25():
            _hx_local_24 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_24
        key = _hx_local_25()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curX)
        _this = _gthis.bprim
        def _hx_local_27():
            _hx_local_26 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_26
        key = _hx_local_27()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curY)
        _this = _gthis.bprim
        def _hx_local_29():
            _hx_local_28 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_28
        key = _hx_local_29()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curZ)
        _this = _gthis.bprim
        def _hx_local_31():
            _hx_local_30 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_30
        key = _hx_local_31()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nx)
        _this = _gthis.bprim
        def _hx_local_33():
            _hx_local_32 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_32
        key = _hx_local_33()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, ny)
        _this = _gthis.bprim
        def _hx_local_35():
            _hx_local_34 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_34
        key = _hx_local_35()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nz)
        _this = _gthis.bprim
        def _hx_local_37():
            _hx_local_36 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_36
        key = _hx_local_37()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 0)
        _this = _gthis.bprim
        def _hx_local_39():
            _hx_local_38 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_38
        key = _hx_local_39()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 1)
        _this = _gthis.bprim
        def _hx_local_41():
            _hx_local_40 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_40
        key = _hx_local_41()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curR)
        _this = _gthis.bprim
        def _hx_local_43():
            _hx_local_42 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_42
        key = _hx_local_43()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curG)
        _this = _gthis.bprim
        def _hx_local_45():
            _hx_local_44 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_44
        key = _hx_local_45()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curB)
        _this = _gthis.bprim
        def _hx_local_47():
            _hx_local_46 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_46
        key = _hx_local_47()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curA)
        _this = _gthis.bprim
        def _hx_local_49():
            _hx_local_48 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_48
        key = _hx_local_49()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curX)
        _this = _gthis.bprim
        def _hx_local_51():
            _hx_local_50 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_50
        key = _hx_local_51()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curY)
        _this = _gthis.bprim
        def _hx_local_53():
            _hx_local_52 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_52
        key = _hx_local_53()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curZ)
        _this = _gthis.bprim
        def _hx_local_55():
            _hx_local_54 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_54
        key = _hx_local_55()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nx)
        _this = _gthis.bprim
        def _hx_local_57():
            _hx_local_56 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_56
        key = _hx_local_57()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, ny)
        _this = _gthis.bprim
        def _hx_local_59():
            _hx_local_58 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_58
        key = _hx_local_59()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nz)
        _this = _gthis.bprim
        def _hx_local_61():
            _hx_local_60 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_60
        key = _hx_local_61()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 1)
        _this = _gthis.bprim
        def _hx_local_63():
            _hx_local_62 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_62
        key = _hx_local_63()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 0)
        _this = _gthis.bprim
        def _hx_local_65():
            _hx_local_64 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_64
        key = _hx_local_65()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curR)
        _this = _gthis.bprim
        def _hx_local_67():
            _hx_local_66 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_66
        key = _hx_local_67()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curG)
        _this = _gthis.bprim
        def _hx_local_69():
            _hx_local_68 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_68
        key = _hx_local_69()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curB)
        _this = _gthis.bprim
        def _hx_local_71():
            _hx_local_70 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_70
        key = _hx_local_71()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curA)
        _this = _gthis.bprim
        def _hx_local_73():
            _hx_local_72 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_72
        key = _hx_local_73()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curX)
        _this = _gthis.bprim
        def _hx_local_75():
            _hx_local_74 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_74
        key = _hx_local_75()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curY)
        _this = _gthis.bprim
        def _hx_local_77():
            _hx_local_76 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_76
        key = _hx_local_77()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curZ)
        _this = _gthis.bprim
        def _hx_local_79():
            _hx_local_78 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_78
        key = _hx_local_79()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nx)
        _this = _gthis.bprim
        def _hx_local_81():
            _hx_local_80 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_80
        key = _hx_local_81()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, ny)
        _this = _gthis.bprim
        def _hx_local_83():
            _hx_local_82 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_82
        key = _hx_local_83()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, nz)
        _this = _gthis.bprim
        def _hx_local_85():
            _hx_local_84 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_84
        key = _hx_local_85()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 1)
        _this = _gthis.bprim
        def _hx_local_87():
            _hx_local_86 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_86
        key = _hx_local_87()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, 1)
        _this = _gthis.bprim
        def _hx_local_89():
            _hx_local_88 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_88
        key = _hx_local_89()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curR)
        _this = _gthis.bprim
        def _hx_local_91():
            _hx_local_90 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_90
        key = _hx_local_91()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curG)
        _this = _gthis.bprim
        def _hx_local_93():
            _hx_local_92 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_92
        key = _hx_local_93()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curB)
        _this = _gthis.bprim
        def _hx_local_95():
            _hx_local_94 = _this.bufPos
            _this.bufPos = (_this.bufPos + 1)
            return _hx_local_94
        key = _hx_local_95()
        python_internal_ArrayImpl._set(_this.tmpBuf, key, _gthis.curA)
        _this = self.bprim
        def _hx_local_97():
            _hx_local_96 = _this.idxPos
            _this.idxPos = (_this.idxPos + 1)
            return _hx_local_96
        key = _hx_local_97()
        python_internal_ArrayImpl._set(_this.tmpIdx, key, _this.startIndex)
        _this = self.bprim
        def _hx_local_99():
            _hx_local_98 = _this.idxPos
            _this.idxPos = (_this.idxPos + 1)
            return _hx_local_98
        key = _hx_local_99()
        python_internal_ArrayImpl._set(_this.tmpIdx, key, (1 + _this.startIndex))
        _this = self.bprim
        def _hx_local_101():
            _hx_local_100 = _this.idxPos
            _this.idxPos = (_this.idxPos + 1)
            return _hx_local_100
        key = _hx_local_101()
        python_internal_ArrayImpl._set(_this.tmpIdx, key, (2 + _this.startIndex))
        _this = self.bprim
        def _hx_local_103():
            _hx_local_102 = _this.idxPos
            _this.idxPos = (_this.idxPos + 1)
            return _hx_local_102
        key = _hx_local_103()
        python_internal_ArrayImpl._set(_this.tmpIdx, key, (2 + _this.startIndex))
        _this = self.bprim
        def _hx_local_105():
            _hx_local_104 = _this.idxPos
            _this.idxPos = (_this.idxPos + 1)
            return _hx_local_104
        key = _hx_local_105()
        python_internal_ArrayImpl._set(_this.tmpIdx, key, (3 + _this.startIndex))
        _this = self.bprim
        def _hx_local_107():
            _hx_local_106 = _this.idxPos
            _this.idxPos = (_this.idxPos + 1)
            return _hx_local_106
        key = _hx_local_107()
        python_internal_ArrayImpl._set(_this.tmpIdx, key, (1 + _this.startIndex))
        self.curX = x
        self.curY = y
        self.curZ = z

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bprim = None
        _hx_o.curX = None
        _hx_o.curY = None
        _hx_o.curZ = None
        _hx_o.curR = None
        _hx_o.curG = None
        _hx_o.curB = None
        _hx_o.curA = None
        _hx_o.lineSize = None
        _hx_o.lineShader = None
        _hx_o.tmpPoints = None
        _hx_o.is3D = None
h3d_scene_Graphics._hx_class = h3d_scene_Graphics
_hx_classes["h3d.scene.Graphics"] = h3d_scene_Graphics


class h3d_scene_Interactive(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Interactive"
    _hx_is_interface = "False"
    _hx_fields = ["shape", "preciseShape", "priority", "cursor", "cancelEvents", "propagateEvents", "enableRightButton", "bestMatch", "scene", "mouseDownButton", "hitPoint"]
    _hx_methods = ["onAdd", "onRemove", "preventClick", "getInteractiveScene", "handleEvent", "set_cursor", "focus", "blur", "isOver", "hasFocus", "onOver", "onOut", "onPush", "onRelease", "onReleaseOutside", "onClick", "onMove", "onWheel", "onFocus", "onFocusLost", "onKeyUp", "onKeyDown", "onCheck", "onTextInput"]
    _hx_statics = []
    _hx_interfaces = [hxd_Interactive]
    _hx_super = h3d_scene_Object


    def __init__(self,shape,parent = None):
        self.scene = None
        self.bestMatch = None
        self.enableRightButton = None
        self.cursor = None
        self.priority = None
        self.preciseShape = None
        self.shape = None
        self.hitPoint = h3d_Vector()
        self.mouseDownButton = -1
        self.propagateEvents = False
        self.cancelEvents = False
        super().__init__(parent)
        self.shape = shape
        self.set_cursor(hxd_Cursor.Button)

    def onAdd(self):
        self.scene = self.getScene()
        if (self.scene is not None):
            self.scene.addEventTarget(self)
        super().onAdd()

    def onRemove(self):
        if (self.scene is not None):
            self.scene.removeEventTarget(self)
            self.scene = None
        super().onRemove()

    def preventClick(self):
        self.mouseDownButton = -1

    def getInteractiveScene(self):
        return self.scene

    def handleEvent(self,e):
        if self.propagateEvents:
            e.propagate = True
        if self.cancelEvents:
            e.cancel = True
        tmp = e.kind.index
        if (tmp == 0):
            if (self.enableRightButton or ((e.button == 0))):
                self.mouseDownButton = e.button
                self.onPush(e)
                if e.cancel:
                    self.mouseDownButton = -1
        elif (tmp == 1):
            if (self.enableRightButton or ((e.button == 0))):
                self.onRelease(e)
                if (self.mouseDownButton == e.button):
                    self.onClick(e)
            self.mouseDownButton = -1
        elif (tmp == 2):
            self.onMove(e)
        elif (tmp == 3):
            self.onOver(e)
        elif (tmp == 4):
            self.onOut(e)
        elif (tmp == 5):
            self.onWheel(e)
        elif (tmp == 6):
            self.onFocus(e)
        elif (tmp == 7):
            self.onFocusLost(e)
        elif (tmp == 8):
            self.onKeyDown(e)
        elif (tmp == 9):
            self.onKeyUp(e)
        elif (tmp == 10):
            if (self.enableRightButton or ((e.button == 0))):
                self.onRelease(e)
                if (self.mouseDownButton == e.button):
                    self.onReleaseOutside(e)
            self.mouseDownButton = -1
        elif (tmp == 11):
            self.onTextInput(e)
        elif (tmp == 12):
            self.onCheck(e)
        else:
            pass

    def set_cursor(self,c):
        self.cursor = c
        if ((self.scene is not None) and ((self.scene.events is not None))):
            self.scene.events.updateCursor(self)
        return c

    def focus(self):
        if ((self.scene is None) or ((self.scene.events is None))):
            return
        self.scene.events.focus(self)

    def blur(self):
        if self.hasFocus():
            self.scene.events.blur()

    def isOver(self):
        if ((self.scene is not None) and ((self.scene.events is not None))):
            return (python_internal_ArrayImpl.indexOf(self.scene.events.overList,self,None) != -1)
        else:
            return False

    def hasFocus(self):
        if ((self.scene is not None) and ((self.scene.events is not None))):
            return (self.scene.events.currentFocus == self)
        else:
            return False

    def onOver(self,e):
        pass

    def onOut(self,e):
        pass

    def onPush(self,e):
        pass

    def onRelease(self,e):
        pass

    def onReleaseOutside(self,e):
        pass

    def onClick(self,e):
        pass

    def onMove(self,e):
        pass

    def onWheel(self,e):
        pass

    def onFocus(self,e):
        pass

    def onFocusLost(self,e):
        pass

    def onKeyUp(self,e):
        pass

    def onKeyDown(self,e):
        pass

    def onCheck(self,e):
        pass

    def onTextInput(self,e):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shape = None
        _hx_o.preciseShape = None
        _hx_o.priority = None
        _hx_o.cursor = None
        _hx_o.cancelEvents = None
        _hx_o.propagateEvents = None
        _hx_o.enableRightButton = None
        _hx_o.bestMatch = None
        _hx_o.scene = None
        _hx_o.mouseDownButton = None
        _hx_o.hitPoint = None
h3d_scene_Interactive._hx_class = h3d_scene_Interactive
_hx_classes["h3d.scene.Interactive"] = h3d_scene_Interactive


class h3d_scene_Light(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Light"
    _hx_is_interface = "False"
    __slots__ = ("shader", "objectDistance", "next", "cullingDistance", "priority")
    _hx_fields = ["shader", "objectDistance", "next", "cullingDistance", "priority"]
    _hx_methods = ["get_color", "set_color", "get_enableSpecular", "set_enableSpecular", "emit", "getShadowDirection"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Object


    def __init__(self,shader,parent = None):
        self.next = None
        self.objectDistance = None
        self.shader = None
        self.priority = 0
        self.cullingDistance = -1
        super().__init__(parent)
        self.shader = shader

    def get_color(self):
        return h3d_Vector()

    def set_color(self,v):
        return v

    def get_enableSpecular(self):
        return False

    def set_enableSpecular(self,b):
        if b:
            raise haxe_Exception.thrown("Not implemented for this light")
        return False

    def emit(self,ctx):
        ctx.emitLight(self)

    def getShadowDirection(self):
        return None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shader = None
        _hx_o.objectDistance = None
        _hx_o.next = None
        _hx_o.cullingDistance = None
        _hx_o.priority = None
h3d_scene_Light._hx_class = h3d_scene_Light
_hx_classes["h3d.scene.Light"] = h3d_scene_Light


class h3d_scene_LightSystem:
    _hx_class_name = "h3d.scene.LightSystem"
    _hx_is_interface = "False"
    __slots__ = ("drawPasses", "ambientLight", "shadowLight", "lightCount", "ctx")
    _hx_fields = ["drawPasses", "ambientLight", "shadowLight", "lightCount", "ctx"]
    _hx_methods = ["initGlobals", "cullLights", "initLights", "computeLight"]

    def __init__(self):
        self.ctx = None
        self.lightCount = None
        self.shadowLight = None
        self.drawPasses = 0
        self.ambientLight = h3d_Vector(1,1,1)

    def initGlobals(self,globals):
        pass

    def cullLights(self):
        l = self.ctx.lights
        prev = None
        s = h3d_col_Sphere()
        while (l is not None):
            s.x = l.absPos._41
            s.y = l.absPos._42
            s.z = l.absPos._43
            s.r = l.cullingDistance
            if (((l.cullingDistance > 0) and (not self.ctx.computingStatic)) and (not self.ctx.camera.frustum.hasSphere(s))):
                if (prev is None):
                    self.ctx.lights = l.next
                else:
                    prev.next = l.next
                l = l.next
                continue
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.lightCount
            _hx_local_0.lightCount = (_hx_local_1 + 1)
            _hx_local_1
            l.objectDistance = 0.
            prev = l
            l = l.next

    def initLights(self,ctx):
        self.lightCount = 0
        self.ctx = ctx
        self.cullLights()
        if ((self.shadowLight is None) or ((((self.shadowLight.flags & 32)) == 0))):
            l = ctx.lights
            while (l is not None):
                dir = l.getShadowDirection()
                if (dir is not None):
                    self.shadowLight = l
                    break
                l = l.next

    def computeLight(self,obj,shaders):
        return shaders

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.drawPasses = None
        _hx_o.ambientLight = None
        _hx_o.shadowLight = None
        _hx_o.lightCount = None
        _hx_o.ctx = None
h3d_scene_LightSystem._hx_class = h3d_scene_LightSystem
_hx_classes["h3d.scene.LightSystem"] = h3d_scene_LightSystem


class h3d_scene_MultiMaterial(h3d_scene_Mesh):
    _hx_class_name = "h3d.scene.MultiMaterial"
    _hx_is_interface = "False"
    __slots__ = ("materials",)
    _hx_fields = ["materials"]
    _hx_methods = ["getMeshMaterials", "clone", "emit", "getMaterialByName", "getMaterials", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Mesh


    def __init__(self,prim,mats = None,parent = None):
        self.materials = None
        super().__init__(prim,(None if ((mats is None)) else (mats[0] if 0 < len(mats) else None)),parent)
        self.materials = ([self.material] if ((mats is None)) else mats)

    def getMeshMaterials(self):
        return list(self.materials)

    def clone(self,o = None):
        m = (h3d_scene_MultiMaterial(None,self.materials) if ((o is None)) else o)
        m.materials = []
        _g = 0
        _g1 = self.materials
        while (_g < len(_g1)):
            mat = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _this = m.materials
            x = (None if ((mat is None)) else mat.clone())
            _this.append(x)
        super().clone(m)
        m.material = (m.materials[0] if 0 < len(m.materials) else None)
        return m

    def emit(self,ctx):
        _g = 0
        _g1 = len(self.materials)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            m = (self.materials[i] if i >= 0 and i < len(self.materials) else None)
            if (m is not None):
                index = i
                if (index is None):
                    index = 0
                p = m.passes
                while (p is not None):
                    ctx.emitPass(p,self).index = index
                    p = p.nextPass

    def getMaterialByName(self,name):
        _g = 0
        _g1 = self.materials
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((m is not None) and ((m.name == name))):
                return m
        return super().getMaterialByName(name)

    def getMaterials(self,a = None,recursive = None):
        if (recursive is None):
            recursive = True
        if (a is None):
            a = []
        _g = 0
        _g1 = self.materials
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((m is not None) and ((python_internal_ArrayImpl.indexOf(a,m,None) < 0))):
                a.append(m)
        if recursive:
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                o.getMaterials(a)
        return a

    def draw(self,ctx):
        if (len(self.materials) > 1):
            self.primitive.selectMaterial(ctx.drawPass.index)
        super().draw(ctx)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.materials = None
h3d_scene_MultiMaterial._hx_class = h3d_scene_MultiMaterial
_hx_classes["h3d.scene.MultiMaterial"] = h3d_scene_MultiMaterial


class h3d_scene__Object_ObjectFlags_Impl_:
    _hx_class_name = "h3d.scene._Object.ObjectFlags_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["FPosChanged", "FVisible", "FCulled", "FFollowPositionOnly", "FLightCameraCenter", "FAllocated", "FAlwaysSync", "FInheritCulled", "FNoSerialize", "FIgnoreBounds", "FIgnoreCollide", "FIgnoreParentTransform", "FCullingColliderInherited", "_new", "toInt", "has", "set"]

    @staticmethod
    def _new(value):
        this1 = value
        return this1

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def has(this1,f):
        return (((this1 & f)) != 0)

    @staticmethod
    def set(this1,f,b):
        if b:
            this1 = (this1 | f)
        else:
            this1 = (this1 & ~f)
        return b
h3d_scene__Object_ObjectFlags_Impl_._hx_class = h3d_scene__Object_ObjectFlags_Impl_
_hx_classes["h3d.scene._Object.ObjectFlags_Impl_"] = h3d_scene__Object_ObjectFlags_Impl_


class h3d_scene__RenderContext_SharedGlobal:
    _hx_class_name = "h3d.scene._RenderContext.SharedGlobal"
    _hx_is_interface = "False"
    __slots__ = ("gid", "value")
    _hx_fields = ["gid", "value"]

    def __init__(self,gid,value):
        self.gid = gid
        self.value = value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.gid = None
        _hx_o.value = None
h3d_scene__RenderContext_SharedGlobal._hx_class = h3d_scene__RenderContext_SharedGlobal
_hx_classes["h3d.scene._RenderContext.SharedGlobal"] = h3d_scene__RenderContext_SharedGlobal


class h3d_scene_RenderContext(h3d_impl_RenderContext):
    _hx_class_name = "h3d.scene.RenderContext"
    _hx_is_interface = "False"
    __slots__ = ("camera", "scene", "drawPass", "pbrLightPass", "computingStatic", "sharedGlobals", "lightSystem", "extraShaders", "visibleFlag", "shaderBuffers", "cullingCollider", "allocPool", "allocFirst", "cachedShaderList", "cachedPassObjects", "cachedPos", "passes", "lights", "currentManager")
    _hx_fields = ["camera", "scene", "drawPass", "pbrLightPass", "computingStatic", "sharedGlobals", "lightSystem", "extraShaders", "visibleFlag", "shaderBuffers", "cullingCollider", "allocPool", "allocFirst", "cachedShaderList", "cachedPassObjects", "cachedPos", "passes", "lights", "currentManager"]
    _hx_methods = ["emit", "start", "nextPass", "getGlobal", "setGlobal", "setGlobalID", "emitPass", "allocShaderList", "emitLight", "uploadParams", "done"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_impl_RenderContext


    def __init__(self):
        self.currentManager = None
        self.lights = None
        self.passes = None
        self.cachedPos = None
        self.cachedPassObjects = None
        self.cachedShaderList = None
        self.allocFirst = None
        self.allocPool = None
        self.cullingCollider = None
        self.shaderBuffers = None
        self.visibleFlag = None
        self.extraShaders = None
        self.lightSystem = None
        self.sharedGlobals = None
        self.computingStatic = None
        self.pbrLightPass = None
        self.drawPass = None
        self.scene = None
        self.camera = None
        super().__init__()
        self.cachedShaderList = []
        self.cachedPassObjects = []

    def emit(self,mat,obj,index = None):
        if (index is None):
            index = 0
        p = mat.passes
        while (p is not None):
            self.emitPass(p,obj).index = index
            p = p.nextPass

    def start(self):
        self.sharedGlobals = []
        self.lights = None
        self.drawPass = None
        self.passes = None
        self.lights = None
        self.cachedPos = 0
        self.visibleFlag = True
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.time
        _hx_local_0.time = (_hx_local_1 + self.elapsedTime)
        _hx_local_0.time
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.frame
        _hx_local_2.frame = (_hx_local_3 + 1)
        _hx_local_3

    def nextPass(self):
        self.cachedPos = 0
        self.drawPass = None

    def getGlobal(self,name):
        id = hxsl_Globals.allocID(name)
        _g = 0
        _g1 = self.sharedGlobals
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (g.gid == id):
                return g.value
        return None

    def setGlobal(self,name,value):
        self.setGlobalID(hxsl_Globals.allocID(name),value)

    def setGlobalID(self,gid,value):
        _g = 0
        _g1 = self.sharedGlobals
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (g.gid == gid):
                g.value = value
                return
        _this = self.sharedGlobals
        x = h3d_scene__RenderContext_SharedGlobal(gid,value)
        _this.append(x)

    def emitPass(self,_hx_pass,obj):
        o = self.allocPool
        if (o is None):
            o = h3d_pass_PassObject()
            o.nextAlloc = self.allocFirst
            self.allocFirst = o
        else:
            self.allocPool = o.nextAlloc
        o._hx_pass = _hx_pass
        o.obj = obj
        o.next = self.passes
        self.passes = o
        return o

    def allocShaderList(self,s,next = None):
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.cachedPos
            _hx_local_0.cachedPos = (_hx_local_1 + 1)
            return _hx_local_1
        sl = python_internal_ArrayImpl._get(self.cachedShaderList, _hx_local_2())
        if (sl is None):
            sl = hxsl_ShaderList(None)
            python_internal_ArrayImpl._set(self.cachedShaderList, (self.cachedPos - 1), sl)
        sl.s = s
        sl.next = next
        return sl

    def emitLight(self,l):
        l.next = self.lights
        self.lights = l

    def uploadParams(self):
        self.currentManager.fillParams(self.shaderBuffers,self.drawPass.shader,self.drawPass.shaders)
        self.engine.uploadShaderBuffers(self.shaderBuffers,1)
        self.engine.uploadShaderBuffers(self.shaderBuffers,2)
        self.engine.uploadShaderBuffers(self.shaderBuffers,3)

    def done(self):
        self.drawPass = None
        p = self.allocFirst
        while ((p is not None) and ((p != self.allocPool))):
            p.obj = None
            p._hx_pass = None
            p.shader = None
            p.shaders = None
            p.next = None
            p.index = 0
            p.texture = 0
            p = p.nextAlloc
        if (self.allocPool is not None):
            self.allocFirst = self.allocFirst.nextAlloc
        self.allocPool = self.allocFirst
        _g = 0
        _g1 = self.cachedShaderList
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.s = None
            c.next = None
        self.passes = None
        self.lights = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.camera = None
        _hx_o.scene = None
        _hx_o.drawPass = None
        _hx_o.pbrLightPass = None
        _hx_o.computingStatic = None
        _hx_o.sharedGlobals = None
        _hx_o.lightSystem = None
        _hx_o.extraShaders = None
        _hx_o.visibleFlag = None
        _hx_o.shaderBuffers = None
        _hx_o.cullingCollider = None
        _hx_o.allocPool = None
        _hx_o.allocFirst = None
        _hx_o.cachedShaderList = None
        _hx_o.cachedPassObjects = None
        _hx_o.cachedPos = None
        _hx_o.passes = None
        _hx_o.lights = None
        _hx_o.currentManager = None
h3d_scene_RenderContext._hx_class = h3d_scene_RenderContext
_hx_classes["h3d.scene.RenderContext"] = h3d_scene_RenderContext


class h3d_scene_PassObjects:
    _hx_class_name = "h3d.scene.PassObjects"
    _hx_is_interface = "False"
    __slots__ = ("name", "passes", "rendered")
    _hx_fields = ["name", "passes", "rendered"]

    def __init__(self):
        self.rendered = None
        self.name = None
        self.passes = h3d_pass_PassList()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.passes = None
        _hx_o.rendered = None
h3d_scene_PassObjects._hx_class = h3d_scene_PassObjects
_hx_classes["h3d.scene.PassObjects"] = h3d_scene_PassObjects

class h3d_scene_RenderMode(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.scene.RenderMode"
    _hx_constructs = ["Default", "LightProbe"]
h3d_scene_RenderMode.Default = h3d_scene_RenderMode("Default", 0, ())
h3d_scene_RenderMode.LightProbe = h3d_scene_RenderMode("LightProbe", 1, ())
h3d_scene_RenderMode._hx_class = h3d_scene_RenderMode
_hx_classes["h3d.scene.RenderMode"] = h3d_scene_RenderMode


class h3d_scene_Renderer(hxd_impl_AnyProps):
    _hx_class_name = "h3d.scene.Renderer"
    _hx_is_interface = "False"
    __slots__ = ("defaultPass", "passObjects", "allPasses", "emptyPasses", "ctx", "hasSetTarget", "frontToBack", "backToFront", "effects", "renderMode")
    _hx_fields = ["defaultPass", "passObjects", "allPasses", "emptyPasses", "ctx", "hasSetTarget", "frontToBack", "backToFront", "effects", "renderMode"]
    _hx_methods = ["getEffect", "dispose", "mark", "addShader", "getPass", "getPassByName", "debugCompileShader", "hasFeature", "getDefaultLight", "getLightSystem", "depthSort", "clear", "allocTarget", "copy", "setTarget", "setTargets", "resetTarget", "has", "get", "draw", "render", "computeStatic", "start", "process"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_impl_AnyProps


    def __init__(self):
        self.backToFront = None
        self.frontToBack = None
        self.ctx = None
        self.defaultPass = None
        self.renderMode = h3d_scene_RenderMode.Default
        self.effects = []
        self.hasSetTarget = False
        self.emptyPasses = h3d_pass_PassList()
        self.allPasses = []
        self.passObjects = haxe_ds_StringMap()
        self.set_props(self.getDefaultProps())
        _g = self.depthSort
        frontToBack = True
        def _hx_local_0(passes):
            _g(frontToBack,passes)
        self.frontToBack = _hx_local_0
        _g1 = self.depthSort
        frontToBack1 = False
        def _hx_local_1(passes):
            _g1(frontToBack1,passes)
        self.backToFront = _hx_local_1

    def getEffect(self,cl):
        _g = 0
        _g1 = self.effects
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f1 = Std.downcast(f,cl)
            if (f1 is not None):
                return f1
        return None

    def dispose(self):
        _g = 0
        _g1 = self.allPasses
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.dispose()
        _g = 0
        _g1 = self.effects
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f.dispose()
        self.passObjects = haxe_ds_StringMap()

    def mark(self,id):
        pass

    def addShader(self,s):
        pass

    def getPass(self,c):
        _g = 0
        _g1 = self.allPasses
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if Std.isOfType(p,c):
                return p
        return None

    def getPassByName(self,name):
        _g = 0
        _g1 = self.allPasses
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (p.name == name):
                return p
        return None

    def debugCompileShader(self,_hx_pass):
        p = self.getPassByName(_hx_pass.name)
        if (p is None):
            p = self.defaultPass
        p.setContext(self.ctx)
        return p.compileShader(_hx_pass)

    def hasFeature(self,f):
        return h3d_Engine.CURRENT.driver.hasFeature(f)

    def getDefaultLight(self,l):
        return l

    def getLightSystem(self):
        return self.ctx.scene.lightSystem

    def depthSort(self,frontToBack,passes):
        cam = self.ctx.camera.m
        _g_o = passes.current
        while (_g_o is not None):
            tmp = _g_o
            _g_o = _g_o.next
            p = tmp
            z = ((((p.obj.absPos._41 * cam._13) + ((p.obj.absPos._42 * cam._23))) + ((p.obj.absPos._43 * cam._33))) + cam._43)
            w = ((((p.obj.absPos._41 * cam._14) + ((p.obj.absPos._42 * cam._24))) + ((p.obj.absPos._43 * cam._34))) + cam._44)
            p.depth = (z / w)
        if frontToBack:
            _hx_list = passes.current
            tmp = None
            if (_hx_list is None):
                tmp = None
            else:
                insize = 1
                nmerges = None
                psize = 0
                qsize = 0
                p = None
                q = None
                e = None
                tail = None
                while True:
                    p = _hx_list
                    _hx_list = None
                    tail = None
                    nmerges = 0
                    while (p is not None):
                        nmerges = (nmerges + 1)
                        q = p
                        psize = 0
                        _g = 0
                        _g1 = insize
                        while (_g < _g1):
                            i = _g
                            _g = (_g + 1)
                            psize = (psize + 1)
                            q = q.next
                            if (q is None):
                                break
                        qsize = insize
                        while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                            if (psize == 0):
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            elif (((qsize == 0) or ((q is None))) or ((((1 if ((p.depth > q.depth)) else -1)) <= 0))):
                                e = p
                                p = p.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            if (tail is not None):
                                tail.next = e
                            else:
                                _hx_list = e
                            tail = e
                        p = q
                    tail.next = None
                    if (nmerges <= 1):
                        break
                    insize = (insize * 2)
                tmp = _hx_list
            passes.current = tmp
        else:
            _hx_list = passes.current
            tmp = None
            if (_hx_list is None):
                tmp = None
            else:
                insize = 1
                nmerges = None
                psize = 0
                qsize = 0
                p = None
                q = None
                e = None
                tail = None
                while True:
                    p = _hx_list
                    _hx_list = None
                    tail = None
                    nmerges = 0
                    while (p is not None):
                        nmerges = (nmerges + 1)
                        q = p
                        psize = 0
                        _g = 0
                        _g1 = insize
                        while (_g < _g1):
                            i = _g
                            _g = (_g + 1)
                            psize = (psize + 1)
                            q = q.next
                            if (q is None):
                                break
                        qsize = insize
                        while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                            if (psize == 0):
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            elif (((qsize == 0) or ((q is None))) or ((((-1 if ((p.depth > q.depth)) else 1)) <= 0))):
                                e = p
                                p = p.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            if (tail is not None):
                                tail.next = e
                            else:
                                _hx_list = e
                            tail = e
                        p = q
                    tail.next = None
                    if (nmerges <= 1):
                        break
                    insize = (insize * 2)
                tmp = _hx_list
            passes.current = tmp

    def clear(self,color = None,depth = None,stencil = None):
        self.ctx.engine.clear(color,depth,stencil)

    def allocTarget(self,name,depth = None,size = None,format = None):
        if (depth is None):
            depth = True
        if (size is None):
            size = 1.
        return self.ctx.textures.allocTarget(name,Math.floor(((self.ctx.engine.width * size) + 0.5)),Math.floor(((self.ctx.engine.height * size) + 0.5)),depth,format)

    def copy(self,_hx_from,to,blend = None):
        h3d_pass_Copy.run(_hx_from,to,blend)

    def setTarget(self,tex):
        if self.hasSetTarget:
            self.ctx.engine.popTarget()
        self.ctx.engine.pushTarget(tex)
        self.hasSetTarget = True

    def setTargets(self,textures):
        if self.hasSetTarget:
            self.ctx.engine.popTarget()
        self.ctx.engine.pushTargets(textures)
        self.hasSetTarget = True

    def resetTarget(self):
        if self.hasSetTarget:
            self.ctx.engine.popTarget()
            self.hasSetTarget = False

    def has(self,name):
        return (self.passObjects.h.get(name,None) is not None)

    def get(self,name):
        p = self.passObjects.h.get(name,None)
        if (p is None):
            return self.emptyPasses
        p.rendered = True
        return p.passes

    def draw(self,name):
        self.defaultPass.draw(self.get(name))

    def render(self):
        raise haxe_Exception.thrown("Not implemented")

    def computeStatic(self):
        raise haxe_Exception.thrown("Not implemented")

    def start(self):
        pass

    def process(self,passes):
        self.hasSetTarget = False
        _g = 0
        _g1 = self.allPasses
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.setContext(self.ctx)
        _g = 0
        while (_g < len(passes)):
            p = (passes[_g] if _g >= 0 and _g < len(passes) else None)
            _g = (_g + 1)
            self.passObjects.h[p.name] = p
        self.ctx.textures.begin()
        if self.ctx.computingStatic:
            self.computeStatic()
        else:
            self.render()
        self.resetTarget()
        _g = 0
        while (_g < len(passes)):
            p = (passes[_g] if _g >= 0 and _g < len(passes) else None)
            _g = (_g + 1)
            self.passObjects.h[p.name] = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.defaultPass = None
        _hx_o.passObjects = None
        _hx_o.allPasses = None
        _hx_o.emptyPasses = None
        _hx_o.ctx = None
        _hx_o.hasSetTarget = None
        _hx_o.frontToBack = None
        _hx_o.backToFront = None
        _hx_o.effects = None
        _hx_o.renderMode = None
h3d_scene_Renderer._hx_class = h3d_scene_Renderer
_hx_classes["h3d.scene.Renderer"] = h3d_scene_Renderer


class h3d_scene_Scene(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Scene"
    _hx_is_interface = "False"
    __slots__ = ("camera", "lightSystem", "renderer", "ctx", "interactives", "events", "hitInteractives", "eventListeners", "window", "hardwarePass")
    _hx_fields = ["camera", "lightSystem", "renderer", "ctx", "interactives", "events", "hitInteractives", "eventListeners", "window", "hardwarePass"]
    _hx_methods = ["setEvents", "addEventListener", "removeEventListener", "dispatchListeners", "set_renderer", "sortHitPointByCameraDistance", "dispatchEvent", "isInteractiveVisible", "handleEvent", "clone", "dispose", "addEventTarget", "removeEventTarget", "setElapsedTime", "hardwarePick", "syncOnly", "computeStatic", "render", "serializeScene"]
    _hx_statics = []
    _hx_interfaces = [hxd_InteractiveScene, h3d_IDrawable]
    _hx_super = h3d_scene_Object


    def __init__(self,createRenderer = None,createLightSystem = None):
        if (createRenderer is None):
            createRenderer = True
        if (createLightSystem is None):
            createLightSystem = True
        self.hardwarePass = None
        self.window = None
        self.eventListeners = None
        self.hitInteractives = None
        self.events = None
        self.interactives = None
        self.ctx = None
        self.renderer = None
        self.lightSystem = None
        self.camera = None
        super().__init__(None)
        self.window = hxd_Window.getInstance()
        self.eventListeners = []
        self.hitInteractives = []
        self.interactives = []
        self.camera = h3d_Camera()
        engine = h3d_Engine.CURRENT
        if (engine is not None):
            self.camera.screenRatio = (engine.width / engine.height)
        self.ctx = h3d_scene_RenderContext()
        if createRenderer:
            self.set_renderer(h3d_mat_MaterialSetup.current.createRenderer())
        if createLightSystem:
            self.lightSystem = h3d_mat_MaterialSetup.current.createLightSystem()

    def setEvents(self,events):
        self.events = events

    def addEventListener(self,f):
        _this = self.eventListeners
        _this.append(f)

    def removeEventListener(self,f):
        _g = 0
        _g1 = self.eventListeners
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if Reflect.compareMethods(e,f):
                python_internal_ArrayImpl.remove(self.eventListeners,e)
                return True
        return False

    def dispatchListeners(self,event):
        _g = 0
        _g1 = self.eventListeners
        while (_g < len(_g1)):
            l = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            l(event)
            if (not event.propagate):
                break

    def set_renderer(self,r):
        self.renderer = r
        if (r is not None):
            r.ctx = self.ctx
        return r

    def sortHitPointByCameraDistance(self,i1,i2):
        z1 = i1.hitPoint.w
        z2 = i2.hitPoint.w
        if (z1 > z2):
            return -1
        return 1

    def dispatchEvent(self,event,to):
        i = to
        i.handleEvent(event)

    def isInteractiveVisible(self,i):
        o = i
        while (o != self):
            if ((o is None) or ((((o.flags & 2)) == 0))):
                return False
            o = o.parent
        return True

    def handleEvent(self,event,last):
        if (len(self.interactives) == 0):
            return None
        if (len(self.hitInteractives) == 0):
            screenX = ((((event.relX / self.window.get_width()) - 0.5)) * 2)
            screenY = (-(((event.relY / self.window.get_height()) - 0.5)) * 2)
            p0 = self.camera.unproject(screenX,screenY,0)
            p1 = self.camera.unproject(screenX,screenY,1)
            x = p0.x
            y = p0.y
            z = p0.z
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p1_x = x
            p1_y = y
            p1_z = z
            x = p1.x
            y = p1.y
            z = p1.z
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p2_x = x
            p2_y = y
            p2_z = z
            r = h3d_col_Ray()
            r.px = p1_x
            r.py = p1_y
            r.pz = p1_z
            r.lx = (p2_x - p1_x)
            r.ly = (p2_y - p1_y)
            r.lz = (p2_z - p1_z)
            r.normalize()
            r1 = r
            saveR_px = r1.px
            saveR_py = r1.py
            saveR_pz = r1.pz
            saveR_lx = r1.lx
            saveR_ly = r1.ly
            saveR_lz = r1.lz
            priority = -2147483648
            _g = 0
            _g1 = self.interactives
            while (_g < len(_g1)):
                i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (i.priority < priority):
                    continue
                p = i
                while ((p is not None) and ((((p.flags & 2)) != 0))):
                    p = p.parent
                if (p is not None):
                    continue
                minv = i.getInvPos()
                x = r1.px
                y = r1.py
                z = r1.pz
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                p_x = x
                p_y = y
                p_z = z
                p_w = 1.
                px = ((((p_x * minv._11) + ((p_y * minv._21))) + ((p_z * minv._31))) + ((p_w * minv._41)))
                py = ((((p_x * minv._12) + ((p_y * minv._22))) + ((p_z * minv._32))) + ((p_w * minv._42)))
                pz = ((((p_x * minv._13) + ((p_y * minv._23))) + ((p_z * minv._33))) + ((p_w * minv._43)))
                p_x = px
                p_y = py
                p_z = pz
                r1.px = p_x
                r1.py = p_y
                r1.pz = p_z
                x1 = r1.lx
                y1 = r1.ly
                z1 = r1.lz
                if (z1 is None):
                    z1 = 0.
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                l_x = x1
                l_y = y1
                l_z = z1
                l_w = 1.
                px1 = (((l_x * minv._11) + ((l_y * minv._21))) + ((l_z * minv._31)))
                py1 = (((l_x * minv._12) + ((l_y * minv._22))) + ((l_z * minv._32)))
                pz1 = (((l_x * minv._13) + ((l_y * minv._23))) + ((l_z * minv._33)))
                l_x = px1
                l_y = py1
                l_z = pz1
                r1.lx = l_x
                r1.ly = l_y
                r1.lz = l_z
                r1.normalize()
                if (r1.lx != r1.lx):
                    r1.px = saveR_px
                    r1.py = saveR_py
                    r1.pz = saveR_pz
                    r1.lx = saveR_lx
                    r1.ly = saveR_ly
                    r1.lz = saveR_lz
                    continue
                hit = i.shape.rayIntersection(r1,i.bestMatch)
                if (hit < 0):
                    r1.px = saveR_px
                    r1.py = saveR_py
                    r1.pz = saveR_pz
                    r1.lx = saveR_lx
                    r1.ly = saveR_ly
                    r1.lz = saveR_lz
                    continue
                x2 = (r1.px + ((hit * r1.lx)))
                y2 = (r1.py + ((hit * r1.ly)))
                z2 = (r1.pz + ((hit * r1.lz)))
                if (z2 is None):
                    z2 = 0.
                if (y2 is None):
                    y2 = 0.
                if (x2 is None):
                    x2 = 0.
                hitPoint_x = x2
                hitPoint_y = y2
                hitPoint_z = z2
                r1.px = saveR_px
                r1.py = saveR_py
                r1.pz = saveR_pz
                r1.lx = saveR_lx
                r1.ly = saveR_ly
                r1.lz = saveR_lz
                i.hitPoint.x = hitPoint_x
                i.hitPoint.y = hitPoint_y
                i.hitPoint.z = hitPoint_z
                if (i.priority > priority):
                    while (len(self.hitInteractives) > 0):
                        _this = self.hitInteractives
                        if (len(_this) != 0):
                            _this.pop()
                    priority = i.priority
                _this1 = self.hitInteractives
                _this1.append(i)
            if (len(self.hitInteractives) == 0):
                return None
            if (len(self.hitInteractives) > 1):
                _g = 0
                _g1 = self.hitInteractives
                while (_g < len(_g1)):
                    i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    m = i.invPos
                    wfactor = 0.
                    if (i.preciseShape is not None):
                        x = r1.px
                        y = r1.py
                        z = r1.pz
                        if (z is None):
                            z = 0.
                        if (y is None):
                            y = 0.
                        if (x is None):
                            x = 0.
                        p_x = x
                        p_y = y
                        p_z = z
                        p_w = 1.
                        px = ((((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31))) + ((p_w * m._41)))
                        py = ((((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32))) + ((p_w * m._42)))
                        pz = ((((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33))) + ((p_w * m._43)))
                        p_x = px
                        p_y = py
                        p_z = pz
                        r1.px = p_x
                        r1.py = p_y
                        r1.pz = p_z
                        x1 = r1.lx
                        y1 = r1.ly
                        z1 = r1.lz
                        if (z1 is None):
                            z1 = 0.
                        if (y1 is None):
                            y1 = 0.
                        if (x1 is None):
                            x1 = 0.
                        l_x = x1
                        l_y = y1
                        l_z = z1
                        l_w = 1.
                        px1 = (((l_x * m._11) + ((l_y * m._21))) + ((l_z * m._31)))
                        py1 = (((l_x * m._12) + ((l_y * m._22))) + ((l_z * m._32)))
                        pz1 = (((l_x * m._13) + ((l_y * m._23))) + ((l_z * m._33)))
                        l_x = px1
                        l_y = py1
                        l_z = pz1
                        r1.lx = l_x
                        r1.ly = l_y
                        r1.lz = l_z
                        r1.normalize()
                        hit = i.preciseShape.rayIntersection(r1,i.bestMatch)
                        if (hit > 0):
                            x2 = (r1.px + ((hit * r1.lx)))
                            y2 = (r1.py + ((hit * r1.ly)))
                            z2 = (r1.pz + ((hit * r1.lz)))
                            if (z2 is None):
                                z2 = 0.
                            if (y2 is None):
                                y2 = 0.
                            if (x2 is None):
                                x2 = 0.
                            hitPoint_x = x2
                            hitPoint_y = y2
                            hitPoint_z = z2
                            i.hitPoint.x = hitPoint_x
                            i.hitPoint.y = hitPoint_y
                            i.hitPoint.z = hitPoint_z
                        else:
                            wfactor = 1.
                        r1.px = saveR_px
                        r1.py = saveR_py
                        r1.pz = saveR_pz
                        r1.lx = saveR_lx
                        r1.ly = saveR_ly
                        r1.lz = saveR_lz
                    _this = i.hitPoint
                    x3 = _this.x
                    y3 = _this.y
                    z3 = _this.z
                    w = _this.w
                    if (w is None):
                        w = 1.
                    if (z3 is None):
                        z3 = 0.
                    if (y3 is None):
                        y3 = 0.
                    if (x3 is None):
                        x3 = 0.
                    p_x1 = x3
                    p_y1 = y3
                    p_z1 = z3
                    p_w1 = w
                    p_w1 = 1
                    m1 = i.absPos
                    px2 = ((((p_x1 * m1._11) + ((p_y1 * m1._21))) + ((p_z1 * m1._31))) + ((p_w1 * m1._41)))
                    py2 = ((((p_x1 * m1._12) + ((p_y1 * m1._22))) + ((p_z1 * m1._32))) + ((p_w1 * m1._42)))
                    pz2 = ((((p_x1 * m1._13) + ((p_y1 * m1._23))) + ((p_z1 * m1._33))) + ((p_w1 * m1._43)))
                    p_x1 = px2
                    p_y1 = py2
                    p_z1 = pz2
                    m2 = self.camera.m
                    px3 = ((((p_x1 * m2._11) + ((p_y1 * m2._21))) + ((p_z1 * m2._31))) + ((p_w1 * m2._41)))
                    py3 = ((((p_x1 * m2._12) + ((p_y1 * m2._22))) + ((p_z1 * m2._32))) + ((p_w1 * m2._42)))
                    pz3 = ((((p_x1 * m2._13) + ((p_y1 * m2._23))) + ((p_z1 * m2._33))) + ((p_w1 * m2._43)))
                    iw = (1 / (((((p_x1 * m2._14) + ((p_y1 * m2._24))) + ((p_z1 * m2._34))) + ((p_w1 * m2._44)))))
                    p_x1 = (px3 * iw)
                    p_y1 = (py3 * iw)
                    p_z1 = (pz3 * iw)
                    p_w1 = 1
                    i.hitPoint.w = (p_z1 + wfactor)
                self.hitInteractives.sort(key= python_lib_Functools.cmp_to_key(self.sortHitPointByCameraDistance))
            self.hitInteractives.insert(0, None)
        while (len(self.hitInteractives) > 0):
            _this = self.hitInteractives
            i = (None if ((len(_this) == 0)) else _this.pop())
            if (i is None):
                return None
            event.relX = i.hitPoint.x
            event.relY = i.hitPoint.y
            event.relZ = i.hitPoint.z
            i.handleEvent(event)
            if event.cancel:
                event.cancel = False
                event.propagate = False
                continue
            if (not event.propagate):
                while (len(self.hitInteractives) > 0):
                    _this1 = self.hitInteractives
                    if (len(_this1) != 0):
                        _this1.pop()
            return i
        return None

    def clone(self,o = None):
        s = (h3d_scene_Scene() if ((o is None)) else o)
        s.camera = self.camera.clone()
        super().clone(s)
        return s

    def dispose(self):
        if (((self.flags & 32)) != 0):
            self.onRemove()
        if (self.hardwarePass is not None):
            self.hardwarePass.dispose()
            self.hardwarePass = None
        self.ctx.dispose()
        if (self.renderer is not None):
            self.renderer.dispose()
            self.set_renderer(h3d_scene_Renderer())

    def addEventTarget(self,i):
        if (python_internal_ArrayImpl.indexOf(self.interactives,i,None) >= 0):
            raise haxe_Exception.thrown("assert")
        _this = self.interactives
        _this.append(i)

    def removeEventTarget(self,i):
        if python_internal_ArrayImpl.remove(self.interactives,i):
            if (self.events is not None):
                self.events.onRemove(i)
            python_internal_ArrayImpl.remove(self.hitInteractives,i)

    def setElapsedTime(self,elapsedTime):
        self.ctx.elapsedTime = elapsedTime

    def hardwarePick(self,pixelX,pixelY):
        _gthis = self
        engine = h3d_Engine.CURRENT
        self.camera.screenRatio = (engine.width / engine.height)
        self.camera.update()
        self.ctx.camera = self.camera
        self.ctx.engine = engine
        self.ctx.scene = self
        self.ctx.start()
        ray = self.camera.rayFromScreen(pixelX,pixelY)
        savedRay_pz = None
        savedRay_py = None
        savedRay_px = None
        savedRay_lz = None
        savedRay_ly = None
        savedRay_lx = None
        savedRay_px = ray.px
        savedRay_py = ray.py
        savedRay_pz = ray.pz
        savedRay_lx = ray.lx
        savedRay_ly = ray.ly
        savedRay_lz = ray.lz
        def _hx_local_0(m):
            if (m.primitive is None):
                return
            m1 = m.getInvPos()
            x = ray.px
            y = ray.py
            z = ray.pz
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p_x = x
            p_y = y
            p_z = z
            p_w = 1.
            px = ((((p_x * m1._11) + ((p_y * m1._21))) + ((p_z * m1._31))) + ((p_w * m1._41)))
            py = ((((p_x * m1._12) + ((p_y * m1._22))) + ((p_z * m1._32))) + ((p_w * m1._42)))
            pz = ((((p_x * m1._13) + ((p_y * m1._23))) + ((p_z * m1._33))) + ((p_w * m1._43)))
            p_x = px
            p_y = py
            p_z = pz
            ray.px = p_x
            ray.py = p_y
            ray.pz = p_z
            x = ray.lx
            y = ray.ly
            z = ray.lz
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            l_x = x
            l_y = y
            l_z = z
            l_w = 1.
            px = (((l_x * m1._11) + ((l_y * m1._21))) + ((l_z * m1._31)))
            py = (((l_x * m1._12) + ((l_y * m1._22))) + ((l_z * m1._32)))
            pz = (((l_x * m1._13) + ((l_y * m1._23))) + ((l_z * m1._33)))
            l_x = px
            l_y = py
            l_z = pz
            ray.lx = l_x
            ray.ly = l_y
            ray.lz = l_z
            ray.normalize()
            if (m.primitive.getBounds().rayIntersection(ray,False) >= 0):
                _gthis.ctx.emitPass(m.material.passes,m)
            ray.px = savedRay_px
            ray.py = savedRay_py
            ray.pz = savedRay_pz
            ray.lx = savedRay_lx
            ray.ly = savedRay_ly
            ray.lz = savedRay_lz
        self.iterVisibleMeshes(_hx_local_0)
        self.ctx.lightSystem = None
        found = None
        passes = h3d_pass_PassList(self.ctx.passes)
        if (passes.current is not None):
            p = self.hardwarePass
            if (p is None):
                p = h3d_pass_HardwarePick()
                self.hardwarePass = p
            _this = self.ctx
            value = _hx_AnonObject({'texture': h3d_mat_Texture.fromColor(267386880,0)})
            _this.setGlobalID(hxsl_Globals.allocID("depthMap"),value)
            p.pickX = pixelX
            p.pickY = pixelY
            p.setContext(self.ctx)
            p.draw(passes)
            if (p.pickedIndex >= 0):
                _g_o = passes.current
                while (_g_o is not None):
                    tmp = _g_o
                    _g_o = _g_o.next
                    po = tmp
                    def _hx_local_2():
                        _hx_local_1 = p.pickedIndex
                        p.pickedIndex = (p.pickedIndex - 1)
                        return _hx_local_1
                    tmp1 = (_hx_local_2() == 0)
                    if tmp1:
                        found = po.obj
                        break
        self.ctx.done()
        self.ctx.camera = None
        self.ctx.engine = None
        self.ctx.scene = None
        return found

    def syncOnly(self,et):
        engine = h3d_Engine.CURRENT
        self.setElapsedTime(et)
        t = engine.getCurrentTarget()
        if (t is None):
            self.camera.screenRatio = (engine.width / engine.height)
        else:
            self.camera.screenRatio = (t.width / t.height)
        self.camera.update()
        self.ctx.camera = self.camera
        self.ctx.engine = engine
        self.ctx.scene = self
        self.ctx.start()
        self.syncRec(self.ctx)
        self.ctx.camera = None
        self.ctx.engine = None
        self.ctx.scene = None

    def computeStatic(self):
        old = self.ctx.elapsedTime
        self.ctx.elapsedTime = 0
        self.ctx.computingStatic = True
        self.render(h3d_Engine.CURRENT)
        self.ctx.computingStatic = False
        self.ctx.elapsedTime = old

    def render(self,engine):
        if (((self.flags & 32)) == 0):
            self.onAdd()
        t = engine.getCurrentTarget()
        if (t is None):
            self.camera.screenRatio = (engine.width / engine.height)
        else:
            self.camera.screenRatio = (t.width / t.height)
        self.camera.update()
        if self.camera.rightHanded:
            engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,1)
        self.ctx.camera = self.camera
        self.ctx.engine = engine
        self.ctx.scene = self
        self.ctx.start()
        self.renderer.start()
        self.syncRec(self.ctx)
        self.emitRec(self.ctx)
        _hx_list = self.ctx.passes
        tmp = None
        if (_hx_list is None):
            tmp = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p = None
            q = None
            e = None
            tail = None
            while True:
                p = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p is not None):
                    nmerges = (nmerges + 1)
                    q = p
                    psize = 0
                    _g = 0
                    _g1 = insize
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        elif (((qsize == 0) or ((q is None))) or (((p._hx_pass.passId - q._hx_pass.passId) <= 0))):
                            e = p
                            p = p.next
                            psize = (psize - 1)
                        else:
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            tmp = _hx_list
        self.ctx.passes = tmp
        curPass = self.ctx.passes
        passes = []
        passIndex = -1
        while (curPass is not None):
            passId = curPass._hx_pass.passId
            p = curPass
            prev = None
            while ((p is not None) and ((p._hx_pass.passId == passId))):
                prev = p
                p = p.next
            prev.next = None
            passIndex = (passIndex + 1)
            pobjs = passIndex
            pobjs1 = python_internal_ArrayImpl._get(self.ctx.cachedPassObjects, pobjs)
            if (pobjs1 is None):
                pobjs1 = h3d_scene_PassObjects()
                python_internal_ArrayImpl._set(self.ctx.cachedPassObjects, passIndex, pobjs1)
            pobjs1.name = curPass._hx_pass.name
            _this = pobjs1.passes
            _this.current = curPass
            def _hx_local_6():
                _this.lastDisc = None
                return _this.lastDisc
            _this.discarded = _hx_local_6()
            passes.append(pobjs1)
            curPass = p
        if (self.lightSystem is not None):
            self.ctx.lightSystem = self.lightSystem
            self.lightSystem.initLights(self.ctx)
        self.renderer.process(passes)
        if self.camera.rightHanded:
            engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,0)
        self.ctx.done()
        self.ctx.scene = None
        self.ctx.camera = None
        self.ctx.engine = None
        _g = 0
        _g1 = passIndex
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p = python_internal_ArrayImpl._get(self.ctx.cachedPassObjects, i)
            p.name = None
            _this = p.passes
            _this.current = None
            def _hx_local_7():
                _this.lastDisc = None
                return _this.lastDisc
            _this.discarded = _hx_local_7()

    def serializeScene(self):
        raise haxe_Exception.thrown("You need -lib hxbit to serialize the scene data")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.camera = None
        _hx_o.lightSystem = None
        _hx_o.renderer = None
        _hx_o.ctx = None
        _hx_o.interactives = None
        _hx_o.events = None
        _hx_o.hitInteractives = None
        _hx_o.eventListeners = None
        _hx_o.window = None
        _hx_o.hardwarePass = None
h3d_scene_Scene._hx_class = h3d_scene_Scene
_hx_classes["h3d.scene.Scene"] = h3d_scene_Scene


class h3d_scene_Joint(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Joint"
    _hx_is_interface = "False"
    __slots__ = ("skin", "index")
    _hx_fields = ["skin", "index"]
    _hx_methods = ["getObjectByName", "syncPos"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Object


    def __init__(self,skin,j):
        self.index = None
        self.skin = None
        super().__init__(None)
        self.name = j.name
        self.skin = skin
        self.parent = skin
        self.index = j.index

    def getObjectByName(self,name):
        sk = self.skin.getSkinData()
        j = sk.namedJoints.h.get(name,None)
        if (j is None):
            return None
        cur = python_internal_ArrayImpl._get(sk.allJoints, self.index)
        if (cur.index != self.index):
            raise haxe_Exception.thrown("assert")
        jp = j.parent
        while (jp is not None):
            if (jp == cur):
                jo = h3d_scene_Joint(self.skin,j)
                jo.parent = self
                return jo
            jp = jp.parent
        return None

    def syncPos(self):
        p = self.parent
        while (p is not None):
            if (((p.flags & 1)) != 0):
                if (self.skin.jointsAbsPosInv is None):
                    self.skin.jointsAbsPosInv = h3d_Matrix()
                    self.skin.jointsAbsPosInv.zero()
                if (self.skin.jointsAbsPosInv._44 == 0):
                    self.skin.jointsAbsPosInv.inverse3x4(self.parent.absPos)
                self.parent.syncPos()
                self.lastFrame = -1
                break
            p = p.parent
        if (self.lastFrame != self.skin.lastFrame):
            self.lastFrame = self.skin.lastFrame
            self.absPos.load(python_internal_ArrayImpl._get(self.skin.currentAbsPose, self.index))
            if ((self.skin.jointsAbsPosInv is not None) and ((self.skin.jointsAbsPosInv._44 != 0))):
                self.absPos.multiply3x4(self.absPos,self.skin.jointsAbsPosInv)
                self.absPos.multiply3x4(self.absPos,self.parent.absPos)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.skin = None
        _hx_o.index = None
h3d_scene_Joint._hx_class = h3d_scene_Joint
_hx_classes["h3d.scene.Joint"] = h3d_scene_Joint


class h3d_scene_Skin(h3d_scene_MultiMaterial):
    _hx_class_name = "h3d.scene.Skin"
    _hx_is_interface = "False"
    __slots__ = ("skinData", "currentRelPose", "currentAbsPose", "currentPalette", "splitPalette", "jointsUpdated", "jointsAbsPosInv", "paletteChanged", "skinShader", "jointsGraphics", "showJoints", "enableRetargeting")
    _hx_fields = ["skinData", "currentRelPose", "currentAbsPose", "currentPalette", "splitPalette", "jointsUpdated", "jointsAbsPosInv", "paletteChanged", "skinShader", "jointsGraphics", "showJoints", "enableRetargeting"]
    _hx_methods = ["clone", "getBoundsRec", "getCurrentSkeletonBounds", "getObjectByName", "getLocalCollider", "getGlobalCollider", "calcAbsPos", "getSkinData", "setSkinData", "sync", "syncJoints", "emit", "draw"]
    _hx_statics = ["TMP_MAT"]
    _hx_interfaces = []
    _hx_super = h3d_scene_MultiMaterial


    def __init__(self,s,mat = None,parent = None):
        self.showJoints = None
        self.jointsGraphics = None
        self.skinShader = None
        self.paletteChanged = None
        self.jointsAbsPosInv = None
        self.jointsUpdated = None
        self.splitPalette = None
        self.currentPalette = None
        self.currentAbsPose = None
        self.currentRelPose = None
        self.skinData = None
        self.enableRetargeting = True
        super().__init__(None,mat,parent)
        if (s is not None):
            self.setSkinData(s)

    def clone(self,o = None):
        s = (h3d_scene_Skin(None,list(self.materials)) if ((o is None)) else o)
        super().clone(s)
        s.setSkinData(self.skinData)
        s.currentRelPose = list(self.currentRelPose)
        return s

    def getBoundsRec(self,b):
        old = self.primitive
        self.set_primitive(None)
        b = super().getBoundsRec(b)
        self.set_primitive(old)
        if (((self.flags & 512)) != 0):
            return b
        self.syncJoints()
        if (self.skinData.vertexWeights is None):
            def _hx_local_1():
                _hx_local_0 = self.primitive
                if (Std.isOfType(_hx_local_0,h3d_prim_HMDModel) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            (_hx_local_1()).loadSkin(self.skinData)
        _g = 0
        _g1 = self.skinData.allJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (j.offsetRay < 0):
                continue
            m = python_internal_ArrayImpl._get(self.currentPalette, j.bindIndex)
            _this = j.offsets
            x = _this.xMin
            y = _this.yMin
            z = _this.zMin
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            pt_x = x
            pt_y = y
            pt_z = z
            px = ((((pt_x * m._11) + ((pt_y * m._21))) + ((pt_z * m._31))) + m._41)
            py = ((((pt_x * m._12) + ((pt_y * m._22))) + ((pt_z * m._32))) + m._42)
            pz = ((((pt_x * m._13) + ((pt_y * m._23))) + ((pt_z * m._33))) + m._43)
            pt_x = px
            pt_y = py
            pt_z = pz
            x1 = pt_x
            y1 = pt_y
            z1 = pt_z
            r = j.offsetRay
            if ((x1 - r) < b.xMin):
                b.xMin = (x1 - r)
            if ((x1 + r) > b.xMax):
                b.xMax = (x1 + r)
            if ((y1 - r) < b.yMin):
                b.yMin = (y1 - r)
            if ((y1 + r) > b.yMax):
                b.yMax = (y1 + r)
            if ((z1 - r) < b.zMin):
                b.zMin = (z1 - r)
            if ((z1 + r) > b.zMax):
                b.zMax = (z1 + r)
            _this1 = j.offsets
            x2 = _this1.xMax
            y2 = _this1.yMax
            z2 = _this1.zMax
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            pt_x1 = x2
            pt_y1 = y2
            pt_z1 = z2
            px1 = ((((pt_x1 * m._11) + ((pt_y1 * m._21))) + ((pt_z1 * m._31))) + m._41)
            py1 = ((((pt_x1 * m._12) + ((pt_y1 * m._22))) + ((pt_z1 * m._32))) + m._42)
            pz1 = ((((pt_x1 * m._13) + ((pt_y1 * m._23))) + ((pt_z1 * m._33))) + m._43)
            pt_x1 = px1
            pt_y1 = py1
            pt_z1 = pz1
            x3 = pt_x1
            y3 = pt_y1
            z3 = pt_z1
            r1 = j.offsetRay
            if ((x3 - r1) < b.xMin):
                b.xMin = (x3 - r1)
            if ((x3 + r1) > b.xMax):
                b.xMax = (x3 + r1)
            if ((y3 - r1) < b.yMin):
                b.yMin = (y3 - r1)
            if ((y3 + r1) > b.yMax):
                b.yMax = (y3 + r1)
            if ((z3 - r1) < b.zMin):
                b.zMin = (z3 - r1)
            if ((z3 + r1) > b.zMax):
                b.zMax = (z3 + r1)
        return b

    def getCurrentSkeletonBounds(self):
        self.syncJoints()
        b = h3d_col_Bounds()
        _g = 0
        _g1 = self.skinData.allJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (j.bindIndex < 0):
                continue
            r = python_internal_ArrayImpl._get(self.currentAbsPose, j.index)
            x = r._41
            y = r._42
            z = r._43
            if (x < b.xMin):
                b.xMin = x
            if (x > b.xMax):
                b.xMax = x
            if (y < b.yMin):
                b.yMin = y
            if (y > b.yMax):
                b.yMax = y
            if (z < b.zMin):
                b.zMin = z
            if (z > b.zMax):
                b.zMax = z
        return b

    def getObjectByName(self,name):
        if ((self.skinData is not None) and ((self.skinData.name == name))):
            return self
        o = super().getObjectByName(name)
        if (o is not None):
            return o
        if (self.skinData is not None):
            j = self.skinData.namedJoints.h.get(name,None)
            if (j is not None):
                return h3d_scene_Joint(self,j)
        return None

    def getLocalCollider(self):
        raise haxe_Exception.thrown("Not implemented")

    def getGlobalCollider(self):
        def _hx_local_1():
            _hx_local_0 = self.primitive.getCollider()
            if (Std.isOfType(_hx_local_0,h3d_col_OptimizedCollider) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise "Class cast error"
            return _hx_local_0
        col = _hx_local_1()
        def _hx_local_3():
            _hx_local_2 = self.primitive
            if (Std.isOfType(_hx_local_2,h3d_prim_HMDModel) or ((_hx_local_2 is None))):
                _hx_local_2
            else:
                raise "Class cast error"
            return _hx_local_2
        (_hx_local_3()).loadSkin(self.skinData)
        def _hx_local_6():
            def _hx_local_5():
                _hx_local_4 = col.b
                if (Std.isOfType(_hx_local_4,h3d_col_PolygonBuffer) or ((_hx_local_4 is None))):
                    _hx_local_4
                else:
                    raise "Class cast error"
                return _hx_local_4
            return h3d_col_SkinCollider(self,_hx_local_5())
        return _hx_local_6()

    def calcAbsPos(self):
        super().calcAbsPos()
        self.jointsUpdated = True

    def getSkinData(self):
        return self.skinData

    def setSkinData(self,s,shaderInit = None):
        if (shaderInit is None):
            shaderInit = True
        self.skinData = s
        self.jointsUpdated = True
        self.set_primitive(s.primitive)
        if shaderInit:
            hasNormalMap = False
            _g = 0
            _g1 = self.materials
            while (_g < len(_g1)):
                m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if ((m is not None) and ((m.get_normalMap() is not None))):
                    hasNormalMap = True
                    break
            self.skinShader = (h3d_shader_SkinTangent() if hasNormalMap else h3d_shader_Skin())
            maxBones = 0
            if (self.skinData.splitJoints is not None):
                _g = 0
                _g1 = self.skinData.splitJoints
                while (_g < len(_g1)):
                    s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    if (len(s.joints) > maxBones):
                        maxBones = len(s.joints)
            else:
                maxBones = len(self.skinData.boundJoints)
            if (self.skinShader.MaxBones__ < maxBones):
                _this = self.skinShader
                _this.constModified = True
                _this.MaxBones__ = maxBones
            _g = 0
            _g1 = self.materials
            while (_g < len(_g1)):
                m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (m is not None):
                    if (m.get_normalMap() is not None):
                        m.passes.addShaderAtIndex(self.skinShader,(m.passes.getShaderIndex(m.normalShader) + 1))
                    else:
                        m.passes.addShader(self.skinShader)
                    if (self.skinData.splitJoints is not None):
                        m.passes.set_dynamicParameters(True)
        self.currentRelPose = []
        self.currentAbsPose = []
        self.currentPalette = []
        self.paletteChanged = True
        _g = 0
        _g1 = self.skinData.allJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _this = self.currentAbsPose
            x = h3d_Matrix.I()
            _this.append(x)
        _g = 0
        _g1 = len(self.skinData.boundJoints)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this = self.currentPalette
            x = h3d_Matrix.I()
            _this.append(x)
        if (self.skinData.splitJoints is not None):
            self.splitPalette = []
            _g = 0
            _g1 = self.skinData.splitJoints
            while (_g < len(_g1)):
                a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _this = self.splitPalette
                _g2 = []
                _g3 = 0
                _g4 = a.joints
                while (_g3 < len(_g4)):
                    j = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                    _g3 = (_g3 + 1)
                    x = python_internal_ArrayImpl._get(self.currentPalette, j.bindIndex)
                    _g2.append(x)
                _this.append(_g2)
        else:
            self.splitPalette = None

    def sync(self,ctx):
        if ((not ctx.visibleFlag) and ((((self.flags & 64)) == 0))):
            return
        self.syncJoints()

    def syncJoints(self):
        if (not self.jointsUpdated):
            return
        tmpMat = h3d_scene_Skin.TMP_MAT
        _g = 0
        _g1 = self.skinData.allJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            id = j.index
            m = (self.currentAbsPose[id] if id >= 0 and id < len(self.currentAbsPose) else None)
            r = (self.currentRelPose[id] if id >= 0 and id < len(self.currentRelPose) else None)
            bid = j.bindIndex
            if (r is None):
                r = j.defMat
            elif (j.retargetAnim and self.enableRetargeting):
                tmpMat.load(r)
                r = tmpMat
                r._41 = j.defMat._41
                r._42 = j.defMat._42
                r._43 = j.defMat._43
            if (j.parent is None):
                b = self.absPos
                m11 = r._11
                m12 = r._12
                m13 = r._13
                m21 = r._21
                m22 = r._22
                m23 = r._23
                a31 = r._31
                a32 = r._32
                a33 = r._33
                a41 = r._41
                a42 = r._42
                a43 = r._43
                b11 = b._11
                b12 = b._12
                b13 = b._13
                b21 = b._21
                b22 = b._22
                b23 = b._23
                b31 = b._31
                b32 = b._32
                b33 = b._33
                b41 = b._41
                b42 = b._42
                b43 = b._43
                m._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
                m._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
                m._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
                m._14 = 0
                m._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
                m._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
                m._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
                m._24 = 0
                m._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
                m._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
                m._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
                m._34 = 0
                m._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
                m._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
                m._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
                m._44 = 1
            else:
                b1 = python_internal_ArrayImpl._get(self.currentAbsPose, j.parent.index)
                m111 = r._11
                m121 = r._12
                m131 = r._13
                m211 = r._21
                m221 = r._22
                m231 = r._23
                a311 = r._31
                a321 = r._32
                a331 = r._33
                a411 = r._41
                a421 = r._42
                a431 = r._43
                b111 = b1._11
                b121 = b1._12
                b131 = b1._13
                b211 = b1._21
                b221 = b1._22
                b231 = b1._23
                b311 = b1._31
                b321 = b1._32
                b331 = b1._33
                b411 = b1._41
                b421 = b1._42
                b431 = b1._43
                m._11 = (((m111 * b111) + ((m121 * b211))) + ((m131 * b311)))
                m._12 = (((m111 * b121) + ((m121 * b221))) + ((m131 * b321)))
                m._13 = (((m111 * b131) + ((m121 * b231))) + ((m131 * b331)))
                m._14 = 0
                m._21 = (((m211 * b111) + ((m221 * b211))) + ((m231 * b311)))
                m._22 = (((m211 * b121) + ((m221 * b221))) + ((m231 * b321)))
                m._23 = (((m211 * b131) + ((m221 * b231))) + ((m231 * b331)))
                m._24 = 0
                m._31 = (((a311 * b111) + ((a321 * b211))) + ((a331 * b311)))
                m._32 = (((a311 * b121) + ((a321 * b221))) + ((a331 * b321)))
                m._33 = (((a311 * b131) + ((a321 * b231))) + ((a331 * b331)))
                m._34 = 0
                m._41 = ((((a411 * b111) + ((a421 * b211))) + ((a431 * b311))) + b411)
                m._42 = ((((a411 * b121) + ((a421 * b221))) + ((a431 * b321))) + b421)
                m._43 = ((((a411 * b131) + ((a421 * b231))) + ((a431 * b331))) + b431)
                m._44 = 1
            if (bid >= 0):
                _this = (self.currentPalette[bid] if bid >= 0 and bid < len(self.currentPalette) else None)
                a = j.transPos
                m112 = a._11
                m122 = a._12
                m132 = a._13
                m212 = a._21
                m222 = a._22
                m232 = a._23
                a312 = a._31
                a322 = a._32
                a332 = a._33
                a412 = a._41
                a422 = a._42
                a432 = a._43
                b112 = m._11
                b122 = m._12
                b132 = m._13
                b212 = m._21
                b222 = m._22
                b232 = m._23
                b312 = m._31
                b322 = m._32
                b332 = m._33
                b412 = m._41
                b422 = m._42
                b432 = m._43
                _this._11 = (((m112 * b112) + ((m122 * b212))) + ((m132 * b312)))
                _this._12 = (((m112 * b122) + ((m122 * b222))) + ((m132 * b322)))
                _this._13 = (((m112 * b132) + ((m122 * b232))) + ((m132 * b332)))
                _this._14 = 0
                _this._21 = (((m212 * b112) + ((m222 * b212))) + ((m232 * b312)))
                _this._22 = (((m212 * b122) + ((m222 * b222))) + ((m232 * b322)))
                _this._23 = (((m212 * b132) + ((m222 * b232))) + ((m232 * b332)))
                _this._24 = 0
                _this._31 = (((a312 * b112) + ((a322 * b212))) + ((a332 * b312)))
                _this._32 = (((a312 * b122) + ((a322 * b222))) + ((a332 * b322)))
                _this._33 = (((a312 * b132) + ((a322 * b232))) + ((a332 * b332)))
                _this._34 = 0
                _this._41 = ((((a412 * b112) + ((a422 * b212))) + ((a432 * b312))) + b412)
                _this._42 = ((((a412 * b122) + ((a422 * b222))) + ((a432 * b322))) + b422)
                _this._43 = ((((a412 * b132) + ((a422 * b232))) + ((a432 * b332))) + b432)
                _this._44 = 1
        self.skinShader.bonesMatrixes__ = self.currentPalette
        if (self.jointsAbsPosInv is not None):
            self.jointsAbsPosInv._44 = 0
        self.jointsUpdated = False

    def emit(self,ctx):
        if (self.splitPalette is None):
            super().emit(ctx)
        else:
            _g = 0
            _g1 = len(self.splitPalette)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                m = python_internal_ArrayImpl._get(self.materials, python_internal_ArrayImpl._get(self.skinData.splitJoints, i).material)
                if (m is not None):
                    index = i
                    if (index is None):
                        index = 0
                    p = m.passes
                    while (p is not None):
                        ctx.emitPass(p,self).index = index
                        p = p.nextPass
        if self.showJoints:
            if (self.jointsGraphics is None):
                self.jointsGraphics = h3d_scene_Graphics(self)
                self.jointsGraphics.material.passes.depth(False,h3d_mat_Compare.Always)
                self.jointsGraphics.material.passes.setPassName("add")
            topParent = self
            while (topParent.parent is not None):
                topParent = topParent.parent
            self.jointsGraphics.set_follow(topParent)
            g = self.jointsGraphics
            g.clear()
            _g = 0
            _g1 = self.skinData.allJoints
            while (_g < len(_g1)):
                j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                m = python_internal_ArrayImpl._get(self.currentAbsPose, j.index)
                mp = (self.absPos if ((j.parent is None)) else python_internal_ArrayImpl._get(self.currentAbsPose, j.parent.index))
                g.lineStyle(1,(-16776961 if ((j.parent is None)) else -256))
                g.moveTo(mp._41,mp._42,mp._43)
                g.lineTo(m._41,m._42,m._43)
        elif (self.jointsGraphics is not None):
            _this = self.jointsGraphics
            if ((_this is not None) and ((_this.parent is not None))):
                _this.parent.removeChild(_this)
            self.jointsGraphics = None

    def draw(self,ctx):
        if (self.splitPalette is None):
            super().draw(ctx)
        else:
            i = ctx.drawPass.index
            self.skinShader.bonesMatrixes__ = (self.splitPalette[i] if i >= 0 and i < len(self.splitPalette) else None)
            self.primitive.selectMaterial(i)
            ctx.uploadParams()
            self.primitive.render(ctx.engine)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.skinData = None
        _hx_o.currentRelPose = None
        _hx_o.currentAbsPose = None
        _hx_o.currentPalette = None
        _hx_o.splitPalette = None
        _hx_o.jointsUpdated = None
        _hx_o.jointsAbsPosInv = None
        _hx_o.paletteChanged = None
        _hx_o.skinShader = None
        _hx_o.jointsGraphics = None
        _hx_o.showJoints = None
        _hx_o.enableRetargeting = None
h3d_scene_Skin._hx_class = h3d_scene_Skin
_hx_classes["h3d.scene.Skin"] = h3d_scene_Skin


class h3d_scene_fwd_LightSystem(h3d_scene_LightSystem):
    _hx_class_name = "h3d.scene.fwd.LightSystem"
    _hx_is_interface = "False"
    __slots__ = ("maxLightsPerObject", "globals", "ambientShader", "perPixelLighting")
    _hx_fields = ["maxLightsPerObject", "globals", "ambientShader", "perPixelLighting"]
    _hx_methods = ["get_additiveLighting", "set_additiveLighting", "initLights", "initGlobals", "sortLight", "computeLight"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_LightSystem


    def __init__(self):
        self.ambientShader = None
        self.globals = None
        self.perPixelLighting = True
        self.maxLightsPerObject = 6
        super().__init__()
        _this = self.ambientLight
        x = 0.5
        y = 0.5
        z = 0.5
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        self.ambientShader = h3d_shader_AmbientLight()
        self.set_additiveLighting(True)

    def get_additiveLighting(self):
        return Std.downcast(self.ambientShader,h3d_shader_AmbientLight).additive__

    def set_additiveLighting(self,b):
        _this = Std.downcast(self.ambientShader,h3d_shader_AmbientLight)
        _this.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                _this.additive__ = b
                return _this.additive__
            return _hx_local_0()
        return _hx_local_1()

    def initLights(self,ctx):
        super().initLights(ctx)
        if (self.lightCount <= self.maxLightsPerObject):
            _hx_list = ctx.lights
            cmp = self.sortLight
            tmp = None
            if (_hx_list is None):
                tmp = None
            else:
                insize = 1
                nmerges = None
                psize = 0
                qsize = 0
                p = None
                q = None
                e = None
                tail = None
                while True:
                    p = _hx_list
                    _hx_list = None
                    tail = None
                    nmerges = 0
                    while (p is not None):
                        nmerges = (nmerges + 1)
                        q = p
                        psize = 0
                        _g = 0
                        _g1 = insize
                        while (_g < _g1):
                            i = _g
                            _g = (_g + 1)
                            psize = (psize + 1)
                            q = q.next
                            if (q is None):
                                break
                        qsize = insize
                        while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                            if (psize == 0):
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            elif (((qsize == 0) or ((q is None))) or ((cmp(p,q) <= 0))):
                                e = p
                                p = p.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            if (tail is not None):
                                tail.next = e
                            else:
                                _hx_list = e
                            tail = e
                        p = q
                    tail.next = None
                    if (nmerges <= 1):
                        break
                    insize = (insize * 2)
                tmp = _hx_list
            ctx.lights = tmp

    def initGlobals(self,globals):
        globals.set("global.ambientLight",self.ambientLight)
        globals.set("global.perPixelLighting",self.perPixelLighting)

    def sortLight(self,l1,l2):
        p = (l1.priority - l2.priority)
        if (p != 0):
            return -p
        if (l1.objectDistance < l2.objectDistance):
            return -1
        else:
            return 1

    def computeLight(self,obj,shaders):
        _gthis = self
        if (self.lightCount > self.maxLightsPerObject):
            l = self.ctx.lights
            while (l is not None):
                if (((obj.flags & 16)) != 0):
                    dx = (l.absPos._41 - self.ctx.camera.target.x)
                    dy = (l.absPos._42 - self.ctx.camera.target.y)
                    dz = (l.absPos._43 - self.ctx.camera.target.z)
                    if (dz is None):
                        dz = 0.
                    l.objectDistance = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
                else:
                    dx1 = (l.absPos._41 - obj.absPos._41)
                    dy1 = (l.absPos._42 - obj.absPos._42)
                    dz1 = (l.absPos._43 - obj.absPos._43)
                    if (dz1 is None):
                        dz1 = 0.
                    l.objectDistance = (((dx1 * dx1) + ((dy1 * dy1))) + ((dz1 * dz1)))
                l = l.next
            _hx_list = self.ctx.lights
            cmp = self.sortLight
            tmp = None
            if (_hx_list is None):
                tmp = None
            else:
                insize = 1
                nmerges = None
                psize = 0
                qsize = 0
                p = None
                q = None
                e = None
                tail = None
                while True:
                    p = _hx_list
                    _hx_list = None
                    tail = None
                    nmerges = 0
                    while (p is not None):
                        nmerges = (nmerges + 1)
                        q = p
                        psize = 0
                        _g = 0
                        _g1 = insize
                        while (_g < _g1):
                            i = _g
                            _g = (_g + 1)
                            psize = (psize + 1)
                            q = q.next
                            if (q is None):
                                break
                        qsize = insize
                        while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                            if (psize == 0):
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            elif (((qsize == 0) or ((q is None))) or ((cmp(p,q) <= 0))):
                                e = p
                                p = p.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            if (tail is not None):
                                tail.next = e
                            else:
                                _hx_list = e
                            tail = e
                        p = q
                    tail.next = None
                    if (nmerges <= 1):
                        break
                    insize = (insize * 2)
                tmp = _hx_list
            self.ctx.lights = tmp
        shaders = _gthis.ctx.allocShaderList(self.ambientShader,shaders)
        l = self.ctx.lights
        i = 0
        while (l is not None):
            tmp = i
            i = (i + 1)
            if (tmp == self.maxLightsPerObject):
                break
            shaders = _gthis.ctx.allocShaderList(l.shader,shaders)
            l = l.next
        return shaders

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.maxLightsPerObject = None
        _hx_o.globals = None
        _hx_o.ambientShader = None
        _hx_o.perPixelLighting = None
h3d_scene_fwd_LightSystem._hx_class = h3d_scene_fwd_LightSystem
_hx_classes["h3d.scene.fwd.LightSystem"] = h3d_scene_fwd_LightSystem


class h3d_scene_fwd_DepthPass(h3d_pass_Default):
    _hx_class_name = "h3d.scene.fwd.DepthPass"
    _hx_is_interface = "False"
    __slots__ = ("depthMapId", "enableSky")
    _hx_fields = ["depthMapId", "enableSky"]
    _hx_methods = ["getOutputs", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Default


    def __init__(self):
        self.depthMapId = None
        self.enableSky = False
        super().__init__("depth")
        self.depthMapId = hxsl_Globals.allocID("depthMap")

    def getOutputs(self):
        return [hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))]

    def draw(self,passes,sort = None):
        texture = self.ctx.textures.allocTarget("depthMap",self.ctx.engine.width,self.ctx.engine.height,True)
        self.ctx.engine.pushTarget(texture)
        self.ctx.engine.clear((0 if (self.enableSky) else 16711680),1)
        super().draw(passes,sort)
        self.ctx.engine.popTarget()
        self.ctx.setGlobalID(self.depthMapId,_hx_AnonObject({'texture': texture}))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.depthMapId = None
        _hx_o.enableSky = None
h3d_scene_fwd_DepthPass._hx_class = h3d_scene_fwd_DepthPass
_hx_classes["h3d.scene.fwd.DepthPass"] = h3d_scene_fwd_DepthPass


class h3d_scene_fwd_NormalPass(h3d_pass_Default):
    _hx_class_name = "h3d.scene.fwd.NormalPass"
    _hx_is_interface = "False"
    __slots__ = ("normalMapId",)
    _hx_fields = ["normalMapId"]
    _hx_methods = ["getOutputs", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Default


    def __init__(self):
        self.normalMapId = None
        super().__init__("normal")
        self.normalMapId = hxsl_Globals.allocID("normalMap")

    def getOutputs(self):
        return [hxsl_Output.PackNormal(hxsl_Output.Value("output.normal"))]

    def draw(self,passes,sort = None):
        texture = self.ctx.textures.allocTarget("normalMap",self.ctx.engine.width,self.ctx.engine.height)
        self.ctx.engine.pushTarget(texture)
        self.ctx.engine.clear(8421504,1)
        super().draw(passes,sort)
        self.ctx.engine.popTarget()
        self.ctx.setGlobalID(self.normalMapId,texture)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.normalMapId = None
h3d_scene_fwd_NormalPass._hx_class = h3d_scene_fwd_NormalPass
_hx_classes["h3d.scene.fwd.NormalPass"] = h3d_scene_fwd_NormalPass


class h3d_scene_fwd_Renderer(h3d_scene_Renderer):
    _hx_class_name = "h3d.scene.fwd.Renderer"
    _hx_is_interface = "False"
    __slots__ = ("depth", "normal", "shadow")
    _hx_fields = ["depth", "normal", "shadow"]
    _hx_methods = ["get_def", "renderPass", "getPassByName", "render"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Renderer


    def __init__(self):
        self.shadow = h3d_pass_DefaultShadowMap(1024)
        self.normal = h3d_scene_fwd_NormalPass()
        self.depth = h3d_scene_fwd_DepthPass()
        super().__init__()
        self.defaultPass = h3d_pass_Default("default")
        self.allPasses = [self.defaultPass, self.depth, self.normal, self.shadow]

    def get_def(self):
        return self.defaultPass

    def renderPass(self,p,passes,sort = None):
        p.draw(passes,sort)

    def getPassByName(self,name):
        if ((name == "alpha") or ((name == "additive"))):
            return self.defaultPass
        return super().getPassByName(name)

    def render(self):
        if self.has("shadow"):
            self.renderPass(self.shadow,self.get("shadow"))
        if self.has("depth"):
            self.renderPass(self.depth,self.get("depth"))
        if self.has("normal"):
            self.renderPass(self.normal,self.get("normal"))
        self.renderPass(self.defaultPass,self.get("default"))
        self.renderPass(self.defaultPass,self.get("alpha"),self.backToFront)
        self.renderPass(self.defaultPass,self.get("additive"))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.depth = None
        _hx_o.normal = None
        _hx_o.shadow = None
h3d_scene_fwd_Renderer._hx_class = h3d_scene_fwd_Renderer
_hx_classes["h3d.scene.fwd.Renderer"] = h3d_scene_fwd_Renderer


class h3d_shader_AmbientLight(hxsl_Shader):
    _hx_class_name = "h3d.shader.AmbientLight"
    _hx_is_interface = "False"
    __slots__ = ("additive__",)
    _hx_fields = ["additive__"]
    _hx_methods = ["get_additive", "set_additive", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.additive__ = None
        super().__init__()

    def get_additive(self):
        return self.additive__

    def set_additive(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.additive__ = _v
                return self.additive__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.additive__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 2)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.additive__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_AmbientLight)
        s.shader = self.shader
        s.additive__ = self.additive__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.additive__ = None
h3d_shader_AmbientLight._hx_class = h3d_shader_AmbientLight
_hx_classes["h3d.shader.AmbientLight"] = h3d_shader_AmbientLight


class h3d_shader_Base2d(hxsl_Shader):
    _hx_class_name = "h3d.shader.Base2d"
    _hx_is_interface = "False"
    __slots__ = ("zValue__", "texture__", "isRelative__", "color__", "absoluteMatrixA__", "absoluteMatrixB__", "filterMatrixA__", "filterMatrixB__", "hasUVPos__", "uvPos__", "killAlpha__", "pixelAlign__", "halfPixelInverse__", "viewportA__", "viewportB__")
    _hx_fields = ["zValue__", "texture__", "isRelative__", "color__", "absoluteMatrixA__", "absoluteMatrixB__", "filterMatrixA__", "filterMatrixB__", "hasUVPos__", "uvPos__", "killAlpha__", "pixelAlign__", "halfPixelInverse__", "viewportA__", "viewportB__"]
    _hx_methods = ["get_zValue", "set_zValue", "get_texture", "set_texture", "get_isRelative", "set_isRelative", "get_color", "set_color", "get_absoluteMatrixA", "set_absoluteMatrixA", "get_absoluteMatrixB", "set_absoluteMatrixB", "get_filterMatrixA", "set_filterMatrixA", "get_filterMatrixB", "set_filterMatrixB", "get_hasUVPos", "set_hasUVPos", "get_uvPos", "set_uvPos", "get_killAlpha", "set_killAlpha", "get_pixelAlign", "set_pixelAlign", "get_halfPixelInverse", "set_halfPixelInverse", "get_viewportA", "set_viewportA", "get_viewportB", "set_viewportB", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.pixelAlign__ = None
        self.killAlpha__ = None
        self.hasUVPos__ = None
        self.isRelative__ = None
        self.texture__ = None
        self.viewportB__ = h3d_Vector()
        self.viewportA__ = h3d_Vector()
        self.halfPixelInverse__ = h3d_Vector()
        self.uvPos__ = h3d_Vector()
        self.filterMatrixB__ = h3d_Vector()
        self.filterMatrixA__ = h3d_Vector()
        self.absoluteMatrixB__ = h3d_Vector()
        self.absoluteMatrixA__ = h3d_Vector()
        self.color__ = h3d_Vector()
        self.zValue__ = 0
        super().__init__()

    def get_zValue(self):
        return self.zValue__

    def set_zValue(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.zValue__ = _v
                return self.zValue__
            return _hx_local_0()
        return _hx_local_1()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def get_isRelative(self):
        return self.isRelative__

    def set_isRelative(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isRelative__ = _v
                return self.isRelative__
            return _hx_local_0()
        return _hx_local_1()

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def get_absoluteMatrixA(self):
        return self.absoluteMatrixA__

    def set_absoluteMatrixA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.absoluteMatrixA__ = _v
                return self.absoluteMatrixA__
            return _hx_local_0()
        return _hx_local_1()

    def get_absoluteMatrixB(self):
        return self.absoluteMatrixB__

    def set_absoluteMatrixB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.absoluteMatrixB__ = _v
                return self.absoluteMatrixB__
            return _hx_local_0()
        return _hx_local_1()

    def get_filterMatrixA(self):
        return self.filterMatrixA__

    def set_filterMatrixA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.filterMatrixA__ = _v
                return self.filterMatrixA__
            return _hx_local_0()
        return _hx_local_1()

    def get_filterMatrixB(self):
        return self.filterMatrixB__

    def set_filterMatrixB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.filterMatrixB__ = _v
                return self.filterMatrixB__
            return _hx_local_0()
        return _hx_local_1()

    def get_hasUVPos(self):
        return self.hasUVPos__

    def set_hasUVPos(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.hasUVPos__ = _v
                return self.hasUVPos__
            return _hx_local_0()
        return _hx_local_1()

    def get_uvPos(self):
        return self.uvPos__

    def set_uvPos(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.uvPos__ = _v
                return self.uvPos__
            return _hx_local_0()
        return _hx_local_1()

    def get_killAlpha(self):
        return self.killAlpha__

    def set_killAlpha(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.killAlpha__ = _v
                return self.killAlpha__
            return _hx_local_0()
        return _hx_local_1()

    def get_pixelAlign(self):
        return self.pixelAlign__

    def set_pixelAlign(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.pixelAlign__ = _v
                return self.pixelAlign__
            return _hx_local_0()
        return _hx_local_1()

    def get_halfPixelInverse(self):
        return self.halfPixelInverse__

    def set_halfPixelInverse(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.halfPixelInverse__ = _v
                return self.halfPixelInverse__
            return _hx_local_0()
        return _hx_local_1()

    def get_viewportA(self):
        return self.viewportA__

    def set_viewportA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.viewportA__ = _v
                return self.viewportA__
            return _hx_local_0()
        return _hx_local_1()

    def get_viewportB(self):
        return self.viewportB__

    def set_viewportB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.viewportB__ = _v
                return self.viewportB__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.isRelative__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        if self.hasUVPos__:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.constBits
            _hx_local_2.constBits = (_hx_local_3 | 2)
            _hx_local_2.constBits
        if self.killAlpha__:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.constBits
            _hx_local_4.constBits = (_hx_local_5 | 4)
            _hx_local_4.constBits
        if self.pixelAlign__:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.constBits
            _hx_local_6.constBits = (_hx_local_7 | 8)
            _hx_local_6.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.zValue__
        elif (index1 == 1):
            return self.texture__
        elif (index1 == 2):
            return self.isRelative__
        elif (index1 == 3):
            return self.color__
        elif (index1 == 4):
            return self.absoluteMatrixA__
        elif (index1 == 5):
            return self.absoluteMatrixB__
        elif (index1 == 6):
            return self.filterMatrixA__
        elif (index1 == 7):
            return self.filterMatrixB__
        elif (index1 == 8):
            return self.hasUVPos__
        elif (index1 == 9):
            return self.uvPos__
        elif (index1 == 10):
            return self.killAlpha__
        elif (index1 == 11):
            return self.pixelAlign__
        elif (index1 == 12):
            return self.halfPixelInverse__
        elif (index1 == 13):
            return self.viewportA__
        elif (index1 == 14):
            return self.viewportB__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.zValue__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_Base2d)
        s.shader = self.shader
        s.zValue__ = self.zValue__
        s.texture__ = self.texture__
        s.isRelative__ = self.isRelative__
        s.color__ = self.color__
        s.absoluteMatrixA__ = self.absoluteMatrixA__
        s.absoluteMatrixB__ = self.absoluteMatrixB__
        s.filterMatrixA__ = self.filterMatrixA__
        s.filterMatrixB__ = self.filterMatrixB__
        s.hasUVPos__ = self.hasUVPos__
        s.uvPos__ = self.uvPos__
        s.killAlpha__ = self.killAlpha__
        s.pixelAlign__ = self.pixelAlign__
        s.halfPixelInverse__ = self.halfPixelInverse__
        s.viewportA__ = self.viewportA__
        s.viewportB__ = self.viewportB__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.zValue__ = None
        _hx_o.texture__ = None
        _hx_o.isRelative__ = None
        _hx_o.color__ = None
        _hx_o.absoluteMatrixA__ = None
        _hx_o.absoluteMatrixB__ = None
        _hx_o.filterMatrixA__ = None
        _hx_o.filterMatrixB__ = None
        _hx_o.hasUVPos__ = None
        _hx_o.uvPos__ = None
        _hx_o.killAlpha__ = None
        _hx_o.pixelAlign__ = None
        _hx_o.halfPixelInverse__ = None
        _hx_o.viewportA__ = None
        _hx_o.viewportB__ = None
h3d_shader_Base2d._hx_class = h3d_shader_Base2d
_hx_classes["h3d.shader.Base2d"] = h3d_shader_Base2d


class h3d_shader_BaseMesh(hxsl_Shader):
    _hx_class_name = "h3d.shader.BaseMesh"
    _hx_is_interface = "False"
    __slots__ = ("color__", "specularPower__", "specularAmount__", "specularColor__")
    _hx_fields = ["color__", "specularPower__", "specularAmount__", "specularColor__"]
    _hx_methods = ["get_color", "set_color", "get_specularPower", "set_specularPower", "get_specularAmount", "set_specularAmount", "get_specularColor", "set_specularColor", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.specularColor__ = h3d_Vector()
        self.specularAmount__ = 0
        self.specularPower__ = 0
        self.color__ = h3d_Vector()
        super().__init__()
        _this = self.color__
        x = 1
        y = 1
        z = 1
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.specularColor__
        x = 1
        y = 1
        z = 1
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        self.specularPower__ = 50
        self.specularAmount__ = 1

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularPower(self):
        return self.specularPower__

    def set_specularPower(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.specularPower__ = _v
                return self.specularPower__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularAmount(self):
        return self.specularAmount__

    def set_specularAmount(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.specularAmount__ = _v
                return self.specularAmount__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularColor(self):
        return self.specularColor__

    def set_specularColor(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.specularColor__ = _v
                return self.specularColor__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.color__
        elif (index1 == 1):
            return self.specularPower__
        elif (index1 == 2):
            return self.specularAmount__
        elif (index1 == 3):
            return self.specularColor__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        index1 = index
        if (index1 == 1):
            return self.specularPower__
        elif (index1 == 2):
            return self.specularAmount__
        else:
            pass
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_BaseMesh)
        s.shader = self.shader
        s.color__ = self.color__
        s.specularPower__ = self.specularPower__
        s.specularAmount__ = self.specularAmount__
        s.specularColor__ = self.specularColor__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color__ = None
        _hx_o.specularPower__ = None
        _hx_o.specularAmount__ = None
        _hx_o.specularColor__ = None
h3d_shader_BaseMesh._hx_class = h3d_shader_BaseMesh
_hx_classes["h3d.shader.BaseMesh"] = h3d_shader_BaseMesh


class h3d_shader_Blur(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.shader.Blur"
    _hx_is_interface = "False"
    __slots__ = ("cameraInverseViewProj__", "texture__", "depthTexture__", "Quality__", "isDepth__", "values__", "offsets__", "pixel__", "hasFixedColor__", "smoothFixedColor__", "fixedColor__", "isDepthDependant__", "hasNormal__", "normalTexture__", "isCube__", "cubeTexture__", "cubeDir__")
    _hx_fields = ["cameraInverseViewProj__", "texture__", "depthTexture__", "Quality__", "isDepth__", "values__", "offsets__", "pixel__", "hasFixedColor__", "smoothFixedColor__", "fixedColor__", "isDepthDependant__", "hasNormal__", "normalTexture__", "isCube__", "cubeTexture__", "cubeDir__"]
    _hx_methods = ["get_cameraInverseViewProj", "set_cameraInverseViewProj", "get_texture", "set_texture", "get_depthTexture", "set_depthTexture", "get_Quality", "set_Quality", "get_isDepth", "set_isDepth", "get_values", "set_values", "get_offsets", "set_offsets", "get_pixel", "set_pixel", "get_hasFixedColor", "set_hasFixedColor", "get_smoothFixedColor", "set_smoothFixedColor", "get_fixedColor", "set_fixedColor", "get_isDepthDependant", "set_isDepthDependant", "get_hasNormal", "set_hasNormal", "get_normalTexture", "set_normalTexture", "get_isCube", "set_isCube", "get_cubeTexture", "set_cubeTexture", "get_cubeDir", "set_cubeDir", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.cubeTexture__ = None
        self.isCube__ = None
        self.normalTexture__ = None
        self.hasNormal__ = None
        self.isDepthDependant__ = None
        self.smoothFixedColor__ = None
        self.hasFixedColor__ = None
        self.isDepth__ = None
        self.depthTexture__ = None
        self.texture__ = None
        self.cubeDir__ = h3d_Matrix()
        self.fixedColor__ = h3d_Vector()
        self.pixel__ = h3d_Vector()
        self.offsets__ = list()
        self.values__ = list()
        self.Quality__ = 0
        self.cameraInverseViewProj__ = h3d_Matrix()
        super().__init__()

    def get_cameraInverseViewProj(self):
        return self.cameraInverseViewProj__

    def set_cameraInverseViewProj(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.cameraInverseViewProj__ = _v
                return self.cameraInverseViewProj__
            return _hx_local_0()
        return _hx_local_1()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def get_depthTexture(self):
        return self.depthTexture__

    def set_depthTexture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.depthTexture__ = _v
                return self.depthTexture__
            return _hx_local_0()
        return _hx_local_1()

    def get_Quality(self):
        return self.Quality__

    def set_Quality(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.Quality__ = _v
                return self.Quality__
            return _hx_local_0()
        return _hx_local_1()

    def get_isDepth(self):
        return self.isDepth__

    def set_isDepth(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isDepth__ = _v
                return self.isDepth__
            return _hx_local_0()
        return _hx_local_1()

    def get_values(self):
        return self.values__

    def set_values(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.values__ = _v
                return self.values__
            return _hx_local_0()
        return _hx_local_1()

    def get_offsets(self):
        return self.offsets__

    def set_offsets(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.offsets__ = _v
                return self.offsets__
            return _hx_local_0()
        return _hx_local_1()

    def get_pixel(self):
        return self.pixel__

    def set_pixel(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.pixel__ = _v
                return self.pixel__
            return _hx_local_0()
        return _hx_local_1()

    def get_hasFixedColor(self):
        return self.hasFixedColor__

    def set_hasFixedColor(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.hasFixedColor__ = _v
                return self.hasFixedColor__
            return _hx_local_0()
        return _hx_local_1()

    def get_smoothFixedColor(self):
        return self.smoothFixedColor__

    def set_smoothFixedColor(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.smoothFixedColor__ = _v
                return self.smoothFixedColor__
            return _hx_local_0()
        return _hx_local_1()

    def get_fixedColor(self):
        return self.fixedColor__

    def set_fixedColor(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.fixedColor__ = _v
                return self.fixedColor__
            return _hx_local_0()
        return _hx_local_1()

    def get_isDepthDependant(self):
        return self.isDepthDependant__

    def set_isDepthDependant(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isDepthDependant__ = _v
                return self.isDepthDependant__
            return _hx_local_0()
        return _hx_local_1()

    def get_hasNormal(self):
        return self.hasNormal__

    def set_hasNormal(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.hasNormal__ = _v
                return self.hasNormal__
            return _hx_local_0()
        return _hx_local_1()

    def get_normalTexture(self):
        return self.normalTexture__

    def set_normalTexture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.normalTexture__ = _v
                return self.normalTexture__
            return _hx_local_0()
        return _hx_local_1()

    def get_isCube(self):
        return self.isCube__

    def set_isCube(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isCube__ = _v
                return self.isCube__
            return _hx_local_0()
        return _hx_local_1()

    def get_cubeTexture(self):
        return self.cubeTexture__

    def set_cubeTexture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.cubeTexture__ = _v
                return self.cubeTexture__
            return _hx_local_0()
        return _hx_local_1()

    def get_cubeDir(self):
        return self.cubeDir__

    def set_cubeDir(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.cubeDir__ = _v
                return self.cubeDir__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.Quality__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("Quality" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        if self.isDepth__:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.constBits
            _hx_local_2.constBits = (_hx_local_3 | 256)
            _hx_local_2.constBits
        if self.hasFixedColor__:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.constBits
            _hx_local_4.constBits = (_hx_local_5 | 512)
            _hx_local_4.constBits
        if self.smoothFixedColor__:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.constBits
            _hx_local_6.constBits = (_hx_local_7 | 1024)
            _hx_local_6.constBits
        if self.isDepthDependant__:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.constBits
            _hx_local_8.constBits = (_hx_local_9 | 2048)
            _hx_local_8.constBits
        if self.hasNormal__:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.constBits
            _hx_local_10.constBits = (_hx_local_11 | 4096)
            _hx_local_10.constBits
        if self.isCube__:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.constBits
            _hx_local_12.constBits = (_hx_local_13 | 8192)
            _hx_local_12.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.cameraInverseViewProj__
        elif (index1 == 2):
            return self.texture__
        elif (index1 == 3):
            return self.depthTexture__
        elif (index1 == 4):
            return self.Quality__
        elif (index1 == 5):
            return self.isDepth__
        elif (index1 == 6):
            return self.values__
        elif (index1 == 7):
            return self.offsets__
        elif (index1 == 8):
            return self.pixel__
        elif (index1 == 9):
            return self.hasFixedColor__
        elif (index1 == 10):
            return self.smoothFixedColor__
        elif (index1 == 11):
            return self.fixedColor__
        elif (index1 == 12):
            return self.isDepthDependant__
        elif (index1 == 13):
            return self.hasNormal__
        elif (index1 == 14):
            return self.normalTexture__
        elif (index1 == 15):
            return self.isCube__
        elif (index1 == 16):
            return self.cubeTexture__
        elif (index1 == 17):
            return self.cubeDir__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_Blur)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.cameraInverseViewProj__ = self.cameraInverseViewProj__
        s.texture__ = self.texture__
        s.depthTexture__ = self.depthTexture__
        s.Quality__ = self.Quality__
        s.isDepth__ = self.isDepth__
        s.values__ = self.values__
        s.offsets__ = self.offsets__
        s.pixel__ = self.pixel__
        s.hasFixedColor__ = self.hasFixedColor__
        s.smoothFixedColor__ = self.smoothFixedColor__
        s.fixedColor__ = self.fixedColor__
        s.isDepthDependant__ = self.isDepthDependant__
        s.hasNormal__ = self.hasNormal__
        s.normalTexture__ = self.normalTexture__
        s.isCube__ = self.isCube__
        s.cubeTexture__ = self.cubeTexture__
        s.cubeDir__ = self.cubeDir__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cameraInverseViewProj__ = None
        _hx_o.texture__ = None
        _hx_o.depthTexture__ = None
        _hx_o.Quality__ = None
        _hx_o.isDepth__ = None
        _hx_o.values__ = None
        _hx_o.offsets__ = None
        _hx_o.pixel__ = None
        _hx_o.hasFixedColor__ = None
        _hx_o.smoothFixedColor__ = None
        _hx_o.fixedColor__ = None
        _hx_o.isDepthDependant__ = None
        _hx_o.hasNormal__ = None
        _hx_o.normalTexture__ = None
        _hx_o.isCube__ = None
        _hx_o.cubeTexture__ = None
        _hx_o.cubeDir__ = None
h3d_shader_Blur._hx_class = h3d_shader_Blur
_hx_classes["h3d.shader.Blur"] = h3d_shader_Blur


class h3d_shader_ShaderBuffers:
    _hx_class_name = "h3d.shader.ShaderBuffers"
    _hx_is_interface = "False"
    __slots__ = ("globals", "params", "tex", "buffers")
    _hx_fields = ["globals", "params", "tex", "buffers"]
    _hx_methods = ["grow"]

    def __init__(self,s):
        this1 = [None]*(s.globalsSize << 2)
        self.globals = this1
        this1 = [None]*(s.paramsSize << 2)
        self.params = this1
        this1 = [None]*s.texturesCount
        self.tex = this1
        tmp = None
        if (s.bufferCount > 0):
            this1 = [None]*s.bufferCount
            tmp = this1
        else:
            tmp = None
        self.buffers = tmp

    def grow(self,s):
        ng = (s.globalsSize << 2)
        np = (s.paramsSize << 2)
        nt = s.texturesCount
        nb = s.bufferCount
        if (len(self.globals) < ng):
            this1 = [None]*ng
            self.globals = this1
        if (len(self.params) < np):
            this1 = [None]*np
            self.params = this1
        if (len(self.tex) < nt):
            this1 = [None]*nt
            self.tex = this1
        if ((nb > 0) and (((self.buffers is None) or ((len(self.buffers) < nb))))):
            this1 = [None]*nb
            self.buffers = this1

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.globals = None
        _hx_o.params = None
        _hx_o.tex = None
        _hx_o.buffers = None
h3d_shader_ShaderBuffers._hx_class = h3d_shader_ShaderBuffers
_hx_classes["h3d.shader.ShaderBuffers"] = h3d_shader_ShaderBuffers


class h3d_shader_Buffers:
    _hx_class_name = "h3d.shader.Buffers"
    _hx_is_interface = "False"
    __slots__ = ("vertex", "fragment")
    _hx_fields = ["vertex", "fragment"]
    _hx_methods = ["grow"]

    def __init__(self,s):
        self.vertex = h3d_shader_ShaderBuffers(s.vertex)
        self.fragment = h3d_shader_ShaderBuffers(s.fragment)

    def grow(self,s):
        self.vertex.grow(s.vertex)
        self.fragment.grow(s.fragment)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vertex = None
        _hx_o.fragment = None
h3d_shader_Buffers._hx_class = h3d_shader_Buffers
_hx_classes["h3d.shader.Buffers"] = h3d_shader_Buffers


class h3d_shader_ColorAdd(hxsl_Shader):
    _hx_class_name = "h3d.shader.ColorAdd"
    _hx_is_interface = "False"
    __slots__ = ("color__",)
    _hx_fields = ["color__"]
    _hx_methods = ["get_color", "set_color", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,color = None):
        if (color is None):
            color = 0
        self.color__ = h3d_Vector()
        super().__init__()
        _this = self.color__
        _this.x = ((((color >> 16) & 255)) / 255)
        _this.y = ((((color >> 8) & 255)) / 255)
        _this.z = (((color & 255)) / 255)
        _this.w = ((HxOverrides.rshift(color, 24)) / 255)

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.color__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_ColorAdd)
        s.shader = self.shader
        s.color__ = self.color__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color__ = None
h3d_shader_ColorAdd._hx_class = h3d_shader_ColorAdd
_hx_classes["h3d.shader.ColorAdd"] = h3d_shader_ColorAdd


class h3d_shader_ColorKey(hxsl_Shader):
    _hx_class_name = "h3d.shader.ColorKey"
    _hx_is_interface = "False"
    __slots__ = ("colorKey__",)
    _hx_fields = ["colorKey__"]
    _hx_methods = ["get_colorKey", "set_colorKey", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,v = None):
        if (v is None):
            v = 0
        self.colorKey__ = h3d_Vector()
        super().__init__()
        _this = self.colorKey__
        _this.x = ((((v >> 16) & 255)) / 255)
        _this.y = ((((v >> 8) & 255)) / 255)
        _this.z = (((v & 255)) / 255)
        _this.w = ((HxOverrides.rshift(v, 24)) / 255)

    def get_colorKey(self):
        return self.colorKey__

    def set_colorKey(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.colorKey__ = _v
                return self.colorKey__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.colorKey__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_ColorKey)
        s.shader = self.shader
        s.colorKey__ = self.colorKey__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.colorKey__ = None
h3d_shader_ColorKey._hx_class = h3d_shader_ColorKey
_hx_classes["h3d.shader.ColorKey"] = h3d_shader_ColorKey


class h3d_shader_ColorMatrix(hxsl_Shader):
    _hx_class_name = "h3d.shader.ColorMatrix"
    _hx_is_interface = "False"
    __slots__ = ("matrix__",)
    _hx_fields = ["matrix__"]
    _hx_methods = ["get_matrix", "set_matrix", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,m = None):
        self.matrix__ = h3d_Matrix()
        super().__init__()
        if (m is not None):
            self.matrix__.loadValues(m)
        else:
            self.matrix__.identity()

    def get_matrix(self):
        return self.matrix__

    def set_matrix(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.matrix__ = _v
                return self.matrix__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.matrix__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_ColorMatrix)
        s.shader = self.shader
        s.matrix__ = self.matrix__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.matrix__ = None
h3d_shader_ColorMatrix._hx_class = h3d_shader_ColorMatrix
_hx_classes["h3d.shader.ColorMatrix"] = h3d_shader_ColorMatrix


class h3d_shader_DirShadow(hxsl_Shader):
    _hx_class_name = "h3d.shader.DirShadow"
    _hx_is_interface = "False"
    __slots__ = ("enable__", "USE_ESM__", "shadowPower__", "USE_PCF__", "pcfQuality__", "pcfScale__", "shadowRes__", "shadowMap__", "shadowMapChannel__", "shadowProj__", "shadowBias__", "poissonDiskLow__", "poissonDiskHigh__", "poissonDiskVeryHigh__")
    _hx_fields = ["enable__", "USE_ESM__", "shadowPower__", "USE_PCF__", "pcfQuality__", "pcfScale__", "shadowRes__", "shadowMap__", "shadowMapChannel__", "shadowProj__", "shadowBias__", "poissonDiskLow__", "poissonDiskHigh__", "poissonDiskVeryHigh__"]
    _hx_methods = ["get_enable", "set_enable", "get_USE_ESM", "set_USE_ESM", "get_shadowPower", "set_shadowPower", "get_USE_PCF", "set_USE_PCF", "get_pcfQuality", "set_pcfQuality", "get_pcfScale", "set_pcfScale", "get_shadowRes", "set_shadowRes", "get_shadowMap", "set_shadowMap", "get_shadowMapChannel", "set_shadowMapChannel", "get_shadowProj", "set_shadowProj", "get_shadowBias", "set_shadowBias", "get_poissonDiskLow", "set_poissonDiskLow", "get_poissonDiskHigh", "set_poissonDiskHigh", "get_poissonDiskVeryHigh", "set_poissonDiskVeryHigh", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.shadowMap__ = None
        self.USE_PCF__ = None
        self.USE_ESM__ = None
        self.enable__ = None
        self.poissonDiskVeryHigh__ = list()
        self.poissonDiskHigh__ = list()
        self.poissonDiskLow__ = list()
        self.shadowBias__ = 0
        self.shadowProj__ = h3d_Matrix()
        self.shadowMapChannel__ = hxsl_Channel.Unknown
        self.shadowRes__ = h3d_Vector()
        self.pcfScale__ = 0
        self.pcfQuality__ = 0
        self.shadowPower__ = 0
        super().__init__()
        self.poissonDiskLow__ = [h3d_Vector(-0.942,-0.399), h3d_Vector(0.945,-0.768), h3d_Vector(-0.094,-0.929), h3d_Vector(0.344,0.293)]
        self.poissonDiskHigh__ = [h3d_Vector(-0.326,-0.406), h3d_Vector(-0.840,-0.074), h3d_Vector(-0.696,0.457), h3d_Vector(-0.203,0.621), h3d_Vector(0.962,-0.195), h3d_Vector(0.473,-0.480), h3d_Vector(0.519,0.767), h3d_Vector(0.185,-0.893), h3d_Vector(0.507,0.064), h3d_Vector(0.896,0.412), h3d_Vector(-0.322,-0.933), h3d_Vector(-0.792,-0.598)]
        self.poissonDiskVeryHigh__ = [h3d_Vector(-0.613392,0.617481), h3d_Vector(0.170019,-0.040254), h3d_Vector(-0.299417,0.791925), h3d_Vector(0.645680,0.493210), h3d_Vector(-0.651784,0.717887), h3d_Vector(0.421003,0.027070), h3d_Vector(-0.817194,-0.271096), h3d_Vector(-0.705374,-0.668203), h3d_Vector(0.977050,-0.108615), h3d_Vector(0.063326,0.142369), h3d_Vector(0.203528,0.214331), h3d_Vector(-0.667531,0.326090), h3d_Vector(-0.098422,-0.295755), h3d_Vector(-0.885922,0.215369), h3d_Vector(0.566637,0.605213), h3d_Vector(0.039766,-0.396100), h3d_Vector(0.751946,0.453352), h3d_Vector(0.078707,-0.715323), h3d_Vector(-0.075838,-0.529344), h3d_Vector(0.724479,-0.580798), h3d_Vector(0.222999,-0.215125), h3d_Vector(-0.467574,-0.405438), h3d_Vector(-0.248268,-0.814753), h3d_Vector(0.354411,-0.887570), h3d_Vector(0.175817,0.382366), h3d_Vector(0.487472,-0.063082), h3d_Vector(-0.084078,0.898312), h3d_Vector(0.488876,-0.783441), h3d_Vector(0.470016,0.217933), h3d_Vector(-0.696890,-0.549791), h3d_Vector(-0.149693,0.605762), h3d_Vector(0.034211,0.979980), h3d_Vector(0.503098,-0.308878), h3d_Vector(-0.016205,-0.872921), h3d_Vector(0.385784,-0.393902), h3d_Vector(-0.146886,-0.859249), h3d_Vector(0.643361,0.164098), h3d_Vector(0.634388,-0.049471), h3d_Vector(-0.688894,0.007843), h3d_Vector(0.464034,-0.188818), h3d_Vector(-0.440840,0.137486), h3d_Vector(0.364483,0.511704), h3d_Vector(0.034028,0.325968), h3d_Vector(0.099094,-0.308023), h3d_Vector(0.693960,-0.366253), h3d_Vector(0.678884,-0.204688), h3d_Vector(0.001801,0.780328), h3d_Vector(0.145177,-0.898984), h3d_Vector(0.062655,-0.611866), h3d_Vector(0.315226,-0.604297), h3d_Vector(-0.780145,0.486251), h3d_Vector(-0.371868,0.882138), h3d_Vector(0.200476,0.494430), h3d_Vector(-0.494552,-0.711051), h3d_Vector(0.612476,0.705252), h3d_Vector(-0.578845,-0.768792), h3d_Vector(-0.772454,-0.090976), h3d_Vector(0.504440,0.372295), h3d_Vector(0.155736,0.065157), h3d_Vector(0.391522,0.849605), h3d_Vector(-0.620106,-0.328104), h3d_Vector(0.789239,-0.419965), h3d_Vector(-0.545396,0.538133), h3d_Vector(-0.178564,-0.596057)]

    def get_enable(self):
        return self.enable__

    def set_enable(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.enable__ = _v
                return self.enable__
            return _hx_local_0()
        return _hx_local_1()

    def get_USE_ESM(self):
        return self.USE_ESM__

    def set_USE_ESM(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.USE_ESM__ = _v
                return self.USE_ESM__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowPower(self):
        return self.shadowPower__

    def set_shadowPower(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.shadowPower__ = _v
                return self.shadowPower__
            return _hx_local_0()
        return _hx_local_1()

    def get_USE_PCF(self):
        return self.USE_PCF__

    def set_USE_PCF(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.USE_PCF__ = _v
                return self.USE_PCF__
            return _hx_local_0()
        return _hx_local_1()

    def get_pcfQuality(self):
        return self.pcfQuality__

    def set_pcfQuality(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.pcfQuality__ = _v
                return self.pcfQuality__
            return _hx_local_0()
        return _hx_local_1()

    def get_pcfScale(self):
        return self.pcfScale__

    def set_pcfScale(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.pcfScale__ = _v
                return self.pcfScale__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowRes(self):
        return self.shadowRes__

    def set_shadowRes(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.shadowRes__ = _v
                return self.shadowRes__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowMap(self):
        return self.shadowMap__

    def set_shadowMap(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.shadowMap__ = _v
                return self.shadowMap__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowMapChannel(self):
        return self.shadowMapChannel__

    def set_shadowMapChannel(self,v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.shadowMapChannel__ = v
                return self.shadowMapChannel__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowProj(self):
        return self.shadowProj__

    def set_shadowProj(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.shadowProj__ = _v
                return self.shadowProj__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowBias(self):
        return self.shadowBias__

    def set_shadowBias(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.shadowBias__ = _v
                return self.shadowBias__
            return _hx_local_0()
        return _hx_local_1()

    def get_poissonDiskLow(self):
        return self.poissonDiskLow__

    def set_poissonDiskLow(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.poissonDiskLow__ = _v
                return self.poissonDiskLow__
            return _hx_local_0()
        return _hx_local_1()

    def get_poissonDiskHigh(self):
        return self.poissonDiskHigh__

    def set_poissonDiskHigh(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.poissonDiskHigh__ = _v
                return self.poissonDiskHigh__
            return _hx_local_0()
        return _hx_local_1()

    def get_poissonDiskVeryHigh(self):
        return self.poissonDiskVeryHigh__

    def set_poissonDiskVeryHigh(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.poissonDiskVeryHigh__ = _v
                return self.poissonDiskVeryHigh__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.enable__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        if self.USE_ESM__:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.constBits
            _hx_local_2.constBits = (_hx_local_3 | 2)
            _hx_local_2.constBits
        if self.USE_PCF__:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.constBits
            _hx_local_4.constBits = (_hx_local_5 | 4)
            _hx_local_4.constBits
        v = self.pcfQuality__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("pcfQuality" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.constBits
        _hx_local_6.constBits = (_hx_local_7 | ((v << 3)))
        _hx_local_6.constBits
        if (self.shadowMap__ is None):
            self.shadowMapChannel__ = hxsl_Channel.Unknown
        elif (self.shadowMapChannel__ == hxsl_Channel.Unknown):
            if (self.shadowMap__.format == h3d_mat_Texture.nativeFormat):
                self.shadowMapChannel__ = hxsl_Channel.PackedFloat
            else:
                raise haxe_Exception.thrown(("shadowMap" + "Channel is not set"))
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.constBits
        _hx_local_8.constBits = (_hx_local_9 | (((((globals.allocChannelID(self.shadowMap__) << 3) | self.shadowMapChannel__.index)) << 11)))
        _hx_local_8.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.enable__
        elif (index1 == 1):
            return self.USE_ESM__
        elif (index1 == 2):
            return self.shadowPower__
        elif (index1 == 3):
            return self.USE_PCF__
        elif (index1 == 4):
            return self.pcfQuality__
        elif (index1 == 5):
            return self.pcfScale__
        elif (index1 == 6):
            return self.shadowRes__
        elif (index1 == 7):
            return self.shadowMap__
        elif (index1 == 8):
            return self.shadowProj__
        elif (index1 == 9):
            return self.shadowBias__
        elif (index1 == 10):
            return self.poissonDiskLow__
        elif (index1 == 11):
            return self.poissonDiskHigh__
        elif (index1 == 12):
            return self.poissonDiskVeryHigh__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        index1 = index
        if (index1 == 2):
            return self.shadowPower__
        elif (index1 == 5):
            return self.pcfScale__
        elif (index1 == 9):
            return self.shadowBias__
        else:
            pass
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_DirShadow)
        s.shader = self.shader
        s.enable__ = self.enable__
        s.USE_ESM__ = self.USE_ESM__
        s.shadowPower__ = self.shadowPower__
        s.USE_PCF__ = self.USE_PCF__
        s.pcfQuality__ = self.pcfQuality__
        s.pcfScale__ = self.pcfScale__
        s.shadowRes__ = self.shadowRes__
        s.shadowMap__ = self.shadowMap__
        s.shadowProj__ = self.shadowProj__
        s.shadowBias__ = self.shadowBias__
        s.poissonDiskLow__ = self.poissonDiskLow__
        s.poissonDiskHigh__ = self.poissonDiskHigh__
        s.poissonDiskVeryHigh__ = self.poissonDiskVeryHigh__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.enable__ = None
        _hx_o.USE_ESM__ = None
        _hx_o.shadowPower__ = None
        _hx_o.USE_PCF__ = None
        _hx_o.pcfQuality__ = None
        _hx_o.pcfScale__ = None
        _hx_o.shadowRes__ = None
        _hx_o.shadowMap__ = None
        _hx_o.shadowMapChannel__ = None
        _hx_o.shadowProj__ = None
        _hx_o.shadowBias__ = None
        _hx_o.poissonDiskLow__ = None
        _hx_o.poissonDiskHigh__ = None
        _hx_o.poissonDiskVeryHigh__ = None
h3d_shader_DirShadow._hx_class = h3d_shader_DirShadow
_hx_classes["h3d.shader.DirShadow"] = h3d_shader_DirShadow


class h3d_shader_GenTexture(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.shader.GenTexture"
    _hx_is_interface = "False"
    __slots__ = ("mode__", "color__")
    _hx_fields = ["mode__", "color__"]
    _hx_methods = ["get_mode", "set_mode", "get_color", "set_color", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.color__ = h3d_Vector()
        self.mode__ = 0
        super().__init__()

    def get_mode(self):
        return self.mode__

    def set_mode(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.mode__ = _v
                return self.mode__
            return _hx_local_0()
        return _hx_local_1()

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.mode__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("mode" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.mode__
        elif (index1 == 2):
            return self.color__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_GenTexture)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.mode__ = self.mode__
        s.color__ = self.color__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mode__ = None
        _hx_o.color__ = None
h3d_shader_GenTexture._hx_class = h3d_shader_GenTexture
_hx_classes["h3d.shader.GenTexture"] = h3d_shader_GenTexture


class h3d_shader_LineShader(hxsl_Shader):
    _hx_class_name = "h3d.shader.LineShader"
    _hx_is_interface = "False"
    __slots__ = ("lengthScale__", "width__")
    _hx_fields = ["lengthScale__", "width__"]
    _hx_methods = ["get_lengthScale", "set_lengthScale", "get_width", "set_width", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,width = None,lengthScale = None):
        if (width is None):
            width = 1.5
        if (lengthScale is None):
            lengthScale = 1.
        self.width__ = 0
        self.lengthScale__ = 0
        super().__init__()
        self.width__ = width
        self.lengthScale__ = lengthScale

    def get_lengthScale(self):
        return self.lengthScale__

    def set_lengthScale(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.lengthScale__ = _v
                return self.lengthScale__
            return _hx_local_0()
        return _hx_local_1()

    def get_width(self):
        return self.width__

    def set_width(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.width__ = _v
                return self.width__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.lengthScale__
        elif (index1 == 1):
            return self.width__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.lengthScale__
        elif (index1 == 1):
            return self.width__
        else:
            pass
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_LineShader)
        s.shader = self.shader
        s.lengthScale__ = self.lengthScale__
        s.width__ = self.width__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lengthScale__ = None
        _hx_o.width__ = None
h3d_shader_LineShader._hx_class = h3d_shader_LineShader
_hx_classes["h3d.shader.LineShader"] = h3d_shader_LineShader


class h3d_shader_MinMaxShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.shader.MinMaxShader"
    _hx_is_interface = "False"
    __slots__ = ("texA__", "texB__", "isMax__")
    _hx_fields = ["texA__", "texB__", "isMax__"]
    _hx_methods = ["get_texA", "set_texA", "get_texB", "set_texB", "get_isMax", "set_isMax", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.isMax__ = None
        self.texB__ = None
        self.texA__ = None
        super().__init__()

    def get_texA(self):
        return self.texA__

    def set_texA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texA__ = _v
                return self.texA__
            return _hx_local_0()
        return _hx_local_1()

    def get_texB(self):
        return self.texB__

    def set_texB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texB__ = _v
                return self.texB__
            return _hx_local_0()
        return _hx_local_1()

    def get_isMax(self):
        return self.isMax__

    def set_isMax(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isMax__ = _v
                return self.isMax__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.isMax__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texA__
        elif (index1 == 2):
            return self.texB__
        elif (index1 == 3):
            return self.isMax__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_MinMaxShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texA__ = self.texA__
        s.texB__ = self.texB__
        s.isMax__ = self.isMax__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texA__ = None
        _hx_o.texB__ = None
        _hx_o.isMax__ = None
h3d_shader_MinMaxShader._hx_class = h3d_shader_MinMaxShader
_hx_classes["h3d.shader.MinMaxShader"] = h3d_shader_MinMaxShader


class h3d_shader_CubeMinMaxShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.shader.CubeMinMaxShader"
    _hx_is_interface = "False"
    __slots__ = ("texA__", "texB__", "isMax__", "mat__")
    _hx_fields = ["texA__", "texB__", "isMax__", "mat__"]
    _hx_methods = ["get_texA", "set_texA", "get_texB", "set_texB", "get_isMax", "set_isMax", "get_mat", "set_mat", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.isMax__ = None
        self.texB__ = None
        self.texA__ = None
        self.mat__ = h3d_Matrix()
        super().__init__()

    def get_texA(self):
        return self.texA__

    def set_texA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texA__ = _v
                return self.texA__
            return _hx_local_0()
        return _hx_local_1()

    def get_texB(self):
        return self.texB__

    def set_texB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texB__ = _v
                return self.texB__
            return _hx_local_0()
        return _hx_local_1()

    def get_isMax(self):
        return self.isMax__

    def set_isMax(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isMax__ = _v
                return self.isMax__
            return _hx_local_0()
        return _hx_local_1()

    def get_mat(self):
        return self.mat__

    def set_mat(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.mat__ = _v
                return self.mat__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.isMax__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texA__
        elif (index1 == 2):
            return self.texB__
        elif (index1 == 3):
            return self.isMax__
        elif (index1 == 4):
            return self.mat__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_CubeMinMaxShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texA__ = self.texA__
        s.texB__ = self.texB__
        s.isMax__ = self.isMax__
        s.mat__ = self.mat__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texA__ = None
        _hx_o.texB__ = None
        _hx_o.isMax__ = None
        _hx_o.mat__ = None
h3d_shader_CubeMinMaxShader._hx_class = h3d_shader_CubeMinMaxShader
_hx_classes["h3d.shader.CubeMinMaxShader"] = h3d_shader_CubeMinMaxShader


class h3d_shader_NormalMap(hxsl_Shader):
    _hx_class_name = "h3d.shader.NormalMap"
    _hx_is_interface = "False"
    __slots__ = ("texture__",)
    _hx_fields = ["texture__"]
    _hx_methods = ["get_texture", "set_texture", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,texture = None):
        self.texture__ = None
        super().__init__()
        self.texture__ = texture

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.texture__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_NormalMap)
        s.shader = self.shader
        s.texture__ = self.texture__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
h3d_shader_NormalMap._hx_class = h3d_shader_NormalMap
_hx_classes["h3d.shader.NormalMap"] = h3d_shader_NormalMap


class h3d_shader_Shadow(hxsl_Shader):
    _hx_class_name = "h3d.shader.Shadow"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["updateConstants", "getParamValue", "getParamFloatValue"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        super().__init__()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        return None

    def getParamFloatValue(self,index):
        return 0.
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_shader_Shadow._hx_class = h3d_shader_Shadow
_hx_classes["h3d.shader.Shadow"] = h3d_shader_Shadow


class h3d_shader_SignedDistanceField(hxsl_Shader):
    _hx_class_name = "h3d.shader.SignedDistanceField"
    _hx_is_interface = "False"
    __slots__ = ("channel__", "alphaCutoff__", "smoothing__")
    _hx_fields = ["channel__", "alphaCutoff__", "smoothing__"]
    _hx_methods = ["get_channel", "set_channel", "get_alphaCutoff", "set_alphaCutoff", "get_smoothing", "set_smoothing", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.smoothing__ = 0.0416666666666666644
        self.alphaCutoff__ = 0.5
        self.channel__ = 0
        super().__init__()

    def get_channel(self):
        return self.channel__

    def set_channel(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.channel__ = _v
                return self.channel__
            return _hx_local_0()
        return _hx_local_1()

    def get_alphaCutoff(self):
        return self.alphaCutoff__

    def set_alphaCutoff(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.alphaCutoff__ = _v
                return self.alphaCutoff__
            return _hx_local_0()
        return _hx_local_1()

    def get_smoothing(self):
        return self.smoothing__

    def set_smoothing(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.smoothing__ = _v
                return self.smoothing__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.channel__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("channel" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.channel__
        elif (index1 == 1):
            return self.alphaCutoff__
        elif (index1 == 2):
            return self.smoothing__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        index1 = index
        if (index1 == 1):
            return self.alphaCutoff__
        elif (index1 == 2):
            return self.smoothing__
        else:
            pass
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_SignedDistanceField)
        s.shader = self.shader
        s.channel__ = self.channel__
        s.alphaCutoff__ = self.alphaCutoff__
        s.smoothing__ = self.smoothing__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.channel__ = None
        _hx_o.alphaCutoff__ = None
        _hx_o.smoothing__ = None
h3d_shader_SignedDistanceField._hx_class = h3d_shader_SignedDistanceField
_hx_classes["h3d.shader.SignedDistanceField"] = h3d_shader_SignedDistanceField


class h3d_shader_SkinBase(hxsl_Shader):
    _hx_class_name = "h3d.shader.SkinBase"
    _hx_is_interface = "False"
    __slots__ = ("MaxBones__", "bonesMatrixes__")
    _hx_fields = ["MaxBones__", "bonesMatrixes__"]
    _hx_methods = ["get_MaxBones", "set_MaxBones", "get_bonesMatrixes", "set_bonesMatrixes", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.bonesMatrixes__ = list()
        self.MaxBones__ = 0
        super().__init__()
        self.constModified = True
        self.MaxBones__ = 34

    def get_MaxBones(self):
        return self.MaxBones__

    def set_MaxBones(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.MaxBones__ = _v
                return self.MaxBones__
            return _hx_local_0()
        return _hx_local_1()

    def get_bonesMatrixes(self):
        return self.bonesMatrixes__

    def set_bonesMatrixes(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.bonesMatrixes__ = _v
                return self.bonesMatrixes__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.MaxBones__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("MaxBones" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.MaxBones__
        elif (index1 == 1):
            return self.bonesMatrixes__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_SkinBase)
        s.shader = self.shader
        s.MaxBones__ = self.MaxBones__
        s.bonesMatrixes__ = self.bonesMatrixes__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.MaxBones__ = None
        _hx_o.bonesMatrixes__ = None
h3d_shader_SkinBase._hx_class = h3d_shader_SkinBase
_hx_classes["h3d.shader.SkinBase"] = h3d_shader_SkinBase


class h3d_shader_Skin(h3d_shader_SkinBase):
    _hx_class_name = "h3d.shader.Skin"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_SkinBase


    def __init__(self):
        super().__init__()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.MaxBones__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("MaxBones" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.MaxBones__
        elif (index1 == 1):
            return self.bonesMatrixes__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_Skin)
        s.shader = self.shader
        s.MaxBones__ = self.MaxBones__
        s.bonesMatrixes__ = self.bonesMatrixes__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_shader_Skin._hx_class = h3d_shader_Skin
_hx_classes["h3d.shader.Skin"] = h3d_shader_Skin


class h3d_shader_SkinTangent(h3d_shader_SkinBase):
    _hx_class_name = "h3d.shader.SkinTangent"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_SkinBase


    def __init__(self):
        super().__init__()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.MaxBones__
        if (HxOverrides.rshift(v, 8) != 0):
            raise haxe_Exception.thrown((((("MaxBones" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.MaxBones__
        elif (index1 == 1):
            return self.bonesMatrixes__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_SkinTangent)
        s.shader = self.shader
        s.MaxBones__ = self.MaxBones__
        s.bonesMatrixes__ = self.bonesMatrixes__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_shader_SkinTangent._hx_class = h3d_shader_SkinTangent
_hx_classes["h3d.shader.SkinTangent"] = h3d_shader_SkinTangent


class h3d_shader_SpecularTexture(hxsl_Shader):
    _hx_class_name = "h3d.shader.SpecularTexture"
    _hx_is_interface = "False"
    __slots__ = ("texture__",)
    _hx_fields = ["texture__"]
    _hx_methods = ["get_texture", "set_texture", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,tex = None):
        self.texture__ = None
        super().__init__()
        self.texture__ = tex

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.texture__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_SpecularTexture)
        s.shader = self.shader
        s.texture__ = self.texture__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
h3d_shader_SpecularTexture._hx_class = h3d_shader_SpecularTexture
_hx_classes["h3d.shader.SpecularTexture"] = h3d_shader_SpecularTexture


class h3d_shader_Texture(hxsl_Shader):
    _hx_class_name = "h3d.shader.Texture"
    _hx_is_interface = "False"
    __slots__ = ("additive__", "killAlpha__", "specularAlpha__", "killAlphaThreshold__", "texture__")
    _hx_fields = ["additive__", "killAlpha__", "specularAlpha__", "killAlphaThreshold__", "texture__"]
    _hx_methods = ["get_additive", "set_additive", "get_killAlpha", "set_killAlpha", "get_specularAlpha", "set_specularAlpha", "get_killAlphaThreshold", "set_killAlphaThreshold", "get_texture", "set_texture", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,tex = None):
        self.texture__ = None
        self.specularAlpha__ = None
        self.killAlpha__ = None
        self.additive__ = None
        self.killAlphaThreshold__ = 0
        super().__init__()
        self.texture__ = tex
        self.killAlphaThreshold__ = h3d_mat_Defaults.defaultKillAlphaThreshold

    def get_additive(self):
        return self.additive__

    def set_additive(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.additive__ = _v
                return self.additive__
            return _hx_local_0()
        return _hx_local_1()

    def get_killAlpha(self):
        return self.killAlpha__

    def set_killAlpha(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.killAlpha__ = _v
                return self.killAlpha__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularAlpha(self):
        return self.specularAlpha__

    def set_specularAlpha(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.specularAlpha__ = _v
                return self.specularAlpha__
            return _hx_local_0()
        return _hx_local_1()

    def get_killAlphaThreshold(self):
        return self.killAlphaThreshold__

    def set_killAlphaThreshold(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.killAlphaThreshold__ = _v
                return self.killAlphaThreshold__
            return _hx_local_0()
        return _hx_local_1()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.additive__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        if self.killAlpha__:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.constBits
            _hx_local_2.constBits = (_hx_local_3 | 2)
            _hx_local_2.constBits
        if self.specularAlpha__:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.constBits
            _hx_local_4.constBits = (_hx_local_5 | 4)
            _hx_local_4.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.additive__
        elif (index1 == 1):
            return self.killAlpha__
        elif (index1 == 2):
            return self.specularAlpha__
        elif (index1 == 3):
            return self.killAlphaThreshold__
        elif (index1 == 4):
            return self.texture__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 3):
            return self.killAlphaThreshold__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_Texture)
        s.shader = self.shader
        s.additive__ = self.additive__
        s.killAlpha__ = self.killAlpha__
        s.specularAlpha__ = self.specularAlpha__
        s.killAlphaThreshold__ = self.killAlphaThreshold__
        s.texture__ = self.texture__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.additive__ = None
        _hx_o.killAlpha__ = None
        _hx_o.specularAlpha__ = None
        _hx_o.killAlphaThreshold__ = None
        _hx_o.texture__ = None
h3d_shader_Texture._hx_class = h3d_shader_Texture
_hx_classes["h3d.shader.Texture"] = h3d_shader_Texture


class h3d_shader_UVDelta(hxsl_Shader):
    _hx_class_name = "h3d.shader.UVDelta"
    _hx_is_interface = "False"
    __slots__ = ("uvDelta__", "uvScale__")
    _hx_fields = ["uvDelta__", "uvScale__"]
    _hx_methods = ["get_uvDelta", "set_uvDelta", "get_uvScale", "set_uvScale", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,dx = None,dy = None,sx = None,sy = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        if (sx is None):
            sx = 1.
        if (sy is None):
            sy = 1.
        self.uvScale__ = h3d_Vector()
        self.uvDelta__ = h3d_Vector()
        super().__init__()
        _this = self.uvDelta__
        x = dx
        y = dy
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        _this = self.uvScale__
        x = sx
        y = sy
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.

    def get_uvDelta(self):
        return self.uvDelta__

    def set_uvDelta(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.uvDelta__ = _v
                return self.uvDelta__
            return _hx_local_0()
        return _hx_local_1()

    def get_uvScale(self):
        return self.uvScale__

    def set_uvScale(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.uvScale__ = _v
                return self.uvScale__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.uvDelta__
        elif (index1 == 1):
            return self.uvScale__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_UVDelta)
        s.shader = self.shader
        s.uvDelta__ = self.uvDelta__
        s.uvScale__ = self.uvScale__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.uvDelta__ = None
        _hx_o.uvScale__ = None
h3d_shader_UVDelta._hx_class = h3d_shader_UVDelta
_hx_classes["h3d.shader.UVDelta"] = h3d_shader_UVDelta


class h3d_shader_VertexColorAlpha(hxsl_Shader):
    _hx_class_name = "h3d.shader.VertexColorAlpha"
    _hx_is_interface = "False"
    __slots__ = ("additive__",)
    _hx_fields = ["additive__"]
    _hx_methods = ["get_additive", "set_additive", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.additive__ = None
        super().__init__()

    def get_additive(self):
        return self.additive__

    def set_additive(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.additive__ = _v
                return self.additive__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.additive__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.additive__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_VertexColorAlpha)
        s.shader = self.shader
        s.additive__ = self.additive__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.additive__ = None
h3d_shader_VertexColorAlpha._hx_class = h3d_shader_VertexColorAlpha
_hx_classes["h3d.shader.VertexColorAlpha"] = h3d_shader_VertexColorAlpha


class h3d_shader_VolumeDecal(hxsl_Shader):
    _hx_class_name = "h3d.shader.VolumeDecal"
    _hx_is_interface = "False"
    __slots__ = ("scale__", "normal__", "tangent__", "isCentered__")
    _hx_fields = ["scale__", "normal__", "tangent__", "isCentered__"]
    _hx_methods = ["get_scale", "set_scale", "get_normal", "set_normal", "get_tangent", "set_tangent", "get_isCentered", "set_isCentered", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,objectWidth,objectHeight):
        self.isCentered__ = True
        self.tangent__ = h3d_Vector()
        self.normal__ = h3d_Vector()
        self.scale__ = h3d_Vector()
        super().__init__()
        _this = self.normal__
        x = 0
        y = 0
        z = 1
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.tangent__
        x = 1
        y = 0
        z = 0
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.scale__
        x = (1 / objectWidth)
        y = (1 / objectHeight)
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.

    def get_scale(self):
        return self.scale__

    def set_scale(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.scale__ = _v
                return self.scale__
            return _hx_local_0()
        return _hx_local_1()

    def get_normal(self):
        return self.normal__

    def set_normal(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.normal__ = _v
                return self.normal__
            return _hx_local_0()
        return _hx_local_1()

    def get_tangent(self):
        return self.tangent__

    def set_tangent(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.tangent__ = _v
                return self.tangent__
            return _hx_local_0()
        return _hx_local_1()

    def get_isCentered(self):
        return self.isCentered__

    def set_isCentered(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isCentered__ = _v
                return self.isCentered__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.isCentered__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 64)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.scale__
        elif (index1 == 1):
            return self.normal__
        elif (index1 == 2):
            return self.tangent__
        elif (index1 == 3):
            return self.isCentered__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_VolumeDecal)
        s.shader = self.shader
        s.scale__ = self.scale__
        s.normal__ = self.normal__
        s.tangent__ = self.tangent__
        s.isCentered__ = self.isCentered__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.scale__ = None
        _hx_o.normal__ = None
        _hx_o.tangent__ = None
        _hx_o.isCentered__ = None
h3d_shader_VolumeDecal._hx_class = h3d_shader_VolumeDecal
_hx_classes["h3d.shader.VolumeDecal"] = h3d_shader_VolumeDecal


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    _hx_is_interface = "True"
    __slots__ = ()
haxe_IMap._hx_class = haxe_IMap
_hx_classes["haxe.IMap"] = haxe_IMap


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "remove", "keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def remove(self,key):
        r = (key in self.h)
        if r:
            del self.h[key]
        return r

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap
_hx_classes["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap


class sys_thread_Mutex:
    _hx_class_name = "sys.thread.Mutex"
    _hx_is_interface = "False"
    __slots__ = ("lock",)
    _hx_fields = ["lock"]

    def __init__(self):
        self.lock = sys_thread__Mutex_NativeRLock()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lock = None
sys_thread_Mutex._hx_class = sys_thread_Mutex
_hx_classes["sys.thread.Mutex"] = sys_thread_Mutex


class sys_thread_EventLoop:
    _hx_class_name = "sys.thread.EventLoop"
    _hx_is_interface = "False"
    __slots__ = ("mutex", "oneTimeEvents", "oneTimeEventsIdx", "waitLock", "promisedEventsCount", "regularEvents")
    _hx_fields = ["mutex", "oneTimeEvents", "oneTimeEventsIdx", "waitLock", "promisedEventsCount", "regularEvents"]
    _hx_methods = ["repeat", "cancel", "loop"]

    def __init__(self):
        self.regularEvents = None
        self.promisedEventsCount = 0
        self.waitLock = sys_thread_Lock()
        self.oneTimeEventsIdx = 0
        self.oneTimeEvents = list()
        self.mutex = sys_thread_Mutex()

    def repeat(self,event,intervalMs):
        self.mutex.lock.acquire(True)
        interval = (0.001 * intervalMs)
        event1 = sys_thread__EventLoop_RegularEvent(event,(python_lib_Time.time() + interval),interval)
        _g = self.regularEvents
        if (_g is not None):
            current = _g
            event1.next = current
            current.previous = event1
        self.regularEvents = event1
        self.waitLock.semaphore.release()
        self.mutex.lock.release()
        return event1

    def cancel(self,eventHandler):
        self.mutex.lock.acquire(True)
        event = eventHandler
        if (self.regularEvents == event):
            self.regularEvents = event.next
        _g = event.next
        if (_g is not None):
            e = _g
            e.previous = event.previous
        _g = event.previous
        if (_g is not None):
            e = _g
            e.next = event.next
        self.mutex.lock.release()

    def loop(self):
        events = []
        while True:
            now = python_lib_Time.time()
            eventsToRun = events
            eventsToRunIdx = 0
            nextEventAt = -1
            self.mutex.lock.acquire(True)
            while self.waitLock.semaphore.acquire(True,0.0):
                pass
            current = self.regularEvents
            while (current is not None):
                if (current.nextRunTime <= now):
                    tmp = eventsToRunIdx
                    eventsToRunIdx = (eventsToRunIdx + 1)
                    python_internal_ArrayImpl._set(eventsToRun, tmp, current.run)
                    current.nextRunTime = (current.nextRunTime + current.interval)
                    nextEventAt = -2
                elif ((nextEventAt == -1) or ((current.nextRunTime < nextEventAt))):
                    nextEventAt = current.nextRunTime
                current = current.next
            self.mutex.lock.release()
            _g = 0
            _g1 = eventsToRunIdx
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                (eventsToRun[i] if i >= 0 and i < len(eventsToRun) else None)()
                python_internal_ArrayImpl._set(eventsToRun, i, None)
            eventsToRunIdx = 0
            self.mutex.lock.acquire(True)
            _g2_current = 0
            _g2_array = self.oneTimeEvents
            while (_g2_current < len(_g2_array)):
                _g3_value = (_g2_array[_g2_current] if _g2_current >= 0 and _g2_current < len(_g2_array) else None)
                _g3_key = _g2_current
                _g2_current = (_g2_current + 1)
                i1 = _g3_key
                event = _g3_value
                if (event is None):
                    break
                else:
                    tmp1 = eventsToRunIdx
                    eventsToRunIdx = (eventsToRunIdx + 1)
                    python_internal_ArrayImpl._set(eventsToRun, tmp1, event)
                    python_internal_ArrayImpl._set(self.oneTimeEvents, i1, None)
            self.oneTimeEventsIdx = 0
            hasPromisedEvents = (self.promisedEventsCount > 0)
            self.mutex.lock.release()
            _g2 = 0
            _g3 = eventsToRunIdx
            while (_g2 < _g3):
                i2 = _g2
                _g2 = (_g2 + 1)
                (eventsToRun[i2] if i2 >= 0 and i2 < len(eventsToRun) else None)()
                python_internal_ArrayImpl._set(eventsToRun, i2, None)
            if (eventsToRunIdx > 0):
                nextEventAt = -2
            r_nextEventAt = nextEventAt
            r_anyTime = hasPromisedEvents
            _g4 = r_anyTime
            _g5 = r_nextEventAt
            _g6 = _g5
            if (_g6 == -2):
                pass
            elif (_g6 == -1):
                if _g4:
                    self.waitLock.semaphore.acquire(True,None)
                else:
                    break
            else:
                time = _g5
                timeout = (time - python_lib_Time.time())
                _this = self.waitLock
                timeout1 = (0 if (python_lib_Math.isnan(0)) else (timeout if (python_lib_Math.isnan(timeout)) else max(0,timeout)))
                _this.semaphore.acquire(True,timeout1)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mutex = None
        _hx_o.oneTimeEvents = None
        _hx_o.oneTimeEventsIdx = None
        _hx_o.waitLock = None
        _hx_o.promisedEventsCount = None
        _hx_o.regularEvents = None
sys_thread_EventLoop._hx_class = sys_thread_EventLoop
_hx_classes["sys.thread.EventLoop"] = sys_thread_EventLoop


class sys_thread__Thread_HxThread:
    _hx_class_name = "sys.thread._Thread.HxThread"
    _hx_is_interface = "False"
    __slots__ = ("events", "nativeThread")
    _hx_fields = ["events", "nativeThread"]
    _hx_statics = ["threads", "threadsMutex", "mainThread", "current"]

    def __init__(self,t):
        self.events = None
        self.nativeThread = t
    threads = None
    threadsMutex = None
    mainThread = None

    @staticmethod
    def current():
        sys_thread__Thread_HxThread.threadsMutex.lock.acquire(True)
        ct = threading.current_thread()
        if (ct == threading.main_thread()):
            sys_thread__Thread_HxThread.threadsMutex.lock.release()
            return sys_thread__Thread_HxThread.mainThread
        if (not (ct in sys_thread__Thread_HxThread.threads.h)):
            sys_thread__Thread_HxThread.threads.set(ct,sys_thread__Thread_HxThread(ct))
        t = sys_thread__Thread_HxThread.threads.h.get(ct,None)
        sys_thread__Thread_HxThread.threadsMutex.lock.release()
        return t

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.events = None
        _hx_o.nativeThread = None
sys_thread__Thread_HxThread._hx_class = sys_thread__Thread_HxThread
_hx_classes["sys.thread._Thread.HxThread"] = sys_thread__Thread_HxThread


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run():
        pass
haxe_EntryPoint._hx_class = haxe_EntryPoint
_hx_classes["haxe.EntryPoint"] = haxe_EntryPoint


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    _hx_is_interface = "False"
    __slots__ = ("_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "toString", "get_message", "get_native"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def toString(self):
        return self.get_message()

    def get_message(self):
        return str(self)

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___nativeStack = None
        _hx_o._hx___skipStack = None
        _hx_o._hx___nativeException = None
        _hx_o._hx___previousException = None
haxe_Exception._hx_class = haxe_Exception
_hx_classes["haxe.Exception"] = haxe_Exception


class haxe__Int64____Int64:
    _hx_class_name = "haxe._Int64.___Int64"
    _hx_is_interface = "False"
    __slots__ = ("high", "low")
    _hx_fields = ["high", "low"]

    def __init__(self,high,low):
        self.high = high
        self.low = low

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.high = None
        _hx_o.low = None
haxe__Int64____Int64._hx_class = haxe__Int64____Int64
_hx_classes["haxe._Int64.___Int64"] = haxe__Int64____Int64


class haxe_Log:
    _hx_class_name = "haxe.Log"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        _hx_str = Std.string(v)
        if (infos is None):
            return _hx_str
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        if (Reflect.field(infos,"customParams") is not None):
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v))))
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        _hx_str = haxe_Log.formatOutput(v,infos)
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
haxe_Log._hx_class = haxe_Log
_hx_classes["haxe.Log"] = haxe_Log


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    _hx_is_interface = "False"
    __slots__ = ("f", "prev", "next", "isBlocking", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "isBlocking", "nextRun", "priority"]
    _hx_methods = ["stop"]

    def __init__(self,f,p):
        self.next = None
        self.prev = None
        self.isBlocking = True
        self.f = f
        self.priority = p
        self.nextRun = Math.NEGATIVE_INFINITY

    def stop(self):
        if (self.f is None):
            return
        self.f = None
        self.nextRun = Math.NEGATIVE_INFINITY
        if (self.prev is None):
            haxe_MainLoop.pending = self.next
        else:
            self.prev.next = self.next
        if (self.next is not None):
            self.next.prev = self.prev

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
        _hx_o.prev = None
        _hx_o.next = None
        _hx_o.isBlocking = None
        _hx_o.nextRun = None
        _hx_o.priority = None
haxe_MainEvent._hx_class = haxe_MainEvent
_hx_classes["haxe.MainEvent"] = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["eventLoopHandler", "mutex", "mainThread", "pending", "hasEvents", "add", "injectIntoEventLoop", "sortEvents", "tick"]
    eventLoopHandler = None
    pending = None

    @staticmethod
    def hasEvents():
        p = haxe_MainLoop.pending
        while (p is not None):
            if p.isBlocking:
                return True
            p = p.next
        return False

    @staticmethod
    def add(f,priority = None):
        if (priority is None):
            priority = 0
        if (f is None):
            raise haxe_Exception.thrown("Event function is null")
        e = haxe_MainEvent(f,priority)
        head = haxe_MainLoop.pending
        if (head is not None):
            head.prev = e
        e.next = head
        haxe_MainLoop.pending = e
        haxe_MainLoop.injectIntoEventLoop(0)
        return e

    @staticmethod
    def injectIntoEventLoop(waitMs):
        haxe_MainLoop.mutex.lock.acquire(True)
        if (haxe_MainLoop.eventLoopHandler is not None):
            sys_thread__Thread_Thread_Impl_.get_events(haxe_MainLoop.mainThread).cancel(haxe_MainLoop.eventLoopHandler)
        def _hx_local_0():
            wait = haxe_MainLoop.tick()
            if haxe_MainLoop.hasEvents():
                tmp = None
                try:
                    tmp = int((wait * 1000))
                except BaseException as _g:
                    None
                    tmp = None
                haxe_MainLoop.injectIntoEventLoop(tmp)
        haxe_MainLoop.eventLoopHandler = sys_thread__Thread_Thread_Impl_.get_events(haxe_MainLoop.mainThread).repeat(_hx_local_0,waitMs)
        haxe_MainLoop.mutex.lock.release()

    @staticmethod
    def sortEvents():
        _hx_list = haxe_MainLoop.pending
        if (_hx_list is None):
            return
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        p = None
        q = None
        e = None
        tail = None
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            nmerges = 0
            while (p is not None):
                nmerges = (nmerges + 1)
                q = p
                psize = 0
                _g = 0
                _g1 = insize
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    psize = (psize + 1)
                    q = q.next
                    if (q is None):
                        break
                qsize = insize
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    if (psize == 0):
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        e = p
                        p = p.next
                        psize = (psize - 1)
                    else:
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    e.prev = tail
                    tail = e
                p = q
            tail.next = None
            if (nmerges <= 1):
                break
            insize = (insize * 2)
        _hx_list.prev = None
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        haxe_MainLoop.sortEvents()
        e = haxe_MainLoop.pending
        now = python_lib_Timeit.default_timer()
        wait = 1e9
        while (e is not None):
            next = e.next
            wt = (e.nextRun - now)
            if (wt <= 0):
                wait = 0
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            e = next
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop
_hx_classes["haxe.MainLoop"] = haxe_MainLoop


class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []
haxe_NativeStackTrace._hx_class = haxe_NativeStackTrace
_hx_classes["haxe.NativeStackTrace"] = haxe_NativeStackTrace


class haxe_Serializer:
    _hx_class_name = "haxe.Serializer"
    _hx_is_interface = "False"
    __slots__ = ("buf", "cache", "shash", "scount", "useCache", "useEnumIndex")
    _hx_fields = ["buf", "cache", "shash", "scount", "useCache", "useEnumIndex"]
    _hx_methods = ["toString", "serializeString", "serializeRef", "serializeFields", "serialize"]
    _hx_statics = ["USE_CACHE", "USE_ENUM_INDEX", "BASE64", "BASE64_CODES", "run"]

    def __init__(self):
        self.buf = StringBuf()
        self.cache = list()
        self.useCache = haxe_Serializer.USE_CACHE
        self.useEnumIndex = haxe_Serializer.USE_ENUM_INDEX
        self.shash = haxe_ds_StringMap()
        self.scount = 0

    def toString(self):
        return self.buf.b.getvalue()

    def serializeString(self,s):
        x = self.shash.h.get(s,None)
        if (x is not None):
            self.buf.b.write("R")
            _this = self.buf
            s1 = Std.string(x)
            _this.b.write(s1)
            return
        value = self.scount
        self.scount = (self.scount + 1)
        self.shash.h[s] = value
        self.buf.b.write("y")
        s = python_lib_urllib_Parse.quote(s,"")
        _this = self.buf
        s1 = Std.string(len(s))
        _this.b.write(s1)
        self.buf.b.write(":")
        _this = self.buf
        s1 = Std.string(s)
        _this.b.write(s1)

    def serializeRef(self,v):
        _g = 0
        _g1 = len(self.cache)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq((self.cache[i] if i >= 0 and i < len(self.cache) else None),v):
                self.buf.b.write("r")
                _this = self.buf
                s = Std.string(i)
                _this.b.write(s)
                return True
        _this = self.cache
        _this.append(v)
        return False

    def serializeFields(self,v):
        _g = 0
        _g1 = python_Boot.fields(v)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.serializeString(f)
            self.serialize(Reflect.field(v,f))
        self.buf.b.write("g")

    def serialize(self,v):
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 0):
            self.buf.b.write("n")
        elif (tmp == 1):
            v1 = v
            if (v1 == 0):
                self.buf.b.write("z")
                return
            self.buf.b.write("i")
            _this = self.buf
            s = Std.string(v1)
            _this.b.write(s)
        elif (tmp == 2):
            v1 = v
            if python_lib_Math.isnan(v1):
                self.buf.b.write("k")
            elif (not ((((v1 != Math.POSITIVE_INFINITY) and ((v1 != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(v1))))):
                self.buf.b.write(("m" if ((v1 < 0)) else "p"))
            else:
                self.buf.b.write("d")
                _this = self.buf
                s = Std.string(v1)
                _this.b.write(s)
        elif (tmp == 3):
            self.buf.b.write(("t" if v else "f"))
        elif (tmp == 4):
            if Std.isOfType(v,Class):
                className = Type.getClassName(v)
                self.buf.b.write("A")
                self.serializeString(className)
            elif Std.isOfType(v,Enum):
                self.buf.b.write("B")
                self.serializeString(Type.getEnumName(v))
            else:
                if (self.useCache and self.serializeRef(v)):
                    return
                self.buf.b.write("o")
                self.serializeFields(v)
        elif (tmp == 5):
            raise haxe_Exception.thrown("Cannot serialize function")
        elif (tmp == 6):
            c = _g.params[0]
            if (c == str):
                self.serializeString(v)
                return
            if (self.useCache and self.serializeRef(v)):
                return
            _g1 = Type.getClassName(c)
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 17):
                if (_g1 == "haxe.ds.ObjectMap"):
                    self.buf.b.write("M")
                    v1 = v
                    k = v1.keys()
                    while k.hasNext():
                        k1 = k.next()
                        self.serialize(k1)
                        self.serialize(v1.h.get(k1,None))
                    self.buf.b.write("h")
                elif (_g1 == "haxe.ds.StringMap"):
                    self.buf.b.write("b")
                    v1 = v
                    k = v1.keys()
                    while k.hasNext():
                        k1 = k.next()
                        self.serializeString(k1)
                        self.serialize(v1.h.get(k1,None))
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this = self.cache
                        if (len(_this) != 0):
                            _this.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 5):
                if (_g1 == "Array"):
                    ucount = 0
                    self.buf.b.write("a")
                    v1 = v
                    l = len(v1)
                    _g1 = 0
                    _g2 = l
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        if ((v1[i] if i >= 0 and i < len(v1) else None) is None):
                            ucount = (ucount + 1)
                        else:
                            if (ucount > 0):
                                if (ucount == 1):
                                    self.buf.b.write("n")
                                else:
                                    self.buf.b.write("u")
                                    _this = self.buf
                                    s = Std.string(ucount)
                                    _this.b.write(s)
                                ucount = 0
                            self.serialize((v1[i] if i >= 0 and i < len(v1) else None))
                    if (ucount > 0):
                        if (ucount == 1):
                            self.buf.b.write("n")
                        else:
                            self.buf.b.write("u")
                            _this = self.buf
                            s = Std.string(ucount)
                            _this.b.write(s)
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this = self.cache
                        if (len(_this) != 0):
                            _this.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 4):
                if (_g1 == "Date"):
                    d = v
                    self.buf.b.write("v")
                    _this = self.buf
                    s = Std.string((d.date.timestamp() * 1000))
                    _this.b.write(s)
                else:
                    if self.useCache:
                        _this = self.cache
                        if (len(_this) != 0):
                            _this.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 12):
                if (_g1 == "haxe.ds.List"):
                    self.buf.b.write("l")
                    v1 = v
                    _g_head = v1.h
                    while (_g_head is not None):
                        val = _g_head.item
                        _g_head = _g_head.next
                        i = val
                        self.serialize(i)
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this = self.cache
                        if (len(_this) != 0):
                            _this.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 13):
                if (_g1 == "haxe.io.Bytes"):
                    v1 = v
                    self.buf.b.write("s")
                    _this = self.buf
                    s = Std.string(Math.ceil(((v1.length * 8) / 6)))
                    _this.b.write(s)
                    self.buf.b.write(":")
                    i = 0
                    _hx_max = (v1.length - 2)
                    b64 = haxe_Serializer.BASE64_CODES
                    if (b64 is None):
                        this1 = [None]*len(haxe_Serializer.BASE64)
                        b64 = this1
                        _g1 = 0
                        _g2 = len(haxe_Serializer.BASE64)
                        while (_g1 < _g2):
                            i1 = _g1
                            _g1 = (_g1 + 1)
                            val = HxString.charCodeAt(haxe_Serializer.BASE64,i1)
                            b64[i1] = val
                        haxe_Serializer.BASE64_CODES = b64
                    while (i < _hx_max):
                        pos = i
                        i = (i + 1)
                        b1 = v1.b[pos]
                        pos1 = i
                        i = (i + 1)
                        b2 = v1.b[pos1]
                        pos2 = i
                        i = (i + 1)
                        b3 = v1.b[pos2]
                        _this = self.buf
                        c1 = b64[(b1 >> 2)]
                        s = "".join(map(chr,[c1]))
                        _this.b.write(s)
                        _this1 = self.buf
                        c2 = b64[((((b1 << 4) | ((b2 >> 4)))) & 63)]
                        s1 = "".join(map(chr,[c2]))
                        _this1.b.write(s1)
                        _this2 = self.buf
                        c3 = b64[((((b2 << 2) | ((b3 >> 6)))) & 63)]
                        s2 = "".join(map(chr,[c3]))
                        _this2.b.write(s2)
                        _this3 = self.buf
                        c4 = b64[(b3 & 63)]
                        s3 = "".join(map(chr,[c4]))
                        _this3.b.write(s3)
                    if (i == _hx_max):
                        pos = i
                        i = (i + 1)
                        b1 = v1.b[pos]
                        pos = i
                        i = (i + 1)
                        b2 = v1.b[pos]
                        _this = self.buf
                        c1 = b64[(b1 >> 2)]
                        s = "".join(map(chr,[c1]))
                        _this.b.write(s)
                        _this = self.buf
                        c1 = b64[((((b1 << 4) | ((b2 >> 4)))) & 63)]
                        s = "".join(map(chr,[c1]))
                        _this.b.write(s)
                        _this = self.buf
                        c1 = b64[((b2 << 2) & 63)]
                        s = "".join(map(chr,[c1]))
                        _this.b.write(s)
                    elif (i == ((_hx_max + 1))):
                        pos = i
                        i = (i + 1)
                        b1 = v1.b[pos]
                        _this = self.buf
                        c1 = b64[(b1 >> 2)]
                        s = "".join(map(chr,[c1]))
                        _this.b.write(s)
                        _this = self.buf
                        c1 = b64[((b1 << 4) & 63)]
                        s = "".join(map(chr,[c1]))
                        _this.b.write(s)
                else:
                    if self.useCache:
                        _this = self.cache
                        if (len(_this) != 0):
                            _this.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 14):
                if (_g1 == "haxe.ds.IntMap"):
                    self.buf.b.write("q")
                    v1 = v
                    k = v1.keys()
                    while k.hasNext():
                        k1 = k.next()
                        self.buf.b.write(":")
                        _this = self.buf
                        s = Std.string(k1)
                        _this.b.write(s)
                        self.serialize(v1.h.get(k1,None))
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this = self.cache
                        if (len(_this) != 0):
                            _this.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this = self.cache
                            _this.append(v)
                        self.serializeFields(v)
            else:
                if self.useCache:
                    _this = self.cache
                    if (len(_this) != 0):
                        _this.pop()
                if python_Boot.hasField(v,"hxSerialize"):
                    self.buf.b.write("C")
                    self.serializeString(Type.getClassName(c))
                    if self.useCache:
                        _this = self.cache
                        _this.append(v)
                    Reflect.field(v,"hxSerialize")(self)
                    self.buf.b.write("g")
                else:
                    self.buf.b.write("c")
                    self.serializeString(Type.getClassName(c))
                    if self.useCache:
                        _this = self.cache
                        _this.append(v)
                    self.serializeFields(v)
        elif (tmp == 7):
            e = _g.params[0]
            if self.useCache:
                if self.serializeRef(v):
                    return
                _this = self.cache
                if (len(_this) != 0):
                    _this.pop()
            _this = self.buf
            s = Std.string(("j" if (self.useEnumIndex) else "w"))
            _this.b.write(s)
            self.serializeString(Type.getEnumName(e))
            if self.useEnumIndex:
                self.buf.b.write(":")
                _this = self.buf
                s = Std.string(v.index)
                _this.b.write(s)
            else:
                self.serializeString(v.tag)
            self.buf.b.write(":")
            arr = list(v.params)
            if (arr is not None):
                _this = self.buf
                s = Std.string(len(arr))
                _this.b.write(s)
                _g = 0
                while (_g < len(arr)):
                    v1 = (arr[_g] if _g >= 0 and _g < len(arr) else None)
                    _g = (_g + 1)
                    self.serialize(v1)
            else:
                self.buf.b.write("0")
            if self.useCache:
                _this = self.cache
                _this.append(v)
        else:
            raise haxe_Exception.thrown(("Cannot serialize " + Std.string(v)))

    @staticmethod
    def run(v):
        s = haxe_Serializer()
        s.serialize(v)
        return s.toString()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.cache = None
        _hx_o.shash = None
        _hx_o.scount = None
        _hx_o.useCache = None
        _hx_o.useEnumIndex = None
haxe_Serializer._hx_class = haxe_Serializer
_hx_classes["haxe.Serializer"] = haxe_Serializer


class haxe_Timer:
    _hx_class_name = "haxe.Timer"
    _hx_is_interface = "False"
    _hx_fields = ["thread", "eventHandler"]
    _hx_methods = ["stop", "run"]
    _hx_statics = ["delay"]

    def __init__(self,time_ms):
        self.eventHandler = None
        self.thread = None
        _gthis = self
        self.thread = sys_thread__Thread_HxThread.current()
        def _hx_local_0():
            _gthis.run()
        self.eventHandler = sys_thread__Thread_Thread_Impl_.get_events(self.thread).repeat(_hx_local_0,time_ms)

    def stop(self):
        sys_thread__Thread_Thread_Impl_.get_events(self.thread).cancel(self.eventHandler)

    def run(self):
        pass

    @staticmethod
    def delay(f,time_ms):
        t = haxe_Timer(time_ms)
        def _hx_local_0():
            t.stop()
            f()
        t.run = _hx_local_0
        return t

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.thread = None
        _hx_o.eventHandler = None
haxe_Timer._hx_class = haxe_Timer
_hx_classes["haxe.Timer"] = haxe_Timer


class haxe__Unserializer_DefaultResolver:
    _hx_class_name = "haxe._Unserializer.DefaultResolver"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["resolveClass", "resolveEnum"]

    def __init__(self):
        pass

    def resolveClass(self,name):
        return Type.resolveClass(name)

    def resolveEnum(self,name):
        return Type.resolveEnum(name)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe__Unserializer_DefaultResolver._hx_class = haxe__Unserializer_DefaultResolver
_hx_classes["haxe._Unserializer.DefaultResolver"] = haxe__Unserializer_DefaultResolver


class haxe_Unserializer:
    _hx_class_name = "haxe.Unserializer"
    _hx_is_interface = "False"
    __slots__ = ("buf", "pos", "length", "cache", "scache", "resolver")
    _hx_fields = ["buf", "pos", "length", "cache", "scache", "resolver"]
    _hx_methods = ["readDigits", "readFloat", "unserializeObject", "unserializeEnum", "unserialize"]
    _hx_statics = ["DEFAULT_RESOLVER", "BASE64", "CODES", "initCodes", "run"]

    def __init__(self,buf):
        self.resolver = None
        self.scache = None
        self.cache = None
        self.length = None
        self.pos = None
        self.buf = buf
        self.length = len(self.buf)
        self.pos = 0
        self.scache = list()
        self.cache = list()
        r = haxe_Unserializer.DEFAULT_RESOLVER
        if (r is None):
            r = haxe__Unserializer_DefaultResolver()
            haxe_Unserializer.DEFAULT_RESOLVER = r
        self.resolver = r

    def readDigits(self):
        k = 0
        s = False
        fpos = self.pos
        while True:
            p = self.pos
            s1 = self.buf
            c = (-1 if ((p >= len(s1))) else ord(s1[p]))
            if (c == -1):
                break
            if (c == 45):
                if (self.pos != fpos):
                    break
                s = True
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                _hx_local_1
                continue
            if ((c < 48) or ((c > 57))):
                break
            k = ((k * 10) + ((c - 48)))
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 1)
            _hx_local_3
        if s:
            k = (k * -1)
        return k

    def readFloat(self):
        p1 = self.pos
        while True:
            p = self.pos
            s = self.buf
            c = (-1 if ((p >= len(s))) else ord(s[p]))
            if (c == -1):
                break
            if ((((c >= 43) and ((c < 58))) or ((c == 101))) or ((c == 69))):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                _hx_local_1
            else:
                break
        return Std.parseFloat(HxString.substr(self.buf,p1,(self.pos - p1)))

    def unserializeObject(self,o):
        while True:
            if (self.pos >= self.length):
                raise haxe_Exception.thrown("Invalid object")
            p = self.pos
            s = self.buf
            if (((-1 if ((p >= len(s))) else ord(s[p]))) == 103):
                break
            k = self.unserialize()
            if (not Std.isOfType(k,str)):
                raise haxe_Exception.thrown("Invalid object key")
            v = self.unserialize()
            field = k
            setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 1)
        _hx_local_1

    def unserializeEnum(self,edecl,tag):
        p = self.pos
        self.pos = (self.pos + 1)
        s = self.buf
        if (((-1 if ((p >= len(s))) else ord(s[p]))) != 58):
            raise haxe_Exception.thrown("Invalid enum format")
        nargs = self.readDigits()
        if (nargs == 0):
            return Type.createEnum(edecl,tag)
        args = list()
        while True:
            tmp = nargs
            nargs = (nargs - 1)
            if (not ((tmp > 0))):
                break
            x = self.unserialize()
            args.append(x)
        return Type.createEnum(edecl,tag,args)

    def unserialize(self):
        p = self.pos
        self.pos = (self.pos + 1)
        s = self.buf
        _g = (-1 if ((p >= len(s))) else ord(s[p]))
        if (_g == 65):
            name = self.unserialize()
            cl = self.resolver.resolveClass(name)
            if (cl is None):
                raise haxe_Exception.thrown(("Class not found " + ("null" if name is None else name)))
            return cl
        elif (_g == 66):
            name = self.unserialize()
            e = self.resolver.resolveEnum(name)
            if (e is None):
                raise haxe_Exception.thrown(("Enum not found " + ("null" if name is None else name)))
            return e
        elif (_g == 67):
            name = self.unserialize()
            cl = self.resolver.resolveClass(name)
            if (cl is None):
                raise haxe_Exception.thrown(("Class not found " + ("null" if name is None else name)))
            o = Type.createEmptyInstance(cl)
            _this = self.cache
            _this.append(o)
            Reflect.field(o,"hxUnserialize")(self)
            p = self.pos
            self.pos = (self.pos + 1)
            s = self.buf
            if (((-1 if ((p >= len(s))) else ord(s[p]))) != 103):
                raise haxe_Exception.thrown("Invalid custom data")
            return o
        elif (_g == 77):
            h = haxe_ds_ObjectMap()
            _this = self.cache
            _this.append(h)
            buf = self.buf
            while True:
                p = self.pos
                s = self.buf
                if (not ((((-1 if ((p >= len(s))) else ord(s[p]))) != 104))):
                    break
                s1 = self.unserialize()
                h.set(s1,self.unserialize())
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 1)
            _hx_local_1
            return h
        elif (_g == 82):
            n = self.readDigits()
            if ((n < 0) or ((n >= len(self.scache)))):
                raise haxe_Exception.thrown("Invalid string reference")
            return (self.scache[n] if n >= 0 and n < len(self.scache) else None)
        elif (_g == 97):
            buf = self.buf
            a = list()
            _this = self.cache
            _this.append(a)
            while True:
                p = self.pos
                s = self.buf
                c = (-1 if ((p >= len(s))) else ord(s[p]))
                if (c == 104):
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2.pos
                    _hx_local_2.pos = (_hx_local_3 + 1)
                    _hx_local_3
                    break
                if (c == 117):
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.pos
                    _hx_local_4.pos = (_hx_local_5 + 1)
                    _hx_local_5
                    n = self.readDigits()
                    python_internal_ArrayImpl._set(a, ((len(a) + n) - 1), None)
                else:
                    x = self.unserialize()
                    a.append(x)
            return a
        elif (_g == 98):
            h = haxe_ds_StringMap()
            _this = self.cache
            _this.append(h)
            buf = self.buf
            while True:
                p = self.pos
                s = self.buf
                if (not ((((-1 if ((p >= len(s))) else ord(s[p]))) != 104))):
                    break
                s1 = self.unserialize()
                value = self.unserialize()
                h.h[s1] = value
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 1)
            _hx_local_7
            return h
        elif (_g == 99):
            name = self.unserialize()
            cl = self.resolver.resolveClass(name)
            if (cl is None):
                raise haxe_Exception.thrown(("Class not found " + ("null" if name is None else name)))
            o = Type.createEmptyInstance(cl)
            _this = self.cache
            _this.append(o)
            self.unserializeObject(o)
            return o
        elif (_g == 100):
            return self.readFloat()
        elif (_g == 102):
            return False
        elif (_g == 105):
            return self.readDigits()
        elif (_g == 106):
            name = self.unserialize()
            edecl = self.resolver.resolveEnum(name)
            if (edecl is None):
                raise haxe_Exception.thrown(("Enum not found " + ("null" if name is None else name)))
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.pos
            _hx_local_8.pos = (_hx_local_9 + 1)
            _hx_local_9
            index = self.readDigits()
            tag = python_internal_ArrayImpl._get(Type.getEnumConstructs(edecl), index)
            if (tag is None):
                raise haxe_Exception.thrown(((("Unknown enum index " + ("null" if name is None else name)) + "@") + Std.string(index)))
            e = self.unserializeEnum(edecl,tag)
            _this = self.cache
            _this.append(e)
            return e
        elif (_g == 107):
            return Math.NaN
        elif (_g == 108):
            l = haxe_ds_List()
            _this = self.cache
            _this.append(l)
            buf = self.buf
            while True:
                p = self.pos
                s = self.buf
                if (not ((((-1 if ((p >= len(s))) else ord(s[p]))) != 104))):
                    break
                l.add(self.unserialize())
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.pos
            _hx_local_10.pos = (_hx_local_11 + 1)
            _hx_local_11
            return l
        elif (_g == 109):
            return Math.NEGATIVE_INFINITY
        elif (_g == 110):
            return None
        elif (_g == 111):
            o = _hx_AnonObject({})
            _this = self.cache
            _this.append(o)
            self.unserializeObject(o)
            return o
        elif (_g == 112):
            return Math.POSITIVE_INFINITY
        elif (_g == 113):
            h = haxe_ds_IntMap()
            _this = self.cache
            _this.append(h)
            buf = self.buf
            p = self.pos
            self.pos = (self.pos + 1)
            s = self.buf
            c = (-1 if ((p >= len(s))) else ord(s[p]))
            while (c == 58):
                i = self.readDigits()
                h.set(i,self.unserialize())
                p = self.pos
                self.pos = (self.pos + 1)
                s = self.buf
                c = (-1 if ((p >= len(s))) else ord(s[p]))
            if (c != 104):
                raise haxe_Exception.thrown("Invalid IntMap format")
            return h
        elif (_g == 114):
            n = self.readDigits()
            if ((n < 0) or ((n >= len(self.cache)))):
                raise haxe_Exception.thrown("Invalid reference")
            return (self.cache[n] if n >= 0 and n < len(self.cache) else None)
        elif (_g == 115):
            _hx_len = self.readDigits()
            buf = self.buf
            p = self.pos
            self.pos = (self.pos + 1)
            s = self.buf
            if ((((-1 if ((p >= len(s))) else ord(s[p]))) != 58) or (((self.length - self.pos) < _hx_len))):
                raise haxe_Exception.thrown("Invalid bytes length")
            codes = haxe_Unserializer.CODES
            if (codes is None):
                codes = haxe_Unserializer.initCodes()
                haxe_Unserializer.CODES = codes
            i = self.pos
            rest = (_hx_len & 3)
            size = ((((_hx_len >> 2)) * 3) + (((rest - 1) if ((rest >= 2)) else 0)))
            _hx_max = (i + ((_hx_len - rest)))
            _hx_bytes = haxe_io_Bytes.alloc(size)
            bpos = 0
            while (i < _hx_max):
                index = i
                i = (i + 1)
                c1 = python_internal_ArrayImpl._get(codes, (-1 if ((index >= len(buf))) else ord(buf[index])))
                index1 = i
                i = (i + 1)
                c2 = python_internal_ArrayImpl._get(codes, (-1 if ((index1 >= len(buf))) else ord(buf[index1])))
                pos = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos] = ((((c1 << 2) | ((c2 >> 4)))) & 255)
                index2 = i
                i = (i + 1)
                c3 = python_internal_ArrayImpl._get(codes, (-1 if ((index2 >= len(buf))) else ord(buf[index2])))
                pos1 = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos1] = ((((c2 << 4) | ((c3 >> 2)))) & 255)
                index3 = i
                i = (i + 1)
                c4 = python_internal_ArrayImpl._get(codes, (-1 if ((index3 >= len(buf))) else ord(buf[index3])))
                pos2 = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos2] = ((((c3 << 6) | c4)) & 255)
            if (rest >= 2):
                index = i
                i = (i + 1)
                c1 = python_internal_ArrayImpl._get(codes, (-1 if ((index >= len(buf))) else ord(buf[index])))
                index = i
                i = (i + 1)
                c2 = python_internal_ArrayImpl._get(codes, (-1 if ((index >= len(buf))) else ord(buf[index])))
                pos = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos] = ((((c1 << 2) | ((c2 >> 4)))) & 255)
                if (rest == 3):
                    index = i
                    i = (i + 1)
                    c3 = python_internal_ArrayImpl._get(codes, (-1 if ((index >= len(buf))) else ord(buf[index])))
                    pos = bpos
                    bpos = (bpos + 1)
                    _hx_bytes.b[pos] = ((((c2 << 4) | ((c3 >> 2)))) & 255)
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + _hx_len)
            _hx_local_12.pos
            _this = self.cache
            _this.append(_hx_bytes)
            return _hx_bytes
        elif (_g == 116):
            return True
        elif (_g == 118):
            d = None
            tmp = None
            tmp1 = None
            tmp2 = None
            tmp3 = None
            tmp4 = None
            tmp5 = None
            tmp6 = None
            tmp7 = None
            p = self.pos
            s = self.buf
            if (((-1 if ((p >= len(s))) else ord(s[p]))) >= 48):
                p = self.pos
                s = self.buf
                tmp7 = (((-1 if ((p >= len(s))) else ord(s[p]))) <= 57)
            else:
                tmp7 = False
            if tmp7:
                p = (self.pos + 1)
                s = self.buf
                tmp6 = (((-1 if ((p >= len(s))) else ord(s[p]))) >= 48)
            else:
                tmp6 = False
            if tmp6:
                p = (self.pos + 1)
                s = self.buf
                tmp5 = (((-1 if ((p >= len(s))) else ord(s[p]))) <= 57)
            else:
                tmp5 = False
            if tmp5:
                p = (self.pos + 2)
                s = self.buf
                tmp4 = (((-1 if ((p >= len(s))) else ord(s[p]))) >= 48)
            else:
                tmp4 = False
            if tmp4:
                p = (self.pos + 2)
                s = self.buf
                tmp3 = (((-1 if ((p >= len(s))) else ord(s[p]))) <= 57)
            else:
                tmp3 = False
            if tmp3:
                p = (self.pos + 3)
                s = self.buf
                tmp2 = (((-1 if ((p >= len(s))) else ord(s[p]))) >= 48)
            else:
                tmp2 = False
            if tmp2:
                p = (self.pos + 3)
                s = self.buf
                tmp1 = (((-1 if ((p >= len(s))) else ord(s[p]))) <= 57)
            else:
                tmp1 = False
            if tmp1:
                p = (self.pos + 4)
                s = self.buf
                tmp = (((-1 if ((p >= len(s))) else ord(s[p]))) == 45)
            else:
                tmp = False
            if tmp:
                d = Date.fromString(HxString.substr(self.buf,self.pos,19))
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.pos
                _hx_local_14.pos = (_hx_local_15 + 19)
                _hx_local_14.pos
            else:
                d = Date.fromTime(self.readFloat())
            _this = self.cache
            _this.append(d)
            return d
        elif (_g == 119):
            name = self.unserialize()
            edecl = self.resolver.resolveEnum(name)
            if (edecl is None):
                raise haxe_Exception.thrown(("Enum not found " + ("null" if name is None else name)))
            e = self.unserializeEnum(edecl,self.unserialize())
            _this = self.cache
            _this.append(e)
            return e
        elif (_g == 120):
            raise haxe_Exception.thrown(self.unserialize())
        elif (_g == 121):
            _hx_len = self.readDigits()
            p = self.pos
            self.pos = (self.pos + 1)
            s = self.buf
            if ((((-1 if ((p >= len(s))) else ord(s[p]))) != 58) or (((self.length - self.pos) < _hx_len))):
                raise haxe_Exception.thrown("Invalid string length")
            s = HxString.substr(self.buf,self.pos,_hx_len)
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.pos
            _hx_local_16.pos = (_hx_local_17 + _hx_len)
            _hx_local_16.pos
            s = python_lib_urllib_Parse.unquote(s)
            _this = self.scache
            _this.append(s)
            return s
        elif (_g == 122):
            return 0
        else:
            pass
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18.pos
        _hx_local_18.pos = (_hx_local_19 - 1)
        _hx_local_19
        s = self.buf
        pos = self.pos
        raise haxe_Exception.thrown(((("Invalid char " + HxOverrides.stringOrNull((("" if (((pos < 0) or ((pos >= len(s))))) else s[pos])))) + " at position ") + Std.string(self.pos)))

    @staticmethod
    def initCodes():
        codes = list()
        _g = 0
        _g1 = len(haxe_Unserializer.BASE64)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            s = haxe_Unserializer.BASE64
            python_internal_ArrayImpl._set(codes, (-1 if ((i >= len(s))) else ord(s[i])), i)
        return codes

    @staticmethod
    def run(v):
        return haxe_Unserializer(v).unserialize()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.pos = None
        _hx_o.length = None
        _hx_o.cache = None
        _hx_o.scache = None
        _hx_o.resolver = None
haxe_Unserializer._hx_class = haxe_Unserializer
_hx_classes["haxe.Unserializer"] = haxe_Unserializer


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(Std.string(value),previous,native)
        self.value = value

    def unwrap(self):
        return self.value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
haxe_ValueException._hx_class = haxe_ValueException
_hx_classes["haxe.ValueException"] = haxe_ValueException


class haxe_crypto_Adler32:
    _hx_class_name = "haxe.crypto.Adler32"
    _hx_is_interface = "False"
    __slots__ = ("a1", "a2")
    _hx_fields = ["a1", "a2"]
    _hx_methods = ["update", "equals"]
    _hx_statics = ["read"]

    def __init__(self):
        self.a1 = 1
        self.a2 = 0

    def update(self,b,pos,_hx_len):
        a1 = self.a1
        a2 = self.a2
        _g = pos
        _g1 = (pos + _hx_len)
        while (_g < _g1):
            p = _g
            _g = (_g + 1)
            c = b.b[p]
            a1 = HxOverrides.mod(((a1 + c)), 65521)
            a2 = HxOverrides.mod(((a2 + a1)), 65521)
        self.a1 = a1
        self.a2 = a2

    def equals(self,a):
        if (a.a1 == self.a1):
            return (a.a2 == self.a2)
        else:
            return False

    @staticmethod
    def read(i):
        a = haxe_crypto_Adler32()
        a2a = i.readByte()
        a2b = i.readByte()
        a1a = i.readByte()
        a1b = i.readByte()
        a.a1 = ((a1a << 8) | a1b)
        a.a2 = ((a2a << 8) | a2b)
        return a

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a1 = None
        _hx_o.a2 = None
haxe_crypto_Adler32._hx_class = haxe_crypto_Adler32
_hx_classes["haxe.crypto.Adler32"] = haxe_crypto_Adler32


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    _hx_is_interface = "False"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["blit", "fill", "sub", "getDouble", "getFloat", "setFloat", "getString", "toString", "toHex"]
    _hx_statics = ["alloc", "ofString", "ofData"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def blit(self,pos,src,srcpos,_hx_len):
        if (((((pos < 0) or ((srcpos < 0))) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))) or (((srcpos + _hx_len) > src.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        self.b[pos:pos+_hx_len] = src.b[srcpos:srcpos+_hx_len]

    def fill(self,pos,_hx_len,value):
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos1 = pos
            pos = (pos + 1)
            self.b[pos1] = (value & 255)

    def sub(self,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return haxe_io_Bytes(_hx_len,self.b[pos:(pos + _hx_len)])

    def getDouble(self,pos):
        v = (((self.b[pos] | ((self.b[(pos + 1)] << 8))) | ((self.b[(pos + 2)] << 16))) | ((self.b[(pos + 3)] << 24)))
        pos1 = (pos + 4)
        v1 = (((self.b[pos1] | ((self.b[(pos1 + 1)] << 8))) | ((self.b[(pos1 + 2)] << 16))) | ((self.b[(pos1 + 3)] << 24)))
        return haxe_io_FPHelper.i64ToDouble(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1))

    def getFloat(self,pos):
        v = (((self.b[pos] | ((self.b[(pos + 1)] << 8))) | ((self.b[(pos + 2)] << 16))) | ((self.b[(pos + 3)] << 24)))
        return haxe_io_FPHelper.i32ToFloat(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v))

    def setFloat(self,pos,v):
        v1 = haxe_io_FPHelper.floatToI32(v)
        self.b[pos] = (v1 & 255)
        self.b[(pos + 1)] = ((v1 >> 8) & 255)
        self.b[(pos + 2)] = ((v1 >> 16) & 255)
        self.b[(pos + 3)] = (HxOverrides.rshift(v1, 24) & 255)

    def getString(self,pos,_hx_len,encoding = None):
        tmp = (encoding is None)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)

    def toHex(self):
        s_b = python_lib_io_StringIO()
        chars = []
        _hx_str = "0123456789abcdef"
        _g = 0
        _g1 = len(_hx_str)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = HxString.charCodeAt(_hx_str,i)
            chars.append(x)
        _g = 0
        _g1 = self.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.b[i]
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c >> 4))])))
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c & 15))])))
        return s_b.getvalue()

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofData(b):
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.length = None
        _hx_o.b = None
haxe_io_Bytes._hx_class = haxe_io_Bytes
_hx_classes["haxe.io.Bytes"] = haxe_io_Bytes


class haxe_crypto_Base64:
    _hx_class_name = "haxe.crypto.Base64"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["CHARS", "BYTES", "encode", "decode"]

    @staticmethod
    def encode(_hx_bytes,complement = None):
        if (complement is None):
            complement = True
        _hx_str = haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(_hx_bytes).toString()
        if complement:
            _g = HxOverrides.mod(_hx_bytes.length, 3)
            if (_g == 1):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "==")
            elif (_g == 2):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "=")
            else:
                pass
        return _hx_str

    @staticmethod
    def decode(_hx_str,complement = None):
        if (complement is None):
            complement = True
        if complement:
            while (HxString.charCodeAt(_hx_str,(len(_hx_str) - 1)) == 61):
                _hx_str = HxString.substr(_hx_str,0,-1)
        return haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(_hx_str))
haxe_crypto_Base64._hx_class = haxe_crypto_Base64
_hx_classes["haxe.crypto.Base64"] = haxe_crypto_Base64


class haxe_crypto_BaseCode:
    _hx_class_name = "haxe.crypto.BaseCode"
    _hx_is_interface = "False"
    __slots__ = ("base", "nbits", "tbl")
    _hx_fields = ["base", "nbits", "tbl"]
    _hx_methods = ["encodeBytes", "initTable", "decodeBytes"]

    def __init__(self,base):
        self.tbl = None
        _hx_len = base.length
        nbits = 1
        while (_hx_len > ((1 << nbits))):
            nbits = (nbits + 1)
        if ((nbits > 8) or ((_hx_len != ((1 << nbits))))):
            raise haxe_Exception.thrown("BaseCode : base length must be a power of two.")
        self.base = base
        self.nbits = nbits

    def encodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        x = ((b.length * 8) / nbits)
        size = None
        try:
            size = int(x)
        except BaseException as _g:
            None
            size = None
        out = haxe_io_Bytes.alloc((size + ((0 if ((HxOverrides.mod((b.length * 8), nbits) == 0)) else 1))))
        buf = 0
        curbits = 0
        mask = (((1 << nbits)) - 1)
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < nbits):
                curbits = (curbits + 8)
                buf = (buf << 8)
                pos = pin
                pin = (pin + 1)
                buf = (buf | b.b[pos])
            curbits = (curbits - nbits)
            pos1 = pout
            pout = (pout + 1)
            v = base.b[((buf >> curbits) & mask)]
            out.b[pos1] = (v & 255)
        if (curbits > 0):
            pos = pout
            pout = (pout + 1)
            v = base.b[((buf << ((nbits - curbits))) & mask)]
            out.b[pos] = (v & 255)
        return out

    def initTable(self):
        tbl = list()
        _g = 0
        while (_g < 256):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(tbl, i, -1)
        _g = 0
        _g1 = self.base.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(tbl, self.base.b[i], i)
        self.tbl = tbl

    def decodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        if (self.tbl is None):
            self.initTable()
        tbl = self.tbl
        size = ((b.length * nbits) >> 3)
        out = haxe_io_Bytes.alloc(size)
        buf = 0
        curbits = 0
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < 8):
                curbits = (curbits + nbits)
                buf = (buf << nbits)
                pos = pin
                pin = (pin + 1)
                i = python_internal_ArrayImpl._get(tbl, b.b[pos])
                if (i == -1):
                    raise haxe_Exception.thrown("BaseCode : invalid encoded char")
                buf = (buf | i)
            curbits = (curbits - 8)
            pos1 = pout
            pout = (pout + 1)
            out.b[pos1] = (((buf >> curbits) & 255) & 255)
        return out

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.base = None
        _hx_o.nbits = None
        _hx_o.tbl = None
haxe_crypto_BaseCode._hx_class = haxe_crypto_BaseCode
_hx_classes["haxe.crypto.BaseCode"] = haxe_crypto_BaseCode


class haxe_crypto_Md5:
    _hx_class_name = "haxe.crypto.Md5"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["bitOR", "bitXOR", "bitAND", "addme", "hex", "rol", "cmn", "ff", "gg", "hh", "ii", "doEncode"]
    _hx_statics = ["encode", "str2blks"]

    def __init__(self):
        pass

    def bitOR(self,a,b):
        lsb = ((a & 1) | ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) | (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def bitXOR(self,a,b):
        lsb = ((a & 1) ^ ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) ^ (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def bitAND(self,a,b):
        lsb = ((a & 1) & ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) & (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def addme(self,x,y):
        lsw = (((x & 65535)) + ((y & 65535)))
        msw = ((((x >> 16)) + ((y >> 16))) + ((lsw >> 16)))
        return ((msw << 16) | ((lsw & 65535)))

    def hex(self,a):
        _hx_str = ""
        hex_chr = "0123456789abcdef"
        _g = 0
        while (_g < len(a)):
            num = (a[_g] if _g >= 0 and _g < len(a) else None)
            _g = (_g + 1)
            index = ((num >> 4) & 15)
            index1 = (num & 15)
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull((("" if (((index < 0) or ((index >= len(hex_chr))))) else hex_chr[index]))) + HxOverrides.stringOrNull((("" if (((index1 < 0) or ((index1 >= len(hex_chr))))) else hex_chr[index1])))))))
            index2 = ((num >> 12) & 15)
            index3 = ((num >> 8) & 15)
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull((("" if (((index2 < 0) or ((index2 >= len(hex_chr))))) else hex_chr[index2]))) + HxOverrides.stringOrNull((("" if (((index3 < 0) or ((index3 >= len(hex_chr))))) else hex_chr[index3])))))))
            index4 = ((num >> 20) & 15)
            index5 = ((num >> 16) & 15)
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull((("" if (((index4 < 0) or ((index4 >= len(hex_chr))))) else hex_chr[index4]))) + HxOverrides.stringOrNull((("" if (((index5 < 0) or ((index5 >= len(hex_chr))))) else hex_chr[index5])))))))
            index6 = ((num >> 28) & 15)
            index7 = ((num >> 24) & 15)
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull((("" if (((index6 < 0) or ((index6 >= len(hex_chr))))) else hex_chr[index6]))) + HxOverrides.stringOrNull((("" if (((index7 < 0) or ((index7 >= len(hex_chr))))) else hex_chr[index7])))))))
        return _hx_str

    def rol(self,num,cnt):
        return ((num << cnt) | (HxOverrides.rshift(num, ((32 - cnt)))))

    def cmn(self,q,a,b,x,s,t):
        return self.addme(self.rol(self.addme(self.addme(a,q),self.addme(x,t)),s),b)

    def ff(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitOR(self.bitAND(b,c),self.bitAND(~b,d)),a,b,x,s,t)

    def gg(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitOR(self.bitAND(b,d),self.bitAND(c,~d)),a,b,x,s,t)

    def hh(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitXOR(self.bitXOR(b,c),d),a,b,x,s,t)

    def ii(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitXOR(c,self.bitOR(b,~d)),a,b,x,s,t)

    def doEncode(self,x):
        a = 1732584193
        b = -271733879
        c = -1732584194
        d = 271733878
        step = None
        i = 0
        while (i < len(x)):
            olda = a
            oldb = b
            oldc = c
            oldd = d
            step = 0
            a = self.ff(a,b,c,d,(x[i] if i >= 0 and i < len(x) else None),7,-680876936)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 1)),12,-389564586)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 2)),17,606105819)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 3)),22,-1044525330)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 4)),7,-176418897)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 5)),12,1200080426)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 6)),17,-1473231341)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 7)),22,-45705983)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 8)),7,1770035416)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 9)),12,-1958414417)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 10)),17,-42063)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 11)),22,-1990404162)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 12)),7,1804603682)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 13)),12,-40341101)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 14)),17,-1502002290)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 15)),22,1236535329)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 1)),5,-165796510)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 6)),9,-1069501632)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 11)),14,643717713)
            b = self.gg(b,c,d,a,(x[i] if i >= 0 and i < len(x) else None),20,-373897302)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 5)),5,-701558691)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 10)),9,38016083)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 15)),14,-660478335)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 4)),20,-405537848)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 9)),5,568446438)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 14)),9,-1019803690)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 3)),14,-187363961)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 8)),20,1163531501)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 13)),5,-1444681467)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 2)),9,-51403784)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 7)),14,1735328473)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 12)),20,-1926607734)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 5)),4,-378558)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 8)),11,-2022574463)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 11)),16,1839030562)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 14)),23,-35309556)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 1)),4,-1530992060)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 4)),11,1272893353)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 7)),16,-155497632)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 10)),23,-1094730640)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 13)),4,681279174)
            d = self.hh(d,a,b,c,(x[i] if i >= 0 and i < len(x) else None),11,-358537222)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 3)),16,-722521979)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 6)),23,76029189)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 9)),4,-640364487)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 12)),11,-421815835)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 15)),16,530742520)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 2)),23,-995338651)
            a = self.ii(a,b,c,d,(x[i] if i >= 0 and i < len(x) else None),6,-198630844)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 7)),10,1126891415)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 14)),15,-1416354905)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 5)),21,-57434055)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 12)),6,1700485571)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 3)),10,-1894986606)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 10)),15,-1051523)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 1)),21,-2054922799)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 8)),6,1873313359)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 15)),10,-30611744)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 6)),15,-1560198380)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 13)),21,1309151649)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 4)),6,-145523070)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 11)),10,-1120210379)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 2)),15,718787259)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 9)),21,-343485551)
            a = self.addme(a,olda)
            b = self.addme(b,oldb)
            c = self.addme(c,oldc)
            d = self.addme(d,oldd)
            i = (i + 16)
        return [a, b, c, d]

    @staticmethod
    def encode(s):
        m = haxe_crypto_Md5()
        h = m.doEncode(haxe_crypto_Md5.str2blks(s))
        return m.hex(h)

    @staticmethod
    def str2blks(_hx_str):
        str1 = haxe_io_Bytes.ofString(_hx_str)
        nblk = ((((str1.length + 8) >> 6)) + 1)
        blks = list()
        blksSize = (nblk * 16)
        _g = 0
        _g1 = blksSize
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(blks, i, 0)
        i = 0
        _hx_max = str1.length
        l = (_hx_max * 8)
        while (i < _hx_max):
            _hx_local_0 = blks
            _hx_local_1 = (i >> 2)
            _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 | ((str1.b[i] << ((HxOverrides.mod(((l + i)), 4) * 8))))))
            (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            i = (i + 1)
        _hx_local_4 = blks
        _hx_local_5 = (i >> 2)
        _hx_local_6 = (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        python_internal_ArrayImpl._set(_hx_local_4, _hx_local_5, (_hx_local_6 | ((128 << ((HxOverrides.mod(((l + i)), 4) * 8))))))
        (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        k = ((nblk * 16) - 2)
        python_internal_ArrayImpl._set(blks, k, (l & 255))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 8) & 255)) << 8))))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 16) & 255)) << 16))))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 24) & 255)) << 24))))
        return blks

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_crypto_Md5._hx_class = haxe_crypto_Md5
_hx_classes["haxe.crypto.Md5"] = haxe_crypto_Md5


class haxe_crypto_Sha1:
    _hx_class_name = "haxe.crypto.Sha1"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["doEncode", "ft", "kt"]
    _hx_statics = ["make", "bytes2blks"]

    def __init__(self):
        pass

    def doEncode(self,x):
        w = list()
        a = 1732584193
        b = -271733879
        c = -1732584194
        d = 271733878
        e = -1009589776
        i = 0
        while (i < len(x)):
            olda = a
            oldb = b
            oldc = c
            oldd = d
            olde = e
            j = 0
            while (j < 80):
                if (j < 16):
                    python_internal_ArrayImpl._set(w, j, python_internal_ArrayImpl._get(x, (i + j)))
                else:
                    num = (((python_internal_ArrayImpl._get(w, (j - 3)) ^ python_internal_ArrayImpl._get(w, (j - 8))) ^ python_internal_ArrayImpl._get(w, (j - 14))) ^ python_internal_ArrayImpl._get(w, (j - 16)))
                    python_internal_ArrayImpl._set(w, j, ((num << 1) | (HxOverrides.rshift(num, 31))))
                t = (((((((a << 5) | (HxOverrides.rshift(a, 27)))) + self.ft(j,b,c,d)) + e) + (w[j] if j >= 0 and j < len(w) else None)) + self.kt(j))
                e = d
                d = c
                c = ((b << 30) | (HxOverrides.rshift(b, 2)))
                b = a
                a = t
                j = (j + 1)
            a = (a + olda)
            b = (b + oldb)
            c = (c + oldc)
            d = (d + oldd)
            e = (e + olde)
            i = (i + 16)
        return [a, b, c, d, e]

    def ft(self,t,b,c,d):
        if (t < 20):
            return ((b & c) | ((~b & d)))
        if (t < 40):
            return ((b ^ c) ^ d)
        if (t < 60):
            return (((b & c) | ((b & d))) | ((c & d)))
        return ((b ^ c) ^ d)

    def kt(self,t):
        if (t < 20):
            return 1518500249
        if (t < 40):
            return 1859775393
        if (t < 60):
            return -1894007588
        return -899497514

    @staticmethod
    def make(b):
        h = haxe_crypto_Sha1().doEncode(haxe_crypto_Sha1.bytes2blks(b))
        out = haxe_io_Bytes.alloc(20)
        p = 0
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[0] if 0 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[0] if 0 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[1] if 1 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[1] if 1 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[2] if 2 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[2] if 2 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[3] if 3 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[3] if 3 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[4] if 4 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[4] if 4 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[4] if 4 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[4] if 4 < len(h) else None) & 255) & 255)
        return out

    @staticmethod
    def bytes2blks(b):
        nblk = ((((b.length + 8) >> 6)) + 1)
        blks = list()
        _g = 0
        _g1 = (nblk * 16)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(blks, i, 0)
        _g = 0
        _g1 = b.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p = (i >> 2)
            python_internal_ArrayImpl._set(blks, p, ((blks[p] if p >= 0 and p < len(blks) else None) | ((b.b[i] << ((24 - ((((i & 3)) << 3))))))))
        i = b.length
        p = (i >> 2)
        python_internal_ArrayImpl._set(blks, p, ((blks[p] if p >= 0 and p < len(blks) else None) | ((128 << ((24 - ((((i & 3)) << 3))))))))
        python_internal_ArrayImpl._set(blks, ((nblk * 16) - 1), (b.length * 8))
        return blks

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_crypto_Sha1._hx_class = haxe_crypto_Sha1
_hx_classes["haxe.crypto.Sha1"] = haxe_crypto_Sha1


class haxe_ds_ArraySort:
    _hx_class_name = "haxe.ds.ArraySort"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["sort", "rec", "doMerge", "rotate", "gcd", "upper", "lower", "swap"]

    @staticmethod
    def sort(a,cmp):
        haxe_ds_ArraySort.rec(a,cmp,0,len(a))

    @staticmethod
    def rec(a,cmp,_hx_from,to):
        middle = ((_hx_from + to) >> 1)
        if ((to - _hx_from) < 12):
            if (to <= _hx_from):
                return
            _g = (_hx_from + 1)
            _g1 = to
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                j = i
                while (j > _hx_from):
                    if (cmp((a[j] if j >= 0 and j < len(a) else None),python_internal_ArrayImpl._get(a, (j - 1))) < 0):
                        haxe_ds_ArraySort.swap(a,(j - 1),j)
                    else:
                        break
                    j = (j - 1)
            return
        haxe_ds_ArraySort.rec(a,cmp,_hx_from,middle)
        haxe_ds_ArraySort.rec(a,cmp,middle,to)
        haxe_ds_ArraySort.doMerge(a,cmp,_hx_from,middle,to,(middle - _hx_from),(to - middle))

    @staticmethod
    def doMerge(a,cmp,_hx_from,pivot,to,len1,len2):
        first_cut = None
        second_cut = None
        len11 = None
        len22 = None
        if ((len1 == 0) or ((len2 == 0))):
            return
        if ((len1 + len2) == 2):
            if (cmp((a[pivot] if pivot >= 0 and pivot < len(a) else None),(a[_hx_from] if _hx_from >= 0 and _hx_from < len(a) else None)) < 0):
                haxe_ds_ArraySort.swap(a,pivot,_hx_from)
            return
        if (len1 > len2):
            len11 = (len1 >> 1)
            first_cut = (_hx_from + len11)
            second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut)
            len22 = (second_cut - pivot)
        else:
            len22 = (len2 >> 1)
            second_cut = (pivot + len22)
            first_cut = haxe_ds_ArraySort.upper(a,cmp,_hx_from,pivot,second_cut)
            len11 = (first_cut - _hx_from)
        haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut)
        new_mid = (first_cut + len22)
        haxe_ds_ArraySort.doMerge(a,cmp,_hx_from,first_cut,new_mid,len11,len22)
        haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,(len1 - len11),(len2 - len22))

    @staticmethod
    def rotate(a,cmp,_hx_from,mid,to):
        if ((_hx_from == mid) or ((mid == to))):
            return
        n = haxe_ds_ArraySort.gcd((to - _hx_from),(mid - _hx_from))
        while True:
            tmp = n
            n = (n - 1)
            if (not ((tmp != 0))):
                break
            val = python_internal_ArrayImpl._get(a, (_hx_from + n))
            shift = (mid - _hx_from)
            p1 = (_hx_from + n)
            p2 = ((_hx_from + n) + shift)
            while (p2 != ((_hx_from + n))):
                python_internal_ArrayImpl._set(a, p1, (a[p2] if p2 >= 0 and p2 < len(a) else None))
                p1 = p2
                if ((to - p2) > shift):
                    p2 = (p2 + shift)
                else:
                    p2 = (_hx_from + ((shift - ((to - p2)))))
            python_internal_ArrayImpl._set(a, p1, val)

    @staticmethod
    def gcd(m,n):
        while (n != 0):
            t = HxOverrides.mod(m, n)
            m = n
            n = t
        return m

    @staticmethod
    def upper(a,cmp,_hx_from,to,val):
        _hx_len = (to - _hx_from)
        half = None
        mid = None
        while (_hx_len > 0):
            half = (_hx_len >> 1)
            mid = (_hx_from + half)
            if (cmp((a[val] if val >= 0 and val < len(a) else None),(a[mid] if mid >= 0 and mid < len(a) else None)) < 0):
                _hx_len = half
            else:
                _hx_from = (mid + 1)
                _hx_len = ((_hx_len - half) - 1)
        return _hx_from

    @staticmethod
    def lower(a,cmp,_hx_from,to,val):
        _hx_len = (to - _hx_from)
        half = None
        mid = None
        while (_hx_len > 0):
            half = (_hx_len >> 1)
            mid = (_hx_from + half)
            if (cmp((a[mid] if mid >= 0 and mid < len(a) else None),(a[val] if val >= 0 and val < len(a) else None)) < 0):
                _hx_from = (mid + 1)
                _hx_len = ((_hx_len - half) - 1)
            else:
                _hx_len = half
        return _hx_from

    @staticmethod
    def swap(a,i,j):
        tmp = (a[i] if i >= 0 and i < len(a) else None)
        python_internal_ArrayImpl._set(a, i, (a[j] if j >= 0 and j < len(a) else None))
        python_internal_ArrayImpl._set(a, j, tmp)
haxe_ds_ArraySort._hx_class = haxe_ds_ArraySort
_hx_classes["haxe.ds.ArraySort"] = haxe_ds_ArraySort


class haxe_ds_BalancedTree:
    _hx_class_name = "haxe.ds.BalancedTree"
    _hx_is_interface = "False"
    __slots__ = ("root",)
    _hx_fields = ["root"]
    _hx_methods = ["set", "get", "setLoop", "balance", "compare"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.root = None

    def set(self,key,value):
        self.root = self.setLoop(key,value,self.root)

    def get(self,key):
        node = self.root
        while (node is not None):
            c = self.compare(key,node.key)
            if (c == 0):
                return node.value
            if (c < 0):
                node = node.left
            else:
                node = node.right
        return None

    def setLoop(self,k,v,node):
        if (node is None):
            return haxe_ds_TreeNode(None,k,v,None)
        c = self.compare(k,node.key)
        if (c == 0):
            return haxe_ds_TreeNode(node.left,k,v,node.right,(0 if ((node is None)) else node._height))
        elif (c < 0):
            nl = self.setLoop(k,v,node.left)
            return self.balance(nl,node.key,node.value,node.right)
        else:
            nr = self.setLoop(k,v,node.right)
            return self.balance(node.left,node.key,node.value,nr)

    def balance(self,l,k,v,r):
        hl = (0 if ((l is None)) else l._height)
        hr = (0 if ((r is None)) else r._height)
        if (hl > ((hr + 2))):
            _this = l.left
            _this1 = l.right
            if (((0 if ((_this is None)) else _this._height)) >= ((0 if ((_this1 is None)) else _this1._height))):
                return haxe_ds_TreeNode(l.left,l.key,l.value,haxe_ds_TreeNode(l.right,k,v,r))
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,haxe_ds_TreeNode(l.right.right,k,v,r))
        elif (hr > ((hl + 2))):
            _this = r.right
            _this1 = r.left
            if (((0 if ((_this is None)) else _this._height)) > ((0 if ((_this1 is None)) else _this1._height))):
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right)
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right))
        else:
            return haxe_ds_TreeNode(l,k,v,r,(((hl if ((hl > hr)) else hr)) + 1))

    def compare(self,k1,k2):
        return Reflect.compare(k1,k2)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
haxe_ds_BalancedTree._hx_class = haxe_ds_BalancedTree
_hx_classes["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree


class haxe_ds_TreeNode:
    _hx_class_name = "haxe.ds.TreeNode"
    _hx_is_interface = "False"
    __slots__ = ("left", "right", "key", "value", "_height")
    _hx_fields = ["left", "right", "key", "value", "_height"]

    def __init__(self,l,k,v,r,h = None):
        if (h is None):
            h = -1
        self._height = None
        self.left = l
        self.key = k
        self.value = v
        self.right = r
        if (h == -1):
            tmp = None
            _this = self.left
            _this1 = self.right
            if (((0 if ((_this is None)) else _this._height)) > ((0 if ((_this1 is None)) else _this1._height))):
                _this = self.left
                tmp = (0 if ((_this is None)) else _this._height)
            else:
                _this = self.right
                tmp = (0 if ((_this is None)) else _this._height)
            self._height = (tmp + 1)
        else:
            self._height = h

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.left = None
        _hx_o.right = None
        _hx_o.key = None
        _hx_o.value = None
        _hx_o._height = None
haxe_ds_TreeNode._hx_class = haxe_ds_TreeNode
_hx_classes["haxe.ds.TreeNode"] = haxe_ds_TreeNode


class haxe_ds_EnumValueMap(haxe_ds_BalancedTree):
    _hx_class_name = "haxe.ds.EnumValueMap"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compare", "compareArgs", "compareArg"]
    _hx_statics = []
    _hx_interfaces = [haxe_IMap]
    _hx_super = haxe_ds_BalancedTree


    def __init__(self):
        super().__init__()

    def compare(self,k1,k2):
        d = (k1.index - k2.index)
        if (d != 0):
            return d
        p1 = list(k1.params)
        p2 = list(k2.params)
        if ((len(p1) == 0) and ((len(p2) == 0))):
            return 0
        return self.compareArgs(p1,p2)

    def compareArgs(self,a1,a2):
        ld = (len(a1) - len(a2))
        if (ld != 0):
            return ld
        _g = 0
        _g1 = len(a1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            d = self.compareArg((a1[i] if i >= 0 and i < len(a1) else None),(a2[i] if i >= 0 and i < len(a2) else None))
            if (d != 0):
                return d
        return 0

    def compareArg(self,v1,v2):
        if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)):
            return self.compare(v1,v2)
        elif (Std.isOfType(v1,list) and Std.isOfType(v2,list)):
            return self.compareArgs(v1,v2)
        else:
            return Reflect.compare(v1,v2)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_ds_EnumValueMap._hx_class = haxe_ds_EnumValueMap
_hx_classes["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "remove", "keys", "iterator"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def remove(self,key):
        if (not (key in self.h)):
            return False
        del self.h[key]
        return True

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_IntMap._hx_class = haxe_ds_IntMap
_hx_classes["haxe.ds.IntMap"] = haxe_ds_IntMap


class haxe_ds_List:
    _hx_class_name = "haxe.ds.List"
    _hx_is_interface = "False"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["add", "push", "remove"]

    def __init__(self):
        self.q = None
        self.h = None
        self.length = 0

    def add(self,item):
        x = haxe_ds__List_ListNode(item,None)
        if (self.h is None):
            self.h = x
        else:
            self.q.next = x
        self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def push(self,item):
        x = haxe_ds__List_ListNode(item,self.h)
        self.h = x
        if (self.q is None):
            self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def remove(self,v):
        prev = None
        l = self.h
        while (l is not None):
            if HxOverrides.eq(l.item,v):
                if (prev is None):
                    self.h = l.next
                else:
                    prev.next = l.next
                if (self.q == l):
                    self.q = prev
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.length
                _hx_local_0.length = (_hx_local_1 - 1)
                _hx_local_1
                return True
            prev = l
            l = l.next
        return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
        _hx_o.q = None
        _hx_o.length = None
haxe_ds_List._hx_class = haxe_ds_List
_hx_classes["haxe.ds.List"] = haxe_ds_List


class haxe_ds__List_ListNode:
    _hx_class_name = "haxe.ds._List.ListNode"
    _hx_is_interface = "False"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        self.item = item
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.item = None
        _hx_o.next = None
haxe_ds__List_ListNode._hx_class = haxe_ds__List_ListNode
_hx_classes["haxe.ds._List.ListNode"] = haxe_ds__List_ListNode


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["remove", "keys", "iterator"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def remove(self,key):
        has = (key in self.h)
        if has:
            del self.h[key]
        return has

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_StringMap._hx_class = haxe_ds_StringMap
_hx_classes["haxe.ds.StringMap"] = haxe_ds_StringMap


class haxe_ds__Vector_Vector_Impl_:
    _hx_class_name = "haxe.ds._Vector.Vector_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["blit"]

    @staticmethod
    def blit(src,srcPos,dest,destPos,_hx_len):
        if (src is dest):
            if (srcPos < destPos):
                i = (srcPos + _hx_len)
                j = (destPos + _hx_len)
                _g = 0
                _g1 = _hx_len
                while (_g < _g1):
                    k = _g
                    _g = (_g + 1)
                    i = (i - 1)
                    j = (j - 1)
                    val = src[i]
                    src[j] = val
            elif (srcPos > destPos):
                i = srcPos
                j = destPos
                _g = 0
                _g1 = _hx_len
                while (_g < _g1):
                    k = _g
                    _g = (_g + 1)
                    val = src[i]
                    src[j] = val
                    i = (i + 1)
                    j = (j + 1)
        else:
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                val = src[(srcPos + i)]
                dest[(destPos + i)] = val
haxe_ds__Vector_Vector_Impl_._hx_class = haxe_ds__Vector_Vector_Impl_
_hx_classes["haxe.ds._Vector.Vector_Impl_"] = haxe_ds__Vector_Vector_Impl_


class haxe_exceptions_PosException(haxe_Exception):
    _hx_class_name = "haxe.exceptions.PosException"
    _hx_is_interface = "False"
    __slots__ = ("posInfos",)
    _hx_fields = ["posInfos"]
    _hx_methods = ["toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,message,previous = None,pos = None):
        self.posInfos = None
        super().__init__(message,previous)
        if (pos is None):
            self.posInfos = _hx_AnonObject({'fileName': "(unknown)", 'lineNumber': 0, 'className': "(unknown)", 'methodName': "(unknown)"})
        else:
            self.posInfos = pos

    def toString(self):
        return ((((((((("" + HxOverrides.stringOrNull(super().toString())) + " in ") + HxOverrides.stringOrNull(self.posInfos.className)) + ".") + HxOverrides.stringOrNull(self.posInfos.methodName)) + " at ") + HxOverrides.stringOrNull(self.posInfos.fileName)) + ":") + Std.string(self.posInfos.lineNumber))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.posInfos = None
haxe_exceptions_PosException._hx_class = haxe_exceptions_PosException
_hx_classes["haxe.exceptions.PosException"] = haxe_exceptions_PosException


class haxe_exceptions_NotImplementedException(haxe_exceptions_PosException):
    _hx_class_name = "haxe.exceptions.NotImplementedException"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_exceptions_PosException


    def __init__(self,message = None,previous = None,pos = None):
        if (message is None):
            message = "Not implemented"
        super().__init__(message,previous,pos)
haxe_exceptions_NotImplementedException._hx_class = haxe_exceptions_NotImplementedException
_hx_classes["haxe.exceptions.NotImplementedException"] = haxe_exceptions_NotImplementedException


class haxe_format_JsonPrinter:
    _hx_class_name = "haxe.format.JsonPrinter"
    _hx_is_interface = "False"
    __slots__ = ("buf", "replacer", "indent", "pretty", "nind")
    _hx_fields = ["buf", "replacer", "indent", "pretty", "nind"]
    _hx_methods = ["write", "classString", "fieldsString", "quote"]
    _hx_statics = ["print"]

    def __init__(self,replacer,space):
        self.replacer = replacer
        self.indent = space
        self.pretty = (space is not None)
        self.nind = 0
        self.buf = StringBuf()

    def write(self,k,v):
        if (self.replacer is not None):
            v = self.replacer(k,v)
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 0):
            self.buf.b.write("null")
        elif (tmp == 1):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 2):
            f = v
            v1 = (Std.string(v) if ((((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))) else "null")
            _this = self.buf
            s = Std.string(v1)
            _this.b.write(s)
        elif (tmp == 3):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 4):
            self.fieldsString(v,python_Boot.fields(v))
        elif (tmp == 5):
            self.buf.b.write("\"<fun>\"")
        elif (tmp == 6):
            c = _g.params[0]
            if (c == str):
                self.quote(v)
            elif (c == list):
                v1 = v
                _this = self.buf
                s = "".join(map(chr,[91]))
                _this.b.write(s)
                _hx_len = len(v1)
                last = (_hx_len - 1)
                _g1 = 0
                _g2 = _hx_len
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    if (i > 0):
                        _this = self.buf
                        s = "".join(map(chr,[44]))
                        _this.b.write(s)
                    else:
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.nind
                        _hx_local_0.nind = (_hx_local_1 + 1)
                        _hx_local_1
                    if self.pretty:
                        _this1 = self.buf
                        s1 = "".join(map(chr,[10]))
                        _this1.b.write(s1)
                    if self.pretty:
                        v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                        _this2 = self.buf
                        s2 = Std.string(v2)
                        _this2.b.write(s2)
                    self.write(i,(v1[i] if i >= 0 and i < len(v1) else None))
                    if (i == last):
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.nind
                        _hx_local_2.nind = (_hx_local_3 - 1)
                        _hx_local_3
                        if self.pretty:
                            _this3 = self.buf
                            s3 = "".join(map(chr,[10]))
                            _this3.b.write(s3)
                        if self.pretty:
                            v3 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                            _this4 = self.buf
                            s4 = Std.string(v3)
                            _this4.b.write(s4)
                _this = self.buf
                s = "".join(map(chr,[93]))
                _this.b.write(s)
            elif (c == haxe_ds_StringMap):
                v1 = v
                o = _hx_AnonObject({})
                k = v1.keys()
                while k.hasNext():
                    k1 = k.next()
                    value = v1.h.get(k1,None)
                    setattr(o,(("_hx_" + k1) if ((k1 in python_Boot.keywords)) else (("_hx_" + k1) if (((((len(k1) > 2) and ((ord(k1[0]) == 95))) and ((ord(k1[1]) == 95))) and ((ord(k1[(len(k1) - 1)]) != 95)))) else k1)),value)
                v1 = o
                self.fieldsString(v1,python_Boot.fields(v1))
            elif (c == Date):
                v1 = v
                self.quote(v1.toString())
            else:
                self.classString(v)
        elif (tmp == 7):
            _g1 = _g.params[0]
            i = v.index
            _this = self.buf
            s = Std.string(i)
            _this.b.write(s)
        elif (tmp == 8):
            self.buf.b.write("\"???\"")
        else:
            pass

    def classString(self,v):
        self.fieldsString(v,python_Boot.getInstanceFields(Type.getClass(v)))

    def fieldsString(self,v,fields):
        _this = self.buf
        s = "".join(map(chr,[123]))
        _this.b.write(s)
        _hx_len = len(fields)
        last = (_hx_len - 1)
        first = True
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            f = (fields[i] if i >= 0 and i < len(fields) else None)
            value = Reflect.field(v,f)
            if Reflect.isFunction(value):
                continue
            if first:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nind
                _hx_local_0.nind = (_hx_local_1 + 1)
                _hx_local_1
                first = False
            else:
                _this = self.buf
                s = "".join(map(chr,[44]))
                _this.b.write(s)
            if self.pretty:
                _this1 = self.buf
                s1 = "".join(map(chr,[10]))
                _this1.b.write(s1)
            if self.pretty:
                v1 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                _this2 = self.buf
                s2 = Std.string(v1)
                _this2.b.write(s2)
            self.quote(f)
            _this3 = self.buf
            s3 = "".join(map(chr,[58]))
            _this3.b.write(s3)
            if self.pretty:
                _this4 = self.buf
                s4 = "".join(map(chr,[32]))
                _this4.b.write(s4)
            self.write(f,value)
            if (i == last):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.nind
                _hx_local_2.nind = (_hx_local_3 - 1)
                _hx_local_3
                if self.pretty:
                    _this5 = self.buf
                    s5 = "".join(map(chr,[10]))
                    _this5.b.write(s5)
                if self.pretty:
                    v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                    _this6 = self.buf
                    s6 = Std.string(v2)
                    _this6.b.write(s6)
        _this = self.buf
        s = "".join(map(chr,[125]))
        _this.b.write(s)

    def quote(self,s):
        _this = self.buf
        s1 = "".join(map(chr,[34]))
        _this.b.write(s1)
        i = 0
        length = len(s)
        while (i < length):
            index = i
            i = (i + 1)
            c = ord(s[index])
            c1 = c
            if (c1 == 8):
                self.buf.b.write("\\b")
            elif (c1 == 9):
                self.buf.b.write("\\t")
            elif (c1 == 10):
                self.buf.b.write("\\n")
            elif (c1 == 12):
                self.buf.b.write("\\f")
            elif (c1 == 13):
                self.buf.b.write("\\r")
            elif (c1 == 34):
                self.buf.b.write("\\\"")
            elif (c1 == 92):
                self.buf.b.write("\\\\")
            else:
                _this = self.buf
                s1 = "".join(map(chr,[c]))
                _this.b.write(s1)
        _this = self.buf
        s = "".join(map(chr,[34]))
        _this.b.write(s)

    @staticmethod
    def print(o,replacer = None,space = None):
        printer = haxe_format_JsonPrinter(replacer,space)
        printer.write("",o)
        return printer.buf.b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.replacer = None
        _hx_o.indent = None
        _hx_o.pretty = None
        _hx_o.nind = None
haxe_format_JsonPrinter._hx_class = haxe_format_JsonPrinter
_hx_classes["haxe.format.JsonPrinter"] = haxe_format_JsonPrinter


class haxe_io_ArrayBufferViewImpl:
    _hx_class_name = "haxe.io.ArrayBufferViewImpl"
    _hx_is_interface = "False"
    __slots__ = ("bytes", "byteOffset", "byteLength")
    _hx_fields = ["bytes", "byteOffset", "byteLength"]

    def __init__(self,_hx_bytes,pos,length):
        self.bytes = _hx_bytes
        self.byteOffset = pos
        self.byteLength = length

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bytes = None
        _hx_o.byteOffset = None
        _hx_o.byteLength = None
haxe_io_ArrayBufferViewImpl._hx_class = haxe_io_ArrayBufferViewImpl
_hx_classes["haxe.io.ArrayBufferViewImpl"] = haxe_io_ArrayBufferViewImpl


class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["addInt32", "addInt64", "getBytes"]

    def __init__(self):
        self.b = bytearray()

    def addInt32(self,v):
        self.b.append((v & 255))
        self.b.append(((v >> 8) & 255))
        self.b.append(((v >> 16) & 255))
        self.b.append(HxOverrides.rshift(v, 24))

    def addInt64(self,v):
        self.addInt32(v.low)
        self.addInt32(v.high)

    def getBytes(self):
        _hx_bytes = haxe_io_Bytes(len(self.b),self.b)
        self.b = None
        return _hx_bytes

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
haxe_io_BytesBuffer._hx_class = haxe_io_BytesBuffer
_hx_classes["haxe.io.BytesBuffer"] = haxe_io_BytesBuffer


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    _hx_is_interface = "False"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["readByte", "readBytes", "set_bigEndian", "readFullBytes", "read", "readUntil", "readLine", "readFloat", "readDouble", "readInt16", "readUInt16", "readUInt24", "readInt32", "readString"]

    def readByte(self):
        raise haxe_exceptions_NotImplementedException(None,None,_hx_AnonObject({'fileName': "haxe/io/Input.hx", 'lineNumber': 53, 'className': "haxe.io.Input", 'methodName': "readByte"}))

    def readBytes(self,s,pos,_hx_len):
        k = _hx_len
        b = s.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        try:
            while (k > 0):
                b[pos] = self.readByte()
                pos = (pos + 1)
                k = (k - 1)
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return (_hx_len - k)

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def readFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.readBytes(s,pos,_hx_len)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def read(self,nbytes):
        s = haxe_io_Bytes.alloc(nbytes)
        p = 0
        while (nbytes > 0):
            k = self.readBytes(s,p,nbytes)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            p = (p + k)
            nbytes = (nbytes - k)
        return s

    def readUntil(self,end):
        buf = haxe_io_BytesBuffer()
        last = None
        while True:
            last = self.readByte()
            if (not ((last != end))):
                break
            buf.b.append(last)
        return buf.getBytes().toString()

    def readLine(self):
        buf = haxe_io_BytesBuffer()
        last = None
        s = None
        try:
            while True:
                last = self.readByte()
                if (not ((last != 10))):
                    break
                buf.b.append(last)
            s = buf.getBytes().toString()
            if (HxString.charCodeAt(s,(len(s) - 1)) == 13):
                s = HxString.substr(s,0,-1)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,haxe_io_Eof):
                e = _g1
                s = buf.getBytes().toString()
                if (len(s) == 0):
                    raise haxe_Exception.thrown(e)
            else:
                raise _g
        return s

    def readFloat(self):
        return haxe_io_FPHelper.i32ToFloat(self.readInt32())

    def readDouble(self):
        i1 = self.readInt32()
        i2 = self.readInt32()
        if self.bigEndian:
            return haxe_io_FPHelper.i64ToDouble(i2,i1)
        else:
            return haxe_io_FPHelper.i64ToDouble(i1,i2)

    def readInt16(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        n = ((ch2 | ((ch1 << 8))) if (self.bigEndian) else (ch1 | ((ch2 << 8))))
        if (((n & 32768)) != 0):
            return (n - 65536)
        return n

    def readUInt16(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        if self.bigEndian:
            return (ch2 | ((ch1 << 8)))
        else:
            return (ch1 | ((ch2 << 8)))

    def readUInt24(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        ch3 = self.readByte()
        if self.bigEndian:
            return ((ch3 | ((ch2 << 8))) | ((ch1 << 16)))
        else:
            return ((ch1 | ((ch2 << 8))) | ((ch3 << 16)))

    def readInt32(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        ch3 = self.readByte()
        ch4 = self.readByte()
        n = ((((ch4 | ((ch3 << 8))) | ((ch2 << 16))) | ((ch1 << 24))) if (self.bigEndian) else (((ch1 | ((ch2 << 8))) | ((ch3 << 16))) | ((ch4 << 24))))
        if (((n & -2147483648)) != 0):
            return (n | -2147483648)
        else:
            return n

    def readString(self,_hx_len,encoding = None):
        b = haxe_io_Bytes.alloc(_hx_len)
        self.readFullBytes(b,0,_hx_len)
        return b.getString(0,_hx_len,encoding)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None
haxe_io_Input._hx_class = haxe_io_Input
_hx_classes["haxe.io.Input"] = haxe_io_Input


class haxe_io_BytesInput(haxe_io_Input):
    _hx_class_name = "haxe.io.BytesInput"
    _hx_is_interface = "False"
    __slots__ = ("b", "pos", "len", "totlen")
    _hx_fields = ["b", "pos", "len", "totlen"]
    _hx_methods = ["set_position", "readByte", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,b,pos = None,_hx_len = None):
        if (pos is None):
            pos = 0
        if (_hx_len is None):
            _hx_len = (b.length - pos)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > b.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        self.b = b.b
        self.pos = pos
        self.len = _hx_len
        self.totlen = _hx_len
        self.set_bigEndian(False)

    def set_position(self,p):
        if (p < 0):
            p = 0
        elif (p > self.totlen):
            p = self.totlen
        self.len = (self.totlen - p)
        def _hx_local_1():
            def _hx_local_0():
                self.pos = p
                return self.pos
            return _hx_local_0()
        return _hx_local_1()

    def readByte(self):
        if (self.len == 0):
            raise haxe_Exception.thrown(haxe_io_Eof())
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 - 1)
        _hx_local_1
        b = self.b[self.pos]
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.pos
        _hx_local_2.pos = (_hx_local_3 + 1)
        _hx_local_3
        return b

    def readBytes(self,buf,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        if ((self.len == 0) and ((_hx_len > 0))):
            raise haxe_Exception.thrown(haxe_io_Eof())
        if (self.len < _hx_len):
            _hx_len = self.len
        b1 = self.b
        b2 = buf.b
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            b2[(pos + i)] = b1[(self.pos + i)]
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + _hx_len)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.len
        _hx_local_2.len = (_hx_local_3 - _hx_len)
        _hx_local_2.len
        return _hx_len

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.pos = None
        _hx_o.len = None
        _hx_o.totlen = None
haxe_io_BytesInput._hx_class = haxe_io_BytesInput
_hx_classes["haxe.io.BytesInput"] = haxe_io_BytesInput


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    _hx_is_interface = "False"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "flush", "close", "set_bigEndian", "write", "writeFullBytes", "writeFloat", "writeInt16", "writeUInt16", "writeInt32", "writeString"]

    def writeByte(self,c):
        raise haxe_exceptions_NotImplementedException(None,None,_hx_AnonObject({'fileName': "haxe/io/Output.hx", 'lineNumber': 47, 'className': "haxe.io.Output", 'methodName': "writeByte"}))

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def flush(self):
        pass

    def close(self):
        pass

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def write(self,s):
        l = s.length
        p = 0
        while (l > 0):
            k = self.writeBytes(s,p,l)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            p = (p + k)
            l = (l - k)

    def writeFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.writeBytes(s,pos,_hx_len)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def writeFloat(self,x):
        self.writeInt32(haxe_io_FPHelper.floatToI32(x))

    def writeInt16(self,x):
        if ((x < -32768) or ((x >= 32768))):
            raise haxe_Exception.thrown(haxe_io_Error.Overflow)
        self.writeUInt16((x & 65535))

    def writeUInt16(self,x):
        if ((x < 0) or ((x >= 65536))):
            raise haxe_Exception.thrown(haxe_io_Error.Overflow)
        if self.bigEndian:
            self.writeByte((x >> 8))
            self.writeByte((x & 255))
        else:
            self.writeByte((x & 255))
            self.writeByte((x >> 8))

    def writeInt32(self,x):
        if self.bigEndian:
            self.writeByte(HxOverrides.rshift(x, 24))
            self.writeByte(((x >> 16) & 255))
            self.writeByte(((x >> 8) & 255))
            self.writeByte((x & 255))
        else:
            self.writeByte((x & 255))
            self.writeByte(((x >> 8) & 255))
            self.writeByte(((x >> 16) & 255))
            self.writeByte(HxOverrides.rshift(x, 24))

    def writeString(self,s,encoding = None):
        b = haxe_io_Bytes.ofString(s,encoding)
        self.writeFullBytes(b,0,b.length)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None
haxe_io_Output._hx_class = haxe_io_Output
_hx_classes["haxe.io.Output"] = haxe_io_Output


class haxe_io_BytesOutput(haxe_io_Output):
    _hx_class_name = "haxe.io.BytesOutput"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["writeByte", "writeBytes", "getBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self):
        self.b = haxe_io_BytesBuffer()
        self.set_bigEndian(False)

    def writeByte(self,c):
        self.b.b.append(c)

    def writeBytes(self,buf,pos,_hx_len):
        _this = self.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        _this.b.extend(buf.b[pos:(pos + _hx_len)])
        return _hx_len

    def getBytes(self):
        return self.b.getBytes()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
haxe_io_BytesOutput._hx_class = haxe_io_BytesOutput
_hx_classes["haxe.io.BytesOutput"] = haxe_io_BytesOutput

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())
haxe_io_Encoding._hx_class = haxe_io_Encoding
_hx_classes["haxe.io.Encoding"] = haxe_io_Encoding


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_io_Eof._hx_class = haxe_io_Eof
_hx_classes["haxe.io.Eof"] = haxe_io_Eof

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())
haxe_io_Error._hx_class = haxe_io_Error
_hx_classes["haxe.io.Error"] = haxe_io_Error


class haxe_io_FPHelper:
    _hx_class_name = "haxe.io.FPHelper"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["i64tmp", "i32ToFloat", "floatToI32", "i64ToDouble", "doubleToI64"]

    @staticmethod
    def i32ToFloat(i):
        sign = (1 - ((HxOverrides.rshift(i, 31) << 1)))
        e = ((i >> 23) & 255)
        if (e == 255):
            if (((i & 8388607)) == 0):
                if (sign > 0):
                    return Math.POSITIVE_INFINITY
                else:
                    return Math.NEGATIVE_INFINITY
            else:
                return Math.NaN
        else:
            m = ((((i & 8388607)) << 1) if ((e == 0)) else ((i & 8388607) | 8388608))
            return ((sign * m) * Math.pow(2,(e - 150)))

    @staticmethod
    def floatToI32(f):
        if (f == 0):
            return 0
        else:
            af = (-f if ((f < 0)) else f)
            exp = Math.floor((((Math.NEGATIVE_INFINITY if ((af == 0.0)) else (Math.NaN if ((af < 0.0)) else python_lib_Math.log(af)))) / 0.6931471805599453))
            if (exp > 127):
                return 2139095040
            else:
                if (exp <= -127):
                    exp = -127
                    af = (af * 7.1362384635298e+44)
                else:
                    af = ((((af / Math.pow(2,exp)) - 1.0)) * 8388608)
                return ((((-2147483648 if ((f < 0)) else 0)) | (((exp + 127) << 23))) | Math.floor((af + 0.5)))

    @staticmethod
    def i64ToDouble(low,high):
        sign = (1 - ((HxOverrides.rshift(high, 31) << 1)))
        e = ((high >> 20) & 2047)
        if (e == 2047):
            if ((low == 0) and ((((high & 1048575)) == 0))):
                if (sign > 0):
                    return Math.POSITIVE_INFINITY
                else:
                    return Math.NEGATIVE_INFINITY
            else:
                return Math.NaN
        else:
            m = (2.220446049250313e-16 * ((((((high & 1048575)) * 4294967296.) + (((HxOverrides.rshift(low, 31)) * 2147483648.))) + ((low & 2147483647)))))
            if (e == 0):
                m = (m * 2.0)
            else:
                m = (m + 1.0)
            return ((sign * m) * Math.pow(2,(e - 1023)))

    @staticmethod
    def doubleToI64(v):
        i64 = haxe_io_FPHelper.i64tmp
        if (v == 0):
            i64.low = 0
            i64.high = 0
        elif (not ((((v != Math.POSITIVE_INFINITY) and ((v != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(v))))):
            i64.low = 0
            i64.high = (2146435072 if ((v > 0)) else -1048576)
        else:
            av = (-v if ((v < 0)) else v)
            exp = Math.floor((((Math.NEGATIVE_INFINITY if ((av == 0.0)) else (Math.NaN if ((av < 0.0)) else python_lib_Math.log(av)))) / 0.6931471805599453))
            if (exp > 1023):
                i64.low = -1
                i64.high = 2146435071
            else:
                if (exp <= -1023):
                    exp = -1023
                    av = (av / 2.2250738585072014e-308)
                else:
                    av = ((av / Math.pow(2,exp)) - 1.0)
                v1 = (av * 4503599627370496.)
                sig = (v1 if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v1)) else Math.floor((v1 + 0.5))))
                sig_l = None
                try:
                    sig_l = int(sig)
                except BaseException as _g:
                    None
                    sig_l = None
                sig_l1 = sig_l
                sig_h = None
                try:
                    sig_h = int((sig / 4294967296.0))
                except BaseException as _g:
                    None
                    sig_h = None
                sig_h1 = sig_h
                i64.low = sig_l1
                i64.high = ((((-2147483648 if ((v < 0)) else 0)) | (((exp + 1023) << 20))) | sig_h1)
        return i64
haxe_io_FPHelper._hx_class = haxe_io_FPHelper
_hx_classes["haxe.io.FPHelper"] = haxe_io_FPHelper


class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    _hx_is_interface = "False"
    __slots__ = ("dir", "file", "ext", "backslash")
    _hx_fields = ["dir", "file", "ext", "backslash"]
    _hx_methods = ["toString"]
    _hx_statics = ["directory", "withExtension", "join", "normalize", "addTrailingSlash", "isAbsolute"]

    def __init__(self,path):
        self.backslash = None
        self.ext = None
        self.file = None
        self.dir = None
        path1 = path
        _hx_local_0 = len(path1)
        if (_hx_local_0 == 1):
            if (path1 == "."):
                self.dir = path
                self.file = ""
                return
        elif (_hx_local_0 == 2):
            if (path1 == ".."):
                self.dir = path
                self.file = ""
                return
        else:
            pass
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex = None
        c2 = None
        if (startIndex is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i = path.rfind("\\", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\\"))) if ((i == -1)) else (i + 1))
            check = path.find("\\", startLeft, len(path))
            c2 = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (c1 < c2):
            self.dir = HxString.substr(path,0,c2)
            path = HxString.substr(path,(c2 + 1),None)
            self.backslash = True
        elif (c2 < c1):
            self.dir = HxString.substr(path,0,c1)
            path = HxString.substr(path,(c1 + 1),None)
        else:
            self.dir = None
        startIndex = None
        cp = None
        if (startIndex is None):
            cp = path.rfind(".", 0, len(path))
        else:
            i = path.rfind(".", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("."))) if ((i == -1)) else (i + 1))
            check = path.find(".", startLeft, len(path))
            cp = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (cp != -1):
            self.ext = HxString.substr(path,(cp + 1),None)
            self.file = HxString.substr(path,0,cp)
        else:
            self.ext = None
            self.file = path

    def toString(self):
        return ((HxOverrides.stringOrNull((("" if ((self.dir is None)) else (HxOverrides.stringOrNull(self.dir) + HxOverrides.stringOrNull((("\\" if (self.backslash) else "/"))))))) + HxOverrides.stringOrNull(self.file)) + HxOverrides.stringOrNull((("" if ((self.ext is None)) else ("." + HxOverrides.stringOrNull(self.ext))))))

    @staticmethod
    def directory(path):
        s = haxe_io_Path(path)
        if (s.dir is None):
            return ""
        return s.dir

    @staticmethod
    def withExtension(path,ext):
        s = haxe_io_Path(path)
        s.ext = ext
        return s.toString()

    @staticmethod
    def join(paths):
        def _hx_local_0(s):
            if (s is not None):
                return (s != "")
            else:
                return False
        paths1 = list(filter(_hx_local_0,paths))
        if (len(paths1) == 0):
            return ""
        path = (paths1[0] if 0 < len(paths1) else None)
        _g = 1
        _g1 = len(paths1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            path = haxe_io_Path.addTrailingSlash(path)
            path = (("null" if path is None else path) + HxOverrides.stringOrNull((paths1[i] if i >= 0 and i < len(paths1) else None)))
        return haxe_io_Path.normalize(path)

    @staticmethod
    def normalize(path):
        slash = "/"
        _this = path.split("\\")
        path = slash.join([python_Boot.toString1(x1,'') for x1 in _this])
        if (path == slash):
            return slash
        target = []
        _g = 0
        _g1 = (list(path) if ((slash == "")) else path.split(slash))
        while (_g < len(_g1)):
            token = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((token == "..") and ((len(target) > 0))) and ((python_internal_ArrayImpl._get(target, (len(target) - 1)) != ".."))):
                if (len(target) != 0):
                    target.pop()
            elif (token == ""):
                if ((len(target) > 0) or ((HxString.charCodeAt(path,0) == 47))):
                    target.append(token)
            elif (token != "."):
                target.append(token)
        tmp = slash.join([python_Boot.toString1(x1,'') for x1 in target])
        acc_b = python_lib_io_StringIO()
        colon = False
        slashes = False
        _g = 0
        _g1 = len(tmp)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = (-1 if ((i >= len(tmp))) else ord(tmp[i]))
            _g3 = _g2
            if (_g3 == 47):
                if (not colon):
                    slashes = True
                else:
                    i1 = _g2
                    colon = False
                    if slashes:
                        acc_b.write("/")
                        slashes = False
                    acc_b.write("".join(map(chr,[i1])))
            elif (_g3 == 58):
                acc_b.write(":")
                colon = True
            else:
                i2 = _g2
                colon = False
                if slashes:
                    acc_b.write("/")
                    slashes = False
                acc_b.write("".join(map(chr,[i2])))
        return acc_b.getvalue()

    @staticmethod
    def addTrailingSlash(path):
        if (len(path) == 0):
            return "/"
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex = None
        c2 = None
        if (startIndex is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i = path.rfind("\\", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\\"))) if ((i == -1)) else (i + 1))
            check = path.find("\\", startLeft, len(path))
            c2 = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (c1 < c2):
            if (c2 != ((len(path) - 1))):
                return (("null" if path is None else path) + "\\")
            else:
                return path
        elif (c1 != ((len(path) - 1))):
            return (("null" if path is None else path) + "/")
        else:
            return path

    @staticmethod
    def isAbsolute(path):
        if path.startswith("/"):
            return True
        if ((("" if ((1 >= len(path))) else path[1])) == ":"):
            return True
        if path.startswith("\\\\"):
            return True
        return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.dir = None
        _hx_o.file = None
        _hx_o.ext = None
        _hx_o.backslash = None
haxe_io_Path._hx_class = haxe_io_Path
_hx_classes["haxe.io.Path"] = haxe_io_Path


class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    _hx_is_interface = "False"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.array = None
        _hx_o.current = None
haxe_iterators_ArrayIterator._hx_class = haxe_iterators_ArrayIterator
_hx_classes["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator

class haxe_macro_Binop(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Binop"
    _hx_constructs = ["OpAdd", "OpMult", "OpDiv", "OpSub", "OpAssign", "OpEq", "OpNotEq", "OpGt", "OpGte", "OpLt", "OpLte", "OpAnd", "OpOr", "OpXor", "OpBoolAnd", "OpBoolOr", "OpShl", "OpShr", "OpUShr", "OpMod", "OpAssignOp", "OpInterval", "OpArrow", "OpIn"]

    @staticmethod
    def OpAssignOp(op):
        return haxe_macro_Binop("OpAssignOp", 20, (op,))
haxe_macro_Binop.OpAdd = haxe_macro_Binop("OpAdd", 0, ())
haxe_macro_Binop.OpMult = haxe_macro_Binop("OpMult", 1, ())
haxe_macro_Binop.OpDiv = haxe_macro_Binop("OpDiv", 2, ())
haxe_macro_Binop.OpSub = haxe_macro_Binop("OpSub", 3, ())
haxe_macro_Binop.OpAssign = haxe_macro_Binop("OpAssign", 4, ())
haxe_macro_Binop.OpEq = haxe_macro_Binop("OpEq", 5, ())
haxe_macro_Binop.OpNotEq = haxe_macro_Binop("OpNotEq", 6, ())
haxe_macro_Binop.OpGt = haxe_macro_Binop("OpGt", 7, ())
haxe_macro_Binop.OpGte = haxe_macro_Binop("OpGte", 8, ())
haxe_macro_Binop.OpLt = haxe_macro_Binop("OpLt", 9, ())
haxe_macro_Binop.OpLte = haxe_macro_Binop("OpLte", 10, ())
haxe_macro_Binop.OpAnd = haxe_macro_Binop("OpAnd", 11, ())
haxe_macro_Binop.OpOr = haxe_macro_Binop("OpOr", 12, ())
haxe_macro_Binop.OpXor = haxe_macro_Binop("OpXor", 13, ())
haxe_macro_Binop.OpBoolAnd = haxe_macro_Binop("OpBoolAnd", 14, ())
haxe_macro_Binop.OpBoolOr = haxe_macro_Binop("OpBoolOr", 15, ())
haxe_macro_Binop.OpShl = haxe_macro_Binop("OpShl", 16, ())
haxe_macro_Binop.OpShr = haxe_macro_Binop("OpShr", 17, ())
haxe_macro_Binop.OpUShr = haxe_macro_Binop("OpUShr", 18, ())
haxe_macro_Binop.OpMod = haxe_macro_Binop("OpMod", 19, ())
haxe_macro_Binop.OpInterval = haxe_macro_Binop("OpInterval", 21, ())
haxe_macro_Binop.OpArrow = haxe_macro_Binop("OpArrow", 22, ())
haxe_macro_Binop.OpIn = haxe_macro_Binop("OpIn", 23, ())
haxe_macro_Binop._hx_class = haxe_macro_Binop
_hx_classes["haxe.macro.Binop"] = haxe_macro_Binop

class haxe_macro_Unop(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Unop"
    _hx_constructs = ["OpIncrement", "OpDecrement", "OpNot", "OpNeg", "OpNegBits", "OpSpread"]
haxe_macro_Unop.OpIncrement = haxe_macro_Unop("OpIncrement", 0, ())
haxe_macro_Unop.OpDecrement = haxe_macro_Unop("OpDecrement", 1, ())
haxe_macro_Unop.OpNot = haxe_macro_Unop("OpNot", 2, ())
haxe_macro_Unop.OpNeg = haxe_macro_Unop("OpNeg", 3, ())
haxe_macro_Unop.OpNegBits = haxe_macro_Unop("OpNegBits", 4, ())
haxe_macro_Unop.OpSpread = haxe_macro_Unop("OpSpread", 5, ())
haxe_macro_Unop._hx_class = haxe_macro_Unop
_hx_classes["haxe.macro.Unop"] = haxe_macro_Unop


class haxe_xml__Access_NodeAccess_Impl_:
    _hx_class_name = "haxe.xml._Access.NodeAccess_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["resolve"]

    @staticmethod
    def resolve(this1,name):
        x = this1.elementsNamed(name).next()
        if (x is None):
            xname = None
            if (this1.nodeType == Xml.Document):
                xname = "Document"
            else:
                if (this1.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((this1.nodeType is None)) else _Xml_XmlType_Impl_.toString(this1.nodeType))))))
                xname = this1.nodeName
            raise haxe_Exception.thrown(((("null" if xname is None else xname) + " is missing element ") + ("null" if name is None else name)))
        if ((x.nodeType != Xml.Document) and ((x.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Invalid nodeType " + HxOverrides.stringOrNull((("null" if ((x.nodeType is None)) else _Xml_XmlType_Impl_.toString(x.nodeType))))))
        this1 = x
        return this1
haxe_xml__Access_NodeAccess_Impl_._hx_class = haxe_xml__Access_NodeAccess_Impl_
_hx_classes["haxe.xml._Access.NodeAccess_Impl_"] = haxe_xml__Access_NodeAccess_Impl_


class haxe_xml__Access_AttribAccess_Impl_:
    _hx_class_name = "haxe.xml._Access.AttribAccess_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["resolve"]

    @staticmethod
    def resolve(this1,name):
        if (this1.nodeType == Xml.Document):
            raise haxe_Exception.thrown(("Cannot access document attribute " + ("null" if name is None else name)))
        v = this1.get(name)
        if (v is None):
            if (this1.nodeType != Xml.Element):
                raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((this1.nodeType is None)) else _Xml_XmlType_Impl_.toString(this1.nodeType))))))
            raise haxe_Exception.thrown(((HxOverrides.stringOrNull(this1.nodeName) + " is missing attribute ") + ("null" if name is None else name)))
        return v
haxe_xml__Access_AttribAccess_Impl_._hx_class = haxe_xml__Access_AttribAccess_Impl_
_hx_classes["haxe.xml._Access.AttribAccess_Impl_"] = haxe_xml__Access_AttribAccess_Impl_


class haxe_xml__Access_HasNodeAccess_Impl_:
    _hx_class_name = "haxe.xml._Access.HasNodeAccess_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["resolve"]

    @staticmethod
    def resolve(this1,name):
        return this1.elementsNamed(name).hasNext()
haxe_xml__Access_HasNodeAccess_Impl_._hx_class = haxe_xml__Access_HasNodeAccess_Impl_
_hx_classes["haxe.xml._Access.HasNodeAccess_Impl_"] = haxe_xml__Access_HasNodeAccess_Impl_


class haxe_xml__Access_Access_Impl_:
    _hx_class_name = "haxe.xml._Access.Access_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_innerData"]
    innerData = None

    @staticmethod
    def get_innerData(this1):
        if ((this1.nodeType != Xml.Document) and ((this1.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((this1.nodeType is None)) else _Xml_XmlType_Impl_.toString(this1.nodeType))))))
        it_current = 0
        it_array = this1.children
        if (it_current >= len(it_array)):
            tmp = None
            if (this1.nodeType == Xml.Document):
                tmp = "Document"
            else:
                if (this1.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((this1.nodeType is None)) else _Xml_XmlType_Impl_.toString(this1.nodeType))))))
                tmp = this1.nodeName
            raise haxe_Exception.thrown((("null" if tmp is None else tmp) + " does not have data"))
        v = it_current
        it_current = (it_current + 1)
        v1 = (it_array[v] if v >= 0 and v < len(it_array) else None)
        if (it_current < len(it_array)):
            n = it_current
            it_current = (it_current + 1)
            n1 = (it_array[n] if n >= 0 and n < len(it_array) else None)
            tmp = None
            if ((v1.nodeType == Xml.PCData) and ((n1.nodeType == Xml.CData))):
                if ((v1.nodeType == Xml.Document) or ((v1.nodeType == Xml.Element))):
                    raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((v1.nodeType is None)) else _Xml_XmlType_Impl_.toString(v1.nodeType))))))
                tmp = (StringTools.trim(v1.nodeValue) == "")
            else:
                tmp = False
            if tmp:
                if (it_current >= len(it_array)):
                    if ((n1.nodeType == Xml.Document) or ((n1.nodeType == Xml.Element))):
                        raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((n1.nodeType is None)) else _Xml_XmlType_Impl_.toString(n1.nodeType))))))
                    return n1.nodeValue
                n2 = it_current
                it_current = (it_current + 1)
                n21 = (it_array[n2] if n2 >= 0 and n2 < len(it_array) else None)
                tmp = None
                if (n21.nodeType == Xml.PCData):
                    if ((n21.nodeType == Xml.Document) or ((n21.nodeType == Xml.Element))):
                        raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((n21.nodeType is None)) else _Xml_XmlType_Impl_.toString(n21.nodeType))))))
                    tmp = (StringTools.trim(n21.nodeValue) == "")
                else:
                    tmp = False
                if (tmp and ((it_current >= len(it_array)))):
                    if ((n1.nodeType == Xml.Document) or ((n1.nodeType == Xml.Element))):
                        raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((n1.nodeType is None)) else _Xml_XmlType_Impl_.toString(n1.nodeType))))))
                    return n1.nodeValue
            tmp = None
            if (this1.nodeType == Xml.Document):
                tmp = "Document"
            else:
                if (this1.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((this1.nodeType is None)) else _Xml_XmlType_Impl_.toString(this1.nodeType))))))
                tmp = this1.nodeName
            raise haxe_Exception.thrown((("null" if tmp is None else tmp) + " does not only have data"))
        if ((v1.nodeType != Xml.PCData) and ((v1.nodeType != Xml.CData))):
            tmp = None
            if (this1.nodeType == Xml.Document):
                tmp = "Document"
            else:
                if (this1.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((this1.nodeType is None)) else _Xml_XmlType_Impl_.toString(this1.nodeType))))))
                tmp = this1.nodeName
            raise haxe_Exception.thrown((("null" if tmp is None else tmp) + " does not have data"))
        if ((v1.nodeType == Xml.Document) or ((v1.nodeType == Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((v1.nodeType is None)) else _Xml_XmlType_Impl_.toString(v1.nodeType))))))
        return v1.nodeValue
haxe_xml__Access_Access_Impl_._hx_class = haxe_xml__Access_Access_Impl_
_hx_classes["haxe.xml._Access.Access_Impl_"] = haxe_xml__Access_Access_Impl_


class haxe_xml_XmlParserException:
    _hx_class_name = "haxe.xml.XmlParserException"
    _hx_is_interface = "False"
    __slots__ = ("message", "lineNumber", "positionAtLine", "position", "xml")
    _hx_fields = ["message", "lineNumber", "positionAtLine", "position", "xml"]
    _hx_methods = ["toString"]

    def __init__(self,message,xml,position):
        self.xml = xml
        self.message = message
        self.position = position
        self.lineNumber = 1
        self.positionAtLine = 0
        _g = 0
        _g1 = position
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(xml))) else ord(xml[i]))
            if (c == 10):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.lineNumber
                _hx_local_0.lineNumber = (_hx_local_1 + 1)
                _hx_local_1
                self.positionAtLine = 0
            elif (c != 13):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.positionAtLine
                _hx_local_2.positionAtLine = (_hx_local_3 + 1)
                _hx_local_3

    def toString(self):
        return ((((((HxOverrides.stringOrNull(Type.getClassName(Type.getClass(self))) + ": ") + HxOverrides.stringOrNull(self.message)) + " at line ") + Std.string(self.lineNumber)) + " char ") + Std.string(self.positionAtLine))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.message = None
        _hx_o.lineNumber = None
        _hx_o.positionAtLine = None
        _hx_o.position = None
        _hx_o.xml = None
haxe_xml_XmlParserException._hx_class = haxe_xml_XmlParserException
_hx_classes["haxe.xml.XmlParserException"] = haxe_xml_XmlParserException


class haxe_xml_Parser:
    _hx_class_name = "haxe.xml.Parser"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["escapes", "parse", "doParse"]

    @staticmethod
    def parse(_hx_str,strict = None):
        if (strict is None):
            strict = False
        doc = Xml.createDocument()
        haxe_xml_Parser.doParse(_hx_str,strict,0,doc)
        return doc

    @staticmethod
    def doParse(_hx_str,strict,p = None,parent = None):
        if (p is None):
            p = 0
        xml = None
        state = 1
        next = 1
        aname = None
        start = 0
        nsubs = 0
        nbrackets = 0
        buf = StringBuf()
        escapeNext = 1
        attrValQuote = -1
        while (p < len(_hx_str)):
            c = ord(_hx_str[p])
            state1 = state
            if (state1 == 0):
                c1 = c
                if ((((c1 == 32) or ((c1 == 13))) or ((c1 == 10))) or ((c1 == 9))):
                    pass
                else:
                    state = next
                    continue
            elif (state1 == 1):
                if (c == 60):
                    state = 0
                    next = 2
                else:
                    start = p
                    state = 13
                    continue
            elif (state1 == 2):
                c2 = c
                if (c2 == 33):
                    index = (p + 1)
                    if (((-1 if ((index >= len(_hx_str))) else ord(_hx_str[index]))) == 91):
                        p = (p + 2)
                        if (HxString.substr(_hx_str,p,6).upper() != "CDATA["):
                            raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected <![CDATA[",_hx_str,p))
                        p = (p + 5)
                        state = 17
                        start = (p + 1)
                    else:
                        tmp = None
                        index1 = (p + 1)
                        if (((-1 if ((index1 >= len(_hx_str))) else ord(_hx_str[index1]))) != 68):
                            index2 = (p + 1)
                            tmp = (((-1 if ((index2 >= len(_hx_str))) else ord(_hx_str[index2]))) == 100)
                        else:
                            tmp = True
                        if tmp:
                            if (HxString.substr(_hx_str,(p + 2),6).upper() != "OCTYPE"):
                                raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected <!DOCTYPE",_hx_str,p))
                            p = (p + 8)
                            state = 16
                            start = (p + 1)
                        else:
                            tmp1 = None
                            index3 = (p + 1)
                            if (((-1 if ((index3 >= len(_hx_str))) else ord(_hx_str[index3]))) == 45):
                                index4 = (p + 2)
                                tmp1 = (((-1 if ((index4 >= len(_hx_str))) else ord(_hx_str[index4]))) != 45)
                            else:
                                tmp1 = True
                            if tmp1:
                                raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected <!--",_hx_str,p))
                            else:
                                p = (p + 2)
                                state = 15
                                start = (p + 1)
                elif (c2 == 47):
                    if (parent is None):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    start = (p + 1)
                    state = 0
                    next = 10
                elif (c2 == 63):
                    state = 14
                    start = p
                else:
                    state = 3
                    start = p
                    continue
            elif (state1 == 3):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (p == start):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    xml = Xml.createElement(HxString.substr(_hx_str,start,(p - start)))
                    parent.addChild(xml)
                    nsubs = (nsubs + 1)
                    state = 0
                    next = 4
                    continue
            elif (state1 == 4):
                c3 = c
                if (c3 == 47):
                    state = 11
                elif (c3 == 62):
                    state = 9
                else:
                    state = 5
                    start = p
                    continue
            elif (state1 == 5):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (start == p):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected attribute name",_hx_str,p))
                    tmp2 = HxString.substr(_hx_str,start,(p - start))
                    aname = tmp2
                    if xml.exists(aname):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Duplicate attribute [" + ("null" if aname is None else aname)) + "]"),_hx_str,p))
                    state = 0
                    next = 6
                    continue
            elif (state1 == 6):
                if (c == 61):
                    state = 0
                    next = 7
                else:
                    raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected =",_hx_str,p))
            elif (state1 == 7):
                c4 = c
                if ((c4 == 39) or ((c4 == 34))):
                    buf = StringBuf()
                    state = 8
                    start = (p + 1)
                    attrValQuote = c
                else:
                    raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected \"",_hx_str,p))
            elif (state1 == 8):
                c5 = c
                if (c5 == 38):
                    _hx_len = (p - start)
                    s = (HxString.substr(_hx_str,start,None) if ((_hx_len is None)) else HxString.substr(_hx_str,start,_hx_len))
                    buf.b.write(s)
                    state = 18
                    escapeNext = 8
                    start = (p + 1)
                elif ((c5 == 62) or ((c5 == 60))):
                    if strict:
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Invalid unescaped " + HxOverrides.stringOrNull("".join(map(chr,[c])))) + " in attribute value"),_hx_str,p))
                    elif (c == attrValQuote):
                        len1 = (p - start)
                        s1 = (HxString.substr(_hx_str,start,None) if ((len1 is None)) else HxString.substr(_hx_str,start,len1))
                        buf.b.write(s1)
                        val = buf.b.getvalue()
                        buf = StringBuf()
                        xml.set(aname,val)
                        state = 0
                        next = 4
                elif (c == attrValQuote):
                    len2 = (p - start)
                    s2 = (HxString.substr(_hx_str,start,None) if ((len2 is None)) else HxString.substr(_hx_str,start,len2))
                    buf.b.write(s2)
                    val1 = buf.b.getvalue()
                    buf = StringBuf()
                    xml.set(aname,val1)
                    state = 0
                    next = 4
            elif (state1 == 9):
                p = haxe_xml_Parser.doParse(_hx_str,strict,p,xml)
                start = p
                state = 1
            elif (state1 == 10):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (start == p):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    v = HxString.substr(_hx_str,start,(p - start))
                    if ((parent is None) or ((parent.nodeType != 0))):
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Unexpected </" + ("null" if v is None else v)) + ">, tag is not open"),_hx_str,p))
                    if (parent.nodeType != Xml.Element):
                        raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((parent.nodeType is None)) else _Xml_XmlType_Impl_.toString(parent.nodeType))))))
                    if (v != parent.nodeName):
                        if (parent.nodeType != Xml.Element):
                            raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((parent.nodeType is None)) else _Xml_XmlType_Impl_.toString(parent.nodeType))))))
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Expected </" + HxOverrides.stringOrNull(parent.nodeName)) + ">"),_hx_str,p))
                    state = 0
                    next = 12
                    continue
            elif (state1 == 11):
                if (c == 62):
                    state = 1
                else:
                    raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected >",_hx_str,p))
            elif (state1 == 12):
                if (c == 62):
                    if (nsubs == 0):
                        parent.addChild(Xml.createPCData(""))
                    return p
                else:
                    raise haxe_Exception.thrown(haxe_xml_XmlParserException("Expected >",_hx_str,p))
            elif (state1 == 13):
                if (c == 60):
                    len3 = (p - start)
                    s3 = (HxString.substr(_hx_str,start,None) if ((len3 is None)) else HxString.substr(_hx_str,start,len3))
                    buf.b.write(s3)
                    child = Xml.createPCData(buf.b.getvalue())
                    buf = StringBuf()
                    parent.addChild(child)
                    nsubs = (nsubs + 1)
                    state = 0
                    next = 2
                elif (c == 38):
                    len4 = (p - start)
                    s4 = (HxString.substr(_hx_str,start,None) if ((len4 is None)) else HxString.substr(_hx_str,start,len4))
                    buf.b.write(s4)
                    state = 18
                    escapeNext = 13
                    start = (p + 1)
            elif (state1 == 14):
                tmp3 = None
                if (c == 63):
                    index5 = (p + 1)
                    tmp3 = (((-1 if ((index5 >= len(_hx_str))) else ord(_hx_str[index5]))) == 62)
                else:
                    tmp3 = False
                if tmp3:
                    p = (p + 1)
                    str1 = HxString.substr(_hx_str,(start + 1),((p - start) - 2))
                    parent.addChild(Xml.createProcessingInstruction(str1))
                    nsubs = (nsubs + 1)
                    state = 1
            elif (state1 == 15):
                tmp4 = None
                tmp5 = None
                if (c == 45):
                    index6 = (p + 1)
                    tmp5 = (((-1 if ((index6 >= len(_hx_str))) else ord(_hx_str[index6]))) == 45)
                else:
                    tmp5 = False
                if tmp5:
                    index7 = (p + 2)
                    tmp4 = (((-1 if ((index7 >= len(_hx_str))) else ord(_hx_str[index7]))) == 62)
                else:
                    tmp4 = False
                if tmp4:
                    parent.addChild(Xml.createComment(HxString.substr(_hx_str,start,(p - start))))
                    nsubs = (nsubs + 1)
                    p = (p + 2)
                    state = 1
            elif (state1 == 16):
                if (c == 91):
                    nbrackets = (nbrackets + 1)
                elif (c == 93):
                    nbrackets = (nbrackets - 1)
                elif ((c == 62) and ((nbrackets == 0))):
                    parent.addChild(Xml.createDocType(HxString.substr(_hx_str,start,(p - start))))
                    nsubs = (nsubs + 1)
                    state = 1
            elif (state1 == 17):
                tmp6 = None
                tmp7 = None
                if (c == 93):
                    index8 = (p + 1)
                    tmp7 = (((-1 if ((index8 >= len(_hx_str))) else ord(_hx_str[index8]))) == 93)
                else:
                    tmp7 = False
                if tmp7:
                    index9 = (p + 2)
                    tmp6 = (((-1 if ((index9 >= len(_hx_str))) else ord(_hx_str[index9]))) == 62)
                else:
                    tmp6 = False
                if tmp6:
                    child1 = Xml.createCData(HxString.substr(_hx_str,start,(p - start)))
                    parent.addChild(child1)
                    nsubs = (nsubs + 1)
                    p = (p + 2)
                    state = 1
            elif (state1 == 18):
                if (c == 59):
                    s5 = HxString.substr(_hx_str,start,(p - start))
                    if (((-1 if ((0 >= len(s5))) else ord(s5[0]))) == 35):
                        c6 = (Std.parseInt(("0" + HxOverrides.stringOrNull(HxString.substr(s5,1,(len(s5) - 1))))) if ((((-1 if ((1 >= len(s5))) else ord(s5[1]))) == 120)) else Std.parseInt(HxString.substr(s5,1,(len(s5) - 1))))
                        s6 = "".join(map(chr,[c6]))
                        buf.b.write(s6)
                    elif (not (s5 in haxe_xml_Parser.escapes.h)):
                        if strict:
                            raise haxe_Exception.thrown(haxe_xml_XmlParserException(("Undefined entity: " + ("null" if s5 is None else s5)),_hx_str,p))
                        s7 = Std.string((("&" + ("null" if s5 is None else s5)) + ";"))
                        buf.b.write(s7)
                    else:
                        s8 = Std.string(haxe_xml_Parser.escapes.h.get(s5,None))
                        buf.b.write(s8)
                    start = (p + 1)
                    state = escapeNext
                elif ((not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))) and ((c != 35))):
                    if strict:
                        raise haxe_Exception.thrown(haxe_xml_XmlParserException(("Invalid character in entity: " + HxOverrides.stringOrNull("".join(map(chr,[c])))),_hx_str,p))
                    s9 = "".join(map(chr,[38]))
                    buf.b.write(s9)
                    len5 = (p - start)
                    s10 = (HxString.substr(_hx_str,start,None) if ((len5 is None)) else HxString.substr(_hx_str,start,len5))
                    buf.b.write(s10)
                    p = (p - 1)
                    start = (p + 1)
                    state = escapeNext
            else:
                pass
            p = (p + 1)
        if (state == 1):
            start = p
            state = 13
        if (state == 13):
            if (parent.nodeType == 0):
                if (parent.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((parent.nodeType is None)) else _Xml_XmlType_Impl_.toString(parent.nodeType))))))
                raise haxe_Exception.thrown(haxe_xml_XmlParserException((("Unclosed node <" + HxOverrides.stringOrNull(parent.nodeName)) + ">"),_hx_str,p))
            if ((p != start) or ((nsubs == 0))):
                _hx_len = (p - start)
                s = (HxString.substr(_hx_str,start,None) if ((_hx_len is None)) else HxString.substr(_hx_str,start,_hx_len))
                buf.b.write(s)
                parent.addChild(Xml.createPCData(buf.b.getvalue()))
                nsubs = (nsubs + 1)
            return p
        if (((not strict) and ((state == 18))) and ((escapeNext == 13))):
            s = "".join(map(chr,[38]))
            buf.b.write(s)
            _hx_len = (p - start)
            s = (HxString.substr(_hx_str,start,None) if ((_hx_len is None)) else HxString.substr(_hx_str,start,_hx_len))
            buf.b.write(s)
            parent.addChild(Xml.createPCData(buf.b.getvalue()))
            nsubs = (nsubs + 1)
            return p
        raise haxe_Exception.thrown(haxe_xml_XmlParserException("Unexpected end",_hx_str,p))
haxe_xml_Parser._hx_class = haxe_xml_Parser
_hx_classes["haxe.xml.Parser"] = haxe_xml_Parser


class haxe_xml_Printer:
    _hx_class_name = "haxe.xml.Printer"
    _hx_is_interface = "False"
    __slots__ = ("output", "pretty")
    _hx_fields = ["output", "pretty"]
    _hx_methods = ["writeNode", "hasChildren"]
    _hx_statics = ["print"]

    def __init__(self,pretty):
        self.output = StringBuf()
        self.pretty = pretty

    def writeNode(self,value,tabs):
        _g = value.nodeType
        if (_g == 0):
            _this = self.output
            s = Std.string((("null" if tabs is None else tabs) + "<"))
            _this.b.write(s)
            if (value.nodeType != Xml.Element):
                raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _this = self.output
            s = Std.string(value.nodeName)
            _this.b.write(s)
            attribute = value.attributes()
            while attribute.hasNext():
                attribute1 = attribute.next()
                _this = self.output
                s = Std.string(((" " + ("null" if attribute1 is None else attribute1)) + "=\""))
                _this.b.write(s)
                input = StringTools.htmlEscape(value.get(attribute1),True)
                _this1 = self.output
                s1 = Std.string(input)
                _this1.b.write(s1)
                self.output.b.write("\"")
            if self.hasChildren(value):
                self.output.b.write(">")
                if self.pretty:
                    self.output.b.write("\n")
                if ((value.nodeType != Xml.Document) and ((value.nodeType != Xml.Element))):
                    raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
                _g_current = 0
                _g_array = value.children
                while (_g_current < len(_g_array)):
                    child = _g_current
                    _g_current = (_g_current + 1)
                    child1 = (_g_array[child] if child >= 0 and child < len(_g_array) else None)
                    self.writeNode(child1,((("null" if tabs is None else tabs) + "\t") if (self.pretty) else tabs))
                _this = self.output
                s = Std.string((("null" if tabs is None else tabs) + "</"))
                _this.b.write(s)
                if (value.nodeType != Xml.Element):
                    raise haxe_Exception.thrown(("Bad node type, expected Element but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
                _this = self.output
                s = Std.string(value.nodeName)
                _this.b.write(s)
                self.output.b.write(">")
                if self.pretty:
                    self.output.b.write("\n")
            else:
                self.output.b.write("/>")
                if self.pretty:
                    self.output.b.write("\n")
        elif (_g == 1):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            nodeValue = value.nodeValue
            if (len(nodeValue) != 0):
                input = (("null" if tabs is None else tabs) + HxOverrides.stringOrNull(StringTools.htmlEscape(nodeValue)))
                _this = self.output
                s = Std.string(input)
                _this.b.write(s)
                if self.pretty:
                    self.output.b.write("\n")
        elif (_g == 2):
            _this = self.output
            s = Std.string((("null" if tabs is None else tabs) + "<![CDATA["))
            _this.b.write(s)
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _this = self.output
            s = Std.string(value.nodeValue)
            _this.b.write(s)
            self.output.b.write("]]>")
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 3):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            commentContent = value.nodeValue
            commentContent = EReg("[\n\r\t]+","g").replace(commentContent,"")
            commentContent = (("<!--" + ("null" if commentContent is None else commentContent)) + "-->")
            _this = self.output
            s = Std.string(tabs)
            _this.b.write(s)
            input = StringTools.trim(commentContent)
            _this = self.output
            s = Std.string(input)
            _this.b.write(s)
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 4):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _this = self.output
            s = Std.string((("<!DOCTYPE " + HxOverrides.stringOrNull(value.nodeValue)) + ">"))
            _this.b.write(s)
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 5):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _this = self.output
            s = Std.string((("<?" + HxOverrides.stringOrNull(value.nodeValue)) + "?>"))
            _this.b.write(s)
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 6):
            if ((value.nodeType != Xml.Document) and ((value.nodeType != Xml.Element))):
                raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
            _g_current = 0
            _g_array = value.children
            while (_g_current < len(_g_array)):
                child = _g_current
                _g_current = (_g_current + 1)
                child1 = (_g_array[child] if child >= 0 and child < len(_g_array) else None)
                self.writeNode(child1,tabs)
        else:
            pass

    def hasChildren(self,value):
        if ((value.nodeType != Xml.Document) and ((value.nodeType != Xml.Element))):
            raise haxe_Exception.thrown(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull((("null" if ((value.nodeType is None)) else _Xml_XmlType_Impl_.toString(value.nodeType))))))
        _g_current = 0
        _g_array = value.children
        while (_g_current < len(_g_array)):
            child = _g_current
            _g_current = (_g_current + 1)
            child1 = (_g_array[child] if child >= 0 and child < len(_g_array) else None)
            _g = child1.nodeType
            if ((_g == 1) or ((_g == 0))):
                return True
            elif ((_g == 3) or ((_g == 2))):
                if ((child1.nodeType == Xml.Document) or ((child1.nodeType == Xml.Element))):
                    raise haxe_Exception.thrown(("Bad node type, unexpected " + HxOverrides.stringOrNull((("null" if ((child1.nodeType is None)) else _Xml_XmlType_Impl_.toString(child1.nodeType))))))
                if (len(StringTools.ltrim(child1.nodeValue)) != 0):
                    return True
            else:
                pass
        return False

    @staticmethod
    def print(xml,pretty = None):
        if (pretty is None):
            pretty = False
        printer = haxe_xml_Printer(pretty)
        printer.writeNode(xml,"")
        return printer.output.b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.output = None
        _hx_o.pretty = None
haxe_xml_Printer._hx_class = haxe_xml_Printer
_hx_classes["haxe.xml.Printer"] = haxe_xml_Printer


class haxe_zip_Compress:
    _hx_class_name = "haxe.zip.Compress"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(s,level):
        raise haxe_exceptions_NotImplementedException("Not implemented for this platform",None,_hx_AnonObject({'fileName': "haxe/zip/Compress.hx", 'lineNumber': 39, 'className': "haxe.zip.Compress", 'methodName': "run"}))
haxe_zip_Compress._hx_class = haxe_zip_Compress
_hx_classes["haxe.zip.Compress"] = haxe_zip_Compress

class haxe_zip_Huffman(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.zip.Huffman"
    _hx_constructs = ["Found", "NeedBit", "NeedBits"]

    @staticmethod
    def Found(i):
        return haxe_zip_Huffman("Found", 0, (i,))

    @staticmethod
    def NeedBit(left,right):
        return haxe_zip_Huffman("NeedBit", 1, (left,right))

    @staticmethod
    def NeedBits(n,table):
        return haxe_zip_Huffman("NeedBits", 2, (n,table))
haxe_zip_Huffman._hx_class = haxe_zip_Huffman
_hx_classes["haxe.zip.Huffman"] = haxe_zip_Huffman


class haxe_zip_HuffTools:
    _hx_class_name = "haxe.zip.HuffTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["treeDepth", "treeCompress", "treeWalk", "treeMake", "make"]

    def __init__(self):
        pass

    def treeDepth(self,t):
        tmp = t.index
        if (tmp == 0):
            _g = t.params[0]
            return 0
        elif (tmp == 1):
            a = t.params[0]
            b = t.params[1]
            da = self.treeDepth(a)
            db = self.treeDepth(b)
            return (1 + ((da if ((da < db)) else db)))
        elif (tmp == 2):
            _g = t.params[0]
            _g = t.params[1]
            raise haxe_Exception.thrown("assert")
        else:
            pass

    def treeCompress(self,t):
        d = self.treeDepth(t)
        if (d == 0):
            return t
        if (d == 1):
            if (t.index == 1):
                a = t.params[0]
                b = t.params[1]
                return haxe_zip_Huffman.NeedBit(self.treeCompress(a),self.treeCompress(b))
            else:
                raise haxe_Exception.thrown("assert")
        size = (1 << d)
        table = list()
        _g = 0
        _g1 = size
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            table.append(haxe_zip_Huffman.Found(-1))
        self.treeWalk(table,0,0,d,t)
        return haxe_zip_Huffman.NeedBits(d,table)

    def treeWalk(self,table,p,cd,d,t):
        if (t.index == 1):
            a = t.params[0]
            b = t.params[1]
            if (d > 0):
                self.treeWalk(table,p,(cd + 1),(d - 1),a)
                self.treeWalk(table,(p | ((1 << cd))),(cd + 1),(d - 1),b)
            else:
                python_internal_ArrayImpl._set(table, p, self.treeCompress(t))
        else:
            python_internal_ArrayImpl._set(table, p, self.treeCompress(t))

    def treeMake(self,bits,maxbits,v,_hx_len):
        if (_hx_len > maxbits):
            raise haxe_Exception.thrown("Invalid huffman")
        idx = ((v << 5) | _hx_len)
        if (idx in bits.h):
            return haxe_zip_Huffman.Found(bits.h.get(idx,None))
        v = (v << 1)
        _hx_len = (_hx_len + 1)
        return haxe_zip_Huffman.NeedBit(self.treeMake(bits,maxbits,v,_hx_len),self.treeMake(bits,maxbits,(v | 1),_hx_len))

    def make(self,lengths,pos,nlengths,maxbits):
        if (nlengths == 1):
            return haxe_zip_Huffman.NeedBit(haxe_zip_Huffman.Found(0),haxe_zip_Huffman.Found(0))
        counts = list()
        tmp = list()
        if (maxbits > 32):
            raise haxe_Exception.thrown("Invalid huffman")
        _g = 0
        _g1 = maxbits
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            counts.append(0)
            tmp.append(0)
        _g = 0
        _g1 = nlengths
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p = python_internal_ArrayImpl._get(lengths, (i + pos))
            if (p >= maxbits):
                raise haxe_Exception.thrown("Invalid huffman")
            python_internal_ArrayImpl._set(counts, p, ((counts[p] if p >= 0 and p < len(counts) else None) + 1))
        code = 0
        _g = 1
        _g1 = (maxbits - 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            code = ((code + (counts[i] if i >= 0 and i < len(counts) else None)) << 1)
            python_internal_ArrayImpl._set(tmp, i, code)
        bits = haxe_ds_IntMap()
        _g = 0
        _g1 = nlengths
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            l = python_internal_ArrayImpl._get(lengths, (i + pos))
            if (l != 0):
                n = python_internal_ArrayImpl._get(tmp, (l - 1))
                python_internal_ArrayImpl._set(tmp, (l - 1), (n + 1))
                bits.set(((n << 5) | l),i)
        return self.treeCompress(haxe_zip_Huffman.NeedBit(self.treeMake(bits,maxbits,0,1),self.treeMake(bits,maxbits,1,1)))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_zip_HuffTools._hx_class = haxe_zip_HuffTools
_hx_classes["haxe.zip.HuffTools"] = haxe_zip_HuffTools


class haxe_zip__InflateImpl_Window:
    _hx_class_name = "haxe.zip._InflateImpl.Window"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "pos", "crc")
    _hx_fields = ["buffer", "pos", "crc"]
    _hx_methods = ["slide", "addBytes", "addByte", "getLastChar", "available", "checksum"]

    def __init__(self,hasCrc):
        self.crc = None
        self.buffer = haxe_io_Bytes.alloc(65536)
        self.pos = 0
        if hasCrc:
            self.crc = haxe_crypto_Adler32()

    def slide(self):
        if (self.crc is not None):
            self.crc.update(self.buffer,0,32768)
        b = haxe_io_Bytes.alloc(65536)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 - 32768)
        _hx_local_0.pos
        b.blit(0,self.buffer,32768,self.pos)
        self.buffer = b

    def addBytes(self,b,p,_hx_len):
        if ((self.pos + _hx_len) > 65536):
            self.slide()
        self.buffer.blit(self.pos,b,p,_hx_len)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + _hx_len)
        _hx_local_0.pos

    def addByte(self,c):
        if (self.pos == 65536):
            self.slide()
        self.buffer.b[self.pos] = (c & 255)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 1)
        _hx_local_1

    def getLastChar(self):
        return self.buffer.b[(self.pos - 1)]

    def available(self):
        return self.pos

    def checksum(self):
        if (self.crc is not None):
            self.crc.update(self.buffer,0,self.pos)
        return self.crc

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.pos = None
        _hx_o.crc = None
haxe_zip__InflateImpl_Window._hx_class = haxe_zip__InflateImpl_Window
_hx_classes["haxe.zip._InflateImpl.Window"] = haxe_zip__InflateImpl_Window

class haxe_zip__InflateImpl_State(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.zip._InflateImpl.State"
    _hx_constructs = ["Head", "Block", "CData", "Flat", "Crc", "Dist", "DistOne", "Done"]
haxe_zip__InflateImpl_State.Head = haxe_zip__InflateImpl_State("Head", 0, ())
haxe_zip__InflateImpl_State.Block = haxe_zip__InflateImpl_State("Block", 1, ())
haxe_zip__InflateImpl_State.CData = haxe_zip__InflateImpl_State("CData", 2, ())
haxe_zip__InflateImpl_State.Flat = haxe_zip__InflateImpl_State("Flat", 3, ())
haxe_zip__InflateImpl_State.Crc = haxe_zip__InflateImpl_State("Crc", 4, ())
haxe_zip__InflateImpl_State.Dist = haxe_zip__InflateImpl_State("Dist", 5, ())
haxe_zip__InflateImpl_State.DistOne = haxe_zip__InflateImpl_State("DistOne", 6, ())
haxe_zip__InflateImpl_State.Done = haxe_zip__InflateImpl_State("Done", 7, ())
haxe_zip__InflateImpl_State._hx_class = haxe_zip__InflateImpl_State
_hx_classes["haxe.zip._InflateImpl.State"] = haxe_zip__InflateImpl_State


class haxe_zip_InflateImpl:
    _hx_class_name = "haxe.zip.InflateImpl"
    _hx_is_interface = "False"
    __slots__ = ("nbits", "bits", "state", "isFinal", "huffman", "huffdist", "htools", "len", "dist", "needed", "output", "outpos", "input", "lengths", "window")
    _hx_fields = ["nbits", "bits", "state", "isFinal", "huffman", "huffdist", "htools", "len", "dist", "needed", "output", "outpos", "input", "lengths", "window"]
    _hx_methods = ["buildFixedHuffman", "readBytes", "getBits", "getBit", "getRevBits", "resetBits", "addBytes", "addByte", "addDistOne", "addDist", "applyHuffman", "inflateLengths", "inflateLoop"]
    _hx_statics = ["LEN_EXTRA_BITS_TBL", "LEN_BASE_VAL_TBL", "DIST_EXTRA_BITS_TBL", "DIST_BASE_VAL_TBL", "CODE_LENGTHS_POS", "FIXED_HUFFMAN", "run"]

    def __init__(self,i,header = None,crc = None):
        if (header is None):
            header = True
        if (crc is None):
            crc = True
        self.window = None
        self.lengths = None
        self.input = None
        self.outpos = None
        self.output = None
        self.needed = None
        self.dist = None
        self.len = None
        self.huffdist = None
        self.huffman = None
        self.state = None
        self.bits = None
        self.nbits = None
        self.isFinal = False
        self.htools = haxe_zip_HuffTools()
        self.huffman = self.buildFixedHuffman()
        self.huffdist = None
        self.len = 0
        self.dist = 0
        self.state = (haxe_zip__InflateImpl_State.Head if header else haxe_zip__InflateImpl_State.Block)
        self.input = i
        self.bits = 0
        self.nbits = 0
        self.needed = 0
        self.output = None
        self.outpos = 0
        self.lengths = list()
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        _this = self.lengths
        _this.append(-1)
        self.window = haxe_zip__InflateImpl_Window(crc)

    def buildFixedHuffman(self):
        if (haxe_zip_InflateImpl.FIXED_HUFFMAN is not None):
            return haxe_zip_InflateImpl.FIXED_HUFFMAN
        a = list()
        _g = 0
        while (_g < 288):
            n = _g
            _g = (_g + 1)
            a.append((8 if ((n <= 143)) else (9 if ((n <= 255)) else (7 if ((n <= 279)) else 8))))
        haxe_zip_InflateImpl.FIXED_HUFFMAN = self.htools.make(a,0,288,10)
        return haxe_zip_InflateImpl.FIXED_HUFFMAN

    def readBytes(self,b,pos,_hx_len):
        self.needed = _hx_len
        self.outpos = pos
        self.output = b
        if (_hx_len > 0):
            while self.inflateLoop():
                pass
        return (_hx_len - self.needed)

    def getBits(self,n):
        while (self.nbits < n):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.bits
            _hx_local_0.bits = (_hx_local_1 | ((self.input.readByte() << self.nbits)))
            _hx_local_0.bits
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.nbits
            _hx_local_2.nbits = (_hx_local_3 + 8)
            _hx_local_2.nbits
        b = (self.bits & ((((1 << n)) - 1)))
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.nbits
        _hx_local_4.nbits = (_hx_local_5 - n)
        _hx_local_4.nbits
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.bits
        _hx_local_6.bits = (_hx_local_7 >> n)
        _hx_local_6.bits
        return b

    def getBit(self):
        if (self.nbits == 0):
            self.nbits = 8
            self.bits = self.input.readByte()
        b = (((self.bits & 1)) == 1)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nbits
        _hx_local_0.nbits = (_hx_local_1 - 1)
        _hx_local_1
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.bits
        _hx_local_2.bits = (_hx_local_3 >> 1)
        _hx_local_2.bits
        return b

    def getRevBits(self,n):
        if (n == 0):
            return 0
        elif self.getBit():
            return ((1 << ((n - 1))) | self.getRevBits((n - 1)))
        else:
            return self.getRevBits((n - 1))

    def resetBits(self):
        self.bits = 0
        self.nbits = 0

    def addBytes(self,b,p,_hx_len):
        self.window.addBytes(b,p,_hx_len)
        self.output.blit(self.outpos,b,p,_hx_len)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.needed
        _hx_local_0.needed = (_hx_local_1 - _hx_len)
        _hx_local_0.needed
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.outpos
        _hx_local_2.outpos = (_hx_local_3 + _hx_len)
        _hx_local_2.outpos

    def addByte(self,b):
        self.window.addByte(b)
        self.output.b[self.outpos] = (b & 255)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.needed
        _hx_local_0.needed = (_hx_local_1 - 1)
        _hx_local_1
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.outpos
        _hx_local_2.outpos = (_hx_local_3 + 1)
        _hx_local_3

    def addDistOne(self,n):
        c = self.window.getLastChar()
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.addByte(c)

    def addDist(self,d,_hx_len):
        self.addBytes(self.window.buffer,(self.window.pos - d),_hx_len)

    def applyHuffman(self,h):
        tmp = h.index
        if (tmp == 0):
            n = h.params[0]
            return n
        elif (tmp == 1):
            a = h.params[0]
            b = h.params[1]
            return self.applyHuffman((b if (self.getBit()) else a))
        elif (tmp == 2):
            n = h.params[0]
            tbl = h.params[1]
            return self.applyHuffman(python_internal_ArrayImpl._get(tbl, self.getBits(n)))
        else:
            pass

    def inflateLengths(self,a,_hx_max):
        i = 0
        prev = 0
        while (i < _hx_max):
            n = self.applyHuffman(self.huffman)
            n1 = n
            if ((((((((((((((((n1 == 15) or ((n1 == 14))) or ((n1 == 13))) or ((n1 == 12))) or ((n1 == 11))) or ((n1 == 10))) or ((n1 == 9))) or ((n1 == 8))) or ((n1 == 7))) or ((n1 == 6))) or ((n1 == 5))) or ((n1 == 4))) or ((n1 == 3))) or ((n1 == 2))) or ((n1 == 1))) or ((n1 == 0))):
                prev = n
                python_internal_ArrayImpl._set(a, i, n)
                i = (i + 1)
            elif (n1 == 16):
                end = ((i + 3) + self.getBits(2))
                if (end > _hx_max):
                    raise haxe_Exception.thrown("Invalid data")
                while (i < end):
                    python_internal_ArrayImpl._set(a, i, prev)
                    i = (i + 1)
            elif (n1 == 17):
                i = (i + ((3 + self.getBits(3))))
                if (i > _hx_max):
                    raise haxe_Exception.thrown("Invalid data")
            elif (n1 == 18):
                i = (i + ((11 + self.getBits(7))))
                if (i > _hx_max):
                    raise haxe_Exception.thrown("Invalid data")
            else:
                raise haxe_Exception.thrown("Invalid data")

    def inflateLoop(self):
        tmp = self.state.index
        if (tmp == 0):
            cmf = self.input.readByte()
            cm = (cmf & 15)
            cinfo = (cmf >> 4)
            if (cm != 8):
                raise haxe_Exception.thrown("Invalid data")
            flg = self.input.readByte()
            fdict = (((flg & 32)) != 0)
            if (HxOverrides.mod(((((cmf << 8)) + flg)), 31) != 0):
                raise haxe_Exception.thrown("Invalid data")
            if fdict:
                raise haxe_Exception.thrown("Unsupported dictionary")
            self.state = haxe_zip__InflateImpl_State.Block
            return True
        elif (tmp == 1):
            self.isFinal = self.getBit()
            _g = self.getBits(2)
            if (_g == 0):
                self.len = self.input.readUInt16()
                nlen = self.input.readUInt16()
                if (nlen != ((65535 - self.len))):
                    raise haxe_Exception.thrown("Invalid data")
                self.state = haxe_zip__InflateImpl_State.Flat
                r = self.inflateLoop()
                self.resetBits()
                return r
            elif (_g == 1):
                self.huffman = self.buildFixedHuffman()
                self.huffdist = None
                self.state = haxe_zip__InflateImpl_State.CData
                return True
            elif (_g == 2):
                hlit = (self.getBits(5) + 257)
                hdist = (self.getBits(5) + 1)
                hclen = (self.getBits(4) + 4)
                _g = 0
                _g1 = hclen
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    python_internal_ArrayImpl._set(self.lengths, python_internal_ArrayImpl._get(haxe_zip_InflateImpl.CODE_LENGTHS_POS, i), self.getBits(3))
                _g = hclen
                _g1 = 19
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    python_internal_ArrayImpl._set(self.lengths, python_internal_ArrayImpl._get(haxe_zip_InflateImpl.CODE_LENGTHS_POS, i), 0)
                self.huffman = self.htools.make(self.lengths,0,19,8)
                lengths = list()
                _g = 0
                _g1 = (hlit + hdist)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    lengths.append(0)
                self.inflateLengths(lengths,(hlit + hdist))
                self.huffdist = self.htools.make(lengths,hlit,hdist,16)
                self.huffman = self.htools.make(lengths,0,hlit,16)
                self.state = haxe_zip__InflateImpl_State.CData
                return True
            else:
                raise haxe_Exception.thrown("Invalid data")
        elif (tmp == 2):
            n = self.applyHuffman(self.huffman)
            if (n < 256):
                self.addByte(n)
                return (self.needed > 0)
            elif (n == 256):
                self.state = (haxe_zip__InflateImpl_State.Crc if (self.isFinal) else haxe_zip__InflateImpl_State.Block)
                return True
            else:
                n = (n - 257)
                extra_bits = python_internal_ArrayImpl._get(haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL, n)
                if (extra_bits == -1):
                    raise haxe_Exception.thrown("Invalid data")
                self.len = (python_internal_ArrayImpl._get(haxe_zip_InflateImpl.LEN_BASE_VAL_TBL, n) + self.getBits(extra_bits))
                dist_code = (self.getRevBits(5) if ((self.huffdist is None)) else self.applyHuffman(self.huffdist))
                extra_bits = python_internal_ArrayImpl._get(haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL, dist_code)
                if (extra_bits == -1):
                    raise haxe_Exception.thrown("Invalid data")
                self.dist = (python_internal_ArrayImpl._get(haxe_zip_InflateImpl.DIST_BASE_VAL_TBL, dist_code) + self.getBits(extra_bits))
                if (self.dist > self.window.available()):
                    raise haxe_Exception.thrown("Invalid data")
                self.state = (haxe_zip__InflateImpl_State.DistOne if ((self.dist == 1)) else haxe_zip__InflateImpl_State.Dist)
                return True
        elif (tmp == 3):
            rlen = (self.len if ((self.len < self.needed)) else self.needed)
            _hx_bytes = self.input.read(rlen)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.len
            _hx_local_1.len = (_hx_local_2 - rlen)
            _hx_local_1.len
            self.addBytes(_hx_bytes,0,rlen)
            if (self.len == 0):
                self.state = (haxe_zip__InflateImpl_State.Crc if (self.isFinal) else haxe_zip__InflateImpl_State.Block)
            return (self.needed > 0)
        elif (tmp == 4):
            calc = self.window.checksum()
            if (calc is None):
                self.state = haxe_zip__InflateImpl_State.Done
                return True
            crc = haxe_crypto_Adler32.read(self.input)
            if (not calc.equals(crc)):
                raise haxe_Exception.thrown("Invalid CRC")
            self.state = haxe_zip__InflateImpl_State.Done
            return True
        elif (tmp == 5):
            while ((self.len > 0) and ((self.needed > 0))):
                rdist = (self.len if ((self.len < self.dist)) else self.dist)
                rlen = (self.needed if ((self.needed < rdist)) else rdist)
                self.addDist(self.dist,rlen)
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.len
                _hx_local_3.len = (_hx_local_4 - rlen)
                _hx_local_3.len
            if (self.len == 0):
                self.state = haxe_zip__InflateImpl_State.CData
            return (self.needed > 0)
        elif (tmp == 6):
            rlen = (self.len if ((self.len < self.needed)) else self.needed)
            self.addDistOne(rlen)
            _hx_local_5 = self
            _hx_local_6 = _hx_local_5.len
            _hx_local_5.len = (_hx_local_6 - rlen)
            _hx_local_5.len
            if (self.len == 0):
                self.state = haxe_zip__InflateImpl_State.CData
            return (self.needed > 0)
        elif (tmp == 7):
            return False
        else:
            pass

    @staticmethod
    def run(i,bufsize = None):
        if (bufsize is None):
            bufsize = 65536
        buf = haxe_io_Bytes.alloc(bufsize)
        output = haxe_io_BytesBuffer()
        inflate = haxe_zip_InflateImpl(i)
        while True:
            _hx_len = inflate.readBytes(buf,0,bufsize)
            if ((_hx_len < 0) or ((_hx_len > buf.length))):
                raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
            output.b.extend(buf.b[0:_hx_len])
            if (_hx_len < bufsize):
                break
        return output.getBytes()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nbits = None
        _hx_o.bits = None
        _hx_o.state = None
        _hx_o.isFinal = None
        _hx_o.huffman = None
        _hx_o.huffdist = None
        _hx_o.htools = None
        _hx_o.len = None
        _hx_o.dist = None
        _hx_o.needed = None
        _hx_o.output = None
        _hx_o.outpos = None
        _hx_o.input = None
        _hx_o.lengths = None
        _hx_o.window = None
haxe_zip_InflateImpl._hx_class = haxe_zip_InflateImpl
_hx_classes["haxe.zip.InflateImpl"] = haxe_zip_InflateImpl


class haxe_zip_Uncompress:
    _hx_class_name = "haxe.zip.Uncompress"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(src,bufsize = None):
        return haxe_zip_InflateImpl.run(haxe_io_BytesInput(src),bufsize)
haxe_zip_Uncompress._hx_class = haxe_zip_Uncompress
_hx_classes["haxe.zip.Uncompress"] = haxe_zip_Uncompress


class hxd_BitmapInnerDataImpl:
    _hx_class_name = "hxd.BitmapInnerDataImpl"
    _hx_is_interface = "False"
    __slots__ = ("pixels", "width", "height")
    _hx_fields = ["pixels", "width", "height"]

    def __init__(self):
        self.height = None
        self.width = None
        self.pixels = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pixels = None
        _hx_o.width = None
        _hx_o.height = None
hxd_BitmapInnerDataImpl._hx_class = hxd_BitmapInnerDataImpl
_hx_classes["hxd.BitmapInnerDataImpl"] = hxd_BitmapInnerDataImpl


class hxd_BitmapData:
    _hx_class_name = "hxd.BitmapData"
    _hx_is_interface = "False"
    __slots__ = ("data",)
    _hx_fields = ["data"]
    _hx_methods = ["clear", "fill", "draw", "drawScaled", "line", "dispose", "clone", "sub", "lock", "unlock", "getPixel", "setPixel", "get_width", "get_height", "getPixels", "setPixels", "toNative", "toPNG"]
    _hx_statics = ["notImplemented", "fromNative"]

    def __init__(self,width,height):
        self.data = None
        if (not (((width == -101) and ((height == -102))))):
            self.data = hxd_BitmapInnerDataImpl()
            this1 = [None]*(width * height)
            self.data.pixels = this1
            self.data.width = width
            self.data.height = height

    def clear(self,color):
        self.fill(0,0,self.data.width,self.data.height,color)

    def fill(self,x,y,width,height,color):
        if (x < 0):
            width = (width + x)
            x = 0
        if (y < 0):
            height = (height + y)
            y = 0
        if ((x + width) > self.data.width):
            width = (self.data.width - x)
        if ((y + height) > self.data.height):
            height = (self.data.height - y)
        _g = 0
        _g1 = height
        while (_g < _g1):
            dy = _g
            _g = (_g + 1)
            p = (x + ((((y + dy)) * self.data.width)))
            _g2 = 0
            _g3 = width
            while (_g2 < _g3):
                dx = _g2
                _g2 = (_g2 + 1)
                index = p
                p = (p + 1)
                self.data.pixels[index] = color

    def draw(self,x,y,src,srcX,srcY,width,height,blendMode = None):
        raise haxe_Exception.thrown("Not implemented")

    def drawScaled(self,x,y,width,height,src,srcX,srcY,srcWidth,srcHeight,blendMode = None,smooth = None):
        if (smooth is None):
            smooth = True
        if (blendMode is None):
            blendMode = h2d_BlendMode.Alpha
        raise haxe_Exception.thrown("Not implemented")

    def line(self,x0,y0,x1,y1,color):
        dx = (x1 - x0)
        dy = (y1 - y0)
        if (dx == 0):
            if (y1 < y0):
                tmp = y0
                y0 = y1
                y1 = tmp
            if (y0 < 0):
                y0 = 0
            if (y1 > ((self.data.height - 1))):
                y1 = (self.data.height - 1)
            _g = y0
            _g1 = (y1 + 1)
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                self.setPixel(x0,y,color)
        elif (dy == 0):
            if (x1 < x0):
                tmp = x0
                x0 = x1
                x1 = tmp
            if (x0 < 0):
                x0 = 0
            if (x1 > ((self.data.width - 1))):
                x1 = (self.data.width - 1)
            _g = x0
            _g1 = (x1 + 1)
            while (_g < _g1):
                x = _g
                _g = (_g + 1)
                self.setPixel(x,y0,color)
        else:
            sx = None
            sy = None
            clip_x0 = None
            clip_y0 = None
            clip_x1 = None
            clip_y1 = None
            if (x0 < x1):
                if ((x0 >= self.data.width) or ((x1 < 0))):
                    return
                sx = 1
                clip_x0 = 0
                clip_x1 = (self.data.width - 1)
            else:
                if ((x1 >= self.data.width) or ((x0 < 0))):
                    return
                sx = -1
                x1 = -x1
                x0 = -x0
                clip_x0 = (1 - self.data.width)
                clip_x1 = 0
            if (y0 < y1):
                if ((y0 >= self.data.height) or ((y1 < 0))):
                    return
                sy = 1
                clip_y0 = 0
                clip_y1 = (self.data.height - 1)
            else:
                if ((y1 >= self.data.width) or ((y0 < 0))):
                    return
                sy = -1
                y1 = -y1
                y0 = -y0
                clip_y0 = (1 - self.data.height)
                clip_y1 = 0
            dx = (x1 - x0)
            dy = (y1 - y0)
            d2x = (dx << 1)
            d2y = (dy << 1)
            x = x0
            y = y0
            if (dx >= dy):
                delta = (d2y - dx)
                tracing_can_start = False
                if (y0 < clip_y0):
                    temp = d2x
                    temp = ((temp * ((clip_y0 - y0))) - dx)
                    xinc = (temp / d2y)
                    x2 = None
                    try:
                        x2 = int(xinc)
                    except BaseException as _g:
                        None
                        x2 = None
                    x = (x + x2)
                    if (x > clip_x1):
                        return
                    if (x >= clip_x0):
                        temp = (temp - ((xinc * d2y)))
                        delta1 = None
                        try:
                            delta1 = int(temp)
                        except BaseException as _g:
                            None
                            delta1 = None
                        delta = (delta - ((delta1 + dx)))
                        y = clip_y0
                        if (temp > 0):
                            x = (x + 1)
                            delta = (delta + d2y)
                        tracing_can_start = True
                if ((not tracing_can_start) and ((x0 < clip_x0))):
                    temp = d2y
                    temp = (temp * ((clip_x0 - x0)))
                    yinc = (temp / d2x)
                    y2 = None
                    try:
                        y2 = int(yinc)
                    except BaseException as _g:
                        None
                        y2 = None
                    y = (y + y2)
                    temp = HxOverrides.modf(temp, d2x)
                    if ((y > clip_y1) or (((y == clip_y1) and ((temp > dx))))):
                        return
                    x = clip_x0
                    delta1 = None
                    try:
                        delta1 = int(temp)
                    except BaseException as _g:
                        None
                        delta1 = None
                    delta = (delta + delta1)
                    if (temp >= dx):
                        y = (y + 1)
                        delta = (delta - d2x)
                xend = x1
                if (y1 > clip_y1):
                    temp = d2x
                    temp = ((temp * ((clip_y1 - y1))) + dx)
                    xinc = (temp / d2y)
                    xend1 = None
                    try:
                        xend1 = int(xinc)
                    except BaseException as _g:
                        None
                        xend1 = None
                    xend = (xend + xend1)
                    if ((temp - ((xinc * d2y))) == 0):
                        xend = (xend - 1)
                if (xend > clip_x1):
                    xend = (clip_x1 + 1)
                else:
                    xend = (xend + 1)
                if (sx == -1):
                    x = -x
                    xend = -xend
                if (sy == -1):
                    y = -y
                d2x = (d2x - d2y)
                while (x != xend):
                    self.setPixel(x,y,color)
                    if (delta >= 0):
                        y = (y + sy)
                        delta = (delta - d2x)
                    else:
                        delta = (delta + d2y)
                    x = (x + sx)
            else:
                delta = (d2x - dy)
                tracing_can_start = False
                if (x0 < clip_x0):
                    temp = d2y
                    temp = ((temp * ((clip_x0 - x0))) - dy)
                    yinc = (temp / d2x)
                    y2 = None
                    try:
                        y2 = int(yinc)
                    except BaseException as _g:
                        None
                        y2 = None
                    y = (y + y2)
                    if (y > clip_y1):
                        return
                    if (y >= clip_y0):
                        temp = (temp - ((yinc * d2x)))
                        delta1 = None
                        try:
                            delta1 = int(temp)
                        except BaseException as _g:
                            None
                            delta1 = None
                        delta = (delta - ((delta1 + dy)))
                        x = clip_x0
                        if (temp > 0):
                            y = (y + 1)
                            delta = (delta + d2x)
                        tracing_can_start = True
                if ((not tracing_can_start) and ((y0 < clip_y0))):
                    temp = d2x
                    temp = (temp * ((clip_y0 - y0)))
                    xinc = (temp / d2y)
                    x2 = None
                    try:
                        x2 = int(xinc)
                    except BaseException as _g:
                        None
                        x2 = None
                    x = (x + x2)
                    temp = HxOverrides.modf(temp, d2y)
                    if ((x > clip_x1) or (((x == clip_x1) and ((temp > dy))))):
                        return
                    y = clip_y0
                    delta1 = None
                    try:
                        delta1 = int(temp)
                    except BaseException as _g:
                        None
                        delta1 = None
                    delta = (delta + delta1)
                    if (temp >= dy):
                        x = (x + 1)
                        delta = (delta - d2y)
                yend = y1
                if (x1 > clip_x1):
                    temp = d2y
                    temp = ((temp * ((clip_x1 - x1))) + dy)
                    yinc = (temp / d2x)
                    yend1 = None
                    try:
                        yend1 = int(yinc)
                    except BaseException as _g:
                        None
                        yend1 = None
                    yend = (yend + yend1)
                    if ((temp - ((yinc * d2x))) == 0):
                        yend = (yend - 1)
                if (yend > clip_y1):
                    yend = (clip_y1 + 1)
                else:
                    yend = (yend + 1)
                if (sx == -1):
                    x = -x
                if (sy == -1):
                    y = -y
                    yend = -yend
                d2y = (d2y - d2x)
                while (y != yend):
                    self.setPixel(x,y,color)
                    if (delta >= 0):
                        x = (x + sx)
                        delta = (delta - d2y)
                    else:
                        delta = (delta + d2x)
                    y = (y + sy)

    def dispose(self):
        self.data = None

    def clone(self):
        return self.sub(0,0,self.data.width,self.data.height)

    def sub(self,x,y,w,h):
        if ((((((x < 0) or ((y < 0))) or ((w < 0))) or ((h < 0))) or (((x + w) > self.data.width))) or (((y + h) > self.data.height))):
            raise haxe_Exception.thrown("Outside bounds")
        b = hxd_BitmapInnerDataImpl()
        b.width = w
        b.height = h
        this1 = [None]*(w * h)
        b.pixels = this1
        _g = 0
        _g1 = h
        while (_g < _g1):
            dy = _g
            _g = (_g + 1)
            haxe_ds__Vector_Vector_Impl_.blit(self.data.pixels,(x + ((((y + dy)) * self.data.width))),b.pixels,(dy * w),w)
        return hxd_BitmapData.fromNative(b)

    def lock(self):
        pass

    def unlock(self):
        pass

    def getPixel(self,x,y):
        if ((((x >= 0) and ((y >= 0))) and ((x < self.data.width))) and ((y < self.data.height))):
            return self.data.pixels[(x + ((y * self.data.width)))]
        else:
            return 0

    def setPixel(self,x,y,c):
        if ((((x >= 0) and ((y >= 0))) and ((x < self.data.width))) and ((y < self.data.height))):
            self.data.pixels[(x + ((y * self.data.width)))] = c

    def get_width(self):
        return self.data.width

    def get_height(self):
        return self.data.height

    def getPixels(self):
        out = haxe_io_Bytes.alloc(((self.data.width * self.data.height) * 4))
        _g = 0
        _g1 = (self.data.width * self.data.height)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = self.data.pixels[i]
            out.b[pos] = (v & 255)
            out.b[(pos + 1)] = ((v >> 8) & 255)
            out.b[(pos + 2)] = ((v >> 16) & 255)
            out.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        return hxd_Pixels(self.data.width,self.data.height,out,hxd_PixelFormat.BGRA)

    def setPixels(self,pixels):
        if ((pixels.width != self.data.width) or ((pixels.height != self.data.height))):
            raise haxe_Exception.thrown("Invalid pixels size")
        pixels.setFlip(False)
        pixels.convert(hxd_PixelFormat.BGRA)
        src = pixels.bytes
        _g = 0
        _g1 = (self.data.width * self.data.height)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            this1 = self.data.pixels
            pos = (i << 2)
            v = (((src.b[pos] | ((src.b[(pos + 1)] << 8))) | ((src.b[(pos + 2)] << 16))) | ((src.b[(pos + 3)] << 24)))
            val = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            this1[i] = val

    def toNative(self):
        return self.data

    def toPNG(self):
        pixels = self.getPixels()
        png = pixels.toPNG()
        pixels.dispose()
        return png

    @staticmethod
    def notImplemented():
        raise haxe_Exception.thrown("Not implemented")

    @staticmethod
    def fromNative(data):
        b = hxd_BitmapData(-101,-102)
        b.data = data
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
hxd_BitmapData._hx_class = hxd_BitmapData
_hx_classes["hxd.BitmapData"] = hxd_BitmapData


class hxd_Charset:
    _hx_class_name = "hxd.Charset"
    _hx_is_interface = "False"
    __slots__ = ("map",)
    _hx_fields = ["map"]
    _hx_methods = ["resolveChar", "isCJK", "isSpace", "isBreakChar", "isComplementChar"]
    _hx_statics = ["ASCII", "LATIN1", "CYRILLIC", "POLISH", "TURKISH", "JP_KANA", "UNICODE_SPECIALS", "DEFAULT_CHARS", "complementChars", "inst", "getDefault"]

    def __init__(self):
        self.map = None
        _gthis = self
        self.map = haxe_ds_IntMap()
        _g = 0
        while (_g < 94):
            i = _g
            _g = (_g + 1)
            _gthis.map.set((65281 + i),(33 + i))
        _g = 192
        _g1 = 199
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,65)
        _g = 224
        _g1 = 231
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,97)
        _g = 200
        _g1 = 204
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,69)
        _g = 232
        _g1 = 236
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,101)
        _g = 204
        _g1 = 208
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,73)
        _g = 236
        _g1 = 240
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,105)
        _g = 210
        _g1 = 215
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,79)
        _g = 242
        _g1 = 247
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,111)
        _g = 217
        _g1 = 221
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,85)
        _g = 249
        _g1 = 253
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _gthis.map.set(i,117)
        _gthis.map.set(199,67)
        _gthis.map.set(231,67)
        _gthis.map.set(208,68)
        _gthis.map.set(222,100)
        _gthis.map.set(209,78)
        _gthis.map.set(241,110)
        _gthis.map.set(221,89)
        _gthis.map.set(253,121)
        _gthis.map.set(255,121)
        _gthis.map.set(8364,69)
        _gthis.map.set(12288,32)
        _gthis.map.set(160,32)
        _gthis.map.set(171,34)
        _gthis.map.set(187,34)
        _gthis.map.set(8220,34)
        _gthis.map.set(8221,34)
        _gthis.map.set(8216,39)
        _gthis.map.set(8217,39)
        _gthis.map.set(180,39)
        _gthis.map.set(8216,39)
        _gthis.map.set(8249,60)
        _gthis.map.set(8250,62)
        _gthis.map.set(8211,45)

    def resolveChar(self,code,glyphs):
        c = code
        while (c is not None):
            g = glyphs.h.get(c,None)
            if (g is not None):
                return g
            c = self.map.h.get(c,None)
        return None

    def isCJK(self,code):
        if (not ((((code >= 11904) and ((code <= 42191))) or (((code >= 63744) and ((code <= 64255))))))):
            if (code >= 131072):
                return (code <= 262141)
            else:
                return False
        else:
            return True

    def isSpace(self,code):
        if (code != 32):
            return (code == 12288)
        else:
            return True

    def isBreakChar(self,code):
        if (not self.isSpace(code)):
            return self.isCJK(code)
        else:
            return True

    def isComplementChar(self,code):
        return (code in hxd_Charset.complementChars.h)
    inst = None

    @staticmethod
    def getDefault():
        if (hxd_Charset.inst is None):
            hxd_Charset.inst = hxd_Charset()
        return hxd_Charset.inst

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.map = None
hxd_Charset._hx_class = hxd_Charset
_hx_classes["hxd.Charset"] = hxd_Charset

class hxd_Cursor(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.Cursor"
    _hx_constructs = ["Default", "Button", "Move", "TextInput", "Hide", "Custom", "Callback"]

    @staticmethod
    def Custom(custom):
        return hxd_Cursor("Custom", 5, (custom,))

    @staticmethod
    def Callback(f):
        return hxd_Cursor("Callback", 6, (f,))
hxd_Cursor.Default = hxd_Cursor("Default", 0, ())
hxd_Cursor.Button = hxd_Cursor("Button", 1, ())
hxd_Cursor.Move = hxd_Cursor("Move", 2, ())
hxd_Cursor.TextInput = hxd_Cursor("TextInput", 3, ())
hxd_Cursor.Hide = hxd_Cursor("Hide", 4, ())
hxd_Cursor._hx_class = hxd_Cursor
_hx_classes["hxd.Cursor"] = hxd_Cursor


class hxd_CustomCursor:
    _hx_class_name = "hxd.CustomCursor"
    _hx_is_interface = "False"
    __slots__ = ("frames", "speed", "offsetX", "offsetY", "alloc")
    _hx_fields = ["frames", "speed", "offsetX", "offsetY", "alloc"]
    _hx_methods = ["dispose"]

    def __init__(self,frames,speed,offsetX,offsetY):
        self.alloc = None
        self.frames = frames
        self.speed = speed
        self.offsetX = offsetX
        self.offsetY = offsetY

    def dispose(self):
        _g = 0
        _g1 = self.frames
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f.data = None
        self.frames = []
        if (self.alloc is not None):
            raise haxe_Exception.thrown("TODO")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.frames = None
        _hx_o.speed = None
        _hx_o.offsetX = None
        _hx_o.offsetY = None
        _hx_o.alloc = None
hxd_CustomCursor._hx_class = hxd_CustomCursor
_hx_classes["hxd.CustomCursor"] = hxd_CustomCursor

class hxd_EventKind(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.EventKind"
    _hx_constructs = ["EPush", "ERelease", "EMove", "EOver", "EOut", "EWheel", "EFocus", "EFocusLost", "EKeyDown", "EKeyUp", "EReleaseOutside", "ETextInput", "ECheck"]
hxd_EventKind.EPush = hxd_EventKind("EPush", 0, ())
hxd_EventKind.ERelease = hxd_EventKind("ERelease", 1, ())
hxd_EventKind.EMove = hxd_EventKind("EMove", 2, ())
hxd_EventKind.EOver = hxd_EventKind("EOver", 3, ())
hxd_EventKind.EOut = hxd_EventKind("EOut", 4, ())
hxd_EventKind.EWheel = hxd_EventKind("EWheel", 5, ())
hxd_EventKind.EFocus = hxd_EventKind("EFocus", 6, ())
hxd_EventKind.EFocusLost = hxd_EventKind("EFocusLost", 7, ())
hxd_EventKind.EKeyDown = hxd_EventKind("EKeyDown", 8, ())
hxd_EventKind.EKeyUp = hxd_EventKind("EKeyUp", 9, ())
hxd_EventKind.EReleaseOutside = hxd_EventKind("EReleaseOutside", 10, ())
hxd_EventKind.ETextInput = hxd_EventKind("ETextInput", 11, ())
hxd_EventKind.ECheck = hxd_EventKind("ECheck", 12, ())
hxd_EventKind._hx_class = hxd_EventKind
_hx_classes["hxd.EventKind"] = hxd_EventKind


class hxd_Event:
    _hx_class_name = "hxd.Event"
    _hx_is_interface = "False"
    __slots__ = ("kind", "relX", "relY", "relZ", "propagate", "cancel", "button", "touchId", "keyCode", "charCode", "wheelDelta")
    _hx_fields = ["kind", "relX", "relY", "relZ", "propagate", "cancel", "button", "touchId", "keyCode", "charCode", "wheelDelta"]
    _hx_methods = ["toString"]

    def __init__(self,k,x = None,y = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        self.wheelDelta = None
        self.charCode = None
        self.keyCode = None
        self.touchId = None
        self.cancel = None
        self.propagate = None
        self.relZ = None
        self.button = 0
        self.kind = k
        self.relX = x
        self.relY = y

    def toString(self):
        tmp = (Std.string(self.kind) + "[")
        x = self.relX
        tmp1 = None
        try:
            tmp1 = int(x)
        except BaseException as _g:
            None
            tmp1 = None
        tmp2 = ((("null" if tmp is None else tmp) + Std.string(tmp1)) + ",")
        x = self.relY
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        tmp1 = ((("null" if tmp2 is None else tmp2) + Std.string(tmp)) + "]")
        tmp = None
        tmp2 = self.kind.index
        if (tmp2 == 5):
            tmp = (",wheelDelta=" + Std.string(self.wheelDelta))
        elif ((((((tmp2 == 12) or ((tmp2 == 7))) or ((tmp2 == 6))) or ((tmp2 == 4))) or ((tmp2 == 3))) or ((tmp2 == 2))):
            tmp = ""
        elif ((tmp2 == 9) or ((tmp2 == 8))):
            tmp = (",keyCode=" + Std.string(self.keyCode))
        elif (((tmp2 == 10) or ((tmp2 == 1))) or ((tmp2 == 0))):
            tmp = (",button=" + Std.string(self.button))
        elif (tmp2 == 11):
            tmp = (",charCode=" + Std.string(self.charCode))
        else:
            pass
        return (("null" if tmp1 is None else tmp1) + ("null" if tmp is None else tmp))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.kind = None
        _hx_o.relX = None
        _hx_o.relY = None
        _hx_o.relZ = None
        _hx_o.propagate = None
        _hx_o.cancel = None
        _hx_o.button = None
        _hx_o.touchId = None
        _hx_o.keyCode = None
        _hx_o.charCode = None
        _hx_o.wheelDelta = None
hxd_Event._hx_class = hxd_Event
_hx_classes["hxd.Event"] = hxd_Event


class hxd_File:
    _hx_class_name = "hxd.File"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["browse", "saveAs", "exists", "delete", "listDirectory", "getBytes", "saveBytes", "load", "createDirectory", "applicationPath"]

    @staticmethod
    def browse(onSelect,options = None):
        if (options is None):
            options = _hx_AnonObject({})
        raise haxe_Exception.thrown("Not supported")

    @staticmethod
    def saveAs(dataContent,options = None):
        if (options is None):
            options = _hx_AnonObject({})
        raise haxe_Exception.thrown("Not supported")

    @staticmethod
    def exists(path):
        return sys_FileSystem.exists(path)

    @staticmethod
    def delete(path):
        try:
            sys_FileSystem.deleteFile(path)
        except BaseException as _g:
            None

    @staticmethod
    def listDirectory(path):
        return sys_FileSystem.readDirectory(path)

    @staticmethod
    def getBytes(path):
        return sys_io_File.getBytes(path)

    @staticmethod
    def saveBytes(path,data):
        sys_io_File.saveBytes(path,data)

    @staticmethod
    def load(path,onLoad,onError = None):
        if (onError is None):
            def _hx_local_0(_):
                pass
            onError = _hx_local_0
        content = None
        try:
            content = sys_io_File.getBytes(path)
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            if (onError is not None):
                onError(("" + Std.string(e)))
            return
        onLoad(content)

    @staticmethod
    def createDirectory(path):
        sys_FileSystem.createDirectory(path)

    @staticmethod
    def applicationPath():
        raise haxe_Exception.thrown("Not supported")
hxd_File._hx_class = hxd_File
_hx_classes["hxd.File"] = hxd_File


class hxd__FloatBuffer_InnerIterator:
    _hx_class_name = "hxd._FloatBuffer.InnerIterator"
    _hx_is_interface = "False"
    __slots__ = ("b", "len", "pos")
    _hx_fields = ["b", "len", "pos"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,b):
        self.pos = None
        self.len = None
        self.b = b
        self.len = len(self.b)
        self.pos = 0

    def hasNext(self):
        return (self.pos < self.len)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.b, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.len = None
        _hx_o.pos = None
hxd__FloatBuffer_InnerIterator._hx_class = hxd__FloatBuffer_InnerIterator
_hx_classes["hxd._FloatBuffer.InnerIterator"] = hxd__FloatBuffer_InnerIterator


class hxd__FloatBuffer_FloatBuffer_Impl_:
    _hx_class_name = "hxd._FloatBuffer.FloatBuffer_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "push", "grow", "resize", "arrayRead", "arrayWrite", "getNative", "iterator", "get_length"]
    length = None

    @staticmethod
    def _new(length = None):
        if (length is None):
            length = 0
        this1 = list()
        if (length > 0):
            if (length > len(this1)):
                python_internal_ArrayImpl._set(this1, (length - 1), 0.)
        return this1

    @staticmethod
    def push(this1,v):
        this1.append(v)

    @staticmethod
    def grow(this1,v):
        if (v > len(this1)):
            python_internal_ArrayImpl._set(this1, (v - 1), 0.)

    @staticmethod
    def resize(this1,v):
        if (len(this1) > v):
            _hx_len = (len(this1) - v)
            pos = v
            if (pos < 0):
                pos = (len(this1) + pos)
            if (pos < 0):
                pos = 0
            res = this1[pos:(pos + _hx_len)]
            del this1[pos:(pos + _hx_len)]
        elif (v > len(this1)):
            python_internal_ArrayImpl._set(this1, (v - 1), 0.)

    @staticmethod
    def arrayRead(this1,key):
        return (this1[key] if key >= 0 and key < len(this1) else None)

    @staticmethod
    def arrayWrite(this1,key,value):
        def _hx_local_1():
            def _hx_local_0():
                python_internal_ArrayImpl._set(this1, key, value)
                return (this1[key] if key >= 0 and key < len(this1) else None)
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def getNative(this1):
        return this1

    @staticmethod
    def iterator(this1):
        return hxd__FloatBuffer_InnerIterator(this1)

    @staticmethod
    def get_length(this1):
        return len(this1)
hxd__FloatBuffer_FloatBuffer_Impl_._hx_class = hxd__FloatBuffer_FloatBuffer_Impl_
_hx_classes["hxd._FloatBuffer.FloatBuffer_Impl_"] = hxd__FloatBuffer_FloatBuffer_Impl_


class hxd__IndexBuffer_InnerIterator:
    _hx_class_name = "hxd._IndexBuffer.InnerIterator"
    _hx_is_interface = "False"
    __slots__ = ("b", "len", "pos")
    _hx_fields = ["b", "len", "pos"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,b):
        self.pos = None
        self.len = None
        self.b = b
        self.len = len(self.b)
        self.pos = 0

    def hasNext(self):
        return (self.pos < self.len)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.b, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.len = None
        _hx_o.pos = None
hxd__IndexBuffer_InnerIterator._hx_class = hxd__IndexBuffer_InnerIterator
_hx_classes["hxd._IndexBuffer.InnerIterator"] = hxd__IndexBuffer_InnerIterator


class hxd__IndexBuffer_IndexBuffer_Impl_:
    _hx_class_name = "hxd._IndexBuffer.IndexBuffer_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "push", "grow", "arrayRead", "arrayWrite", "getNative", "iterator", "get_length"]
    length = None

    @staticmethod
    def _new(length = None):
        if (length is None):
            length = 0
        this1 = list()
        if (length > 0):
            if (length > len(this1)):
                python_internal_ArrayImpl._set(this1, (length - 1), 0)
        return this1

    @staticmethod
    def push(this1,v):
        this1.append(v)

    @staticmethod
    def grow(this1,v):
        if (v > len(this1)):
            python_internal_ArrayImpl._set(this1, (v - 1), 0)

    @staticmethod
    def arrayRead(this1,key):
        return (this1[key] if key >= 0 and key < len(this1) else None)

    @staticmethod
    def arrayWrite(this1,key,value):
        def _hx_local_1():
            def _hx_local_0():
                python_internal_ArrayImpl._set(this1, key, value)
                return (this1[key] if key >= 0 and key < len(this1) else None)
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def getNative(this1):
        return this1

    @staticmethod
    def iterator(this1):
        return hxd__IndexBuffer_InnerIterator(this1)

    @staticmethod
    def get_length(this1):
        return len(this1)
hxd__IndexBuffer_IndexBuffer_Impl_._hx_class = hxd__IndexBuffer_IndexBuffer_Impl_
_hx_classes["hxd._IndexBuffer.IndexBuffer_Impl_"] = hxd__IndexBuffer_IndexBuffer_Impl_


class hxd_Key:
    _hx_class_name = "hxd.Key"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["BACKSPACE", "TAB", "ENTER", "SHIFT", "CTRL", "ALT", "ESCAPE", "SPACE", "PGUP", "PGDOWN", "END", "HOME", "LEFT", "UP", "RIGHT", "DOWN", "INSERT", "DELETE", "QWERTY_EQUALS", "QWERTY_MINUS", "QWERTY_TILDE", "QWERTY_BRACKET_LEFT", "QWERTY_BRACKET_RIGHT", "QWERTY_SEMICOLON", "QWERTY_QUOTE", "QWERTY_BACKSLASH", "QWERTY_COMMA", "QWERTY_PERIOD", "QWERTY_SLASH", "INTL_BACKSLASH", "LEFT_WINDOW_KEY", "RIGHT_WINDOW_KEY", "CONTEXT_MENU", "PAUSE_BREAK", "CAPS_LOCK", "NUM_LOCK", "SCROLL_LOCK", "NUMBER_0", "NUMBER_1", "NUMBER_2", "NUMBER_3", "NUMBER_4", "NUMBER_5", "NUMBER_6", "NUMBER_7", "NUMBER_8", "NUMBER_9", "NUMPAD_0", "NUMPAD_1", "NUMPAD_2", "NUMPAD_3", "NUMPAD_4", "NUMPAD_5", "NUMPAD_6", "NUMPAD_7", "NUMPAD_8", "NUMPAD_9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "NUMPAD_MULT", "NUMPAD_ADD", "NUMPAD_ENTER", "NUMPAD_SUB", "NUMPAD_DOT", "NUMPAD_DIV", "MOUSE_LEFT", "MOUSE_RIGHT", "MOUSE_MIDDLE", "MOUSE_BACK", "MOUSE_FORWARD", "MOUSE_WHEEL_UP", "MOUSE_WHEEL_DOWN", "LOC_LEFT", "LOC_RIGHT", "LSHIFT", "RSHIFT", "LCTRL", "RCTRL", "LALT", "RALT", "initDone", "keyPressed", "ALLOW_KEY_REPEAT", "isDown", "getFrame", "isPressed", "isReleased", "initialize", "dispose", "onEvent", "getKeyName"]

    @staticmethod
    def isDown(code):
        return (python_internal_ArrayImpl._get(hxd_Key.keyPressed, code) > 0)

    @staticmethod
    def getFrame():
        return (hxd_Timer.frameCount + 2)

    @staticmethod
    def isPressed(code):
        return (python_internal_ArrayImpl._get(hxd_Key.keyPressed, code) == (((hxd_Timer.frameCount + 2) - 1)))

    @staticmethod
    def isReleased(code):
        return (python_internal_ArrayImpl._get(hxd_Key.keyPressed, code) == ((-((hxd_Timer.frameCount + 2)) + 1)))

    @staticmethod
    def initialize():
        if hxd_Key.initDone:
            hxd_Key.dispose()
        hxd_Key.initDone = True
        hxd_Key.keyPressed = []
        hxd_Window.getInstance().addEventTarget(hxd_Key.onEvent)

    @staticmethod
    def dispose():
        if hxd_Key.initDone:
            hxd_Window.getInstance().removeEventTarget(hxd_Key.onEvent)
            hxd_Key.initDone = False
            hxd_Key.keyPressed = []

    @staticmethod
    def onEvent(e):
        tmp = e.kind.index
        if (tmp == 0):
            if (e.button < 5):
                python_internal_ArrayImpl._set(hxd_Key.keyPressed, e.button, (hxd_Timer.frameCount + 2))
        elif (tmp == 1):
            if (e.button < 5):
                python_internal_ArrayImpl._set(hxd_Key.keyPressed, e.button, -((hxd_Timer.frameCount + 2)))
        elif (tmp == 5):
            python_internal_ArrayImpl._set(hxd_Key.keyPressed, (6 if ((e.wheelDelta > 0)) else 5), (hxd_Timer.frameCount + 2))
        elif (tmp == 8):
            if ((not hxd_Key.ALLOW_KEY_REPEAT) and ((python_internal_ArrayImpl._get(hxd_Key.keyPressed, e.keyCode) > 0))):
                return
            python_internal_ArrayImpl._set(hxd_Key.keyPressed, e.keyCode, (hxd_Timer.frameCount + 2))
        elif (tmp == 9):
            python_internal_ArrayImpl._set(hxd_Key.keyPressed, e.keyCode, -((hxd_Timer.frameCount + 2)))
        else:
            pass

    @staticmethod
    def getKeyName(keyCode):
        c = keyCode
        c1 = c
        if (c1 == 0):
            return "MouseLeft"
        elif (c1 == 1):
            return "MouseRight"
        elif (c1 == 2):
            return "MouseMiddle"
        elif (c1 == 3):
            return "Mouse3"
        elif (c1 == 4):
            return "Mouse4"
        elif (c1 == 8):
            return "Backspace"
        elif (c1 == 9):
            return "Tab"
        elif (c1 == 13):
            return "Enter"
        elif (c1 == 16):
            return "Shift"
        elif (c1 == 17):
            return "Ctrl"
        elif (c1 == 18):
            return "Alt"
        elif (c1 == 19):
            return "PauseBreak"
        elif (c1 == 20):
            return "CapsLock"
        elif (c1 == 27):
            return "Escape"
        elif (c1 == 32):
            return "Space"
        elif (c1 == 33):
            return "PageUp"
        elif (c1 == 34):
            return "PageDown"
        elif (c1 == 35):
            return "End"
        elif (c1 == 36):
            return "Home"
        elif (c1 == 37):
            return "Left"
        elif (c1 == 38):
            return "Up"
        elif (c1 == 39):
            return "Right"
        elif (c1 == 40):
            return "Down"
        elif (c1 == 45):
            return "Insert"
        elif (c1 == 46):
            return "Delete"
        elif (c1 == 91):
            return "LeftWindowKey"
        elif (c1 == 92):
            return "RightWindowKey"
        elif (c1 == 93):
            return "ContextMenu"
        elif (c1 == 106):
            return "NumPad*"
        elif (c1 == 107):
            return "NumPad+"
        elif (c1 == 108):
            return "NumPadEnter"
        elif (c1 == 109):
            return "NumPad-"
        elif (c1 == 110):
            return "NumPad."
        elif (c1 == 111):
            return "NumPad/"
        elif (c1 == 144):
            return "NumLock"
        elif (c1 == 145):
            return "ScrollLock"
        elif (c1 == 186):
            return "Semicolon"
        elif (c1 == 187):
            return "Equals"
        elif (c1 == 188):
            return "Comma"
        elif (c1 == 189):
            return "Minus"
        elif (c1 == 190):
            return "Period"
        elif (c1 == 191):
            return "Slash"
        elif (c1 == 192):
            return "Tilde"
        elif (c1 == 219):
            return "BracketLeft"
        elif (c1 == 220):
            return "Backslash"
        elif (c1 == 221):
            return "BacketRight"
        elif (c1 == 222):
            return "Quote"
        elif (c1 == 226):
            return "IntlBackslash"
        elif (c1 == 272):
            return "LShift"
        elif (c1 == 273):
            return "LCtrl"
        elif (c1 == 274):
            return "LAlt"
        elif (c1 == 528):
            return "RShift"
        elif (c1 == 529):
            return "RCtrl"
        elif (c1 == 530):
            return "RAlt"
        elif ((c >= 48) and ((c <= 57))):
            return ("" + Std.string(((c - 48))))
        elif ((c >= 96) and ((c <= 105))):
            return ("NumPad" + Std.string(((c - 96))))
        elif ((c >= 65) and ((c <= 90))):
            return "".join(map(chr,[((65 + c) - 65)]))
        elif ((c >= 112) and ((c <= 135))):
            return ("F" + Std.string((((c - 112) + 1))))
        else:
            return None
hxd_Key._hx_class = hxd_Key
_hx_classes["hxd.Key"] = hxd_Key


class hxd_Math:
    _hx_class_name = "hxd.Math"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["PI", "EPSILON", "get_POSITIVE_INFINITY", "get_NEGATIVE_INFINITY", "get_NaN", "isNaN", "fmt", "floor", "ceil", "round", "clamp", "pow", "cos", "sin", "tan", "acos", "asin", "atan", "sqrt", "invSqrt", "atan2", "abs", "max", "min", "iabs", "imax", "imin", "iclamp", "lerp", "lerpTime", "bitCount", "isPOT", "nextPOT", "distanceSq", "distance", "colorLerp", "angle", "angleLerp", "angleMove", "valueMove", "shuffle", "random", "srand", "b2f", "f2b", "umod", "ufmod", "degToRad", "radToDeg"]
    POSITIVE_INFINITY = None
    NEGATIVE_INFINITY = None
    NaN = None

    @staticmethod
    def get_POSITIVE_INFINITY():
        return Math.POSITIVE_INFINITY

    @staticmethod
    def get_NEGATIVE_INFINITY():
        return Math.NEGATIVE_INFINITY

    @staticmethod
    def get_NaN():
        return Math.NaN

    @staticmethod
    def isNaN(v):
        return python_lib_Math.isnan(v)

    @staticmethod
    def fmt(v):
        neg = None
        if (v < 0):
            neg = -1.0
            v = -v
        else:
            neg = 1.0
        if (python_lib_Math.isnan(v) or (not ((((v != Math.POSITIVE_INFINITY) and ((v != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(v)))))):
            return v
        x = (4 - ((((Math.NEGATIVE_INFINITY if ((v == 0.0)) else (Math.NaN if ((v < 0.0)) else python_lib_Math.log(v)))) / python_lib_Math.log(10))))
        digits = None
        try:
            digits = int(x)
        except BaseException as _g:
            None
            digits = None
        if (digits < 1):
            digits = 1
        elif (digits >= 10):
            return 0.
        exp = Math.pow(10,digits)
        v1 = ((v * exp) + .49999)
        return ((((v1 if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v1)) else Math.floor(v1)))) * neg) / exp)

    @staticmethod
    def floor(f):
        return Math.floor(f)

    @staticmethod
    def ceil(f):
        return Math.ceil(f)

    @staticmethod
    def round(f):
        return Math.floor((f + 0.5))

    @staticmethod
    def clamp(f,_hx_min = None,_hx_max = None):
        if (_hx_min is None):
            _hx_min = 0.
        if (_hx_max is None):
            _hx_max = 1.
        if (f < _hx_min):
            return _hx_min
        elif (f > _hx_max):
            return _hx_max
        else:
            return f

    @staticmethod
    def pow(v,p):
        return Math.pow(v,p)

    @staticmethod
    def cos(f):
        if ((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY))):
            return Math.NaN
        else:
            return python_lib_Math.cos(f)

    @staticmethod
    def sin(f):
        if ((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY))):
            return Math.NaN
        else:
            return python_lib_Math.sin(f)

    @staticmethod
    def tan(f):
        return Math.tan(f)

    @staticmethod
    def acos(f):
        return Math.acos(f)

    @staticmethod
    def asin(f):
        return Math.asin(f)

    @staticmethod
    def atan(f):
        return Math.atan(f)

    @staticmethod
    def sqrt(f):
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    @staticmethod
    def invSqrt(f):
        return (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))

    @staticmethod
    def atan2(dy,dx):
        return Math.atan2(dy,dx)

    @staticmethod
    def abs(f):
        if (f < 0):
            return -f
        else:
            return f

    @staticmethod
    def max(a,b):
        if (a < b):
            return b
        else:
            return a

    @staticmethod
    def min(a,b):
        if (a > b):
            return b
        else:
            return a

    @staticmethod
    def iabs(i):
        if (i < 0):
            return -i
        else:
            return i

    @staticmethod
    def imax(a,b):
        if (a < b):
            return b
        else:
            return a

    @staticmethod
    def imin(a,b):
        if (a > b):
            return b
        else:
            return a

    @staticmethod
    def iclamp(v,_hx_min,_hx_max):
        if (v < _hx_min):
            return _hx_min
        elif (v > _hx_max):
            return _hx_max
        else:
            return v

    @staticmethod
    def lerp(a,b,k):
        return (a + ((k * ((b - a)))))

    @staticmethod
    def lerpTime(a,b,k,dt):
        return (a + ((((1 - Math.pow((1 - k),(dt * hxd_Timer.wantedFPS)))) * ((b - a)))))

    @staticmethod
    def bitCount(v):
        v = (v - (((v >> 1) & 1431655765)))
        v = (((v & 858993459)) + (((v >> 2) & 858993459)))
        return (((((v + ((v >> 4))) & 252645135)) * 16843009) >> 24)

    @staticmethod
    def isPOT(v):
        return (((v & ((v - 1)))) == 0)

    @staticmethod
    def nextPOT(v):
        v = (v - 1)
        v = (v | ((v >> 1)))
        v = (v | ((v >> 2)))
        v = (v | ((v >> 4)))
        v = (v | ((v >> 8)))
        v = (v | ((v >> 16)))
        def _hx_local_8():
            def _hx_local_7():
                nonlocal v
                v = (v + 1)
                return v
            return _hx_local_7()
        return _hx_local_8()

    @staticmethod
    def distanceSq(dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        return (((dx * dx) + ((dy * dy))) + ((dz * dz)))

    @staticmethod
    def distance(dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        dz1 = dz
        if (dz1 is None):
            dz1 = 0.
        f = (((dx * dx) + ((dy * dy))) + ((dz1 * dz1)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    @staticmethod
    def colorLerp(c1,c2,k):
        a1 = HxOverrides.rshift(c1, 24)
        r1 = ((c1 >> 16) & 255)
        g1 = ((c1 >> 8) & 255)
        b1 = (c1 & 255)
        a2 = HxOverrides.rshift(c2, 24)
        r2 = ((c2 >> 16) & 255)
        g2 = ((c2 >> 8) & 255)
        b2 = (c2 & 255)
        a = None
        try:
            a = int(((a1 * ((1 - k))) + ((a2 * k))))
        except BaseException as _g:
            None
            a = None
        a1 = a
        r = None
        try:
            r = int(((r1 * ((1 - k))) + ((r2 * k))))
        except BaseException as _g:
            None
            r = None
        r1 = r
        g = None
        try:
            g = int(((g1 * ((1 - k))) + ((g2 * k))))
        except BaseException as _g:
            None
            g = None
        g1 = g
        b = None
        try:
            b = int(((b1 * ((1 - k))) + ((b2 * k))))
        except BaseException as _g:
            None
            b = None
        b1 = b
        return ((((a1 << 24) | ((r1 << 16))) | ((g1 << 8))) | b1)

    @staticmethod
    def angle(da):
        da = HxOverrides.modf(da, 6.28318530717958623)
        if (da > 3.14159265358979323):
            da = (da - 6.28318530717958623)
        elif (da <= -3.14159265358979312):
            da = (da + 6.28318530717958623)
        return da

    @staticmethod
    def angleLerp(a,b,k):
        da = (b - a)
        da = HxOverrides.modf(da, 6.28318530717958623)
        if (da > 3.14159265358979323):
            da = (da - 6.28318530717958623)
        elif (da <= -3.14159265358979312):
            da = (da + 6.28318530717958623)
        return (a + ((da * k)))

    @staticmethod
    def angleMove(a,b,_hx_max):
        da = (b - a)
        da = HxOverrides.modf(da, 6.28318530717958623)
        if (da > 3.14159265358979323):
            da = (da - 6.28318530717958623)
        elif (da <= -3.14159265358979312):
            da = (da + 6.28318530717958623)
        da1 = da
        if ((da1 > -_hx_max) and ((da1 < _hx_max))):
            return b
        else:
            return (a + ((-_hx_max if ((da1 < 0)) else _hx_max)))

    @staticmethod
    def valueMove(v,target,_hx_max):
        if (v < target):
            v = (v + _hx_max)
            if (v > target):
                v = target
        elif (v > target):
            v = (v - _hx_max)
            if (v < target):
                v = target
        return v

    @staticmethod
    def shuffle(a):
        _hx_len = len(a)
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = (0 if ((_hx_len <= 0)) else int((python_lib_Random.random() * _hx_len)))
            y = (0 if ((_hx_len <= 0)) else int((python_lib_Random.random() * _hx_len)))
            tmp = (a[x] if x >= 0 and x < len(a) else None)
            python_internal_ArrayImpl._set(a, x, (a[y] if y >= 0 and y < len(a) else None))
            python_internal_ArrayImpl._set(a, y, tmp)

    @staticmethod
    def random(_hx_max = None):
        if (_hx_max is None):
            _hx_max = 1.0
        return (python_lib_Random.random() * _hx_max)

    @staticmethod
    def srand(_hx_max = None):
        if (_hx_max is None):
            _hx_max = 1.0
        return (((python_lib_Random.random() - 0.5)) * ((_hx_max * 2)))

    @staticmethod
    def b2f(v):
        return (((v & 255)) * 0.0039215686274509803921568627451)

    @staticmethod
    def f2b(v):
        tmp = None
        try:
            tmp = int((((0. if ((v < 0.)) else (1. if ((v > 1.)) else v))) * 255.0))
        except BaseException as _g:
            None
            tmp = None
        return tmp

    @staticmethod
    def umod(value,modulo):
        r = HxOverrides.mod(value, modulo)
        if (r >= 0):
            return r
        else:
            return (r + modulo)

    @staticmethod
    def ufmod(value,modulo):
        r = HxOverrides.modf(value, modulo)
        if (r >= 0):
            return r
        else:
            return (r + modulo)

    @staticmethod
    def degToRad(deg):
        return ((deg * 3.14159265358979323) / 180.0)

    @staticmethod
    def radToDeg(rad):
        return ((rad * 180.0) / 3.14159265358979323)
hxd_Math._hx_class = hxd_Math
_hx_classes["hxd.Math"] = hxd_Math

class hxd_Flags(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.Flags"
    _hx_constructs = ["ReadOnly", "AlphaPremultiplied", "FlipY"]
hxd_Flags.ReadOnly = hxd_Flags("ReadOnly", 0, ())
hxd_Flags.AlphaPremultiplied = hxd_Flags("AlphaPremultiplied", 1, ())
hxd_Flags.FlipY = hxd_Flags("FlipY", 2, ())
hxd_Flags._hx_class = hxd_Flags
_hx_classes["hxd.Flags"] = hxd_Flags


class hxd__Pixels_PixelsARGB_Impl_:
    _hx_class_name = "hxd._Pixels.PixelsARGB_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getPixel", "setPixel", "fromPixels"]

    @staticmethod
    def getPixel(this1,x,y):
        _this = this1.bytes
        pos = ((((x + ((y * this1.width))) << 2)) + this1.offset)
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        v1 = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        return (((HxOverrides.rshift(v1, 24) | (((v1 >> 8) & 65280))) | (((v1 << 8) & 16711680))) | ((v1 << 24)))

    @staticmethod
    def setPixel(this1,x,y,v):
        _this = this1.bytes
        pos = ((((x + ((y * this1.width))) << 2)) + this1.offset)
        v1 = (((HxOverrides.rshift(v, 24) | (((v >> 8) & 65280))) | (((v << 8) & 16711680))) | ((v << 24)))
        _this.b[pos] = (v1 & 255)
        _this.b[(pos + 1)] = ((v1 >> 8) & 255)
        _this.b[(pos + 2)] = ((v1 >> 16) & 255)
        _this.b[(pos + 3)] = (HxOverrides.rshift(v1, 24) & 255)

    @staticmethod
    def fromPixels(p):
        p.convert(hxd_PixelFormat.ARGB)
        p.setFlip(False)
        return p
hxd__Pixels_PixelsARGB_Impl_._hx_class = hxd__Pixels_PixelsARGB_Impl_
_hx_classes["hxd._Pixels.PixelsARGB_Impl_"] = hxd__Pixels_PixelsARGB_Impl_


class hxd__Pixels_PixelsFloat_Impl_:
    _hx_class_name = "hxd._Pixels.PixelsFloat_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getPixelF", "setPixelF", "fromPixels"]

    @staticmethod
    def getPixelF(this1,x,y,v = None):
        if (v is None):
            v = h3d_Vector()
        pix = ((((x + ((y * this1.width))) << 2)) + this1.offset)
        v.x = this1.bytes.getFloat(pix)
        return v

    @staticmethod
    def setPixelF(this1,x,y,v):
        pix = ((((x + ((y * this1.width))) << 2)) + this1.offset)
        this1.bytes.setFloat(pix,v.x)

    @staticmethod
    def fromPixels(p):
        p.setFlip(False)
        p.convert(hxd_PixelFormat.R32F)
        return p
hxd__Pixels_PixelsFloat_Impl_._hx_class = hxd__Pixels_PixelsFloat_Impl_
_hx_classes["hxd._Pixels.PixelsFloat_Impl_"] = hxd__Pixels_PixelsFloat_Impl_


class hxd__Pixels_PixelsFloatRGBA_Impl_:
    _hx_class_name = "hxd._Pixels.PixelsFloatRGBA_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getPixelF", "setPixelF", "fromPixels"]

    @staticmethod
    def getPixelF(this1,x,y,v = None):
        if (v is None):
            v = h3d_Vector()
        pix = ((((x + ((y * this1.width))) << 4)) + this1.offset)
        v.x = this1.bytes.getFloat(pix)
        v.y = this1.bytes.getFloat((pix + 4))
        v.z = this1.bytes.getFloat((pix + 8))
        v.w = this1.bytes.getFloat((pix + 12))
        return v

    @staticmethod
    def setPixelF(this1,x,y,v):
        pix = ((((x + ((y * this1.width))) << 4)) + this1.offset)
        this1.bytes.setFloat(pix,v.x)
        this1.bytes.setFloat((pix + 4),v.y)
        this1.bytes.setFloat((pix + 8),v.z)
        this1.bytes.setFloat((pix + 12),v.w)

    @staticmethod
    def fromPixels(p):
        p.setFlip(False)
        p.convert(hxd_PixelFormat.RGBA32F)
        return p
hxd__Pixels_PixelsFloatRGBA_Impl_._hx_class = hxd__Pixels_PixelsFloatRGBA_Impl_
_hx_classes["hxd._Pixels.PixelsFloatRGBA_Impl_"] = hxd__Pixels_PixelsFloatRGBA_Impl_


class hxd__Pixels_Channel_Impl_:
    _hx_class_name = "hxd._Pixels.Channel_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["R", "G", "B", "A", "toInt", "fromInt"]

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def fromInt(v):
        return v
hxd__Pixels_Channel_Impl_._hx_class = hxd__Pixels_Channel_Impl_
_hx_classes["hxd._Pixels.Channel_Impl_"] = hxd__Pixels_Channel_Impl_


class hxd_Pixels:
    _hx_class_name = "hxd.Pixels"
    _hx_is_interface = "False"
    __slots__ = ("bytes", "width", "height", "dataSize", "offset", "flags", "stride", "bytesPerPixel", "innerFormat")
    _hx_fields = ["bytes", "width", "height", "dataSize", "offset", "flags", "stride", "bytesPerPixel", "innerFormat"]
    _hx_methods = ["get_format", "set_innerFormat", "invalidFormat", "sub", "yflip", "blit", "clear", "toVector", "makeSquare", "copyInner", "willChange", "setFlip", "convert", "getPixel", "setPixel", "getPixelF", "setPixelF", "dispose", "toString", "toPNG", "clone"]
    _hx_statics = ["switchEndian", "switchBR", "calcDataSize", "calcStride", "isFloatFormat", "getChannelOffset", "alloc", "toDDS"]

    def __init__(self,width,height,_hx_bytes,format,offset = None):
        if (offset is None):
            offset = 0
        self.innerFormat = None
        self.bytesPerPixel = None
        self.stride = None
        self.flags = None
        self.offset = None
        self.dataSize = None
        self.width = width
        self.height = height
        self.bytes = _hx_bytes
        self.set_innerFormat(format)
        self.offset = offset
        i = 0
        if (i is None):
            i = 0
        this1 = i
        self.flags = this1

    def get_format(self):
        return self.innerFormat

    def set_innerFormat(self,fmt):
        self.innerFormat = fmt
        self.stride = hxd_Pixels.calcStride(self.width,fmt)
        self.dataSize = hxd_Pixels.calcDataSize(self.width,self.height,fmt)
        self.bytesPerPixel = hxd_Pixels.calcStride(1,fmt)
        return fmt

    def invalidFormat(self):
        raise haxe_Exception.thrown(("Unsupported format for this operation : " + Std.string(self.innerFormat)))

    def sub(self,x,y,width,height):
        if ((((x < 0) or ((y < 0))) or (((x + width) > self.width))) or (((y + height) > self.height))):
            raise haxe_Exception.thrown("Pixels.sub() outside bounds")
        out = haxe_io_Bytes.alloc((height * self.stride))
        stride = hxd_Pixels.calcStride(width,self.innerFormat)
        outP = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            dy = _g
            _g = (_g + 1)
            y1 = (y + dy)
            p = ((((x + ((((((self.height - 1) - y1) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y1)) * self.width)))) * self.bytesPerPixel) + self.offset)
            out.blit(outP,self.bytes,p,stride)
            outP = (outP + stride)
        return hxd_Pixels(width,height,out,self.innerFormat)

    def yflip(self,y):
        if (((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0):
            return ((self.height - 1) - y)
        else:
            return y

    def blit(self,x,y,src,srcX,srcY,width,height):
        if ((((x < 0) or ((y < 0))) or (((x + width) > self.width))) or (((y + height) > self.height))):
            raise haxe_Exception.thrown("Pixels.blit() outside bounds")
        if ((((srcX < 0) or ((srcX < 0))) or (((srcX + width) > src.width))) or (((srcY + height) > src.height))):
            raise haxe_Exception.thrown("Pixels.blit() outside src bounds")
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        src.convert(self.innerFormat)
        bpp = self.bytesPerPixel
        if (bpp == 0):
            raise haxe_Exception.thrown("assert")
        stride = hxd_Pixels.calcStride(width,self.innerFormat)
        _g = 0
        _g1 = height
        while (_g < _g1):
            dy = _g
            _g = (_g + 1)
            y1 = (dy + srcY)
            srcP = ((((srcX + ((((((src.height - 1) - y1) if ((((src.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y1)) * src.width)))) * bpp) + src.offset)
            y2 = (dy + y)
            dstP = ((((x + ((((((self.height - 1) - y2) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y2)) * self.width)))) * bpp) + self.offset)
            self.bytes.blit(dstP,src.bytes,srcP,stride)

    def clear(self,color,preserveMask = None):
        if (preserveMask is None):
            preserveMask = 0
        mask = preserveMask
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        if (((((color & 255)) == (((color >> 8) & 255))) and ((((color & 65535)) == (HxOverrides.rshift(color, 16))))) and ((mask == 0))):
            self.bytes.fill(self.offset,((self.width * self.height) * self.bytesPerPixel),(color & 255))
            return
        tmp = self.innerFormat.index
        if (tmp == 0):
            color = (((HxOverrides.rshift(color, 24) | (((color >> 8) & 65280))) | (((color << 8) & 16711680))) | ((color << 24)))
            mask = (((HxOverrides.rshift(mask, 24) | (((mask >> 8) & 65280))) | (((mask << 8) & 16711680))) | ((mask << 24)))
        elif (tmp == 1):
            pass
        elif (tmp == 2):
            color = (((color & -16711936) | (((color << 16) & 16711680))) | (((color >> 16) & 255)))
            mask = (((mask & -16711936) | (((mask << 16) & 16711680))) | (((mask >> 16) & 255)))
        else:
            self.invalidFormat()
        p = self.offset
        if (mask == 0):
            _g = 0
            _g1 = (self.width * self.height)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this = self.bytes
                _this.b[p] = (color & 255)
                _this.b[(p + 1)] = ((color >> 8) & 255)
                _this.b[(p + 2)] = ((color >> 16) & 255)
                _this.b[(p + 3)] = (HxOverrides.rshift(color, 24) & 255)
                p = (p + 4)
        else:
            _g = 0
            _g1 = (self.width * self.height)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this = self.bytes
                _this1 = self.bytes
                v = (((_this1.b[p] | ((_this1.b[(p + 1)] << 8))) | ((_this1.b[(p + 2)] << 16))) | ((_this1.b[(p + 3)] << 24)))
                v1 = (color | (((((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)) & mask)))
                _this.b[p] = (v1 & 255)
                _this.b[(p + 1)] = ((v1 >> 8) & 255)
                _this.b[(p + 2)] = ((v1 >> 16) & 255)
                _this.b[(p + 3)] = (HxOverrides.rshift(v1, 24) & 255)
                p = (p + 4)

    def toVector(self):
        this1 = [None]*(self.width * self.height)
        vec = this1
        idx = 0
        p = self.offset
        dl = 0
        if (((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0):
            p = (p + (((((self.height - 1)) * self.width) * self.bytesPerPixel)))
            dl = ((-self.width * 2) * self.bytesPerPixel)
        tmp = self.innerFormat.index
        if (tmp == 0):
            _g = 0
            _g1 = self.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                _g2 = 0
                _g3 = self.width
                while (_g2 < _g3):
                    x = _g2
                    _g2 = (_g2 + 1)
                    _this = self.bytes
                    v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
                    v1 = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                    index = idx
                    idx = (idx + 1)
                    val = (((HxOverrides.rshift(v1, 24) | (((v1 >> 8) & 65280))) | (((v1 << 8) & 16711680))) | ((v1 << 24)))
                    vec[index] = val
                    p = (p + 4)
                p = (p + dl)
        elif (tmp == 1):
            _g = 0
            _g1 = self.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                _g2 = 0
                _g3 = self.width
                while (_g2 < _g3):
                    x = _g2
                    _g2 = (_g2 + 1)
                    index = idx
                    idx = (idx + 1)
                    _this = self.bytes
                    v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
                    val = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                    vec[index] = val
                    p = (p + 4)
                p = (p + dl)
        elif (tmp == 2):
            _g = 0
            _g1 = self.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                _g2 = 0
                _g3 = self.width
                while (_g2 < _g3):
                    x = _g2
                    _g2 = (_g2 + 1)
                    _this = self.bytes
                    v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
                    v1 = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                    index = idx
                    idx = (idx + 1)
                    val = (((v1 & -16711936) | (((v1 << 16) & 16711680))) | (((v1 >> 16) & 255)))
                    vec[index] = val
                    p = (p + 4)
                p = (p + dl)
        else:
            self.invalidFormat()
        return vec

    def makeSquare(self,copy = None):
        w = self.width
        h = self.height
        tw = (0 if ((w == 0)) else 1)
        th = (0 if ((h == 0)) else 1)
        while (tw < w):
            tw = (tw << 1)
        while (th < h):
            th = (th << 1)
        if ((w == tw) and ((h == th))):
            return self
        bpp = self.bytesPerPixel
        out = haxe_io_Bytes.alloc(((tw * th) * bpp))
        p = 0
        b = self.offset
        _g = 0
        _g1 = h
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            out.blit(p,self.bytes,b,(w * bpp))
            p = (p + ((w * bpp)))
            b = (b + ((w * bpp)))
            _g2 = 0
            _g3 = ((((tw - w)) * bpp) >> 2)
            while (_g2 < _g3):
                i = _g2
                _g2 = (_g2 + 1)
                out.b[p] = 0
                out.b[(p + 1)] = 0
                out.b[(p + 2)] = 0
                out.b[(p + 3)] = 0
                p = (p + 4)
        _g = 0
        _g1 = (((((th - h)) * tw) * bpp) >> 2)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            out.b[p] = 0
            out.b[(p + 1)] = 0
            out.b[(p + 2)] = 0
            out.b[(p + 3)] = 0
            p = (p + 4)
        if copy:
            return hxd_Pixels(tw,th,out,self.innerFormat)
        self.bytes = out
        self.width = tw
        self.height = th
        return self

    def copyInner(self):
        old = self.bytes
        self.bytes = haxe_io_Bytes.alloc(self.dataSize)
        self.bytes.blit(0,old,self.offset,self.dataSize)
        self.offset = 0
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 & ((-1 - ((1 << hxd_Flags.ReadOnly.index)))))
        _hx_local_0.flags

    def willChange(self):
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()

    def setFlip(self,b):
        if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0) == b):
            return
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | ((1 << hxd_Flags.FlipY.index)))
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ((-1 - ((1 << hxd_Flags.FlipY.index)))))
            _hx_local_2.flags
        if (HxOverrides.mod(self.stride, 4) != 0):
            self.invalidFormat()
        _g = 0
        _g1 = (self.height >> 1)
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            p1 = ((y * self.stride) + self.offset)
            p2 = (((((self.height - 1) - y)) * self.stride) + self.offset)
            _g2 = 0
            _g3 = (self.stride >> 2)
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                _this = self.bytes
                v = (((_this.b[p1] | ((_this.b[(p1 + 1)] << 8))) | ((_this.b[(p1 + 2)] << 16))) | ((_this.b[(p1 + 3)] << 24)))
                a = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                _this1 = self.bytes
                v1 = (((_this1.b[p2] | ((_this1.b[(p2 + 1)] << 8))) | ((_this1.b[(p2 + 2)] << 16))) | ((_this1.b[(p2 + 3)] << 24)))
                b = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
                _this2 = self.bytes
                _this2.b[p1] = (b & 255)
                _this2.b[(p1 + 1)] = ((b >> 8) & 255)
                _this2.b[(p1 + 2)] = ((b >> 16) & 255)
                _this2.b[(p1 + 3)] = (HxOverrides.rshift(b, 24) & 255)
                _this3 = self.bytes
                _this3.b[p2] = (a & 255)
                _this3.b[(p2 + 1)] = ((a >> 8) & 255)
                _this3.b[(p2 + 2)] = ((a >> 16) & 255)
                _this3.b[(p2 + 3)] = (HxOverrides.rshift(a, 24) & 255)
                p1 = (p1 + 4)
                p2 = (p2 + 4)

    def convert(self,target):
        if ((self.innerFormat == target) or Type.enumEq(self.innerFormat,target)):
            return
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        this1 = self.bytes.b
        _hx_bytes = this1
        _g = self.innerFormat
        tmp = _g.index
        if (tmp == 0):
            tmp = target.index
            if (tmp == 1):
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    p = (((i << 2)) + self.offset)
                    a = _hx_bytes[p]
                    r = _hx_bytes[(p + 1)]
                    g = _hx_bytes[(p + 2)]
                    b = _hx_bytes[(p + 3)]
                    i1 = p
                    p = (p + 1)
                    _hx_bytes[i1] = b
                    i2 = p
                    p = (p + 1)
                    _hx_bytes[i2] = g
                    i3 = p
                    p = (p + 1)
                    _hx_bytes[i3] = r
                    _hx_bytes[p] = a
            elif (tmp == 2):
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    p = (((i << 2)) + self.offset)
                    a = _hx_bytes[p]
                    v = _hx_bytes[(p + 1)]
                    _hx_bytes[p] = v
                    v1 = _hx_bytes[(p + 2)]
                    _hx_bytes[(p + 1)] = v1
                    v2 = _hx_bytes[(p + 3)]
                    _hx_bytes[(p + 2)] = v2
                    _hx_bytes[(p + 3)] = a
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 1):
            tmp = target.index
            if (tmp == 0):
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    p = (((i << 2)) + self.offset)
                    a = _hx_bytes[p]
                    r = _hx_bytes[(p + 1)]
                    g = _hx_bytes[(p + 2)]
                    b = _hx_bytes[(p + 3)]
                    i1 = p
                    p = (p + 1)
                    _hx_bytes[i1] = b
                    i2 = p
                    p = (p + 1)
                    _hx_bytes[i2] = g
                    i3 = p
                    p = (p + 1)
                    _hx_bytes[i3] = r
                    _hx_bytes[p] = a
            elif (tmp == 2):
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    p = (((i << 2)) + self.offset)
                    b = _hx_bytes[p]
                    r = _hx_bytes[(p + 2)]
                    _hx_bytes[p] = r
                    _hx_bytes[(p + 2)] = b
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 2):
            tmp = target.index
            if (tmp == 0):
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    p = (((i << 2)) + self.offset)
                    a = _hx_bytes[(p + 3)]
                    v = _hx_bytes[(p + 2)]
                    _hx_bytes[(p + 3)] = v
                    v1 = _hx_bytes[(p + 1)]
                    _hx_bytes[(p + 2)] = v1
                    v2 = _hx_bytes[p]
                    _hx_bytes[(p + 1)] = v2
                    _hx_bytes[p] = a
            elif (tmp == 1):
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    p = (((i << 2)) + self.offset)
                    b = _hx_bytes[p]
                    r = _hx_bytes[(p + 2)]
                    _hx_bytes[p] = r
                    _hx_bytes[(p + 2)] = b
            elif (tmp == 5):
                nbytes = haxe_io_Bytes.alloc((self.width * self.height))
                this1 = nbytes.b
                out = this1
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    v = _hx_bytes[(i << 2)]
                    out[i] = v
                self.bytes = nbytes
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 4):
            if (target.index == 7):
                nbytes = haxe_io_Bytes.alloc(((self.height * self.width) * 4))
                this1 = nbytes.b
                out = this1
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    nbytes.setFloat((i << 2),self.bytes.getFloat((i << 4)))
                self.bytes = nbytes
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 7):
            tmp = target.index
            if ((tmp == 2) or ((tmp == 1))):
                fbytes = self.bytes
                p = 0
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    x = (fbytes.getFloat(p) * 255)
                    v = None
                    try:
                        v = int(x)
                    except BaseException as _g3:
                        None
                        v = None
                    if (v < 0):
                        v = 0
                    elif (v > 255):
                        v = 255
                    i1 = p
                    p = (p + 1)
                    _hx_bytes[i1] = v
                    i2 = p
                    p = (p + 1)
                    _hx_bytes[i2] = v
                    i3 = p
                    p = (p + 1)
                    _hx_bytes[i3] = v
                    i4 = p
                    p = (p + 1)
                    _hx_bytes[i4] = 255
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 18):
            if (target.index == 7):
                nbytes = haxe_io_Bytes.alloc(((self.width * self.height) * 4))
                fbytes = self.bytes
                _g1 = 0
                _g2 = (self.width * self.height)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    pos = (i << 1)
                    nv = (fbytes.b[pos] | ((fbytes.b[(pos + 1)] << 8)))
                    nbytes.setFloat((i << 2),(nv / 65535.0))
                self.bytes = nbytes
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 21):
            if (target.index == 21):
                b = target.params[0]
                a = _g.params[0]
                if (a != b):
                    raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
            else:
                raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        else:
            raise haxe_Exception.thrown(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        self.set_innerFormat(target)

    def getPixel(self,x,y):
        p = ((((x + ((((((self.height - 1) - y) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y)) * self.width)))) * self.bytesPerPixel) + self.offset)
        tmp = self.innerFormat.index
        if (tmp == 0):
            _this = self.bytes
            v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
            v1 = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            return (((HxOverrides.rshift(v1, 24) | (((v1 >> 8) & 65280))) | (((v1 << 8) & 16711680))) | ((v1 << 24)))
        elif (tmp == 1):
            _this = self.bytes
            v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
            if (((v & -2147483648)) != 0):
                return (v | -2147483648)
            else:
                return v
        elif (tmp == 2):
            _this = self.bytes
            v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
            v1 = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            return (((v1 & -16711936) | (((v1 << 16) & 16711680))) | (((v1 >> 16) & 255)))
        else:
            self.invalidFormat()
            return 0

    def setPixel(self,x,y,color):
        p = ((((x + ((((((self.height - 1) - y) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y)) * self.width)))) * self.bytesPerPixel) + self.offset)
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        tmp = self.innerFormat.index
        if (tmp == 0):
            _this = self.bytes
            v = (((HxOverrides.rshift(color, 24) | (((color >> 8) & 65280))) | (((color << 8) & 16711680))) | ((color << 24)))
            _this.b[p] = (v & 255)
            _this.b[(p + 1)] = ((v >> 8) & 255)
            _this.b[(p + 2)] = ((v >> 16) & 255)
            _this.b[(p + 3)] = (HxOverrides.rshift(v, 24) & 255)
        elif (tmp == 1):
            _this = self.bytes
            _this.b[p] = (color & 255)
            _this.b[(p + 1)] = ((color >> 8) & 255)
            _this.b[(p + 2)] = ((color >> 16) & 255)
            _this.b[(p + 3)] = (HxOverrides.rshift(color, 24) & 255)
        elif (tmp == 2):
            _this = self.bytes
            v = (((color & -16711936) | (((color << 16) & 16711680))) | (((color >> 16) & 255)))
            _this.b[p] = (v & 255)
            _this.b[(p + 1)] = ((v >> 8) & 255)
            _this.b[(p + 2)] = ((v >> 16) & 255)
            _this.b[(p + 3)] = (HxOverrides.rshift(v, 24) & 255)
        elif (tmp == 5):
            self.bytes.b[p] = (color & 255)
        else:
            self.invalidFormat()

    def getPixelF(self,x,y,v = None):
        if (v is None):
            v = h3d_Vector()
        p = ((((x + ((((((self.height - 1) - y) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y)) * self.width)))) * self.bytesPerPixel) + self.offset)
        tmp = self.innerFormat.index
        if (tmp == 4):
            x1 = self.bytes.getFloat(p)
            y1 = self.bytes.getFloat((p + 4))
            z = self.bytes.getFloat((p + 8))
            w = self.bytes.getFloat((p + 12))
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            v.x = x1
            v.y = y1
            v.z = z
            v.w = w
            return v
        elif (tmp == 7):
            x1 = self.bytes.getFloat(p)
            y1 = 0
            z = 0
            w = 0
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            v.x = x1
            v.y = y1
            v.z = z
            v.w = w
            return v
        elif (tmp == 10):
            x1 = self.bytes.getFloat(p)
            y1 = self.bytes.getFloat((p + 4))
            z = 0
            w = 0
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            v.x = x1
            v.y = y1
            v.z = z
            v.w = w
            return v
        else:
            c = self.getPixel(x,y)
            v.x = ((((c >> 16) & 255)) / 255)
            v.y = ((((c >> 8) & 255)) / 255)
            v.z = (((c & 255)) / 255)
            v.w = ((HxOverrides.rshift(c, 24)) / 255)
            return v

    def setPixelF(self,x,y,v):
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        p = ((((x + ((((((self.height - 1) - y) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y)) * self.width)))) * self.bytesPerPixel) + self.offset)
        tmp = self.innerFormat.index
        if (tmp == 4):
            self.bytes.setFloat(p,v.x)
            self.bytes.setFloat((p + 4),v.y)
            self.bytes.setFloat((p + 8),v.z)
            self.bytes.setFloat((p + 12),v.w)
        elif (tmp == 7):
            self.bytes.setFloat(p,v.x)
        else:
            f = v.w
            x1 = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
            tmp = None
            try:
                tmp = int(x1)
            except BaseException as _g:
                None
                tmp = None
            tmp1 = (tmp << 24)
            f = v.x
            x1 = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
            tmp = None
            try:
                tmp = int(x1)
            except BaseException as _g:
                None
                tmp = None
            tmp2 = (tmp1 | ((tmp << 16)))
            f = v.y
            x1 = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
            tmp = None
            try:
                tmp = int(x1)
            except BaseException as _g:
                None
                tmp = None
            tmp1 = (tmp2 | ((tmp << 8)))
            f = v.z
            x1 = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
            tmp = None
            try:
                tmp = int(x1)
            except BaseException as _g:
                None
                tmp = None
            self.setPixel(x,y,(tmp1 | tmp))

    def dispose(self):
        self.bytes = None

    def toString(self):
        return (((((("Pixels(" + Std.string(self.width)) + "x") + Std.string(self.height)) + " ") + Std.string(self.innerFormat)) + ")")

    def toPNG(self,level = None):
        if (level is None):
            level = 9
        png = None
        self.setFlip(False)
        if (self.innerFormat.index == 0):
            png = format_png_Tools.build32ARGB(self.width,self.height,self.bytes,level)
        else:
            self.convert(hxd_PixelFormat.BGRA)
            png = format_png_Tools.build32BGRA(self.width,self.height,self.bytes,level)
        o = haxe_io_BytesOutput()
        format_png_Writer(o).write(png)
        return o.getBytes()

    def clone(self):
        p = hxd_Pixels(self.width,self.height,None,self.innerFormat)
        p.flags = self.flags
        p.flags = (p.flags & ((-1 - ((1 << hxd_Flags.ReadOnly.index)))))
        if (self.bytes is not None):
            p.bytes = haxe_io_Bytes.alloc(self.dataSize)
            p.bytes.blit(0,self.bytes,self.offset,self.dataSize)
        return p

    @staticmethod
    def switchEndian(v):
        return (((HxOverrides.rshift(v, 24) | (((v >> 8) & 65280))) | (((v << 8) & 16711680))) | ((v << 24)))

    @staticmethod
    def switchBR(v):
        return (((v & -16711936) | (((v << 16) & 16711680))) | (((v >> 16) & 255)))

    @staticmethod
    def calcDataSize(width,height,format):
        if (format.index == 21):
            _g = format.params[0]
            return (((((height + 3) >> 2) << 2)) * hxd_Pixels.calcStride(width,format))
        else:
            return (height * hxd_Pixels.calcStride(width,format))

    @staticmethod
    def calcStride(width,format):
        tmp = None
        tmp1 = format.index
        if ((tmp1 == 20) or ((tmp1 == 3))):
            tmp = 8
        elif (tmp1 == 4):
            tmp = 16
        elif (tmp1 == 5):
            tmp = 1
        elif (tmp1 == 7):
            tmp = 4
        elif (tmp1 == 8):
            tmp = 2
        elif (tmp1 == 9):
            tmp = 4
        elif (tmp1 == 10):
            tmp = 8
        elif (tmp1 == 11):
            tmp = 3
        elif ((tmp1 == 19) or ((tmp1 == 12))):
            tmp = 6
        elif (tmp1 == 13):
            tmp = 12
        elif (((((tmp1 == 15) or ((tmp1 == 14))) or ((tmp1 == 2))) or ((tmp1 == 1))) or ((tmp1 == 0))):
            tmp = 4
        elif (tmp1 == 16):
            tmp = 4
        elif (tmp1 == 17):
            tmp = 4
        elif ((tmp1 == 18) or ((tmp1 == 6))):
            tmp = 2
        elif (tmp1 == 21):
            n = format.params[0]
            blocks = ((width + 3) >> 2)
            if ((n == 1) or ((n == 4))):
                return (blocks << 1)
            return (blocks << 2)
        else:
            pass
        return (width * tmp)

    @staticmethod
    def isFloatFormat(format):
        tmp = format.index
        if ((((tmp == 12) or ((tmp == 9))) or ((tmp == 6))) or ((tmp == 3))):
            return True
        elif ((((tmp == 13) or ((tmp == 10))) or ((tmp == 7))) or ((tmp == 4))):
            return True
        elif (tmp == 21):
            if (format.params[0] == 6):
                return True
            else:
                return False
        else:
            return False

    @staticmethod
    def getChannelOffset(format,channel):
        tmp = format.index
        if (tmp == 0):
            return python_internal_ArrayImpl._get([1, 2, 3, 0], channel)
        elif (tmp == 1):
            return python_internal_ArrayImpl._get([2, 1, 0, 3], channel)
        elif ((tmp == 20) or ((tmp == 3))):
            return (channel * 2)
        elif (tmp == 4):
            return (channel * 4)
        elif ((((tmp == 18) or ((tmp == 7))) or ((tmp == 6))) or ((tmp == 5))):
            if (channel == 0):
                return 0
            else:
                return -1
        elif (((tmp == 10) or ((tmp == 9))) or ((tmp == 8))):
            p = hxd_Pixels.calcStride(1,format)
            return python_internal_ArrayImpl._get([0, p, -1, -1], channel)
        elif ((((tmp == 19) or ((tmp == 13))) or ((tmp == 12))) or ((tmp == 11))):
            p = hxd_Pixels.calcStride(1,format)
            return python_internal_ArrayImpl._get([0, p, (p << 1), -1], channel)
        elif (((tmp == 15) or ((tmp == 14))) or ((tmp == 2))):
            return channel
        elif ((tmp == 17) or ((tmp == 16))):
            raise haxe_Exception.thrown("Bit packed format")
        elif (tmp == 21):
            _g = format.params[0]
            raise haxe_Exception.thrown("Not supported")
        else:
            pass

    @staticmethod
    def alloc(width,height,format):
        return hxd_Pixels(width,height,haxe_io_Bytes.alloc(hxd_Pixels.calcDataSize(width,height,format)),format)

    @staticmethod
    def toDDS(pixels,isCubeMap = None):
        if (isCubeMap is None):
            isCubeMap = False
        if (len(pixels) == 0):
            raise haxe_Exception.thrown("Must contain at least one image")
        ref = (pixels[0] if 0 < len(pixels) else None)
        fmt = ref.innerFormat
        levels = []
        outSize = 0
        _g = 0
        while (_g < len(pixels)):
            p = (pixels[_g] if _g >= 0 and _g < len(pixels) else None)
            _g = (_g + 1)
            if (p.innerFormat != fmt):
                raise haxe_Exception.thrown("All images must be of the same pixel format")
            outSize = (outSize + p.dataSize)
            found = False
            _g1 = 0
            while (_g1 < len(levels)):
                sz = (levels[_g1] if _g1 >= 0 and _g1 < len(levels) else None)
                _g1 = (_g1 + 1)
                if (((sz[0] if 0 < len(sz) else None).width == p.width) and (((sz[0] if 0 < len(sz) else None).height == p.height))):
                    sz.append(p)
                    found = True
                    break
            if (not found):
                levels.append([p])
        def _hx_local_3(a1,a2):
            return (((a2[0] if 0 < len(a2) else None).width * (a2[0] if 0 < len(a2) else None).height) - (((a1[0] if 0 < len(a1) else None).width * (a1[0] if 0 < len(a1) else None).height)))
        levels.sort(key= python_lib_Functools.cmp_to_key(_hx_local_3))
        layerCount = len((levels[0] if 0 < len(levels) else None))
        width = python_internal_ArrayImpl._get((levels[0] if 0 < len(levels) else None), 0).width
        height = python_internal_ArrayImpl._get((levels[0] if 0 < len(levels) else None), 0).height
        _g = 1
        _g1 = len(levels)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            level = (levels[i] if i >= 0 and i < len(levels) else None)
            if (len(level) != layerCount):
                raise haxe_Exception.thrown(((((("Invalid number of mipmaps at level " + Std.string(i)) + ": ") + Std.string(len(level))) + " should be ") + Std.string(layerCount)))
            w = (width >> i)
            if (w == 0):
                w = 1
            h = (height >> i)
            if (h == 0):
                h = 1
            lw = (level[0] if 0 < len(level) else None).width
            lh = (level[0] if 0 < len(level) else None).height
            if ((lw != w) or ((lh != h))):
                raise haxe_Exception.thrown(((((((((("Invalid mip level size " + Std.string(i)) + ": ") + Std.string(lw)) + "x") + Std.string(lh)) + " should be ") + Std.string(w)) + "x") + Std.string(h)))
        outSize = (outSize + 128)
        ddsOut = haxe_io_Bytes.alloc(outSize)
        outPos = 0
        ddsOut.b[outPos] = 68
        ddsOut.b[(outPos + 1)] = 68
        ddsOut.b[(outPos + 2)] = 83
        ddsOut.b[(outPos + 3)] = 32
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 124
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 15
        ddsOut.b[(outPos + 1)] = 16
        ddsOut.b[(outPos + 2)] = 2
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = (width & 255)
        ddsOut.b[(outPos + 1)] = ((width >> 8) & 255)
        ddsOut.b[(outPos + 2)] = ((width >> 16) & 255)
        ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(width, 24) & 255)
        outPos = (outPos + 4)
        ddsOut.b[outPos] = (height & 255)
        ddsOut.b[(outPos + 1)] = ((height >> 8) & 255)
        ddsOut.b[(outPos + 2)] = ((height >> 16) & 255)
        ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(height, 24) & 255)
        outPos = (outPos + 4)
        v = ref.stride
        ddsOut.b[outPos] = (v & 255)
        ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
        ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
        ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 1
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        v = len(levels)
        ddsOut.b[outPos] = (v & 255)
        ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
        ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
        ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 32
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        tmp = fmt.index
        if (((tmp == 2) or ((tmp == 1))) or ((tmp == 0))):
            ddsOut.b[outPos] = 65
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 0
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 32
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            byte = hxd_Pixels.getChannelOffset(fmt,0)
            v = (255 << ((byte * 8)))
            ddsOut.b[outPos] = (v & 255)
            ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
            ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
            ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
            outPos = (outPos + 4)
            byte = hxd_Pixels.getChannelOffset(fmt,1)
            v = (255 << ((byte * 8)))
            ddsOut.b[outPos] = (v & 255)
            ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
            ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
            ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
            outPos = (outPos + 4)
            byte = hxd_Pixels.getChannelOffset(fmt,2)
            v = (255 << ((byte * 8)))
            ddsOut.b[outPos] = (v & 255)
            ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
            ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
            ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
            outPos = (outPos + 4)
            byte = hxd_Pixels.getChannelOffset(fmt,3)
            v = (255 << ((byte * 8)))
            ddsOut.b[outPos] = (v & 255)
            ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
            ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
            ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
            outPos = (outPos + 4)
        else:
            alpha = (hxd_Pixels.getChannelOffset(fmt,3) >= 0)
            ddsOut.b[outPos] = 4
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            v = None
            v1 = fmt.index
            if (v1 == 3):
                v = 113
            elif (v1 == 4):
                v = 116
            elif (v1 == 6):
                v = 111
            elif (v1 == 7):
                v = 114
            elif (v1 == 9):
                v = 112
            elif (v1 == 10):
                v = 115
            else:
                raise haxe_Exception.thrown(("Unsupported format " + Std.string(fmt)))
            ddsOut.b[outPos] = (v & 255)
            ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
            ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
            ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 0
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 0
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 0
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 0
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
            ddsOut.b[outPos] = 0
            ddsOut.b[(outPos + 1)] = 0
            ddsOut.b[(outPos + 2)] = 0
            ddsOut.b[(outPos + 3)] = 0
            outPos = (outPos + 4)
        v = ((((0 if ((len(pixels) == 1)) else 8)) | 4096) | ((0 if ((len(levels) == 1)) else 4194304)))
        ddsOut.b[outPos] = (v & 255)
        ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
        ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
        ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        outPos = (outPos + 4)
        cubebits = (((((1536 | ((2048 if ((layerCount > 1)) else 0))) | ((4096 if ((layerCount > 2)) else 0))) | ((8192 if ((layerCount > 3)) else 0))) | ((16384 if ((layerCount > 4)) else 0))) | ((32768 if ((layerCount > 5)) else 0)))
        v = (cubebits if isCubeMap else 0)
        ddsOut.b[outPos] = (v & 255)
        ddsOut.b[(outPos + 1)] = ((v >> 8) & 255)
        ddsOut.b[(outPos + 2)] = ((v >> 16) & 255)
        ddsOut.b[(outPos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        ddsOut.b[outPos] = 0
        ddsOut.b[(outPos + 1)] = 0
        ddsOut.b[(outPos + 2)] = 0
        ddsOut.b[(outPos + 3)] = 0
        outPos = (outPos + 4)
        _g = 0
        _g1 = layerCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = len(levels)
            while (_g2 < _g3):
                l = _g2
                _g2 = (_g2 + 1)
                p = python_internal_ArrayImpl._get((levels[l] if l >= 0 and l < len(levels) else None), i)
                ddsOut.blit(outPos,p.bytes,p.offset,p.dataSize)
                outPos = (outPos + p.dataSize)
        return ddsOut

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bytes = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.dataSize = None
        _hx_o.offset = None
        _hx_o.flags = None
        _hx_o.stride = None
        _hx_o.bytesPerPixel = None
        _hx_o.innerFormat = None
hxd_Pixels._hx_class = hxd_Pixels
_hx_classes["hxd.Pixels"] = hxd_Pixels


class hxd_Res:
    _hx_class_name = "hxd.Res"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["load", "get_loader", "set_loader"]
    loader = None
    tree = None
    cocoa_yellow = None
    cocoa_red = None
    cocoa_purple = None
    cocoa_green = None
    chest = None
    background = None
    GloriaHallelujah = None
    GloriaHallelujah_Regular = None

    @staticmethod
    def load(name):
        return hxd_Res.get_loader().load(name)

    @staticmethod
    def get_loader():
        l = hxd_res_Loader.currentInstance
        if (l is None):
            raise haxe_Exception.thrown("Resource loader not initialized: call to hxd.Res.initXXX() required")
        return l

    @staticmethod
    def set_loader(l):
        def _hx_local_1():
            def _hx_local_0():
                hxd_res_Loader.currentInstance = l
                return hxd_res_Loader.currentInstance
            return _hx_local_0()
        return _hx_local_1()
hxd_Res._hx_class = hxd_Res
_hx_classes["hxd.Res"] = hxd_Res


class hxd_SceneEvents:
    _hx_class_name = "hxd.SceneEvents"
    _hx_is_interface = "False"
    __slots__ = ("window", "scenes", "overList", "overCandidates", "overIndex", "currentFocus", "pendingEvents", "pushList", "currentDrag", "mouseX", "mouseY", "lastTouch", "focusLost", "checkPos", "onOut", "onOver", "isOut", "enablePhysicalMouse", "mouseCheckMove", "defaultCursor")
    _hx_fields = ["window", "scenes", "overList", "overCandidates", "overIndex", "currentFocus", "pendingEvents", "pushList", "currentDrag", "mouseX", "mouseY", "lastTouch", "focusLost", "checkPos", "onOut", "onOver", "isOut", "enablePhysicalMouse", "mouseCheckMove", "defaultCursor"]
    _hx_methods = ["setMousePos", "onRemove", "addScene", "removeScene", "dispose", "focus", "blur", "checkFocus", "emitEvent", "checkEvents", "startCapture", "stopCapture", "startDrag", "stopDrag", "getFocus", "updateCursor", "set_defaultCursor", "selectCursor", "onEvent", "dispatchListeners"]

    def __init__(self,window = None):
        self.currentDrag = None
        self.currentFocus = None
        self.defaultCursor = hxd_Cursor.Default
        self.mouseCheckMove = True
        self.enablePhysicalMouse = True
        self.isOut = False
        self.onOver = hxd_Event(hxd_EventKind.EOver)
        self.onOut = hxd_Event(hxd_EventKind.EOut)
        self.checkPos = hxd_Event(hxd_EventKind.ECheck)
        self.focusLost = hxd_Event(hxd_EventKind.EFocusLost)
        self.lastTouch = 0
        self.mouseY = -1.
        self.mouseX = -1.
        self.overIndex = -1
        self.scenes = []
        self.pendingEvents = []
        self.pushList = []
        self.overList = []
        self.overCandidates = []
        if (window is None):
            window = hxd_Window.getInstance()
        self.window = window
        window.addEventTarget(self.onEvent)

    def setMousePos(self,xPos,yPos):
        self.mouseX = xPos
        self.mouseY = yPos

    def onRemove(self,i):
        if (i == self.currentFocus):
            self.currentFocus = None
        if (self.overIndex >= 0):
            index = python_internal_ArrayImpl.indexOf(self.overList,i,None)
            if (index >= 0):
                python_internal_ArrayImpl.remove(self.overList,i)
                if (index < self.overIndex):
                    _hx_local_0 = self
                    _hx_local_1 = _hx_local_0.overIndex
                    _hx_local_0.overIndex = (_hx_local_1 - 1)
                    _hx_local_1
        else:
            python_internal_ArrayImpl.remove(self.overList,i)
            self.selectCursor()
        python_internal_ArrayImpl.remove(self.pushList,i)

    def addScene(self,s,index = None):
        s.setEvents(self)
        if (index is None):
            _this = self.scenes
            _this.append(s)
        else:
            self.scenes.insert(index, s)

    def removeScene(self,s):
        if python_internal_ArrayImpl.remove(self.scenes,s):
            s.setEvents(None)

    def dispose(self):
        self.window.removeEventTarget(self.onEvent)

    def focus(self,i):
        if (self.currentFocus == i):
            return
        if (i is None):
            self.blur()
            return
        if (self.currentFocus is not None):
            self.blur()
            if (self.currentFocus is not None):
                return
        e = hxd_Event(hxd_EventKind.EFocus)
        i.handleEvent(e)
        if (not e.cancel):
            self.currentFocus = i

    def blur(self):
        if (self.currentFocus is None):
            return
        self.focusLost.cancel = False
        self.currentFocus.handleEvent(self.focusLost)
        if (not self.focusLost.cancel):
            self.currentFocus = None

    def checkFocus(self):
        if (self.currentFocus is None):
            return
        s = self.currentFocus.getInteractiveScene()
        if (s is None):
            self.currentFocus = None
            return
        if (not s.isInteractiveVisible(self.currentFocus)):
            self.blur()

    def emitEvent(self,event):
        oldX = event.relX
        oldY = event.relY
        overCandidateCount = 0
        handled = False
        checkOver = False
        fillOver = False
        checkPush = False
        cancelFocus = False
        updateCursor = False
        self.overIndex = 0
        tmp = event.kind.index
        if (tmp == 0):
            cancelFocus = True
            checkPush = True
        elif (tmp == 1):
            checkPush = True
        elif ((tmp == 12) or ((tmp == 2))):
            checkOver = True
            fillOver = True
        elif ((((tmp == 11) or ((tmp == 9))) or ((tmp == 8))) or ((tmp == 5))):
            if (self.currentFocus is not None):
                def _hx_local_0():
                    event.relY = 0
                    return event.relY
                event.relX = _hx_local_0()
                self.currentFocus.handleEvent(event)
                event.relX = oldX
                event.relY = oldY
                if (not event.propagate):
                    return
        else:
            pass
        _g = 0
        _g1 = self.scenes
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            last = None
            while True:
                i = s.handleEvent(event,last)
                if (i is None):
                    event.relX = oldX
                    event.relY = oldY
                    break
                if checkOver:
                    if fillOver:
                        idx = python_internal_ArrayImpl.indexOf(self.overList,i,None)
                        if (idx == -1):
                            if (len(self.overCandidates) == overCandidateCount):
                                python_internal_ArrayImpl._set(self.overCandidates, overCandidateCount, _hx_AnonObject({'i': i, 's': s, 'x': event.relX, 'y': event.relY, 'z': event.relZ}))
                            else:
                                info = (self.overCandidates[overCandidateCount] if overCandidateCount >= 0 and overCandidateCount < len(self.overCandidates) else None)
                                info.i = i
                                info.s = s
                                info.x = event.relX
                                info.y = event.relY
                                info.z = event.relZ
                            overCandidateCount = (overCandidateCount + 1)
                            pos = self.overIndex
                            self.overIndex = (self.overIndex + 1)
                            self.overList.insert(pos, i)
                            updateCursor = True
                        else:
                            if (idx < self.overIndex):
                                while True:
                                    python_internal_ArrayImpl._set(self.overList, idx, python_internal_ArrayImpl._get(self.overList, (idx + 1)))
                                    idx = (idx + 1)
                                    if (not ((idx < self.overIndex))):
                                        break
                                python_internal_ArrayImpl._set(self.overList, self.overIndex, i)
                                updateCursor = True
                            elif (idx > self.overIndex):
                                while True:
                                    python_internal_ArrayImpl._set(self.overList, idx, python_internal_ArrayImpl._get(self.overList, (idx - 1)))
                                    idx = (idx - 1)
                                    if (not ((idx > self.overIndex))):
                                        break
                                python_internal_ArrayImpl._set(self.overList, self.overIndex, i)
                                updateCursor = True
                            _hx_local_5 = self
                            _hx_local_6 = _hx_local_5.overIndex
                            _hx_local_5.overIndex = (_hx_local_6 + 1)
                            _hx_local_6
                        fillOver = event.propagate
                else:
                    if checkPush:
                        if (event.kind == hxd_EventKind.EPush):
                            _this = self.pushList
                            _this.append(i)
                        else:
                            python_internal_ArrayImpl.remove(self.pushList,i)
                    if (cancelFocus and ((i == self.currentFocus))):
                        cancelFocus = False
                event.relX = oldX
                event.relY = oldY
                if (not event.propagate):
                    handled = True
                    break
                last = i
                event.propagate = False
            if handled:
                break
        if (cancelFocus and ((self.currentFocus is not None))):
            self.blur()
        if checkOver:
            if (self.overIndex < len(self.overList)):
                while (self.overIndex < len(self.overList)):
                    _this = self.overList
                    e = (None if ((len(_this) == 0)) else _this.pop())
                    e.handleEvent(self.onOut)
                updateCursor = True
            if (overCandidateCount != 0):
                i = 0
                ev = self.onOver
                while True:
                    info = i
                    i = (i + 1)
                    info1 = (self.overCandidates[info] if info >= 0 and info < len(self.overCandidates) else None)
                    ev.relX = info1.x
                    ev.relY = info1.y
                    ev.relZ = info1.z
                    if info1.s.isInteractiveVisible(info1.i):
                        info1.i.handleEvent(ev)
                    else:
                        python_internal_ArrayImpl.remove(self.overList,info1.i)
                    info1.i = None
                    info1.s = None
                    if (not ((i < overCandidateCount))):
                        break
        self.overIndex = -1
        if updateCursor:
            self.selectCursor()
        if ((not handled) and ((event != self.checkPos))):
            if (event.kind == hxd_EventKind.EPush):
                _this = self.pushList
                _this.append(None)
            elif (event.kind == hxd_EventKind.ERelease):
                python_internal_ArrayImpl.remove(self.pushList,None)
            self.dispatchListeners(event)
        if ((event.kind == hxd_EventKind.ERelease) and ((len(self.pushList) > 0))):
            _g = 0
            _g1 = self.pushList
            while (_g < len(_g1)):
                i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (i is None):
                    event.kind = hxd_EventKind.EReleaseOutside
                    self.dispatchListeners(event)
                    event.kind = hxd_EventKind.ERelease
                else:
                    s = i.getInteractiveScene()
                    if (s is None):
                        continue
                    event.kind = hxd_EventKind.EReleaseOutside
                    s.dispatchEvent(event,i)
                    event.kind = hxd_EventKind.ERelease
                    event.relX = oldX
                    event.relY = oldY
            self.pushList = list()

    def checkEvents(self):
        old = self.pendingEvents
        checkMoved = (not self.mouseCheckMove)
        checkFocused = (self.currentFocus is None)
        if (len(old) > 0):
            self.pendingEvents = []
            _g = 0
            while (_g < len(old)):
                e = (old[_g] if _g >= 0 and _g < len(old) else None)
                _g = (_g + 1)
                ox = e.relX
                oy = e.relY
                tmp = e.kind.index
                if ((tmp == 1) or ((tmp == 0))):
                    self.mouseX = e.relX
                    self.mouseY = e.relY
                    self.lastTouch = e.touchId
                elif (tmp == 2):
                    checkMoved = True
                    self.mouseX = e.relX
                    self.mouseY = e.relY
                    self.lastTouch = e.touchId
                elif (tmp == 3):
                    self.isOut = False
                    self.selectCursor()
                    continue
                elif (tmp == 4):
                    self.isOut = True
                    if (len(self.overList) > 0):
                        i = (len(self.overList) - 1)
                        while (i >= 0):
                            self.onOut.cancel = False
                            (self.overList[i] if i >= 0 and i < len(self.overList) else None).handleEvent(self.onOut)
                            python_internal_ArrayImpl.remove(self.overList,(self.overList[i] if i >= 0 and i < len(self.overList) else None))
                            i = (i - 1)
                        self.selectCursor()
                    continue
                elif ((((tmp == 11) or ((tmp == 9))) or ((tmp == 8))) or ((tmp == 5))):
                    if (not checkFocused):
                        checkFocused = True
                        self.checkFocus()
                else:
                    pass
                if ((self.currentDrag is not None) and (((self.currentDrag.ref is None) or ((self.currentDrag.ref == e.touchId))))):
                    e.propagate = True
                    e.cancel = False
                    self.currentDrag.f(e)
                    e.relX = ox
                    e.relY = oy
                    if (not e.propagate):
                        continue
                self.emitEvent(e)
        if (not checkFocused):
            self.checkFocus()
        if (((not checkMoved) and (not self.isOut)) and ((self.currentDrag is None))):
            self.checkPos.relX = self.mouseX
            self.checkPos.relY = self.mouseY
            self.checkPos.touchId = self.lastTouch
            self.checkPos.cancel = False
            self.checkPos.propagate = False
            self.emitEvent(self.checkPos)

    def startCapture(self,f,onCancel = None,touchId = None):
        if ((self.currentDrag is not None) and ((self.currentDrag.onCancel is not None))):
            self.currentDrag.onCancel()
        self.currentDrag = _hx_AnonObject({'f': f, 'ref': touchId, 'onCancel': onCancel})

    def stopCapture(self):
        if ((self.currentDrag is not None) and ((self.currentDrag.onCancel is not None))):
            self.currentDrag.onCancel()
        self.currentDrag = None

    def startDrag(self,f,onCancel = None,refEvent = None):
        self.startCapture(f,onCancel,(refEvent.touchId if ((refEvent is not None)) else None))

    def stopDrag(self):
        self.stopCapture()

    def getFocus(self):
        return self.currentFocus

    def updateCursor(self,i):
        if (python_internal_ArrayImpl.indexOf(self.overList,i,None) != -1):
            self.selectCursor()

    def set_defaultCursor(self,c):
        if Type.enumEq(c,self.defaultCursor):
            return c
        self.defaultCursor = c
        self.selectCursor()
        return c

    def selectCursor(self):
        cur = self.defaultCursor
        _g = 0
        _g1 = self.overList
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (o.cursor is not None):
                cur = o.cursor
                break
        if (cur.index == 6):
            f = cur.params[0]
            f()
        else:
            hxd_System.setCursor(cur)

    def onEvent(self,e):
        if ((not self.enablePhysicalMouse) and ((e.kind == hxd_EventKind.EMove))):
            return
        _this = self.pendingEvents
        _this.append(e)

    def dispatchListeners(self,event):
        ox = event.relX
        oy = event.relY
        event.propagate = True
        _g = 0
        _g1 = self.scenes
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            event.cancel = False
            s.dispatchListeners(event)
            event.relX = ox
            event.relY = oy
            if (not event.propagate):
                break

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.window = None
        _hx_o.scenes = None
        _hx_o.overList = None
        _hx_o.overCandidates = None
        _hx_o.overIndex = None
        _hx_o.currentFocus = None
        _hx_o.pendingEvents = None
        _hx_o.pushList = None
        _hx_o.currentDrag = None
        _hx_o.mouseX = None
        _hx_o.mouseY = None
        _hx_o.lastTouch = None
        _hx_o.focusLost = None
        _hx_o.checkPos = None
        _hx_o.onOut = None
        _hx_o.onOver = None
        _hx_o.isOut = None
        _hx_o.enablePhysicalMouse = None
        _hx_o.mouseCheckMove = None
        _hx_o.defaultCursor = None
hxd_SceneEvents._hx_class = hxd_SceneEvents
_hx_classes["hxd.SceneEvents"] = hxd_SceneEvents

class hxd_Platform(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.Platform"
    _hx_constructs = ["IOS", "Android", "WebGL", "PC", "Console", "FlashPlayer"]
hxd_Platform.IOS = hxd_Platform("IOS", 0, ())
hxd_Platform.Android = hxd_Platform("Android", 1, ())
hxd_Platform.WebGL = hxd_Platform("WebGL", 2, ())
hxd_Platform.PC = hxd_Platform("PC", 3, ())
hxd_Platform.Console = hxd_Platform("Console", 4, ())
hxd_Platform.FlashPlayer = hxd_Platform("FlashPlayer", 5, ())
hxd_Platform._hx_class = hxd_Platform
_hx_classes["hxd.Platform"] = hxd_Platform

class hxd_SystemValue(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.SystemValue"
    _hx_constructs = ["IsTouch", "IsWindowed", "IsMobile"]
hxd_SystemValue.IsTouch = hxd_SystemValue("IsTouch", 0, ())
hxd_SystemValue.IsWindowed = hxd_SystemValue("IsWindowed", 1, ())
hxd_SystemValue.IsMobile = hxd_SystemValue("IsMobile", 2, ())
hxd_SystemValue._hx_class = hxd_SystemValue
_hx_classes["hxd.SystemValue"] = hxd_SystemValue


class hxd_System:
    _hx_class_name = "hxd.System"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["setCursor", "timeoutTick", "loopFunc", "getCurrentLoop", "setLoop", "start", "setNativeCursor", "getDeviceName", "getDefaultFrameRate", "getValue", "exit", "openURL", "get_width", "get_height", "get_lang", "get_platform", "get_screenDPI", "get_allowTimeout", "set_allowTimeout"]
    width = None
    height = None
    lang = None
    platform = None
    screenDPI = None
    allowTimeout = None
    loopFunc = None

    @staticmethod
    def timeoutTick():
        pass

    @staticmethod
    def getCurrentLoop():
        return hxd_System.loopFunc

    @staticmethod
    def setLoop(f):
        hxd_System.loopFunc = f

    @staticmethod
    def start(callb):
        pass

    @staticmethod
    def setNativeCursor(c):
        pass

    @staticmethod
    def getDeviceName():
        return "Unknown"

    @staticmethod
    def getDefaultFrameRate():
        return 60.

    @staticmethod
    def getValue(s):
        return False

    @staticmethod
    def exit():
        pass

    @staticmethod
    def openURL(url):
        pass

    @staticmethod
    def get_width():
        return 0

    @staticmethod
    def get_height():
        return 0

    @staticmethod
    def get_lang():
        return "en"

    @staticmethod
    def get_platform():
        return hxd_Platform.PC

    @staticmethod
    def get_screenDPI():
        return 72

    @staticmethod
    def get_allowTimeout():
        return False

    @staticmethod
    def set_allowTimeout(b):
        return False
hxd_System._hx_class = hxd_System
_hx_classes["hxd.System"] = hxd_System


class hxd_Timer:
    _hx_class_name = "hxd.Timer"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["wantedFPS", "maxDeltaTime", "smoothFactor", "lastTimeStamp", "elapsedTime", "frameCount", "dt", "currentDT", "update", "get_tmod", "set_tmod", "fps", "skip", "reset"]
    tmod = None

    @staticmethod
    def update():
        _hx_local_0 = hxd_Timer
        _hx_local_1 = _hx_local_0.frameCount
        _hx_local_0.frameCount = (_hx_local_1 + 1)
        _hx_local_1
        newTime = python_lib_Timeit.default_timer()
        hxd_Timer.elapsedTime = (newTime - hxd_Timer.lastTimeStamp)
        hxd_Timer.lastTimeStamp = newTime
        if (hxd_Timer.elapsedTime < hxd_Timer.maxDeltaTime):
            a = hxd_Timer.elapsedTime
            hxd_Timer.currentDT = (a + ((hxd_Timer.smoothFactor * ((hxd_Timer.currentDT - a)))))
        else:
            hxd_Timer.elapsedTime = (1 / hxd_Timer.wantedFPS)
        hxd_Timer.dt = hxd_Timer.currentDT

    @staticmethod
    def get_tmod():
        return (hxd_Timer.dt * hxd_Timer.wantedFPS)

    @staticmethod
    def set_tmod(v):
        hxd_Timer.dt = (v / hxd_Timer.wantedFPS)
        return v

    @staticmethod
    def fps():
        return (1. / hxd_Timer.currentDT)

    @staticmethod
    def skip():
        hxd_Timer.lastTimeStamp = python_lib_Timeit.default_timer()

    @staticmethod
    def reset():
        hxd_Timer.lastTimeStamp = python_lib_Timeit.default_timer()
        def _hx_local_0():
            hxd_Timer.currentDT = (1. / hxd_Timer.wantedFPS)
            return hxd_Timer.currentDT
        hxd_Timer.dt = _hx_local_0()
hxd_Timer._hx_class = hxd_Timer
_hx_classes["hxd.Timer"] = hxd_Timer

class hxd_DisplayMode(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.DisplayMode"
    _hx_constructs = ["Windowed", "Borderless", "Fullscreen", "FullscreenResize"]
hxd_DisplayMode.Windowed = hxd_DisplayMode("Windowed", 0, ())
hxd_DisplayMode.Borderless = hxd_DisplayMode("Borderless", 1, ())
hxd_DisplayMode.Fullscreen = hxd_DisplayMode("Fullscreen", 2, ())
hxd_DisplayMode.FullscreenResize = hxd_DisplayMode("FullscreenResize", 3, ())
hxd_DisplayMode._hx_class = hxd_DisplayMode
_hx_classes["hxd.DisplayMode"] = hxd_DisplayMode


class hxd_Window:
    _hx_class_name = "hxd.Window"
    _hx_is_interface = "False"
    _hx_fields = ["resizeEvents", "eventTargets"]
    _hx_methods = ["onClose", "event", "addEventTarget", "removeEventTarget", "addResizeEvent", "removeResizeEvent", "onResize", "resize", "setFullScreen", "get_mouseX", "get_mouseY", "get_width", "get_height", "get_mouseLock", "set_mouseLock", "get_vsync", "set_vsync", "get_isFocused", "get_displayMode", "set_displayMode", "get_title", "set_title"]
    _hx_statics = ["inst", "getInstance"]

    def __init__(self):
        self.eventTargets = haxe_ds_List()
        self.resizeEvents = haxe_ds_List()

    def onClose(self):
        return True

    def event(self,e):
        _g_head = self.eventTargets.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            et = val
            et(e)

    def addEventTarget(self,et):
        self.eventTargets.add(et)

    def removeEventTarget(self,et):
        _g_head = self.eventTargets.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            e = val
            if Reflect.compareMethods(e,et):
                self.eventTargets.remove(e)
                break

    def addResizeEvent(self,f):
        self.resizeEvents.push(f)

    def removeResizeEvent(self,f):
        _g_head = self.resizeEvents.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            e = val
            if Reflect.compareMethods(e,f):
                self.resizeEvents.remove(f)
                break

    def onResize(self,e):
        _g_head = self.resizeEvents.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            r = val
            r()

    def resize(self,width,height):
        pass

    def setFullScreen(self,v):
        pass

    def get_mouseX(self):
        return 0

    def get_mouseY(self):
        return 0

    def get_width(self):
        return 0

    def get_height(self):
        return 0

    def get_mouseLock(self):
        return False

    def set_mouseLock(self,v):
        if v:
            raise haxe_Exception.thrown("Not implemented")
        return False

    def get_vsync(self):
        return True

    def set_vsync(self,b):
        if (not b):
            raise haxe_Exception.thrown("Can't disable vsync on this platform")
        return True

    def get_isFocused(self):
        return True

    def get_displayMode(self):
        return hxd_DisplayMode.Windowed

    def set_displayMode(self,m):
        return m

    def get_title(self):
        return ""

    def set_title(self,t):
        return t

    @staticmethod
    def getInstance():
        if (hxd_Window.inst is None):
            hxd_Window.inst = hxd_Window()
        return hxd_Window.inst

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.resizeEvents = None
        _hx_o.eventTargets = None
hxd_Window._hx_class = hxd_Window
_hx_classes["hxd.Window"] = hxd_Window

class hxd_clipper_ClipType(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.ClipType"
    _hx_constructs = ["Intersection", "Union", "Difference", "Xor"]
hxd_clipper_ClipType.Intersection = hxd_clipper_ClipType("Intersection", 0, ())
hxd_clipper_ClipType.Union = hxd_clipper_ClipType("Union", 1, ())
hxd_clipper_ClipType.Difference = hxd_clipper_ClipType("Difference", 2, ())
hxd_clipper_ClipType.Xor = hxd_clipper_ClipType("Xor", 3, ())
hxd_clipper_ClipType._hx_class = hxd_clipper_ClipType
_hx_classes["hxd.clipper.ClipType"] = hxd_clipper_ClipType

class hxd_clipper__Clipper_EdgeSide(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper._Clipper.EdgeSide"
    _hx_constructs = ["Left", "Right"]
hxd_clipper__Clipper_EdgeSide.Left = hxd_clipper__Clipper_EdgeSide("Left", 0, ())
hxd_clipper__Clipper_EdgeSide.Right = hxd_clipper__Clipper_EdgeSide("Right", 1, ())
hxd_clipper__Clipper_EdgeSide._hx_class = hxd_clipper__Clipper_EdgeSide
_hx_classes["hxd.clipper._Clipper.EdgeSide"] = hxd_clipper__Clipper_EdgeSide

class hxd_clipper__Clipper_Direction(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper._Clipper.Direction"
    _hx_constructs = ["RightToLeft", "LeftToRight"]
hxd_clipper__Clipper_Direction.RightToLeft = hxd_clipper__Clipper_Direction("RightToLeft", 0, ())
hxd_clipper__Clipper_Direction.LeftToRight = hxd_clipper__Clipper_Direction("LeftToRight", 1, ())
hxd_clipper__Clipper_Direction._hx_class = hxd_clipper__Clipper_Direction
_hx_classes["hxd.clipper._Clipper.Direction"] = hxd_clipper__Clipper_Direction


class hxd_clipper__Clipper_PolyNode:
    _hx_class_name = "hxd.clipper._Clipper.PolyNode"
    _hx_is_interface = "False"
    __slots__ = ("parent", "childs", "polygon", "index", "jointype", "endtype")
    _hx_fields = ["parent", "childs", "polygon", "index", "jointype", "endtype"]
    _hx_methods = ["isHoleNode", "get_childCount", "get_contour", "addChild", "getNext", "getNextSiblingUp", "isHole"]

    def __init__(self):
        self.endtype = None
        self.jointype = None
        self.index = None
        self.parent = None
        points = []
        this1 = ([] if ((points is None)) else points)
        self.polygon = this1
        self.childs = []

    def isHoleNode(self):
        result = True
        node = self.parent
        while (node is not None):
            result = (not result)
            node = node.parent
        return result

    def get_childCount(self):
        return len(self.childs)

    def get_contour(self):
        return self.polygon

    def addChild(self,child):
        cnt = len(self.childs)
        _this = self.childs
        _this.append(child)
        child.parent = self
        child.index = cnt

    def getNext(self):
        if (len(self.childs) > 0):
            return (self.childs[0] if 0 < len(self.childs) else None)
        else:
            return self.getNextSiblingUp()

    def getNextSiblingUp(self):
        if (self.parent is None):
            return None
        elif (self.index == ((len(self.parent.childs) - 1))):
            return self.parent.getNextSiblingUp()
        else:
            return python_internal_ArrayImpl._get(self.parent.childs, (self.index + 1))

    def isHole(self):
        return self.isHoleNode()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.parent = None
        _hx_o.childs = None
        _hx_o.polygon = None
        _hx_o.index = None
        _hx_o.jointype = None
        _hx_o.endtype = None
hxd_clipper__Clipper_PolyNode._hx_class = hxd_clipper__Clipper_PolyNode
_hx_classes["hxd.clipper._Clipper.PolyNode"] = hxd_clipper__Clipper_PolyNode


class hxd_clipper__Clipper_PolyTree(hxd_clipper__Clipper_PolyNode):
    _hx_class_name = "hxd.clipper._Clipper.PolyTree"
    _hx_is_interface = "False"
    __slots__ = ("allPolys",)
    _hx_fields = ["allPolys"]
    _hx_methods = ["toPolygons", "addRec", "clear", "getFirst", "get_total"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_clipper__Clipper_PolyNode


    def __init__(self):
        self.allPolys = None
        super().__init__()
        self.allPolys = []

    def toPolygons(self,polygons):
        polygons = []
        self.addRec(self,polygons)

    def addRec(self,polynode,polygons):
        if (len(polynode.polygon) > 0):
            x = polynode.polygon
            polygons.append(x)
        _g = 0
        _g1 = polynode.childs
        while (_g < len(_g1)):
            pn = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.addRec(pn,polygons)

    def clear(self):
        self.allPolys = []
        self.childs = []

    def getFirst(self):
        if (len(self.childs) > 0):
            return (self.childs[0] if 0 < len(self.childs) else None)
        return None

    def get_total(self):
        result = len(self.allPolys)
        if ((result > 0) and (((self.childs[0] if 0 < len(self.childs) else None) != (self.allPolys[0] if 0 < len(self.allPolys) else None)))):
            result = (result - 1)
        return result

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.allPolys = None
hxd_clipper__Clipper_PolyTree._hx_class = hxd_clipper__Clipper_PolyTree
_hx_classes["hxd.clipper._Clipper.PolyTree"] = hxd_clipper__Clipper_PolyTree


class hxd_clipper__Clipper_Ref:
    _hx_class_name = "hxd.clipper._Clipper.Ref"
    _hx_is_interface = "False"
    __slots__ = ("val",)
    _hx_fields = ["val"]

    def __init__(self,v = None):
        self.val = v

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.val = None
hxd_clipper__Clipper_Ref._hx_class = hxd_clipper__Clipper_Ref
_hx_classes["hxd.clipper._Clipper.Ref"] = hxd_clipper__Clipper_Ref


class hxd_clipper__Clipper_TEdge:
    _hx_class_name = "hxd.clipper._Clipper.TEdge"
    _hx_is_interface = "False"
    __slots__ = ("botX", "botY", "currX", "currY", "topX", "topY", "deltaX", "deltaY", "dx", "polyType", "side", "windDelta", "windCnt", "windCnt2", "outIdx", "next", "prev", "nextInLML", "nextInAEL", "prevInAEL", "nextInSEL", "prevInSEL")
    _hx_fields = ["botX", "botY", "currX", "currY", "topX", "topY", "deltaX", "deltaY", "dx", "polyType", "side", "windDelta", "windCnt", "windCnt2", "outIdx", "next", "prev", "nextInLML", "nextInAEL", "prevInAEL", "nextInSEL", "prevInSEL"]
    _hx_methods = ["get_top", "get_bot", "get_curr", "set_top", "set_bot", "set_curr"]

    def __init__(self):
        self.prevInSEL = None
        self.nextInSEL = None
        self.prevInAEL = None
        self.nextInAEL = None
        self.nextInLML = None
        self.prev = None
        self.next = None
        self.outIdx = None
        self.windCnt2 = None
        self.windCnt = None
        self.windDelta = None
        self.side = None
        self.polyType = None
        self.dx = None
        self.deltaY = None
        self.deltaX = None
        self.topY = None
        self.topX = None
        self.currY = None
        self.currX = None
        self.botY = None
        self.botX = None

    def get_top(self):
        return h2d_col_IPoint(self.topX,self.topY)

    def get_bot(self):
        return h2d_col_IPoint(self.botX,self.botY)

    def get_curr(self):
        return h2d_col_IPoint(self.currX,self.currY)

    def set_top(self,p):
        self.topX = p.x
        self.topY = p.y
        return p

    def set_bot(self,p):
        self.botX = p.x
        self.botY = p.y
        return p

    def set_curr(self,p):
        self.currX = p.x
        self.currY = p.y
        return p

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.botX = None
        _hx_o.botY = None
        _hx_o.currX = None
        _hx_o.currY = None
        _hx_o.topX = None
        _hx_o.topY = None
        _hx_o.deltaX = None
        _hx_o.deltaY = None
        _hx_o.dx = None
        _hx_o.polyType = None
        _hx_o.side = None
        _hx_o.windDelta = None
        _hx_o.windCnt = None
        _hx_o.windCnt2 = None
        _hx_o.outIdx = None
        _hx_o.next = None
        _hx_o.prev = None
        _hx_o.nextInLML = None
        _hx_o.nextInAEL = None
        _hx_o.prevInAEL = None
        _hx_o.nextInSEL = None
        _hx_o.prevInSEL = None
hxd_clipper__Clipper_TEdge._hx_class = hxd_clipper__Clipper_TEdge
_hx_classes["hxd.clipper._Clipper.TEdge"] = hxd_clipper__Clipper_TEdge


class hxd_clipper__Clipper_IntersectNode:
    _hx_class_name = "hxd.clipper._Clipper.IntersectNode"
    _hx_is_interface = "False"
    __slots__ = ("edge1", "edge2", "pt")
    _hx_fields = ["edge1", "edge2", "pt"]

    def __init__(self):
        self.pt = None
        self.edge2 = None
        self.edge1 = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.edge1 = None
        _hx_o.edge2 = None
        _hx_o.pt = None
hxd_clipper__Clipper_IntersectNode._hx_class = hxd_clipper__Clipper_IntersectNode
_hx_classes["hxd.clipper._Clipper.IntersectNode"] = hxd_clipper__Clipper_IntersectNode


class hxd_clipper__Clipper_LocalMinima:
    _hx_class_name = "hxd.clipper._Clipper.LocalMinima"
    _hx_is_interface = "False"
    __slots__ = ("y", "leftBound", "rightBound", "next")
    _hx_fields = ["y", "leftBound", "rightBound", "next"]

    def __init__(self):
        self.next = None
        self.rightBound = None
        self.leftBound = None
        self.y = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.y = None
        _hx_o.leftBound = None
        _hx_o.rightBound = None
        _hx_o.next = None
hxd_clipper__Clipper_LocalMinima._hx_class = hxd_clipper__Clipper_LocalMinima
_hx_classes["hxd.clipper._Clipper.LocalMinima"] = hxd_clipper__Clipper_LocalMinima


class hxd_clipper__Clipper_Scanbeam:
    _hx_class_name = "hxd.clipper._Clipper.Scanbeam"
    _hx_is_interface = "False"
    __slots__ = ("y", "next")
    _hx_fields = ["y", "next"]

    def __init__(self):
        self.next = None
        self.y = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.y = None
        _hx_o.next = None
hxd_clipper__Clipper_Scanbeam._hx_class = hxd_clipper__Clipper_Scanbeam
_hx_classes["hxd.clipper._Clipper.Scanbeam"] = hxd_clipper__Clipper_Scanbeam


class hxd_clipper__Clipper_OutRec:
    _hx_class_name = "hxd.clipper._Clipper.OutRec"
    _hx_is_interface = "False"
    __slots__ = ("idx", "isHole", "firstLeft", "pts", "bottomPt", "polyNode")
    _hx_fields = ["idx", "isHole", "firstLeft", "pts", "bottomPt", "polyNode"]

    def __init__(self):
        self.polyNode = None
        self.bottomPt = None
        self.pts = None
        self.firstLeft = None
        self.isHole = None
        self.idx = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.idx = None
        _hx_o.isHole = None
        _hx_o.firstLeft = None
        _hx_o.pts = None
        _hx_o.bottomPt = None
        _hx_o.polyNode = None
hxd_clipper__Clipper_OutRec._hx_class = hxd_clipper__Clipper_OutRec
_hx_classes["hxd.clipper._Clipper.OutRec"] = hxd_clipper__Clipper_OutRec


class hxd_clipper__Clipper_OutPt:
    _hx_class_name = "hxd.clipper._Clipper.OutPt"
    _hx_is_interface = "False"
    __slots__ = ("idx", "pt", "next", "prev")
    _hx_fields = ["idx", "pt", "next", "prev"]

    def __init__(self):
        self.prev = None
        self.next = None
        self.pt = None
        self.idx = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.idx = None
        _hx_o.pt = None
        _hx_o.next = None
        _hx_o.prev = None
hxd_clipper__Clipper_OutPt._hx_class = hxd_clipper__Clipper_OutPt
_hx_classes["hxd.clipper._Clipper.OutPt"] = hxd_clipper__Clipper_OutPt


class hxd_clipper__Clipper_Join:
    _hx_class_name = "hxd.clipper._Clipper.Join"
    _hx_is_interface = "False"
    __slots__ = ("outPt1", "outPt2", "offPt")
    _hx_fields = ["outPt1", "outPt2", "offPt"]

    def __init__(self):
        self.offPt = None
        self.outPt2 = None
        self.outPt1 = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.outPt1 = None
        _hx_o.outPt2 = None
        _hx_o.offPt = None
hxd_clipper__Clipper_Join._hx_class = hxd_clipper__Clipper_Join
_hx_classes["hxd.clipper._Clipper.Join"] = hxd_clipper__Clipper_Join


class hxd_clipper__Clipper_ClipperBase:
    _hx_class_name = "hxd.clipper._Clipper.ClipperBase"
    _hx_is_interface = "False"
    __slots__ = ("preserveCollinear", "m_MinimaList", "m_CurrentLM", "m_edges")
    _hx_fields = ["preserveCollinear", "m_MinimaList", "m_CurrentLM", "m_edges"]
    _hx_methods = ["isHorizontal", "abs", "PointIsVertex", "PointOnLineSegment", "PointOnPolygon", "SlopesEqual", "SlopesEqual3", "clear", "disposeLocalMinimaList", "addPolygons", "addPolygon", "InitEdge", "InitEdge2", "RemoveEdge", "FindNextLocMin", "ProcessBound", "ReverseHorizontal", "Pt2IsBetweenPt1AndPt3", "SetDx", "InsertLocalMinima", "PopLocalMinima", "SwapX", "equals", "Reset"]
    _hx_statics = ["HORIZONTAL", "TOLERANCE", "SKIP", "UNASSIGNED", "nearZero", "getBounds"]

    def __init__(self):
        self.preserveCollinear = None
        self.m_edges = []
        self.m_MinimaList = None
        self.m_CurrentLM = None

    def isHorizontal(self,e):
        return (e.deltaY == 0)

    def abs(self,i):
        if (i < 0):
            return -i
        else:
            return i

    def PointIsVertex(self,pt,pp):
        pp2 = pp
        while True:
            pt1 = pp2.pt
            if ((pt1.x == pt.x) and ((pt1.y == pt.y))):
                return True
            pp2 = pp2.next
            if (not ((pp2 != pp))):
                break
        return False

    def PointOnLineSegment(self,pt,linePt1,linePt2):
        if (not ((((pt.x == linePt1.x) and ((pt.y == linePt1.y))) or (((pt.x == linePt2.x) and ((pt.y == linePt2.y))))))):
            if (((pt.x > linePt1.x) == ((pt.x < linePt2.x))) and (((pt.y > linePt1.y) == ((pt.y < linePt2.y))))):
                return ((((pt.x - linePt1.x)) * ((linePt2.y - linePt1.y))) == ((((linePt2.x - linePt1.x)) * ((pt.y - linePt1.y)))))
            else:
                return False
        else:
            return True

    def PointOnPolygon(self,pt,pp):
        pp2 = pp
        while True:
            if self.PointOnLineSegment(pt,pp2.pt,pp2.next.pt):
                return True
            pp2 = pp2.next
            if (pp2 == pp):
                break
        return False

    def SlopesEqual(self,e1,e2):
        return ((e1.deltaY * e2.deltaX) == ((e1.deltaX * e2.deltaY)))

    def SlopesEqual3(self,pt1,pt2,pt3):
        return (((((pt1.y - pt2.y)) * ((pt2.x - pt3.x))) - ((((pt1.x - pt2.x)) * ((pt2.y - pt3.y))))) == 0)

    def clear(self):
        self.disposeLocalMinimaList()
        self.m_edges = []

    def disposeLocalMinimaList(self):
        while (self.m_MinimaList is not None):
            tmpLm = self.m_MinimaList.next
            self.m_MinimaList = None
            self.m_MinimaList = tmpLm
        self.m_CurrentLM = None

    def addPolygons(self,ppg,polyType):
        result = False
        _g_i = 0
        _g_a = ppg
        _g_l = len(_g_a)
        while (_g_i < _g_l):
            p = _g_i
            _g_i = (_g_i + 1)
            p1 = (_g_a[p] if p >= 0 and p < len(_g_a) else None)
            if self.addPolygon(p1,polyType):
                result = True
        return result

    def addPolygon(self,pg,polyType):
        highI = (len(pg) - 1)
        while ((highI > 0) and (((pg[highI] if highI >= 0 and highI < len(pg) else None) == (pg[0] if 0 < len(pg) else None)))):
            highI = (highI - 1)
        while ((highI > 0) and (((pg[highI] if highI >= 0 and highI < len(pg) else None) == python_internal_ArrayImpl._get(pg, (highI - 1))))):
            highI = (highI - 1)
        if (highI < 2):
            return False
        edges = []
        _g = 0
        _g1 = (highI + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = hxd_clipper__Clipper_TEdge()
            edges.append(x)
        isFlat = True
        _this = (edges[1] if 1 < len(edges) else None)
        p = (pg[1] if 1 < len(pg) else None)
        _this.currX = p.x
        _this.currY = p.y
        e = (edges[0] if 0 < len(edges) else None)
        pt = (pg[0] if 0 < len(pg) else None)
        e.next = (edges[1] if 1 < len(edges) else None)
        e.prev = (edges[highI] if highI >= 0 and highI < len(edges) else None)
        e.currX = pt.x
        e.currY = pt.y
        e.outIdx = -1
        e = (edges[highI] if highI >= 0 and highI < len(edges) else None)
        pt = (pg[highI] if highI >= 0 and highI < len(pg) else None)
        e.next = (edges[0] if 0 < len(edges) else None)
        e.prev = python_internal_ArrayImpl._get(edges, (highI - 1))
        e.currX = pt.x
        e.currY = pt.y
        e.outIdx = -1
        i = (highI - 1)
        while (i > 0):
            e = (edges[i] if i >= 0 and i < len(edges) else None)
            pt = (pg[i] if i >= 0 and i < len(pg) else None)
            e.next = python_internal_ArrayImpl._get(edges, (i + 1))
            e.prev = python_internal_ArrayImpl._get(edges, (i - 1))
            e.currX = pt.x
            e.currY = pt.y
            e.outIdx = -1
            i = (i - 1)
        eStart = (edges[0] if 0 < len(edges) else None)
        eStop = eStart
        e = eStart
        while True:
            if ((e.currX == e.next.currX) and ((e.currY == e.next.currY))):
                if (e == e.next):
                    break
                if (e == eStart):
                    eStart = e.next
                e = self.RemoveEdge(e)
                eStop = e
                continue
            if (e.prev == e.next):
                break
            tmp = None
            _this = e.prev
            x = _this.currX
            y = _this.currY
            if (y is None):
                y = 0
            if (x is None):
                x = 0
            pt1_x = x
            pt1_y = y
            x1 = e.currX
            y1 = e.currY
            if (y1 is None):
                y1 = 0
            if (x1 is None):
                x1 = 0
            pt2_x = x1
            pt2_y = y1
            _this1 = e.next
            x2 = _this1.currX
            y2 = _this1.currY
            if (y2 is None):
                y2 = 0
            if (x2 is None):
                x2 = 0
            pt3_x = x2
            pt3_y = y2
            if (((((pt1_y - pt2_y)) * ((pt2_x - pt3_x))) - ((((pt1_x - pt2_x)) * ((pt2_y - pt3_y))))) == 0):
                if self.preserveCollinear:
                    _this2 = e.prev
                    tmp1 = h2d_col_IPoint(_this2.currX,_this2.currY)
                    tmp2 = h2d_col_IPoint(e.currX,e.currY)
                    _this3 = e.next
                    tmp = (not self.Pt2IsBetweenPt1AndPt3(tmp1,tmp2,h2d_col_IPoint(_this3.currX,_this3.currY)))
                else:
                    tmp = True
            else:
                tmp = False
            if tmp:
                if (e == eStart):
                    eStart = e.next
                e = self.RemoveEdge(e)
                e = e.prev
                eStop = e
                continue
            e = e.next
            if (e == eStop):
                break
        if (e.prev == e.next):
            return False
        e = eStart
        while True:
            if (e.currY >= e.next.currY):
                e.botX = e.currX
                e.botY = e.currY
                e.topX = e.next.currX
                e.topY = e.next.currY
            else:
                e.topX = e.currX
                e.topY = e.currY
                e.botX = e.next.currX
                e.botY = e.next.currY
            self.SetDx(e)
            e.polyType = polyType
            e = e.next
            if (e.currY != eStart.currY):
                isFlat = False
            if (not ((e != eStart))):
                break
        if isFlat:
            return False
        _this = self.m_edges
        _this.append(edges)
        leftBoundIsForward = None
        eMin = None
        if ((e.prev.botX == e.prev.topX) and ((e.prev.botY == e.prev.topY))):
            e = e.next
        old = None
        while True:
            e = self.FindNextLocMin(e)
            if (e == eMin):
                break
            elif (eMin is None):
                eMin = e
            if (e == old):
                raise haxe_Exception.thrown("!")
            old = e
            locMin = hxd_clipper__Clipper_LocalMinima()
            locMin.next = None
            locMin.y = e.botY
            if (e.dx < e.prev.dx):
                locMin.leftBound = e.prev
                locMin.rightBound = e
                leftBoundIsForward = False
            else:
                locMin.leftBound = e
                locMin.rightBound = e.prev
                leftBoundIsForward = True
            locMin.leftBound.side = hxd_clipper__Clipper_EdgeSide.Left
            locMin.rightBound.side = hxd_clipper__Clipper_EdgeSide.Right
            if (locMin.leftBound.next == locMin.rightBound):
                locMin.leftBound.windDelta = -1
            else:
                locMin.leftBound.windDelta = 1
            locMin.rightBound.windDelta = -locMin.leftBound.windDelta
            e = self.ProcessBound(locMin.leftBound,leftBoundIsForward)
            if (e.outIdx == -2):
                e = self.ProcessBound(e,leftBoundIsForward)
            e2 = self.ProcessBound(locMin.rightBound,(not leftBoundIsForward))
            if (e2.outIdx == -2):
                e2 = self.ProcessBound(e2,(not leftBoundIsForward))
            if (locMin.leftBound.outIdx == -2):
                locMin.leftBound = None
            elif (locMin.rightBound.outIdx == -2):
                locMin.rightBound = None
            self.InsertLocalMinima(locMin)
            if (not leftBoundIsForward):
                e = e2
        return True

    def InitEdge(self,e,eNext,ePrev,pt):
        e.next = eNext
        e.prev = ePrev
        e.currX = pt.x
        e.currY = pt.y
        e.outIdx = -1

    def InitEdge2(self,e,polyType):
        if (e.currY >= e.next.currY):
            e.botX = e.currX
            e.botY = e.currY
            e.topX = e.next.currX
            e.topY = e.next.currY
        else:
            e.topX = e.currX
            e.topY = e.currY
            e.botX = e.next.currX
            e.botY = e.next.currY
        self.SetDx(e)
        e.polyType = polyType

    def RemoveEdge(self,e):
        e.prev.next = e.next
        e.next.prev = e.prev
        result = e.next
        e.prev = None
        return result

    def FindNextLocMin(self,e):
        e2 = None
        while True:
            while (((e.botX != e.prev.botX) or ((e.botY != e.prev.botY))) or (((e.currX == e.topX) and ((e.currY == e.topY))))):
                e = e.next
            if ((e.dx != -9007199254740992.) and ((e.prev.dx != -9007199254740992.))):
                break
            while (e.prev.dx == -9007199254740992.):
                e = e.prev
            e2 = e
            while (e.dx == -9007199254740992.):
                e = e.next
            if (e.topY == e.prev.botY):
                continue
            if (e2.prev.botX < e.botX):
                e = e2
            break
        return e

    def ProcessBound(self,E,LeftBoundIsForward):
        EStart = None
        Horz = None
        Result = E
        if (Result.outIdx == -2):
            E = Result
            if LeftBoundIsForward:
                while (E.topY == E.next.botY):
                    E = E.next
                while ((E != Result) and ((E.dx == -9007199254740992.))):
                    E = E.prev
            else:
                while (E.topY == E.prev.botY):
                    E = E.prev
                while ((E != Result) and ((E.dx == -9007199254740992.))):
                    E = E.next
            if (E == Result):
                if LeftBoundIsForward:
                    Result = E.next
                else:
                    Result = E.prev
            else:
                if LeftBoundIsForward:
                    E = Result.next
                else:
                    E = Result.prev
                locMin = hxd_clipper__Clipper_LocalMinima()
                locMin.next = None
                locMin.y = E.botY
                locMin.leftBound = None
                locMin.rightBound = E
                E.windDelta = 0
                Result = self.ProcessBound(E,LeftBoundIsForward)
                self.InsertLocalMinima(locMin)
            return Result
        if (E.dx == -9007199254740992.):
            if LeftBoundIsForward:
                EStart = E.prev
            else:
                EStart = E.next
            if (EStart.outIdx != -2):
                if (EStart.dx == -9007199254740992.):
                    if ((EStart.botX != E.botX) and ((EStart.topX != E.botX))):
                        self.ReverseHorizontal(E)
                elif (EStart.botX != E.botX):
                    self.ReverseHorizontal(E)
        EStart = E
        if LeftBoundIsForward:
            while ((Result.topY == Result.next.botY) and ((Result.next.outIdx != -2))):
                Result = Result.next
            if ((Result.dx == -9007199254740992.) and ((Result.next.outIdx != -2))):
                Horz = Result
                while (Horz.prev.dx == -9007199254740992.):
                    Horz = Horz.prev
                if (Horz.prev.topX == Result.next.topX):
                    if (not LeftBoundIsForward):
                        Result = Horz.prev
                elif (Horz.prev.topX > Result.next.topX):
                    Result = Horz.prev
            while (E != Result):
                E.nextInLML = E.next
                if (((E.dx == -9007199254740992.) and ((E != EStart))) and ((E.botX != E.prev.topX))):
                    self.ReverseHorizontal(E)
                E = E.next
            if (((E.dx == -9007199254740992.) and ((E != EStart))) and ((E.botX != E.prev.topX))):
                self.ReverseHorizontal(E)
            Result = Result.next
        else:
            while ((Result.topY == Result.prev.botY) and ((Result.prev.outIdx != -2))):
                Result = Result.prev
            if ((Result.dx == -9007199254740992.) and ((Result.prev.outIdx != -2))):
                Horz = Result
                while (Horz.next.dx == -9007199254740992.):
                    Horz = Horz.next
                if (Horz.next.topX == Result.prev.topX):
                    if (not LeftBoundIsForward):
                        Result = Horz.next
                elif (Horz.next.topX > Result.prev.topX):
                    Result = Horz.next
            while (E != Result):
                E.nextInLML = E.prev
                if (((E.dx == -9007199254740992.) and ((E != EStart))) and ((E.botX != E.next.topX))):
                    self.ReverseHorizontal(E)
                E = E.prev
            if (((E.dx == -9007199254740992.) and ((E != EStart))) and ((E.botX != E.next.topX))):
                self.ReverseHorizontal(E)
            Result = Result.prev
        return Result

    def ReverseHorizontal(self,e):
        tmp = e.topX
        e.topX = e.botX
        e.botX = tmp

    def Pt2IsBetweenPt1AndPt3(self,pt1,pt2,pt3):
        if ((((pt1.x == pt3.x) and ((pt1.y == pt3.y))) or (((pt1.x == pt2.x) and ((pt1.y == pt2.y))))) or (((pt3.x == pt2.x) and ((pt3.y == pt2.y))))):
            return False
        elif (pt1.x != pt3.x):
            return ((pt2.x > pt1.x) == ((pt2.x < pt3.x)))
        else:
            return ((pt2.y > pt1.y) == ((pt2.y < pt3.y)))

    def SetDx(self,e):
        e.deltaX = (e.topX - e.botX)
        e.deltaY = (e.topY - e.botY)
        if (e.deltaY == 0):
            e.dx = -9007199254740992.
        else:
            e.dx = (e.deltaX / e.deltaY)

    def InsertLocalMinima(self,newLm):
        if (self.m_MinimaList is None):
            self.m_MinimaList = newLm
        elif (newLm.y >= self.m_MinimaList.y):
            newLm.next = self.m_MinimaList
            self.m_MinimaList = newLm
        else:
            tmpLm = self.m_MinimaList
            while ((tmpLm.next is not None) and ((newLm.y < tmpLm.next.y))):
                tmpLm = tmpLm.next
            newLm.next = tmpLm.next
            tmpLm.next = newLm

    def PopLocalMinima(self):
        if (self.m_CurrentLM is None):
            return
        self.m_CurrentLM = self.m_CurrentLM.next

    def SwapX(self,e):
        e.currX = e.topX
        e.topX = e.botX
        e.botX = e.currX

    def equals(self,pt1,pt2):
        if (pt1.x == pt2.x):
            return (pt1.y == pt2.y)
        else:
            return False

    def Reset(self):
        self.m_CurrentLM = self.m_MinimaList
        lm = self.m_MinimaList
        while (lm is not None):
            e = lm.leftBound
            if (e is not None):
                e.currX = e.botX
                e.currY = e.botY
                e.side = hxd_clipper__Clipper_EdgeSide.Left
                e.outIdx = -1
                e = e.nextInLML
            e = lm.rightBound
            if (e is not None):
                e.currX = e.botX
                e.currY = e.botY
                e.side = hxd_clipper__Clipper_EdgeSide.Right
                e.outIdx = -1
                e = e.nextInLML
            lm = lm.next

    @staticmethod
    def nearZero(v):
        if (v > -1e-20):
            return (v < 1E-20)
        else:
            return False

    @staticmethod
    def getBounds(pols):
        result = hxd_clipper_Rect()
        i = 0
        count = len(pols)
        while ((i < count) and ((len((pols[i] if i >= 0 and i < len(pols) else None)) == 0))):
            i = (i + 1)
        tmp = (i == count)
        def _hx_local_1():
            result.right = python_internal_ArrayImpl._get((pols[i] if i >= 0 and i < len(pols) else None), 0).x
            return result.right
        result.left = _hx_local_1()
        def _hx_local_2():
            result.bottom = python_internal_ArrayImpl._get((pols[i] if i >= 0 and i < len(pols) else None), 0).y
            return result.bottom
        result.top = _hx_local_2()
        _g = 0
        _g1 = count
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g_i = 0
            _g_a = (pols[i] if i >= 0 and i < len(pols) else None)
            _g_l = len(_g_a)
            while (_g_i < _g_l):
                p = _g_i
                _g_i = (_g_i + 1)
                p1 = (_g_a[p] if p >= 0 and p < len(_g_a) else None)
                if (p1.x < result.left):
                    result.left = p1.x
                elif (p1.x > result.right):
                    result.right = p1.x
                if (p1.y < result.top):
                    result.top = p1.y
                elif (p1.y > result.bottom):
                    result.bottom = p1.y
        return result

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.preserveCollinear = None
        _hx_o.m_MinimaList = None
        _hx_o.m_CurrentLM = None
        _hx_o.m_edges = None
hxd_clipper__Clipper_ClipperBase._hx_class = hxd_clipper__Clipper_ClipperBase
_hx_classes["hxd.clipper._Clipper.ClipperBase"] = hxd_clipper__Clipper_ClipperBase

class hxd_clipper_NodeType(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.NodeType"
    _hx_constructs = ["Any", "Open", "Closed"]
hxd_clipper_NodeType.Any = hxd_clipper_NodeType("Any", 0, ())
hxd_clipper_NodeType.Open = hxd_clipper_NodeType("Open", 1, ())
hxd_clipper_NodeType.Closed = hxd_clipper_NodeType("Closed", 2, ())
hxd_clipper_NodeType._hx_class = hxd_clipper_NodeType
_hx_classes["hxd.clipper.NodeType"] = hxd_clipper_NodeType

class hxd_clipper_ResultKind(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.ResultKind"
    _hx_constructs = ["All", "NoHoles", "HolesOnly"]
hxd_clipper_ResultKind.All = hxd_clipper_ResultKind("All", 0, ())
hxd_clipper_ResultKind.NoHoles = hxd_clipper_ResultKind("NoHoles", 1, ())
hxd_clipper_ResultKind.HolesOnly = hxd_clipper_ResultKind("HolesOnly", 2, ())
hxd_clipper_ResultKind._hx_class = hxd_clipper_ResultKind
_hx_classes["hxd.clipper.ResultKind"] = hxd_clipper_ResultKind


class hxd_clipper_Clipper(hxd_clipper__Clipper_ClipperBase):
    _hx_class_name = "hxd.clipper.Clipper"
    _hx_is_interface = "False"
    __slots__ = ("strictlySimple", "reverseSolution", "resultKind", "m_PolyOuts", "m_ClipType", "m_Scanbeam", "m_ActiveEdges", "m_SortedEdges", "m_IntersectList", "m_ExecuteLocked", "m_ClipFillType", "m_SubjFillType", "m_Joins", "m_GhostJoins", "m_UsingPolyTree")
    _hx_fields = ["strictlySimple", "reverseSolution", "resultKind", "m_PolyOuts", "m_ClipType", "m_Scanbeam", "m_ActiveEdges", "m_SortedEdges", "m_IntersectList", "m_ExecuteLocked", "m_ClipFillType", "m_SubjFillType", "m_Joins", "m_GhostJoins", "m_UsingPolyTree"]
    _hx_methods = ["xor", "DisposeScanbeamList", "Reset", "InsertScanbeam", "execute", "ExecuteTree", "FixHoleLinkage", "ExecuteInternal", "PopScanbeam", "DisposeAllPolyPts", "DisposeOutRec", "AddJoin", "AddGhostJoin", "InsertLocalMinimaIntoAEL", "InsertEdgeIntoAEL", "E2InsertsBeforeE1", "IsEvenOddFillType", "IsEvenOddAltFillType", "IsContributing", "SetWindingCount", "AddEdgeToSEL", "CopyAELToSEL", "SwapPositionsInAEL", "SwapPositionsInSEL", "AddLocalMaxPoly", "AddLocalMinPoly", "CreateOutRec", "AddOutPt", "HorzSegmentsOverlap", "SetHoleState", "GetDx", "FirstIsBottomPt", "GetBottomPt", "GetLowermostRec", "Param1RightOfParam2", "GetOutRec", "AppendPolygon", "ReversePolyPtLinks", "SwapSides", "SwapPolyIndexes", "IntersectEdges", "DeleteFromAEL", "DeleteFromSEL", "UpdateEdgeIntoAEL", "GetHorzDirection", "ProcessHorizontals", "ProcessHorizontal", "GetNextInAEL", "IsMinima", "IsMaxima", "IsIntermediate", "GetMaximaPair", "ProcessIntersections", "BuildIntersectList", "EdgesAdjacent", "IntersectNodeSort", "FixupIntersectionOrder", "ProcessIntersectList", "Round", "TopX", "IntersectPoint", "ProcessEdgesAtTopOfScanbeam", "DoMaxima", "reversePolygons", "PointCount", "BuildResult", "BuildResult2", "FixupOutPolygon", "DupOutPt", "GetOverlap", "JoinHorz", "JoinPoints", "PointInPolygon", "PointInPolygon2", "Poly2ContainsPoly1", "FixupFirstLefts1", "FixupFirstLefts2", "ParseFirstLeft", "JoinCommonEdges", "UpdateOutPtIdxs", "DoSimplePolygons", "Area", "DistanceFromLineSqrd", "SlopesNearCollinear", "PointsAreClose", "ExcludeOp", "CleanPolygon", "CleanPolygons", "Minkowski", "MinkowskiSum", "TranslatePath", "PolyTreeToPaths", "AddPolyNodeToPaths"]
    _hx_statics = ["compareY", "Orientation", "polArea", "SimplifyPolygon", "SimplifyPolygons", "MinkowskiSums", "MinkowskiDiff"]
    _hx_interfaces = []
    _hx_super = hxd_clipper__Clipper_ClipperBase


    def __init__(self):
        self.m_UsingPolyTree = None
        self.m_GhostJoins = None
        self.m_Joins = None
        self.m_SubjFillType = None
        self.m_ClipFillType = None
        self.m_ExecuteLocked = None
        self.m_IntersectList = None
        self.m_SortedEdges = None
        self.m_ActiveEdges = None
        self.m_Scanbeam = None
        self.m_ClipType = None
        self.m_PolyOuts = None
        self.resultKind = None
        self.reverseSolution = None
        self.strictlySimple = None
        super().__init__()
        self.m_Scanbeam = None
        self.m_ActiveEdges = None
        self.m_SortedEdges = None
        self.m_IntersectList = []
        self.m_ExecuteLocked = False
        self.m_UsingPolyTree = False
        self.m_PolyOuts = []
        self.m_Joins = []
        self.m_GhostJoins = []
        self.reverseSolution = False
        self.strictlySimple = False
        self.preserveCollinear = False
        self.resultKind = hxd_clipper_ResultKind.All

    def xor(self,a,b):
        if a:
            return (not b)
        else:
            return b

    def DisposeScanbeamList(self):
        while (self.m_Scanbeam is not None):
            sb2 = self.m_Scanbeam.next
            self.m_Scanbeam = None
            self.m_Scanbeam = sb2

    def Reset(self):
        super().Reset()
        self.m_Scanbeam = None
        self.m_ActiveEdges = None
        self.m_SortedEdges = None
        lm = self.m_MinimaList
        while (lm is not None):
            self.InsertScanbeam(lm.y)
            lm = lm.next

    def InsertScanbeam(self,y):
        if (self.m_Scanbeam is None):
            self.m_Scanbeam = hxd_clipper__Clipper_Scanbeam()
            self.m_Scanbeam.next = None
            self.m_Scanbeam.y = y
        elif (y > self.m_Scanbeam.y):
            newSb = hxd_clipper__Clipper_Scanbeam()
            newSb.y = y
            newSb.next = self.m_Scanbeam
            self.m_Scanbeam = newSb
        else:
            sb2 = self.m_Scanbeam
            while ((sb2.next is not None) and ((y <= sb2.next.y))):
                sb2 = sb2.next
            if (y == sb2.y):
                return
            newSb = hxd_clipper__Clipper_Scanbeam()
            newSb.y = y
            newSb.next = sb2.next
            sb2.next = newSb

    def execute(self,clipType,subjFillType = None,clipFillType = None):
        if (subjFillType is None):
            subjFillType = hxd_clipper_PolyFillType.EvenOdd
        if (clipFillType is None):
            clipFillType = hxd_clipper_PolyFillType.EvenOdd
        if self.m_ExecuteLocked:
            return []
        self.m_ExecuteLocked = True
        solution = []
        self.m_SubjFillType = subjFillType
        self.m_ClipFillType = clipFillType
        self.m_ClipType = clipType
        self.m_UsingPolyTree = False
        succeeded = self.ExecuteInternal()
        if succeeded:
            solution = self.BuildResult()
        self.DisposeAllPolyPts()
        self.m_ExecuteLocked = False
        return solution

    def ExecuteTree(self,clipType,polytree,subjFillType = None,clipFillType = None):
        if (subjFillType is None):
            subjFillType = hxd_clipper_PolyFillType.EvenOdd
        if (clipFillType is None):
            clipFillType = hxd_clipper_PolyFillType.EvenOdd
        if self.m_ExecuteLocked:
            return False
        self.m_ExecuteLocked = True
        self.m_SubjFillType = subjFillType
        self.m_ClipFillType = clipFillType
        self.m_ClipType = clipType
        self.m_UsingPolyTree = True
        succeeded = self.ExecuteInternal()
        if succeeded:
            self.BuildResult2(polytree)
        self.m_ExecuteLocked = False
        return succeeded

    def FixHoleLinkage(self,outRec):
        if ((outRec.firstLeft is None) or (((outRec.isHole != outRec.firstLeft.isHole) and ((outRec.firstLeft.pts is not None))))):
            return
        orfl = outRec.firstLeft
        while ((orfl is not None) and (((orfl.isHole == outRec.isHole) or ((orfl.pts is None))))):
            orfl = orfl.firstLeft
        outRec.firstLeft = orfl

    def ExecuteInternal(self):
        self.Reset()
        if (self.m_CurrentLM is None):
            return False
        botY = self.PopScanbeam()
        while True:
            self.InsertLocalMinimaIntoAEL(botY)
            if (len(self.m_GhostJoins) > 0):
                self.m_GhostJoins = []
            self.ProcessHorizontals(False)
            if (self.m_Scanbeam is None):
                break
            topY = self.PopScanbeam()
            if (not self.ProcessIntersections(topY)):
                return False
            self.ProcessEdgesAtTopOfScanbeam(topY)
            botY = topY
            if (not (((self.m_Scanbeam is not None) or ((self.m_CurrentLM is not None))))):
                break
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (outRec.pts is None):
                continue
            b = self.reverseSolution
            if ((((not b) if (outRec.isHole) else b)) == ((self.Area(outRec) > 0))):
                self.ReversePolyPtLinks(outRec.pts)
        self.JoinCommonEdges()
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (outRec.pts is not None):
                self.FixupOutPolygon(outRec)
        if self.strictlySimple:
            self.DoSimplePolygons()
        self.m_Joins = []
        self.m_GhostJoins = []
        return True

    def PopScanbeam(self):
        y = self.m_Scanbeam.y
        self.m_Scanbeam = self.m_Scanbeam.next
        return y

    def DisposeAllPolyPts(self):
        _g = 0
        _g1 = len(self.m_PolyOuts)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.DisposeOutRec(i)
        self.m_PolyOuts = []

    def DisposeOutRec(self,index):
        outRec = (self.m_PolyOuts[index] if index >= 0 and index < len(self.m_PolyOuts) else None)
        outRec.pts = None
        outRec = None
        python_internal_ArrayImpl._set(self.m_PolyOuts, index, None)

    def AddJoin(self,op1,op2,offPt):
        j = hxd_clipper__Clipper_Join()
        j.outPt1 = op1
        j.outPt2 = op2
        j.offPt = offPt
        _this = self.m_Joins
        _this.append(j)

    def AddGhostJoin(self,op,offPt):
        j = hxd_clipper__Clipper_Join()
        j.outPt1 = op
        j.offPt = offPt
        _this = self.m_GhostJoins
        _this.append(j)

    def InsertLocalMinimaIntoAEL(self,botY):
        while ((self.m_CurrentLM is not None) and ((self.m_CurrentLM.y == botY))):
            lb = self.m_CurrentLM.leftBound
            rb = self.m_CurrentLM.rightBound
            self.PopLocalMinima()
            op1 = None
            if (lb is None):
                self.InsertEdgeIntoAEL(rb)
                self.SetWindingCount(rb)
                if self.IsContributing(rb):
                    op1 = self.AddOutPt(rb,h2d_col_IPoint(rb.botX,rb.botY))
            elif (rb is None):
                self.InsertEdgeIntoAEL(lb)
                self.SetWindingCount(lb)
                if self.IsContributing(lb):
                    op1 = self.AddOutPt(lb,h2d_col_IPoint(lb.botX,lb.botY))
                self.InsertScanbeam(lb.topY)
            else:
                self.InsertEdgeIntoAEL(lb)
                self.InsertEdgeIntoAEL(rb,lb)
                self.SetWindingCount(lb)
                rb.windCnt = lb.windCnt
                rb.windCnt2 = lb.windCnt2
                if self.IsContributing(lb):
                    op1 = self.AddLocalMinPoly(lb,rb,h2d_col_IPoint(lb.botX,lb.botY))
                self.InsertScanbeam(lb.topY)
            if (rb is not None):
                if (rb.deltaY == 0):
                    self.AddEdgeToSEL(rb)
                else:
                    self.InsertScanbeam(rb.topY)
            if ((lb is None) or ((rb is None))):
                continue
            if ((((op1 is not None) and ((rb.deltaY == 0))) and ((len(self.m_GhostJoins) > 0))) and ((rb.windDelta != 0))):
                _g = 0
                _g1 = self.m_GhostJoins
                while (_g < len(_g1)):
                    j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    if self.HorzSegmentsOverlap(j.outPt1.pt.x,j.offPt.x,rb.botX,rb.topX):
                        self.AddJoin(j.outPt1,op1,j.offPt)
            tmp = None
            if ((((lb.outIdx >= 0) and ((lb.prevInAEL is not None))) and ((lb.prevInAEL.currX == lb.botX))) and ((lb.prevInAEL.outIdx >= 0))):
                e1 = lb.prevInAEL
                tmp = ((e1.deltaY * lb.deltaX) == ((e1.deltaX * lb.deltaY)))
            else:
                tmp = False
            if ((tmp and ((lb.windDelta != 0))) and ((lb.prevInAEL.windDelta != 0))):
                op2 = self.AddOutPt(lb.prevInAEL,h2d_col_IPoint(lb.botX,lb.botY))
                self.AddJoin(op1,op2,h2d_col_IPoint(lb.topX,lb.topY))
            if (lb.nextInAEL != rb):
                tmp1 = None
                if ((rb.outIdx >= 0) and ((rb.prevInAEL.outIdx >= 0))):
                    e11 = rb.prevInAEL
                    tmp1 = ((e11.deltaY * rb.deltaX) == ((e11.deltaX * rb.deltaY)))
                else:
                    tmp1 = False
                if ((tmp1 and ((rb.windDelta != 0))) and ((rb.prevInAEL.windDelta != 0))):
                    op21 = self.AddOutPt(rb.prevInAEL,h2d_col_IPoint(rb.botX,rb.botY))
                    self.AddJoin(op1,op21,h2d_col_IPoint(rb.topX,rb.topY))
                e = lb.nextInAEL
                if (e is not None):
                    while (e != rb):
                        self.IntersectEdges(rb,e,h2d_col_IPoint(lb.currX,lb.currY))
                        e = e.nextInAEL

    def InsertEdgeIntoAEL(self,edge,startEdge = None):
        if (self.m_ActiveEdges is None):
            edge.prevInAEL = None
            edge.nextInAEL = None
            self.m_ActiveEdges = edge
        elif ((startEdge is None) and self.E2InsertsBeforeE1(self.m_ActiveEdges,edge)):
            edge.prevInAEL = None
            edge.nextInAEL = self.m_ActiveEdges
            self.m_ActiveEdges.prevInAEL = edge
            self.m_ActiveEdges = edge
        else:
            if (startEdge is None):
                startEdge = self.m_ActiveEdges
            while ((startEdge.nextInAEL is not None) and (not self.E2InsertsBeforeE1(startEdge.nextInAEL,edge))):
                startEdge = startEdge.nextInAEL
            edge.nextInAEL = startEdge.nextInAEL
            if (startEdge.nextInAEL is not None):
                startEdge.nextInAEL.prevInAEL = edge
            edge.prevInAEL = startEdge
            startEdge.nextInAEL = edge

    def E2InsertsBeforeE1(self,e1,e2):
        if (e2.currX == e1.currX):
            if (e2.topY > e1.topY):
                e21 = e2.topX
                currentY = e2.topY
                tmp = None
                if (currentY == e1.topY):
                    tmp = e1.topX
                else:
                    e11 = e1.botX
                    value = (e1.dx * ((currentY - e1.botY)))
                    tmp1 = None
                    if (value < 0):
                        tmp2 = None
                        try:
                            tmp2 = int((value - 0.5))
                        except BaseException as _g:
                            None
                            tmp2 = None
                        tmp1 = tmp2
                    else:
                        tmp2 = None
                        try:
                            tmp2 = int((value + 0.5))
                        except BaseException as _g:
                            None
                            tmp2 = None
                        tmp1 = tmp2
                    tmp = (e11 + tmp1)
                return (e21 < tmp)
            else:
                e11 = e1.topX
                currentY = e1.topY
                tmp = None
                if (currentY == e2.topY):
                    tmp = e2.topX
                else:
                    e21 = e2.botX
                    value = (e2.dx * ((currentY - e2.botY)))
                    tmp1 = None
                    if (value < 0):
                        tmp2 = None
                        try:
                            tmp2 = int((value - 0.5))
                        except BaseException as _g:
                            None
                            tmp2 = None
                        tmp1 = tmp2
                    else:
                        tmp2 = None
                        try:
                            tmp2 = int((value + 0.5))
                        except BaseException as _g:
                            None
                            tmp2 = None
                        tmp1 = tmp2
                    tmp = (e21 + tmp1)
                return (e11 > tmp)
        else:
            return (e2.currX < e1.currX)

    def IsEvenOddFillType(self,edge):
        if (edge.polyType == hxd_clipper_PolyType.Subject):
            return (self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd)
        else:
            return (self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)

    def IsEvenOddAltFillType(self,edge):
        if (edge.polyType == hxd_clipper_PolyType.Subject):
            return (self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)
        else:
            return (self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd)

    def IsContributing(self,edge):
        pft = None
        pft2 = None
        if (edge.polyType == hxd_clipper_PolyType.Subject):
            pft = self.m_SubjFillType
            pft2 = self.m_ClipFillType
        else:
            pft = self.m_ClipFillType
            pft2 = self.m_SubjFillType
        tmp = pft.index
        if (tmp == 0):
            if ((edge.windDelta == 0) and ((edge.windCnt != 1))):
                return False
        elif (tmp == 1):
            f = edge.windCnt
            if (((-f if ((f < 0)) else f)) != 1):
                return False
        elif (tmp == 2):
            if (edge.windCnt != 1):
                return False
        elif (edge.windCnt != -1):
            return False
        tmp = self.m_ClipType.index
        if (tmp == 0):
            tmp = pft2.index
            if ((tmp == 1) or ((tmp == 0))):
                return (edge.windCnt2 != 0)
            elif (tmp == 2):
                return (edge.windCnt2 > 0)
            else:
                return (edge.windCnt2 < 0)
        elif (tmp == 1):
            tmp = pft2.index
            if ((tmp == 1) or ((tmp == 0))):
                return (edge.windCnt2 == 0)
            elif (tmp == 2):
                return (edge.windCnt2 <= 0)
            else:
                return (edge.windCnt2 >= 0)
        elif (tmp == 2):
            if (edge.polyType == hxd_clipper_PolyType.Subject):
                tmp = pft2.index
                if ((tmp == 1) or ((tmp == 0))):
                    return (edge.windCnt2 == 0)
                elif (tmp == 2):
                    return (edge.windCnt2 <= 0)
                else:
                    return (edge.windCnt2 >= 0)
            else:
                tmp = pft2.index
                if ((tmp == 1) or ((tmp == 0))):
                    return (edge.windCnt2 != 0)
                elif (tmp == 2):
                    return (edge.windCnt2 > 0)
                else:
                    return (edge.windCnt2 < 0)
        elif (tmp == 3):
            if (edge.windDelta == 0):
                tmp = pft2.index
                if ((tmp == 1) or ((tmp == 0))):
                    return (edge.windCnt2 == 0)
                elif (tmp == 2):
                    return (edge.windCnt2 <= 0)
                else:
                    return (edge.windCnt2 >= 0)
            else:
                return True
        else:
            pass

    def SetWindingCount(self,edge):
        e = edge.prevInAEL
        while ((e is not None) and (((e.polyType != edge.polyType) or ((e.windDelta == 0))))):
            e = e.prevInAEL
        if (e is None):
            edge.windCnt = (1 if ((edge.windDelta == 0)) else edge.windDelta)
            edge.windCnt2 = 0
            e = self.m_ActiveEdges
        elif ((edge.windDelta == 0) and ((self.m_ClipType != hxd_clipper_ClipType.Union))):
            edge.windCnt = 1
            edge.windCnt2 = e.windCnt2
            e = e.nextInAEL
        elif ((self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd) if ((edge.polyType == hxd_clipper_PolyType.Subject)) else (self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)):
            if (edge.windDelta == 0):
                Inside = True
                e2 = e.prevInAEL
                while (e2 is not None):
                    if ((e2.polyType == e.polyType) and ((e2.windDelta != 0))):
                        Inside = (not Inside)
                    e2 = e2.prevInAEL
                edge.windCnt = (0 if Inside else 1)
            else:
                edge.windCnt = edge.windDelta
            edge.windCnt2 = e.windCnt2
            e = e.nextInAEL
        else:
            if ((e.windCnt * e.windDelta) < 0):
                if ((e.windCnt > 1) or ((e.windCnt < -1))):
                    if ((e.windDelta * edge.windDelta) < 0):
                        edge.windCnt = e.windCnt
                    else:
                        edge.windCnt = (e.windCnt + edge.windDelta)
                else:
                    edge.windCnt = (1 if ((edge.windDelta == 0)) else edge.windDelta)
            elif (edge.windDelta == 0):
                edge.windCnt = ((e.windCnt - 1) if ((e.windCnt < 0)) else (e.windCnt + 1))
            elif ((e.windDelta * edge.windDelta) < 0):
                edge.windCnt = e.windCnt
            else:
                edge.windCnt = (e.windCnt + edge.windDelta)
            edge.windCnt2 = e.windCnt2
            e = e.nextInAEL
        if ((self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd) if ((edge.polyType == hxd_clipper_PolyType.Subject)) else (self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd)):
            while (e != edge):
                if (e.windDelta != 0):
                    edge.windCnt2 = (1 if ((edge.windCnt2 == 0)) else 0)
                e = e.nextInAEL
        else:
            while (e != edge):
                edge.windCnt2 = (edge.windCnt2 + e.windDelta)
                e = e.nextInAEL

    def AddEdgeToSEL(self,edge):
        if (self.m_SortedEdges is None):
            self.m_SortedEdges = edge
            edge.prevInSEL = None
            edge.nextInSEL = None
        else:
            edge.nextInSEL = self.m_SortedEdges
            edge.prevInSEL = None
            self.m_SortedEdges.prevInSEL = edge
            self.m_SortedEdges = edge

    def CopyAELToSEL(self):
        e = self.m_ActiveEdges
        self.m_SortedEdges = e
        while (e is not None):
            e.prevInSEL = e.prevInAEL
            e.nextInSEL = e.nextInAEL
            e = e.nextInAEL

    def SwapPositionsInAEL(self,edge1,edge2):
        if ((edge1.nextInAEL == edge1.prevInAEL) or ((edge2.nextInAEL == edge2.prevInAEL))):
            return
        if (edge1.nextInAEL == edge2):
            next = edge2.nextInAEL
            if (next is not None):
                next.prevInAEL = edge1
            prev = edge1.prevInAEL
            if (prev is not None):
                prev.nextInAEL = edge2
            edge2.prevInAEL = prev
            edge2.nextInAEL = edge1
            edge1.prevInAEL = edge2
            edge1.nextInAEL = next
        elif (edge2.nextInAEL == edge1):
            next = edge1.nextInAEL
            if (next is not None):
                next.prevInAEL = edge2
            prev = edge2.prevInAEL
            if (prev is not None):
                prev.nextInAEL = edge1
            edge1.prevInAEL = prev
            edge1.nextInAEL = edge2
            edge2.prevInAEL = edge1
            edge2.nextInAEL = next
        else:
            next = edge1.nextInAEL
            prev = edge1.prevInAEL
            edge1.nextInAEL = edge2.nextInAEL
            if (edge1.nextInAEL is not None):
                edge1.nextInAEL.prevInAEL = edge1
            edge1.prevInAEL = edge2.prevInAEL
            if (edge1.prevInAEL is not None):
                edge1.prevInAEL.nextInAEL = edge1
            edge2.nextInAEL = next
            if (edge2.nextInAEL is not None):
                edge2.nextInAEL.prevInAEL = edge2
            edge2.prevInAEL = prev
            if (edge2.prevInAEL is not None):
                edge2.prevInAEL.nextInAEL = edge2
        if (edge1.prevInAEL is None):
            self.m_ActiveEdges = edge1
        elif (edge2.prevInAEL is None):
            self.m_ActiveEdges = edge2

    def SwapPositionsInSEL(self,edge1,edge2):
        if ((edge1.nextInSEL is None) and ((edge1.prevInSEL is None))):
            return
        if ((edge2.nextInSEL is None) and ((edge2.prevInSEL is None))):
            return
        if (edge1.nextInSEL == edge2):
            next = edge2.nextInSEL
            if (next is not None):
                next.prevInSEL = edge1
            prev = edge1.prevInSEL
            if (prev is not None):
                prev.nextInSEL = edge2
            edge2.prevInSEL = prev
            edge2.nextInSEL = edge1
            edge1.prevInSEL = edge2
            edge1.nextInSEL = next
        elif (edge2.nextInSEL == edge1):
            next = edge1.nextInSEL
            if (next is not None):
                next.prevInSEL = edge2
            prev = edge2.prevInSEL
            if (prev is not None):
                prev.nextInSEL = edge1
            edge1.prevInSEL = prev
            edge1.nextInSEL = edge2
            edge2.prevInSEL = edge1
            edge2.nextInSEL = next
        else:
            next = edge1.nextInSEL
            prev = edge1.prevInSEL
            edge1.nextInSEL = edge2.nextInSEL
            if (edge1.nextInSEL is not None):
                edge1.nextInSEL.prevInSEL = edge1
            edge1.prevInSEL = edge2.prevInSEL
            if (edge1.prevInSEL is not None):
                edge1.prevInSEL.nextInSEL = edge1
            edge2.nextInSEL = next
            if (edge2.nextInSEL is not None):
                edge2.nextInSEL.prevInSEL = edge2
            edge2.prevInSEL = prev
            if (edge2.prevInSEL is not None):
                edge2.prevInSEL.nextInSEL = edge2
        if (edge1.prevInSEL is None):
            self.m_SortedEdges = edge1
        elif (edge2.prevInSEL is None):
            self.m_SortedEdges = edge2

    def AddLocalMaxPoly(self,e1,e2,pt):
        self.AddOutPt(e1,pt)
        if (e2.windDelta == 0):
            self.AddOutPt(e2,pt)
        if (e1.outIdx == e2.outIdx):
            e1.outIdx = -1
            e2.outIdx = -1
        elif (e1.outIdx < e2.outIdx):
            self.AppendPolygon(e1,e2)
        else:
            self.AppendPolygon(e2,e1)

    def AddLocalMinPoly(self,e1,e2,pt):
        result = None
        e = None
        prevE = None
        if ((e2.deltaY == 0) or ((e1.dx > e2.dx))):
            result = self.AddOutPt(e1,pt)
            e2.outIdx = e1.outIdx
            e1.side = hxd_clipper__Clipper_EdgeSide.Left
            e2.side = hxd_clipper__Clipper_EdgeSide.Right
            e = e1
            if (e.prevInAEL == e2):
                prevE = e2.prevInAEL
            else:
                prevE = e.prevInAEL
        else:
            result = self.AddOutPt(e2,pt)
            e1.outIdx = e2.outIdx
            e1.side = hxd_clipper__Clipper_EdgeSide.Right
            e2.side = hxd_clipper__Clipper_EdgeSide.Left
            e = e2
            if (e.prevInAEL == e1):
                prevE = e1.prevInAEL
            else:
                prevE = e.prevInAEL
        tmp = None
        if ((prevE is not None) and ((prevE.outIdx >= 0))):
            currentY = pt.y
            tmp1 = None
            if (currentY == prevE.topY):
                tmp1 = prevE.topX
            else:
                prevE1 = prevE.botX
                value = (prevE.dx * ((currentY - prevE.botY)))
                tmp2 = None
                if (value < 0):
                    tmp3 = None
                    try:
                        tmp3 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        tmp3 = None
                    tmp2 = tmp3
                else:
                    tmp3 = None
                    try:
                        tmp3 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        tmp3 = None
                    tmp2 = tmp3
                tmp1 = (prevE1 + tmp2)
            currentY = pt.y
            tmp2 = None
            if (currentY == e.topY):
                tmp2 = e.topX
            else:
                e1 = e.botX
                value = (e.dx * ((currentY - e.botY)))
                tmp3 = None
                if (value < 0):
                    tmp4 = None
                    try:
                        tmp4 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        tmp4 = None
                    tmp3 = tmp4
                else:
                    tmp4 = None
                    try:
                        tmp4 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        tmp4 = None
                    tmp3 = tmp4
                tmp2 = (e1 + tmp3)
            tmp = (tmp1 == tmp2)
        else:
            tmp = False
        if (((tmp and (((e.deltaY * prevE.deltaX) == ((e.deltaX * prevE.deltaY))))) and ((e.windDelta != 0))) and ((prevE.windDelta != 0))):
            out = self.AddOutPt(prevE,pt)
            self.AddJoin(result,out,h2d_col_IPoint(e.topX,e.topY))
        return result

    def CreateOutRec(self):
        result = hxd_clipper__Clipper_OutRec()
        result.idx = -1
        result.isHole = False
        result.firstLeft = None
        result.pts = None
        result.bottomPt = None
        result.polyNode = None
        _this = self.m_PolyOuts
        _this.append(result)
        result.idx = (len(self.m_PolyOuts) - 1)
        return result

    def AddOutPt(self,e,pt):
        ToFront = (e.side == hxd_clipper__Clipper_EdgeSide.Left)
        if (e.outIdx < 0):
            outRec = self.CreateOutRec()
            op = hxd_clipper__Clipper_OutPt()
            outRec.pts = op
            op.idx = outRec.idx
            op.pt = h2d_col_IPoint(pt.x,pt.y)
            op.next = op
            op.prev = op
            self.SetHoleState(e,outRec)
            e.outIdx = outRec.idx
            return op
        else:
            outRec = python_internal_ArrayImpl._get(self.m_PolyOuts, e.outIdx)
            op = outRec.pts
            tmp = None
            if ToFront:
                pt2 = op.pt
                tmp = ((pt.x == pt2.x) and ((pt.y == pt2.y)))
            else:
                tmp = False
            if tmp:
                return op
            else:
                tmp = None
                if (not ToFront):
                    pt2 = op.prev.pt
                    tmp = ((pt.x == pt2.x) and ((pt.y == pt2.y)))
                else:
                    tmp = False
                if tmp:
                    return op.prev
            op2 = hxd_clipper__Clipper_OutPt()
            op2.idx = outRec.idx
            op2.pt = h2d_col_IPoint(pt.x,pt.y)
            op2.next = op
            op2.prev = op.prev
            op2.prev.next = op2
            op.prev = op2
            if ToFront:
                outRec.pts = op2
            return op2

    def HorzSegmentsOverlap(self,seg1a,seg1b,seg2a,seg2b):
        if (seg1a > seg1b):
            tmp = seg1a
            seg1a = seg1b
            seg1b = tmp
        if (seg2a > seg2b):
            tmp = seg2a
            seg2a = seg2b
            seg2b = tmp
        if (seg1a < seg2b):
            return (seg2a < seg1b)
        else:
            return False

    def SetHoleState(self,e,outRec):
        isHole = False
        e2 = e.prevInAEL
        while (e2 is not None):
            if ((e2.outIdx >= 0) and ((e2.windDelta != 0))):
                isHole = (not isHole)
                if (outRec.firstLeft is None):
                    outRec.firstLeft = python_internal_ArrayImpl._get(self.m_PolyOuts, e2.outIdx)
            e2 = e2.prevInAEL
        if isHole:
            outRec.isHole = True

    def GetDx(self,pt1,pt2):
        if (pt1.y == pt2.y):
            return -9007199254740992.
        else:
            return (((pt2.x - pt1.x)) / ((pt2.y - pt1.y)))

    def FirstIsBottomPt(self,btmPt1,btmPt2):
        p = btmPt1.prev
        while True:
            pt1 = p.pt
            pt2 = btmPt1.pt
            if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((p != btmPt1))))):
                break
            p = p.prev
        f = self.GetDx(btmPt1.pt,p.pt)
        dx1p = (-f if ((f < 0)) else f)
        p = btmPt1.next
        while True:
            pt1 = p.pt
            pt2 = btmPt1.pt
            if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((p != btmPt1))))):
                break
            p = p.next
        f = self.GetDx(btmPt1.pt,p.pt)
        dx1n = (-f if ((f < 0)) else f)
        p = btmPt2.prev
        while True:
            pt1 = p.pt
            pt2 = btmPt2.pt
            if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((p != btmPt2))))):
                break
            p = p.prev
        f = self.GetDx(btmPt2.pt,p.pt)
        dx2p = (-f if ((f < 0)) else f)
        p = btmPt2.next
        while True:
            pt1 = p.pt
            pt2 = btmPt2.pt
            if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((p != btmPt2))))):
                break
            p = p.next
        f = self.GetDx(btmPt2.pt,p.pt)
        dx2n = (-f if ((f < 0)) else f)
        if (not (((dx1p >= dx2p) and ((dx1p >= dx2n))))):
            if (dx1n >= dx2p):
                return (dx1n >= dx2n)
            else:
                return False
        else:
            return True

    def GetBottomPt(self,pp):
        dups = None
        p = pp.next
        while (p != pp):
            if (p.pt.y > pp.pt.y):
                pp = p
                dups = None
            elif ((p.pt.y == pp.pt.y) and ((p.pt.x <= pp.pt.x))):
                if (p.pt.x < pp.pt.x):
                    dups = None
                    pp = p
                elif ((p.next != pp) and ((p.prev != pp))):
                    dups = p
            p = p.next
        if (dups is not None):
            n = 0
            while (dups != p):
                if (not self.FirstIsBottomPt(p,dups)):
                    pp = dups
                dups = dups.next
                while True:
                    pt1 = dups.pt
                    pt2 = pp.pt
                    if ((pt1.x == pt2.x) and ((pt1.y == pt2.y))):
                        break
                    dups = dups.next
        return pp

    def GetLowermostRec(self,outRec1,outRec2):
        if (outRec1.bottomPt is None):
            outRec1.bottomPt = self.GetBottomPt(outRec1.pts)
        if (outRec2.bottomPt is None):
            outRec2.bottomPt = self.GetBottomPt(outRec2.pts)
        bPt1 = outRec1.bottomPt
        bPt2 = outRec2.bottomPt
        if (bPt1.pt.y > bPt2.pt.y):
            return outRec1
        elif (bPt1.pt.y < bPt2.pt.y):
            return outRec2
        elif (bPt1.pt.x < bPt2.pt.x):
            return outRec1
        elif (bPt1.pt.x > bPt2.pt.x):
            return outRec2
        elif (bPt1.next == bPt1):
            return outRec2
        elif (bPt2.next == bPt2):
            return outRec1
        elif self.FirstIsBottomPt(bPt1,bPt2):
            return outRec1
        else:
            return outRec2

    def Param1RightOfParam2(self,outRec1,outRec2):
        while True:
            outRec1 = outRec1.firstLeft
            if (outRec1 == outRec2):
                return True
            if (not ((outRec1 is not None))):
                break
        return False

    def GetOutRec(self,idx):
        outrec = (self.m_PolyOuts[idx] if idx >= 0 and idx < len(self.m_PolyOuts) else None)
        while (outrec != python_internal_ArrayImpl._get(self.m_PolyOuts, outrec.idx)):
            outrec = python_internal_ArrayImpl._get(self.m_PolyOuts, outrec.idx)
        return outrec

    def AppendPolygon(self,e1,e2):
        outRec1 = python_internal_ArrayImpl._get(self.m_PolyOuts, e1.outIdx)
        outRec2 = python_internal_ArrayImpl._get(self.m_PolyOuts, e2.outIdx)
        holeStateRec = None
        if self.Param1RightOfParam2(outRec1,outRec2):
            holeStateRec = outRec2
        elif self.Param1RightOfParam2(outRec2,outRec1):
            holeStateRec = outRec1
        else:
            holeStateRec = self.GetLowermostRec(outRec1,outRec2)
        p1_lft = outRec1.pts
        p1_rt = p1_lft.prev
        p2_lft = outRec2.pts
        p2_rt = p2_lft.prev
        side = None
        if (e1.side == hxd_clipper__Clipper_EdgeSide.Left):
            if (e2.side == hxd_clipper__Clipper_EdgeSide.Left):
                self.ReversePolyPtLinks(p2_lft)
                p2_lft.next = p1_lft
                p1_lft.prev = p2_lft
                p1_rt.next = p2_rt
                p2_rt.prev = p1_rt
                outRec1.pts = p2_rt
            else:
                p2_rt.next = p1_lft
                p1_lft.prev = p2_rt
                p2_lft.prev = p1_rt
                p1_rt.next = p2_lft
                outRec1.pts = p2_lft
            side = hxd_clipper__Clipper_EdgeSide.Left
        else:
            if (e2.side == hxd_clipper__Clipper_EdgeSide.Right):
                self.ReversePolyPtLinks(p2_lft)
                p1_rt.next = p2_rt
                p2_rt.prev = p1_rt
                p2_lft.next = p1_lft
                p1_lft.prev = p2_lft
            else:
                p1_rt.next = p2_lft
                p2_lft.prev = p1_rt
                p1_lft.prev = p2_rt
                p2_rt.next = p1_lft
            side = hxd_clipper__Clipper_EdgeSide.Right
        outRec1.bottomPt = None
        if (holeStateRec == outRec2):
            if (outRec2.firstLeft != outRec1):
                outRec1.firstLeft = outRec2.firstLeft
            outRec1.isHole = outRec2.isHole
        outRec2.pts = None
        outRec2.bottomPt = None
        outRec2.firstLeft = outRec1
        OKIdx = e1.outIdx
        ObsoleteIdx = e2.outIdx
        e1.outIdx = -1
        e2.outIdx = -1
        e = self.m_ActiveEdges
        while (e is not None):
            if (e.outIdx == ObsoleteIdx):
                e.outIdx = OKIdx
                e.side = side
                break
            e = e.nextInAEL
        outRec2.idx = outRec1.idx

    def ReversePolyPtLinks(self,pp):
        if (pp is None):
            return
        pp2 = None
        pp1 = pp
        while True:
            pp2 = pp1.next
            pp1.next = pp1.prev
            pp1.prev = pp2
            pp1 = pp2
            if (not ((pp1 != pp))):
                break

    def SwapSides(self,edge1,edge2):
        side = edge1.side
        edge1.side = edge2.side
        edge2.side = side

    def SwapPolyIndexes(self,edge1,edge2):
        outIdx = edge1.outIdx
        edge1.outIdx = edge2.outIdx
        edge2.outIdx = outIdx

    def IntersectEdges(self,e1,e2,pt):
        e1Contributing = (e1.outIdx >= 0)
        e2Contributing = (e2.outIdx >= 0)
        if (e1.polyType == e2.polyType):
            if ((self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd) if ((e1.polyType == hxd_clipper_PolyType.Subject)) else (self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)):
                oldE1WindCnt = e1.windCnt
                e1.windCnt = e2.windCnt
                e2.windCnt = oldE1WindCnt
            else:
                if ((e1.windCnt + e2.windDelta) == 0):
                    e1.windCnt = -e1.windCnt
                else:
                    e1.windCnt = (e1.windCnt + e2.windDelta)
                if ((e2.windCnt - e1.windDelta) == 0):
                    e2.windCnt = -e2.windCnt
                else:
                    e2.windCnt = (e2.windCnt - e1.windDelta)
        else:
            if (not (((self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd) if ((e2.polyType == hxd_clipper_PolyType.Subject)) else (self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)))):
                e1.windCnt2 = (e1.windCnt2 + e2.windDelta)
            else:
                e1.windCnt2 = (1 if ((e1.windCnt2 == 0)) else 0)
            if (not (((self.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd) if ((e1.polyType == hxd_clipper_PolyType.Subject)) else (self.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)))):
                e2.windCnt2 = (e2.windCnt2 - e1.windDelta)
            else:
                e2.windCnt2 = (1 if ((e2.windCnt2 == 0)) else 0)
        e1FillType = None
        e2FillType = None
        e1FillType2 = None
        e2FillType2 = None
        if (e1.polyType == hxd_clipper_PolyType.Subject):
            e1FillType = self.m_SubjFillType
            e1FillType2 = self.m_ClipFillType
        else:
            e1FillType = self.m_ClipFillType
            e1FillType2 = self.m_SubjFillType
        if (e2.polyType == hxd_clipper_PolyType.Subject):
            e2FillType = self.m_SubjFillType
            e2FillType2 = self.m_ClipFillType
        else:
            e2FillType = self.m_ClipFillType
            e2FillType2 = self.m_SubjFillType
        e1Wc = None
        e2Wc = None
        tmp = e1FillType.index
        if (tmp == 2):
            e1Wc = e1.windCnt
        elif (tmp == 3):
            e1Wc = -e1.windCnt
        else:
            i = e1.windCnt
            e1Wc = (-i if ((i < 0)) else i)
        tmp = e2FillType.index
        if (tmp == 2):
            e2Wc = e2.windCnt
        elif (tmp == 3):
            e2Wc = -e2.windCnt
        else:
            i = e2.windCnt
            e2Wc = (-i if ((i < 0)) else i)
        if (e1Contributing and e2Contributing):
            if ((((e1Wc != 0) and ((e1Wc != 1))) or (((e2Wc != 0) and ((e2Wc != 1))))) or (((e1.polyType != e2.polyType) and ((self.m_ClipType != hxd_clipper_ClipType.Xor))))):
                self.AddLocalMaxPoly(e1,e2,pt)
            else:
                self.AddOutPt(e1,pt)
                self.AddOutPt(e2,pt)
                side = e1.side
                e1.side = e2.side
                e2.side = side
                self.SwapPolyIndexes(e1,e2)
        elif e1Contributing:
            if ((e2Wc == 0) or ((e2Wc == 1))):
                self.AddOutPt(e1,pt)
                side = e1.side
                e1.side = e2.side
                e2.side = side
                self.SwapPolyIndexes(e1,e2)
        elif e2Contributing:
            if ((e1Wc == 0) or ((e1Wc == 1))):
                self.AddOutPt(e2,pt)
                side = e1.side
                e1.side = e2.side
                e2.side = side
                self.SwapPolyIndexes(e1,e2)
        elif ((((e1Wc == 0) or ((e1Wc == 1)))) and (((e2Wc == 0) or ((e2Wc == 1))))):
            e1Wc2 = None
            e2Wc2 = None
            tmp = e1FillType2.index
            if (tmp == 2):
                e1Wc2 = e1.windCnt2
            elif (tmp == 3):
                e1Wc2 = -e1.windCnt2
            else:
                i = e1.windCnt2
                e1Wc2 = (-i if ((i < 0)) else i)
            tmp = e2FillType2.index
            if (tmp == 2):
                e2Wc2 = e2.windCnt2
            elif (tmp == 3):
                e2Wc2 = -e2.windCnt2
            else:
                i = e2.windCnt2
                e2Wc2 = (-i if ((i < 0)) else i)
            if (e1.polyType != e2.polyType):
                self.AddLocalMinPoly(e1,e2,pt)
            elif ((e1Wc == 1) and ((e2Wc == 1))):
                tmp = self.m_ClipType.index
                if (tmp == 0):
                    if ((e1Wc2 > 0) and ((e2Wc2 > 0))):
                        self.AddLocalMinPoly(e1,e2,pt)
                elif (tmp == 1):
                    if ((e1Wc2 <= 0) and ((e2Wc2 <= 0))):
                        self.AddLocalMinPoly(e1,e2,pt)
                elif (tmp == 2):
                    if ((((e1.polyType == hxd_clipper_PolyType.Clip) and ((e1Wc2 > 0))) and ((e2Wc2 > 0))) or ((((e1.polyType == hxd_clipper_PolyType.Subject) and ((e1Wc2 <= 0))) and ((e2Wc2 <= 0))))):
                        self.AddLocalMinPoly(e1,e2,pt)
                elif (tmp == 3):
                    self.AddLocalMinPoly(e1,e2,pt)
                else:
                    pass
            else:
                side = e1.side
                e1.side = e2.side
                e2.side = side

    def DeleteFromAEL(self,e):
        AelPrev = e.prevInAEL
        AelNext = e.nextInAEL
        if (((AelPrev is None) and ((AelNext is None))) and ((e != self.m_ActiveEdges))):
            return
        if (AelPrev is not None):
            AelPrev.nextInAEL = AelNext
        else:
            self.m_ActiveEdges = AelNext
        if (AelNext is not None):
            AelNext.prevInAEL = AelPrev
        e.nextInAEL = None
        e.prevInAEL = None

    def DeleteFromSEL(self,e):
        SelPrev = e.prevInSEL
        SelNext = e.nextInSEL
        if (((SelPrev is None) and ((SelNext is None))) and ((e != self.m_SortedEdges))):
            return
        if (SelPrev is not None):
            SelPrev.nextInSEL = SelNext
        else:
            self.m_SortedEdges = SelNext
        if (SelNext is not None):
            SelNext.prevInSEL = SelPrev
        e.nextInSEL = None
        e.prevInSEL = None

    def UpdateEdgeIntoAEL(self,e):
        if (e.nextInLML is None):
            raise haxe_Exception.thrown("UpdateEdgeIntoAEL: invalid call")
        AelPrev = e.prevInAEL
        AelNext = e.nextInAEL
        e.nextInLML.outIdx = e.outIdx
        if (AelPrev is not None):
            AelPrev.nextInAEL = e.nextInLML
        else:
            self.m_ActiveEdges = e.nextInLML
        if (AelNext is not None):
            AelNext.prevInAEL = e.nextInLML
        e.nextInLML.side = e.side
        e.nextInLML.windDelta = e.windDelta
        e.nextInLML.windCnt = e.windCnt
        e.nextInLML.windCnt2 = e.windCnt2
        e = e.nextInLML
        e.currX = e.botX
        e.currY = e.botY
        e.prevInAEL = AelPrev
        e.nextInAEL = AelNext
        if (e.deltaY != 0):
            self.InsertScanbeam(e.topY)
        return e

    def GetHorzDirection(self,HorzEdge):
        if (HorzEdge.botX < HorzEdge.topX):
            return _hx_AnonObject({'left': HorzEdge.botX, 'right': HorzEdge.topX, 'dir': hxd_clipper__Clipper_Direction.LeftToRight})
        else:
            return _hx_AnonObject({'left': HorzEdge.topX, 'right': HorzEdge.botX, 'dir': hxd_clipper__Clipper_Direction.RightToLeft})

    def ProcessHorizontals(self,isTopOfScanbeam):
        horzEdge = self.m_SortedEdges
        while (horzEdge is not None):
            self.DeleteFromSEL(horzEdge)
            self.ProcessHorizontal(horzEdge,isTopOfScanbeam)
            horzEdge = self.m_SortedEdges

    def ProcessHorizontal(self,horzEdge,isTopOfScanbeam):
        res = self.GetHorzDirection(horzEdge)
        dir = res.dir
        horzLeft = res.left
        horzRight = res.right
        eLastHorz = horzEdge
        eMaxPair = None
        while ((eLastHorz.nextInLML is not None) and ((eLastHorz.nextInLML.deltaY == 0))):
            eLastHorz = eLastHorz.nextInLML
        if (eLastHorz.nextInLML is None):
            eMaxPair = self.GetMaximaPair(eLastHorz)
        while True:
            IsLastHorz = (horzEdge == eLastHorz)
            e = (horzEdge.nextInAEL if ((dir == hxd_clipper__Clipper_Direction.LeftToRight)) else horzEdge.prevInAEL)
            while (e is not None):
                if (((e.currX == horzEdge.topX) and ((horzEdge.nextInLML is not None))) and ((e.dx < horzEdge.nextInLML.dx))):
                    break
                eNext = (e.nextInAEL if ((dir == hxd_clipper__Clipper_Direction.LeftToRight)) else e.prevInAEL)
                if (((dir == hxd_clipper__Clipper_Direction.LeftToRight) and ((e.currX <= horzRight))) or (((dir == hxd_clipper__Clipper_Direction.RightToLeft) and ((e.currX >= horzLeft))))):
                    if ((e == eMaxPair) and IsLastHorz):
                        if (horzEdge.outIdx >= 0):
                            op1 = self.AddOutPt(horzEdge,h2d_col_IPoint(horzEdge.topX,horzEdge.topY))
                            eNextHorz = self.m_SortedEdges
                            while (eNextHorz is not None):
                                if ((eNextHorz.outIdx >= 0) and self.HorzSegmentsOverlap(horzEdge.botX,horzEdge.topX,eNextHorz.botX,eNextHorz.topX)):
                                    op2 = self.AddOutPt(eNextHorz,h2d_col_IPoint(eNextHorz.botX,eNextHorz.botY))
                                    self.AddJoin(op2,op1,h2d_col_IPoint(eNextHorz.topX,eNextHorz.topY))
                                eNextHorz = eNextHorz.nextInSEL
                            self.AddGhostJoin(op1,h2d_col_IPoint(horzEdge.botX,horzEdge.botY))
                            self.AddLocalMaxPoly(horzEdge,eMaxPair,h2d_col_IPoint(horzEdge.topX,horzEdge.topY))
                        self.DeleteFromAEL(horzEdge)
                        self.DeleteFromAEL(eMaxPair)
                        return
                    elif (dir == hxd_clipper__Clipper_Direction.LeftToRight):
                        Pt = h2d_col_IPoint(e.currX,horzEdge.currY)
                        self.IntersectEdges(horzEdge,e,Pt)
                    else:
                        Pt1 = h2d_col_IPoint(e.currX,horzEdge.currY)
                        self.IntersectEdges(e,horzEdge,Pt1)
                    self.SwapPositionsInAEL(horzEdge,e)
                elif (((dir == hxd_clipper__Clipper_Direction.LeftToRight) and ((e.currX >= horzRight))) or (((dir == hxd_clipper__Clipper_Direction.RightToLeft) and ((e.currX <= horzLeft))))):
                    break
                e = eNext
            if ((horzEdge.nextInLML is not None) and ((horzEdge.nextInLML.deltaY == 0))):
                horzEdge = self.UpdateEdgeIntoAEL(horzEdge)
                if (horzEdge.outIdx >= 0):
                    self.AddOutPt(horzEdge,h2d_col_IPoint(horzEdge.botX,horzEdge.botY))
                out = self.GetHorzDirection(horzEdge)
                dir = out.dir
                horzLeft = out.left
                horzRight = out.right
            else:
                break
        if (horzEdge.nextInLML is not None):
            if (horzEdge.outIdx >= 0):
                op1 = self.AddOutPt(horzEdge,h2d_col_IPoint(horzEdge.topX,horzEdge.topY))
                if isTopOfScanbeam:
                    self.AddGhostJoin(op1,h2d_col_IPoint(horzEdge.botX,horzEdge.botY))
                horzEdge = self.UpdateEdgeIntoAEL(horzEdge)
                if (horzEdge.windDelta == 0):
                    return
                ePrev = horzEdge.prevInAEL
                eNext = horzEdge.nextInAEL
                if (((((ePrev is not None) and ((ePrev.currX == horzEdge.botX))) and ((ePrev.currY == horzEdge.botY))) and ((ePrev.windDelta != 0))) and ((((ePrev.outIdx >= 0) and ((ePrev.currY > ePrev.topY))) and (((horzEdge.deltaY * ePrev.deltaX) == ((horzEdge.deltaX * ePrev.deltaY))))))):
                    op2 = self.AddOutPt(ePrev,h2d_col_IPoint(horzEdge.botX,horzEdge.botY))
                    self.AddJoin(op1,op2,h2d_col_IPoint(horzEdge.topX,horzEdge.topY))
                elif (((((((eNext is not None) and ((eNext.currX == horzEdge.botX))) and ((eNext.currY == horzEdge.botY))) and ((eNext.windDelta != 0))) and ((eNext.outIdx >= 0))) and ((eNext.currY > eNext.topY))) and (((horzEdge.deltaY * eNext.deltaX) == ((horzEdge.deltaX * eNext.deltaY))))):
                    op2 = self.AddOutPt(eNext,h2d_col_IPoint(horzEdge.botX,horzEdge.botY))
                    self.AddJoin(op1,op2,h2d_col_IPoint(horzEdge.topX,horzEdge.topY))
            else:
                horzEdge = self.UpdateEdgeIntoAEL(horzEdge)
        else:
            if (horzEdge.outIdx >= 0):
                self.AddOutPt(horzEdge,h2d_col_IPoint(horzEdge.topX,horzEdge.topY))
            self.DeleteFromAEL(horzEdge)

    def GetNextInAEL(self,e,dir):
        if (dir == hxd_clipper__Clipper_Direction.LeftToRight):
            return e.nextInAEL
        else:
            return e.prevInAEL

    def IsMinima(self,e):
        if ((e is not None) and ((e.prev.nextInLML != e))):
            return (e.next.nextInLML != e)
        else:
            return False

    def IsMaxima(self,e,y):
        if ((e is not None) and ((e.topY == y))):
            return (e.nextInLML is None)
        else:
            return False

    def IsIntermediate(self,e,y):
        if (e.topY == y):
            return (e.nextInLML is not None)
        else:
            return False

    def GetMaximaPair(self,e):
        result = None
        if (((e.next.topX == e.topX) and ((e.next.topY == e.topY))) and ((e.next.nextInLML is None))):
            result = e.next
        elif (((e.prev.topX == e.topX) and ((e.prev.topY == e.topY))) and ((e.prev.nextInLML is None))):
            result = e.prev
        if ((result is not None) and (((result.outIdx == -2) or (((result.nextInAEL == result.prevInAEL) and ((result.deltaY != 0))))))):
            return None
        return result

    def ProcessIntersections(self,topY):
        if (self.m_ActiveEdges is None):
            return True
        self.BuildIntersectList(topY)
        if (len(self.m_IntersectList) == 0):
            return True
        if ((len(self.m_IntersectList) == 1) or self.FixupIntersectionOrder()):
            self.ProcessIntersectList()
        else:
            return False
        self.m_SortedEdges = None
        return True

    def BuildIntersectList(self,topY):
        if (self.m_ActiveEdges is None):
            return
        e = self.m_ActiveEdges
        self.m_SortedEdges = e
        while (e is not None):
            e.prevInSEL = e.prevInAEL
            e.nextInSEL = e.nextInAEL
            tmp = None
            if (topY == e.topY):
                tmp = e.topX
            else:
                e1 = e.botX
                value = (e.dx * ((topY - e.botY)))
                tmp1 = None
                if (value < 0):
                    tmp2 = None
                    try:
                        tmp2 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        tmp2 = None
                    tmp1 = tmp2
                else:
                    tmp3 = None
                    try:
                        tmp3 = int((value + 0.5))
                    except BaseException as _g1:
                        None
                        tmp3 = None
                    tmp1 = tmp3
                tmp = (e1 + tmp1)
            e.currX = tmp
            e = e.nextInAEL
        isModified = True
        while (isModified and ((self.m_SortedEdges is not None))):
            isModified = False
            e = self.m_SortedEdges
            while (e.nextInSEL is not None):
                eNext = e.nextInSEL
                pt = None
                if (e.currX > eNext.currX):
                    ipx = None
                    ipy = None
                    b1 = None
                    b2 = None
                    if (e.dx == eNext.dx):
                        ipy = e.currY
                        if (ipy == e.topY):
                            ipx = e.topX
                        else:
                            e1 = e.botX
                            value = (e.dx * ((ipy - e.botY)))
                            ipx1 = None
                            if (value < 0):
                                ipx2 = None
                                try:
                                    ipx2 = int((value - 0.5))
                                except BaseException as _g:
                                    None
                                    ipx2 = None
                                ipx1 = ipx2
                            else:
                                ipx3 = None
                                try:
                                    ipx3 = int((value + 0.5))
                                except BaseException as _g1:
                                    None
                                    ipx3 = None
                                ipx1 = ipx3
                            ipx = (e1 + ipx1)
                        pt = h2d_col_IPoint(ipx,ipy)
                    else:
                        if (e.deltaX == 0):
                            ipx = e.botX
                            if (eNext.deltaY == 0):
                                ipy = eNext.botY
                            else:
                                b2 = (eNext.botY - ((eNext.botX / eNext.dx)))
                                value1 = ((ipx / eNext.dx) + b2)
                                if (value1 < 0):
                                    ipy1 = None
                                    try:
                                        ipy1 = int((value1 - 0.5))
                                    except BaseException as _g2:
                                        None
                                        ipy1 = None
                                    ipy = ipy1
                                else:
                                    ipy2 = None
                                    try:
                                        ipy2 = int((value1 + 0.5))
                                    except BaseException as _g3:
                                        None
                                        ipy2 = None
                                    ipy = ipy2
                        elif (eNext.deltaX == 0):
                            ipx = eNext.botX
                            if (e.deltaY == 0):
                                ipy = e.botY
                            else:
                                b1 = (e.botY - ((e.botX / e.dx)))
                                value2 = ((ipx / e.dx) + b1)
                                if (value2 < 0):
                                    ipy3 = None
                                    try:
                                        ipy3 = int((value2 - 0.5))
                                    except BaseException as _g4:
                                        None
                                        ipy3 = None
                                    ipy = ipy3
                                else:
                                    ipy4 = None
                                    try:
                                        ipy4 = int((value2 + 0.5))
                                    except BaseException as _g5:
                                        None
                                        ipy4 = None
                                    ipy = ipy4
                        else:
                            b1 = (e.botX - ((e.botY * e.dx)))
                            b2 = (eNext.botX - ((eNext.botY * eNext.dx)))
                            q = (((b2 - b1)) / ((e.dx - eNext.dx)))
                            if (q < 0):
                                ipy5 = None
                                try:
                                    ipy5 = int((q - 0.5))
                                except BaseException as _g6:
                                    None
                                    ipy5 = None
                                ipy = ipy5
                            else:
                                ipy6 = None
                                try:
                                    ipy6 = int((q + 0.5))
                                except BaseException as _g7:
                                    None
                                    ipy6 = None
                                ipy = ipy6
                            f = e.dx
                            f1 = eNext.dx
                            if (((-f if ((f < 0)) else f)) < ((-f1 if ((f1 < 0)) else f1))):
                                value3 = ((e.dx * q) + b1)
                                if (value3 < 0):
                                    ipx4 = None
                                    try:
                                        ipx4 = int((value3 - 0.5))
                                    except BaseException as _g8:
                                        None
                                        ipx4 = None
                                    ipx = ipx4
                                else:
                                    ipx5 = None
                                    try:
                                        ipx5 = int((value3 + 0.5))
                                    except BaseException as _g9:
                                        None
                                        ipx5 = None
                                    ipx = ipx5
                            else:
                                value4 = ((eNext.dx * q) + b2)
                                if (value4 < 0):
                                    ipx6 = None
                                    try:
                                        ipx6 = int((value4 - 0.5))
                                    except BaseException as _g10:
                                        None
                                        ipx6 = None
                                    ipx = ipx6
                                else:
                                    ipx7 = None
                                    try:
                                        ipx7 = int((value4 + 0.5))
                                    except BaseException as _g11:
                                        None
                                        ipx7 = None
                                    ipx = ipx7
                        if ((ipy < e.topY) or ((ipy < eNext.topY))):
                            if (e.topY > eNext.topY):
                                ipy = e.topY
                            else:
                                ipy = eNext.topY
                            f2 = e.dx
                            f3 = eNext.dx
                            if (((-f2 if ((f2 < 0)) else f2)) < ((-f3 if ((f3 < 0)) else f3))):
                                if (ipy == e.topY):
                                    ipx = e.topX
                                else:
                                    e2 = e.botX
                                    value5 = (e.dx * ((ipy - e.botY)))
                                    ipx8 = None
                                    if (value5 < 0):
                                        ipx9 = None
                                        try:
                                            ipx9 = int((value5 - 0.5))
                                        except BaseException as _g12:
                                            None
                                            ipx9 = None
                                        ipx8 = ipx9
                                    else:
                                        ipx10 = None
                                        try:
                                            ipx10 = int((value5 + 0.5))
                                        except BaseException as _g13:
                                            None
                                            ipx10 = None
                                        ipx8 = ipx10
                                    ipx = (e2 + ipx8)
                            elif (ipy == eNext.topY):
                                ipx = eNext.topX
                            else:
                                eNext1 = eNext.botX
                                value6 = (eNext.dx * ((ipy - eNext.botY)))
                                ipx11 = None
                                if (value6 < 0):
                                    ipx12 = None
                                    try:
                                        ipx12 = int((value6 - 0.5))
                                    except BaseException as _g14:
                                        None
                                        ipx12 = None
                                    ipx11 = ipx12
                                else:
                                    ipx13 = None
                                    try:
                                        ipx13 = int((value6 + 0.5))
                                    except BaseException as _g15:
                                        None
                                        ipx13 = None
                                    ipx11 = ipx13
                                ipx = (eNext1 + ipx11)
                        if (ipy > e.currY):
                            ipy = e.currY
                            f4 = e.dx
                            f5 = eNext.dx
                            if (((-f4 if ((f4 < 0)) else f4)) > ((-f5 if ((f5 < 0)) else f5))):
                                if (ipy == eNext.topY):
                                    ipx = eNext.topX
                                else:
                                    eNext2 = eNext.botX
                                    value7 = (eNext.dx * ((ipy - eNext.botY)))
                                    ipx14 = None
                                    if (value7 < 0):
                                        ipx15 = None
                                        try:
                                            ipx15 = int((value7 - 0.5))
                                        except BaseException as _g16:
                                            None
                                            ipx15 = None
                                        ipx14 = ipx15
                                    else:
                                        ipx16 = None
                                        try:
                                            ipx16 = int((value7 + 0.5))
                                        except BaseException as _g17:
                                            None
                                            ipx16 = None
                                        ipx14 = ipx16
                                    ipx = (eNext2 + ipx14)
                            elif (ipy == e.topY):
                                ipx = e.topX
                            else:
                                e3 = e.botX
                                value8 = (e.dx * ((ipy - e.botY)))
                                ipx17 = None
                                if (value8 < 0):
                                    ipx18 = None
                                    try:
                                        ipx18 = int((value8 - 0.5))
                                    except BaseException as _g18:
                                        None
                                        ipx18 = None
                                    ipx17 = ipx18
                                else:
                                    ipx19 = None
                                    try:
                                        ipx19 = int((value8 + 0.5))
                                    except BaseException as _g19:
                                        None
                                        ipx19 = None
                                    ipx17 = ipx19
                                ipx = (e3 + ipx17)
                        pt = h2d_col_IPoint(ipx,ipy)
                    newNode = hxd_clipper__Clipper_IntersectNode()
                    newNode.edge1 = e
                    newNode.edge2 = eNext
                    newNode.pt = pt
                    _this = self.m_IntersectList
                    _this.append(newNode)
                    self.SwapPositionsInSEL(e,eNext)
                    isModified = True
                else:
                    e = eNext
            if (e.prevInSEL is not None):
                e.prevInSEL.nextInSEL = None
            else:
                break
        self.m_SortedEdges = None

    def EdgesAdjacent(self,inode):
        if (inode.edge1.nextInSEL != inode.edge2):
            return (inode.edge1.prevInSEL == inode.edge2)
        else:
            return True

    def IntersectNodeSort(self,node1,node2):
        x = (node2.pt.y - node1.pt.y)
        try:
            return int(x)
        except BaseException as _g:
            None
            return None

    def FixupIntersectionOrder(self):
        self.m_IntersectList.sort(key= python_lib_Functools.cmp_to_key(hxd_clipper_Clipper.compareY))
        e = self.m_ActiveEdges
        self.m_SortedEdges = e
        while (e is not None):
            e.prevInSEL = e.prevInAEL
            e.nextInSEL = e.nextInAEL
            e = e.nextInAEL
        cnt = len(self.m_IntersectList)
        _g = 0
        _g1 = cnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            inode = (self.m_IntersectList[i] if i >= 0 and i < len(self.m_IntersectList) else None)
            if (not (((inode.edge1.nextInSEL == inode.edge2) or ((inode.edge1.prevInSEL == inode.edge2))))):
                j = (i + 1)
                while True:
                    tmp = None
                    if (j < cnt):
                        inode1 = (self.m_IntersectList[j] if j >= 0 and j < len(self.m_IntersectList) else None)
                        tmp = (not (((inode1.edge1.nextInSEL == inode1.edge2) or ((inode1.edge1.prevInSEL == inode1.edge2)))))
                    else:
                        tmp = False
                    if (not tmp):
                        break
                    j = (j + 1)
                if (j == cnt):
                    return False
                tmp1 = (self.m_IntersectList[i] if i >= 0 and i < len(self.m_IntersectList) else None)
                python_internal_ArrayImpl._set(self.m_IntersectList, i, (self.m_IntersectList[j] if j >= 0 and j < len(self.m_IntersectList) else None))
                python_internal_ArrayImpl._set(self.m_IntersectList, j, tmp1)
            self.SwapPositionsInSEL((self.m_IntersectList[i] if i >= 0 and i < len(self.m_IntersectList) else None).edge1,(self.m_IntersectList[i] if i >= 0 and i < len(self.m_IntersectList) else None).edge2)
        return True

    def ProcessIntersectList(self):
        _g = 0
        _g1 = len(self.m_IntersectList)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            iNode = (self.m_IntersectList[i] if i >= 0 and i < len(self.m_IntersectList) else None)
            self.IntersectEdges(iNode.edge1,iNode.edge2,iNode.pt)
            self.SwapPositionsInAEL(iNode.edge1,iNode.edge2)
        self.m_IntersectList = []

    def Round(self,value):
        if (value < 0):
            tmp = None
            try:
                tmp = int((value - 0.5))
            except BaseException as _g:
                None
                tmp = None
            return tmp
        else:
            tmp = None
            try:
                tmp = int((value + 0.5))
            except BaseException as _g:
                None
                tmp = None
            return tmp

    def TopX(self,edge,currentY):
        if (currentY == edge.topY):
            return edge.topX
        edge1 = edge.botX
        value = (edge.dx * ((currentY - edge.botY)))
        tmp = None
        if (value < 0):
            tmp1 = None
            try:
                tmp1 = int((value - 0.5))
            except BaseException as _g:
                None
                tmp1 = None
            tmp = tmp1
        else:
            tmp1 = None
            try:
                tmp1 = int((value + 0.5))
            except BaseException as _g:
                None
                tmp1 = None
            tmp = tmp1
        return (edge1 + tmp)

    def IntersectPoint(self,edge1,edge2):
        ipx = None
        ipy = None
        b1 = None
        b2 = None
        if (edge1.dx == edge2.dx):
            ipy = edge1.currY
            if (ipy == edge1.topY):
                ipx = edge1.topX
            else:
                edge11 = edge1.botX
                value = (edge1.dx * ((ipy - edge1.botY)))
                ipx1 = None
                if (value < 0):
                    ipx2 = None
                    try:
                        ipx2 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipx2 = None
                    ipx1 = ipx2
                else:
                    ipx2 = None
                    try:
                        ipx2 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipx2 = None
                    ipx1 = ipx2
                ipx = (edge11 + ipx1)
            return h2d_col_IPoint(ipx,ipy)
        if (edge1.deltaX == 0):
            ipx = edge1.botX
            if (edge2.deltaY == 0):
                ipy = edge2.botY
            else:
                b2 = (edge2.botY - ((edge2.botX / edge2.dx)))
                value = ((ipx / edge2.dx) + b2)
                if (value < 0):
                    ipy1 = None
                    try:
                        ipy1 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipy1 = None
                    ipy = ipy1
                else:
                    ipy1 = None
                    try:
                        ipy1 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipy1 = None
                    ipy = ipy1
        elif (edge2.deltaX == 0):
            ipx = edge2.botX
            if (edge1.deltaY == 0):
                ipy = edge1.botY
            else:
                b1 = (edge1.botY - ((edge1.botX / edge1.dx)))
                value = ((ipx / edge1.dx) + b1)
                if (value < 0):
                    ipy1 = None
                    try:
                        ipy1 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipy1 = None
                    ipy = ipy1
                else:
                    ipy1 = None
                    try:
                        ipy1 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipy1 = None
                    ipy = ipy1
        else:
            b1 = (edge1.botX - ((edge1.botY * edge1.dx)))
            b2 = (edge2.botX - ((edge2.botY * edge2.dx)))
            q = (((b2 - b1)) / ((edge1.dx - edge2.dx)))
            if (q < 0):
                ipy1 = None
                try:
                    ipy1 = int((q - 0.5))
                except BaseException as _g:
                    None
                    ipy1 = None
                ipy = ipy1
            else:
                ipy1 = None
                try:
                    ipy1 = int((q + 0.5))
                except BaseException as _g:
                    None
                    ipy1 = None
                ipy = ipy1
            f = edge1.dx
            f1 = edge2.dx
            if (((-f if ((f < 0)) else f)) < ((-f1 if ((f1 < 0)) else f1))):
                value = ((edge1.dx * q) + b1)
                if (value < 0):
                    ipx1 = None
                    try:
                        ipx1 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipx1 = None
                    ipx = ipx1
                else:
                    ipx1 = None
                    try:
                        ipx1 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipx1 = None
                    ipx = ipx1
            else:
                value = ((edge2.dx * q) + b2)
                if (value < 0):
                    ipx1 = None
                    try:
                        ipx1 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipx1 = None
                    ipx = ipx1
                else:
                    ipx1 = None
                    try:
                        ipx1 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipx1 = None
                    ipx = ipx1
        if ((ipy < edge1.topY) or ((ipy < edge2.topY))):
            if (edge1.topY > edge2.topY):
                ipy = edge1.topY
            else:
                ipy = edge2.topY
            f = edge1.dx
            f1 = edge2.dx
            if (((-f if ((f < 0)) else f)) < ((-f1 if ((f1 < 0)) else f1))):
                if (ipy == edge1.topY):
                    ipx = edge1.topX
                else:
                    edge11 = edge1.botX
                    value = (edge1.dx * ((ipy - edge1.botY)))
                    ipx1 = None
                    if (value < 0):
                        ipx2 = None
                        try:
                            ipx2 = int((value - 0.5))
                        except BaseException as _g:
                            None
                            ipx2 = None
                        ipx1 = ipx2
                    else:
                        ipx2 = None
                        try:
                            ipx2 = int((value + 0.5))
                        except BaseException as _g:
                            None
                            ipx2 = None
                        ipx1 = ipx2
                    ipx = (edge11 + ipx1)
            elif (ipy == edge2.topY):
                ipx = edge2.topX
            else:
                edge21 = edge2.botX
                value = (edge2.dx * ((ipy - edge2.botY)))
                ipx1 = None
                if (value < 0):
                    ipx2 = None
                    try:
                        ipx2 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipx2 = None
                    ipx1 = ipx2
                else:
                    ipx2 = None
                    try:
                        ipx2 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipx2 = None
                    ipx1 = ipx2
                ipx = (edge21 + ipx1)
        if (ipy > edge1.currY):
            ipy = edge1.currY
            f = edge1.dx
            f1 = edge2.dx
            if (((-f if ((f < 0)) else f)) > ((-f1 if ((f1 < 0)) else f1))):
                if (ipy == edge2.topY):
                    ipx = edge2.topX
                else:
                    edge21 = edge2.botX
                    value = (edge2.dx * ((ipy - edge2.botY)))
                    ipx1 = None
                    if (value < 0):
                        ipx2 = None
                        try:
                            ipx2 = int((value - 0.5))
                        except BaseException as _g:
                            None
                            ipx2 = None
                        ipx1 = ipx2
                    else:
                        ipx2 = None
                        try:
                            ipx2 = int((value + 0.5))
                        except BaseException as _g:
                            None
                            ipx2 = None
                        ipx1 = ipx2
                    ipx = (edge21 + ipx1)
            elif (ipy == edge1.topY):
                ipx = edge1.topX
            else:
                edge11 = edge1.botX
                value = (edge1.dx * ((ipy - edge1.botY)))
                ipx1 = None
                if (value < 0):
                    ipx2 = None
                    try:
                        ipx2 = int((value - 0.5))
                    except BaseException as _g:
                        None
                        ipx2 = None
                    ipx1 = ipx2
                else:
                    ipx2 = None
                    try:
                        ipx2 = int((value + 0.5))
                    except BaseException as _g:
                        None
                        ipx2 = None
                    ipx1 = ipx2
                ipx = (edge11 + ipx1)
        return h2d_col_IPoint(ipx,ipy)

    def ProcessEdgesAtTopOfScanbeam(self,topY):
        e = self.m_ActiveEdges
        while (e is not None):
            IsMaximaEdge = (((e is not None) and ((e.topY == topY))) and ((e.nextInLML is None)))
            if IsMaximaEdge:
                eMaxPair = self.GetMaximaPair(e)
                IsMaximaEdge = ((eMaxPair is None) or ((eMaxPair.deltaY != 0)))
            if IsMaximaEdge:
                ePrev = e.prevInAEL
                self.DoMaxima(e)
                if (ePrev is None):
                    e = self.m_ActiveEdges
                else:
                    e = ePrev.nextInAEL
            else:
                if (((e.topY == topY) and ((e.nextInLML is not None))) and ((e.nextInLML.deltaY == 0))):
                    e = self.UpdateEdgeIntoAEL(e)
                    if (e.outIdx >= 0):
                        self.AddOutPt(e,h2d_col_IPoint(e.botX,e.botY))
                    self.AddEdgeToSEL(e)
                else:
                    tmp = None
                    if (topY == e.topY):
                        tmp = e.topX
                    else:
                        e1 = e.botX
                        value = (e.dx * ((topY - e.botY)))
                        tmp1 = None
                        if (value < 0):
                            tmp2 = None
                            try:
                                tmp2 = int((value - 0.5))
                            except BaseException as _g:
                                None
                                tmp2 = None
                            tmp1 = tmp2
                        else:
                            tmp3 = None
                            try:
                                tmp3 = int((value + 0.5))
                            except BaseException as _g1:
                                None
                                tmp3 = None
                            tmp1 = tmp3
                        tmp = (e1 + tmp1)
                    e.currX = tmp
                    e.currY = topY
                if self.strictlySimple:
                    ePrev1 = e.prevInAEL
                    if ((((((e.outIdx >= 0) and ((e.windDelta != 0))) and ((ePrev1 is not None))) and ((ePrev1.outIdx >= 0))) and ((ePrev1.currX == e.currX))) and ((ePrev1.windDelta != 0))):
                        ip = h2d_col_IPoint(e.currX,e.currY)
                        op = self.AddOutPt(ePrev1,ip)
                        op2 = self.AddOutPt(e,ip)
                        self.AddJoin(op,op2,ip)
                e = e.nextInAEL
        self.ProcessHorizontals(True)
        e = self.m_ActiveEdges
        while (e is not None):
            if ((e.topY == topY) and ((e.nextInLML is not None))):
                op = None
                if (e.outIdx >= 0):
                    op = self.AddOutPt(e,h2d_col_IPoint(e.topX,e.topY))
                e = self.UpdateEdgeIntoAEL(e)
                ePrev = e.prevInAEL
                eNext = e.nextInAEL
                if (((((((((ePrev is not None) and ((ePrev.currX == e.botX))) and ((ePrev.currY == e.botY))) and ((op is not None))) and ((ePrev.outIdx >= 0))) and ((ePrev.currY > ePrev.topY))) and (((e.deltaY * ePrev.deltaX) == ((e.deltaX * ePrev.deltaY))))) and ((e.windDelta != 0))) and ((ePrev.windDelta != 0))):
                    op2 = self.AddOutPt(ePrev,h2d_col_IPoint(e.botX,e.botY))
                    self.AddJoin(op,op2,h2d_col_IPoint(e.topX,e.topY))
                elif (((((((((eNext is not None) and ((eNext.currX == e.botX))) and ((eNext.currY == e.botY))) and ((op is not None))) and ((eNext.outIdx >= 0))) and ((eNext.currY > eNext.topY))) and (((e.deltaY * eNext.deltaX) == ((e.deltaX * eNext.deltaY))))) and ((e.windDelta != 0))) and ((eNext.windDelta != 0))):
                    op21 = self.AddOutPt(eNext,h2d_col_IPoint(e.botX,e.botY))
                    self.AddJoin(op,op21,h2d_col_IPoint(e.topX,e.topY))
            e = e.nextInAEL

    def DoMaxima(self,e):
        eMaxPair = self.GetMaximaPair(e)
        if (eMaxPair is None):
            if (e.outIdx >= 0):
                self.AddOutPt(e,h2d_col_IPoint(e.topX,e.topY))
            self.DeleteFromAEL(e)
            return
        eNext = e.nextInAEL
        while ((eNext is not None) and ((eNext != eMaxPair))):
            self.IntersectEdges(e,eNext,h2d_col_IPoint(e.topX,e.topY))
            self.SwapPositionsInAEL(e,eNext)
            eNext = e.nextInAEL
        if ((e.outIdx == -1) and ((eMaxPair.outIdx == -1))):
            self.DeleteFromAEL(e)
            self.DeleteFromAEL(eMaxPair)
        elif ((e.outIdx >= 0) and ((eMaxPair.outIdx >= 0))):
            if (e.outIdx >= 0):
                self.AddLocalMaxPoly(e,eMaxPair,h2d_col_IPoint(e.topX,e.topY))
            self.DeleteFromAEL(e)
            self.DeleteFromAEL(eMaxPair)
        else:
            raise haxe_Exception.thrown("DoMaxima error")

    def reversePolygons(self,polys):
        _g_i = 0
        _g_a = polys
        _g_l = len(_g_a)
        while (_g_i < _g_l):
            p = _g_i
            _g_i = (_g_i + 1)
            p1 = (_g_a[p] if p >= 0 and p < len(_g_a) else None)
            h2d_col__IPolygon_IPolygon_Impl_.reverse(p1)

    def PointCount(self,pts):
        if (pts is None):
            return 0
        result = 0
        p = pts
        while True:
            result = (result + 1)
            p = p.next
            if (not ((p != pts))):
                break
        return result

    def BuildResult(self):
        solution = []
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (outRec.pts is None):
                continue
            if ((self.resultKind == hxd_clipper_ResultKind.NoHoles) and outRec.isHole):
                continue
            if ((self.resultKind == hxd_clipper_ResultKind.HolesOnly) and (not outRec.isHole)):
                continue
            p = outRec.pts.prev
            cnt = self.PointCount(p)
            if (cnt < 2):
                continue
            points = None
            this1 = ([] if ((points is None)) else points)
            pg = this1
            _g2 = 0
            _g3 = cnt
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                x = p.pt
                pg.append(x)
                p = p.prev
            solution.append(pg)
        return solution

    def BuildResult2(self,polytree):
        polytree.clear()
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            cnt = self.PointCount(outRec.pts)
            if (cnt < 3):
                continue
            self.FixHoleLinkage(outRec)
            pn = hxd_clipper__Clipper_PolyNode()
            _this = polytree.allPolys
            _this.append(pn)
            outRec.polyNode = pn
            op = outRec.pts.prev
            _g2 = 0
            _g3 = cnt
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                _this1 = pn.polygon
                x = op.pt
                _this1.append(x)
                op = op.prev
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (outRec.polyNode is None):
                continue
            elif ((outRec.firstLeft is not None) and ((outRec.firstLeft.polyNode is not None))):
                outRec.firstLeft.polyNode.addChild(outRec.polyNode)
            else:
                polytree.addChild(outRec.polyNode)

    def FixupOutPolygon(self,outRec):
        lastOK = None
        outRec.bottomPt = None
        pp = outRec.pts
        while True:
            if ((pp.prev == pp) or ((pp.prev == pp.next))):
                outRec.pts = None
                return
            tmp = None
            tmp1 = None
            pt1 = pp.pt
            pt2 = pp.next.pt
            if (not (((pt1.x == pt2.x) and ((pt1.y == pt2.y))))):
                pt11 = pp.pt
                pt21 = pp.prev.pt
                tmp1 = ((pt11.x == pt21.x) and ((pt11.y == pt21.y)))
            else:
                tmp1 = True
            if (not tmp1):
                pt12 = pp.prev.pt
                pt22 = pp.pt
                pt3 = pp.next.pt
                tmp = ((((((pt12.y - pt22.y)) * ((pt22.x - pt3.x))) - ((((pt12.x - pt22.x)) * ((pt22.y - pt3.y))))) == 0) and (((not self.preserveCollinear) or (not self.Pt2IsBetweenPt1AndPt3(pp.prev.pt,pp.pt,pp.next.pt)))))
            else:
                tmp = True
            if tmp:
                lastOK = None
                tmp2 = pp
                pp.prev.next = pp.next
                pp.next.prev = pp.prev
                pp = pp.prev
                tmp2 = None
            elif (pp == lastOK):
                break
            else:
                if (lastOK is None):
                    lastOK = pp
                pp = pp.next
        outRec.pts = pp

    def DupOutPt(self,outPt,InsertAfter):
        result = hxd_clipper__Clipper_OutPt()
        result.pt = outPt.pt
        result.idx = outPt.idx
        if InsertAfter:
            result.next = outPt.next
            result.prev = outPt
            outPt.next.prev = result
            outPt.next = result
        else:
            result.prev = outPt.prev
            result.next = outPt
            outPt.prev.next = result
            outPt.prev = result
        return result

    def GetOverlap(self,a1,a2,b1,b2):
        Left = None
        Right = None
        if (a1 < a2):
            if (b1 < b2):
                Left = (b1 if ((a1 < b1)) else a1)
                Right = (b2 if ((a2 > b2)) else a2)
            else:
                Left = (b2 if ((a1 < b2)) else a1)
                Right = (b1 if ((a2 > b1)) else a2)
        elif (b1 < b2):
            Left = (b1 if ((a2 < b1)) else a2)
            Right = (b2 if ((a1 > b2)) else a1)
        else:
            Left = (b2 if ((a2 < b2)) else a2)
            Right = (b1 if ((a1 > b1)) else a1)
        return _hx_AnonObject({'left': Left, 'right': Right, 'done': (Left < Right)})

    def JoinHorz(self,op1,op1b,op2,op2b,pt,DiscardLeft):
        Dir1 = (hxd_clipper__Clipper_Direction.RightToLeft if ((op1.pt.x > op1b.pt.x)) else hxd_clipper__Clipper_Direction.LeftToRight)
        Dir2 = (hxd_clipper__Clipper_Direction.RightToLeft if ((op2.pt.x > op2b.pt.x)) else hxd_clipper__Clipper_Direction.LeftToRight)
        if (Dir1 == Dir2):
            return False
        if (Dir1 == hxd_clipper__Clipper_Direction.LeftToRight):
            while (((op1.next.pt.x <= pt.x) and ((op1.next.pt.x >= op1.pt.x))) and ((op1.next.pt.y == pt.y))):
                op1 = op1.next
            if (DiscardLeft and ((op1.pt.x != pt.x))):
                op1 = op1.next
            op1b = self.DupOutPt(op1,(not DiscardLeft))
            if (op1b.pt != pt):
                op1 = op1b
                op1.pt = pt
                op1b = self.DupOutPt(op1,(not DiscardLeft))
        else:
            while (((op1.next.pt.x >= pt.x) and ((op1.next.pt.x <= op1.pt.x))) and ((op1.next.pt.y == pt.y))):
                op1 = op1.next
            if ((not DiscardLeft) and ((op1.pt.x != pt.x))):
                op1 = op1.next
            op1b = self.DupOutPt(op1,DiscardLeft)
            if (op1b.pt != pt):
                op1 = op1b
                op1.pt = pt
                op1b = self.DupOutPt(op1,DiscardLeft)
        if (Dir2 == hxd_clipper__Clipper_Direction.LeftToRight):
            while (((op2.next.pt.x <= pt.x) and ((op2.next.pt.x >= op2.pt.x))) and ((op2.next.pt.y == pt.y))):
                op2 = op2.next
            if (DiscardLeft and ((op2.pt.x != pt.x))):
                op2 = op2.next
            op2b = self.DupOutPt(op2,(not DiscardLeft))
            if (op2b.pt != pt):
                op2 = op2b
                op2.pt = pt
                op2b = self.DupOutPt(op2,(not DiscardLeft))
        else:
            while (((op2.next.pt.x >= pt.x) and ((op2.next.pt.x <= op2.pt.x))) and ((op2.next.pt.y == pt.y))):
                op2 = op2.next
            if ((not DiscardLeft) and ((op2.pt.x != pt.x))):
                op2 = op2.next
            op2b = self.DupOutPt(op2,DiscardLeft)
            if (op2b.pt != pt):
                op2 = op2b
                op2.pt = pt
                op2b = self.DupOutPt(op2,DiscardLeft)
        if ((Dir1 == hxd_clipper__Clipper_Direction.LeftToRight) == DiscardLeft):
            op1.prev = op2
            op2.next = op1
            op1b.next = op2b
            op2b.prev = op1b
        else:
            op1.next = op2
            op2.prev = op1
            op1b.prev = op2b
            op2b.next = op1b
        return True

    def JoinPoints(self,j,outRec1,outRec2):
        op1 = j.outPt1
        op1b = None
        op2 = j.outPt2
        op2b = None
        isHorizontal = (j.outPt1.pt.y == j.offPt.y)
        tmp = None
        tmp1 = None
        if isHorizontal:
            pt1 = j.offPt
            pt2 = j.outPt1.pt
            tmp1 = ((pt1.x == pt2.x) and ((pt1.y == pt2.y)))
        else:
            tmp1 = False
        if tmp1:
            pt1 = j.offPt
            pt2 = j.outPt2.pt
            tmp = ((pt1.x == pt2.x) and ((pt1.y == pt2.y)))
        else:
            tmp = False
        if tmp:
            if (outRec1 != outRec2):
                return False
            op1b = j.outPt1.next
            while True:
                tmp = None
                if (op1b != op1):
                    pt1 = op1b.pt
                    pt2 = j.offPt
                    tmp = ((pt1.x == pt2.x) and ((pt1.y == pt2.y)))
                else:
                    tmp = False
                if (not tmp):
                    break
                op1b = op1b.next
            reverse1 = (op1b.pt.y > j.offPt.y)
            op2b = j.outPt2.next
            while True:
                tmp = None
                if (op2b != op2):
                    pt1 = op2b.pt
                    pt2 = j.offPt
                    tmp = ((pt1.x == pt2.x) and ((pt1.y == pt2.y)))
                else:
                    tmp = False
                if (not tmp):
                    break
                op2b = op2b.next
            reverse2 = (op2b.pt.y > j.offPt.y)
            if (reverse1 == reverse2):
                return False
            if reverse1:
                op1b = self.DupOutPt(op1,False)
                op2b = self.DupOutPt(op2,True)
                op1.prev = op2
                op2.next = op1
                op1b.next = op2b
                op2b.prev = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return True
            else:
                op1b = self.DupOutPt(op1,True)
                op2b = self.DupOutPt(op2,False)
                op1.next = op2
                op2.prev = op1
                op1b.prev = op2b
                op2b.next = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return True
        elif isHorizontal:
            op1b = op1
            while (((op1.prev.pt.y == op1.pt.y) and ((op1.prev != op1b))) and ((op1.prev != op2))):
                op1 = op1.prev
            while (((op1b.next.pt.y == op1b.pt.y) and ((op1b.next != op1))) and ((op1b.next != op2))):
                op1b = op1b.next
            if ((op1b.next == op1) or ((op1b.next == op2))):
                return False
            op2b = op2
            while (((op2.prev.pt.y == op2.pt.y) and ((op2.prev != op2b))) and ((op2.prev != op1b))):
                op2 = op2.prev
            while (((op2b.next.pt.y == op2b.pt.y) and ((op2b.next != op2))) and ((op2b.next != op1))):
                op2b = op2b.next
            if ((op2b.next == op2) or ((op2b.next == op1))):
                return False
            out = self.GetOverlap(op1.pt.x,op1b.pt.x,op2.pt.x,op2b.pt.x)
            if (not out.done):
                return False
            Left = out.left
            Right = out.right
            Pt = None
            DiscardLeftSide = None
            if ((op1.pt.x >= Left) and ((op1.pt.x <= Right))):
                Pt = op1.pt
                DiscardLeftSide = (op1.pt.x > op1b.pt.x)
            elif ((op2.pt.x >= Left) and ((op2.pt.x <= Right))):
                Pt = op2.pt
                DiscardLeftSide = (op2.pt.x > op2b.pt.x)
            elif ((op1b.pt.x >= Left) and ((op1b.pt.x <= Right))):
                Pt = op1b.pt
                DiscardLeftSide = (op1b.pt.x > op1.pt.x)
            else:
                Pt = op2b.pt
                DiscardLeftSide = (op2b.pt.x > op2.pt.x)
            j.outPt1 = op1
            j.outPt2 = op2
            return self.JoinHorz(op1,op1b,op2,op2b,Pt,DiscardLeftSide)
        else:
            op1b = op1.next
            while True:
                pt1 = op1b.pt
                pt2 = op1.pt
                if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((op1b != op1))))):
                    break
                op1b = op1b.next
            Reverse1 = None
            if (op1b.pt.y <= op1.pt.y):
                pt1 = op1.pt
                pt2 = op1b.pt
                pt3 = j.offPt
                Reverse1 = (((((pt1.y - pt2.y)) * ((pt2.x - pt3.x))) - ((((pt1.x - pt2.x)) * ((pt2.y - pt3.y))))) != 0)
            else:
                Reverse1 = True
            if Reverse1:
                op1b = op1.prev
                while True:
                    pt1 = op1b.pt
                    pt2 = op1.pt
                    if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((op1b != op1))))):
                        break
                    op1b = op1b.prev
                tmp = None
                if (op1b.pt.y <= op1.pt.y):
                    pt1 = op1.pt
                    pt2 = op1b.pt
                    pt3 = j.offPt
                    tmp = (((((pt1.y - pt2.y)) * ((pt2.x - pt3.x))) - ((((pt1.x - pt2.x)) * ((pt2.y - pt3.y))))) != 0)
                else:
                    tmp = True
                if tmp:
                    return False
            op2b = op2.next
            while True:
                pt1 = op2b.pt
                pt2 = op2.pt
                if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((op2b != op2))))):
                    break
                op2b = op2b.next
            Reverse2 = None
            if (op2b.pt.y <= op2.pt.y):
                pt1 = op2.pt
                pt2 = op2b.pt
                pt3 = j.offPt
                Reverse2 = (((((pt1.y - pt2.y)) * ((pt2.x - pt3.x))) - ((((pt1.x - pt2.x)) * ((pt2.y - pt3.y))))) != 0)
            else:
                Reverse2 = True
            if Reverse2:
                op2b = op2.prev
                while True:
                    pt1 = op2b.pt
                    pt2 = op2.pt
                    if (not ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((op2b != op2))))):
                        break
                    op2b = op2b.prev
                tmp = None
                if (op2b.pt.y <= op2.pt.y):
                    pt1 = op2.pt
                    pt2 = op2b.pt
                    pt3 = j.offPt
                    tmp = (((((pt1.y - pt2.y)) * ((pt2.x - pt3.x))) - ((((pt1.x - pt2.x)) * ((pt2.y - pt3.y))))) != 0)
                else:
                    tmp = True
                if tmp:
                    return False
            if ((((op1b == op1) or ((op2b == op2))) or ((op1b == op2b))) or (((outRec1 == outRec2) and ((Reverse1 == Reverse2))))):
                return False
            if Reverse1:
                op1b = self.DupOutPt(op1,False)
                op2b = self.DupOutPt(op2,True)
                op1.prev = op2
                op2.next = op1
                op1b.next = op2b
                op2b.prev = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return True
            else:
                op1b = self.DupOutPt(op1,True)
                op2b = self.DupOutPt(op2,False)
                op1.next = op2
                op2.prev = op1
                op1b.prev = op2b
                op2b.next = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return True

    def PointInPolygon(self,pt,pol):
        result = 0
        cnt = len(pol)
        if (cnt < 3):
            return 0
        ip = (pol[0] if 0 < len(pol) else None)
        _g = 1
        _g1 = (cnt + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            ipNext = ((pol[0] if 0 < len(pol) else None) if ((i == cnt)) else (pol[i] if i >= 0 and i < len(pol) else None))
            if (ipNext.y == pt.y):
                if ((ipNext.x == pt.x) or (((ip.y == pt.y) and (((ipNext.x > pt.x) == ((ip.x < pt.x))))))):
                    return -1
            if ((ip.y < pt.y) != ((ipNext.y < pt.y))):
                if (ip.x >= pt.x):
                    if (ipNext.x > pt.x):
                        result = (1 - result)
                    else:
                        d = ((((ip.x - pt.x)) * ((ipNext.y - pt.y))) - ((((ipNext.x - pt.x)) * ((ip.y - pt.y)))))
                        if (d == 0):
                            return -1
                        elif ((d > 0) == ((ipNext.y > ip.y))):
                            result = (1 - result)
                elif (ipNext.x > pt.x):
                    d1 = ((((ip.x - pt.x)) * ((ipNext.y - pt.y))) - ((((ipNext.x - pt.x)) * ((ip.y - pt.y)))))
                    if (d1 == 0):
                        return -1
                    elif ((d1 > 0) == ((ipNext.y > ip.y))):
                        result = (1 - result)
            ip = ipNext
        return result

    def PointInPolygon2(self,pt,op):
        result = 0
        startOp = op
        ptx = pt.x
        pty = pt.y
        poly0x = op.pt.x
        poly0y = op.pt.y
        while True:
            op = op.next
            poly1x = op.pt.x
            poly1y = op.pt.y
            if (poly1y == pty):
                if ((poly1x == ptx) or (((poly0y == pty) and (((poly1x > ptx) == ((poly0x < ptx))))))):
                    return -1
            if ((poly0y < pty) != ((poly1y < pty))):
                if (poly0x >= ptx):
                    if (poly1x > ptx):
                        result = (1 - result)
                    else:
                        d = ((((poly0x - ptx)) * ((poly1y - pty))) - ((((poly1x - ptx)) * ((poly0y - pty)))))
                        if (d == 0):
                            return -1
                        if ((d > 0) == ((poly1y > poly0y))):
                            result = (1 - result)
                elif (poly1x > ptx):
                    d1 = ((((poly0x - ptx)) * ((poly1y - pty))) - ((((poly1x - ptx)) * ((poly0y - pty)))))
                    if (d1 == 0):
                        return -1
                    if ((d1 > 0) == ((poly1y > poly0y))):
                        result = (1 - result)
            poly0x = poly1x
            poly0y = poly1y
            if (not ((startOp != op))):
                break
        return result

    def Poly2ContainsPoly1(self,outPt1,outPt2):
        op = outPt1
        while True:
            res = self.PointInPolygon2(op.pt,outPt2)
            if (res >= 0):
                return (res > 0)
            op = op.next
            if (not ((op != outPt1))):
                break
        return True

    def FixupFirstLefts1(self,OldOutRec,NewOutRec):
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((outRec.pts is None) or ((outRec.firstLeft is None))):
                continue
            firstLeft = self.ParseFirstLeft(outRec.firstLeft)
            if (firstLeft == OldOutRec):
                if self.Poly2ContainsPoly1(outRec.pts,NewOutRec.pts):
                    outRec.firstLeft = NewOutRec

    def FixupFirstLefts2(self,OldOutRec,NewOutRec):
        _g = 0
        _g1 = self.m_PolyOuts
        while (_g < len(_g1)):
            outRec = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (outRec.firstLeft == OldOutRec):
                outRec.firstLeft = NewOutRec

    def ParseFirstLeft(self,FirstLeft):
        while ((FirstLeft is not None) and ((FirstLeft.pts is None))):
            FirstLeft = FirstLeft.firstLeft
        return FirstLeft

    def JoinCommonEdges(self):
        _g = 0
        _g1 = len(self.m_Joins)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            join = (self.m_Joins[i] if i >= 0 and i < len(self.m_Joins) else None)
            outRec1 = self.GetOutRec(join.outPt1.idx)
            outRec2 = self.GetOutRec(join.outPt2.idx)
            if ((outRec1.pts is None) or ((outRec2.pts is None))):
                continue
            holeStateRec = None
            if (outRec1 == outRec2):
                holeStateRec = outRec1
            elif self.Param1RightOfParam2(outRec1,outRec2):
                holeStateRec = outRec2
            elif self.Param1RightOfParam2(outRec2,outRec1):
                holeStateRec = outRec1
            else:
                holeStateRec = self.GetLowermostRec(outRec1,outRec2)
            if (not self.JoinPoints(join,outRec1,outRec2)):
                continue
            if (outRec1 == outRec2):
                outRec1.pts = join.outPt1
                outRec1.bottomPt = None
                outRec2 = self.CreateOutRec()
                outRec2.pts = join.outPt2
                self.UpdateOutPtIdxs(outRec2)
                if self.m_UsingPolyTree:
                    _g2 = 0
                    _g3 = (len(self.m_PolyOuts) - 1)
                    while (_g2 < _g3):
                        j = _g2
                        _g2 = (_g2 + 1)
                        oRec = (self.m_PolyOuts[j] if j >= 0 and j < len(self.m_PolyOuts) else None)
                        if (((oRec.pts is None) or ((self.ParseFirstLeft(oRec.firstLeft) != outRec1))) or ((oRec.isHole == outRec1.isHole))):
                            continue
                        if self.Poly2ContainsPoly1(oRec.pts,join.outPt2):
                            oRec.firstLeft = outRec2
                if self.Poly2ContainsPoly1(outRec2.pts,outRec1.pts):
                    outRec2.isHole = (not outRec1.isHole)
                    outRec2.firstLeft = outRec1
                    if self.m_UsingPolyTree:
                        self.FixupFirstLefts2(outRec2,outRec1)
                    b = self.reverseSolution
                    if ((((not b) if (outRec2.isHole) else b)) == ((self.Area(outRec2) > 0))):
                        self.ReversePolyPtLinks(outRec2.pts)
                elif self.Poly2ContainsPoly1(outRec1.pts,outRec2.pts):
                    outRec2.isHole = outRec1.isHole
                    outRec1.isHole = (not outRec2.isHole)
                    outRec2.firstLeft = outRec1.firstLeft
                    outRec1.firstLeft = outRec2
                    if self.m_UsingPolyTree:
                        self.FixupFirstLefts2(outRec1,outRec2)
                    b1 = self.reverseSolution
                    if ((((not b1) if (outRec1.isHole) else b1)) == ((self.Area(outRec1) > 0))):
                        self.ReversePolyPtLinks(outRec1.pts)
                else:
                    outRec2.isHole = outRec1.isHole
                    outRec2.firstLeft = outRec1.firstLeft
                    if self.m_UsingPolyTree:
                        self.FixupFirstLefts1(outRec1,outRec2)
            else:
                outRec2.pts = None
                outRec2.bottomPt = None
                outRec2.idx = outRec1.idx
                outRec1.isHole = holeStateRec.isHole
                if (holeStateRec == outRec2):
                    outRec1.firstLeft = outRec2.firstLeft
                outRec2.firstLeft = outRec1
                if self.m_UsingPolyTree:
                    self.FixupFirstLefts2(outRec2,outRec1)

    def UpdateOutPtIdxs(self,outrec):
        op = outrec.pts
        while True:
            op.idx = outrec.idx
            op = op.prev
            if (not ((op != outrec.pts))):
                break

    def DoSimplePolygons(self):
        i = 0
        while (i < len(self.m_PolyOuts)):
            outrec = i
            i = (i + 1)
            outrec1 = (self.m_PolyOuts[outrec] if outrec >= 0 and outrec < len(self.m_PolyOuts) else None)
            op = outrec1.pts
            if (op is None):
                continue
            while True:
                op2 = op.next
                while (op2 != outrec1.pts):
                    pt1 = op.pt
                    pt2 = op2.pt
                    if ((((pt1.x == pt2.x) and ((pt1.y == pt2.y))) and ((op2.next != op))) and ((op2.prev != op))):
                        op3 = op.prev
                        op4 = op2.prev
                        op.prev = op4
                        op4.next = op
                        op2.prev = op3
                        op3.next = op2
                        outrec1.pts = op
                        outrec2 = self.CreateOutRec()
                        outrec2.pts = op2
                        self.UpdateOutPtIdxs(outrec2)
                        if self.Poly2ContainsPoly1(outrec2.pts,outrec1.pts):
                            outrec2.isHole = (not outrec1.isHole)
                            outrec2.firstLeft = outrec1
                        elif self.Poly2ContainsPoly1(outrec1.pts,outrec2.pts):
                            outrec2.isHole = outrec1.isHole
                            outrec1.isHole = (not outrec2.isHole)
                            outrec2.firstLeft = outrec1.firstLeft
                            outrec1.firstLeft = outrec2
                        else:
                            outrec2.isHole = outrec1.isHole
                            outrec2.firstLeft = outrec1.firstLeft
                        op2 = op
                    op2 = op2.next
                op = op.next
                if (not ((op != outrec1.pts))):
                    break

    def Area(self,outRec):
        op = outRec.pts
        if (op is None):
            return 0.
        a = 0
        while True:
            a = (a + ((((op.pt.x + op.prev.pt.x)) * ((op.prev.pt.y - op.pt.y)))))
            op = op.next
            if (not ((op != outRec.pts))):
                break
        return (a / 2)

    def DistanceFromLineSqrd(self,pt,ln1,ln2):
        A = (ln1.y - ln2.y)
        B = (ln2.x - ln1.x)
        C = ((A * ln1.x) + ((B * ln1.y)))
        C = (((A * pt.x) + ((B * pt.y))) - C)
        return ((C * C) / (((A * A) + ((B * B)))))

    def SlopesNearCollinear(self,pt1,pt2,pt3,distSqrd):
        f = (pt1.x - pt2.x)
        f1 = (pt1.y - pt2.y)
        if (((-f if ((f < 0)) else f)) > ((-f1 if ((f1 < 0)) else f1))):
            if ((pt1.x > pt2.x) == ((pt1.x < pt3.x))):
                return (self.DistanceFromLineSqrd(pt1,pt2,pt3) < distSqrd)
            elif ((pt2.x > pt1.x) == ((pt2.x < pt3.x))):
                return (self.DistanceFromLineSqrd(pt2,pt1,pt3) < distSqrd)
            else:
                return (self.DistanceFromLineSqrd(pt3,pt1,pt2) < distSqrd)
        elif ((pt1.y > pt2.y) == ((pt1.y < pt3.y))):
            return (self.DistanceFromLineSqrd(pt1,pt2,pt3) < distSqrd)
        elif ((pt2.y > pt1.y) == ((pt2.y < pt3.y))):
            return (self.DistanceFromLineSqrd(pt2,pt1,pt3) < distSqrd)
        else:
            return (self.DistanceFromLineSqrd(pt3,pt1,pt2) < distSqrd)

    def PointsAreClose(self,pt1,pt2,distSqrd):
        dx = (pt1.x - pt2.x)
        dy = (pt1.y - pt2.y)
        return (((dx * dx) + ((dy * dy))) <= distSqrd)

    def ExcludeOp(self,op):
        result = op.prev
        result.next = op.next
        op.next.prev = result
        result.idx = 0
        return result

    def CleanPolygon(self,path,distance = None):
        if (distance is None):
            distance = 1.415
        cnt = len(path)
        if (cnt == 0):
            points = None
            this1 = ([] if ((points is None)) else points)
            return this1
        outPts = []
        _g = 0
        _g1 = cnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(outPts, i, hxd_clipper__Clipper_OutPt())
            (outPts[i] if i >= 0 and i < len(outPts) else None).pt = (path[i] if i >= 0 and i < len(path) else None)
            (outPts[i] if i >= 0 and i < len(outPts) else None).next = python_internal_ArrayImpl._get(outPts, HxOverrides.mod(((i + 1)), cnt))
            (outPts[i] if i >= 0 and i < len(outPts) else None).next.prev = (outPts[i] if i >= 0 and i < len(outPts) else None)
            (outPts[i] if i >= 0 and i < len(outPts) else None).idx = 0
        distSqrd = (distance * distance)
        op = (outPts[0] if 0 < len(outPts) else None)
        while ((op.idx == 0) and ((op.next != op.prev))):
            if self.PointsAreClose(op.pt,op.prev.pt,distSqrd):
                op = self.ExcludeOp(op)
                cnt = (cnt - 1)
            elif self.PointsAreClose(op.prev.pt,op.next.pt,distSqrd):
                self.ExcludeOp(op.next)
                op = self.ExcludeOp(op)
                cnt = (cnt - 2)
            elif self.SlopesNearCollinear(op.prev.pt,op.pt,op.next.pt,distSqrd):
                op = self.ExcludeOp(op)
                cnt = (cnt - 1)
            else:
                op.idx = 1
                op = op.next
        if (cnt < 3):
            cnt = 0
        points = None
        this1 = ([] if ((points is None)) else points)
        result = this1
        _g = 0
        _g1 = cnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = op.pt
            result.append(x)
            op = op.next
        outPts = None
        return result

    def CleanPolygons(self,polys,distance = None):
        if (distance is None):
            distance = 1.415
        polygons = None
        this1 = ([] if ((polygons is None)) else polygons)
        result = this1
        _g = 0
        _g1 = len(polys)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = self.CleanPolygon((polys[i] if i >= 0 and i < len(polys) else None),distance)
            result.append(x)
        return result

    def Minkowski(self,pattern,path,IsSum):
        polyCnt = len(pattern)
        pathCnt = len(path)
        polygons = None
        this1 = ([] if ((polygons is None)) else polygons)
        result = this1
        _g = 0
        _g1 = pathCnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            points = None
            this1 = ([] if ((points is None)) else points)
            p = this1
            _g_i = 0
            _g_a = pattern
            _g_l = len(_g_a)
            while (_g_i < _g_l):
                ip = _g_i
                _g_i = (_g_i + 1)
                ip1 = (_g_a[ip] if ip >= 0 and ip < len(_g_a) else None)
                if IsSum:
                    x = h2d_col_IPoint(((path[i] if i >= 0 and i < len(path) else None).x + ip1.x),((path[i] if i >= 0 and i < len(path) else None).y + ip1.y))
                    p.append(x)
                else:
                    x1 = h2d_col_IPoint(((path[i] if i >= 0 and i < len(path) else None).x - ip1.x),((path[i] if i >= 0 and i < len(path) else None).y - ip1.y))
                    p.append(x1)
            result.append(p)
        polygons = None
        this1 = ([] if ((polygons is None)) else polygons)
        quads = this1
        _g = 0
        _g1 = pathCnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = polyCnt
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                points = None
                this1 = ([] if ((points is None)) else points)
                quad = this1
                quad.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(result, HxOverrides.mod(i, pathCnt)), HxOverrides.mod(j, polyCnt)))
                quad.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(result, HxOverrides.mod(((i + 1)), pathCnt)), HxOverrides.mod(j, polyCnt)))
                quad.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(result, HxOverrides.mod(((i + 1)), pathCnt)), HxOverrides.mod(((j + 1)), polyCnt)))
                quad.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(result, HxOverrides.mod(i, pathCnt)), HxOverrides.mod(((j + 1)), polyCnt)))
                if (not ((hxd_clipper_Clipper.polArea(quad) >= 0))):
                    h2d_col__IPolygon_IPolygon_Impl_.reverse(quad)
                quads.append(quad)
        return quads

    def MinkowskiSum(self,pattern,pol,kind = None):
        paths = self.Minkowski(pattern,pol,True)
        c = hxd_clipper_Clipper()
        c.resultKind = (hxd_clipper_ResultKind.All if ((kind is None)) else kind)
        c.addPolygons(paths,hxd_clipper_PolyType.Subject)
        return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    def TranslatePath(self,path,delta):
        points = None
        this1 = ([] if ((points is None)) else points)
        outPath = this1
        _g = 0
        _g1 = len(path)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = h2d_col_IPoint(((path[i] if i >= 0 and i < len(path) else None).x + delta.x),((path[i] if i >= 0 and i < len(path) else None).y + delta.y))
            outPath.append(x)
        return outPath

    def PolyTreeToPaths(self,polytree):
        polygons = None
        this1 = ([] if ((polygons is None)) else polygons)
        result = this1
        self.AddPolyNodeToPaths(polytree,hxd_clipper_NodeType.Any,result)
        return result

    def AddPolyNodeToPaths(self,polynode,nt,paths):
        match = True
        if (nt.index == 1):
            return
        if ((len(polynode.polygon) > 0) and match):
            x = polynode.polygon
            paths.append(x)
        _g = 0
        _g1 = polynode.childs
        while (_g < len(_g1)):
            pn = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.AddPolyNodeToPaths(pn,nt,paths)

    @staticmethod
    def compareY(n1,n2):
        if ((n2.pt.y - n1.pt.y) >= 0):
            return 1
        else:
            return -1

    @staticmethod
    def Orientation(poly):
        return (hxd_clipper_Clipper.polArea(poly) >= 0)

    @staticmethod
    def polArea(poly):
        cnt = len(poly)
        if (cnt < 3):
            return 0.
        a = 0.
        j = (cnt - 1)
        _g = 0
        _g1 = cnt
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            a = (a + (((((poly[j] if j >= 0 and j < len(poly) else None).x + (poly[i] if i >= 0 and i < len(poly) else None).x)) * (((poly[j] if j >= 0 and j < len(poly) else None).y - (poly[i] if i >= 0 and i < len(poly) else None).y)))))
            j = i
        return (-a * 0.5)

    @staticmethod
    def SimplifyPolygon(poly,fillType = None):
        if (fillType is None):
            fillType = hxd_clipper_PolyFillType.EvenOdd
        c = hxd_clipper_Clipper()
        c.strictlySimple = True
        c.addPolygon(poly,hxd_clipper_PolyType.Subject)
        return c.execute(hxd_clipper_ClipType.Union,fillType,fillType)

    @staticmethod
    def SimplifyPolygons(polys,fillType = None):
        if (fillType is None):
            fillType = hxd_clipper_PolyFillType.EvenOdd
        c = hxd_clipper_Clipper()
        c.strictlySimple = True
        c.addPolygons(polys,hxd_clipper_PolyType.Subject)
        return c.execute(hxd_clipper_ClipType.Union,fillType,fillType)

    @staticmethod
    def MinkowskiSums(pattern,pols,kind = None):
        c = hxd_clipper_Clipper()
        c.resultKind = (hxd_clipper_ResultKind.All if ((kind is None)) else kind)
        _g = 0
        _g1 = len(pols)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            tmp = c.Minkowski(pattern,(pols[i] if i >= 0 and i < len(pols) else None),True)
            c.addPolygons(tmp,hxd_clipper_PolyType.Subject)
            path = c.TranslatePath((pols[i] if i >= 0 and i < len(pols) else None),(pattern[0] if 0 < len(pattern) else None))
            c.addPolygon(path,hxd_clipper_PolyType.Clip)
        return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    @staticmethod
    def MinkowskiDiff(pattern,pol,kind = None):
        c = hxd_clipper_Clipper()
        paths = c.Minkowski(pattern,pol,False)
        c.resultKind = (hxd_clipper_ResultKind.All if ((kind is None)) else kind)
        c.addPolygons(paths,hxd_clipper_PolyType.Subject)
        return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.strictlySimple = None
        _hx_o.reverseSolution = None
        _hx_o.resultKind = None
        _hx_o.m_PolyOuts = None
        _hx_o.m_ClipType = None
        _hx_o.m_Scanbeam = None
        _hx_o.m_ActiveEdges = None
        _hx_o.m_SortedEdges = None
        _hx_o.m_IntersectList = None
        _hx_o.m_ExecuteLocked = None
        _hx_o.m_ClipFillType = None
        _hx_o.m_SubjFillType = None
        _hx_o.m_Joins = None
        _hx_o.m_GhostJoins = None
        _hx_o.m_UsingPolyTree = None
hxd_clipper_Clipper._hx_class = hxd_clipper_Clipper
_hx_classes["hxd.clipper.Clipper"] = hxd_clipper_Clipper


class hxd_clipper_ClipperOffset:
    _hx_class_name = "hxd.clipper.ClipperOffset"
    _hx_is_interface = "False"
    __slots__ = ("m_destPolys", "m_srcPoly", "m_destPoly", "m_normals", "m_delta", "m_sinA", "m_sin", "m_cos", "m_miterLim", "m_StepsPerRad", "m_lowest", "m_polyNodes", "ArcTolerance", "MiterLimit", "resultKind", "def_arc_tolerance", "two_pi")
    _hx_fields = ["m_destPolys", "m_srcPoly", "m_destPoly", "m_normals", "m_delta", "m_sinA", "m_sin", "m_cos", "m_miterLim", "m_StepsPerRad", "m_lowest", "m_polyNodes", "ArcTolerance", "MiterLimit", "resultKind", "def_arc_tolerance", "two_pi"]
    _hx_methods = ["clear", "addPolygon", "addPolygons", "fixOrientations", "getUnitNormal", "doOffset", "execute", "offsetPoint", "doSquare", "doMiter", "doRound"]

    def __init__(self,miterLimit = None,arcTolerance = None):
        if (miterLimit is None):
            miterLimit = 2.0
        if (arcTolerance is None):
            arcTolerance = 0.25
        self.m_StepsPerRad = None
        self.m_miterLim = None
        self.m_cos = None
        self.m_sin = None
        self.m_sinA = None
        self.m_delta = None
        self.m_destPoly = None
        self.m_srcPoly = None
        self.m_destPolys = None
        self.two_pi = 6.28318530717958623
        self.def_arc_tolerance = 0.25
        self.MiterLimit = miterLimit
        self.ArcTolerance = arcTolerance
        self.m_lowest = h2d_col_IPoint(-1,0)
        self.m_normals = []
        self.m_polyNodes = hxd_clipper__Clipper_PolyNode()
        self.resultKind = hxd_clipper_ResultKind.All

    def clear(self):
        self.m_polyNodes = hxd_clipper__Clipper_PolyNode()
        self.m_lowest = h2d_col_IPoint(-1,0)

    def addPolygon(self,pol,joinType,endType):
        highI = (len(pol) - 1)
        if (highI < 0):
            return
        newNode = hxd_clipper__Clipper_PolyNode()
        newNode.jointype = joinType
        newNode.endtype = endType
        if ((endType == hxd_clipper_EndType.ClosedLine) or ((endType == hxd_clipper_EndType.ClosedPol))):
            while ((highI > 0) and (((pol[0] if 0 < len(pol) else None) == (pol[highI] if highI >= 0 and highI < len(pol) else None)))):
                highI = (highI - 1)
        _this = newNode.polygon
        _this.append((pol[0] if 0 < len(pol) else None))
        j = 0
        k = 0
        _g = 1
        _g1 = (highI + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((newNode.polygon[j] if j >= 0 and j < len(newNode.polygon) else None) != (pol[i] if i >= 0 and i < len(pol) else None)):
                j = (j + 1)
                _this = newNode.polygon
                _this.append((pol[i] if i >= 0 and i < len(pol) else None))
                if (((pol[i] if i >= 0 and i < len(pol) else None).y > (newNode.polygon[k] if k >= 0 and k < len(newNode.polygon) else None).y) or ((((pol[i] if i >= 0 and i < len(pol) else None).y == (newNode.polygon[k] if k >= 0 and k < len(newNode.polygon) else None).y) and (((pol[i] if i >= 0 and i < len(pol) else None).x < (newNode.polygon[k] if k >= 0 and k < len(newNode.polygon) else None).x))))):
                    k = j
        if ((endType == hxd_clipper_EndType.ClosedPol) and ((j < 2))):
            return
        self.m_polyNodes.addChild(newNode)
        if (endType != hxd_clipper_EndType.ClosedPol):
            return
        if (self.m_lowest.x < 0):
            self.m_lowest = h2d_col_IPoint((len(self.m_polyNodes.childs) - 1),k)
        else:
            ip = python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(self.m_polyNodes.childs, self.m_lowest.x).polygon, self.m_lowest.y)
            if (((newNode.polygon[k] if k >= 0 and k < len(newNode.polygon) else None).y > ip.y) or ((((newNode.polygon[k] if k >= 0 and k < len(newNode.polygon) else None).y == ip.y) and (((newNode.polygon[k] if k >= 0 and k < len(newNode.polygon) else None).x < ip.x))))):
                self.m_lowest = h2d_col_IPoint((len(self.m_polyNodes.childs) - 1),k)

    def addPolygons(self,pols,joinType,endType):
        _g_i = 0
        _g_a = pols
        _g_l = len(_g_a)
        while (_g_i < _g_l):
            p = _g_i
            _g_i = (_g_i + 1)
            p1 = (_g_a[p] if p >= 0 and p < len(_g_a) else None)
            self.addPolygon(p1,joinType,endType)

    def fixOrientations(self):
        if ((self.m_lowest.x >= 0) and (not ((hxd_clipper_Clipper.polArea(python_internal_ArrayImpl._get(self.m_polyNodes.childs, self.m_lowest.x).polygon) >= 0)))):
            _g = 0
            _g1 = self.m_polyNodes.childs
            while (_g < len(_g1)):
                node = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if ((node.endtype == hxd_clipper_EndType.ClosedPol) or (((node.endtype == hxd_clipper_EndType.ClosedLine) and ((hxd_clipper_Clipper.polArea(node.polygon) >= 0))))):
                    h2d_col__IPolygon_IPolygon_Impl_.reverse(node.polygon)
        else:
            _g = 0
            _g1 = self.m_polyNodes.childs
            while (_g < len(_g1)):
                node = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if ((node.endtype == hxd_clipper_EndType.ClosedLine) and (not ((hxd_clipper_Clipper.polArea(node.polygon) >= 0)))):
                    h2d_col__IPolygon_IPolygon_Impl_.reverse(node.polygon)

    def getUnitNormal(self,pt1,pt2):
        dx = (pt2.x - pt1.x)
        dy = (pt2.y - pt1.y)
        if ((dx == 0) and ((dy == 0))):
            return h2d_col_Point()
        dz = 0.
        if (dz is None):
            dz = 0.
        f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
        f1 = (1 / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        dx = (dx * f1)
        dy = (dy * f1)
        return h2d_col_Point(dy,-dx)

    def doOffset(self,delta):
        polygons = None
        this1 = ([] if ((polygons is None)) else polygons)
        self.m_destPolys = this1
        self.m_delta = delta
        if ((delta > -1e-20) and ((delta < 1E-20))):
            _g = 0
            _g1 = self.m_polyNodes.childs
            while (_g < len(_g1)):
                node = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (node.endtype == hxd_clipper_EndType.ClosedPol):
                    _this = self.m_destPolys
                    x = node.polygon
                    _this.append(x)
            return
        if (self.MiterLimit > 2):
            self.m_miterLim = (2 / ((self.MiterLimit * self.MiterLimit)))
        else:
            self.m_miterLim = 0.5
        y = None
        if (self.ArcTolerance <= 0.0):
            y = self.def_arc_tolerance
        elif (self.ArcTolerance > ((((-delta if ((delta < 0)) else delta)) * self.def_arc_tolerance))):
            y = (((-delta if ((delta < 0)) else delta)) * self.def_arc_tolerance)
        else:
            y = self.ArcTolerance
        x = (3.14159265358979323 / Math.acos((1 - ((y / ((-delta if ((delta < 0)) else delta)))))))
        steps = None
        try:
            steps = int(x)
        except BaseException as _g:
            None
            steps = None
        f = (self.two_pi / steps)
        self.m_sin = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        f = (self.two_pi / steps)
        self.m_cos = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        self.m_StepsPerRad = (steps / self.two_pi)
        if (delta < 0.):
            self.m_sin = -self.m_sin
        _g = 0
        _g1 = self.m_polyNodes.childs
        while (_g < len(_g1)):
            node = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.m_srcPoly = node.polygon
            _hx_len = len(self.m_srcPoly)
            if ((_hx_len == 0) or (((delta <= 0) and (((_hx_len < 3) or ((node.endtype != hxd_clipper_EndType.ClosedPol))))))):
                continue
            points = None
            this1 = ([] if ((points is None)) else points)
            self.m_destPoly = this1
            if (_hx_len == 1):
                if (node.jointype == hxd_clipper_JoinType.Round):
                    X = 1.
                    Y = 0.
                    _g2 = 1
                    _g3 = (steps + 1)
                    while (_g2 < _g3):
                        j = _g2
                        _g2 = (_g2 + 1)
                        _this = self.m_destPoly
                        x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((X * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((Y * delta))) + 0.5)))
                        _this.append(x)
                        X2 = X
                        X = ((X * self.m_cos) - ((self.m_sin * Y)))
                        Y = ((X2 * self.m_sin) + ((Y * self.m_cos)))
                else:
                    X1 = -1.
                    Y1 = -1.
                    _this1 = self.m_destPoly
                    x1 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((X1 * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((Y1 * delta))) + 0.5)))
                    _this1.append(x1)
                    if (X1 < 0):
                        X1 = 1
                    elif (Y1 < 0):
                        Y1 = 1
                    else:
                        X1 = -1
                    _this2 = self.m_destPoly
                    x2 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((X1 * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((Y1 * delta))) + 0.5)))
                    _this2.append(x2)
                    if (X1 < 0):
                        X1 = 1
                    elif (Y1 < 0):
                        Y1 = 1
                    else:
                        X1 = -1
                    _this3 = self.m_destPoly
                    x3 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((X1 * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((Y1 * delta))) + 0.5)))
                    _this3.append(x3)
                    if (X1 < 0):
                        X1 = 1
                    elif (Y1 < 0):
                        Y1 = 1
                    else:
                        X1 = -1
                    _this4 = self.m_destPoly
                    x4 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((X1 * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((Y1 * delta))) + 0.5)))
                    _this4.append(x4)
                    if (X1 < 0):
                        X1 = 1
                    elif (Y1 < 0):
                        Y1 = 1
                    else:
                        X1 = -1
                _this5 = self.m_destPolys
                x5 = self.m_destPoly
                _this5.append(x5)
                continue
            self.m_normals = []
            _g4 = 0
            _g5 = (_hx_len - 1)
            while (_g4 < _g5):
                j1 = _g4
                _g4 = (_g4 + 1)
                _this6 = self.m_normals
                x6 = self.getUnitNormal((self.m_srcPoly[j1] if j1 >= 0 and j1 < len(self.m_srcPoly) else None),python_internal_ArrayImpl._get(self.m_srcPoly, (j1 + 1)))
                _this6.append(x6)
            if ((node.endtype == hxd_clipper_EndType.ClosedLine) or ((node.endtype == hxd_clipper_EndType.ClosedPol))):
                _this7 = self.m_normals
                x7 = self.getUnitNormal(python_internal_ArrayImpl._get(self.m_srcPoly, (_hx_len - 1)),(self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None))
                _this7.append(x7)
            else:
                _this8 = self.m_normals
                x8 = python_internal_ArrayImpl._get(self.m_normals, (_hx_len - 2))
                _this8.append(x8)
            if (node.endtype == hxd_clipper_EndType.ClosedPol):
                k = (_hx_len - 1)
                _g6 = 0
                _g7 = _hx_len
                while (_g6 < _g7):
                    j2 = _g6
                    _g6 = (_g6 + 1)
                    k = self.offsetPoint(j2,k,node.jointype)
                _this9 = self.m_destPolys
                x9 = self.m_destPoly
                _this9.append(x9)
            elif (node.endtype == hxd_clipper_EndType.ClosedLine):
                k1 = (_hx_len - 1)
                _g8 = 0
                _g9 = _hx_len
                while (_g8 < _g9):
                    j3 = _g8
                    _g8 = (_g8 + 1)
                    k1 = self.offsetPoint(j3,k1,node.jointype)
                _this10 = self.m_destPolys
                x10 = self.m_destPoly
                _this10.append(x10)
                points1 = None
                this2 = ([] if ((points1 is None)) else points1)
                self.m_destPoly = this2
                n = python_internal_ArrayImpl._get(self.m_normals, (_hx_len - 1))
                j4 = (_hx_len - 1)
                while (j4 > 0):
                    python_internal_ArrayImpl._set(self.m_normals, j4, h2d_col_Point(-python_internal_ArrayImpl._get(self.m_normals, (j4 - 1)).x,-python_internal_ArrayImpl._get(self.m_normals, (j4 - 1)).y))
                    j4 = (j4 - 1)
                python_internal_ArrayImpl._set(self.m_normals, 0, h2d_col_Point(-n.x,-n.y))
                k1 = 0
                j5 = (_hx_len - 1)
                while (j5 > 0):
                    k1 = self.offsetPoint(j5,k1,node.jointype)
                    j5 = (j5 - 1)
                _this11 = self.m_destPolys
                x11 = self.m_destPoly
                _this11.append(x11)
            else:
                k2 = 0
                _g10 = 1
                _g11 = (_hx_len - 1)
                while (_g10 < _g11):
                    j6 = _g10
                    _g10 = (_g10 + 1)
                    k2 = self.offsetPoint(j6,k2,node.jointype)
                pt1 = None
                if (node.endtype == hxd_clipper_EndType.OpenButt):
                    j7 = (_hx_len - 1)
                    pt1 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j7] if j7 >= 0 and j7 < len(self.m_srcPoly) else None).x + (((self.m_normals[j7] if j7 >= 0 and j7 < len(self.m_normals) else None).x * delta))) + 0.5)),Math.floor((((self.m_srcPoly[j7] if j7 >= 0 and j7 < len(self.m_srcPoly) else None).y + (((self.m_normals[j7] if j7 >= 0 and j7 < len(self.m_normals) else None).y * delta))) + 0.5)))
                    _this12 = self.m_destPoly
                    _this12.append(pt1)
                    pt1 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j7] if j7 >= 0 and j7 < len(self.m_srcPoly) else None).x - (((self.m_normals[j7] if j7 >= 0 and j7 < len(self.m_normals) else None).x * delta))) + 0.5)),Math.floor((((self.m_srcPoly[j7] if j7 >= 0 and j7 < len(self.m_srcPoly) else None).y - (((self.m_normals[j7] if j7 >= 0 and j7 < len(self.m_normals) else None).y * delta))) + 0.5)))
                    _this13 = self.m_destPoly
                    _this13.append(pt1)
                else:
                    j8 = (_hx_len - 1)
                    k2 = (_hx_len - 2)
                    self.m_sinA = 0
                    python_internal_ArrayImpl._set(self.m_normals, j8, h2d_col_Point(-(self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).x,-(self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).y))
                    if (node.endtype == hxd_clipper_EndType.OpenSquare):
                        dx = Math.tan((Math.atan2(self.m_sinA,(((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).x * (self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).x) + (((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).y * (self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).y)))) * 0.25))
                        _this14 = self.m_destPoly
                        x12 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).x - (((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).y + (((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).x * dx))))))) + 0.5)))
                        _this14.append(x12)
                        _this15 = self.m_destPoly
                        x13 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).x + (((self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).y - (((self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).x * dx))))))) + 0.5)))
                        _this15.append(x13)
                    else:
                        a = Math.atan2(self.m_sinA,(((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).x * (self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).x) + (((self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).y * (self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).y))))
                        a1 = Math.floor(((self.m_StepsPerRad * ((-a if ((a < 0)) else a))) + 0.5))
                        steps1 = (1 if ((a1 < 1)) else a1)
                        X3 = (self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).x
                        Y2 = (self.m_normals[k2] if k2 >= 0 and k2 < len(self.m_normals) else None).y
                        X21 = None
                        _g12 = 0
                        _g13 = steps1
                        while (_g12 < _g13):
                            i = _g12
                            _g12 = (_g12 + 1)
                            _this16 = self.m_destPoly
                            x14 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).x + ((X3 * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).y + ((Y2 * self.m_delta))) + 0.5)))
                            _this16.append(x14)
                            X21 = X3
                            X3 = ((X3 * self.m_cos) - ((self.m_sin * Y2)))
                            Y2 = ((X21 * self.m_sin) + ((Y2 * self.m_cos)))
                        _this17 = self.m_destPoly
                        x15 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).x + (((self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j8] if j8 >= 0 and j8 < len(self.m_srcPoly) else None).y + (((self.m_normals[j8] if j8 >= 0 and j8 < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
                        _this17.append(x15)
                j9 = (_hx_len - 1)
                while (j9 > 0):
                    python_internal_ArrayImpl._set(self.m_normals, j9, h2d_col_Point(-python_internal_ArrayImpl._get(self.m_normals, (j9 - 1)).x,-python_internal_ArrayImpl._get(self.m_normals, (j9 - 1)).y))
                    j9 = (j9 - 1)
                python_internal_ArrayImpl._set(self.m_normals, 0, h2d_col_Point(-(self.m_normals[1] if 1 < len(self.m_normals) else None).x,-(self.m_normals[1] if 1 < len(self.m_normals) else None).y))
                k2 = (_hx_len - 1)
                j10 = (k2 - 1)
                while (j10 > 0):
                    k2 = self.offsetPoint(j10,k2,node.jointype)
                    j10 = (j10 - 1)
                if (node.endtype == hxd_clipper_EndType.OpenButt):
                    pt1 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x - (((self.m_normals[0] if 0 < len(self.m_normals) else None).x * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y - (((self.m_normals[0] if 0 < len(self.m_normals) else None).y * delta))) + 0.5)))
                    _this18 = self.m_destPoly
                    _this18.append(pt1)
                    pt1 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + (((self.m_normals[0] if 0 < len(self.m_normals) else None).x * delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + (((self.m_normals[0] if 0 < len(self.m_normals) else None).y * delta))) + 0.5)))
                    _this19 = self.m_destPoly
                    _this19.append(pt1)
                else:
                    k2 = 1
                    self.m_sinA = 0
                    if (node.endtype == hxd_clipper_EndType.OpenSquare):
                        dx1 = Math.tan((Math.atan2(self.m_sinA,(((self.m_normals[1] if 1 < len(self.m_normals) else None).x * (self.m_normals[0] if 0 < len(self.m_normals) else None).x) + (((self.m_normals[1] if 1 < len(self.m_normals) else None).y * (self.m_normals[0] if 0 < len(self.m_normals) else None).y)))) * 0.25))
                        _this20 = self.m_destPoly
                        x16 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[1] if 1 < len(self.m_normals) else None).x - (((self.m_normals[1] if 1 < len(self.m_normals) else None).y * dx1))))))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[1] if 1 < len(self.m_normals) else None).y + (((self.m_normals[1] if 1 < len(self.m_normals) else None).x * dx1))))))) + 0.5)))
                        _this20.append(x16)
                        _this21 = self.m_destPoly
                        x17 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[0] if 0 < len(self.m_normals) else None).x + (((self.m_normals[0] if 0 < len(self.m_normals) else None).y * dx1))))))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[0] if 0 < len(self.m_normals) else None).y - (((self.m_normals[0] if 0 < len(self.m_normals) else None).x * dx1))))))) + 0.5)))
                        _this21.append(x17)
                    else:
                        a2 = Math.atan2(self.m_sinA,(((self.m_normals[1] if 1 < len(self.m_normals) else None).x * (self.m_normals[0] if 0 < len(self.m_normals) else None).x) + (((self.m_normals[1] if 1 < len(self.m_normals) else None).y * (self.m_normals[0] if 0 < len(self.m_normals) else None).y))))
                        a3 = Math.floor(((self.m_StepsPerRad * ((-a2 if ((a2 < 0)) else a2))) + 0.5))
                        steps2 = (1 if ((a3 < 1)) else a3)
                        X4 = (self.m_normals[1] if 1 < len(self.m_normals) else None).x
                        Y3 = (self.m_normals[1] if 1 < len(self.m_normals) else None).y
                        X22 = None
                        _g14 = 0
                        _g15 = steps2
                        while (_g14 < _g15):
                            i1 = _g14
                            _g14 = (_g14 + 1)
                            _this22 = self.m_destPoly
                            x18 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + ((X4 * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + ((Y3 * self.m_delta))) + 0.5)))
                            _this22.append(x18)
                            X22 = X4
                            X4 = ((X4 * self.m_cos) - ((self.m_sin * Y3)))
                            Y3 = ((X22 * self.m_sin) + ((Y3 * self.m_cos)))
                        _this23 = self.m_destPoly
                        x19 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).x + (((self.m_normals[0] if 0 < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[0] if 0 < len(self.m_srcPoly) else None).y + (((self.m_normals[0] if 0 < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
                        _this23.append(x19)
                _this24 = self.m_destPolys
                x20 = self.m_destPoly
                _this24.append(x20)

    def execute(self,delta):
        self.fixOrientations()
        self.doOffset(delta)
        clpr = hxd_clipper_Clipper()
        clpr.resultKind = self.resultKind
        clpr.addPolygons(self.m_destPolys,hxd_clipper_PolyType.Subject)
        if (delta > 0):
            return clpr.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.Positive,hxd_clipper_PolyFillType.Positive)
        else:
            r = hxd_clipper__Clipper_ClipperBase.getBounds(self.m_destPolys)
            points = None
            this1 = ([] if ((points is None)) else points)
            outer = this1
            x = h2d_col_IPoint((r.left - 10),(r.bottom + 10))
            outer.append(x)
            x = h2d_col_IPoint((r.right + 10),(r.bottom + 10))
            outer.append(x)
            x = h2d_col_IPoint((r.right + 10),(r.top - 10))
            outer.append(x)
            x = h2d_col_IPoint((r.left - 10),(r.top - 10))
            outer.append(x)
            clpr.addPolygon(outer,hxd_clipper_PolyType.Subject)
            clpr.reverseSolution = True
            out = clpr.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.Negative,hxd_clipper_PolyFillType.Negative)
            if (len(out) > 0):
                if (len(out) != 0):
                    out.pop(0)
            return out

    def offsetPoint(self,j,k,jointype):
        self.m_sinA = (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y) - (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y)))
        f = (self.m_sinA * self.m_delta)
        if (((-f if ((f < 0)) else f)) < 1.0):
            cosA = (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x) + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y)))
            if (cosA > 0):
                _this = self.m_destPoly
                x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
                _this.append(x)
                return k
        elif (self.m_sinA > 1.0):
            self.m_sinA = 1.0
        elif (self.m_sinA < -1.0):
            self.m_sinA = -1.0
        if ((self.m_sinA * self.m_delta) < 0):
            p1 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
            p2 = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
            _this = self.m_destPoly
            _this.append(p1)
            dx = (p1.x - p2.x)
            dy = (p1.y - p2.y)
            if (((dx * dx) + ((dy * dy))) > 1):
                _this = self.m_destPoly
                x = (self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None)
                _this.append(x)
                _this = self.m_destPoly
                _this.append(p2)
        else:
            tmp = jointype.index
            if (tmp == 0):
                dx = Math.tan((Math.atan2(self.m_sinA,(((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x) + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y)))) * 0.25))
                _this = self.m_destPoly
                x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x - (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * dx))))))) + 0.5)))
                _this.append(x)
                _this = self.m_destPoly
                x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y - (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * dx))))))) + 0.5)))
                _this.append(x)
            elif (tmp == 1):
                a = Math.atan2(self.m_sinA,(((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x) + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y))))
                a1 = Math.floor(((self.m_StepsPerRad * ((-a if ((a < 0)) else a))) + 0.5))
                steps = (1 if ((a1 < 1)) else a1)
                X = (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x
                Y = (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y
                X2 = None
                _g = 0
                _g1 = steps
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    _this = self.m_destPoly
                    x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((X * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((Y * self.m_delta))) + 0.5)))
                    _this.append(x)
                    X2 = X
                    X = ((X * self.m_cos) - ((self.m_sin * Y)))
                    Y = ((X2 * self.m_sin) + ((Y * self.m_cos)))
                _this = self.m_destPoly
                x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
                _this.append(x)
            elif (tmp == 2):
                r = (1 + ((((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x) + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y)))))
                if (r >= self.m_miterLim):
                    q = (self.m_delta / r)
                    _this = self.m_destPoly
                    x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x + (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x)) * q))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y + (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y)) * q))) + 0.5)))
                    _this.append(x)
                else:
                    dx = Math.tan((Math.atan2(self.m_sinA,(((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x) + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y)))) * 0.25))
                    _this = self.m_destPoly
                    x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x - (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * dx))))))) + 0.5)))
                    _this.append(x)
                    _this = self.m_destPoly
                    x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y - (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * dx))))))) + 0.5)))
                    _this.append(x)
            else:
                pass
        return j

    def doSquare(self,j,k):
        dx = Math.tan((Math.atan2(self.m_sinA,(((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x) + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y)))) * 0.25))
        _this = self.m_destPoly
        x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x - (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * dx))))))) + 0.5)))
        _this.append(x)
        _this = self.m_destPoly
        x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((self.m_delta * (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * dx))))))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((self.m_delta * (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y - (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * dx))))))) + 0.5)))
        _this.append(x)

    def doMiter(self,j,k,r):
        q = (self.m_delta / r)
        _this = self.m_destPoly
        x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x + (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x)) * q))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y + (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y)) * q))) + 0.5)))
        _this.append(x)

    def doRound(self,j,k):
        a = Math.atan2(self.m_sinA,(((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x) + (((self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y * (self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y))))
        a1 = Math.floor(((self.m_StepsPerRad * ((-a if ((a < 0)) else a))) + 0.5))
        steps = (1 if ((a1 < 1)) else a1)
        X = (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).x
        Y = (self.m_normals[k] if k >= 0 and k < len(self.m_normals) else None).y
        X2 = None
        _g = 0
        _g1 = steps
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this = self.m_destPoly
            x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + ((X * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + ((Y * self.m_delta))) + 0.5)))
            _this.append(x)
            X2 = X
            X = ((X * self.m_cos) - ((self.m_sin * Y)))
            Y = ((X2 * self.m_sin) + ((Y * self.m_cos)))
        _this = self.m_destPoly
        x = h2d_col_IPoint(Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).x + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).x * self.m_delta))) + 0.5)),Math.floor((((self.m_srcPoly[j] if j >= 0 and j < len(self.m_srcPoly) else None).y + (((self.m_normals[j] if j >= 0 and j < len(self.m_normals) else None).y * self.m_delta))) + 0.5)))
        _this.append(x)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.m_destPolys = None
        _hx_o.m_srcPoly = None
        _hx_o.m_destPoly = None
        _hx_o.m_normals = None
        _hx_o.m_delta = None
        _hx_o.m_sinA = None
        _hx_o.m_sin = None
        _hx_o.m_cos = None
        _hx_o.m_miterLim = None
        _hx_o.m_StepsPerRad = None
        _hx_o.m_lowest = None
        _hx_o.m_polyNodes = None
        _hx_o.ArcTolerance = None
        _hx_o.MiterLimit = None
        _hx_o.resultKind = None
        _hx_o.def_arc_tolerance = None
        _hx_o.two_pi = None
hxd_clipper_ClipperOffset._hx_class = hxd_clipper_ClipperOffset
_hx_classes["hxd.clipper.ClipperOffset"] = hxd_clipper_ClipperOffset

class hxd_clipper_EndType(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.EndType"
    _hx_constructs = ["ClosedPol", "ClosedLine", "OpenButt", "OpenSquare", "OpenRound"]
hxd_clipper_EndType.ClosedPol = hxd_clipper_EndType("ClosedPol", 0, ())
hxd_clipper_EndType.ClosedLine = hxd_clipper_EndType("ClosedLine", 1, ())
hxd_clipper_EndType.OpenButt = hxd_clipper_EndType("OpenButt", 2, ())
hxd_clipper_EndType.OpenSquare = hxd_clipper_EndType("OpenSquare", 3, ())
hxd_clipper_EndType.OpenRound = hxd_clipper_EndType("OpenRound", 4, ())
hxd_clipper_EndType._hx_class = hxd_clipper_EndType
_hx_classes["hxd.clipper.EndType"] = hxd_clipper_EndType

class hxd_clipper_JoinType(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.JoinType"
    _hx_constructs = ["Square", "Round", "Miter"]
hxd_clipper_JoinType.Square = hxd_clipper_JoinType("Square", 0, ())
hxd_clipper_JoinType.Round = hxd_clipper_JoinType("Round", 1, ())
hxd_clipper_JoinType.Miter = hxd_clipper_JoinType("Miter", 2, ())
hxd_clipper_JoinType._hx_class = hxd_clipper_JoinType
_hx_classes["hxd.clipper.JoinType"] = hxd_clipper_JoinType

class hxd_clipper_PolyFillType(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.PolyFillType"
    _hx_constructs = ["EvenOdd", "NonZero", "Positive", "Negative"]
hxd_clipper_PolyFillType.EvenOdd = hxd_clipper_PolyFillType("EvenOdd", 0, ())
hxd_clipper_PolyFillType.NonZero = hxd_clipper_PolyFillType("NonZero", 1, ())
hxd_clipper_PolyFillType.Positive = hxd_clipper_PolyFillType("Positive", 2, ())
hxd_clipper_PolyFillType.Negative = hxd_clipper_PolyFillType("Negative", 3, ())
hxd_clipper_PolyFillType._hx_class = hxd_clipper_PolyFillType
_hx_classes["hxd.clipper.PolyFillType"] = hxd_clipper_PolyFillType

class hxd_clipper_PolyType(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.clipper.PolyType"
    _hx_constructs = ["Subject", "Clip"]
hxd_clipper_PolyType.Subject = hxd_clipper_PolyType("Subject", 0, ())
hxd_clipper_PolyType.Clip = hxd_clipper_PolyType("Clip", 1, ())
hxd_clipper_PolyType._hx_class = hxd_clipper_PolyType
_hx_classes["hxd.clipper.PolyType"] = hxd_clipper_PolyType


class hxd_clipper_Rect:
    _hx_class_name = "hxd.clipper.Rect"
    _hx_is_interface = "False"
    __slots__ = ("left", "top", "right", "bottom")
    _hx_fields = ["left", "top", "right", "bottom"]

    def __init__(self,l = None,t = None,r = None,b = None):
        if (l is None):
            l = 0
        if (t is None):
            t = 0
        if (r is None):
            r = 0
        if (b is None):
            b = 0
        self.left = l
        self.top = t
        self.right = r
        self.bottom = b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.left = None
        _hx_o.top = None
        _hx_o.right = None
        _hx_o.bottom = None
hxd_clipper_Rect._hx_class = hxd_clipper_Rect
_hx_classes["hxd.clipper.Rect"] = hxd_clipper_Rect


class hxd_earcut_EarNode:
    _hx_class_name = "hxd.earcut.EarNode"
    _hx_is_interface = "False"
    __slots__ = ("next", "prev", "nextZ", "prevZ", "allocNext", "x", "y", "i", "z", "steiner")
    _hx_fields = ["next", "prev", "nextZ", "prevZ", "allocNext", "x", "y", "i", "z", "steiner"]

    def __init__(self):
        self.steiner = None
        self.z = None
        self.i = None
        self.y = None
        self.x = None
        self.allocNext = None
        self.prevZ = None
        self.nextZ = None
        self.prev = None
        self.next = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.prev = None
        _hx_o.nextZ = None
        _hx_o.prevZ = None
        _hx_o.allocNext = None
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.i = None
        _hx_o.z = None
        _hx_o.steiner = None
hxd_earcut_EarNode._hx_class = hxd_earcut_EarNode
_hx_classes["hxd.earcut.EarNode"] = hxd_earcut_EarNode


class hxd_earcut_Earcut:
    _hx_class_name = "hxd.earcut.Earcut"
    _hx_is_interface = "False"
    __slots__ = ("triangles", "cache", "allocated", "minX", "minY", "size", "hasSize")
    _hx_fields = ["triangles", "cache", "allocated", "minX", "minY", "size", "hasSize"]
    _hx_methods = ["triangulate_h2d_col_Point", "eliminateHoles_triangulate_T", "setLinkedList_eliminateHoles_T", "setLinkedList_triangulate_T", "triangulateNode", "eliminateHole", "findHoleBridge", "getLeftmost", "compareX", "equals", "area", "intersects", "locallyInside", "filterPoints", "removeNode", "allocNode", "earcutLinked", "isEar", "isEarHashed", "cureLocalIntersections", "splitEarcut", "splitPolygon", "pointInTriangle", "isValidDiagonal", "middleInside", "intersectsPolygon", "zOrder", "indexCurve", "sortLinked"]

    def __init__(self):
        self.hasSize = None
        self.size = None
        self.minY = None
        self.minX = None
        self.allocated = None
        self.cache = None
        self.triangles = None

    def triangulate_h2d_col_Point(self,points,holes = None):
        hasHoles = ((holes is not None) and ((len(holes) > 0)))
        outerLen = ((holes[0] if 0 < len(holes) else None) if hasHoles else len(points))
        if (outerLen < 3):
            return []
        root = self.setLinkedList_triangulate_T(points,0,outerLen,True)
        if (holes is not None):
            root = self.eliminateHoles_triangulate_T(points,holes,root)
        return self.triangulateNode(root,(len(points) > 80))

    def eliminateHoles_triangulate_T(self,points,holes,root):
        queue = []
        _g = 0
        _g1 = len(holes)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            s = (holes[i] if i >= 0 and i < len(holes) else None)
            e = (len(points) if ((i == ((len(holes) - 1)))) else python_internal_ArrayImpl._get(holes, (i + 1)))
            node = self.setLinkedList_eliminateHoles_T(points,s,e,False)
            if (node == node.next):
                node.steiner = True
            x = self.getLeftmost(node)
            queue.append(x)
        queue.sort(key= python_lib_Functools.cmp_to_key(self.compareX))
        _g = 0
        while (_g < len(queue)):
            q = (queue[_g] if _g >= 0 and _g < len(queue) else None)
            _g = (_g + 1)
            self.eliminateHole(q,root)
            root = self.filterPoints(root,root.next)
        return root

    def setLinkedList_eliminateHoles_T(self,points,start,end,clockwise):
        sum = 0.
        j = (end - 1)
        _g = start
        _g1 = end
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            sum = (sum + (((((points[j] if j >= 0 and j < len(points) else None).x - (points[i] if i >= 0 and i < len(points) else None).x)) * (((points[i] if i >= 0 and i < len(points) else None).y + (points[j] if j >= 0 and j < len(points) else None).y)))))
            j = i
        last = None
        n = self.cache
        if (n is None):
            n = hxd_earcut_EarNode()
            n.allocNext = self.allocated
            self.allocated = n
        else:
            self.cache = n.next
        n.i = -1
        n.z = -1
        n.x = 0
        n.y = 0
        n.next = None
        n.prev = last
        n.steiner = False
        n.prevZ = None
        n.nextZ = None
        if (last is not None):
            last.next = n
        node = n
        first = node
        if (clockwise == ((sum > 0))):
            _g = start
            _g1 = end
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p = (points[i] if i >= 0 and i < len(points) else None)
                x = p.x
                y = p.y
                n = self.cache
                if (n is None):
                    n = hxd_earcut_EarNode()
                    n.allocNext = self.allocated
                    self.allocated = n
                else:
                    self.cache = n.next
                n.i = i
                n.z = -1
                n.x = x
                n.y = y
                n.next = None
                n.prev = node
                n.steiner = False
                n.prevZ = None
                n.nextZ = None
                if (node is not None):
                    node.next = n
                node = n
        else:
            i = (end - 1)
            while (i >= start):
                p = (points[i] if i >= 0 and i < len(points) else None)
                x = p.x
                y = p.y
                n = self.cache
                if (n is None):
                    n = hxd_earcut_EarNode()
                    n.allocNext = self.allocated
                    self.allocated = n
                else:
                    self.cache = n.next
                n.i = i
                n.z = -1
                n.x = x
                n.y = y
                n.next = None
                n.prev = node
                n.steiner = False
                n.prevZ = None
                n.nextZ = None
                if (node is not None):
                    node.next = n
                node = n
                i = (i - 1)
        node.next = first.next
        node.next.prev = node
        return node

    def setLinkedList_triangulate_T(self,points,start,end,clockwise):
        sum = 0.
        j = (end - 1)
        _g = start
        _g1 = end
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            sum = (sum + (((((points[j] if j >= 0 and j < len(points) else None).x - (points[i] if i >= 0 and i < len(points) else None).x)) * (((points[i] if i >= 0 and i < len(points) else None).y + (points[j] if j >= 0 and j < len(points) else None).y)))))
            j = i
        last = None
        n = self.cache
        if (n is None):
            n = hxd_earcut_EarNode()
            n.allocNext = self.allocated
            self.allocated = n
        else:
            self.cache = n.next
        n.i = -1
        n.z = -1
        n.x = 0
        n.y = 0
        n.next = None
        n.prev = last
        n.steiner = False
        n.prevZ = None
        n.nextZ = None
        if (last is not None):
            last.next = n
        node = n
        first = node
        if (clockwise == ((sum > 0))):
            _g = start
            _g1 = end
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p = (points[i] if i >= 0 and i < len(points) else None)
                x = p.x
                y = p.y
                n = self.cache
                if (n is None):
                    n = hxd_earcut_EarNode()
                    n.allocNext = self.allocated
                    self.allocated = n
                else:
                    self.cache = n.next
                n.i = i
                n.z = -1
                n.x = x
                n.y = y
                n.next = None
                n.prev = node
                n.steiner = False
                n.prevZ = None
                n.nextZ = None
                if (node is not None):
                    node.next = n
                node = n
        else:
            i = (end - 1)
            while (i >= start):
                p = (points[i] if i >= 0 and i < len(points) else None)
                x = p.x
                y = p.y
                n = self.cache
                if (n is None):
                    n = hxd_earcut_EarNode()
                    n.allocNext = self.allocated
                    self.allocated = n
                else:
                    self.cache = n.next
                n.i = i
                n.z = -1
                n.x = x
                n.y = y
                n.next = None
                n.prev = node
                n.steiner = False
                n.prevZ = None
                n.nextZ = None
                if (node is not None):
                    node.next = n
                node = n
                i = (i - 1)
        node.next = first.next
        node.next.prev = node
        return node

    def triangulateNode(self,root,useZOrder):
        self.triangles = []
        root = self.filterPoints(root)
        if (useZOrder and ((root is not None))):
            maxX = root.x
            self.minX = maxX
            maxY = root.y
            self.minY = maxY
            p = root.next
            while (p != root):
                x = p.x
                y = p.y
                if (x < self.minX):
                    self.minX = x
                if (y < self.minY):
                    self.minY = y
                if (x > maxX):
                    maxX = x
                if (y > maxY):
                    maxY = y
                p = p.next
            a = (maxX - self.minX)
            b = (maxY - self.minY)
            self.size = (b if ((a < b)) else a)
            self.hasSize = True
        else:
            self.hasSize = False
        self.earcutLinked(root)
        result = self.triangles
        self.triangles = None
        n = self.allocated
        if (self.cache is not None):
            while (n != self.cache):
                n = n.allocNext
            n = n.allocNext
        while (n is not None):
            n.next = self.cache
            self.cache = n
            n = n.allocNext
        return result

    def eliminateHole(self,hole,root):
        root = self.findHoleBridge(hole,root)
        if (root is not None):
            b = self.splitPolygon(root,hole)
            self.filterPoints(b,b.next)

    def findHoleBridge(self,hole,root):
        p = root
        hx = hole.x
        hy = hole.y
        qx = Math.NEGATIVE_INFINITY
        m = None
        while True:
            if ((hy <= p.y) and ((hy >= p.next.y))):
                x = (p.x + (((((hy - p.y)) * ((p.next.x - p.x))) / ((p.next.y - p.y)))))
                if ((x <= hx) and ((x > qx))):
                    qx = x
                    m = (p if ((p.x < p.next.x)) else p.next)
            p = p.next
            if (not ((p != root))):
                break
        if (m is None):
            return None
        stop = m
        tanMin = Math.POSITIVE_INFINITY
        tan = None
        p = m.next
        while (p != stop):
            tmp = None
            if ((hx >= p.x) and ((p.x >= m.x))):
                ax = (hx if ((hy < m.y)) else qx)
                bx = m.x
                by = m.y
                cx = (qx if ((hy < m.y)) else hx)
                px = p.x
                py = p.y
                tmp = (((((((cx - px)) * ((hy - py))) - ((((ax - px)) * ((hy - py))))) >= 0) and ((((((ax - px)) * ((by - py))) - ((((bx - px)) * ((hy - py))))) >= 0))) and ((((((bx - px)) * ((hy - py))) - ((((cx - px)) * ((by - py))))) >= 0)))
            else:
                tmp = False
            if tmp:
                f = (hy - p.y)
                tan = (((-f if ((f < 0)) else f)) / ((hx - p.x)))
                tmp1 = None
                if ((tan < tanMin) or (((tan == tanMin) and ((p.x > m.x))))):
                    p1 = p.prev
                    r = p.next
                    if (((((p.y - p1.y)) * ((r.x - p.x))) - ((((p.x - p1.x)) * ((r.y - p.y))))) < 0):
                        r1 = p.next
                        if (((((hole.y - p.y)) * ((r1.x - hole.x))) - ((((hole.x - p.x)) * ((r1.y - hole.y))))) >= 0):
                            q = p.prev
                            tmp1 = (((((q.y - p.y)) * ((hole.x - q.x))) - ((((q.x - p.x)) * ((hole.y - q.y))))) >= 0)
                        else:
                            tmp1 = False
                    else:
                        r2 = p.prev
                        if (not ((((((hole.y - p.y)) * ((r2.x - hole.x))) - ((((hole.x - p.x)) * ((r2.y - hole.y))))) < 0))):
                            q1 = p.next
                            tmp1 = (((((q1.y - p.y)) * ((hole.x - q1.x))) - ((((q1.x - p.x)) * ((hole.y - q1.y))))) < 0)
                        else:
                            tmp1 = True
                else:
                    tmp1 = False
                if tmp1:
                    m = p
                    tanMin = tan
            p = p.next
        return m

    def getLeftmost(self,node):
        p = node
        leftmost = node
        while True:
            if (p.x < leftmost.x):
                leftmost = p
            p = p.next
            if (not ((p != node))):
                break
        return leftmost

    def compareX(self,a,b):
        if ((a.x - b.x) > 0):
            return 1
        else:
            return -1

    def equals(self,p1,p2):
        if (p1.x == p2.x):
            return (p1.y == p2.y)
        else:
            return False

    def area(self,p,q,r):
        return ((((q.y - p.y)) * ((r.x - q.x))) - ((((q.x - p.x)) * ((r.y - q.y)))))

    def intersects(self,p1,q1,p2,q2):
        if ((((((q1.y - p1.y)) * ((p2.x - q1.x))) - ((((q1.x - p1.x)) * ((p2.y - q1.y))))) > 0) != ((((((q1.y - p1.y)) * ((q2.x - q1.x))) - ((((q1.x - p1.x)) * ((q2.y - q1.y))))) > 0))):
            return ((((((q2.y - p2.y)) * ((p1.x - q2.x))) - ((((q2.x - p2.x)) * ((p1.y - q2.y))))) > 0) != ((((((q2.y - p2.y)) * ((q1.x - q2.x))) - ((((q2.x - p2.x)) * ((q1.y - q2.y))))) > 0)))
        else:
            return False

    def locallyInside(self,a,b):
        p = a.prev
        r = a.next
        if (((((a.y - p.y)) * ((r.x - a.x))) - ((((a.x - p.x)) * ((r.y - a.y))))) < 0):
            r = a.next
            if (((((b.y - a.y)) * ((r.x - b.x))) - ((((b.x - a.x)) * ((r.y - b.y))))) >= 0):
                q = a.prev
                return (((((q.y - a.y)) * ((b.x - q.x))) - ((((q.x - a.x)) * ((b.y - q.y))))) >= 0)
            else:
                return False
        else:
            r = a.prev
            if (not ((((((b.y - a.y)) * ((r.x - b.x))) - ((((b.x - a.x)) * ((r.y - b.y))))) < 0))):
                q = a.next
                return (((((q.y - a.y)) * ((b.x - q.x))) - ((((q.x - a.x)) * ((b.y - q.y))))) < 0)
            else:
                return True

    def filterPoints(self,start,end = None):
        if (start is None):
            return start
        if (end is None):
            end = start
        p = start
        again = None
        while True:
            again = False
            tmp = None
            if (not p.steiner):
                p2 = p.next
                if (not (((p.x == p2.x) and ((p.y == p2.y))))):
                    p1 = p.prev
                    r = p.next
                    tmp = (((((p.y - p1.y)) * ((r.x - p.x))) - ((((p.x - p1.x)) * ((r.y - p.y))))) == 0)
                else:
                    tmp = True
            else:
                tmp = False
            if tmp:
                p.next.prev = p.prev
                p.prev.next = p.next
                if (p.prevZ is not None):
                    p.prevZ.nextZ = p.nextZ
                if (p.nextZ is not None):
                    p.nextZ.prevZ = p.prevZ
                end = p.prev
                p = end
                if (p == p.next):
                    return None
                again = True
            else:
                p = p.next
            if (not ((again or ((p != end))))):
                break
        return end

    def removeNode(self,p):
        p.next.prev = p.prev
        p.prev.next = p.next
        if (p.prevZ is not None):
            p.prevZ.nextZ = p.nextZ
        if (p.nextZ is not None):
            p.nextZ.prevZ = p.prevZ

    def allocNode(self,i,x,y,last = None):
        n = self.cache
        if (n is None):
            n = hxd_earcut_EarNode()
            n.allocNext = self.allocated
            self.allocated = n
        else:
            self.cache = n.next
        n.i = i
        n.z = -1
        n.x = x
        n.y = y
        n.next = None
        n.prev = last
        n.steiner = False
        n.prevZ = None
        n.nextZ = None
        if (last is not None):
            last.next = n
        return n

    def earcutLinked(self,ear,_hx_pass = None):
        if (_hx_pass is None):
            _hx_pass = 0
        if (ear is None):
            return
        if ((_hx_pass == 0) and self.hasSize):
            self.indexCurve(ear)
        stop = ear
        prev = None
        next = None
        while (ear.prev != ear.next):
            prev = ear.prev
            next = ear.next
            if (self.isEarHashed(ear) if (self.hasSize) else self.isEar(ear)):
                _this = self.triangles
                x = prev.i
                _this.append(x)
                _this1 = self.triangles
                x1 = ear.i
                _this1.append(x1)
                _this2 = self.triangles
                x2 = next.i
                _this2.append(x2)
                ear.next.prev = ear.prev
                ear.prev.next = ear.next
                if (ear.prevZ is not None):
                    ear.prevZ.nextZ = ear.nextZ
                if (ear.nextZ is not None):
                    ear.nextZ.prevZ = ear.prevZ
                ear = next.next
                stop = next.next
                continue
            ear = next
            if (ear == stop):
                pass1 = _hx_pass
                if (pass1 == 0):
                    self.earcutLinked(self.filterPoints(ear),1)
                elif (pass1 == 1):
                    ear = self.cureLocalIntersections(ear)
                    self.earcutLinked(ear,2)
                elif (pass1 == 2):
                    self.splitEarcut(ear)
                else:
                    pass
                break

    def isEar(self,ear):
        a = ear.prev
        b = ear
        c = ear.next
        if (((((b.y - a.y)) * ((c.x - b.x))) - ((((b.x - a.x)) * ((c.y - b.y))))) >= 0):
            return False
        p = ear.next.next
        while (p != ear.prev):
            tmp = None
            ax = a.x
            ay = a.y
            bx = b.x
            by = b.y
            cx = c.x
            cy = c.y
            px = p.x
            py = p.y
            if (((((((cx - px)) * ((ay - py))) - ((((ax - px)) * ((cy - py))))) >= 0) and ((((((ax - px)) * ((by - py))) - ((((bx - px)) * ((ay - py))))) >= 0))) and ((((((bx - px)) * ((cy - py))) - ((((cx - px)) * ((by - py))))) >= 0))):
                p1 = p.prev
                r = p.next
                tmp = (((((p.y - p1.y)) * ((r.x - p.x))) - ((((p.x - p1.x)) * ((r.y - p.y))))) >= 0)
            else:
                tmp = False
            if tmp:
                return False
            p = p.next
        return True

    def isEarHashed(self,ear):
        a = ear.prev
        b = ear
        c = ear.next
        if (((((b.y - a.y)) * ((c.x - b.x))) - ((((b.x - a.x)) * ((c.y - b.y))))) >= 0):
            return False
        minTX = ((a.x if ((a.x < c.x)) else c.x) if ((a.x < b.x)) else (b.x if ((b.x < c.x)) else c.x))
        minTY = ((a.y if ((a.y < c.y)) else c.y) if ((a.y < b.y)) else (b.y if ((b.y < c.y)) else c.y))
        maxTX = ((a.x if ((a.x > c.x)) else c.x) if ((a.x > b.x)) else (b.x if ((b.x > c.x)) else c.x))
        maxTY = ((a.y if ((a.y > c.y)) else c.y) if ((a.y > b.y)) else (b.y if ((b.y > c.y)) else c.y))
        x = ((32767 * ((minTX - self.minX))) / self.size)
        x1 = None
        try:
            x1 = int(x)
        except BaseException as _g:
            None
            x1 = None
        x = ((32767 * ((minTY - self.minY))) / self.size)
        y = None
        try:
            y = int(x)
        except BaseException as _g:
            None
            y = None
        x1 = (((x1 | ((x1 << 8)))) & 16711935)
        x1 = (((x1 | ((x1 << 4)))) & 252645135)
        x1 = (((x1 | ((x1 << 2)))) & 858993459)
        x1 = (((x1 | ((x1 << 1)))) & 1431655765)
        y = (((y | ((y << 8)))) & 16711935)
        y = (((y | ((y << 4)))) & 252645135)
        y = (((y | ((y << 2)))) & 858993459)
        y = (((y | ((y << 1)))) & 1431655765)
        minZ = (x1 | ((y << 1)))
        x = ((32767 * ((maxTX - self.minX))) / self.size)
        x1 = None
        try:
            x1 = int(x)
        except BaseException as _g:
            None
            x1 = None
        x = ((32767 * ((maxTY - self.minY))) / self.size)
        y = None
        try:
            y = int(x)
        except BaseException as _g:
            None
            y = None
        x1 = (((x1 | ((x1 << 8)))) & 16711935)
        x1 = (((x1 | ((x1 << 4)))) & 252645135)
        x1 = (((x1 | ((x1 << 2)))) & 858993459)
        x1 = (((x1 | ((x1 << 1)))) & 1431655765)
        y = (((y | ((y << 8)))) & 16711935)
        y = (((y | ((y << 4)))) & 252645135)
        y = (((y | ((y << 2)))) & 858993459)
        y = (((y | ((y << 1)))) & 1431655765)
        maxZ = (x1 | ((y << 1)))
        p = ear.nextZ
        while ((p is not None) and ((p.z <= maxZ))):
            tmp = None
            tmp1 = None
            if ((p != ear.prev) and ((p != ear.next))):
                ax = a.x
                ay = a.y
                bx = b.x
                by = b.y
                cx = c.x
                cy = c.y
                px = p.x
                py = p.y
                tmp1 = (((((((cx - px)) * ((ay - py))) - ((((ax - px)) * ((cy - py))))) >= 0) and ((((((ax - px)) * ((by - py))) - ((((bx - px)) * ((ay - py))))) >= 0))) and ((((((bx - px)) * ((cy - py))) - ((((cx - px)) * ((by - py))))) >= 0)))
            else:
                tmp1 = False
            if tmp1:
                p1 = p.prev
                r = p.next
                tmp = (((((p.y - p1.y)) * ((r.x - p.x))) - ((((p.x - p1.x)) * ((r.y - p.y))))) >= 0)
            else:
                tmp = False
            if tmp:
                return False
            p = p.nextZ
        p = ear.prevZ
        while ((p is not None) and ((p.z >= minZ))):
            tmp = None
            tmp1 = None
            if ((p != ear.prev) and ((p != ear.next))):
                ax = a.x
                ay = a.y
                bx = b.x
                by = b.y
                cx = c.x
                cy = c.y
                px = p.x
                py = p.y
                tmp1 = (((((((cx - px)) * ((ay - py))) - ((((ax - px)) * ((cy - py))))) >= 0) and ((((((ax - px)) * ((by - py))) - ((((bx - px)) * ((ay - py))))) >= 0))) and ((((((bx - px)) * ((cy - py))) - ((((cx - px)) * ((by - py))))) >= 0)))
            else:
                tmp1 = False
            if tmp1:
                p1 = p.prev
                r = p.next
                tmp = (((((p.y - p1.y)) * ((r.x - p.x))) - ((((p.x - p1.x)) * ((r.y - p.y))))) >= 0)
            else:
                tmp = False
            if tmp:
                return False
            p = p.prevZ
        return True

    def cureLocalIntersections(self,start):
        p = start
        while True:
            a = p.prev
            b = p.next.next
            tmp = None
            tmp1 = None
            p2 = p.next
            if (((((((p.y - a.y)) * ((p2.x - p.x))) - ((((p.x - a.x)) * ((p2.y - p.y))))) > 0) != ((((((p.y - a.y)) * ((b.x - p.x))) - ((((p.x - a.x)) * ((b.y - p.y))))) > 0))) and (((((((b.y - p2.y)) * ((a.x - b.x))) - ((((b.x - p2.x)) * ((a.y - b.y))))) > 0) != ((((((b.y - p2.y)) * ((p.x - b.x))) - ((((b.x - p2.x)) * ((p.y - b.y))))) > 0))))):
                p1 = a.prev
                r = a.next
                if (((((a.y - p1.y)) * ((r.x - a.x))) - ((((a.x - p1.x)) * ((r.y - a.y))))) < 0):
                    r1 = a.next
                    if (((((b.y - a.y)) * ((r1.x - b.x))) - ((((b.x - a.x)) * ((r1.y - b.y))))) >= 0):
                        q = a.prev
                        tmp1 = (((((q.y - a.y)) * ((b.x - q.x))) - ((((q.x - a.x)) * ((b.y - q.y))))) >= 0)
                    else:
                        tmp1 = False
                else:
                    r2 = a.prev
                    if (not ((((((b.y - a.y)) * ((r2.x - b.x))) - ((((b.x - a.x)) * ((r2.y - b.y))))) < 0))):
                        q1 = a.next
                        tmp1 = (((((q1.y - a.y)) * ((b.x - q1.x))) - ((((q1.x - a.x)) * ((b.y - q1.y))))) < 0)
                    else:
                        tmp1 = True
            else:
                tmp1 = False
            if tmp1:
                p3 = b.prev
                r3 = b.next
                if (((((b.y - p3.y)) * ((r3.x - b.x))) - ((((b.x - p3.x)) * ((r3.y - b.y))))) < 0):
                    r4 = b.next
                    if (((((a.y - b.y)) * ((r4.x - a.x))) - ((((a.x - b.x)) * ((r4.y - a.y))))) >= 0):
                        q2 = b.prev
                        tmp = (((((q2.y - b.y)) * ((a.x - q2.x))) - ((((q2.x - b.x)) * ((a.y - q2.y))))) >= 0)
                    else:
                        tmp = False
                else:
                    r5 = b.prev
                    if (not ((((((a.y - b.y)) * ((r5.x - a.x))) - ((((a.x - b.x)) * ((r5.y - a.y))))) < 0))):
                        q3 = b.next
                        tmp = (((((q3.y - b.y)) * ((a.x - q3.x))) - ((((q3.x - b.x)) * ((a.y - q3.y))))) < 0)
                    else:
                        tmp = True
            else:
                tmp = False
            if tmp:
                _this = self.triangles
                x = a.i
                _this.append(x)
                _this1 = self.triangles
                x1 = p.i
                _this1.append(x1)
                _this2 = self.triangles
                x2 = b.i
                _this2.append(x2)
                p.next.prev = p.prev
                p.prev.next = p.next
                if (p.prevZ is not None):
                    p.prevZ.nextZ = p.nextZ
                if (p.nextZ is not None):
                    p.nextZ.prevZ = p.prevZ
                p4 = p.next
                p4.next.prev = p4.prev
                p4.prev.next = p4.next
                if (p4.prevZ is not None):
                    p4.prevZ.nextZ = p4.nextZ
                if (p4.nextZ is not None):
                    p4.nextZ.prevZ = p4.prevZ
                start = b
                p = start
            p = p.next
            if (not ((p != start))):
                break
        return p

    def splitEarcut(self,start):
        a = start
        while True:
            b = a.next.next
            while (b != a.prev):
                if ((a.i != b.i) and self.isValidDiagonal(a,b)):
                    c = self.splitPolygon(a,b)
                    a = self.filterPoints(a,a.next)
                    c = self.filterPoints(c,c.next)
                    self.earcutLinked(a)
                    self.earcutLinked(c)
                    return
                b = b.next
            a = a.next
            if (not ((a != start))):
                break

    def splitPolygon(self,a,b):
        i = a.i
        x = a.x
        y = a.y
        last = None
        n = self.cache
        if (n is None):
            n = hxd_earcut_EarNode()
            n.allocNext = self.allocated
            self.allocated = n
        else:
            self.cache = n.next
        n.i = i
        n.z = -1
        n.x = x
        n.y = y
        n.next = None
        n.prev = last
        n.steiner = False
        n.prevZ = None
        n.nextZ = None
        if (last is not None):
            last.next = n
        a2 = n
        i = b.i
        x = b.x
        y = b.y
        last = None
        n = self.cache
        if (n is None):
            n = hxd_earcut_EarNode()
            n.allocNext = self.allocated
            self.allocated = n
        else:
            self.cache = n.next
        n.i = i
        n.z = -1
        n.x = x
        n.y = y
        n.next = None
        n.prev = last
        n.steiner = False
        n.prevZ = None
        n.nextZ = None
        if (last is not None):
            last.next = n
        b2 = n
        an = a.next
        bp = b.prev
        a.next = b
        b.prev = a
        a2.next = an
        an.prev = a2
        b2.next = a2
        a2.prev = b2
        bp.next = b2
        b2.prev = bp
        return b2

    def pointInTriangle(self,ax,ay,bx,by,cx,cy,px,py):
        if ((((((cx - px)) * ((ay - py))) - ((((ax - px)) * ((cy - py))))) >= 0) and ((((((ax - px)) * ((by - py))) - ((((bx - px)) * ((ay - py))))) >= 0))):
            return (((((bx - px)) * ((cy - py))) - ((((cx - px)) * ((by - py))))) >= 0)
        else:
            return False

    def isValidDiagonal(self,a,b):
        if (not (((a.x == b.x) and ((a.y == b.y))))):
            tmp = None
            tmp1 = None
            if (((a.next.i != b.i) and ((a.prev.i != b.i))) and (not self.intersectsPolygon(a,b))):
                p = a.prev
                r = a.next
                if (((((a.y - p.y)) * ((r.x - a.x))) - ((((a.x - p.x)) * ((r.y - a.y))))) < 0):
                    r = a.next
                    if (((((b.y - a.y)) * ((r.x - b.x))) - ((((b.x - a.x)) * ((r.y - b.y))))) >= 0):
                        q = a.prev
                        tmp1 = (((((q.y - a.y)) * ((b.x - q.x))) - ((((q.x - a.x)) * ((b.y - q.y))))) >= 0)
                    else:
                        tmp1 = False
                else:
                    r = a.prev
                    if (not ((((((b.y - a.y)) * ((r.x - b.x))) - ((((b.x - a.x)) * ((r.y - b.y))))) < 0))):
                        q = a.next
                        tmp1 = (((((q.y - a.y)) * ((b.x - q.x))) - ((((q.x - a.x)) * ((b.y - q.y))))) < 0)
                    else:
                        tmp1 = True
            else:
                tmp1 = False
            if tmp1:
                p = b.prev
                r = b.next
                if (((((b.y - p.y)) * ((r.x - b.x))) - ((((b.x - p.x)) * ((r.y - b.y))))) < 0):
                    r = b.next
                    if (((((a.y - b.y)) * ((r.x - a.x))) - ((((a.x - b.x)) * ((r.y - a.y))))) >= 0):
                        q = b.prev
                        tmp = (((((q.y - b.y)) * ((a.x - q.x))) - ((((q.x - b.x)) * ((a.y - q.y))))) >= 0)
                    else:
                        tmp = False
                else:
                    r = b.prev
                    if (not ((((((a.y - b.y)) * ((r.x - a.x))) - ((((a.x - b.x)) * ((r.y - a.y))))) < 0))):
                        q = b.next
                        tmp = (((((q.y - b.y)) * ((a.x - q.x))) - ((((q.x - b.x)) * ((a.y - q.y))))) < 0)
                    else:
                        tmp = True
            else:
                tmp = False
            if tmp:
                return self.middleInside(a,b)
            else:
                return False
        else:
            return True

    def middleInside(self,a,b):
        p = a
        inside = False
        px = (((a.x + b.x)) / 2)
        py = (((a.y + b.y)) / 2)
        while True:
            if (((p.y > py) != ((p.next.y > py))) and ((px < ((((((p.next.x - p.x)) * ((py - p.y))) / ((p.next.y - p.y))) + p.x))))):
                inside = (not inside)
            p = p.next
            if (not ((p != a))):
                break
        return inside

    def intersectsPolygon(self,a,b):
        p = a
        while True:
            tmp = None
            if ((((p.i != a.i) and ((p.next.i != a.i))) and ((p.i != b.i))) and ((p.next.i != b.i))):
                q1 = p.next
                tmp = (((((((q1.y - p.y)) * ((a.x - q1.x))) - ((((q1.x - p.x)) * ((a.y - q1.y))))) > 0) != ((((((q1.y - p.y)) * ((b.x - q1.x))) - ((((q1.x - p.x)) * ((b.y - q1.y))))) > 0))) and (((((((b.y - a.y)) * ((p.x - b.x))) - ((((b.x - a.x)) * ((p.y - b.y))))) > 0) != ((((((b.y - a.y)) * ((q1.x - b.x))) - ((((b.x - a.x)) * ((q1.y - b.y))))) > 0)))))
            else:
                tmp = False
            if tmp:
                return True
            p = p.next
            if (not ((p != a))):
                break
        return False

    def zOrder(self,px,py):
        x = ((32767 * ((px - self.minX))) / self.size)
        x1 = None
        try:
            x1 = int(x)
        except BaseException as _g:
            None
            x1 = None
        x = ((32767 * ((py - self.minY))) / self.size)
        y = None
        try:
            y = int(x)
        except BaseException as _g:
            None
            y = None
        x1 = (((x1 | ((x1 << 8)))) & 16711935)
        x1 = (((x1 | ((x1 << 4)))) & 252645135)
        x1 = (((x1 | ((x1 << 2)))) & 858993459)
        x1 = (((x1 | ((x1 << 1)))) & 1431655765)
        y = (((y | ((y << 8)))) & 16711935)
        y = (((y | ((y << 4)))) & 252645135)
        y = (((y | ((y << 2)))) & 858993459)
        y = (((y | ((y << 1)))) & 1431655765)
        return (x1 | ((y << 1)))

    def indexCurve(self,start):
        p = start
        while True:
            if (p.z < 0):
                py = p.y
                x = ((32767 * ((p.x - self.minX))) / self.size)
                x1 = None
                try:
                    x1 = int(x)
                except BaseException as _g:
                    None
                    x1 = None
                x2 = ((32767 * ((py - self.minY))) / self.size)
                y = None
                try:
                    y = int(x2)
                except BaseException as _g1:
                    None
                    y = None
                x1 = (((x1 | ((x1 << 8)))) & 16711935)
                x1 = (((x1 | ((x1 << 4)))) & 252645135)
                x1 = (((x1 | ((x1 << 2)))) & 858993459)
                x1 = (((x1 | ((x1 << 1)))) & 1431655765)
                y = (((y | ((y << 8)))) & 16711935)
                y = (((y | ((y << 4)))) & 252645135)
                y = (((y | ((y << 2)))) & 858993459)
                y = (((y | ((y << 1)))) & 1431655765)
                p.z = (x1 | ((y << 1)))
            p.prevZ = p.prev
            p.nextZ = p.next
            p = p.next
            if (not ((p != start))):
                break
        p.prevZ.nextZ = None
        p.prevZ = None
        self.sortLinked(p)

    def sortLinked(self,_hx_list):
        p = None
        q = None
        e = None
        tail = None
        numMerges = None
        pSize = None
        qSize = None
        inSize = 1
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            numMerges = 0
            while (p is not None):
                numMerges = (numMerges + 1)
                q = p
                pSize = 0
                _g = 0
                _g1 = inSize
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    pSize = (pSize + 1)
                    q = q.nextZ
                    if (q is None):
                        break
                qSize = inSize
                while ((pSize > 0) or (((qSize > 0) and ((q is not None))))):
                    if (pSize == 0):
                        e = q
                        q = q.nextZ
                        qSize = (qSize - 1)
                    elif ((qSize == 0) or ((q is None))):
                        e = p
                        p = p.nextZ
                        pSize = (pSize - 1)
                    elif (p.z <= q.z):
                        e = p
                        p = p.nextZ
                        pSize = (pSize - 1)
                    else:
                        e = q
                        q = q.nextZ
                        qSize = (qSize - 1)
                    if (tail is not None):
                        tail.nextZ = e
                    else:
                        _hx_list = e
                    e.prevZ = tail
                    tail = e
                p = q
            tail.nextZ = None
            inSize = (inSize * 2)
            if (not ((numMerges > 1))):
                break
        return _hx_list

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.triangles = None
        _hx_o.cache = None
        _hx_o.allocated = None
        _hx_o.minX = None
        _hx_o.minY = None
        _hx_o.size = None
        _hx_o.hasSize = None
hxd_earcut_Earcut._hx_class = hxd_earcut_Earcut
_hx_classes["hxd.earcut.Earcut"] = hxd_earcut_Earcut


class hxd_fmt_bfnt_FontParser:
    _hx_class_name = "hxd.fmt.bfnt.FontParser"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["parse"]

    @staticmethod
    def parse(_hx_bytes,path,resolveTile):
        tile = None
        font = h2d_Font(None,0)
        glyphs = font.glyphs
        font.baseLine = 0
        v = (((_hx_bytes.b[0] | ((_hx_bytes.b[1] << 8))) | ((_hx_bytes.b[2] << 16))) | ((_hx_bytes.b[3] << 24)))
        _g = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _g1 = _g
        if (_g1 == 54938946):
            bytes1 = haxe_io_BytesInput(_hx_bytes)
            bytes1.set_position((bytes1.pos + 4))
            pageCount = 0
            while (bytes1.pos < bytes1.totlen):
                id = bytes1.readByte()
                length = bytes1.readInt32()
                pos = bytes1.pos
                id1 = id
                if (id1 == 1):
                    def _hx_local_0():
                        font.initSize = bytes1.readInt16()
                        return font.initSize
                    font.size = _hx_local_0()
                    bytes1.set_position((bytes1.pos + 12))
                    font.name = bytes1.readUntil(0)
                elif (id1 == 2):
                    font.lineHeight = bytes1.readUInt16()
                    font.baseLine = bytes1.readUInt16()
                    bytes1.set_position((bytes1.pos + 4))
                    pageCount = bytes1.readUInt16()
                    if (pageCount != 1):
                        haxe_Log.trace("Warning: BMF format only supports one page at the moment.",_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 224, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                elif (id1 == 3):
                    name = bytes1.readUntil(0)
                    try:
                        font.tilePath = name
                        tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path), name]))
                    except BaseException as _g1:
                        None
                        haxe_Log.trace((("Warning: Could not find referenced font texture at \"" + ("null" if name is None else name)) + "\", trying to resolve same name as fnt!"),_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 30, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                        font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                        tile = resolveTile(haxe_io_Path.withExtension(path,"png"))
                elif (id1 == 4):
                    count = None
                    try:
                        count = int((length / 20))
                    except BaseException as _g2:
                        None
                        count = None
                    count1 = count
                    while (count1 > 0):
                        cid = bytes1.readInt32()
                        t = tile.sub(bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readInt16(),bytes1.readInt16())
                        fc = h2d_FontChar(t,bytes1.readInt16())
                        glyphs.set(cid,fc)
                        bytes1.set_position((bytes1.pos + 2))
                        count1 = (count1 - 1)
                elif (id1 == 5):
                    count2 = None
                    try:
                        count2 = int((length / 10))
                    except BaseException as _g3:
                        None
                        count2 = None
                    count3 = count2
                    while (count3 > 0):
                        first = bytes1.readInt32()
                        key = bytes1.readInt32()
                        fc1 = glyphs.h.get(key,None)
                        if (fc1 is not None):
                            fc1.addKerning(first,bytes1.readInt16())
                        else:
                            bytes1.set_position((bytes1.pos + 2))
                        count3 = (count3 - 1)
                else:
                    pass
                bytes1.set_position((pos + length))
        elif (_g1 == 1414415938):
            def _hx_local_4():
                def _hx_local_3(tp):
                    nonlocal tile
                    nonlocal tile
                    try:
                        font.tilePath = tp
                        tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path), tp]))
                    except BaseException as _g:
                        None
                        haxe_Log.trace((("Warning: Could not find referenced font texture at \"" + ("null" if tp is None else tp)) + "\", trying to resolve same name as fnt!"),_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 30, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                        font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                        tile = resolveTile(haxe_io_Path.withExtension(path,"png"))
                    return tile
                return hxd_fmt_bfnt_Reader(haxe_io_BytesInput(_hx_bytes)).read(_hx_local_3)
            return _hx_local_4()
        elif ((_g1 == 1852794428) or ((_g1 == 1836597052))):
            xml = Xml.parse(_hx_bytes.toString())
            x = xml.firstElement()
            if ((x.nodeType != Xml.Document) and ((x.nodeType != Xml.Element))):
                raise haxe_Exception.thrown(("Invalid nodeType " + HxOverrides.stringOrNull((("null" if ((x.nodeType is None)) else _Xml_XmlType_Impl_.toString(x.nodeType))))))
            this1 = x
            xml = this1
            if haxe_xml__Access_HasNodeAccess_Impl_.resolve(xml,"info"):
                tmp = haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"info")
                font.name = haxe_xml__Access_AttribAccess_Impl_.resolve(tmp,"face")
                tmp = haxe_xml__Access_AttribAccess_Impl_.resolve(haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"info"),"size")
                def _hx_local_5():
                    font.initSize = Std.parseInt(tmp)
                    return font.initSize
                font.size = _hx_local_5()
                tmp = haxe_xml__Access_AttribAccess_Impl_.resolve(haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"common"),"lineHeight")
                font.lineHeight = Std.parseInt(tmp)
                tmp = haxe_xml__Access_AttribAccess_Impl_.resolve(haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"common"),"base")
                font.baseLine = Std.parseInt(tmp)
                p = haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"pages").elements()
                while p.hasNext():
                    p1 = p.next()
                    if (haxe_xml__Access_AttribAccess_Impl_.resolve(p1,"id") == "0"):
                        tilePath = haxe_xml__Access_AttribAccess_Impl_.resolve(p1,"file")
                        try:
                            font.tilePath = tilePath
                            tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path), tilePath]))
                        except BaseException as _g1:
                            None
                            haxe_Log.trace((("Warning: Could not find referenced font texture at \"" + ("null" if tilePath is None else tilePath)) + "\", trying to resolve same name as fnt!"),_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 30, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                            font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                            tile = resolveTile(haxe_io_Path.withExtension(path,"png"))
                    else:
                        haxe_Log.trace("Warning: BMF format only supports one page at the moment.",_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 66, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                chars = haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"chars").elements()
                c = chars
                while c.hasNext():
                    c1 = c.next()
                    t = tile.sub(Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"x")),Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"y")),Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"width")),Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"height")),Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"xoffset")),Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"yoffset")))
                    fc = h2d_FontChar(t,Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"xadvance")))
                    kerns = haxe_xml__Access_NodeAccess_Impl_.resolve(xml,"kernings").elements()
                    k = kerns
                    while k.hasNext():
                        k1 = k.next()
                        if (haxe_xml__Access_AttribAccess_Impl_.resolve(k1,"second") == haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"id")):
                            fc.addKerning(Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(k1,"first")),Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(k1,"amount")))
                    glyphs.set(Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"id")),fc)
            else:
                font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                tile = resolveTile(haxe_io_Path.withExtension(path,"png"))
                font.name = haxe_xml__Access_AttribAccess_Impl_.resolve(xml,"family")
                tmp = haxe_xml__Access_AttribAccess_Impl_.resolve(xml,"size")
                def _hx_local_6():
                    font.initSize = Std.parseInt(tmp)
                    return font.initSize
                font.size = _hx_local_6()
                tmp = haxe_xml__Access_AttribAccess_Impl_.resolve(xml,"height")
                font.lineHeight = Std.parseInt(tmp)
                kernings = []
                c = xml.elements()
                while c.hasNext():
                    c1 = c.next()
                    _this = haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"rect")
                    r = _this.split(" ")
                    _this1 = haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"offset")
                    o = _this1.split(" ")
                    t = tile.sub(Std.parseInt((r[0] if 0 < len(r) else None)),Std.parseInt((r[1] if 1 < len(r) else None)),Std.parseInt((r[2] if 2 < len(r) else None)),Std.parseInt((r[3] if 3 < len(r) else None)),Std.parseInt((o[0] if 0 < len(o) else None)),Std.parseInt((o[1] if 1 < len(o) else None)))
                    fc = h2d_FontChar(t,Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"width")))
                    code = haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"code")
                    code1 = (Std.parseInt(HxString.substr(code,2,(len(code) - 3))) if (code.startswith("&#")) else HxString.charCodeAt(code,0))
                    k = c1.elements()
                    while k.hasNext():
                        k1 = k.next()
                        code2 = haxe_xml__Access_AttribAccess_Impl_.resolve(k1,"id")
                        next = (Std.parseInt(HxString.substr(code2,2,(len(code2) - 3))) if (code2.startswith("&#")) else HxString.charCodeAt(code2,0))
                        adv = Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(k1,"advance"))
                        if (next in glyphs.h):
                            glyphs.h.get(next,None).addKerning(code1,adv)
                        else:
                            kernings.append(_hx_AnonObject({'prev': code1, 'next': next, 'adv': adv}))
                    glyphs.set(code1,fc)
                _g1 = 0
                while (_g1 < len(kernings)):
                    k = (kernings[_g1] if _g1 >= 0 and _g1 < len(kernings) else None)
                    _g1 = (_g1 + 1)
                    g = glyphs.h.get(k.next,None)
                    if (g is None):
                        continue
                    g.addKerning(k.prev,k.adv)
        elif (_g1 == 1868983913):
            _this = _hx_bytes.toString()
            lines = _this.split("\n")
            reg = EReg(" *?([0-9a-zA-Z]+)=(\"[^\"]+\"|.+?)(?:[ \r]|$)","")
            idx = None
            pageCount = 0
            _g1 = 0
            while (_g1 < len(lines)):
                line = (lines[_g1] if _g1 >= 0 and _g1 < len(lines) else None)
                _g1 = (_g1 + 1)
                startIndex = None
                idx = (line.find(" ") if ((startIndex is None)) else HxString.indexOfImpl(line," ",startIndex))
                _g2 = HxString.substr(line,0,idx)
                _hx_local_9 = len(_g2)
                if (_hx_local_9 == 4):
                    if (_g2 == "char"):
                        id = 0
                        x = 0
                        y = 0
                        width = 0
                        height = 0
                        xoffset = 0
                        yoffset = 0
                        xadvance = 0
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            _g3 = reg.matchObj.group(1)
                            _hx_local_10 = len(_g3)
                            if (_hx_local_10 == 1):
                                if (_g3 == "x"):
                                    v3 = reg.matchObj.group(2)
                                    x = Std.parseInt((HxString.substring(v3,1,(len(v3) - 1)) if ((HxString.charCodeAt(v3,0) == 34)) else v3))
                                elif (_g3 == "y"):
                                    v6 = reg.matchObj.group(2)
                                    y = Std.parseInt((HxString.substring(v6,1,(len(v6) - 1)) if ((HxString.charCodeAt(v6,0) == 34)) else v6))
                            elif (_hx_local_10 == 5):
                                if (_g3 == "width"):
                                    v2 = reg.matchObj.group(2)
                                    width = Std.parseInt((HxString.substring(v2,1,(len(v2) - 1)) if ((HxString.charCodeAt(v2,0) == 34)) else v2))
                            elif (_hx_local_10 == 7):
                                if (_g3 == "xoffset"):
                                    v5 = reg.matchObj.group(2)
                                    xoffset = Std.parseInt((HxString.substring(v5,1,(len(v5) - 1)) if ((HxString.charCodeAt(v5,0) == 34)) else v5))
                                elif (_g3 == "yoffset"):
                                    v7 = reg.matchObj.group(2)
                                    yoffset = Std.parseInt((HxString.substring(v7,1,(len(v7) - 1)) if ((HxString.charCodeAt(v7,0) == 34)) else v7))
                            elif (_hx_local_10 == 8):
                                if (_g3 == "xadvance"):
                                    v4 = reg.matchObj.group(2)
                                    xadvance = Std.parseInt((HxString.substring(v4,1,(len(v4) - 1)) if ((HxString.charCodeAt(v4,0) == 34)) else v4))
                            elif (_hx_local_10 == 6):
                                if (_g3 == "height"):
                                    v = reg.matchObj.group(2)
                                    height = Std.parseInt((HxString.substring(v,1,(len(v) - 1)) if ((HxString.charCodeAt(v,0) == 34)) else v))
                            elif (_hx_local_10 == 2):
                                if (_g3 == "id"):
                                    v1 = reg.matchObj.group(2)
                                    id = Std.parseInt((HxString.substring(v1,1,(len(v1) - 1)) if ((HxString.charCodeAt(v1,0) == 34)) else v1))
                            else:
                                pass
                            pos_pos = reg.matchObj.start()
                            pos_len = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos + pos_len)
                        t = tile.sub(x,y,width,height,xoffset,yoffset)
                        fc = h2d_FontChar(t,xadvance)
                        glyphs.set(id,fc)
                    elif (_g2 == "info"):
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            _g5 = reg.matchObj.group(1)
                            if (_g5 == "face"):
                                v11 = reg.matchObj.group(2)
                                tmp2 = (HxString.substring(v11,1,(len(v11) - 1)) if ((HxString.charCodeAt(v11,0) == 34)) else v11)
                                font.name = tmp2
                            elif (_g5 == "size"):
                                v12 = reg.matchObj.group(2)
                                tmp3 = (HxString.substring(v12,1,(len(v12) - 1)) if ((HxString.charCodeAt(v12,0) == 34)) else v12)
                                def _hx_local_11():
                                    font.initSize = Std.parseInt(tmp3)
                                    return font.initSize
                                font.size = _hx_local_11()
                            else:
                                pass
                            pos_pos2 = reg.matchObj.start()
                            pos_len2 = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos2 + pos_len2)
                    elif (_g2 == "page"):
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            if (reg.matchObj.group(1) == "file"):
                                v16 = reg.matchObj.group(2)
                                tilePath = (HxString.substring(v16,1,(len(v16) - 1)) if ((HxString.charCodeAt(v16,0) == 34)) else v16)
                                try:
                                    font.tilePath = tilePath
                                    tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path), tilePath]))
                                except BaseException as _g7:
                                    None
                                    haxe_Log.trace((("Warning: Could not find referenced font texture at \"" + ("null" if tilePath is None else tilePath)) + "\", trying to resolve same name as fnt!"),_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 30, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                                    font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                                    tile = resolveTile(haxe_io_Path.withExtension(path,"png"))
                            pos_pos4 = reg.matchObj.start()
                            pos_len4 = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos4 + pos_len4)
                elif (_hx_local_9 == 7):
                    if (_g2 == "kerning"):
                        first = 0
                        second = 0
                        advance = 0
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            _g6 = reg.matchObj.group(1)
                            _hx_local_12 = len(_g6)
                            if (_hx_local_12 == 5):
                                if (_g6 == "first"):
                                    v14 = reg.matchObj.group(2)
                                    first = Std.parseInt((HxString.substring(v14,1,(len(v14) - 1)) if ((HxString.charCodeAt(v14,0) == 34)) else v14))
                            elif (_hx_local_12 == 6):
                                if (_g6 == "amount"):
                                    v13 = reg.matchObj.group(2)
                                    advance = Std.parseInt((HxString.substring(v13,1,(len(v13) - 1)) if ((HxString.charCodeAt(v13,0) == 34)) else v13))
                                elif (_g6 == "second"):
                                    v15 = reg.matchObj.group(2)
                                    second = Std.parseInt((HxString.substring(v15,1,(len(v15) - 1)) if ((HxString.charCodeAt(v15,0) == 34)) else v15))
                            else:
                                pass
                            pos_pos3 = reg.matchObj.start()
                            pos_len3 = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos3 + pos_len3)
                        fc1 = glyphs.h.get(second,None)
                        if (fc1 is not None):
                            fc1.addKerning(first,advance)
                elif (_hx_local_9 == 6):
                    if (_g2 == "common"):
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            _g4 = reg.matchObj.group(1)
                            _hx_local_13 = len(_g4)
                            if (_hx_local_13 == 10):
                                if (_g4 == "lineHeight"):
                                    v9 = reg.matchObj.group(2)
                                    tmp1 = (HxString.substring(v9,1,(len(v9) - 1)) if ((HxString.charCodeAt(v9,0) == 34)) else v9)
                                    font.lineHeight = Std.parseInt(tmp1)
                            elif (_hx_local_13 == 4):
                                if (_g4 == "base"):
                                    v8 = reg.matchObj.group(2)
                                    tmp = (HxString.substring(v8,1,(len(v8) - 1)) if ((HxString.charCodeAt(v8,0) == 34)) else v8)
                                    font.baseLine = Std.parseInt(tmp)
                            elif (_hx_local_13 == 5):
                                if (_g4 == "pages"):
                                    v10 = reg.matchObj.group(2)
                                    pageCount = Std.parseInt((HxString.substring(v10,1,(len(v10) - 1)) if ((HxString.charCodeAt(v10,0) == 34)) else v10))
                                    if (pageCount != 1):
                                        haxe_Log.trace("Warning: BMF format only supports one page at the moment.",_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 157, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                            else:
                                pass
                            pos_pos1 = reg.matchObj.start()
                            pos_len1 = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos1 + pos_len1)
                else:
                    pass
        else:
            sign = _g
            raise haxe_Exception.thrown(("Unknown font signature " + HxOverrides.stringOrNull(StringTools.hex(sign,8))))
        if (glyphs.h.get(32,None) is None):
            glyphs.set(32,h2d_FontChar(tile.sub(0,0,0,0),(font.size >> 1)))
        font.tile = tile
        if (font.baseLine == 0):
            padding = 0
            space = glyphs.h.get(32,None)
            if (space is not None):
                padding = (space.t.height * .5)
            a = glyphs.h.get(65,None)
            if (a is None):
                a = glyphs.h.get(97,None)
            if (a is None):
                a = glyphs.h.get(48,None)
            if (a is None):
                font.baseLine = ((font.lineHeight - 2) - padding)
            else:
                font.baseLine = ((a.t.dy + a.t.height) - padding)
        fallback = glyphs.h.get(65533,None)
        if (fallback is None):
            fallback = glyphs.h.get(9633,None)
        if (fallback is None):
            fallback = glyphs.h.get(63,None)
        if (fallback is not None):
            font.defaultChar = fallback
        return font
hxd_fmt_bfnt_FontParser._hx_class = hxd_fmt_bfnt_FontParser
_hx_classes["hxd.fmt.bfnt.FontParser"] = hxd_fmt_bfnt_FontParser


class hxd_fmt_bfnt_Reader:
    _hx_class_name = "hxd.fmt.bfnt.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i",)
    _hx_fields = ["i"]
    _hx_methods = ["read"]
    _hx_statics = ["parse"]

    def __init__(self,i):
        self.i = i

    def read(self,resolveTile):
        if ((self.i.readString(4) != "BFNT") or ((self.i.readByte() != 0))):
            raise haxe_Exception.thrown("Not a BFNT file!")
        font = None
        _g = self.i.readByte()
        if (_g == 1):
            font = h2d_Font(self.i.readString(self.i.readUInt16()),self.i.readInt16())
            font.tilePath = self.i.readString(self.i.readUInt16())
            def _hx_local_0():
                font.tile = resolveTile(font.tilePath)
                return font.tile
            tile = _hx_local_0()
            font.lineHeight = self.i.readInt16()
            font.baseLine = self.i.readInt16()
            defaultChar = self.i.readInt32()
            id = None
            while True:
                id = self.i.readInt32()
                if (not ((id != 0))):
                    break
                t = tile.sub(self.i.readUInt16(),self.i.readUInt16(),self.i.readUInt16(),self.i.readUInt16(),self.i.readInt16(),self.i.readInt16())
                glyph = h2d_FontChar(t,self.i.readInt16())
                font.glyphs.set(id,glyph)
                if (id == defaultChar):
                    font.defaultChar = glyph
                prevChar = None
                while True:
                    prevChar = self.i.readInt32()
                    if (not ((prevChar != 0))):
                        break
                    glyph.addKerning(prevChar,self.i.readInt16())
        else:
            ver = _g
            raise haxe_Exception.thrown(("Unknown BFNT version: " + Std.string(ver)))
        return font

    @staticmethod
    def parse(_hx_bytes,resolveTile):
        return hxd_fmt_bfnt_Reader(haxe_io_BytesInput(_hx_bytes)).read(resolveTile)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
hxd_fmt_bfnt_Reader._hx_class = hxd_fmt_bfnt_Reader
_hx_classes["hxd.fmt.bfnt.Reader"] = hxd_fmt_bfnt_Reader


class hxd_fmt_bfnt_Writer:
    _hx_class_name = "hxd.fmt.bfnt.Writer"
    _hx_is_interface = "False"
    __slots__ = ("out",)
    _hx_fields = ["out"]
    _hx_methods = ["write", "writeString"]
    _hx_statics = ["VERSION"]

    def __init__(self,out):
        self.out = out

    def write(self,font):
        self.out.writeString("BFNT")
        self.out.writeByte(0)
        self.out.writeByte(1)
        s = font.name
        if (s is None):
            s = ""
        _hx_bytes = haxe_io_Bytes.ofString(s)
        if (_hx_bytes.length > 65535):
            raise haxe_Exception.thrown("Invalid string: Size over 0xFFFF")
        self.out.writeUInt16(_hx_bytes.length)
        self.out.write(_hx_bytes)
        self.out.writeInt16(font.size)
        s = font.tilePath
        if (s is None):
            s = ""
        _hx_bytes = haxe_io_Bytes.ofString(s)
        if (_hx_bytes.length > 65535):
            raise haxe_Exception.thrown("Invalid string: Size over 0xFFFF")
        self.out.writeUInt16(_hx_bytes.length)
        self.out.write(_hx_bytes)
        tmp = self.out
        x = font.lineHeight
        tmp1 = None
        try:
            tmp1 = int(x)
        except BaseException as _g:
            None
            tmp1 = None
        tmp.writeInt16(tmp1)
        tmp = self.out
        x = font.baseLine
        tmp1 = None
        try:
            tmp1 = int(x)
        except BaseException as _g:
            None
            tmp1 = None
        tmp.writeInt16(tmp1)
        if (font.defaultChar != font.nullChar):
            found = False
            k = font.glyphs.keys()
            while k.hasNext():
                k1 = k.next()
                if (font.glyphs.h.get(k1,None) == font.defaultChar):
                    self.out.writeInt32(k1)
                    found = True
                    break
            if (not found):
                self.out.writeInt32(0)
        else:
            self.out.writeInt32(0)
        id = font.glyphs.keys()
        while id.hasNext():
            id1 = id.next()
            if (id1 == 0):
                continue
            glyph = font.glyphs.h.get(id1,None)
            t = glyph.t
            self.out.writeInt32(id1)
            tmp = self.out
            x = t.x
            tmp1 = None
            try:
                tmp1 = int(x)
            except BaseException as _g:
                None
                tmp1 = None
            tmp.writeUInt16(tmp1)
            tmp2 = self.out
            x1 = t.y
            tmp3 = None
            try:
                tmp3 = int(x1)
            except BaseException as _g1:
                None
                tmp3 = None
            tmp2.writeUInt16(tmp3)
            tmp4 = self.out
            x2 = t.width
            tmp5 = None
            try:
                tmp5 = int(x2)
            except BaseException as _g2:
                None
                tmp5 = None
            tmp4.writeUInt16(tmp5)
            tmp6 = self.out
            x3 = t.height
            tmp7 = None
            try:
                tmp7 = int(x3)
            except BaseException as _g3:
                None
                tmp7 = None
            tmp6.writeUInt16(tmp7)
            tmp8 = self.out
            x4 = t.dx
            tmp9 = None
            try:
                tmp9 = int(x4)
            except BaseException as _g4:
                None
                tmp9 = None
            tmp8.writeInt16(tmp9)
            tmp10 = self.out
            x5 = t.dy
            tmp11 = None
            try:
                tmp11 = int(x5)
            except BaseException as _g5:
                None
                tmp11 = None
            tmp10.writeInt16(tmp11)
            tmp12 = self.out
            x6 = glyph.width
            tmp13 = None
            try:
                tmp13 = int(x6)
            except BaseException as _g6:
                None
                tmp13 = None
            tmp12.writeInt16(tmp13)
            kern = glyph.kerning
            while (kern is not None):
                if (kern.prevChar != 0):
                    self.out.writeInt32(kern.prevChar)
                    tmp14 = self.out
                    x7 = kern.offset
                    tmp15 = None
                    try:
                        tmp15 = int(x7)
                    except BaseException as _g7:
                        None
                        tmp15 = None
                    tmp14.writeInt16(tmp15)
                kern = kern.next
            self.out.writeInt32(0)
        self.out.writeInt32(0)

    def writeString(self,s):
        if (s is None):
            s = ""
        _hx_bytes = haxe_io_Bytes.ofString(s)
        if (_hx_bytes.length > 65535):
            raise haxe_Exception.thrown("Invalid string: Size over 0xFFFF")
        self.out.writeUInt16(_hx_bytes.length)
        self.out.write(_hx_bytes)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.out = None
hxd_fmt_bfnt_Writer._hx_class = hxd_fmt_bfnt_Writer
_hx_classes["hxd.fmt.bfnt.Writer"] = hxd_fmt_bfnt_Writer


class hxd_fmt_fbx_TmpObject:
    _hx_class_name = "hxd.fmt.fbx.TmpObject"
    _hx_is_interface = "False"
    __slots__ = ("index", "model", "parent", "isJoint", "isMesh", "childs", "obj", "joint", "skin")
    _hx_fields = ["index", "model", "parent", "isJoint", "isMesh", "childs", "obj", "joint", "skin"]

    def __init__(self):
        self.skin = None
        self.joint = None
        self.obj = None
        self.isMesh = None
        self.isJoint = None
        self.parent = None
        self.model = None
        self.index = None
        self.childs = []

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.model = None
        _hx_o.parent = None
        _hx_o.isJoint = None
        _hx_o.isMesh = None
        _hx_o.childs = None
        _hx_o.obj = None
        _hx_o.joint = None
        _hx_o.skin = None
hxd_fmt_fbx_TmpObject._hx_class = hxd_fmt_fbx_TmpObject
_hx_classes["hxd.fmt.fbx.TmpObject"] = hxd_fmt_fbx_TmpObject


class hxd_fmt_fbx__BaseLibrary_AnimCurve:
    _hx_class_name = "hxd.fmt.fbx._BaseLibrary.AnimCurve"
    _hx_is_interface = "False"
    __slots__ = ("_hx_def", "object", "t", "r", "s", "a", "fov", "roll", "uv")
    _hx_fields = ["def", "object", "t", "r", "s", "a", "fov", "roll", "uv"]

    def __init__(self,_hx_def,object):
        self.uv = None
        self.roll = None
        self.fov = None
        self.a = None
        self.s = None
        self.r = None
        self.t = None
        self._hx_def = _hx_def
        self.object = object

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx_def = None
        _hx_o.object = None
        _hx_o.t = None
        _hx_o.r = None
        _hx_o.s = None
        _hx_o.a = None
        _hx_o.fov = None
        _hx_o.roll = None
        _hx_o.uv = None
hxd_fmt_fbx__BaseLibrary_AnimCurve._hx_class = hxd_fmt_fbx__BaseLibrary_AnimCurve
_hx_classes["hxd.fmt.fbx._BaseLibrary.AnimCurve"] = hxd_fmt_fbx__BaseLibrary_AnimCurve


class hxd_fmt_fbx_DefaultMatrixes:
    _hx_class_name = "hxd.fmt.fbx.DefaultMatrixes"
    _hx_is_interface = "False"
    __slots__ = ("trans", "scale", "rotate", "preRot", "wasRemoved", "transPos")
    _hx_fields = ["trans", "scale", "rotate", "preRot", "wasRemoved", "transPos"]
    _hx_methods = ["toMatrix", "toQuaternion"]
    _hx_statics = ["rightHandToLeft"]

    def __init__(self):
        self.transPos = None
        self.wasRemoved = None
        self.preRot = None
        self.rotate = None
        self.scale = None
        self.trans = None

    def toMatrix(self,leftHand):
        m = h3d_Matrix()
        m.identity()
        if (self.scale is not None):
            m.scale(self.scale.x,self.scale.y,self.scale.z)
        if (self.rotate is not None):
            m.rotate(self.rotate.x,self.rotate.y,self.rotate.z)
        if (self.preRot is not None):
            m.rotate(self.preRot.x,self.preRot.y,self.preRot.z)
        if (self.trans is not None):
            m.translate(self.trans.x,self.trans.y,self.trans.z)
        if leftHand:
            m._12 = -m._12
            m._13 = -m._13
            m._21 = -m._21
            m._31 = -m._31
            m._41 = -m._41
        return m

    def toQuaternion(self,leftHand):
        m = h3d_Matrix()
        m.identity()
        if (self.rotate is not None):
            m.rotate(self.rotate.x,self.rotate.y,self.rotate.z)
        if (self.preRot is not None):
            m.rotate(self.preRot.x,self.preRot.y,self.preRot.z)
        if leftHand:
            m._12 = -m._12
            m._13 = -m._13
            m._21 = -m._21
            m._31 = -m._31
            m._41 = -m._41
        q = h3d_Quat()
        q.initRotateMatrix(m)
        return q

    @staticmethod
    def rightHandToLeft(m):
        m._12 = -m._12
        m._13 = -m._13
        m._21 = -m._21
        m._31 = -m._31
        m._41 = -m._41

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.trans = None
        _hx_o.scale = None
        _hx_o.rotate = None
        _hx_o.preRot = None
        _hx_o.wasRemoved = None
        _hx_o.transPos = None
hxd_fmt_fbx_DefaultMatrixes._hx_class = hxd_fmt_fbx_DefaultMatrixes
_hx_classes["hxd.fmt.fbx.DefaultMatrixes"] = hxd_fmt_fbx_DefaultMatrixes


class hxd_fmt_fbx_BaseLibrary:
    _hx_class_name = "hxd.fmt.fbx.BaseLibrary"
    _hx_is_interface = "False"
    __slots__ = ("root", "ids", "connect", "namedConnect", "invConnect", "leftHand", "defaultModelMatrixes", "uvAnims", "animationEvents", "isMaya", "fileName", "version", "keepJoints", "skipObjects", "bonesPerVertex", "unskinnedJointsAsObjects", "allowVertexColor", "normalizeScaleOrient")
    _hx_fields = ["root", "ids", "connect", "namedConnect", "invConnect", "leftHand", "defaultModelMatrixes", "uvAnims", "animationEvents", "isMaya", "fileName", "version", "keepJoints", "skipObjects", "bonesPerVertex", "unskinnedJointsAsObjects", "allowVertexColor", "normalizeScaleOrient"]
    _hx_methods = ["reset", "loadFile", "load", "toFloats", "getAllModels", "getRootModels", "isRootModel", "updateModelScale", "convertYupToZup", "convertPoints", "leftHandConvert", "init", "getGeometry", "getParent", "getChild", "getSpecChild", "getChilds", "getParents", "getRoot", "ignoreMissingObject", "buildHierarchy", "getObjectCurve", "mergeModels", "addLink", "removeLink", "checkData", "roundValues", "getAnimationNames", "loadAnimation", "sortDistinctFloats", "isNullJoint", "getModelPath", "autoMerge", "keepJoint", "createSkin", "round", "updateDefaultMatrix", "getDefaultMatrixes"]
    _hx_statics = ["maxBonesPerSkin"]

    def __init__(self,fileName):
        self.unskinnedJointsAsObjects = None
        self.isMaya = None
        self.animationEvents = None
        self.uvAnims = None
        self.defaultModelMatrixes = None
        self.leftHand = None
        self.invConnect = None
        self.namedConnect = None
        self.connect = None
        self.ids = None
        self.normalizeScaleOrient = True
        self.allowVertexColor = True
        self.bonesPerVertex = 3
        self.version = 0.
        self.fileName = fileName
        self.root = _hx_AnonObject({'name': "Root", 'props': [], 'childs': []})
        self.keepJoints = haxe_ds_StringMap()
        self.skipObjects = haxe_ds_StringMap()
        self.reset()

    def reset(self):
        self.ids = haxe_ds_IntMap()
        self.connect = haxe_ds_IntMap()
        self.namedConnect = haxe_ds_IntMap()
        self.invConnect = haxe_ds_IntMap()
        self.defaultModelMatrixes = haxe_ds_IntMap()

    def loadFile(self,data):
        self.load(hxd_fmt_fbx_Parser.parse(data))

    def load(self,root):
        self.reset()
        self.root = root
        self.version = (hxd_fmt_fbx_FbxTools.toInt(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(root,"FBXHeaderExtension.FBXVersion").props, 0)) / 1000)
        x = self.version
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        if (tmp != 7):
            raise haxe_Exception.thrown("FBX Version 7.x required : use FBX 2010 export")
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(root,"FBXHeaderExtension.SceneInfo.Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None)) == "Original|ApplicationName"):
                _this = hxd_fmt_fbx_FbxTools.toString((p.props[4] if 4 < len(p.props) else None)).lower()
                startIndex = None
                self.isMaya = (((_this.find("maya") if ((startIndex is None)) else HxString.indexOfImpl(_this,"maya",startIndex))) >= 0)
                break
        _g = 0
        _g1 = root.childs
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.init(c)
        if self.normalizeScaleOrient:
            self.updateModelScale()
        _g = 0
        _g1 = self.getAllModels()
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = 0
            _g3 = hxd_fmt_fbx_FbxTools.getAll(m,"Properties70.P")
            while (_g2 < len(_g3)):
                p = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                _g4 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
                _hx_local_4 = len(_g4)
                if (_hx_local_4 == 9):
                    if (_g4 == "UDP3DSMAX"):
                        _this = hxd_fmt_fbx_FbxTools.toString((p.props[4] if 4 < len(p.props) else None))
                        userProps = _this.split("&cr;&lf;")
                        _g5 = 0
                        while (_g5 < len(userProps)):
                            p1 = (userProps[_g5] if _g5 >= 0 and _g5 < len(userProps) else None)
                            _g5 = (_g5 + 1)
                            pl = p1.split("=")
                            pname = StringTools.trim((None if ((len(pl) == 0)) else pl.pop(0)))
                            pval = StringTools.trim("=".join([python_Boot.toString1(x1,'') for x1 in pl]))
                            pname1 = pname
                            _hx_local_6 = len(pname1)
                            if (_hx_local_6 == 6):
                                if (pname1 == "Events"):
                                    xml = None
                                    try:
                                        xml = Xml.parse(pval)
                                    except BaseException as _g6:
                                        None
                                        raise haxe_Exception.thrown(("Invalid Events data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                    _g7 = []
                                    x = xml.firstElement()
                                    if ((x.nodeType != Xml.Document) and ((x.nodeType != Xml.Element))):
                                        raise haxe_Exception.thrown(("Invalid nodeType " + HxOverrides.stringOrNull((("null" if ((x.nodeType is None)) else _Xml_XmlType_Impl_.toString(x.nodeType))))))
                                    this1 = x
                                    f = this1.elements()
                                    while f.hasNext():
                                        f1 = f.next()
                                        _this1 = haxe_xml__Access_Access_Impl_.get_innerData(f1)
                                        f2 = _this1.split(" ")
                                        x1 = _hx_AnonObject({'frame': Std.parseInt((None if ((len(f2) == 0)) else f2.pop(0))), 'data': StringTools.trim(" ".join([python_Boot.toString1(x1,'') for x1 in f2]))})
                                        _g7.append(x1)
                                    self.animationEvents = _g7
                                else:
                                    pass
                            elif (_hx_local_6 == 2):
                                if (pname1 == "UV"):
                                    if (pval != ""):
                                        xml1 = None
                                        try:
                                            xml1 = Xml.parse(pval)
                                        except BaseException as _g8:
                                            None
                                            raise haxe_Exception.thrown(("Invalid UV data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                        _g9 = []
                                        x2 = xml1.firstElement()
                                        if ((x2.nodeType != Xml.Document) and ((x2.nodeType != Xml.Element))):
                                            raise haxe_Exception.thrown(("Invalid nodeType " + HxOverrides.stringOrNull((("null" if ((x2.nodeType is None)) else _Xml_XmlType_Impl_.toString(x2.nodeType))))))
                                        this2 = x2
                                        f3 = this2.elements()
                                        while f3.hasNext():
                                            f4 = f3.next()
                                            _this2 = haxe_xml__Access_Access_Impl_.get_innerData(f4)
                                            f5 = _this2.split(" ")
                                            x3 = _hx_AnonObject({'t': (Std.parseFloat((f5[0] if 0 < len(f5) else None)) * 9622116.25), 'u': Std.parseFloat((f5[1] if 1 < len(f5) else None)), 'v': Std.parseFloat((f5[2] if 2 < len(f5) else None))})
                                            _g9.append(x3)
                                        frames = _g9
                                        if (self.uvAnims is None):
                                            self.uvAnims = haxe_ds_StringMap()
                                        this3 = self.uvAnims
                                        key = hxd_fmt_fbx_FbxTools.getName(m)
                                        this3.h[key] = frames
                                else:
                                    pass
                            else:
                                pass
                    else:
                        pass
                elif (_hx_local_4 == 6):
                    if (_g4 == "Events"):
                        _this = hxd_fmt_fbx_FbxTools.toString((p.props[4] if 4 < len(p.props) else None))
                        userProps = _this.split("&cr;&lf;")
                        _g5 = 0
                        while (_g5 < len(userProps)):
                            p1 = (userProps[_g5] if _g5 >= 0 and _g5 < len(userProps) else None)
                            _g5 = (_g5 + 1)
                            pl = p1.split("=")
                            pname = StringTools.trim((None if ((len(pl) == 0)) else pl.pop(0)))
                            pval = StringTools.trim("=".join([python_Boot.toString1(x1,'') for x1 in pl]))
                            pname1 = pname
                            _hx_local_8 = len(pname1)
                            if (_hx_local_8 == 6):
                                if (pname1 == "Events"):
                                    xml = None
                                    try:
                                        xml = Xml.parse(pval)
                                    except BaseException as _g6:
                                        None
                                        raise haxe_Exception.thrown(("Invalid Events data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                    _g7 = []
                                    x = xml.firstElement()
                                    if ((x.nodeType != Xml.Document) and ((x.nodeType != Xml.Element))):
                                        raise haxe_Exception.thrown(("Invalid nodeType " + HxOverrides.stringOrNull((("null" if ((x.nodeType is None)) else _Xml_XmlType_Impl_.toString(x.nodeType))))))
                                    this1 = x
                                    f = this1.elements()
                                    while f.hasNext():
                                        f1 = f.next()
                                        _this1 = haxe_xml__Access_Access_Impl_.get_innerData(f1)
                                        f2 = _this1.split(" ")
                                        x1 = _hx_AnonObject({'frame': Std.parseInt((None if ((len(f2) == 0)) else f2.pop(0))), 'data': StringTools.trim(" ".join([python_Boot.toString1(x1,'') for x1 in f2]))})
                                        _g7.append(x1)
                                    self.animationEvents = _g7
                                else:
                                    pass
                            elif (_hx_local_8 == 2):
                                if (pname1 == "UV"):
                                    if (pval != ""):
                                        xml1 = None
                                        try:
                                            xml1 = Xml.parse(pval)
                                        except BaseException as _g8:
                                            None
                                            raise haxe_Exception.thrown(("Invalid UV data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                        _g9 = []
                                        x2 = xml1.firstElement()
                                        if ((x2.nodeType != Xml.Document) and ((x2.nodeType != Xml.Element))):
                                            raise haxe_Exception.thrown(("Invalid nodeType " + HxOverrides.stringOrNull((("null" if ((x2.nodeType is None)) else _Xml_XmlType_Impl_.toString(x2.nodeType))))))
                                        this2 = x2
                                        f3 = this2.elements()
                                        while f3.hasNext():
                                            f4 = f3.next()
                                            _this2 = haxe_xml__Access_Access_Impl_.get_innerData(f4)
                                            f5 = _this2.split(" ")
                                            x3 = _hx_AnonObject({'t': (Std.parseFloat((f5[0] if 0 < len(f5) else None)) * 9622116.25), 'u': Std.parseFloat((f5[1] if 1 < len(f5) else None)), 'v': Std.parseFloat((f5[2] if 2 < len(f5) else None))})
                                            _g9.append(x3)
                                        frames = _g9
                                        if (self.uvAnims is None):
                                            self.uvAnims = haxe_ds_StringMap()
                                        this3 = self.uvAnims
                                        key = hxd_fmt_fbx_FbxTools.getName(m)
                                        this3.h[key] = frames
                                else:
                                    pass
                            else:
                                pass
                    else:
                        pass
                else:
                    pass

    def toFloats(self,n):
        _g = (n.props[0] if 0 < len(n.props) else None)
        tmp = _g.index
        if (tmp == 4):
            vl = _g.params[0]
            _g1 = []
            _g2 = 0
            while (_g2 < len(vl)):
                v = (vl[_g2] if _g2 >= 0 and _g2 < len(vl) else None)
                _g2 = (_g2 + 1)
                _g1.append(v)
            vl = _g1
            python_internal_ArrayImpl._set(n.props, 0, hxd_fmt_fbx_FbxProp.PFloats(vl))
            return vl
        elif (tmp == 5):
            vl = _g.params[0]
            return vl
        else:
            raise haxe_Exception.thrown((Std.string((n.props[0] if 0 < len(n.props) else None)) + " should be floats "))

    def getAllModels(self):
        return hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Model")

    def getRootModels(self):
        _g = []
        _g1 = 0
        _g2 = self.getAllModels()
        while (_g1 < len(_g2)):
            m = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            if self.isRootModel(m):
                _g.append(m)
        return _g

    def isRootModel(self,m):
        return (self.getParent(m,"Model",True) is None)

    def updateModelScale(self):
        unitScale = 1
        originScale = 1
        upAxis = 1
        originalUpAxis = 2
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"GlobalSettings.Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
            _hx_local_1 = len(_g2)
            if (_hx_local_1 == 15):
                if (_g2 == "UnitScaleFactor"):
                    unitScale = hxd_fmt_fbx_FbxTools.toInt((p.props[4] if 4 < len(p.props) else None))
                else:
                    pass
            elif (_hx_local_1 == 23):
                if (_g2 == "OriginalUnitScaleFactor"):
                    originScale = hxd_fmt_fbx_FbxTools.toInt((p.props[4] if 4 < len(p.props) else None))
                else:
                    pass
            elif (_hx_local_1 == 14):
                if (_g2 == "OriginalUpAxis"):
                    originalUpAxis = hxd_fmt_fbx_FbxTools.toInt((p.props[4] if 4 < len(p.props) else None))
                else:
                    pass
            elif (_hx_local_1 == 6):
                if (_g2 == "UpAxis"):
                    upAxis = hxd_fmt_fbx_FbxTools.toInt((p.props[4] if 4 < len(p.props) else None))
                else:
                    pass
            else:
                pass
        scaleFactor = (100 if (((unitScale == 100) and ((originScale == 1)))) else 1)
        geometryScaleFactor = scaleFactor
        if (upAxis == 1):
            self.convertYupToZup(originalUpAxis)
        app = ""
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"FBXHeaderExtension.SceneInfo.Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None)) == "LastSaved|ApplicationName"):
                app = hxd_fmt_fbx_FbxTools.toString((p.props[4] if 4 < len(p.props) else None))
        startIndex = None
        if ((((app.find("Blender") if ((startIndex is None)) else HxString.indexOfImpl(app,"Blender",startIndex))) >= 0) and ((unitScale == originScale))):
            scaleFactor = (unitScale / 100)
        if ((scaleFactor == 1) and ((geometryScaleFactor == 1))):
            return
        if (geometryScaleFactor != 1):
            _g = 0
            _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry.Vertices")
            while (_g < len(_g1)):
                g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                v = self.toFloats(g)
                _g2 = 0
                _g3 = len(v)
                while (_g2 < _g3):
                    i = _g2
                    _g2 = (_g2 + 1)
                    python_internal_ArrayImpl._set(v, i, ((v[i] if i >= 0 and i < len(v) else None) / geometryScaleFactor))
        if (scaleFactor == 1):
            return
        _g = 0
        _g1 = self.getAllModels()
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            isRoot = self.isRootModel(m)
            _g2 = 0
            _g3 = hxd_fmt_fbx_FbxTools.getAll(m,"Properties70.P")
            while (_g2 < len(_g3)):
                p = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                _g4 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
                _hx_local_7 = len(_g4)
                if (_hx_local_7 == 15):
                    if (_g4 == "Lcl Translation"):
                        if (not isRoot):
                            idx = 4
                            v = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx] if idx >= 0 and idx < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx, hxd_fmt_fbx_FbxProp.PFloat((v / scaleFactor)))
                            idx1 = 5
                            v1 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx1] if idx1 >= 0 and idx1 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx1, hxd_fmt_fbx_FbxProp.PFloat((v1 / scaleFactor)))
                            idx2 = 6
                            v2 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx2] if idx2 >= 0 and idx2 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx2, hxd_fmt_fbx_FbxProp.PFloat((v2 / scaleFactor)))
                    else:
                        pass
                elif (_hx_local_7 == 11):
                    if (_g4 == "Lcl Scaling"):
                        if isRoot:
                            idx3 = 4
                            v3 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx3] if idx3 >= 0 and idx3 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx3, hxd_fmt_fbx_FbxProp.PFloat((v3 * scaleFactor)))
                            idx4 = 5
                            v4 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx4] if idx4 >= 0 and idx4 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx4, hxd_fmt_fbx_FbxProp.PFloat((v4 * scaleFactor)))
                            idx5 = 6
                            v5 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx5] if idx5 >= 0 and idx5 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx5, hxd_fmt_fbx_FbxProp.PFloat((v5 * scaleFactor)))
                    else:
                        pass
                elif (_hx_local_7 == 20):
                    if (_g4 == "GeometricTranslation"):
                        if (not isRoot):
                            idx = 4
                            v = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx] if idx >= 0 and idx < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx, hxd_fmt_fbx_FbxProp.PFloat((v / scaleFactor)))
                            idx1 = 5
                            v1 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx1] if idx1 >= 0 and idx1 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx1, hxd_fmt_fbx_FbxProp.PFloat((v1 / scaleFactor)))
                            idx2 = 6
                            v2 = hxd_fmt_fbx_FbxTools.toFloat((p.props[idx2] if idx2 >= 0 and idx2 < len(p.props) else None))
                            python_internal_ArrayImpl._set(p.props, idx2, hxd_fmt_fbx_FbxProp.PFloat((v2 / scaleFactor)))
                    else:
                        pass
                else:
                    pass
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Deformer.Transform")
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            m = self.toFloats(t)
            _hx_local_9 = m
            _hx_local_10 = 12
            _hx_local_11 = (_hx_local_9[_hx_local_10] if _hx_local_10 >= 0 and _hx_local_10 < len(_hx_local_9) else None)
            python_internal_ArrayImpl._set(_hx_local_9, _hx_local_10, (_hx_local_11 / scaleFactor))
            (_hx_local_9[_hx_local_10] if _hx_local_10 >= 0 and _hx_local_10 < len(_hx_local_9) else None)
            _hx_local_12 = m
            _hx_local_13 = 13
            _hx_local_14 = (_hx_local_12[_hx_local_13] if _hx_local_13 >= 0 and _hx_local_13 < len(_hx_local_12) else None)
            python_internal_ArrayImpl._set(_hx_local_12, _hx_local_13, (_hx_local_14 / scaleFactor))
            (_hx_local_12[_hx_local_13] if _hx_local_13 >= 0 and _hx_local_13 < len(_hx_local_12) else None)
            _hx_local_15 = m
            _hx_local_16 = 14
            _hx_local_17 = (_hx_local_15[_hx_local_16] if _hx_local_16 >= 0 and _hx_local_16 < len(_hx_local_15) else None)
            python_internal_ArrayImpl._set(_hx_local_15, _hx_local_16, (_hx_local_17 / scaleFactor))
            (_hx_local_15[_hx_local_16] if _hx_local_16 >= 0 and _hx_local_16 < len(_hx_local_15) else None)
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.AnimationCurveNode")
        while (_g < len(_g1)):
            n = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            name = hxd_fmt_fbx_FbxTools.getName(n)
            model = self.getParent(n,"Model",True)
            isRoot = ((model is not None) and ((self.getParent(model,"Model",True) is None)))
            _g2 = 0
            _g3 = hxd_fmt_fbx_FbxTools.getAll(n,"Properties70.P")
            while (_g2 < len(_g3)):
                p = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                _g4 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
                if (((_g4 == "d|Z") or ((_g4 == "d|Y"))) or ((_g4 == "d|X"))):
                    if ((name == "T") and (not isRoot)):
                        python_internal_ArrayImpl._set(p.props, 4, hxd_fmt_fbx_FbxProp.PFloat((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) / scaleFactor)))
                    elif ((name == "S") and isRoot):
                        python_internal_ArrayImpl._set(p.props, 4, hxd_fmt_fbx_FbxProp.PFloat((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * scaleFactor)))
                else:
                    pass
            _g5 = 0
            _g6 = self.getChilds(n,"AnimationCurve")
            while (_g5 < len(_g6)):
                c = (_g6[_g5] if _g5 >= 0 and _g5 < len(_g6) else None)
                _g5 = (_g5 + 1)
                vl = self.toFloats(hxd_fmt_fbx_FbxTools.get(c,"KeyValueFloat"))
                if (name is not None):
                    name1 = name
                    if (name1 == "S"):
                        if isRoot:
                            _g7 = 0
                            _g8 = len(vl)
                            while (_g7 < _g8):
                                i = _g7
                                _g7 = (_g7 + 1)
                                python_internal_ArrayImpl._set(vl, i, ((vl[i] if i >= 0 and i < len(vl) else None) * scaleFactor))
                    elif (name1 == "T"):
                        if (not isRoot):
                            _g9 = 0
                            _g10 = len(vl)
                            while (_g9 < _g10):
                                i1 = _g9
                                _g9 = (_g9 + 1)
                                python_internal_ArrayImpl._set(vl, i1, ((vl[i1] if i1 >= 0 and i1 < len(vl) else None) / scaleFactor))
                    else:
                        pass

    def convertYupToZup(self,originalUpAxis):
        originalUpAxis1 = originalUpAxis
        if ((originalUpAxis1 == 1) or ((originalUpAxis1 == -1))):
            _g = 0
            _g1 = self.getRootModels()
            while (_g < len(_g1)):
                m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                needPreRot = True
                _g2 = 0
                _g3 = hxd_fmt_fbx_FbxTools.getAll(self.root,"GlobalSettings.Properties70.P")
                while (_g2 < len(_g3)):
                    c = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if ((((hxd_fmt_fbx_FbxTools.toString((c.props[0] if 0 < len(c.props) else None)) == "PreRotation") and ((hxd_fmt_fbx_FbxTools.toFloat((c.props[4] if 4 < len(c.props) else None)) == 90))) and ((hxd_fmt_fbx_FbxTools.toFloat((c.props[5] if 5 < len(c.props) else None)) == 0))) and ((hxd_fmt_fbx_FbxTools.toFloat((c.props[6] if 6 < len(c.props) else None)) == 0))):
                        needPreRot = False
                        break
                if needPreRot:
                    preRotProp = _hx_AnonObject({'name': "P", 'props': [hxd_fmt_fbx_FbxProp.PString("PreRotation"), hxd_fmt_fbx_FbxProp.PString("Vector3D"), hxd_fmt_fbx_FbxProp.PString("Vector"), hxd_fmt_fbx_FbxProp.PString(""), hxd_fmt_fbx_FbxProp.PFloat(90), hxd_fmt_fbx_FbxProp.PFloat(0), hxd_fmt_fbx_FbxProp.PFloat(0)], 'childs': []})
                    hxd_fmt_fbx_FbxTools.get(m,"Properties70").childs.insert(0, preRotProp)
        elif (originalUpAxis1 == 2):
            _g = 0
            _g1 = self.getRootModels()
            while (_g < len(_g1)):
                rootObject = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                props = hxd_fmt_fbx_FbxTools.get(rootObject,"Properties70")
                _g2 = 0
                _g3 = props.childs
                while (_g2 < len(_g3)):
                    c = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if ((((hxd_fmt_fbx_FbxTools.toString((c.props[0] if 0 < len(c.props) else None)) == "PreRotation") and ((hxd_fmt_fbx_FbxTools.toFloat((c.props[4] if 4 < len(c.props) else None)) == -90))) and ((hxd_fmt_fbx_FbxTools.toFloat((c.props[5] if 5 < len(c.props) else None)) == 0))) and ((hxd_fmt_fbx_FbxTools.toFloat((c.props[6] if 6 < len(c.props) else None)) == 0))):
                        python_internal_ArrayImpl.remove(props.childs,c)
                        break
        else:
            raise haxe_Exception.thrown((("From Y-up to Z-up with orginalUpAxis = " + Std.string(originalUpAxis)) + " not implemented."))

    def convertPoints(self,a):
        p = 0
        _g = 0
        x = (len(a) / 3)
        _g1 = None
        try:
            _g1 = int(x)
        except BaseException as _g2:
            None
            _g1 = None
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(a, p, -(a[p] if p >= 0 and p < len(a) else None))
            p = (p + 3)

    def leftHandConvert(self):
        if self.leftHand:
            return
        self.leftHand = True
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry")
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = 0
            _g3 = hxd_fmt_fbx_FbxTools.getAll(g,"Vertices")
            while (_g2 < len(_g3)):
                v = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v))
            _g4 = 0
            _g5 = hxd_fmt_fbx_FbxTools.getAll(g,"LayerElementNormal.Normals")
            while (_g4 < len(_g5)):
                v1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v1))
            _g6 = 0
            _g7 = hxd_fmt_fbx_FbxTools.getAll(g,"LayerElementTangent.Tangents")
            while (_g6 < len(_g7)):
                v2 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                _g6 = (_g6 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v2))
            _g8 = 0
            _g9 = hxd_fmt_fbx_FbxTools.getAll(g,"LayerElementBinormal.Binormals")
            while (_g8 < len(_g9)):
                v3 = (_g9[_g8] if _g8 >= 0 and _g8 < len(_g9) else None)
                _g8 = (_g8 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v3))

    def init(self,n):
        _g = n.name
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 11):
            if (_g == "Connections"):
                _g = 0
                _g1 = n.childs
                while (_g < len(_g1)):
                    c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    if (c.name != "C"):
                        continue
                    child = hxd_fmt_fbx_FbxTools.toInt((c.props[1] if 1 < len(c.props) else None))
                    parent = hxd_fmt_fbx_FbxTools.toInt((c.props[2] if 2 < len(c.props) else None))
                    if ((self.ids.h.get(child,None) is None) or ((self.ids.h.get(parent,None) is None))):
                        continue
                    name = (c.props[3] if 3 < len(c.props) else None)
                    if (name is not None):
                        name1 = hxd_fmt_fbx_FbxTools.toString(name)
                        nc = self.namedConnect.h.get(parent,None)
                        if (nc is None):
                            nc = haxe_ds_StringMap()
                            self.namedConnect.set(parent,nc)
                        nc.h[name1] = child
                        if (name1 == "LookAtProperty"):
                            continue
                    c1 = self.connect.h.get(parent,None)
                    if (c1 is None):
                        c1 = []
                        self.connect.set(parent,c1)
                    c1.append(child)
                    if (parent == 0):
                        continue
                    c2 = self.invConnect.h.get(child,None)
                    if (c2 is None):
                        c2 = []
                        self.invConnect.set(child,c2)
                    c2.append(parent)
            else:
                pass
        elif (_hx_local_0 == 7):
            if (_g == "Objects"):
                _g = 0
                _g1 = n.childs
                while (_g < len(_g1)):
                    c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    self.ids.set(hxd_fmt_fbx_FbxTools.getId(c),c)
            else:
                pass
        else:
            pass

    def getGeometry(self,name = None):
        if (name is None):
            name = ""
        geom = None
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry")
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if hxd_fmt_fbx_FbxTools.hasProp(g,hxd_fmt_fbx_FbxProp.PString(("Geometry::" + ("null" if name is None else name)))):
                geom = g
                break
        if (geom is None):
            raise haxe_Exception.thrown((("Geometry " + ("null" if name is None else name)) + " not found"))
        return hxd_fmt_fbx_Geometry(self,geom)

    def getParent(self,node,nodeName,opt = None):
        p = self.getParents(node,nodeName)
        if (len(p) > 1):
            tmp = (((((HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node)) + " has ") + Std.string(len(p))) + " ") + ("null" if nodeName is None else nodeName)) + " parents ")
            _g = []
            _g1 = 0
            while (_g1 < len(p)):
                o = (p[_g1] if _g1 >= 0 and _g1 < len(p) else None)
                _g1 = (_g1 + 1)
                x = hxd_fmt_fbx_FbxTools.getName(o)
                _g.append(x)
            raise haxe_Exception.thrown((("null" if tmp is None else tmp) + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))))
        if ((len(p) == 0) and (not opt)):
            raise haxe_Exception.thrown((((("Missing " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node))) + " ") + ("null" if nodeName is None else nodeName)) + " parent"))
        return (p[0] if 0 < len(p) else None)

    def getChild(self,node,nodeName,opt = None):
        c = self.getChilds(node,nodeName)
        if (len(c) > 1):
            tmp = (((((HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node)) + " has ") + Std.string(len(c))) + " ") + ("null" if nodeName is None else nodeName)) + " childs ")
            _g = []
            _g1 = 0
            while (_g1 < len(c)):
                o = (c[_g1] if _g1 >= 0 and _g1 < len(c) else None)
                _g1 = (_g1 + 1)
                x = hxd_fmt_fbx_FbxTools.getName(o)
                _g.append(x)
            raise haxe_Exception.thrown((("null" if tmp is None else tmp) + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))))
        if ((len(c) == 0) and (not opt)):
            raise haxe_Exception.thrown((((("Missing " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node))) + " ") + ("null" if nodeName is None else nodeName)) + " child"))
        return (c[0] if 0 < len(c) else None)

    def getSpecChild(self,node,name):
        this1 = self.namedConnect
        key = hxd_fmt_fbx_FbxTools.getId(node)
        nc = this1.h.get(key,None)
        if (nc is None):
            return None
        id = nc.h.get(name,None)
        if (id is None):
            return None
        return self.ids.h.get(id,None)

    def getChilds(self,node,nodeName = None):
        this1 = self.connect
        key = hxd_fmt_fbx_FbxTools.getId(node)
        c = this1.h.get(key,None)
        subs = []
        if (c is not None):
            _g = 0
            while (_g < len(c)):
                id = (c[_g] if _g >= 0 and _g < len(c) else None)
                _g = (_g + 1)
                n = self.ids.h.get(id,None)
                if (n is None):
                    raise haxe_Exception.thrown((Std.string(id) + " not found"))
                if ((nodeName is not None) and ((n.name != nodeName))):
                    continue
                subs.append(n)
        return subs

    def getParents(self,node,nodeName = None):
        this1 = self.invConnect
        key = hxd_fmt_fbx_FbxTools.getId(node)
        c = this1.h.get(key,None)
        pl = []
        if (c is not None):
            _g = 0
            while (_g < len(c)):
                id = (c[_g] if _g >= 0 and _g < len(c) else None)
                _g = (_g + 1)
                n = self.ids.h.get(id,None)
                if (n is None):
                    raise haxe_Exception.thrown((Std.string(id) + " not found"))
                if ((nodeName is not None) and ((n.name != nodeName))):
                    continue
                pl.append(n)
        return pl

    def getRoot(self):
        return self.root

    def ignoreMissingObject(self,id):
        _hx_def = self.defaultModelMatrixes.h.get(id,None)
        if (_hx_def is None):
            _hx_def = hxd_fmt_fbx_DefaultMatrixes()
            _hx_def.wasRemoved = -2
            self.defaultModelMatrixes.set(id,_hx_def)

    def buildHierarchy(self):
        oroot = hxd_fmt_fbx_TmpObject()
        objects = list()
        hobjects = haxe_ds_IntMap()
        hobjects.set(0,oroot)
        _g = 0
        _g1 = self.getAllModels()
        while (_g < len(_g1)):
            model = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            this1 = self.skipObjects
            key = hxd_fmt_fbx_FbxTools.getName(model)
            if this1.h.get(key,None):
                continue
            mtype = hxd_fmt_fbx_FbxTools.getType(model)
            isJoint = ((mtype == "LimbNode") and (((not self.unskinnedJointsAsObjects) or (not self.isNullJoint(model)))))
            o = hxd_fmt_fbx_TmpObject()
            o.model = model
            o.isJoint = isJoint
            o.isMesh = (mtype == "Mesh")
            hobjects.set(hxd_fmt_fbx_FbxTools.getId(model),o)
            objects.append(o)
        _g = 0
        while (_g < len(objects)):
            o = (objects[_g] if _g >= 0 and _g < len(objects) else None)
            _g = (_g + 1)
            p = self.getParent(o.model,"Model",True)
            pid = (0 if ((p is None)) else hxd_fmt_fbx_FbxTools.getId(p))
            op = hobjects.h.get(pid,None)
            if (op is None):
                op = oroot
            _this = op.childs
            _this.append(o)
            o.parent = op
        _g = 0
        while (_g < len(objects)):
            o = (objects[_g] if _g >= 0 and _g < len(objects) else None)
            _g = (_g + 1)
            if (not o.isMesh):
                continue
            g = self.getChild(o.model,"Geometry")
            _hx_def = self.getChild(g,"Deformer",True)
            if (_hx_def is None):
                continue
            _g1 = []
            _g2 = 0
            _g3 = self.getChilds(_hx_def,"Deformer")
            while (_g2 < len(_g3)):
                d = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                key = hxd_fmt_fbx_FbxTools.getId(self.getChild(d,"Model"))
                x = hobjects.h.get(key,None)
                _g1.append(x)
            bones = _g1
            if (len(bones) == 0):
                continue
            o1 = (bones[0] if 0 < len(bones) else None)
            k = 0
            while (o1 != oroot):
                o1 = o1.parent
                k = (k + 1)
            minDepth = k
            _g4 = 1
            _g5 = len(bones)
            while (_g4 < _g5):
                i = _g4
                _g4 = (_g4 + 1)
                o2 = (bones[i] if i >= 0 and i < len(bones) else None)
                k1 = 0
                while (o2 != oroot):
                    o2 = o2.parent
                    k1 = (k1 + 1)
                d1 = k1
                if (d1 < minDepth):
                    minDepth = d1
            out = []
            _g6 = 0
            _g7 = len(bones)
            while (_g6 < _g7):
                i1 = _g6
                _g6 = (_g6 + 1)
                b = (bones[i1] if i1 >= 0 and i1 < len(bones) else None)
                o3 = b
                k2 = 0
                while (o3 != oroot):
                    o3 = o3.parent
                    k2 = (k2 + 1)
                n = (k2 - minDepth)
                _g8 = 0
                _g9 = n
                while (_g8 < _g9):
                    i2 = _g8
                    _g8 = (_g8 + 1)
                    b.isJoint = True
                    b = b.parent
                python_internal_ArrayImpl.remove(out,b)
                out.append(b)
            bones = out
            while (len(bones) > 1):
                _g10 = 0
                while (_g10 < len(bones)):
                    b1 = (bones[_g10] if _g10 >= 0 and _g10 < len(bones) else None)
                    _g10 = (_g10 + 1)
                    b1.isJoint = True
                parents = []
                _g11 = 0
                while (_g11 < len(bones)):
                    b2 = (bones[_g11] if _g11 >= 0 and _g11 < len(bones) else None)
                    _g11 = (_g11 + 1)
                    if ((b2.parent == oroot) or b2.parent.isMesh):
                        continue
                    python_internal_ArrayImpl.remove(parents,b2.parent)
                    x1 = b2.parent
                    parents.append(x1)
                bones = parents
        changed = True
        while changed:
            changed = False
            _g = 0
            while (_g < len(objects)):
                o = (objects[_g] if _g >= 0 and _g < len(objects) else None)
                _g = (_g + 1)
                if (o.isJoint or o.isMesh):
                    continue
                if o.parent.isJoint:
                    o.isJoint = True
                    changed = True
                    continue
                hasJoint = False
                _g1 = 0
                _g2 = o.childs
                while (_g1 < len(_g2)):
                    c = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                    _g1 = (_g1 + 1)
                    if c.isJoint:
                        hasJoint = True
                        break
                if hasJoint:
                    _g3 = 0
                    _g4 = o.parent.childs
                    while (_g3 < len(_g4)):
                        c1 = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                        _g3 = (_g3 + 1)
                        if c1.isJoint:
                            o.isJoint = True
                            changed = True
                            break
        return _hx_AnonObject({'root': oroot, 'objects': objects})

    def getObjectCurve(self,curves,model,curveName,animName):
        key = hxd_fmt_fbx_FbxTools.getId(model)
        c = curves.h.get(key,None)
        if (c is not None):
            return c
        name = hxd_fmt_fbx_FbxTools.getName(model)
        if self.skipObjects.h.get(name,None):
            return None
        _hx_def = self.getDefaultMatrixes(model)
        if (_hx_def is None):
            return None
        isMove = ((curveName != "Visibility") and ((curveName != "UV")))
        if ((_hx_def.wasRemoved is not None) and ((isMove or ((_hx_def.wasRemoved == -1))))):
            return None
        if ((_hx_def.wasRemoved is not None) and ((_hx_def.wasRemoved != -2))):
            model = self.ids.h.get(_hx_def.wasRemoved,None)
            name = hxd_fmt_fbx_FbxTools.getName(model)
            c = curves.h.get(_hx_def.wasRemoved,None)
            _hx_def = self.getDefaultMatrixes(model)
            if (_hx_def is None):
                raise haxe_Exception.thrown("assert")
        if (c is None):
            c = hxd_fmt_fbx__BaseLibrary_AnimCurve(_hx_def,name)
            curves.set(hxd_fmt_fbx_FbxTools.getId(model),c)
        return c

    def mergeModels(self,modelNames):
        if (len(modelNames) <= 1):
            return
        models = self.getAllModels()
        def _hx_local_1(name):
            _g = 0
            while (_g < len(models)):
                m = (models[_g] if _g >= 0 and _g < len(models) else None)
                _g = (_g + 1)
                if (hxd_fmt_fbx_FbxTools.getName(m) == name):
                    return m
            raise haxe_Exception.thrown(("Model not found " + ("null" if name is None else name)))
        getModel = _hx_local_1
        m = getModel((modelNames[0] if 0 < len(modelNames) else None))
        geom = hxd_fmt_fbx_Geometry(self,self.getChild(m,"Geometry"))
        _hx_def = self.getChild(geom.getRoot(),"Deformer",True)
        subDefs = self.getChilds(_hx_def,"Deformer")
        _g = 1
        _g1 = len(modelNames)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            name = (modelNames[i] if i >= 0 and i < len(modelNames) else None)
            m2 = getModel(name)
            geom2 = hxd_fmt_fbx_Geometry(self,self.getChild(m2,"Geometry"))
            x = (len(geom.getVertices()) / 3)
            vcount = None
            try:
                vcount = int(x)
            except BaseException as _g2:
                None
                vcount = None
            self.skipObjects.h[name] = True
            mindex = []
            materials = self.getChilds(m,"Material")
            _g3 = 0
            _g4 = self.getChilds(m2,"Material")
            while (_g3 < len(_g4)):
                mat = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                _g3 = (_g3 + 1)
                idx = python_internal_ArrayImpl.indexOf(materials,mat,None)
                if (idx < 0):
                    idx = len(materials)
                    materials.append(mat)
                    self.addLink(m,mat)
                mindex.append(idx)
            geom.merge(geom2,mindex)
            def2 = self.getChild(geom2.getRoot(),"Deformer",True)
            if (def2 is not None):
                if (_hx_def is None):
                    raise haxe_Exception.thrown((((HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m)) + " does not have a deformer but ") + ("null" if name is None else name)) + " has one"))
                _g5 = 0
                _g6 = self.getChilds(def2,"Deformer")
                while (_g5 < len(_g6)):
                    subDef = (_g6[_g5] if _g5 >= 0 and _g5 < len(_g6) else None)
                    _g5 = (_g5 + 1)
                    subModel = self.getChild(subDef,"Model")
                    prevDef = None
                    _g7 = 0
                    while (_g7 < len(subDefs)):
                        s = (subDefs[_g7] if _g7 >= 0 and _g7 < len(subDefs) else None)
                        _g7 = (_g7 + 1)
                        if (self.getChild(s,"Model") == subModel):
                            prevDef = s
                            break
                    if (prevDef is not None):
                        self.removeLink(subDef,subModel)
                    idx1 = hxd_fmt_fbx_FbxTools.get(subDef,"Indexes",True)
                    if (idx1 is None):
                        continue
                    if (prevDef is None):
                        self.addLink(_hx_def,subDef)
                        self.removeLink(def2,subDef)
                        subDefs.append(subDef)
                        idx2 = hxd_fmt_fbx_FbxTools.getInts(idx1)
                        _g8 = 0
                        _g9 = len(idx2)
                        while (_g8 < _g9):
                            i1 = _g8
                            _g8 = (_g8 + 1)
                            python_internal_ArrayImpl._set(idx2, i1, ((idx2[i1] if i1 >= 0 and i1 < len(idx2) else None) + vcount))
                    else:
                        pidx = hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(prevDef,"Indexes"))
                        _g10 = 0
                        _g11 = hxd_fmt_fbx_FbxTools.getInts(idx1)
                        while (_g10 < len(_g11)):
                            i2 = (_g11[_g10] if _g10 >= 0 and _g10 < len(_g11) else None)
                            _g10 = (_g10 + 1)
                            pidx.append((i2 + vcount))
                        weights = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(prevDef,"Weights"))
                        _g12 = 0
                        _g13 = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(subDef,"Weights"))
                        while (_g12 < len(_g13)):
                            w = (_g13[_g12] if _g12 >= 0 and _g12 < len(_g13) else None)
                            _g12 = (_g12 + 1)
                            weights.append(w)

    def addLink(self,parent,child):
        pid = hxd_fmt_fbx_FbxTools.getId(parent)
        nid = hxd_fmt_fbx_FbxTools.getId(child)
        _this = self.connect.h.get(pid,None)
        _this.append(nid)
        _this = self.invConnect.h.get(nid,None)
        _this.append(pid)

    def removeLink(self,parent,child):
        pid = hxd_fmt_fbx_FbxTools.getId(parent)
        nid = hxd_fmt_fbx_FbxTools.getId(child)
        python_internal_ArrayImpl.remove(self.connect.h.get(pid,None),nid)
        python_internal_ArrayImpl.remove(self.invConnect.h.get(nid,None),pid)

    def checkData(self,t):
        if (t is None):
            return True
        if (t.x is not None):
            v = (t.x[0] if 0 < len(t.x) else None)
            _g = 0
            _g1 = t.x
            while (_g < len(_g1)):
                v2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v != v2):
                    return False
        if (t.y is not None):
            v = (t.y[0] if 0 < len(t.y) else None)
            _g = 0
            _g1 = t.y
            while (_g < len(_g1)):
                v2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v != v2):
                    return False
        if (t.z is not None):
            v = (t.z[0] if 0 < len(t.z) else None)
            _g = 0
            _g1 = t.z
            while (_g < len(_g1)):
                v2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v != v2):
                    return False
        return True

    def roundValues(self,data,_hx_def,mult = None):
        if (mult is None):
            mult = 1.
        hasValue = False
        _g = 0
        _g1 = len(data)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            v = ((data[i] if i >= 0 and i < len(data) else None) * mult)
            f = (v - _hx_def)
            if (((-f if ((f < 0)) else f)) > 1e-3):
                hasValue = True
            else:
                v = _hx_def
            python_internal_ArrayImpl._set(data, i, self.round(v))
        return hasValue

    def getAnimationNames(self):
        names = []
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.AnimationStack")
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (len(self.getChilds(a,"AnimationLayer")) > 0):
                x = hxd_fmt_fbx_FbxTools.getName(a)
                names.append(x)
        return names

    def loadAnimation(self,animName = None,root = None,lib = None):
        if (lib is not None):
            lib.defaultModelMatrixes = self.defaultModelMatrixes
            return lib.loadAnimation(animName)
        if (root is not None):
            l = hxd_fmt_fbx_BaseLibrary(self.fileName)
            l.normalizeScaleOrient = self.normalizeScaleOrient
            l.load(root)
            if self.leftHand:
                l.leftHandConvert()
            l.defaultModelMatrixes = self.defaultModelMatrixes
            return l.loadAnimation(animName)
        defNode = None
        animNodes = []
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.AnimationStack")
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((animName is None) or ((hxd_fmt_fbx_FbxTools.getName(a) == animName))):
                _g2 = 0
                _g3 = self.getChilds(a,"AnimationLayer")
                while (_g2 < len(_g3)):
                    n = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    defNode = n
                    if (len(self.getChilds(n,"AnimationCurveNode")) > 0):
                        animNodes.append(n)
        animNode = None
        _g = len(animNodes)
        if (_g == 0):
            animNode = defNode
        elif (_g == 1):
            animNode = (animNodes[0] if 0 < len(animNodes) else None)
        else:
            haxe_Log.trace("Multiple animation layers curves are currently not supported",_hx_AnonObject({'fileName': "hxd/fmt/fbx/BaseLibrary.hx", 'lineNumber': 827, 'className': "hxd.fmt.fbx.BaseLibrary", 'methodName': "loadAnimation"}))
            animNode = (animNodes[0] if 0 < len(animNodes) else None)
        if (animNode is None):
            if (animName is not None):
                raise haxe_Exception.thrown(("Animation not found " + ("null" if animName is None else animName)))
            if (self.uvAnims is None):
                return None
        if (animName is None):
            animName = hxd_fmt_fbx_FbxTools.getName(self.getParent(animNode,"AnimationStack"))
        curves = haxe_ds_IntMap()
        P0 = h3d_col_Point()
        P1 = h3d_col_Point(1,1,1)
        F = 0.0174532925199432955
        allTimes = haxe_ds_IntMap()
        if (animNode is not None):
            _g = 0
            _g1 = self.getChilds(animNode,"AnimationCurveNode")
            while (_g < len(_g1)):
                cn = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                model = self.getParent(cn,"Model",True)
                if (model is None):
                    _g2 = hxd_fmt_fbx_FbxTools.getName(cn)
                    if (_g2 is None):
                        continue
                    else:
                        _g3 = _g2
                        _hx_local_3 = len(_g3)
                        if (_hx_local_3 == 11):
                            if (_g3 == "FieldOfView"):
                                nattr = self.getParent(cn,"NodeAttribute",True)
                                model = (None if ((nattr is None)) else self.getParent(nattr,"Model",True))
                                if (model is None):
                                    continue
                            else:
                                continue
                        elif (_hx_local_3 == 4):
                            if (_g3 == "Roll"):
                                nattr = self.getParent(cn,"NodeAttribute",True)
                                model = (None if ((nattr is None)) else self.getParent(nattr,"Model",True))
                                if (model is None):
                                    continue
                            else:
                                continue
                        else:
                            continue
                c = self.getObjectCurve(curves,model,hxd_fmt_fbx_FbxTools.getName(cn),animName)
                if (c is None):
                    continue
                dataCurves = self.getChilds(cn,"AnimationCurve")
                if (len(dataCurves) == 0):
                    continue
                cname = hxd_fmt_fbx_FbxTools.getName(cn)
                times = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get((dataCurves[0] if 0 < len(dataCurves) else None),"KeyTime"))
                _g4 = 0
                _g5 = len(times)
                while (_g4 < _g5):
                    i = _g4
                    _g4 = (_g4 + 1)
                    t = (times[i] if i >= 0 and i < len(times) else None)
                    if (HxOverrides.modf(t, 100) != 0):
                        t = (t + ((100 - (HxOverrides.modf(t, 100)))))
                        python_internal_ArrayImpl._set(times, i, t)
                    it = None
                    try:
                        it = int((t / 200000))
                    except BaseException as _g6:
                        None
                        it = None
                    it1 = it
                    allTimes.set(it1,t)
                if (len(dataCurves) != 3):
                    values = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get((dataCurves[0] if 0 < len(dataCurves) else None),"KeyValueFloat"))
                    if (cname is not None):
                        cname1 = cname
                        _hx_local_5 = len(cname1)
                        if (_hx_local_5 == 10):
                            if (cname1 == "Visibility"):
                                if (not self.roundValues(values,1)):
                                    continue
                                c.a = _hx_AnonObject({'v': values, 't': times})
                                continue
                            else:
                                pass
                        elif (_hx_local_5 == 11):
                            if (cname1 == "FieldOfView"):
                                ratio = 1.77777777777777768
                                fov = 45.
                                _g7 = 0
                                _g8 = hxd_fmt_fbx_FbxTools.getAll(self.getChild(model,"NodeAttribute"),"Properties70.P")
                                while (_g7 < len(_g8)):
                                    p = (_g8[_g7] if _g7 >= 0 and _g7 < len(_g8) else None)
                                    _g7 = (_g7 + 1)
                                    _g9 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
                                    _hx_local_7 = len(_g9)
                                    if (_hx_local_7 == 15):
                                        if (_g9 == "FilmAspectRatio"):
                                            ratio = hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))
                                        else:
                                            pass
                                    elif (_hx_local_7 == 11):
                                        if (_g9 == "FieldOfView"):
                                            fov = hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))
                                        else:
                                            pass
                                    else:
                                        pass
                                _g10 = 0
                                _g11 = len(values)
                                while (_g10 < _g11):
                                    i1 = _g10
                                    _g10 = (_g10 + 1)
                                    python_internal_ArrayImpl._set(values, i1, (((2 * Math.atan((Math.tan(((((values[i1] if i1 >= 0 and i1 < len(values) else None) * 0.5) * 3.14159265358979323) / 180)) / ratio))) * 180) / 3.14159265358979323))
                                if (not self.roundValues(values,(((2 * Math.atan((Math.tan((((fov * 0.5) * 3.14159265358979323) / 180)) / ratio))) * 180) / 3.14159265358979323))):
                                    continue
                                c.fov = _hx_AnonObject({'v': values, 't': times})
                                continue
                            else:
                                pass
                        elif (_hx_local_5 == 4):
                            if (cname1 == "Roll"):
                                if (not self.roundValues(values,0)):
                                    continue
                                c.roll = _hx_AnonObject({'v': values, 't': times})
                                continue
                            else:
                                pass
                        else:
                            pass
                data = _hx_AnonObject({'x': None, 'y': None, 'z': None, 't': times})
                this1 = self.namedConnect
                key = hxd_fmt_fbx_FbxTools.getId(cn)
                curves1 = this1.h.get(key,None)
                cname2 = curves1.keys()
                while cname2.hasNext():
                    cname3 = cname2.next()
                    this2 = self.ids
                    key1 = curves1.h.get(cname3,None)
                    values1 = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(this2.h.get(key1,None),"KeyValueFloat"))
                    cname4 = cname3
                    if (cname4 == "d|X"):
                        data.x = values1
                    elif (cname4 == "d|Y"):
                        data.y = values1
                    elif (cname4 == "d|Z"):
                        data.z = values1
                    else:
                        haxe_Log.trace(("Unsupported key name " + ("null" if cname3 is None else cname3)),_hx_AnonObject({'fileName': "hxd/fmt/fbx/BaseLibrary.hx", 'lineNumber': 942, 'className': "hxd.fmt.fbx.BaseLibrary", 'methodName': "loadAnimation"}))
                M = 1.0
                _hx_def = None
                if (cname is None):
                    haxe_Log.trace(((("Unknown curve " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(model))) + ".") + ("null" if cname is None else cname)),_hx_AnonObject({'fileName': "hxd/fmt/fbx/BaseLibrary.hx", 'lineNumber': 969, 'className': "hxd.fmt.fbx.BaseLibrary", 'methodName': "loadAnimation"}))
                    continue
                else:
                    cname5 = cname
                    if (cname5 == "R"):
                        M = F
                        if ((c._hx_def.rotate is None) and ((c._hx_def.preRot is None))):
                            _hx_def = P0
                        elif (c._hx_def.rotate is None):
                            _hx_def = c._hx_def.preRot
                        elif (c._hx_def.preRot is None):
                            _hx_def = c._hx_def.rotate
                        else:
                            q = h3d_Quat()
                            q2 = h3d_Quat()
                            q2.initRotation(c._hx_def.preRot.x,c._hx_def.preRot.y,c._hx_def.preRot.z)
                            q.initRotation(c._hx_def.rotate.x,c._hx_def.rotate.y,c._hx_def.rotate.z)
                            q.multiply(q2,q)
                            _this = q.toEuler()
                            _hx_def = h3d_col_Point(_this.x,_this.y,_this.z)
                    elif (cname5 == "S"):
                        _hx_def = (P1 if ((c._hx_def.scale is None)) else c._hx_def.scale)
                    elif (cname5 == "T"):
                        _hx_def = (P0 if ((c._hx_def.trans is None)) else c._hx_def.trans)
                    else:
                        haxe_Log.trace(((("Unknown curve " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(model))) + ".") + ("null" if cname is None else cname)),_hx_AnonObject({'fileName': "hxd/fmt/fbx/BaseLibrary.hx", 'lineNumber': 969, 'className': "hxd.fmt.fbx.BaseLibrary", 'methodName': "loadAnimation"}))
                        continue
                hasValue = False
                if ((data.x is not None) and self.roundValues(data.x,_hx_def.x,M)):
                    hasValue = True
                if ((data.y is not None) and self.roundValues(data.y,_hx_def.y,M)):
                    hasValue = True
                if ((data.z is not None) and self.roundValues(data.z,_hx_def.z,M)):
                    hasValue = True
                if (not hasValue):
                    continue
                keyCount = 0
                if (data.x is not None):
                    keyCount = len(data.x)
                if (data.y is not None):
                    keyCount = len(data.y)
                if (data.z is not None):
                    keyCount = len(data.z)
                if (data.x is None):
                    _g12 = []
                    _g13 = 0
                    _g14 = keyCount
                    while (_g13 < _g14):
                        i2 = _g13
                        _g13 = (_g13 + 1)
                        x = _hx_def.x
                        _g12.append(x)
                    data.x = _g12
                if (data.y is None):
                    _g15 = []
                    _g16 = 0
                    _g17 = keyCount
                    while (_g16 < _g17):
                        i3 = _g16
                        _g16 = (_g16 + 1)
                        x1 = _hx_def.y
                        _g15.append(x1)
                    data.y = _g15
                if (data.z is None):
                    _g18 = []
                    _g19 = 0
                    _g20 = keyCount
                    while (_g19 < _g20):
                        i4 = _g19
                        _g19 = (_g19 + 1)
                        x2 = _hx_def.z
                        _g18.append(x2)
                    data.z = _g18
                if (cname is None):
                    raise haxe_Exception.thrown("assert")
                else:
                    cname6 = cname
                    if (cname6 == "R"):
                        c.r = data
                    elif (cname6 == "S"):
                        c.s = data
                    elif (cname6 == "T"):
                        c.t = data
                    else:
                        raise haxe_Exception.thrown("assert")
        if (self.uvAnims is not None):
            modelByName = haxe_ds_StringMap()
            _g = 0
            _g1 = self.getAllModels()
            while (_g < len(_g1)):
                obj = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                key = hxd_fmt_fbx_FbxTools.getName(obj)
                modelByName.h[key] = obj
            obj = self.uvAnims.keys()
            while obj.hasNext():
                obj1 = obj.next()
                frames = self.uvAnims.h.get(obj1,None)
                model = modelByName.h.get(obj1,None)
                if (model is None):
                    raise haxe_Exception.thrown((("Missing model '" + ("null" if obj1 is None else obj1)) + "' required by UV animation"))
                c = self.getObjectCurve(curves,model,"UV",animName)
                if (c is None):
                    continue
                c.uv = frames
                _g = 0
                while (_g < len(frames)):
                    f = (frames[_g] if _g >= 0 and _g < len(frames) else None)
                    _g = (_g + 1)
                    x = (f.t / 200000)
                    key = None
                    try:
                        key = int(x)
                    except BaseException as _g1:
                        None
                        key = None
                    allTimes.set(key,f.t)
        _g = []
        a = allTimes.iterator()
        while a.hasNext():
            a1 = a.next()
            _g.append(a1)
        allTimes = _g
        if (len(allTimes) == 0):
            return None
        allTimes.sort(key= python_lib_Functools.cmp_to_key(self.sortDistinctFloats))
        maxTime = python_internal_ArrayImpl._get(allTimes, (len(allTimes) - 1))
        minDT = maxTime
        curT = (allTimes[0] if 0 < len(allTimes) else None)
        _g = 1
        _g1 = len(allTimes)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            t = (allTimes[i] if i >= 0 and i < len(allTimes) else None)
            dt = (t - curT)
            if (dt < minDT):
                minDT = dt
            curT = t
        numFrames = None
        if (maxTime == 0):
            numFrames = 1
        else:
            numFrames1 = None
            try:
                numFrames1 = int((((maxTime - (allTimes[0] if 0 < len(allTimes) else None))) / minDT))
            except BaseException as _g:
                None
                numFrames1 = None
            numFrames = (1 + numFrames1)
        sampling = (15.0 / ((minDT / 3079077200)))
        if (len(allTimes) < numFrames):
            t = (allTimes[0] if 0 < len(allTimes) else None)
            while (t < maxTime):
                if (python_internal_ArrayImpl.indexOf(allTimes,t,None) < 0):
                    allTimes.append(t)
                t = (t + minDT)
            allTimes.sort(key= python_lib_Functools.cmp_to_key(Reflect.compare))
            if (len(allTimes) > numFrames):
                tmp = (((("Animation " + ("null" if animName is None else animName)) + "(") + HxOverrides.stringOrNull(self.fileName)) + ") is not baked on a fixed framerate (detected ")
                tmp1 = None
                try:
                    tmp1 = int(sampling)
                except BaseException as _g:
                    None
                    tmp1 = None
                raise haxe_Exception.thrown(((("null" if tmp is None else tmp) + Std.string(tmp1)) + ")"))
            if (len(allTimes) < numFrames):
                raise haxe_Exception.thrown("assert")
        anim = h3d_anim_LinearAnimation(animName,numFrames,sampling)
        q = h3d_Quat()
        q2 = h3d_Quat()
        _g = []
        c = curves.iterator()
        while c.hasNext():
            c1 = c.next()
            _g.append(c1)
        sortedCurves = _g
        def _hx_local_11(c):
            if (c.roll is not None):
                return "roll"
            elif (c.fov is not None):
                return "fov"
            elif (c.uv is not None):
                return "uv"
            else:
                return "position"
        curveName = _hx_local_11
        def _hx_local_12(c1,c2):
            r = Reflect.compare(c1.object,c2.object)
            if (r != 0):
                return r
            return Reflect.compare(curveName(c1),curveName(c2))
        sortedCurves.sort(key= python_lib_Functools.cmp_to_key(_hx_local_12))
        _g = 0
        while (_g < len(sortedCurves)):
            c = (sortedCurves[_g] if _g >= 0 and _g < len(sortedCurves) else None)
            _g = (_g + 1)
            numFrames1 = numFrames
            sameData = True
            if (((((((c.t is None) and ((c.r is None))) and ((c.s is None))) and ((c.a is None))) and ((c.uv is None))) and ((c.roll is None))) and ((c.fov is None))):
                numFrames1 = 1
            else:
                if sameData:
                    sameData = self.checkData(c.t)
                if sameData:
                    sameData = self.checkData(c.r)
                if sameData:
                    sameData = self.checkData(c.s)
            this1 = [None]*(1 if sameData else numFrames1)
            frames = this1
            alpha = None
            if (c.a is None):
                alpha = None
            else:
                this2 = [None]*numFrames1
                alpha = this2
            uvs = None
            if (c.uv is None):
                uvs = None
            else:
                this3 = [None]*(numFrames1 * 2)
                uvs = this3
            roll = None
            if (c.roll is None):
                roll = None
            else:
                this4 = [None]*numFrames1
                roll = this4
            fov = None
            if (c.fov is None):
                fov = None
            else:
                this5 = [None]*numFrames1
                fov = this5
            if (((((frames is None) and ((alpha is None))) and ((uvs is None))) and ((roll is None))) and ((fov is None))):
                continue
            ctx = (None if ((c.t is None)) else c.t.x)
            cty = (None if ((c.t is None)) else c.t.y)
            ctz = (None if ((c.t is None)) else c.t.z)
            ctt = ([-1.] if ((c.t is None)) else c.t.t)
            crx = (None if ((c.r is None)) else c.r.x)
            cry = (None if ((c.r is None)) else c.r.y)
            crz = (None if ((c.r is None)) else c.r.z)
            crt = ([-1.] if ((c.r is None)) else c.r.t)
            csx = (None if ((c.s is None)) else c.s.x)
            csy = (None if ((c.s is None)) else c.s.y)
            csz = (None if ((c.s is None)) else c.s.z)
            cst = ([-1.] if ((c.s is None)) else c.s.t)
            cav = (None if ((c.a is None)) else c.a.v)
            cat = (None if ((c.a is None)) else c.a.t)
            cuv = c.uv
            _hx_def = c._hx_def
            tp = 0
            rp = 0
            sp = 0
            ap = 0
            uvp = 0
            fovp = 0
            rollp = 0
            curFrame = None
            _g1 = 0
            _g2 = numFrames1
            while (_g1 < _g2):
                f = _g1
                _g1 = (_g1 + 1)
                changed = (curFrame is None)
                if ((allTimes[f] if f >= 0 and f < len(allTimes) else None) == (ctt[tp] if tp >= 0 and tp < len(ctt) else None)):
                    changed = True
                    tp = (tp + 1)
                if ((allTimes[f] if f >= 0 and f < len(allTimes) else None) == (crt[rp] if rp >= 0 and rp < len(crt) else None)):
                    changed = True
                    rp = (rp + 1)
                if ((allTimes[f] if f >= 0 and f < len(allTimes) else None) == (cst[sp] if sp >= 0 and sp < len(cst) else None)):
                    changed = True
                    sp = (sp + 1)
                if changed:
                    f1 = h3d_anim_LinearFrame()
                    if ((c.s is None) or ((sp == 0))):
                        if (_hx_def.scale is not None):
                            f1.sx = _hx_def.scale.x
                            f1.sy = _hx_def.scale.y
                            f1.sz = _hx_def.scale.z
                        else:
                            f1.sx = 1
                            f1.sy = 1
                            f1.sz = 1
                    else:
                        f1.sx = python_internal_ArrayImpl._get(csx, (sp - 1))
                        f1.sy = python_internal_ArrayImpl._get(csy, (sp - 1))
                        f1.sz = python_internal_ArrayImpl._get(csz, (sp - 1))
                    if ((c.r is None) or ((rp == 0))):
                        if (_hx_def.rotate is not None):
                            q.initRotation(_hx_def.rotate.x,_hx_def.rotate.y,_hx_def.rotate.z)
                        else:
                            def _hx_local_18():
                                def _hx_local_17():
                                    q.z = 0
                                    return q.z
                                q.y = _hx_local_17()
                                return q.y
                            q.x = _hx_local_18()
                            q.w = 1
                    else:
                        q.initRotation(python_internal_ArrayImpl._get(crx, (rp - 1)),python_internal_ArrayImpl._get(cry, (rp - 1)),python_internal_ArrayImpl._get(crz, (rp - 1)))
                    if (_hx_def.preRot is not None):
                        q2.initRotation(_hx_def.preRot.x,_hx_def.preRot.y,_hx_def.preRot.z)
                        q.multiply(q2,q)
                    f1.qx = q.x
                    f1.qy = q.y
                    f1.qz = q.z
                    f1.qw = q.w
                    if ((c.t is None) or ((tp == 0))):
                        if (_hx_def.trans is not None):
                            f1.tx = _hx_def.trans.x
                            f1.ty = _hx_def.trans.y
                            f1.tz = _hx_def.trans.z
                        else:
                            f1.tx = 0
                            f1.ty = 0
                            f1.tz = 0
                    else:
                        f1.tx = python_internal_ArrayImpl._get(ctx, (tp - 1))
                        f1.ty = python_internal_ArrayImpl._get(cty, (tp - 1))
                        f1.tz = python_internal_ArrayImpl._get(ctz, (tp - 1))
                    if self.leftHand:
                        f1.tx = -f1.tx
                        f1.qy = -f1.qy
                        f1.qz = -f1.qz
                    curFrame = f1
                if ((frames is not None) and ((f < len(frames)))):
                    frames[f] = curFrame
                if (alpha is not None):
                    if ((allTimes[f] if f >= 0 and f < len(allTimes) else None) == (cat[ap] if ap >= 0 and ap < len(cat) else None)):
                        ap = (ap + 1)
                    val = python_internal_ArrayImpl._get(cav, (ap - 1))
                    alpha[f] = val
                if (uvs is not None):
                    if ((uvp < len(cuv)) and (((allTimes[f] if f >= 0 and f < len(allTimes) else None) == (cuv[uvp] if uvp >= 0 and uvp < len(cuv) else None).t))):
                        uvp = (uvp + 1)
                    val1 = python_internal_ArrayImpl._get(cuv, (uvp - 1)).u
                    uvs[(f << 1)] = val1
                    val2 = python_internal_ArrayImpl._get(cuv, (uvp - 1)).v
                    uvs[((f << 1) | 1)] = val2
                if (roll is not None):
                    if ((allTimes[f] if f >= 0 and f < len(allTimes) else None) == python_internal_ArrayImpl._get(c.roll.t, rollp)):
                        rollp = (rollp + 1)
                    val3 = python_internal_ArrayImpl._get(c.roll.v, (rollp - 1))
                    roll[f] = val3
                if (fov is not None):
                    if ((allTimes[f] if f >= 0 and f < len(allTimes) else None) == python_internal_ArrayImpl._get(c.fov.t, fovp)):
                        fovp = (fovp + 1)
                    val4 = python_internal_ArrayImpl._get(c.fov.v, (fovp - 1))
                    fov[f] = val4
            if (frames is not None):
                hasTrans = (c.t is not None)
                hasRot = (((c.r is not None) or ((_hx_def.rotate is not None))) or ((_hx_def.preRot is not None)))
                hasScale = ((c.s is not None) or ((_hx_def.scale is not None)))
                if ((not hasTrans) and ((_hx_def.transPos is None))):
                    hasTrans = True
                anim.addCurve(c.object,frames,hasTrans,hasRot,hasScale)
            if (alpha is not None):
                anim.addAlphaCurve(c.object,alpha)
            if (uvs is not None):
                anim.addUVCurve(c.object,uvs)
            if (roll is not None):
                anim.addPropCurve(c.object,"Roll",roll)
            if (fov is not None):
                anim.addPropCurve(c.object,"FOVY",fov)
        return anim

    def sortDistinctFloats(self,a,b):
        if (a > b):
            return 1
        else:
            return -1

    def isNullJoint(self,model):
        if (len(self.getParents(model,"Deformer")) > 0):
            return False
        parent = self.getParent(model,"Model",True)
        if (parent is None):
            return True
        t = hxd_fmt_fbx_FbxTools.getType(parent)
        if ((t == "LimbNode") or ((t == "Root"))):
            return False
        return True

    def getModelPath(self,model):
        parent = self.getParent(model,"Model",True)
        name = hxd_fmt_fbx_FbxTools.getName(model)
        if (parent is None):
            return name
        return ((HxOverrides.stringOrNull(self.getModelPath(parent)) + ".") + ("null" if name is None else name))

    def autoMerge(self):
        toMerge = []
        mergeGroups = haxe_ds_IntMap()
        _g = 0
        _g1 = self.getAllModels()
        while (_g < len(_g1)):
            model = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            this1 = self.skipObjects
            key = hxd_fmt_fbx_FbxTools.getName(model)
            if this1.h.get(key,None):
                continue
            mtype = hxd_fmt_fbx_FbxTools.getType(model)
            isJoint = ((mtype == "LimbNode") and (((not self.unskinnedJointsAsObjects) or (not self.isNullJoint(model)))))
            if (not isJoint):
                continue
            deformers = self.getParents(model,"Deformer")
            if (len(deformers) <= 1):
                continue
            group = []
            _g2 = 0
            while (_g2 < len(deformers)):
                d = (deformers[_g2] if _g2 >= 0 and _g2 < len(deformers) else None)
                _g2 = (_g2 + 1)
                _hx_def = self.getParent(d,"Deformer")
                if (_hx_def is None):
                    continue
                geom = self.getParent(_hx_def,"Geometry")
                if (geom is None):
                    continue
                model2 = self.getParent(geom,"Model")
                if (model2 is None):
                    continue
                id = hxd_fmt_fbx_FbxTools.getId(model2)
                g = mergeGroups.h.get(id,None)
                if (g is not None):
                    _g3 = 0
                    while (_g3 < len(g)):
                        g1 = (g[_g3] if _g3 >= 0 and _g3 < len(g) else None)
                        _g3 = (_g3 + 1)
                        python_internal_ArrayImpl.remove(group,g1)
                        group.append(g1)
                    python_internal_ArrayImpl.remove(toMerge,g)
                python_internal_ArrayImpl.remove(group,model2)
                group.append(model2)
                mergeGroups.set(id,group)
            toMerge.append(group)
        _g = 0
        while (_g < len(toMerge)):
            group = (toMerge[_g] if _g >= 0 and _g < len(toMerge) else None)
            _g = (_g + 1)
            def _hx_local_4(m1,m2):
                return Reflect.compare(hxd_fmt_fbx_FbxTools.getName(m1),hxd_fmt_fbx_FbxTools.getName(m2))
            group.sort(key= python_lib_Functools.cmp_to_key(_hx_local_4))
            _g1 = 0
            while (_g1 < len(toMerge)):
                g = (toMerge[_g1] if _g1 >= 0 and _g1 < len(toMerge) else None)
                _g1 = (_g1 + 1)
                if (g is not group):
                    found = False
                    _g2 = 0
                    while (_g2 < len(group)):
                        m = (group[_g2] if _g2 >= 0 and _g2 < len(group) else None)
                        _g2 = (_g2 + 1)
                        if python_internal_ArrayImpl.remove(g,m):
                            found = True
                    if found:
                        g.append((group[0] if 0 < len(group) else None))
            _g3 = []
            _g4 = 0
            while (_g4 < len(group)):
                g1 = (group[_g4] if _g4 >= 0 and _g4 < len(group) else None)
                _g4 = (_g4 + 1)
                x = hxd_fmt_fbx_FbxTools.getName(g1)
                _g3.append(x)
            self.mergeModels(_g3)

    def keepJoint(self,j):
        return self.keepJoints.h.get(j.name,None)

    def createSkin(self,hskins,hgeom,rootJoints,bonesPerVertex):
        allJoints = []
        collectJoints = None
        def _hx_local_1(j):
            _g = 0
            _g1 = j.subs
            while (_g < len(_g1)):
                j1 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                collectJoints(j1)
            allJoints.append(j)
        collectJoints = _hx_local_1
        _g = 0
        while (_g < len(rootJoints)):
            j = (rootJoints[_g] if _g >= 0 and _g < len(rootJoints) else None)
            _g = (_g + 1)
            collectJoints(j)
        skin = None
        geomTrans = None
        iterJoints = list(allJoints)
        _g = 0
        while (_g < len(iterJoints)):
            j = (iterJoints[_g] if _g >= 0 and _g < len(iterJoints) else None)
            _g = (_g + 1)
            jModel = self.ids.h.get(j.index,None)
            subDef = self.getParent(jModel,"Deformer",True)
            this1 = self.defaultModelMatrixes
            key = hxd_fmt_fbx_FbxTools.getId(jModel)
            defMat = this1.h.get(key,None)
            j.defMat = defMat.toMatrix(self.leftHand)
            if (subDef is None):
                if ((len(j.subs) > 0) or self.keepJoint(j)):
                    continue
                if (j.parent is None):
                    python_internal_ArrayImpl.remove(rootJoints,j)
                else:
                    python_internal_ArrayImpl.remove(j.parent.subs,j)
                python_internal_ArrayImpl.remove(allJoints,j)
                defMat.wasRemoved = -1
                continue
            if (skin is None):
                _hx_def = self.getParent(subDef,"Deformer")
                key1 = hxd_fmt_fbx_FbxTools.getId(_hx_def)
                skin = hskins.h.get(key1,None)
                if (skin is not None):
                    return skin
                key2 = hxd_fmt_fbx_FbxTools.getId(self.getParent(_hx_def,"Geometry"))
                geom = hgeom.h.get(key2,None)
                skin = h3d_anim_Skin(None,geom.vertexCount(),bonesPerVertex)
                geom.setSkin(skin)
                hskins.set(hxd_fmt_fbx_FbxTools.getId(_hx_def),skin)
            j.transPos = defMat.transPos
            weights = hxd_fmt_fbx_FbxTools.getAll(subDef,"Weights")
            if (len(weights) > 0):
                weights1 = hxd_fmt_fbx_FbxTools.getFloats((weights[0] if 0 < len(weights) else None))
                vertex = hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(subDef,"Indexes"))
                _g1 = 0
                _g2 = len(vertex)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    w = (weights1[i] if i >= 0 and i < len(weights1) else None)
                    if (w < 0.01):
                        continue
                    vid = (vertex[i] if i >= 0 and i < len(vertex) else None)
                    il = (skin.envelop[vid] if vid >= 0 and vid < len(skin.envelop) else None)
                    if (il is None):
                        def _hx_local_4():
                            python_internal_ArrayImpl._set(skin.envelop, vid, [])
                            return (skin.envelop[vid] if vid >= 0 and vid < len(skin.envelop) else None)
                        il = _hx_local_4()
                    x = h3d_anim__Skin_Influence(j,w)
                    il.append(x)
        if (skin is None):
            _g = []
            _g1 = 0
            while (_g1 < len(iterJoints)):
                j = (iterJoints[_g1] if _g1 >= 0 and _g1 < len(iterJoints) else None)
                _g1 = (_g1 + 1)
                x = j.name
                _g.append(x)
            raise haxe_Exception.thrown((("No joint is skinned (" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))) + ")"))
        allJoints.reverse()
        _g = 0
        _g1 = len(allJoints)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            (allJoints[i] if i >= 0 and i < len(allJoints) else None).index = i
        skin.setJoints(allJoints,rootJoints)
        skin.initWeights()
        return skin

    def round(self,v):
        if (v != v):
            raise haxe_Exception.thrown("NaN found")
        v1 = (v * 131072)
        return (((v1 if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v1)) else Math.floor((v1 + 0.5))))) / 131072)

    def updateDefaultMatrix(self,model,d):
        subDef = self.getParent(model,"Deformer",True)
        if (subDef is None):
            return
        transPos = h3d_Matrix.L(hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(subDef,"Transform")))
        if self.leftHand:
            transPos._12 = -transPos._12
            transPos._13 = -transPos._13
            transPos._21 = -transPos._21
            transPos._31 = -transPos._31
            transPos._41 = -transPos._41
        d.transPos = transPos

    def getDefaultMatrixes(self,model):
        id = hxd_fmt_fbx_FbxTools.getId(model)
        d = self.defaultModelMatrixes.h.get(id,None)
        if (d is not None):
            return d
        d = hxd_fmt_fbx_DefaultMatrixes()
        F = 0.0174532925199432955
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(model,"Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
            _hx_local_1 = len(_g2)
            if (_hx_local_1 == 15):
                if (_g2 == "Lcl Translation"):
                    d.trans = h3d_col_Point(self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None))))
                    if (((d.trans.x == 0) and ((d.trans.y == 0))) and ((d.trans.z == 0))):
                        d.trans = None
                else:
                    pass
            elif (_hx_local_1 == 11):
                if (_g2 == "Lcl Scaling"):
                    d.scale = h3d_col_Point(self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None))))
                    if (((d.scale.x == 1) and ((d.scale.y == 1))) and ((d.scale.z == 1))):
                        d.scale = None
                elif (_g2 == "PreRotation"):
                    d.preRot = h3d_col_Point(self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * F)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)) * F)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)) * F)))
                    if (((d.preRot.x == 0) and ((d.preRot.y == 0))) and ((d.preRot.z == 0))):
                        d.preRot = None
                else:
                    pass
            elif (_hx_local_1 == 12):
                if (_g2 == "Lcl Rotation"):
                    d.rotate = h3d_col_Point(self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * F)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)) * F)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)) * F)))
                    if (((d.rotate.x == 0) and ((d.rotate.y == 0))) and ((d.rotate.z == 0))):
                        d.rotate = None
                else:
                    pass
            elif (_hx_local_1 == 20):
                if (_g2 == "GeometricTranslation"):
                    pass
                else:
                    pass
            else:
                pass
        if (hxd_fmt_fbx_FbxTools.getType(model) == "LimbNode"):
            self.updateDefaultMatrix(model,d)
        self.defaultModelMatrixes.set(id,d)
        return d

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
        _hx_o.ids = None
        _hx_o.connect = None
        _hx_o.namedConnect = None
        _hx_o.invConnect = None
        _hx_o.leftHand = None
        _hx_o.defaultModelMatrixes = None
        _hx_o.uvAnims = None
        _hx_o.animationEvents = None
        _hx_o.isMaya = None
        _hx_o.fileName = None
        _hx_o.version = None
        _hx_o.keepJoints = None
        _hx_o.skipObjects = None
        _hx_o.bonesPerVertex = None
        _hx_o.unskinnedJointsAsObjects = None
        _hx_o.allowVertexColor = None
        _hx_o.normalizeScaleOrient = None
hxd_fmt_fbx_BaseLibrary._hx_class = hxd_fmt_fbx_BaseLibrary
_hx_classes["hxd.fmt.fbx.BaseLibrary"] = hxd_fmt_fbx_BaseLibrary

class hxd_fmt_fbx_FbxProp(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.fbx.FbxProp"
    _hx_constructs = ["PInt", "PFloat", "PString", "PIdent", "PInts", "PFloats", "PBinary"]

    @staticmethod
    def PInt(v):
        return hxd_fmt_fbx_FbxProp("PInt", 0, (v,))

    @staticmethod
    def PFloat(v):
        return hxd_fmt_fbx_FbxProp("PFloat", 1, (v,))

    @staticmethod
    def PString(v):
        return hxd_fmt_fbx_FbxProp("PString", 2, (v,))

    @staticmethod
    def PIdent(i):
        return hxd_fmt_fbx_FbxProp("PIdent", 3, (i,))

    @staticmethod
    def PInts(v):
        return hxd_fmt_fbx_FbxProp("PInts", 4, (v,))

    @staticmethod
    def PFloats(v):
        return hxd_fmt_fbx_FbxProp("PFloats", 5, (v,))

    @staticmethod
    def PBinary(v):
        return hxd_fmt_fbx_FbxProp("PBinary", 6, (v,))
hxd_fmt_fbx_FbxProp._hx_class = hxd_fmt_fbx_FbxProp
_hx_classes["hxd.fmt.fbx.FbxProp"] = hxd_fmt_fbx_FbxProp


class hxd_fmt_fbx_FbxTools:
    _hx_class_name = "hxd.fmt.fbx.FbxTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get", "getAll", "getInts", "getFloats", "hasProp", "idToInt", "toInt", "toFloat", "toString", "toBinary", "getId", "getName", "getType"]

    @staticmethod
    def get(n,path,opt = None):
        if (opt is None):
            opt = False
        parts = path.split(".")
        cur = n
        _g = 0
        while (_g < len(parts)):
            p = (parts[_g] if _g >= 0 and _g < len(parts) else None)
            _g = (_g + 1)
            found = False
            _g1 = 0
            _g2 = cur.childs
            while (_g1 < len(_g2)):
                c = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                if (c.name == p):
                    cur = c
                    found = True
                    break
            if (not found):
                if opt:
                    return None
                raise haxe_Exception.thrown((((((HxOverrides.stringOrNull(n.name) + " does not have ") + ("null" if path is None else path)) + " (") + ("null" if p is None else p)) + " not found)"))
        return cur

    @staticmethod
    def getAll(n,path):
        parts = path.split(".")
        cur = [n]
        _g = 0
        while (_g < len(parts)):
            p = (parts[_g] if _g >= 0 and _g < len(parts) else None)
            _g = (_g + 1)
            out = []
            _g1 = 0
            while (_g1 < len(cur)):
                n = (cur[_g1] if _g1 >= 0 and _g1 < len(cur) else None)
                _g1 = (_g1 + 1)
                _g2 = 0
                _g3 = n.childs
                while (_g2 < len(_g3)):
                    c = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if (c.name == p):
                        out.append(c)
            cur = out
            if (len(cur) == 0):
                return cur
        return cur

    @staticmethod
    def getInts(n):
        if (len(n.props) != 1):
            raise haxe_Exception.thrown((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))
        _g = (n.props[0] if 0 < len(n.props) else None)
        if (_g.index == 4):
            v = _g.params[0]
            return v
        else:
            raise haxe_Exception.thrown((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))

    @staticmethod
    def getFloats(n):
        if (len(n.props) != 1):
            raise haxe_Exception.thrown((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))
        _g = (n.props[0] if 0 < len(n.props) else None)
        tmp = _g.index
        if (tmp == 4):
            i = _g.params[0]
            fl = list()
            _g1 = 0
            while (_g1 < len(i)):
                x = (i[_g1] if _g1 >= 0 and _g1 < len(i) else None)
                _g1 = (_g1 + 1)
                fl.append(x)
            python_internal_ArrayImpl._set(n.props, 0, hxd_fmt_fbx_FbxProp.PFloats(fl))
            return fl
        elif (tmp == 5):
            v = _g.params[0]
            return v
        else:
            raise haxe_Exception.thrown((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))

    @staticmethod
    def hasProp(n,p):
        _g = 0
        _g1 = n.props
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if Type.enumEq(p,p2):
                return True
        return False

    @staticmethod
    def idToInt(f):
        f = HxOverrides.modf(f, 4294967296.)
        if (f >= 2147483648.):
            f = (f - 4294967296.)
        elif (f < -2147483648.):
            f = (f + 4294967296.)
        tmp = None
        try:
            tmp = int(f)
        except BaseException as _g:
            None
            tmp = None
        return tmp

    @staticmethod
    def toInt(n):
        if (n is None):
            raise haxe_Exception.thrown("null prop")
        tmp = n.index
        if (tmp == 0):
            v = n.params[0]
            return v
        elif (tmp == 1):
            f = n.params[0]
            return hxd_fmt_fbx_FbxTools.idToInt(f)
        else:
            raise haxe_Exception.thrown(("Invalid prop " + Std.string(n)))

    @staticmethod
    def toFloat(n):
        if (n is None):
            raise haxe_Exception.thrown("null prop")
        tmp = n.index
        if (tmp == 0):
            v = n.params[0]
            return (v * 1.0)
        elif (tmp == 1):
            v = n.params[0]
            return v
        else:
            raise haxe_Exception.thrown(("Invalid prop " + Std.string(n)))

    @staticmethod
    def toString(n):
        if (n is None):
            raise haxe_Exception.thrown("null prop")
        if (n.index == 2):
            v = n.params[0]
            return v
        else:
            raise haxe_Exception.thrown(("Invalid prop " + Std.string(n)))

    @staticmethod
    def toBinary(n):
        if (n is None):
            raise haxe_Exception.thrown("null prop")
        if (n.index == 6):
            v = n.params[0]
            return v
        else:
            raise haxe_Exception.thrown(("Invalid prop " + Std.string(n)))

    @staticmethod
    def getId(n):
        if (len(n.props) != 3):
            raise haxe_Exception.thrown((HxOverrides.stringOrNull(n.name) + " is not an object"))
        _g = (n.props[0] if 0 < len(n.props) else None)
        tmp = _g.index
        if (tmp == 0):
            id = _g.params[0]
            return id
        elif (tmp == 1):
            id = _g.params[0]
            return hxd_fmt_fbx_FbxTools.idToInt(id)
        else:
            raise haxe_Exception.thrown(((HxOverrides.stringOrNull(n.name) + " is not an object ") + Std.string(n.props)))

    @staticmethod
    def getName(n):
        if (len(n.props) != 3):
            raise haxe_Exception.thrown((HxOverrides.stringOrNull(n.name) + " is not an object"))
        _g = (n.props[1] if 1 < len(n.props) else None)
        if (_g.index == 2):
            n1 = _g.params[0]
            _this = n1.split("::")
            return (None if ((len(_this) == 0)) else _this.pop())
        else:
            raise haxe_Exception.thrown((HxOverrides.stringOrNull(n.name) + " is not an object"))

    @staticmethod
    def getType(n):
        if (len(n.props) != 3):
            raise haxe_Exception.thrown((HxOverrides.stringOrNull(n.name) + " is not an object"))
        _g = (n.props[2] if 2 < len(n.props) else None)
        if (_g.index == 2):
            n1 = _g.params[0]
            return n1
        else:
            raise haxe_Exception.thrown((HxOverrides.stringOrNull(n.name) + " is not an object"))
hxd_fmt_fbx_FbxTools._hx_class = hxd_fmt_fbx_FbxTools
_hx_classes["hxd.fmt.fbx.FbxTools"] = hxd_fmt_fbx_FbxTools


class hxd_fmt_fbx_Geometry:
    _hx_class_name = "hxd.fmt.fbx.Geometry"
    _hx_is_interface = "False"
    __slots__ = ("lib", "root")
    _hx_fields = ["lib", "root"]
    _hx_methods = ["getRoot", "getVertices", "getPolygons", "getMaterials", "getMaterialByTriangle", "merge", "getIndexes", "getNormals", "getTangents", "getBinormals", "processVectors", "getColors", "getUVs", "getGeomMatrix"]

    def __init__(self,l,root):
        self.lib = l
        self.root = root

    def getRoot(self):
        return self.root

    def getVertices(self):
        return hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(self.root,"Vertices"))

    def getPolygons(self):
        return hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(self.root,"PolygonVertexIndex"))

    def getMaterials(self):
        mats = hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementMaterial",True)
        if (mats is None):
            return None
        else:
            return hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(mats,"Materials"))

    def getMaterialByTriangle(self):
        mids = self.getMaterials()
        pos = 0
        count = 0
        mats = []
        _g = 0
        _g1 = self.getPolygons()
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            count = (count + 1)
            if (p >= 0):
                continue
            m = pos
            pos = (pos + 1)
            m1 = (mids[m] if m >= 0 and m < len(mids) else None)
            _g2 = 0
            _g3 = (count - 2)
            while (_g2 < _g3):
                i = _g2
                _g2 = (_g2 + 1)
                mats.append(m1)
            count = 0
        return mats

    def merge(self,g,materials):
        vl = self.getVertices()
        x = (len(vl) / 3)
        vcount = None
        try:
            vcount = int(x)
        except BaseException as _g:
            None
            vcount = None
        if ((g.getGeomMatrix() is not None) or ((self.getGeomMatrix() is not None))):
            raise haxe_Exception.thrown("Cannot merge models with geometric transform")
        _g = 0
        _g1 = g.getVertices()
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            vl.append(v)
        poly = self.getPolygons()
        mats = self.getMaterials()
        if ((len(mats) == 1) and ((hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementMaterial.MappingInformationType").props, 0)) == "AllSame"))):
            polyCount = 0
            _g = 0
            while (_g < len(poly)):
                p = (poly[_g] if _g >= 0 and _g < len(poly) else None)
                _g = (_g + 1)
                if (p < 0):
                    polyCount = (polyCount + 1)
            m0 = (mats[0] if 0 < len(mats) else None)
            _g = 1
            _g1 = polyCount
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                mats.append(m0)
        polyCount = 0
        _g = 0
        _g1 = g.getPolygons()
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p1 = p
            if (p1 < 0):
                polyCount = (polyCount + 1)
                p1 = (p1 - vcount)
            else:
                p1 = (p1 + vcount)
            poly.append(p1)
        normals = self.getNormals()
        _g = 0
        _g1 = g.getNormals()
        while (_g < len(_g1)):
            n = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            normals.append(n)
        uv = self.getUVs()
        uv2 = g.getUVs()
        if (len(uv) != len(uv2)):
            raise haxe_Exception.thrown((((("Different UV layer (" + Std.string(len(uv2))) + " should be ") + Std.string(len(uv))) + ")"))
        _g = 0
        _g1 = len(uv)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            uv1 = (uv[i] if i >= 0 and i < len(uv) else None)
            uv21 = (uv2[i] if i >= 0 and i < len(uv2) else None)
            count = (len(uv1.values) >> 1)
            _g2 = 0
            _g3 = uv21.values
            while (_g2 < len(_g3)):
                v = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                _this = uv1.values
                _this.append(v)
            _g4 = 0
            _g5 = uv21.index
            while (_g4 < len(_g5)):
                i1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                _this1 = uv1.index
                _this1.append((i1 + count))
        colors = self.getColors()
        colors2 = g.getColors()
        if (colors is not None):
            if (colors2 is not None):
                count = (len(colors.values) >> 2)
                _g = 0
                _g1 = colors2.values
                while (_g < len(_g1)):
                    v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    _this = colors.values
                    _this.append(v)
                _g = 0
                _g1 = colors2.index
                while (_g < len(_g1)):
                    i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    _this = colors.index
                    _this.append((i + count))
            else:
                count = (len(colors.values) >> 2)
                x = (len(g.getNormals()) / 3)
                count2 = None
                try:
                    count2 = int(x)
                except BaseException as _g:
                    None
                    count2 = None
                _this = colors.values
                _this.append(1)
                _this = colors.values
                _this.append(1)
                _this = colors.values
                _this.append(1)
                _this = colors.values
                _this.append(1)
                _g = 0
                _g1 = count2
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    _this = colors.index
                    _this.append(count)
        else:
            tmp = (colors2 is not None)
        m2 = g.getMaterials()
        if (m2 is None):
            mid = (materials[0] if 0 < len(materials) else None)
            _g = 0
            _g1 = polyCount
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                mats.append(mid)
        elif ((polyCount > 1) and ((len(m2) == 1))):
            m = (m2[0] if 0 < len(m2) else None)
            _g = 0
            _g1 = polyCount
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                mats.append((materials[m] if m >= 0 and m < len(materials) else None))
        else:
            _g = 0
            while (_g < len(m2)):
                m = (m2[_g] if _g >= 0 and _g < len(m2) else None)
                _g = (_g + 1)
                mats.append((materials[m] if m >= 0 and m < len(materials) else None))

    def getIndexes(self):
        count = 0
        pos = 0
        index = self.getPolygons()
        vout = []
        iout = []
        _g = 0
        while (_g < len(index)):
            i = (index[_g] if _g >= 0 and _g < len(index) else None)
            _g = (_g + 1)
            count = (count + 1)
            if (i < 0):
                python_internal_ArrayImpl._set(index, pos, (-i - 1))
                start = ((pos - count) + 1)
                _g1 = 0
                _g2 = count
                while (_g1 < _g2):
                    n = _g1
                    _g1 = (_g1 + 1)
                    vout.append(python_internal_ArrayImpl._get(index, (n + start)))
                _g3 = 0
                _g4 = (count - 2)
                while (_g3 < _g4):
                    n1 = _g3
                    _g3 = (_g3 + 1)
                    iout.append((start + n1))
                    iout.append(((start + count) - 1))
                    iout.append(((start + n1) + 1))
                python_internal_ArrayImpl._set(index, pos, i)
                count = 0
            pos = (pos + 1)
        return _hx_AnonObject({'vidx': vout, 'idx': iout})

    def getNormals(self):
        return self.processVectors("LayerElementNormal","Normals")

    def getTangents(self,opt = None):
        if (opt is None):
            opt = False
        return self.processVectors("LayerElementTangent","Tangents",opt)

    def getBinormals(self,opt = None):
        if (opt is None):
            opt = False
        return self.processVectors("LayerElementBinormal","Binormals",opt)

    def processVectors(self,layer,name,opt = None):
        if (opt is None):
            opt = False
        vect = hxd_fmt_fbx_FbxTools.get(self.root,((("null" if layer is None else layer) + ".") + ("null" if name is None else name)),opt)
        if (vect is None):
            return None
        nrm = hxd_fmt_fbx_FbxTools.getFloats(vect)
        if (hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(self.root,(("null" if layer is None else layer) + ".MappingInformationType")).props, 0)) == "ByVertice"):
            nout = []
            _g = 0
            _g1 = self.getPolygons()
            while (_g < len(_g1)):
                i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                vid = i
                if (vid < 0):
                    vid = (-vid - 1)
                nout.append(python_internal_ArrayImpl._get(nrm, (vid * 3)))
                nout.append(python_internal_ArrayImpl._get(nrm, ((vid * 3) + 1)))
                nout.append(python_internal_ArrayImpl._get(nrm, ((vid * 3) + 2)))
            nrm = nout
        return nrm

    def getColors(self):
        color = hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementColor",True)
        if (color is None):
            return None
        index = hxd_fmt_fbx_FbxTools.get(color,"ColorIndex",True)
        if (index is None):
            return None
        return _hx_AnonObject({'values': hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(color,"Colors")), 'index': hxd_fmt_fbx_FbxTools.getInts(index)})

    def getUVs(self):
        uvs = []
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"LayerElementUV")
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            index = hxd_fmt_fbx_FbxTools.get(v,"UVIndex",True)
            values = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(v,"UV"))
            index1 = None
            if (index is None):
                _g2 = []
                _g3 = 0
                _g4 = self.getPolygons()
                while (_g3 < len(_g4)):
                    i = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                    _g3 = (_g3 + 1)
                    if (i < 0):
                        _g2.append((-i - 1))
                    else:
                        _g2.append(i)
                index1 = _g2
            else:
                index1 = hxd_fmt_fbx_FbxTools.getInts(index)
            uvs.append(_hx_AnonObject({'values': values, 'index': index1}))
        return uvs

    def getGeomMatrix(self):
        rot = None
        trans = None
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.lib.getParent(self.root,"Model"),"Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
            _hx_local_1 = len(_g2)
            if (_hx_local_1 == 17):
                if (_g2 == "GeometricRotation"):
                    rot = h3d_col_Point(((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * 3.14159265358979323) / 180),((hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)) * 3.14159265358979323) / 180),((hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)) * 3.14159265358979323) / 180))
                else:
                    pass
            elif (_hx_local_1 == 20):
                if (_g2 == "GeometricTranslation"):
                    trans = h3d_col_Point((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * ((-1 if (self.lib.leftHand) else 1))),hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)),hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)))
                else:
                    pass
            else:
                pass
        if ((rot is None) and ((trans is None))):
            return None
        m = h3d_Matrix()
        if (rot is None):
            m.identity()
        else:
            m.initRotation(rot.x,rot.y,rot.z)
        if (trans is not None):
            m._41 = (m._41 + trans.x)
            m._42 = (m._42 + trans.y)
            m._43 = (m._43 + trans.z)
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lib = None
        _hx_o.root = None
hxd_fmt_fbx_Geometry._hx_class = hxd_fmt_fbx_Geometry
_hx_classes["hxd.fmt.fbx.Geometry"] = hxd_fmt_fbx_Geometry


class hxd_fmt_fbx_HMDOut(hxd_fmt_fbx_BaseLibrary):
    _hx_class_name = "hxd.fmt.fbx.HMDOut"
    _hx_is_interface = "False"
    __slots__ = ("d", "dataOut", "filePath", "tmp", "absoluteTexturePath", "optimizeSkin", "floatSkinIndexes")
    _hx_fields = ["d", "dataOut", "filePath", "tmp", "absoluteTexturePath", "optimizeSkin", "floatSkinIndexes"]
    _hx_methods = ["int32tof", "keepJoint", "buildTangents", "buildGeom", "addModels", "makeTexturePath", "makeSkin", "makePosition", "writeFloat", "writeFrame", "makeAnimation", "toHMD"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fmt_fbx_BaseLibrary


    def __init__(self,fileName):
        self.absoluteTexturePath = None
        self.filePath = None
        self.dataOut = None
        self.d = None
        self.floatSkinIndexes = False
        self.optimizeSkin = True
        self.tmp = haxe_io_Bytes.alloc(4)
        super().__init__(fileName)

    def int32tof(self,v):
        self.tmp.b[0] = ((v & 255) & 255)
        self.tmp.b[1] = (((v >> 8) & 255) & 255)
        self.tmp.b[2] = (((v >> 16) & 255) & 255)
        self.tmp.b[3] = (HxOverrides.rshift(v, 24) & 255)
        return self.tmp.getFloat(0)

    def keepJoint(self,j):
        if (not self.optimizeSkin):
            return True
        tmp = None
        _this = EReg("^Bip00[0-9] ","")
        _this.matchObj = python_lib_Re.search(_this.pattern,j.name)
        if (_this.matchObj is None):
            _this = EReg("^Bone[0-9][0-9][0-9]$","")
            _this.matchObj = python_lib_Re.search(_this.pattern,j.name)
            tmp = (_this.matchObj is not None)
        else:
            tmp = True
        if tmp:
            return False
        return True

    def buildTangents(self,geom):
        verts = geom.getVertices()
        normals = geom.getNormals()
        uvs = geom.getUVs()
        index = geom.getIndexes()
        tmp = Sys.getEnv("TMPDIR")
        if (tmp is None):
            tmp = Sys.getEnv("TMP")
        if (tmp is None):
            tmp = Sys.getEnv("TEMP")
        if (tmp is None):
            tmp = "."
        fileName = (((((("null" if tmp is None else tmp) + "/mikktspace_data") + Std.string((Date.now().date.timestamp() * 1000))) + "_") + Std.string(int((python_lib_Random.random() * 16777216)))) + ".bin")
        outFile = (("null" if fileName is None else fileName) + ".out")
        outputData = haxe_io_BytesBuffer()
        outputData.addInt32(len(index.vidx))
        outputData.addInt32(8)
        outputData.addInt32(0)
        outputData.addInt32(3)
        outputData.addInt32(6)
        _g = 0
        _g1 = len(index.vidx)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            vidx = (index.vidx[i] if i >= 0 and i < len(index.vidx) else None)
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(verts, (vidx * 3))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(verts, ((vidx * 3) + 1))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(verts, ((vidx * 3) + 2))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(normals, (i * 3))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(normals, ((i * 3) + 1))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(normals, ((i * 3) + 2))))
            uidx = python_internal_ArrayImpl._get((uvs[0] if 0 < len(uvs) else None).index, i)
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get((uvs[0] if 0 < len(uvs) else None).values, (uidx * 2))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get((uvs[0] if 0 < len(uvs) else None).values, ((uidx * 2) + 1))))
        outputData.addInt32(len(index.vidx))
        _g = 0
        _g1 = len(index.vidx)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            outputData.addInt32(i)
        sys_io_File.saveBytes(fileName,outputData.getBytes())
        ret = None
        try:
            ret = Sys.command("mikktspace",[fileName, outFile])
        except BaseException as _g:
            None
            ret = -1
        if (ret != 0):
            sys_FileSystem.deleteFile(fileName)
            raise haxe_Exception.thrown("Failed to call 'mikktspace' executable required to generate tangent data. Please ensure it's in your PATH")
        _hx_bytes = sys_io_File.getBytes(outFile)
        arr = []
        _g = 0
        _g1 = (len(index.vidx) * 4)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(arr, i, _hx_bytes.getFloat((i << 2)))
        sys_FileSystem.deleteFile(fileName)
        sys_FileSystem.deleteFile(outFile)
        return arr

    def buildGeom(self,geom,skin,dataOut,genTangents):
        g = hxd_fmt_hmd_Geometry()
        verts = geom.getVertices()
        normals = geom.getNormals()
        uvs = geom.getUVs()
        colors = geom.getColors()
        mats = geom.getMaterials()
        if (colors is not None):
            hasData = False
            _g = 0
            _g1 = colors.values
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v < 0.99):
                    hasData = True
                    break
            if (not hasData):
                colors = None
        tangents = (self.buildTangents(geom) if genTangents else None)
        g.vertexFormat = [hxd_fmt_hmd_GeometryFormat("position",3)]
        if (normals is not None):
            _this = g.vertexFormat
            x = hxd_fmt_hmd_GeometryFormat("normal",3)
            _this.append(x)
        if (tangents is not None):
            _this = g.vertexFormat
            x = hxd_fmt_hmd_GeometryFormat("tangent",3)
            _this.append(x)
        _g = 0
        _g1 = len(uvs)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this = g.vertexFormat
            x = hxd_fmt_hmd_GeometryFormat(("uv" + HxOverrides.stringOrNull((("" if ((i == 0)) else ("" + Std.string(((i + 1)))))))),2)
            _this.append(x)
        if (colors is not None):
            _this = g.vertexFormat
            x = hxd_fmt_hmd_GeometryFormat("color",3)
            _this.append(x)
        if (skin is not None):
            if ((self.bonesPerVertex <= 0) or ((self.bonesPerVertex > 4))):
                raise haxe_Exception.thrown("assert")
            _this = g.vertexFormat
            x = hxd_fmt_hmd_GeometryFormat("weights",python_internal_ArrayImpl._get([1, 2, 3, 4], (self.bonesPerVertex - 1)))
            _this.append(x)
            _this = g.vertexFormat
            x = hxd_fmt_hmd_GeometryFormat("indexes",(python_internal_ArrayImpl._get([1, 2, 3, 4], (self.bonesPerVertex - 1)) if (self.floatSkinIndexes) else 9))
            _this.append(x)
        stride = 0
        _g = 0
        _g1 = g.vertexFormat
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            stride = (stride + ((f.format & 7)))
        g.vertexStride = stride
        g.vertexCount = 0
        gm = geom.getGeomMatrix()
        this1 = list()
        vbuf = this1
        ibufs = []
        if ((skin is not None) and ((skin.splitJoints is not None))):
            _g = 0
            _g1 = skin.splitJoints
            while (_g < len(_g1)):
                _ = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                ibufs.append([])
        g.bounds = h3d_col_Bounds()
        this1 = [None]*stride
        tmpBuf = this1
        vertexRemap = list()
        index = geom.getPolygons()
        count = 0
        matPos = 0
        stri = 0
        lookup = haxe_ds_IntMap()
        tmp_x = 0.
        tmp_y = 0.
        tmp_z = 0.
        _g = 0
        _g1 = len(index)
        while (_g < _g1):
            pos = _g
            _g = (_g + 1)
            i = (index[pos] if pos >= 0 and pos < len(index) else None)
            count = (count + 1)
            if (i >= 0):
                continue
            python_internal_ArrayImpl._set(index, pos, (-i - 1))
            start = ((pos - count) + 1)
            _g2 = 0
            _g3 = count
            while (_g2 < _g3):
                n = _g2
                _g2 = (_g2 + 1)
                k = (n + start)
                vidx = (index[k] if k >= 0 and k < len(index) else None)
                p = 0
                x = python_internal_ArrayImpl._get(verts, (vidx * 3))
                y = python_internal_ArrayImpl._get(verts, ((vidx * 3) + 1))
                z = python_internal_ArrayImpl._get(verts, ((vidx * 3) + 2))
                if (gm is not None):
                    x1 = x
                    y1 = y
                    z1 = z
                    if (z1 is None):
                        z1 = 0.
                    if (y1 is None):
                        y1 = 0.
                    if (x1 is None):
                        x1 = 0.
                    tmp_x = x1
                    tmp_y = y1
                    tmp_z = z1
                    px = ((((tmp_x * gm._11) + ((tmp_y * gm._21))) + ((tmp_z * gm._31))) + gm._41)
                    py = ((((tmp_x * gm._12) + ((tmp_y * gm._22))) + ((tmp_z * gm._32))) + gm._42)
                    pz = ((((tmp_x * gm._13) + ((tmp_y * gm._23))) + ((tmp_z * gm._33))) + gm._43)
                    tmp_x = px
                    tmp_y = py
                    tmp_z = pz
                    x = tmp_x
                    y = tmp_y
                    z = tmp_z
                index1 = p
                p = (p + 1)
                tmpBuf[index1] = x
                index2 = p
                p = (p + 1)
                tmpBuf[index2] = y
                index3 = p
                p = (p + 1)
                tmpBuf[index3] = z
                _this = g.bounds
                if (x < _this.xMin):
                    _this.xMin = x
                if (x > _this.xMax):
                    _this.xMax = x
                if (y < _this.yMin):
                    _this.yMin = y
                if (y > _this.yMax):
                    _this.yMax = y
                if (z < _this.zMin):
                    _this.zMin = z
                if (z > _this.zMax):
                    _this.zMax = z
                if (normals is not None):
                    nx = python_internal_ArrayImpl._get(normals, (k * 3))
                    ny = python_internal_ArrayImpl._get(normals, ((k * 3) + 1))
                    nz = python_internal_ArrayImpl._get(normals, ((k * 3) + 2))
                    index4 = p
                    p = (p + 1)
                    tmpBuf[index4] = nx
                    index5 = p
                    p = (p + 1)
                    tmpBuf[index5] = ny
                    index6 = p
                    p = (p + 1)
                    tmpBuf[index6] = nz
                if (tangents is not None):
                    index7 = p
                    p = (p + 1)
                    val = self.round(python_internal_ArrayImpl._get(tangents, (k * 4)))
                    tmpBuf[index7] = val
                    index8 = p
                    p = (p + 1)
                    val1 = self.round(python_internal_ArrayImpl._get(tangents, ((k * 4) + 1)))
                    tmpBuf[index8] = val1
                    index9 = p
                    p = (p + 1)
                    val2 = self.round(python_internal_ArrayImpl._get(tangents, ((k * 4) + 2)))
                    tmpBuf[index9] = val2
                    if (python_internal_ArrayImpl._get(tangents, ((k * 4) + 3)) < 0):
                        _g4 = (p - 3)
                        _g5 = tmpBuf
                        val3 = (_g5[_g4] * 0.5)
                        _g5[_g4] = val3
                        _g6 = (p - 2)
                        _g7 = tmpBuf
                        val4 = (_g7[_g6] * 0.5)
                        _g7[_g6] = val4
                        _g8 = (p - 1)
                        _g9 = tmpBuf
                        val5 = (_g9[_g8] * 0.5)
                        _g9[_g8] = val5
                _g10 = 0
                while (_g10 < len(uvs)):
                    tuvs = (uvs[_g10] if _g10 >= 0 and _g10 < len(uvs) else None)
                    _g10 = (_g10 + 1)
                    iuv = (tuvs.index[k] if k >= 0 and k < len(tuvs.index) else None)
                    index10 = p
                    p = (p + 1)
                    val6 = python_internal_ArrayImpl._get(tuvs.values, (iuv * 2))
                    tmpBuf[index10] = val6
                    index11 = p
                    p = (p + 1)
                    val7 = (1 - python_internal_ArrayImpl._get(tuvs.values, ((iuv * 2) + 1)))
                    tmpBuf[index11] = val7
                if (colors is not None):
                    icol = (colors.index[k] if k >= 0 and k < len(colors.index) else None)
                    index12 = p
                    p = (p + 1)
                    val8 = python_internal_ArrayImpl._get(colors.values, (icol * 4))
                    tmpBuf[index12] = val8
                    index13 = p
                    p = (p + 1)
                    val9 = python_internal_ArrayImpl._get(colors.values, ((icol * 4) + 1))
                    tmpBuf[index13] = val9
                    index14 = p
                    p = (p + 1)
                    val10 = python_internal_ArrayImpl._get(colors.values, ((icol * 4) + 2))
                    tmpBuf[index14] = val10
                if (skin is not None):
                    k1 = (vidx * skin.bonesPerVertex)
                    idx = 0
                    _g11 = 0
                    _g12 = skin.bonesPerVertex
                    while (_g11 < _g12):
                        i1 = _g11
                        _g11 = (_g11 + 1)
                        index15 = p
                        p = (p + 1)
                        val11 = skin.vertexWeights[(k1 + i1)]
                        tmpBuf[index15] = val11
                        idx = ((skin.vertexJoints[(k1 + i1)] << ((8 * i1))) | idx)
                    if self.floatSkinIndexes:
                        _g13 = 0
                        _g14 = skin.bonesPerVertex
                        while (_g13 < _g14):
                            i2 = _g13
                            _g13 = (_g13 + 1)
                            index16 = p
                            p = (p + 1)
                            val12 = (skin.vertexJoints[(k1 + i2)] * 3)
                            tmpBuf[index16] = val12
                    else:
                        index17 = p
                        p = (p + 1)
                        val13 = self.int32tof(idx)
                        tmpBuf[index17] = val13
                total = 0.
                _g15 = 0
                _g16 = stride
                while (_g15 < _g16):
                    i3 = _g15
                    _g15 = (_g15 + 1)
                    total = (total + tmpBuf[i3])
                itotal = None
                try:
                    itotal = int(HxOverrides.modf((total * 100), 268435455))
                except BaseException as _g17:
                    None
                    itotal = None
                itotal1 = itotal
                found = None
                vids = lookup.h.get(itotal1,None)
                if (vids is None):
                    vids = []
                    lookup.set(itotal1,vids)
                _g18 = 0
                while (_g18 < len(vids)):
                    vid = (vids[_g18] if _g18 >= 0 and _g18 < len(vids) else None)
                    _g18 = (_g18 + 1)
                    same = True
                    p1 = (vid * stride)
                    _g19 = 0
                    _g20 = stride
                    while (_g19 < _g20):
                        i4 = _g19
                        _g19 = (_g19 + 1)
                        key = p1
                        p1 = (p1 + 1)
                        if (python_internal_ArrayImpl._get(vbuf, key) != tmpBuf[i4]):
                            same = False
                            break
                    if same:
                        found = vid
                        break
                if (found is None):
                    found = g.vertexCount
                    g.vertexCount = (g.vertexCount + 1)
                    _g21 = 0
                    _g22 = stride
                    while (_g21 < _g22):
                        i5 = _g21
                        _g21 = (_g21 + 1)
                        v = tmpBuf[i5]
                        vbuf.append(v)
                    vids.append(found)
                vertexRemap.append(found)
            if ((skin is not None) and ((skin.splitJoints is not None))):
                _g23 = 0
                _g24 = (count - 2)
                while (_g23 < _g24):
                    n1 = _g23
                    _g23 = (_g23 + 1)
                    index18 = stri
                    stri = (stri + 1)
                    idx1 = python_internal_ArrayImpl._get(ibufs, skin.triangleGroups[index18])
                    idx1.append(python_internal_ArrayImpl._get(vertexRemap, (start + n1)))
                    idx1.append(python_internal_ArrayImpl._get(vertexRemap, ((start + count) - 1)))
                    idx1.append(python_internal_ArrayImpl._get(vertexRemap, ((start + n1) + 1)))
            else:
                mid = None
                if (mats is None):
                    mid = 0
                else:
                    mid = (mats[matPos] if matPos >= 0 and matPos < len(mats) else None)
                    if (len(mats) > 1):
                        matPos = (matPos + 1)
                idx2 = (ibufs[mid] if mid >= 0 and mid < len(ibufs) else None)
                if (idx2 is None):
                    idx2 = []
                    python_internal_ArrayImpl._set(ibufs, mid, idx2)
                _g25 = 0
                _g26 = (count - 2)
                while (_g25 < _g26):
                    n2 = _g25
                    _g25 = (_g25 + 1)
                    idx2.append(python_internal_ArrayImpl._get(vertexRemap, (start + n2)))
                    idx2.append(python_internal_ArrayImpl._get(vertexRemap, ((start + count) - 1)))
                    idx2.append(python_internal_ArrayImpl._get(vertexRemap, ((start + n2) + 1)))
            python_internal_ArrayImpl._set(index, pos, i)
            count = 0
        g.vertexPosition = len(dataOut.b.b)
        _g = 0
        _g1 = len(vbuf)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            f = python_internal_ArrayImpl._get(vbuf, i)
            self.dataOut.writeFloat((0 if ((f == 0)) else f))
        g.indexPosition = len(dataOut.b.b)
        g.indexCounts = []
        matMap = []
        matCount = 0
        is32 = (g.vertexCount > 65536)
        _g = 0
        while (_g < len(ibufs)):
            idx = (ibufs[_g] if _g >= 0 and _g < len(ibufs) else None)
            _g = (_g + 1)
            if (idx is None):
                matCount = (matCount + 1)
                continue
            x = matCount
            matCount = (matCount + 1)
            matMap.append(x)
            _this = g.indexCounts
            x1 = len(idx)
            _this.append(x1)
            if is32:
                _g1 = 0
                while (_g1 < len(idx)):
                    i = (idx[_g1] if _g1 >= 0 and _g1 < len(idx) else None)
                    _g1 = (_g1 + 1)
                    dataOut.writeInt32(i)
            else:
                _g2 = 0
                while (_g2 < len(idx)):
                    i1 = (idx[_g2] if _g2 >= 0 and _g2 < len(idx) else None)
                    _g2 = (_g2 + 1)
                    dataOut.writeUInt16(i1)
        if ((skin is not None) and ((skin.splitJoints is not None))):
            matMap = None
        return _hx_AnonObject({'g': g, 'materials': matMap})

    def addModels(self,includeGeometry):
        _gthis = self
        root = self.buildHierarchy().root
        objects = []
        joints = []
        skins = []
        foundSkin = None
        uid = 0
        indexRec = None
        def _hx_local_2(t):
            if t.isJoint:
                joints.append(t)
            else:
                isSkin = False
                if (foundSkin is None):
                    _g = 0
                    _g1 = t.childs
                    while (_g < len(_g1)):
                        c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                        _g = (_g + 1)
                        if c.isJoint:
                            isSkin = True
                            break
                else:
                    isSkin = (python_internal_ArrayImpl.indexOf(foundSkin,t,None) >= 0)
                if isSkin:
                    skins.append(t)
                else:
                    objects.append(t)
            _g = 0
            _g1 = t.childs
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                indexRec(c)
        indexRec = _hx_local_2
        indexRec(root)
        _g = 0
        while (_g < len(joints)):
            o = (joints[_g] if _g >= 0 and _g < len(joints) else None)
            _g = (_g + 1)
            if o.isMesh:
                raise haxe_Exception.thrown("assert")
            j = h3d_anim_Joint()
            self.getDefaultMatrixes(o.model)
            j.index = hxd_fmt_fbx_FbxTools.getId(o.model)
            j.name = hxd_fmt_fbx_FbxTools.getName(o.model)
            o.joint = j
            if (o.parent is not None):
                j.parent = o.parent.joint
                if o.parent.isJoint:
                    _this = o.parent.joint.subs
                    _this.append(j)
        foundSkin = []
        _g = 0
        while (_g < len(skins)):
            o = (skins[_g] if _g >= 0 and _g < len(skins) else None)
            _g = (_g + 1)
            loopRec = [None]
            def _hx_local_7(loopRec):
                def _hx_local_5(o):
                    _g = 0
                    _g1 = o.childs
                    while (_g < len(_g1)):
                        j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                        _g = (_g + 1)
                        if (not j.isJoint):
                            continue
                        s = _gthis.getParent(j.model,"Deformer",True)
                        if (s is not None):
                            return s
                        s = (loopRec[0] if 0 < len(loopRec) else None)(j)
                        if (s is not None):
                            return s
                    return None
                return _hx_local_5
            python_internal_ArrayImpl._set(loopRec, 0, _hx_local_7(loopRec))
            subDef = (loopRec[0] if 0 < len(loopRec) else None)(o)
            if (subDef is None):
                continue
            _hx_def = self.getParent(subDef,"Deformer")
            geoms = self.getParents(_hx_def,"Geometry")
            if (len(geoms) == 0):
                continue
            if (len(geoms) > 1):
                raise haxe_Exception.thrown("Single skin applied to multiple geometries not supported")
            models = self.getParents((geoms[0] if 0 < len(geoms) else None),"Model")
            if (len(models) == 0):
                continue
            if (len(models) > 1):
                raise haxe_Exception.thrown("Single skin applied to multiple models not supported")
            m = (models[0] if 0 < len(models) else None)
            _g1 = 0
            while (_g1 < len(objects)):
                o2 = (objects[_g1] if _g1 >= 0 and _g1 < len(objects) else None)
                _g1 = (_g1 + 1)
                if (o2.model == m):
                    foundSkin.append(o)
                    o2.skin = o
                    if (o.model is None):
                        o.model = m
                    self.ignoreMissingObject(hxd_fmt_fbx_FbxTools.getId(m))
                    p = o.parent
                    if (p != o2):
                        python_internal_ArrayImpl.remove(o2.parent.childs,o2)
                        o2.parent = p
                        if (p is not None):
                            _this = p.childs
                            _this.append(o2)
                        else:
                            root = o2
                    if (p is not None):
                        python_internal_ArrayImpl.remove(p.childs,o)
                    _g2 = 0
                    _g3 = list(o.childs)
                    while (_g2 < len(_g3)):
                        c = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                        _g2 = (_g2 + 1)
                        if (not c.isJoint):
                            python_internal_ArrayImpl.remove(o.childs,c)
                            _this1 = o2.childs
                            _this1.append(c)
                            c.parent = o2
                    break
        if (not includeGeometry):
            return
        objects = []
        if ((len(root.childs) <= 1) and ((root.model is None))):
            root = (root.childs[0] if 0 < len(root.childs) else None)
            root.parent = None
        if (root is not None):
            indexRec(root)
        hskins = haxe_ds_IntMap()
        tmpGeom = haxe_ds_IntMap()
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry")
        while (_g < len(_g1)):
            g = [(_g1[_g] if _g >= 0 and _g < len(_g1) else None)]
            _g = (_g + 1)
            def _hx_local_12():
                def _hx_local_11(_):
                    pass
                return _hx_local_11
            def _hx_local_14(g):
                def _hx_local_13():
                    x = (len(hxd_fmt_fbx_Geometry(_gthis,(g[0] if 0 < len(g) else None)).getVertices()) / 3)
                    try:
                        return int(x)
                    except BaseException as _g:
                        None
                        return None
                return _hx_local_13
            tmpGeom.set(hxd_fmt_fbx_FbxTools.getId((g[0] if 0 < len(g) else None)),_hx_AnonObject({'setSkin': _hx_local_12(), 'vertexCount': _hx_local_14(g)}))
        hgeom = haxe_ds_IntMap()
        hmat = haxe_ds_IntMap()
        index = 0
        _g = 0
        while (_g < len(objects)):
            o = (objects[_g] if _g >= 0 and _g < len(objects) else None)
            _g = (_g + 1)
            tmp = index
            index = (index + 1)
            o.index = tmp
            model = hxd_fmt_hmd_Model()
            ref = (o if ((o.skin is None)) else o.skin)
            model.name = (None if ((o.model is None)) else hxd_fmt_fbx_FbxTools.getName(o.model))
            model.parent = (-1 if (((o.parent is None) or o.parent.isJoint)) else o.parent.index)
            model.follow = (hxd_fmt_fbx_FbxTools.getName(o.parent.model) if (((o.parent is not None) and o.parent.isJoint)) else None)
            m = (hxd_fmt_fbx_DefaultMatrixes() if ((ref.model is None)) else self.getDefaultMatrixes(ref.model))
            p = hxd_fmt_hmd_Position()
            p.x = (0 if ((m.trans is None)) else -m.trans.x)
            p.y = (0 if ((m.trans is None)) else m.trans.y)
            p.z = (0 if ((m.trans is None)) else m.trans.z)
            p.sx = (1 if ((m.scale is None)) else m.scale.x)
            p.sy = (1 if ((m.scale is None)) else m.scale.y)
            p.sz = (1 if ((m.scale is None)) else m.scale.z)
            if ((o.model is not None) and ((hxd_fmt_fbx_FbxTools.getType(o.model) == "Camera"))):
                props = self.getChild(o.model,"NodeAttribute")
                fov = 45.
                ratio = 1.77777777777777768
                _g1 = 0
                _g2 = hxd_fmt_fbx_FbxTools.getAll(props,"Properties70.P")
                while (_g1 < len(_g2)):
                    p1 = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                    _g1 = (_g1 + 1)
                    _g3 = hxd_fmt_fbx_FbxTools.toString((p1.props[0] if 0 < len(p1.props) else None))
                    _hx_local_17 = len(_g3)
                    if (_hx_local_17 == 15):
                        if (_g3 == "FilmAspectRatio"):
                            ratio = hxd_fmt_fbx_FbxTools.toFloat((p1.props[4] if 4 < len(p1.props) else None))
                        else:
                            pass
                    elif (_hx_local_17 == 11):
                        if (_g3 == "FieldOfView"):
                            fov = hxd_fmt_fbx_FbxTools.toFloat((p1.props[4] if 4 < len(p1.props) else None))
                        else:
                            pass
                    else:
                        pass
                fovY = (((2 * Math.atan((Math.tan((((fov * 0.5) * 3.14159265358979323) / 180)) / ratio))) * 180) / 3.14159265358979323)
                if (model.props is None):
                    model.props = []
                _this = model.props
                _this.append(hxd_fmt_hmd_Property.CameraFOVY(fovY))
            q = m.toQuaternion(True)
            q.normalize()
            if (q.w < 0):
                q.x = -q.x
                q.y = -q.y
                q.z = -q.z
                q.w = -q.w
            p.qx = q.x
            p.qy = q.y
            p.qz = q.z
            model.position = p
            model.geometry = -1
            _this1 = self.d.models
            _this1.append(model)
            if (not o.isMesh):
                continue
            mids = []
            hasNormalMap = False
            _g4 = 0
            _g5 = self.getChilds(o.model,"Material")
            while (_g4 < len(_g5)):
                m1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                key = hxd_fmt_fbx_FbxTools.getId(m1)
                mid = hmat.h.get(key,None)
                if (mid is not None):
                    mids.append(mid)
                    m2 = python_internal_ArrayImpl._get(self.d.materials, mid)
                    hasNormalMap = (m2.normalMap is not None)
                    continue
                mat = hxd_fmt_hmd_Material()
                mid = len(self.d.materials)
                mids.append(mid)
                hmat.set(hxd_fmt_fbx_FbxTools.getId(m1),mid)
                _this2 = self.d.materials
                _this2.append(mat)
                mat.name = hxd_fmt_fbx_FbxTools.getName(m1)
                mat.blendMode = None
                _g6 = 0
                _g7 = hxd_fmt_fbx_FbxTools.getAll(m1,"Properties70.P")
                while (_g6 < len(_g7)):
                    p2 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                    _g6 = (_g6 + 1)
                    pval = (p2.props[4] if 4 < len(p2.props) else None)
                    if (hxd_fmt_fbx_FbxTools.toString((p2.props[0] if 0 < len(p2.props) else None)) == "Opacity"):
                        v = hxd_fmt_fbx_FbxTools.toFloat(pval)
                        if (((v < 1) and ((v > 0.98))) and ((mat.blendMode is None))):
                            mat.blendMode = h2d_BlendMode.Add
                texture = self.getSpecChild(m1,"DiffuseColor")
                if (texture is not None):
                    path = self.makeTexturePath(texture)
                    if (path is not None):
                        mat.diffuseTexture = path
                mat.normalMap = self.makeTexturePath(self.getSpecChild(m1,"NormalMap"))
                if (mat.normalMap is not None):
                    hasNormalMap = True
                spec = self.getSpecChild(m1,"SpecularFactor")
                if (spec is None):
                    spec = self.getSpecChild(m1,"SpecularColor")
                mat.specularTexture = self.makeTexturePath(spec)
                if ((mat.normalMap is not None) or ((mat.specularTexture is not None))):
                    if (mat.props is None):
                        mat.props = []
                    _this3 = mat.props
                    _this3.append(hxd_fmt_hmd_Property.HasExtraTextures)
                transp = self.getSpecChild(m1,"TransparentColor")
                if (transp is not None):
                    path1 = hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(transp,"FileName").props, 0))
                    if (path1 != ""):
                        path1 = path1.lower()
                        _this4 = path1.split(".")
                        ext = (None if ((len(_this4) == 0)) else _this4.pop())
                        if ((texture is not None) and ((path1 == hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(texture,"FileName").props, 0)).lower()))):
                            if (((mat.blendMode is None) and ((ext != "jpg"))) and ((ext != "jpeg"))):
                                mat.blendMode = h2d_BlendMode.Alpha
                        else:
                            raise haxe_Exception.thrown("Alpha texture that is different from diffuse is not supported in HMD")
                if (mat.blendMode is None):
                    mat.blendMode = h2d_BlendMode._hx_None
            g1 = self.getChild(o.model,"Geometry")
            skin = None
            if (o.skin is not None):
                rootJoints = []
                _g8 = 0
                _g9 = o.skin.childs
                while (_g8 < len(_g9)):
                    c = (_g9[_g8] if _g8 >= 0 and _g8 < len(_g9) else None)
                    _g8 = (_g8 + 1)
                    if c.isJoint:
                        x = c.joint
                        rootJoints.append(x)
                skin = self.createSkin(hskins,tmpGeom,rootJoints,self.bonesPerVertex)
                if (len(skin.boundJoints) > hxd_fmt_fbx_BaseLibrary.maxBonesPerSkin):
                    g2 = hxd_fmt_fbx_Geometry(self,g1)
                    idx = g2.getIndexes()
                    tmp1 = hxd_fmt_fbx_BaseLibrary.maxBonesPerSkin
                    _g10 = []
                    _g11 = 0
                    _g12 = idx.idx
                    while (_g11 < len(_g12)):
                        i = (_g12[_g11] if _g11 >= 0 and _g11 < len(_g12) else None)
                        _g11 = (_g11 + 1)
                        x1 = (idx.vidx[i] if i >= 0 and i < len(idx.vidx) else None)
                        _g10.append(x1)
                    skin.split(tmp1,_g10,(g2.getMaterialByTriangle() if ((len(mids) > 1)) else None))
                model.skin = self.makeSkin(skin,o.skin)
            key1 = hxd_fmt_fbx_FbxTools.getId(g1)
            gdata = hgeom.h.get(key1,None)
            if (gdata is None):
                geom = self.buildGeom(hxd_fmt_fbx_Geometry(self,g1),skin,self.dataOut,hasNormalMap)
                gdata = _hx_AnonObject({'gid': len(self.d.geometries), 'materials': geom.materials})
                _this5 = self.d.geometries
                x2 = geom.g
                _this5.append(x2)
                hgeom.set(hxd_fmt_fbx_FbxTools.getId(g1),gdata)
            model.geometry = gdata.gid
            if (len(mids) == 0):
                mat1 = hxd_fmt_hmd_Material()
                mat1.blendMode = h2d_BlendMode._hx_None
                mat1.name = "default"
                mid1 = len(self.d.materials)
                _this6 = self.d.materials
                _this6.append(mat1)
                mids = [mid1]
            if (gdata.materials is None):
                model.materials = mids
            else:
                _g13 = []
                _g14 = 0
                _g15 = gdata.materials
                while (_g14 < len(_g15)):
                    id = (_g15[_g14] if _g14 >= 0 and _g14 < len(_g15) else None)
                    _g14 = (_g14 + 1)
                    _g13.append((mids[id] if id >= 0 and id < len(mids) else None))
                model.materials = _g13

    def makeTexturePath(self,tex):
        if (tex is None):
            return None
        path = hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(tex,"FileName").props, 0))
        if (path == ""):
            return None
        _this = path.split("\\")
        path = "/".join([python_Boot.toString1(x1,'') for x1 in _this])
        if (not self.absoluteTexturePath):
            tmp = None
            if (self.filePath is not None):
                s = path.lower()
                start = self.filePath
                tmp = s.startswith(start)
            else:
                tmp = False
            if tmp:
                path = HxString.substr(path,len(self.filePath),None)
            else:
                k = path.split("/res/")
                if (len(k) > 1):
                    if (len(k) != 0):
                        k.pop(0)
                    path = "/res/".join([python_Boot.toString1(x1,'') for x1 in k])
        return path

    def makeSkin(self,skin,obj):
        s = hxd_fmt_hmd_Skin()
        s.name = hxd_fmt_fbx_FbxTools.getName(obj.model)
        s.joints = []
        _g = 0
        _g1 = skin.allJoints
        while (_g < len(_g1)):
            jo = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            j = hxd_fmt_hmd_SkinJoint()
            j.name = jo.name
            j.parent = (-1 if ((jo.parent is None)) else jo.parent.index)
            j.bind = jo.bindIndex
            j.position = self.makePosition(jo.defMat)
            if (jo.transPos is not None):
                j.transpos = self.makePosition(jo.transPos)
                if (((j.transpos.sx != 1) or ((j.transpos.sy != 1))) or ((j.transpos.sz != 1))):
                    tmp = jo.transPos.clone()
                    tmp.transpose()
                    v = None
                    if (v is None):
                        v = h3d_Vector()
                    f = (((tmp._11 * tmp._11) + ((tmp._12 * tmp._12))) + ((tmp._13 * tmp._13)))
                    v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
                    f1 = (((tmp._21 * tmp._21) + ((tmp._22 * tmp._22))) + ((tmp._23 * tmp._23)))
                    v.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
                    f2 = (((tmp._31 * tmp._31) + ((tmp._32 * tmp._32))) + ((tmp._33 * tmp._33)))
                    v.z = (Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))
                    if ((((tmp._11 * (((tmp._22 * tmp._33) - ((tmp._23 * tmp._32))))) + ((tmp._12 * (((tmp._23 * tmp._31) - ((tmp._21 * tmp._33))))))) + ((tmp._13 * (((tmp._21 * tmp._32) - ((tmp._22 * tmp._31))))))) < 0):
                        v.x = (v.x * -1)
                        v.y = (v.y * -1)
                        v.z = (v.z * -1)
                    s1 = v
                    tmp.prependScale((1 / s1.x),(1 / s1.y),(1 / s1.z))
                    tmp.transpose()
                    j.transpos = self.makePosition(tmp)
                    j.transpos.sx = self.round(s1.x)
                    j.transpos.sy = self.round(s1.y)
                    j.transpos.sz = self.round(s1.z)
            _this = s.joints
            _this.append(j)
        if (skin.splitJoints is not None):
            s.split = []
            _g = 0
            _g1 = skin.splitJoints
            while (_g < len(_g1)):
                sp = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                ss = hxd_fmt_hmd_SkinSplit()
                ss.materialIndex = sp.material
                _g2 = []
                _g3 = 0
                _g4 = sp.joints
                while (_g3 < len(_g4)):
                    j = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                    _g3 = (_g3 + 1)
                    x = j.index
                    _g2.append(x)
                ss.joints = _g2
                _this = s.split
                _this.append(ss)
        return s

    def makePosition(self,m):
        p = hxd_fmt_hmd_Position()
        v = None
        if (v is None):
            v = h3d_Vector()
        f = (((m._11 * m._11) + ((m._12 * m._12))) + ((m._13 * m._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((m._21 * m._21) + ((m._22 * m._22))) + ((m._23 * m._23)))
        v.y = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f = (((m._31 * m._31) + ((m._32 * m._32))) + ((m._33 * m._33)))
        v.z = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        if ((((m._11 * (((m._22 * m._33) - ((m._23 * m._32))))) + ((m._12 * (((m._23 * m._31) - ((m._21 * m._33))))))) + ((m._13 * (((m._21 * m._32) - ((m._22 * m._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        s = v
        q = h3d_Quat()
        q.initRotateMatrix(m)
        q.normalize()
        if (q.w < 0):
            q.x = -q.x
            q.y = -q.y
            q.z = -q.z
            q.w = -q.w
        p.sx = self.round(s.x)
        p.sy = self.round(s.y)
        p.sz = self.round(s.z)
        p.qx = self.round(q.x)
        p.qy = self.round(q.y)
        p.qz = self.round(q.z)
        p.x = self.round(m._41)
        p.y = self.round(m._42)
        p.z = self.round(m._43)
        return p

    def writeFloat(self,f):
        self.dataOut.writeFloat((0 if ((f == 0)) else f))

    def writeFrame(self,o,fid):
        if (self.d.version < 3):
            return
        if (o.frames is not None):
            f = o.frames[fid]
            if o.hasPosition:
                f1 = f.tx
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                f1 = f.ty
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                f1 = f.tz
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
            if o.hasRotation:
                f1 = ((((f.qx * f.qx) + ((f.qy * f.qy))) + ((f.qz * f.qz))) + ((f.qw * f.qw)))
                ql = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
                if ((ql * f.qw) < 0):
                    ql = -ql
                f1 = self.round((f.qx / ql))
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                f1 = self.round((f.qy / ql))
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                f1 = self.round((f.qz / ql))
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
            if o.hasScale:
                f1 = f.sx
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                f1 = f.sy
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                f1 = f.sz
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
        if (o.uvs is not None):
            f = o.uvs[(fid << 1)]
            self.dataOut.writeFloat((0 if ((f == 0)) else f))
            f = o.uvs[(((fid << 1)) + 1)]
            self.dataOut.writeFloat((0 if ((f == 0)) else f))
        if (o.alphas is not None):
            f = o.alphas[fid]
            self.dataOut.writeFloat((0 if ((f == 0)) else f))
        if (o.propValues is not None):
            f = o.propValues[fid]
            self.dataOut.writeFloat((0 if ((f == 0)) else f))

    def makeAnimation(self,anim):
        a = hxd_fmt_hmd_Animation()
        a.name = anim.name
        a.loop = True
        a.speed = 1
        a.sampling = anim.sampling
        a.frames = anim.frameCount
        a.objects = []
        a.dataPosition = len(self.dataOut.b.b)
        if (self.animationEvents is not None):
            _g = []
            _g1 = 0
            _g2 = self.animationEvents
            while (_g1 < len(_g2)):
                a1 = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                e = hxd_fmt_hmd_AnimationEvent()
                e.frame = a1.frame
                e.data = a1.data
                _g.append(e)
            a.events = _g
        objects = anim.objects
        def _hx_local_1(o1,o2):
            return Reflect.compare(o1.objectName,o2.objectName)
        objects.sort(key= python_lib_Functools.cmp_to_key(_hx_local_1))
        animatedObjects = []
        _g = 0
        while (_g < len(objects)):
            obj = (objects[_g] if _g >= 0 and _g < len(objects) else None)
            _g = (_g + 1)
            o = hxd_fmt_hmd_AnimationObject()
            count = 0
            o.name = obj.objectName
            this1 = 0
            o.flags = this1
            o.props = []
            if (obj.frames is not None):
                count = len(obj.frames)
                if (obj.hasPosition or ((self.d.version < 3))):
                    o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))
                if obj.hasRotation:
                    o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))
                if obj.hasScale:
                    o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))
                if (self.d.version < 3):
                    _g1 = 0
                    _g2 = obj.frames
                    while (_g1 < len(_g2)):
                        f = _g2[_g1]
                        _g1 = (_g1 + 1)
                        if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))) != 0):
                            f1 = f.tx
                            self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                            f2 = f.ty
                            self.dataOut.writeFloat((0 if ((f2 == 0)) else f2))
                            f3 = f.tz
                            self.dataOut.writeFloat((0 if ((f3 == 0)) else f3))
                        if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))) != 0):
                            f4 = ((((f.qx * f.qx) + ((f.qy * f.qy))) + ((f.qz * f.qz))) + ((f.qw * f.qw)))
                            ql = (Math.NaN if ((f4 < 0)) else python_lib_Math.sqrt(f4))
                            if (f.qw < 0):
                                ql = -ql
                            f5 = self.round((f.qx / ql))
                            self.dataOut.writeFloat((0 if ((f5 == 0)) else f5))
                            f6 = self.round((f.qy / ql))
                            self.dataOut.writeFloat((0 if ((f6 == 0)) else f6))
                            f7 = self.round((f.qz / ql))
                            self.dataOut.writeFloat((0 if ((f7 == 0)) else f7))
                        if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))) != 0):
                            f8 = f.sx
                            self.dataOut.writeFloat((0 if ((f8 == 0)) else f8))
                            f9 = f.sy
                            self.dataOut.writeFloat((0 if ((f9 == 0)) else f9))
                            f10 = f.sz
                            self.dataOut.writeFloat((0 if ((f10 == 0)) else f10))
            if (obj.uvs is not None):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasUV.index)))
                if (count == 0):
                    count = (len(obj.uvs) >> 1)
                elif (count != ((len(obj.uvs) >> 1))):
                    raise haxe_Exception.thrown("assert")
                if (self.d.version < 3):
                    _g3 = 0
                    _g4 = obj.uvs
                    while (_g3 < len(_g4)):
                        f11 = _g4[_g3]
                        _g3 = (_g3 + 1)
                        self.dataOut.writeFloat((0 if ((f11 == 0)) else f11))
            if (obj.alphas is not None):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasAlpha.index)))
                if (count == 0):
                    count = len(obj.alphas)
                elif (count != len(obj.alphas)):
                    raise haxe_Exception.thrown("assert")
                if (self.d.version < 3):
                    _g5 = 0
                    _g6 = obj.alphas
                    while (_g5 < len(_g6)):
                        f12 = _g6[_g5]
                        _g5 = (_g5 + 1)
                        self.dataOut.writeFloat((0 if ((f12 == 0)) else f12))
            if (obj.propValues is not None):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))
                _this = o.props
                x = obj.propName
                _this.append(x)
                if (count == 0):
                    count = len(obj.propValues)
                elif (count != len(obj.propValues)):
                    raise haxe_Exception.thrown("assert")
                if (self.d.version < 3):
                    _g7 = 0
                    _g8 = obj.propValues
                    while (_g7 < len(_g8)):
                        f13 = _g8[_g7]
                        _g7 = (_g7 + 1)
                        self.dataOut.writeFloat((0 if ((f13 == 0)) else f13))
            if (count == 0):
                raise haxe_Exception.thrown("assert")
            if (count == 1):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.SingleFrame.index)))
                self.writeFrame(obj,0)
            else:
                if (count != anim.frameCount):
                    raise haxe_Exception.thrown("assert")
                animatedObjects.append(obj)
            _this1 = a.objects
            _this1.append(o)
        _g = 0
        _g1 = anim.frameCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            while (_g2 < len(animatedObjects)):
                obj = (animatedObjects[_g2] if _g2 >= 0 and _g2 < len(animatedObjects) else None)
                _g2 = (_g2 + 1)
                self.writeFrame(obj,i)
        return a

    def toHMD(self,filePath,includeGeometry):
        if (not includeGeometry):
            self.optimizeSkin = False
        self.leftHandConvert()
        self.autoMerge()
        if (filePath is not None):
            _this = filePath.split("\\")
            filePath = "/".join([python_Boot.toString1(x1,'') for x1 in _this]).lower()
            if (not filePath.endswith("/")):
                filePath = (("null" if filePath is None else filePath) + "/")
        self.filePath = filePath
        self.d = hxd_fmt_hmd_Data()
        self.d.version = 3
        self.d.geometries = []
        self.d.materials = []
        self.d.models = []
        self.d.animations = []
        self.dataOut = haxe_io_BytesOutput()
        self.addModels(includeGeometry)
        names = self.getAnimationNames()
        _g = 0
        while (_g < len(names)):
            animName = (names[_g] if _g >= 0 and _g < len(names) else None)
            _g = (_g + 1)
            anim = self.loadAnimation(animName)
            if (anim is not None):
                _this = self.d.animations
                x = self.makeAnimation(anim)
                _this.append(x)
        self.d.data = self.dataOut.getBytes()
        return self.d

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.d = None
        _hx_o.dataOut = None
        _hx_o.filePath = None
        _hx_o.tmp = None
        _hx_o.absoluteTexturePath = None
        _hx_o.optimizeSkin = None
        _hx_o.floatSkinIndexes = None
hxd_fmt_fbx_HMDOut._hx_class = hxd_fmt_fbx_HMDOut
_hx_classes["hxd.fmt.fbx.HMDOut"] = hxd_fmt_fbx_HMDOut

class hxd_fmt_fbx__Parser_Token(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.fbx._Parser.Token"
    _hx_constructs = ["TIdent", "TNode", "TInt", "TFloat", "TString", "TLength", "TBraceOpen", "TBraceClose", "TColon", "TEof"]

    @staticmethod
    def TIdent(s):
        return hxd_fmt_fbx__Parser_Token("TIdent", 0, (s,))

    @staticmethod
    def TNode(s):
        return hxd_fmt_fbx__Parser_Token("TNode", 1, (s,))

    @staticmethod
    def TInt(s):
        return hxd_fmt_fbx__Parser_Token("TInt", 2, (s,))

    @staticmethod
    def TFloat(s):
        return hxd_fmt_fbx__Parser_Token("TFloat", 3, (s,))

    @staticmethod
    def TString(s):
        return hxd_fmt_fbx__Parser_Token("TString", 4, (s,))

    @staticmethod
    def TLength(v):
        return hxd_fmt_fbx__Parser_Token("TLength", 5, (v,))
hxd_fmt_fbx__Parser_Token.TBraceOpen = hxd_fmt_fbx__Parser_Token("TBraceOpen", 6, ())
hxd_fmt_fbx__Parser_Token.TBraceClose = hxd_fmt_fbx__Parser_Token("TBraceClose", 7, ())
hxd_fmt_fbx__Parser_Token.TColon = hxd_fmt_fbx__Parser_Token("TColon", 8, ())
hxd_fmt_fbx__Parser_Token.TEof = hxd_fmt_fbx__Parser_Token("TEof", 9, ())
hxd_fmt_fbx__Parser_Token._hx_class = hxd_fmt_fbx__Parser_Token
_hx_classes["hxd.fmt.fbx._Parser.Token"] = hxd_fmt_fbx__Parser_Token


class hxd_fmt_fbx_Parser:
    _hx_class_name = "hxd.fmt.fbx.Parser"
    _hx_is_interface = "False"
    __slots__ = ("line", "buf", "bytes", "pos", "token", "binary", "fbxVersion")
    _hx_fields = ["line", "buf", "bytes", "pos", "token", "binary", "fbxVersion"]
    _hx_methods = ["parseText", "parseBytes", "parseNodes", "parseNode", "parseBinaryNodes", "readBinaryString", "parseBinaryNode", "readBinaryProperty", "except", "peek", "next", "error", "unexpected", "tokenStr", "nextChar", "getVersionedInt32", "getInt32", "getInt16", "getFloat", "getDouble", "i64ToFloat", "getByte", "getBuf", "isIdentChar", "nextToken"]
    _hx_statics = ["parse"]

    def __init__(self):
        self.fbxVersion = None
        self.binary = None
        self.token = None
        self.pos = None
        self.bytes = None
        self.buf = None
        self.line = None

    def parseText(self,_hx_str):
        self.buf = _hx_str
        self.pos = 0
        self.line = 1
        self.binary = False
        self.token = None
        return _hx_AnonObject({'name': "Root", 'props': [hxd_fmt_fbx_FbxProp.PInt(0), hxd_fmt_fbx_FbxProp.PString("Root"), hxd_fmt_fbx_FbxProp.PString("Root")], 'childs': self.parseNodes()})

    def parseBytes(self,_hx_bytes):
        self.bytes = _hx_bytes
        self.pos = 0
        self.line = 0
        self.binary = ((_hx_bytes.getString(0,20) == "Kaydara FBX Binary  ") and ((_hx_bytes.b[20] == 0)))
        self.token = None
        if self.binary:
            v = (((_hx_bytes.b[23] | ((_hx_bytes.b[24] << 8))) | ((_hx_bytes.b[25] << 16))) | ((_hx_bytes.b[26] << 24)))
            self.fbxVersion = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            self.pos = 27
            _this = self.bytes
            pos = self.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + (8 if ((self.fbxVersion >= 7500)) else 4))
            _hx_local_0.pos
            firstNode = self.parseBinaryNode(i)
            if (firstNode.name != ""):
                nodes = [firstNode]
                _this = self.bytes
                pos = self.pos
                v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
                i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.pos
                _hx_local_2.pos = (_hx_local_3 + (8 if ((self.fbxVersion >= 7500)) else 4))
                _hx_local_2.pos
                size = i
                while (size != 0):
                    x = self.parseBinaryNode(size)
                    nodes.append(x)
                    _this = self.bytes
                    pos = self.pos
                    v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
                    i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.pos
                    _hx_local_4.pos = (_hx_local_5 + (8 if ((self.fbxVersion >= 7500)) else 4))
                    _hx_local_4.pos
                    size = i
                return _hx_AnonObject({'name': "Root", 'props': [hxd_fmt_fbx_FbxProp.PInt(0), hxd_fmt_fbx_FbxProp.PString("Root"), hxd_fmt_fbx_FbxProp.PString("Root")], 'childs': nodes})
            else:
                return firstNode
        return _hx_AnonObject({'name': "Root", 'props': [hxd_fmt_fbx_FbxProp.PInt(0), hxd_fmt_fbx_FbxProp.PString("Root"), hxd_fmt_fbx_FbxProp.PString("Root")], 'childs': self.parseNodes()})

    def parseNodes(self):
        nodes = []
        while True:
            _g = self.peek()
            if (_g is not None):
                tmp = _g.index
                if ((tmp == 9) or ((tmp == 7))):
                    return nodes
                else:
                    pass
            x = self.parseNode()
            nodes.append(x)

    def parseNode(self):
        t = self.next()
        name = None
        if (t.index == 1):
            n = t.params[0]
            name = n
        else:
            name = self.unexpected(t)
        props = []
        childs = None
        while True:
            t = self.next()
            tmp = t.index
            if (tmp == 0):
                s = t.params[0]
                props.append(hxd_fmt_fbx_FbxProp.PIdent(s))
            elif (tmp == 1):
                _g = t.params[0]
                self.token = t
            elif (tmp == 2):
                s1 = t.params[0]
                x = hxd_fmt_fbx_FbxProp.PInt(Std.parseInt(s1))
                props.append(x)
            elif (tmp == 3):
                s2 = t.params[0]
                x1 = hxd_fmt_fbx_FbxProp.PFloat(Std.parseFloat(s2))
                props.append(x1)
            elif (tmp == 4):
                s3 = t.params[0]
                props.append(hxd_fmt_fbx_FbxProp.PString(s3))
            elif (tmp == 5):
                v = t.params[0]
                self._hx_except(hxd_fmt_fbx__Parser_Token.TBraceOpen)
                self._hx_except(hxd_fmt_fbx__Parser_Token.TNode("a"))
                ints = []
                floats = None
                i = 0
                while (i < v):
                    t = self.next()
                    tmp1 = t.index
                    if (tmp1 == 2):
                        s4 = t.params[0]
                        i = (i + 1)
                        if (floats is None):
                            x2 = Std.parseInt(s4)
                            ints.append(x2)
                        else:
                            x3 = Std.parseInt(s4)
                            floats.append(x3)
                    elif (tmp1 == 3):
                        s5 = t.params[0]
                        i = (i + 1)
                        if (floats is None):
                            floats = []
                            _g1 = 0
                            while (_g1 < len(ints)):
                                i1 = (ints[_g1] if _g1 >= 0 and _g1 < len(ints) else None)
                                _g1 = (_g1 + 1)
                                floats.append(i1)
                            ints = None
                        x4 = Std.parseFloat(s5)
                        floats.append(x4)
                    elif (tmp1 == 8):
                        continue
                    else:
                        self.unexpected(t)
                props.append((hxd_fmt_fbx_FbxProp.PInts(ints) if ((floats is None)) else hxd_fmt_fbx_FbxProp.PFloats(floats)))
                if (self.peek() == hxd_fmt_fbx__Parser_Token.TColon):
                    self._hx_except(hxd_fmt_fbx__Parser_Token.TColon)
                self._hx_except(hxd_fmt_fbx__Parser_Token.TBraceClose)
                break
            elif ((tmp == 7) or ((tmp == 6))):
                self.token = t
            else:
                self.unexpected(t)
            t = self.next()
            tmp2 = t.index
            if (tmp2 == 1):
                _g2 = t.params[0]
                self.token = t
                break
            elif (tmp2 == 6):
                childs = self.parseNodes()
                self._hx_except(hxd_fmt_fbx__Parser_Token.TBraceClose)
                break
            elif (tmp2 == 7):
                self.token = t
                break
            elif (tmp2 == 8):
                pass
            else:
                self.unexpected(t)
        if (childs is None):
            childs = []
        return _hx_AnonObject({'name': name, 'props': props, 'childs': childs})

    def parseBinaryNodes(self,output):
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + (8 if ((self.fbxVersion >= 7500)) else 4))
        _hx_local_0.pos
        size = i
        while (size != 0):
            x = self.parseBinaryNode(size)
            output.append(x)
            _this = self.bytes
            pos = self.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + (8 if ((self.fbxVersion >= 7500)) else 4))
            _hx_local_2.pos
            size = i

    def readBinaryString(self,length):
        if (length == 0):
            return ""
        _hx_str = self.bytes.getString(self.pos,length)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + length)
        _hx_local_0.pos
        _hx_len = len(_hx_str)
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (HxString.charCodeAt(_hx_str,i) == 0):
                return HxString.substr(_hx_str,0,i)
        return _hx_str

    def parseBinaryNode(self,nextRecord):
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + (8 if ((self.fbxVersion >= 7500)) else 4))
        _hx_local_0.pos
        numProperties = i
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.pos
        _hx_local_2.pos = (_hx_local_3 + (8 if ((self.fbxVersion >= 7500)) else 4))
        _hx_local_2.pos
        propertyListLength = i
        pos = self.pos
        self.pos = (self.pos + 1)
        name = self.readBinaryString(self.bytes.b[pos])
        props = list()
        childs = list()
        propStart = self.pos
        _g = 0
        _g1 = numProperties
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = self.readBinaryProperty()
            props.append(x)
        self.pos = (propStart + propertyListLength)
        if (self.pos < nextRecord):
            self.parseBinaryNodes(childs)
        self.pos = nextRecord
        return _hx_AnonObject({'name': name, 'props': props, 'childs': childs})

    def readBinaryProperty(self):
        _gthis = self
        arrayLen = 0
        arrayEncoding = None
        arrayCompressedLen = None
        arrayBytes = None
        arrayBytesPos = 0
        pos = self.pos
        self.pos = (self.pos + 1)
        _hx_type = self.bytes.b[pos]
        type1 = _hx_type
        if (type1 == 67):
            pos = self.pos
            self.pos = (self.pos + 1)
            return hxd_fmt_fbx_FbxProp.PInt(self.bytes.b[pos])
        elif (type1 == 68):
            d = self.bytes.getDouble(self.pos)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 8)
            _hx_local_0.pos
            return hxd_fmt_fbx_FbxProp.PFloat(d)
        elif (type1 == 70):
            f = self.bytes.getFloat(self.pos)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 4)
            _hx_local_2.pos
            return hxd_fmt_fbx_FbxProp.PFloat(f)
        elif (type1 == 73):
            _this = self.bytes
            pos = self.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.pos
            _hx_local_4.pos = (_hx_local_5 + 4)
            _hx_local_4.pos
            return hxd_fmt_fbx_FbxProp.PInt(i)
        elif (type1 == 76):
            _this = self.bytes
            pos = self.pos
            pos1 = (pos + 4)
            v = (((_this.b[pos1] | ((_this.b[(pos1 + 1)] << 8))) | ((_this.b[(pos1 + 2)] << 16))) | ((_this.b[(pos1 + 3)] << 24)))
            v1 = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i64_high = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            i64_low = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 8)
            _hx_local_6.pos
            return hxd_fmt_fbx_FbxProp.PFloat(((i64_high * 4294967296) + (((((i64_low & 2147483647)) + 2147483648) if ((((i64_low & -2147483648)) != 0)) else i64_low))))
        elif (type1 == 82):
            _this = self.bytes
            pos = self.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.pos
            _hx_local_8.pos = (_hx_local_9 + 4)
            _hx_local_8.pos
            _hx_len = i
            data = haxe_io_Bytes.alloc(_hx_len)
            data.blit(0,self.bytes,self.pos,_hx_len)
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.pos
            _hx_local_10.pos = (_hx_local_11 + _hx_len)
            _hx_local_10.pos
            return hxd_fmt_fbx_FbxProp.PBinary(data)
        elif (type1 == 83):
            _this = self.bytes
            pos = self.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + 4)
            _hx_local_12.pos
            return hxd_fmt_fbx_FbxProp.PString(self.readBinaryString(i))
        elif (type1 == 89):
            i = (self.bytes.b[self.pos] | ((self.bytes.b[(self.pos + 1)] << 8)))
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.pos
            _hx_local_14.pos = (_hx_local_15 + 2)
            _hx_local_14.pos
            return hxd_fmt_fbx_FbxProp.PInt(i)
        elif (type1 == 98):
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i
            arrayEncoding1 = arrayEncoding
            if (arrayEncoding1 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + arrayLen)
            elif (arrayEncoding1 == 1):
                arrayBytesPos = 0
                buf = _gthis.bytes.sub(_gthis.pos,arrayCompressedLen)
                arrayBytes = haxe_zip_Uncompress.run(buf)
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            bools = list()
            while (arrayLen > 0):
                pos = arrayBytesPos
                arrayBytesPos = (arrayBytesPos + 1)
                x = arrayBytes.b[pos]
                bools.append(x)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PInts(bools)
        elif (type1 == 100):
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i
            arrayEncoding1 = arrayEncoding
            if (arrayEncoding1 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + ((arrayLen * 8)))
            elif (arrayEncoding1 == 1):
                arrayBytesPos = 0
                buf = _gthis.bytes.sub(_gthis.pos,arrayCompressedLen)
                arrayBytes = haxe_zip_Uncompress.run(buf)
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            doubles = list()
            while (arrayLen > 0):
                x = arrayBytes.getDouble(arrayBytesPos)
                doubles.append(x)
                arrayBytesPos = (arrayBytesPos + 8)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PFloats(doubles)
        elif (type1 == 102):
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i
            arrayEncoding1 = arrayEncoding
            if (arrayEncoding1 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + ((arrayLen * 4)))
            elif (arrayEncoding1 == 1):
                arrayBytesPos = 0
                buf = _gthis.bytes.sub(_gthis.pos,arrayCompressedLen)
                arrayBytes = haxe_zip_Uncompress.run(buf)
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            floats = list()
            while (arrayLen > 0):
                x = arrayBytes.getFloat(arrayBytesPos)
                floats.append(x)
                arrayBytesPos = (arrayBytesPos + 4)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PFloats(floats)
        elif (type1 == 105):
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i
            arrayEncoding1 = arrayEncoding
            if (arrayEncoding1 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + ((arrayLen * 4)))
            elif (arrayEncoding1 == 1):
                arrayBytesPos = 0
                buf = _gthis.bytes.sub(_gthis.pos,arrayCompressedLen)
                arrayBytes = haxe_zip_Uncompress.run(buf)
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            ints = list()
            while (arrayLen > 0):
                v = (((arrayBytes.b[arrayBytesPos] | ((arrayBytes.b[(arrayBytesPos + 1)] << 8))) | ((arrayBytes.b[(arrayBytesPos + 2)] << 16))) | ((arrayBytes.b[(arrayBytesPos + 3)] << 24)))
                ints.append(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v))
                arrayBytesPos = (arrayBytesPos + 4)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PInts(ints)
        elif (type1 == 108):
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i
            _this = _gthis.bytes
            pos = _gthis.pos
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i
            arrayEncoding1 = arrayEncoding
            if (arrayEncoding1 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + ((arrayLen * 8)))
            elif (arrayEncoding1 == 1):
                arrayBytesPos = 0
                buf = _gthis.bytes.sub(_gthis.pos,arrayCompressedLen)
                arrayBytes = haxe_zip_Uncompress.run(buf)
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            i64s = list()
            while (arrayLen > 0):
                pos = (arrayBytesPos + 4)
                v = (((arrayBytes.b[pos] | ((arrayBytes.b[(pos + 1)] << 8))) | ((arrayBytes.b[(pos + 2)] << 16))) | ((arrayBytes.b[(pos + 3)] << 24)))
                v1 = (((arrayBytes.b[arrayBytesPos] | ((arrayBytes.b[(arrayBytesPos + 1)] << 8))) | ((arrayBytes.b[(arrayBytesPos + 2)] << 16))) | ((arrayBytes.b[(arrayBytesPos + 3)] << 24)))
                i64_high = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                i64_low = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
                i64s.append(((i64_high * 4294967296) + (((((i64_low & 2147483647)) + 2147483648) if ((((i64_low & -2147483648)) != 0)) else i64_low))))
                arrayBytesPos = (arrayBytesPos + 8)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PFloats(i64s)
        else:
            return self.error(((("Unknown property type: " + Std.string(_hx_type)) + "/") + HxOverrides.stringOrNull("".join(map(chr,[_hx_type])))))

    def _hx_except(self,_hx_except):
        t = self.next()
        if (not Type.enumEq(t,_hx_except)):
            self.error((((("Unexpected '" + HxOverrides.stringOrNull(self.tokenStr(t))) + "' (") + HxOverrides.stringOrNull(self.tokenStr(_hx_except))) + " expected)"))

    def peek(self):
        if (self.token is None):
            self.token = self.nextToken()
        return self.token

    def next(self):
        if (self.token is None):
            return self.nextToken()
        tmp = self.token
        self.token = None
        return tmp

    def error(self,msg):
        raise haxe_Exception.thrown((((("null" if msg is None else msg) + " (line ") + Std.string(self.line)) + ")"))

    def unexpected(self,t):
        return self.error(("Unexpected " + HxOverrides.stringOrNull(self.tokenStr(t))))

    def tokenStr(self,t):
        tmp = t.index
        if (tmp == 0):
            i = t.params[0]
            return i
        elif (tmp == 1):
            i = t.params[0]
            return (("null" if i is None else i) + ":")
        elif (tmp == 2):
            i = t.params[0]
            return i
        elif (tmp == 3):
            f = t.params[0]
            return f
        elif (tmp == 4):
            s = t.params[0]
            return (("\"" + ("null" if s is None else s)) + "\"")
        elif (tmp == 5):
            l = t.params[0]
            return ("*" + Std.string(l))
        elif (tmp == 6):
            return "{"
        elif (tmp == 7):
            return "}"
        elif (tmp == 8):
            return ","
        elif (tmp == 9):
            return "<eof>"
        else:
            pass

    def nextChar(self):
        s = self.buf
        index = self.pos
        self.pos = (self.pos + 1)
        if (index >= len(s)):
            return -1
        else:
            return ord(s[index])

    def getVersionedInt32(self):
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + (8 if ((self.fbxVersion >= 7500)) else 4))
        _hx_local_0.pos
        return i

    def getInt32(self):
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 4)
        _hx_local_0.pos
        return i

    def getInt16(self):
        i = (self.bytes.b[self.pos] | ((self.bytes.b[(self.pos + 1)] << 8)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        return i

    def getFloat(self):
        f = self.bytes.getFloat(self.pos)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 4)
        _hx_local_0.pos
        return f

    def getDouble(self):
        d = self.bytes.getDouble(self.pos)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 8)
        _hx_local_0.pos
        return d

    def i64ToFloat(self,i64):
        return ((i64.high * 4294967296) + (((((i64.low & 2147483647)) + 2147483648) if ((((i64.low & -2147483648)) != 0)) else i64.low)))

    def getByte(self):
        pos = self.pos
        self.pos = (self.pos + 1)
        return self.bytes.b[pos]

    def getBuf(self,pos,_hx_len):
        return HxString.substr(self.buf,pos,_hx_len)

    def isIdentChar(self,c):
        if (not ((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 95))))):
            return (c == 45)
        else:
            return True

    def nextToken(self):
        start = self.pos
        while True:
            s = self.buf
            index = self.pos
            self.pos = (self.pos + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            c1 = c
            if (c1 == 10):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.line
                _hx_local_0.line = (_hx_local_1 + 1)
                _hx_local_1
                start = (start + 1)
            elif (((c1 == 32) or ((c1 == 13))) or ((c1 == 9))):
                start = (start + 1)
            elif (c1 == 34):
                start = self.pos
                while True:
                    s1 = self.buf
                    index1 = self.pos
                    self.pos = (self.pos + 1)
                    c = (-1 if ((index1 >= len(s1))) else ord(s1[index1]))
                    if (c == 34):
                        break
                    if ((c == -1) or ((c == 10))):
                        self.error("Unclosed string")
                return hxd_fmt_fbx__Parser_Token.TString(HxString.substr(self.buf,start,((self.pos - start) - 1)))
            elif (c1 == 42):
                start = self.pos
                while True:
                    s2 = self.buf
                    index2 = self.pos
                    self.pos = (self.pos + 1)
                    c = (-1 if ((index2 >= len(s2))) else ord(s2[index2]))
                    if (not (((c >= 48) and ((c <= 57))))):
                        break
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.pos
                _hx_local_4.pos = (_hx_local_5 - 1)
                _hx_local_5
                return hxd_fmt_fbx__Parser_Token.TLength(Std.parseInt(HxString.substr(self.buf,start,(self.pos - start))))
            elif (c1 == 44):
                return hxd_fmt_fbx__Parser_Token.TColon
            elif (c1 == 59):
                while True:
                    s3 = self.buf
                    index3 = self.pos
                    self.pos = (self.pos + 1)
                    c2 = (-1 if ((index3 >= len(s3))) else ord(s3[index3]))
                    if ((c2 == -1) or ((c2 == 10))):
                        _hx_local_6 = self
                        _hx_local_7 = _hx_local_6.pos
                        _hx_local_6.pos = (_hx_local_7 - 1)
                        _hx_local_7
                        break
                start = self.pos
            elif (c1 == 123):
                return hxd_fmt_fbx__Parser_Token.TBraceOpen
            elif (c1 == 125):
                return hxd_fmt_fbx__Parser_Token.TBraceClose
            else:
                if ((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or ((c == 95))):
                    while True:
                        s4 = self.buf
                        index4 = self.pos
                        self.pos = (self.pos + 1)
                        c = (-1 if ((index4 >= len(s4))) else ord(s4[index4]))
                        if (not (((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 95))) or ((c == 45))))):
                            break
                    if (c == 58):
                        return hxd_fmt_fbx__Parser_Token.TNode(HxString.substr(self.buf,start,((self.pos - start) - 1)))
                    _hx_local_8 = self
                    _hx_local_9 = _hx_local_8.pos
                    _hx_local_8.pos = (_hx_local_9 - 1)
                    _hx_local_9
                    return hxd_fmt_fbx__Parser_Token.TIdent(HxString.substr(self.buf,start,(self.pos - start)))
                if (((c >= 48) and ((c <= 57))) or ((c == 45))):
                    while True:
                        s5 = self.buf
                        index5 = self.pos
                        self.pos = (self.pos + 1)
                        c = (-1 if ((index5 >= len(s5))) else ord(s5[index5]))
                        if (not (((c >= 48) and ((c <= 57))))):
                            break
                    if ((((c != 46) and ((c != 69))) and ((c != 101))) and (((self.pos - start) < 10))):
                        _hx_local_10 = self
                        _hx_local_11 = _hx_local_10.pos
                        _hx_local_10.pos = (_hx_local_11 - 1)
                        _hx_local_11
                        return hxd_fmt_fbx__Parser_Token.TInt(HxString.substr(self.buf,start,(self.pos - start)))
                    if (c == 46):
                        while True:
                            s6 = self.buf
                            index6 = self.pos
                            self.pos = (self.pos + 1)
                            c = (-1 if ((index6 >= len(s6))) else ord(s6[index6]))
                            if (not (((c >= 48) and ((c <= 57))))):
                                break
                    if ((c == 101) or ((c == 69))):
                        s7 = self.buf
                        index7 = self.pos
                        self.pos = (self.pos + 1)
                        c = (-1 if ((index7 >= len(s7))) else ord(s7[index7]))
                        if ((c != 45) and ((c != 43))):
                            _hx_local_12 = self
                            _hx_local_13 = _hx_local_12.pos
                            _hx_local_12.pos = (_hx_local_13 - 1)
                            _hx_local_13
                        while True:
                            s8 = self.buf
                            index8 = self.pos
                            self.pos = (self.pos + 1)
                            c = (-1 if ((index8 >= len(s8))) else ord(s8[index8]))
                            if (not (((c >= 48) and ((c <= 57))))):
                                break
                    _hx_local_14 = self
                    _hx_local_15 = _hx_local_14.pos
                    _hx_local_14.pos = (_hx_local_15 - 1)
                    _hx_local_15
                    return hxd_fmt_fbx__Parser_Token.TFloat(HxString.substr(self.buf,start,(self.pos - start)))
                if (c == -1):
                    _hx_local_16 = self
                    _hx_local_17 = _hx_local_16.pos
                    _hx_local_16.pos = (_hx_local_17 - 1)
                    _hx_local_17
                    return hxd_fmt_fbx__Parser_Token.TEof
                self.error((("Unexpected char '" + HxOverrides.stringOrNull("".join(map(chr,[c])))) + "'"))

    @staticmethod
    def parse(data):
        if ((data.length > 20) and ((data.getString(0,20) == "Kaydara FBX Binary  "))):
            return hxd_fmt_fbx_Parser().parseBytes(data)
        return hxd_fmt_fbx_Parser().parseText(data.toString())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.line = None
        _hx_o.buf = None
        _hx_o.bytes = None
        _hx_o.pos = None
        _hx_o.token = None
        _hx_o.binary = None
        _hx_o.fbxVersion = None
hxd_fmt_fbx_Parser._hx_class = hxd_fmt_fbx_Parser
_hx_classes["hxd.fmt.fbx.Parser"] = hxd_fmt_fbx_Parser


class hxd_fmt_hdr_Reader:
    _hx_class_name = "hxd.fmt.hdr.Reader"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["decode"]

    @staticmethod
    def decode(_hx_bytes,sRGB):
        f = haxe_io_BytesInput(_hx_bytes)
        width = 0
        height = 0
        keys = haxe_ds_StringMap()
        while True:
            line = f.readLine()
            if (line == ""):
                break
            if (HxString.charCodeAt(line,0) == 35):
                continue
            nameValue = line.split("=")
            if (len(nameValue) > 1):
                key = (None if ((len(nameValue) == 0)) else nameValue.pop(0))
                value = "=".join([python_Boot.toString1(x1,'') for x1 in nameValue])
                keys.h[key] = value
        _this = f.readLine()
        parts = _this.split(" ")
        height = Std.parseInt((parts[1] if 1 < len(parts) else None))
        width = Std.parseInt((parts[3] if 3 < len(parts) else None))
        gamma = (keys.h.get("GAMMA",None) == "1")
        data = haxe_io_Bytes.alloc((((width * height) * 4) * 4))
        exposure = 1.0
        exp = keys.h.get("EXPOSURE",None)
        if (exp is not None):
            exp1 = Std.parseFloat(exp)
            if ((exp1 < 1e-12) or ((exp1 < 1e12))):
                exposure = exp1
        gammaCorrect = (1 if sRGB else 0.45454545454545453)
        _g = []
        _g1 = 0
        while (_g1 < 256):
            e = _g1
            _g1 = (_g1 + 1)
            x = Math.pow(e,gammaCorrect)
            _g.append(x)
        gammaVals = _g
        _g = []
        _g1 = 0
        while (_g1 < 256):
            e = _g1
            _g1 = (_g1 + 1)
            x = Math.pow((Math.pow(2,(e - 128)) / ((256 * exposure))),gammaCorrect)
            _g.append(x)
        exps = _g
        _g = keys.h.get("FORMAT",None)
        if (_g is None):
            fmt = _g
            raise haxe_Exception.thrown(("Unsupported HDR format " + ("null" if fmt is None else fmt)))
        elif (_g == "32-bit_rle_rgbe"):
            dataPos = f.pos
            scanLen = (width * 4)
            scanLine = haxe_io_Bytes.alloc(scanLen)
            widthBE = ((width >> 8) | ((((width & 255)) << 8)))
            _g1 = 0
            _g2 = height
            while (_g1 < _g2):
                y = _g1
                _g1 = (_g1 + 1)
                v = (((_hx_bytes.b[dataPos] | ((_hx_bytes.b[(dataPos + 1)] << 8))) | ((_hx_bytes.b[(dataPos + 2)] << 16))) | ((_hx_bytes.b[(dataPos + 3)] << 24)))
                h = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                if ((((h & 65535)) != 514) or ((HxOverrides.rshift(h, 16) != widthBE))):
                    scanLine.blit(0,_hx_bytes,dataPos,(width * 4))
                    dataPos = (dataPos + ((width * 4)))
                else:
                    dataPos = (dataPos + 4)
                    p = 0
                    end = (width * 4)
                    while (p < end):
                        pos = dataPos
                        dataPos = (dataPos + 1)
                        _hx_len = _hx_bytes.b[pos]
                        if (_hx_len > 128):
                            _hx_len = (_hx_len - 128)
                            pos1 = dataPos
                            dataPos = (dataPos + 1)
                            scanLine.fill(p,_hx_len,_hx_bytes.b[pos1])
                        else:
                            scanLine.blit(p,_hx_bytes,dataPos,_hx_len)
                            dataPos = (dataPos + _hx_len)
                        p = (p + _hx_len)
                pos2 = ((y * width) * 16)
                _g3 = 0
                _g4 = width
                while (_g3 < _g4):
                    x = _g3
                    _g3 = (_g3 + 1)
                    e = python_internal_ArrayImpl._get(exps, scanLine.b[(x + ((width * 3)))])
                    data.setFloat(pos2,(python_internal_ArrayImpl._get(gammaVals, scanLine.b[x]) * e))
                    pos2 = (pos2 + 4)
                    data.setFloat(pos2,(python_internal_ArrayImpl._get(gammaVals, scanLine.b[(x + width)]) * e))
                    pos2 = (pos2 + 4)
                    data.setFloat(pos2,(python_internal_ArrayImpl._get(gammaVals, scanLine.b[(x + ((width << 1)))]) * e))
                    pos2 = (pos2 + 4)
                    data.setFloat(pos2,1.0)
                    pos2 = (pos2 + 4)
        else:
            fmt = _g
            raise haxe_Exception.thrown(("Unsupported HDR format " + ("null" if fmt is None else fmt)))
        return _hx_AnonObject({'width': width, 'height': height, 'bytes': data, 'gamma': gamma})
hxd_fmt_hdr_Reader._hx_class = hxd_fmt_hdr_Reader
_hx_classes["hxd.fmt.hdr.Reader"] = hxd_fmt_hdr_Reader


class hxd_fmt_hmd__Data_GeometryDataFormat_Impl_:
    _hx_class_name = "hxd.fmt.hmd._Data.GeometryDataFormat_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["DFloat", "DVec2", "DVec3", "DVec4", "DBytes4", "_new", "getSize", "toInt", "toString", "fromInt"]

    @staticmethod
    def _new(v):
        this1 = v
        return this1

    @staticmethod
    def getSize(this1):
        return (this1 & 7)

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def toString(this1):
        this2 = this1
        _g = this2
        if (_g == 1):
            return "DFloat"
        elif (_g == 2):
            return "DVec2"
        elif (_g == 3):
            return "DVec3"
        elif (_g == 4):
            return "DVec4"
        elif (_g == 9):
            return "DBytes4"
        else:
            pass

    @staticmethod
    def fromInt(v):
        this1 = v
        return this1
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_._hx_class = hxd_fmt_hmd__Data_GeometryDataFormat_Impl_
_hx_classes["hxd.fmt.hmd._Data.GeometryDataFormat_Impl_"] = hxd_fmt_hmd__Data_GeometryDataFormat_Impl_

class hxd_fmt_hmd_Property(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.hmd.Property"
    _hx_constructs = ["CameraFOVY", "Unused_HasMaterialFlags", "HasExtraTextures"]

    @staticmethod
    def CameraFOVY(v):
        return hxd_fmt_hmd_Property("CameraFOVY", 0, (v,))
hxd_fmt_hmd_Property.Unused_HasMaterialFlags = hxd_fmt_hmd_Property("Unused_HasMaterialFlags", 1, ())
hxd_fmt_hmd_Property.HasExtraTextures = hxd_fmt_hmd_Property("HasExtraTextures", 2, ())
hxd_fmt_hmd_Property._hx_class = hxd_fmt_hmd_Property
_hx_classes["hxd.fmt.hmd.Property"] = hxd_fmt_hmd_Property


class hxd_fmt_hmd_Position:
    _hx_class_name = "hxd.fmt.hmd.Position"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "qx", "qy", "qz", "sx", "sy", "sz")
    _hx_fields = ["x", "y", "z", "qx", "qy", "qz", "sx", "sy", "sz"]
    _hx_methods = ["loadQuaternion", "get_qw", "toMatrix"]
    _hx_statics = ["QTMP"]

    def __init__(self):
        self.sz = None
        self.sy = None
        self.sx = None
        self.qz = None
        self.qy = None
        self.qx = None
        self.z = None
        self.y = None
        self.x = None

    def loadQuaternion(self,q):
        q.x = self.qx
        q.y = self.qy
        q.z = self.qz
        q.w = self.get_qw()

    def get_qw(self):
        qw = (1 - ((((self.qx * self.qx) + ((self.qy * self.qy))) + ((self.qz * self.qz)))))
        if (qw < 0):
            f = -qw
            return -((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f)))
        elif (qw < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(qw)

    def toMatrix(self,postScale = None):
        if (postScale is None):
            postScale = False
        m = h3d_Matrix()
        q = hxd_fmt_hmd_Position.QTMP
        q.x = self.qx
        q.y = self.qy
        q.z = self.qz
        q.w = self.get_qw()
        q.toMatrix(m)
        if postScale:
            m.translate(self.x,self.y,self.z)
            m.scale(self.sx,self.sy,self.sz)
        else:
            m._11 = (m._11 * self.sx)
            m._12 = (m._12 * self.sx)
            m._13 = (m._13 * self.sx)
            m._21 = (m._21 * self.sy)
            m._22 = (m._22 * self.sy)
            m._23 = (m._23 * self.sy)
            m._31 = (m._31 * self.sz)
            m._32 = (m._32 * self.sz)
            m._33 = (m._33 * self.sz)
            m.translate(self.x,self.y,self.z)
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.qx = None
        _hx_o.qy = None
        _hx_o.qz = None
        _hx_o.sx = None
        _hx_o.sy = None
        _hx_o.sz = None
hxd_fmt_hmd_Position._hx_class = hxd_fmt_hmd_Position
_hx_classes["hxd.fmt.hmd.Position"] = hxd_fmt_hmd_Position


class hxd_fmt_hmd_GeometryFormat:
    _hx_class_name = "hxd.fmt.hmd.GeometryFormat"
    _hx_is_interface = "False"
    __slots__ = ("name", "format")
    _hx_fields = ["name", "format"]

    def __init__(self,name,format):
        self.name = name
        self.format = format

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.format = None
hxd_fmt_hmd_GeometryFormat._hx_class = hxd_fmt_hmd_GeometryFormat
_hx_classes["hxd.fmt.hmd.GeometryFormat"] = hxd_fmt_hmd_GeometryFormat


class hxd_fmt_hmd_Geometry:
    _hx_class_name = "hxd.fmt.hmd.Geometry"
    _hx_is_interface = "False"
    __slots__ = ("props", "vertexCount", "vertexStride", "vertexFormat", "vertexPosition", "indexCounts", "indexPosition", "bounds")
    _hx_fields = ["props", "vertexCount", "vertexStride", "vertexFormat", "vertexPosition", "indexCounts", "indexPosition", "bounds"]
    _hx_methods = ["get_indexCount"]

    def __init__(self):
        self.bounds = None
        self.indexPosition = None
        self.indexCounts = None
        self.vertexPosition = None
        self.vertexFormat = None
        self.vertexStride = None
        self.vertexCount = None
        self.props = None

    def get_indexCount(self):
        k = 0
        _g = 0
        _g1 = self.indexCounts
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            k = (k + i)
        return k

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.props = None
        _hx_o.vertexCount = None
        _hx_o.vertexStride = None
        _hx_o.vertexFormat = None
        _hx_o.vertexPosition = None
        _hx_o.indexCounts = None
        _hx_o.indexPosition = None
        _hx_o.bounds = None
hxd_fmt_hmd_Geometry._hx_class = hxd_fmt_hmd_Geometry
_hx_classes["hxd.fmt.hmd.Geometry"] = hxd_fmt_hmd_Geometry


class hxd_fmt_hmd_Material:
    _hx_class_name = "hxd.fmt.hmd.Material"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "diffuseTexture", "specularTexture", "normalMap", "blendMode")
    _hx_fields = ["name", "props", "diffuseTexture", "specularTexture", "normalMap", "blendMode"]

    def __init__(self):
        self.blendMode = None
        self.normalMap = None
        self.specularTexture = None
        self.diffuseTexture = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.diffuseTexture = None
        _hx_o.specularTexture = None
        _hx_o.normalMap = None
        _hx_o.blendMode = None
hxd_fmt_hmd_Material._hx_class = hxd_fmt_hmd_Material
_hx_classes["hxd.fmt.hmd.Material"] = hxd_fmt_hmd_Material


class hxd_fmt_hmd_SkinJoint:
    _hx_class_name = "hxd.fmt.hmd.SkinJoint"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "parent", "position", "bind", "transpos")
    _hx_fields = ["name", "props", "parent", "position", "bind", "transpos"]

    def __init__(self):
        self.transpos = None
        self.bind = None
        self.position = None
        self.parent = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.parent = None
        _hx_o.position = None
        _hx_o.bind = None
        _hx_o.transpos = None
hxd_fmt_hmd_SkinJoint._hx_class = hxd_fmt_hmd_SkinJoint
_hx_classes["hxd.fmt.hmd.SkinJoint"] = hxd_fmt_hmd_SkinJoint


class hxd_fmt_hmd_SkinSplit:
    _hx_class_name = "hxd.fmt.hmd.SkinSplit"
    _hx_is_interface = "False"
    __slots__ = ("materialIndex", "joints")
    _hx_fields = ["materialIndex", "joints"]

    def __init__(self):
        self.joints = None
        self.materialIndex = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.materialIndex = None
        _hx_o.joints = None
hxd_fmt_hmd_SkinSplit._hx_class = hxd_fmt_hmd_SkinSplit
_hx_classes["hxd.fmt.hmd.SkinSplit"] = hxd_fmt_hmd_SkinSplit


class hxd_fmt_hmd_Skin:
    _hx_class_name = "hxd.fmt.hmd.Skin"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "joints", "split")
    _hx_fields = ["name", "props", "joints", "split"]

    def __init__(self):
        self.split = None
        self.joints = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.joints = None
        _hx_o.split = None
hxd_fmt_hmd_Skin._hx_class = hxd_fmt_hmd_Skin
_hx_classes["hxd.fmt.hmd.Skin"] = hxd_fmt_hmd_Skin


class hxd_fmt_hmd_Model:
    _hx_class_name = "hxd.fmt.hmd.Model"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "parent", "follow", "position", "geometry", "materials", "skin")
    _hx_fields = ["name", "props", "parent", "follow", "position", "geometry", "materials", "skin"]

    def __init__(self):
        self.skin = None
        self.materials = None
        self.geometry = None
        self.position = None
        self.follow = None
        self.parent = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.parent = None
        _hx_o.follow = None
        _hx_o.position = None
        _hx_o.geometry = None
        _hx_o.materials = None
        _hx_o.skin = None
hxd_fmt_hmd_Model._hx_class = hxd_fmt_hmd_Model
_hx_classes["hxd.fmt.hmd.Model"] = hxd_fmt_hmd_Model

class hxd_fmt_hmd_AnimationFlag(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.hmd.AnimationFlag"
    _hx_constructs = ["HasPosition", "HasRotation", "HasScale", "HasUV", "HasAlpha", "SingleFrame", "HasProps", "Reserved"]
hxd_fmt_hmd_AnimationFlag.HasPosition = hxd_fmt_hmd_AnimationFlag("HasPosition", 0, ())
hxd_fmt_hmd_AnimationFlag.HasRotation = hxd_fmt_hmd_AnimationFlag("HasRotation", 1, ())
hxd_fmt_hmd_AnimationFlag.HasScale = hxd_fmt_hmd_AnimationFlag("HasScale", 2, ())
hxd_fmt_hmd_AnimationFlag.HasUV = hxd_fmt_hmd_AnimationFlag("HasUV", 3, ())
hxd_fmt_hmd_AnimationFlag.HasAlpha = hxd_fmt_hmd_AnimationFlag("HasAlpha", 4, ())
hxd_fmt_hmd_AnimationFlag.SingleFrame = hxd_fmt_hmd_AnimationFlag("SingleFrame", 5, ())
hxd_fmt_hmd_AnimationFlag.HasProps = hxd_fmt_hmd_AnimationFlag("HasProps", 6, ())
hxd_fmt_hmd_AnimationFlag.Reserved = hxd_fmt_hmd_AnimationFlag("Reserved", 7, ())
hxd_fmt_hmd_AnimationFlag._hx_class = hxd_fmt_hmd_AnimationFlag
_hx_classes["hxd.fmt.hmd.AnimationFlag"] = hxd_fmt_hmd_AnimationFlag


class hxd_fmt_hmd_AnimationObject:
    _hx_class_name = "hxd.fmt.hmd.AnimationObject"
    _hx_is_interface = "False"
    __slots__ = ("name", "flags", "props")
    _hx_fields = ["name", "flags", "props"]
    _hx_methods = ["getStride"]

    def __init__(self):
        self.props = None
        self.flags = None
        self.name = None

    def getStride(self):
        stride = 0
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))) != 0):
            stride = (stride + 3)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))) != 0):
            stride = (stride + 3)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))) != 0):
            stride = (stride + 3)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasUV.index)))) != 0):
            stride = (stride + 2)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasAlpha.index)))) != 0):
            stride = (stride + 1)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
            stride = (stride + len(self.props))
        return stride

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.flags = None
        _hx_o.props = None
hxd_fmt_hmd_AnimationObject._hx_class = hxd_fmt_hmd_AnimationObject
_hx_classes["hxd.fmt.hmd.AnimationObject"] = hxd_fmt_hmd_AnimationObject


class hxd_fmt_hmd_AnimationEvent:
    _hx_class_name = "hxd.fmt.hmd.AnimationEvent"
    _hx_is_interface = "False"
    __slots__ = ("frame", "data")
    _hx_fields = ["frame", "data"]

    def __init__(self):
        self.data = None
        self.frame = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.frame = None
        _hx_o.data = None
hxd_fmt_hmd_AnimationEvent._hx_class = hxd_fmt_hmd_AnimationEvent
_hx_classes["hxd.fmt.hmd.AnimationEvent"] = hxd_fmt_hmd_AnimationEvent


class hxd_fmt_hmd_Animation:
    _hx_class_name = "hxd.fmt.hmd.Animation"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "frames", "sampling", "speed", "loop", "objects", "events", "dataPosition")
    _hx_fields = ["name", "props", "frames", "sampling", "speed", "loop", "objects", "events", "dataPosition"]

    def __init__(self):
        self.dataPosition = None
        self.events = None
        self.objects = None
        self.loop = None
        self.speed = None
        self.sampling = None
        self.frames = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.frames = None
        _hx_o.sampling = None
        _hx_o.speed = None
        _hx_o.loop = None
        _hx_o.objects = None
        _hx_o.events = None
        _hx_o.dataPosition = None
hxd_fmt_hmd_Animation._hx_class = hxd_fmt_hmd_Animation
_hx_classes["hxd.fmt.hmd.Animation"] = hxd_fmt_hmd_Animation


class hxd_fmt_hmd_Data:
    _hx_class_name = "hxd.fmt.hmd.Data"
    _hx_is_interface = "False"
    __slots__ = ("version", "props", "geometries", "materials", "models", "animations", "dataPosition", "data")
    _hx_fields = ["version", "props", "geometries", "materials", "models", "animations", "dataPosition", "data"]
    _hx_statics = ["CURRENT_VERSION"]

    def __init__(self):
        self.data = None
        self.dataPosition = None
        self.animations = None
        self.models = None
        self.materials = None
        self.geometries = None
        self.props = None
        self.version = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.version = None
        _hx_o.props = None
        _hx_o.geometries = None
        _hx_o.materials = None
        _hx_o.models = None
        _hx_o.animations = None
        _hx_o.dataPosition = None
        _hx_o.data = None
hxd_fmt_hmd_Data._hx_class = hxd_fmt_hmd_Data
_hx_classes["hxd.fmt.hmd.Data"] = hxd_fmt_hmd_Data


class hxd_fmt_hmd__Library_FormatMap:
    _hx_class_name = "hxd.fmt.hmd._Library.FormatMap"
    _hx_is_interface = "False"
    __slots__ = ("size", "offset", "_hx_def", "next")
    _hx_fields = ["size", "offset", "def", "next"]

    def __init__(self,size,offset,_hx_def,next):
        self.size = size
        self.offset = offset
        self._hx_def = _hx_def
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.size = None
        _hx_o.offset = None
        _hx_o._hx_def = None
        _hx_o.next = None
hxd_fmt_hmd__Library_FormatMap._hx_class = hxd_fmt_hmd__Library_FormatMap
_hx_classes["hxd.fmt.hmd._Library.FormatMap"] = hxd_fmt_hmd__Library_FormatMap


class hxd_fmt_hmd_GeometryBuffer:
    _hx_class_name = "hxd.fmt.hmd.GeometryBuffer"
    _hx_is_interface = "False"
    __slots__ = ("vertexes", "indexes")
    _hx_fields = ["vertexes", "indexes"]

    def __init__(self):
        self.indexes = None
        self.vertexes = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vertexes = None
        _hx_o.indexes = None
hxd_fmt_hmd_GeometryBuffer._hx_class = hxd_fmt_hmd_GeometryBuffer
_hx_classes["hxd.fmt.hmd.GeometryBuffer"] = hxd_fmt_hmd_GeometryBuffer


class hxd_fmt_hmd_Library:
    _hx_class_name = "hxd.fmt.hmd.Library"
    _hx_is_interface = "False"
    __slots__ = ("resource", "header", "cachedPrimitives", "cachedAnimations", "cachedSkin")
    _hx_fields = ["resource", "header", "cachedPrimitives", "cachedAnimations", "cachedSkin"]
    _hx_methods = ["getData", "getDefaultFormat", "load", "getBuffers", "makePrimitive", "makeMaterial", "makeSkin", "getModelProperty", "makeObject", "loadAnimation", "makeAnimation", "makeLinearAnimation", "loadSkin"]

    def __init__(self,res,header):
        self.resource = res
        self.header = header
        self.cachedPrimitives = []
        self.cachedAnimations = haxe_ds_StringMap()
        self.cachedSkin = haxe_ds_StringMap()

    def getData(self):
        entry = self.resource.entry
        b = haxe_io_Bytes.alloc((entry.get_size() - self.header.dataPosition))
        entry.open()
        entry.skip(self.header.dataPosition)
        entry.read(b,0,b.length)
        entry.close()
        return b

    def getDefaultFormat(self,stride):
        format = [hxd_fmt_hmd_GeometryFormat("position",3)]
        defs = [None]
        if (stride > 3):
            x = hxd_fmt_hmd_GeometryFormat("normal",3)
            format.append(x)
            defs.append(None)
        if (stride > 6):
            x = hxd_fmt_hmd_GeometryFormat("uv",2)
            format.append(x)
            defs.append(None)
        if (stride > 8):
            x = hxd_fmt_hmd_GeometryFormat("color",3)
            format.append(x)
            x = h3d_Vector(1,1,1)
            defs.append(x)
        if (stride > 11):
            raise haxe_Exception.thrown("Unsupported stride")
        return _hx_AnonObject({'format': format, 'defs': defs})

    def load(self,format,defaults = None,modelIndex = None):
        if (modelIndex is None):
            modelIndex = -1
        vtmp_x = 0.
        vtmp_y = 0.
        vtmp_z = 0.
        vtmp_w = 1.
        models = (self.header.models if ((modelIndex < 0)) else [python_internal_ArrayImpl._get(self.header.models, modelIndex)])
        this1 = list()
        outVertex = this1
        this1 = list()
        outIndex = this1
        stride = 0
        mid = -1
        _g = 0
        while (_g < len(format)):
            f = (format[_g] if _g >= 0 and _g < len(format) else None)
            _g = (_g + 1)
            stride = (stride + ((f.format & 7)))
        _g = 0
        while (_g < len(models)):
            m = (models[_g] if _g >= 0 and _g < len(models) else None)
            _g = (_g + 1)
            geom = python_internal_ArrayImpl._get(self.header.geometries, m.geometry)
            if (geom is None):
                continue
            _g1 = 0
            _g2 = m.materials
            while (_g1 < len(_g2)):
                mat = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                if (mid < 0):
                    mid = mat
                if (mid != mat):
                    raise haxe_Exception.thrown("Models have several materials")
            pos = m.position.toMatrix()
            data = self.getBuffers(geom,format,defaults)
            x = (len(outVertex) / stride)
            start = None
            try:
                start = int(x)
            except BaseException as _g3:
                None
                start = None
            _g4 = 0
            x1 = (len(data.vertexes) / stride)
            _g5 = None
            try:
                _g5 = int(x1)
            except BaseException as _g6:
                None
                _g5 = None
            while (_g4 < _g5):
                i = _g4
                _g4 = (_g4 + 1)
                p = (i * stride)
                index = p
                p = (p + 1)
                vtmp_x = data.vertexes[index]
                index1 = p
                p = (p + 1)
                vtmp_y = data.vertexes[index1]
                index2 = p
                p = (p + 1)
                vtmp_z = data.vertexes[index2]
                px = ((((vtmp_x * pos._11) + ((vtmp_y * pos._21))) + ((vtmp_z * pos._31))) + ((vtmp_w * pos._41)))
                py = ((((vtmp_x * pos._12) + ((vtmp_y * pos._22))) + ((vtmp_z * pos._32))) + ((vtmp_w * pos._42)))
                pz = ((((vtmp_x * pos._13) + ((vtmp_y * pos._23))) + ((vtmp_z * pos._33))) + ((vtmp_w * pos._43)))
                vtmp_x = px
                vtmp_y = py
                vtmp_z = pz
                outVertex.append(vtmp_x)
                outVertex.append(vtmp_y)
                outVertex.append(vtmp_z)
                _g7 = 0
                _g8 = (stride - 3)
                while (_g7 < _g8):
                    j = _g7
                    _g7 = (_g7 + 1)
                    index3 = p
                    p = (p + 1)
                    v = data.vertexes[index3]
                    outVertex.append(v)
            _g9 = 0
            _g10 = data.indexes
            while (_g9 < len(_g10)):
                idx = _g10[_g9]
                _g9 = (_g9 + 1)
                outIndex.append((idx + start))
        return _hx_AnonObject({'vertex': outVertex, 'index': outIndex})

    def getBuffers(self,geom,format,defaults = None,material = None):
        if ((material == 0) and ((len(geom.indexCounts) == 1))):
            material = None
        _hx_map = None
        stride = 0
        _g = 0
        _g1 = len(format)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            i1 = ((len(format) - 1) - i)
            f = (format[i1] if i1 >= 0 and i1 < len(format) else None)
            size = (f.format & 7)
            offset = 0
            found = False
            _g2 = 0
            _g3 = geom.vertexFormat
            while (_g2 < len(_g3)):
                f2 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                if (f2.name == f.name):
                    if (((f2.format & 7)) < size):
                        raise haxe_Exception.thrown(((((("Requested " + HxOverrides.stringOrNull(f.name)) + " data has only ") + Std.string(((f2.format & 7)))) + " regs instead of ") + Std.string(size)))
                    found = True
                    break
                offset = (offset + ((f2.format & 7)))
            if found:
                _hx_map = hxd_fmt_hmd__Library_FormatMap(size,offset,None,_hx_map)
            else:
                _hx_def = (None if ((defaults is None)) else (defaults[i1] if i1 >= 0 and i1 < len(defaults) else None))
                if (_hx_def is None):
                    raise haxe_Exception.thrown(("Missing required " + HxOverrides.stringOrNull(f.name)))
                _hx_map = hxd_fmt_hmd__Library_FormatMap(size,0,_hx_def,_hx_map)
            stride = (stride + size)
        vsize = ((geom.vertexCount * geom.vertexStride) * 4)
        vbuf = haxe_io_Bytes.alloc(vsize)
        entry = self.resource.entry
        entry.open()
        entry.skip((self.header.dataPosition + geom.vertexPosition))
        entry.read(vbuf,0,vsize)
        entry.skip((geom.indexPosition - ((geom.vertexPosition + vsize))))
        isSmall = (geom.vertexCount <= 65536)
        imult = (2 if isSmall else 4)
        isize = None
        if (material is None):
            isize = (geom.get_indexCount() * imult)
        else:
            ipos = 0
            _g = 0
            _g1 = material
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                ipos = (ipos + (geom.indexCounts[i] if i >= 0 and i < len(geom.indexCounts) else None))
            entry.skip((ipos * imult))
            isize = ((geom.indexCounts[material] if material >= 0 and material < len(geom.indexCounts) else None) * imult)
        ibuf = haxe_io_Bytes.alloc(isize)
        entry.read(ibuf,0,isize)
        buf = hxd_fmt_hmd_GeometryBuffer()
        if (material is None):
            this1 = [None]*(stride * geom.vertexCount)
            buf.vertexes = this1
            this1 = [None]*geom.get_indexCount()
            buf.indexes = this1
            w = 0
            _g = 0
            _g1 = geom.vertexCount
            while (_g < _g1):
                vid = _g
                _g = (_g + 1)
                m = _hx_map
                while (m is not None):
                    if (m._hx_def is None):
                        r = (vid * geom.vertexStride)
                        _g2 = 0
                        _g3 = m.size
                        while (_g2 < _g3):
                            i = _g2
                            _g2 = (_g2 + 1)
                            this1 = buf.vertexes
                            index = w
                            w = (w + 1)
                            val = vbuf.getFloat((((r + m.offset) + i) << 2))
                            this1[index] = val
                    else:
                        _g4 = m.size
                        if (_g4 == 1):
                            index1 = w
                            w = (w + 1)
                            val1 = m._hx_def.x
                            buf.vertexes[index1] = val1
                        elif (_g4 == 2):
                            index2 = w
                            w = (w + 1)
                            val2 = m._hx_def.x
                            buf.vertexes[index2] = val2
                            index3 = w
                            w = (w + 1)
                            val3 = m._hx_def.y
                            buf.vertexes[index3] = val3
                        elif (_g4 == 3):
                            index4 = w
                            w = (w + 1)
                            val4 = m._hx_def.x
                            buf.vertexes[index4] = val4
                            index5 = w
                            w = (w + 1)
                            val5 = m._hx_def.y
                            buf.vertexes[index5] = val5
                            index6 = w
                            w = (w + 1)
                            val6 = m._hx_def.z
                            buf.vertexes[index6] = val6
                        else:
                            index7 = w
                            w = (w + 1)
                            val7 = m._hx_def.x
                            buf.vertexes[index7] = val7
                            index8 = w
                            w = (w + 1)
                            val8 = m._hx_def.y
                            buf.vertexes[index8] = val8
                            index9 = w
                            w = (w + 1)
                            val9 = m._hx_def.z
                            buf.vertexes[index9] = val9
                            index10 = w
                            w = (w + 1)
                            val10 = m._hx_def.w
                            buf.vertexes[index10] = val10
                    m = m.next
            if isSmall:
                r = 0
                _g = 0
                _g1 = len(buf.indexes)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    this1 = buf.indexes
                    pos = r
                    r = (r + 1)
                    pos1 = r
                    r = (r + 1)
                    val = (ibuf.b[pos] | ((ibuf.b[pos1] << 8)))
                    this1[i] = val
            else:
                _g = 0
                _g1 = len(buf.indexes)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    this1 = buf.indexes
                    pos = (i << 2)
                    v = (((ibuf.b[pos] | ((ibuf.b[(pos + 1)] << 8))) | ((ibuf.b[(pos + 2)] << 16))) | ((ibuf.b[(pos + 3)] << 24)))
                    val = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                    this1[i] = val
        else:
            icount = (geom.indexCounts[material] if material >= 0 and material < len(geom.indexCounts) else None)
            this1 = [None]*geom.vertexCount
            vmap = this1
            this1 = list()
            vertexes = this1
            this1 = [None]*icount
            buf.indexes = this1
            r = 0
            vcount = 0
            _g = 0
            _g1 = len(buf.indexes)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                vid = None
                if isSmall:
                    pos = r
                    r = (r + 1)
                    pos1 = r
                    r = (r + 1)
                    vid = (ibuf.b[pos] | ((ibuf.b[pos1] << 8)))
                else:
                    pos2 = (i << 2)
                    v = (((ibuf.b[pos2] | ((ibuf.b[(pos2 + 1)] << 8))) | ((ibuf.b[(pos2 + 2)] << 16))) | ((ibuf.b[(pos2 + 3)] << 24)))
                    vid = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                rid = vmap[vid]
                if (rid == 0):
                    vcount = (vcount + 1)
                    rid = vcount
                    vmap[vid] = rid
                    m = _hx_map
                    while (m is not None):
                        if (m._hx_def is None):
                            r1 = (vid * geom.vertexStride)
                            _g2 = 0
                            _g3 = m.size
                            while (_g2 < _g3):
                                i1 = _g2
                                _g2 = (_g2 + 1)
                                v1 = vbuf.getFloat((((r1 + m.offset) + i1) << 2))
                                vertexes.append(v1)
                        else:
                            _g4 = m.size
                            if (_g4 == 1):
                                v2 = m._hx_def.x
                                vertexes.append(v2)
                            elif (_g4 == 2):
                                v3 = m._hx_def.x
                                vertexes.append(v3)
                                v4 = m._hx_def.y
                                vertexes.append(v4)
                            elif (_g4 == 3):
                                v5 = m._hx_def.x
                                vertexes.append(v5)
                                v6 = m._hx_def.y
                                vertexes.append(v6)
                                v7 = m._hx_def.z
                                vertexes.append(v7)
                            else:
                                v8 = m._hx_def.x
                                vertexes.append(v8)
                                v9 = m._hx_def.y
                                vertexes.append(v9)
                                v10 = m._hx_def.z
                                vertexes.append(v10)
                                v11 = m._hx_def.w
                                vertexes.append(v11)
                        m = m.next
                val = (rid - 1)
                buf.indexes[i] = val
            buf.vertexes = vertexes
        entry.close()
        return buf

    def makePrimitive(self,id):
        p = (self.cachedPrimitives[id] if id >= 0 and id < len(self.cachedPrimitives) else None)
        if (p is not None):
            return p
        p = h3d_prim_HMDModel(python_internal_ArrayImpl._get(self.header.geometries, id),self.header.dataPosition,self)
        p.incref()
        python_internal_ArrayImpl._set(self.cachedPrimitives, id, p)
        return p

    def makeMaterial(self,model,mid,loadTexture):
        m = python_internal_ArrayImpl._get(self.header.materials, mid)
        mat = h3d_mat_MaterialSetup.current.createMaterial()
        mat.name = m.name
        if (m.diffuseTexture is not None):
            mat.set_texture(loadTexture(m.diffuseTexture))
            if (mat.get_texture() is None):
                mat.set_texture(h3d_mat_Texture.fromColor(16711935))
        if (m.specularTexture is not None):
            mat.set_specularTexture(loadTexture(m.specularTexture))
        if (m.normalMap is not None):
            mat.set_normalMap(loadTexture(m.normalMap))
        mat.set_blendMode(m.blendMode)
        mat.model = self.resource
        props = h3d_mat_MaterialSetup.current.loadMaterialProps(mat)
        if (props is None):
            props = mat.getDefaultModelProps()
        mat.set_props(props)
        return mat

    def makeSkin(self,skin):
        s = self.cachedSkin.h.get(skin.name,None)
        if (s is not None):
            return s
        s = h3d_anim_Skin(skin.name,0,3)
        s.namedJoints = haxe_ds_StringMap()
        s.allJoints = []
        s.boundJoints = []
        s.rootJoints = []
        _g = 0
        _g1 = skin.joints
        while (_g < len(_g1)):
            joint = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            j = h3d_anim_Joint()
            j.name = joint.name
            j.index = len(s.allJoints)
            j.defMat = joint.position.toMatrix()
            if (joint.bind >= 0):
                j.bindIndex = joint.bind
                j.transPos = joint.transpos.toMatrix(True)
                python_internal_ArrayImpl._set(s.boundJoints, j.bindIndex, j)
            if (joint.parent >= 0):
                p = python_internal_ArrayImpl._get(s.allJoints, joint.parent)
                _this = p.subs
                _this.append(j)
                j.parent = p
            else:
                _this1 = s.rootJoints
                _this1.append(j)
            _this2 = s.allJoints
            _this2.append(j)
            s.namedJoints.h[j.name] = j
        if (skin.split is not None):
            s.splitJoints = []
            _g = 0
            _g1 = skin.split
            while (_g < len(_g1)):
                ss = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _this = s.splitJoints
                ss1 = ss.materialIndex
                _g2 = []
                _g3 = 0
                _g4 = ss.joints
                while (_g3 < len(_g4)):
                    j = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                    _g3 = (_g3 + 1)
                    x = (s.allJoints[j] if j >= 0 and j < len(s.allJoints) else None)
                    _g2.append(x)
                _this.append(_hx_AnonObject({'material': ss1, 'joints': _g2}))
        self.cachedSkin.h[skin.name] = s
        return s

    def getModelProperty(self,objName,p,_hx_def = None):
        _g = 0
        _g1 = self.header.models
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (m.name == objName):
                if (m.props is not None):
                    _g2 = 0
                    _g3 = m.props
                    while (_g2 < len(_g3)):
                        pr = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                        _g2 = (_g2 + 1)
                        if (pr.index == p.index):
                            return python_internal_ArrayImpl._get(list(pr.params), 0)
                return _hx_def
        if (_hx_def is None):
            raise haxe_Exception.thrown((("Model " + ("null" if objName is None else objName)) + " not found"))
        return _hx_def

    def makeObject(self,loadTexture = None):
        if (loadTexture is None):
            def _hx_local_0(_):
                return h3d_mat_Texture.fromColor(16711935)
            loadTexture = _hx_local_0
        if (len(self.header.models) == 0):
            raise haxe_Exception.thrown("This file does not contain any model")
        objs = []
        _g = 0
        _g1 = self.header.models
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            obj = None
            if (m.geometry < 0):
                obj = h3d_scene_Object()
            else:
                prim = self.makePrimitive(m.geometry)
                if (m.skin is not None):
                    skinData = self.makeSkin(m.skin)
                    skinData.primitive = prim
                    _g2 = []
                    _g3 = 0
                    _g4 = m.materials
                    while (_g3 < len(_g4)):
                        mat = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                        _g3 = (_g3 + 1)
                        x = self.makeMaterial(m,mat,loadTexture)
                        _g2.append(x)
                    obj = h3d_scene_Skin(skinData,_g2)
                elif (len(m.materials) == 1):
                    obj = h3d_scene_Mesh(prim,self.makeMaterial(m,(m.materials[0] if 0 < len(m.materials) else None),loadTexture))
                else:
                    _g5 = []
                    _g6 = 0
                    _g7 = m.materials
                    while (_g6 < len(_g7)):
                        mat1 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                        _g6 = (_g6 + 1)
                        x1 = self.makeMaterial(m,mat1,loadTexture)
                        _g5.append(x1)
                    obj = h3d_scene_MultiMaterial(prim,_g5)
            obj.name = m.name
            v = m.position.toMatrix()
            obj.defaultTransform = v
            f = 1
            b = True
            if b:
                obj.flags = (obj.flags | f)
            else:
                obj.flags = (obj.flags & ~f)
            objs.append(obj)
            p = python_internal_ArrayImpl._get(objs, m.parent)
            if (p is not None):
                p.addChild(obj)
        return (objs[0] if 0 < len(objs) else None)

    def loadAnimation(self,name = None):
        a = self.cachedAnimations.h.get(("" if ((name is None)) else name),None)
        if (a is not None):
            return a
        a = None
        if (name is None):
            if (len(self.header.animations) == 0):
                return None
            a = python_internal_ArrayImpl._get(self.header.animations, 0)
        else:
            _g = 0
            _g1 = self.header.animations
            while (_g < len(_g1)):
                a2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (a2.name == name):
                    a = a2
                    break
            if (a is None):
                raise haxe_Exception.thrown((("Animation " + ("null" if name is None else name)) + " not found !"))
        l = (self.makeLinearAnimation(a) if ((self.header.version <= 2)) else self.makeAnimation(a))
        l.speed = a.speed
        l.loop = a.loop
        if (a.events is not None):
            l.setEvents(a.events)
        l.resourcePath = self.resource.entry.get_path()
        self.cachedAnimations.h[a.name] = l
        if (name is None):
            self.cachedAnimations.h[""] = l
        return l

    def makeAnimation(self,a):
        b = h3d_anim_BufferAnimation(a.name,a.frames,a.sampling)
        stride = 0
        singleFrames = []
        otherFrames = []
        _g = 0
        _g1 = a.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c = b.addObject(o.name,0)
            sm = 1
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.SingleFrame.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.SingleFrame.index)))
                singleFrames.append(c)
                sm = 0
            else:
                otherFrames.append(c)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.Position.index)))
                stride = (stride + ((3 * sm)))
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.Rotation.index)))
                stride = (stride + ((3 * sm)))
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.Scale.index)))
                stride = (stride + ((3 * sm)))
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasUV.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.UV.index)))
                stride = (stride + ((2 * sm)))
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasAlpha.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.Alpha.index)))
                stride = (stride + sm)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                _g2 = 0
                _g3 = len(o.props)
                while (_g2 < _g3):
                    i = _g2
                    _g2 = (_g2 + 1)
                    c1 = c
                    if (i > 0):
                        c1 = b.addObject(o.name,0)
                        if (sm == 0):
                            singleFrames.append(c1)
                        else:
                            otherFrames.append(c1)
                    c1.layout = (c1.layout | ((1 << h3d_anim_DataLayout.Property.index)))
                    c1.propName = (o.props[i] if i >= 0 and i < len(o.props) else None)
                    stride = (stride + sm)
        pos = 0
        _g = 0
        while (_g < len(singleFrames)):
            b1 = (singleFrames[_g] if _g >= 0 and _g < len(singleFrames) else None)
            _g = (_g + 1)
            b1.dataOffset = pos
            pos = (pos + b1.getStride())
        singleStride = pos
        _g = 0
        while (_g < len(otherFrames)):
            b1 = (otherFrames[_g] if _g >= 0 and _g < len(otherFrames) else None)
            _g = (_g + 1)
            b1.dataOffset = pos
            pos = (pos + b1.getStride())
        entry = self.resource.entry
        entry.open()
        entry.skip((self.header.dataPosition + a.dataPosition))
        count = ((stride * a.frames) + singleStride)
        data = haxe_io_Bytes.alloc((count * 4))
        entry.read(data,0,data.length)
        entry.close()
        this1 = [None]*count
        v = this1
        _g = 0
        _g1 = count
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            val = data.getFloat((i << 2))
            v[i] = val
        b.setData(v,stride)
        return b

    def makeLinearAnimation(self,a):
        l = h3d_anim_LinearAnimation(a.name,a.frames,a.sampling)
        entry = self.resource.entry
        entry.open()
        entry.skip((self.header.dataPosition + a.dataPosition))
        _g = 0
        _g1 = a.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            pos = (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))) != 0)
            rot = (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))) != 0)
            scale = (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))) != 0)
            if ((pos or rot) or scale):
                frameCount = a.frames
                if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.SingleFrame.index)))) != 0):
                    frameCount = 1
                this1 = [None]*frameCount
                fl = this1
                size = (((((((3 if pos else 0)) + ((3 if rot else 0))) + ((3 if scale else 0)))) * 4) * frameCount)
                data = haxe_io_Bytes.alloc(size)
                entry.read(data,0,size)
                p = 0
                _g2 = 0
                _g3 = frameCount
                while (_g2 < _g3):
                    i = _g2
                    _g2 = (_g2 + 1)
                    f = h3d_anim_LinearFrame()
                    if pos:
                        f.tx = data.getFloat(p)
                        p = (p + 4)
                        f.ty = data.getFloat(p)
                        p = (p + 4)
                        f.tz = data.getFloat(p)
                        p = (p + 4)
                    else:
                        f.tx = 0
                        f.ty = 0
                        f.tz = 0
                    if rot:
                        f.qx = data.getFloat(p)
                        p = (p + 4)
                        f.qy = data.getFloat(p)
                        p = (p + 4)
                        f.qz = data.getFloat(p)
                        p = (p + 4)
                        qw = (1 - ((((f.qx * f.qx) + ((f.qy * f.qy))) + ((f.qz * f.qz)))))
                        tmp = None
                        if (qw < 0):
                            f1 = -qw
                            tmp = -((Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1)))
                        else:
                            tmp = (Math.NaN if ((qw < 0)) else python_lib_Math.sqrt(qw))
                        f.qw = tmp
                    else:
                        f.qx = 0
                        f.qy = 0
                        f.qz = 0
                        f.qw = 1
                    if scale:
                        f.sx = data.getFloat(p)
                        p = (p + 4)
                        f.sy = data.getFloat(p)
                        p = (p + 4)
                        f.sz = data.getFloat(p)
                        p = (p + 4)
                    else:
                        f.sx = 1
                        f.sy = 1
                        f.sz = 1
                    fl[i] = f
                l.addCurve(o.name,fl,True,rot,scale)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasUV.index)))) != 0):
                this2 = [None]*(a.frames * 2)
                fl1 = this2
                size1 = (8 * a.frames)
                data1 = haxe_io_Bytes.alloc(size1)
                entry.read(data1,0,size1)
                _g4 = 0
                _g5 = len(fl1)
                while (_g4 < _g5):
                    i1 = _g4
                    _g4 = (_g4 + 1)
                    val = data1.getFloat((i1 * 4))
                    fl1[i1] = val
                l.addUVCurve(o.name,fl1)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasAlpha.index)))) != 0):
                this3 = [None]*a.frames
                fl2 = this3
                size2 = (4 * a.frames)
                data2 = haxe_io_Bytes.alloc(size2)
                entry.read(data2,0,size2)
                _g6 = 0
                _g7 = len(fl2)
                while (_g6 < _g7):
                    i2 = _g6
                    _g6 = (_g6 + 1)
                    val1 = data2.getFloat((i2 * 4))
                    fl2[i2] = val1
                l.addAlphaCurve(o.name,fl2)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                _g8 = 0
                _g9 = o.props
                while (_g8 < len(_g9)):
                    p1 = (_g9[_g8] if _g8 >= 0 and _g8 < len(_g9) else None)
                    _g8 = (_g8 + 1)
                    this4 = [None]*a.frames
                    fl3 = this4
                    size3 = (4 * a.frames)
                    data3 = haxe_io_Bytes.alloc(size3)
                    entry.read(data3,0,size3)
                    _g10 = 0
                    _g11 = len(fl3)
                    while (_g10 < _g11):
                        i3 = _g10
                        _g10 = (_g10 + 1)
                        val2 = data3.getFloat((i3 * 4))
                        fl3[i3] = val2
                    l.addPropCurve(o.name,p1,fl3)
        entry.close()
        return l

    def loadSkin(self,geom,skin,optimize = None):
        if (optimize is None):
            optimize = True
        if (skin.vertexWeights is not None):
            return
        if (skin.bonesPerVertex != 3):
            raise haxe_Exception.thrown("assert")
        skin.vertexCount = geom.vertexCount
        data = self.getBuffers(geom,[hxd_fmt_hmd_GeometryFormat("position",3), hxd_fmt_hmd_GeometryFormat("weights",3), hxd_fmt_hmd_GeometryFormat("indexes",9)])
        this1 = [None]*(skin.vertexCount * skin.bonesPerVertex)
        skin.vertexWeights = this1
        this1 = [None]*(skin.vertexCount * skin.bonesPerVertex)
        skin.vertexJoints = this1
        _g = 0
        _g1 = skin.boundJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            j.offsets = h3d_col_Bounds()
        vbuf = data.vertexes
        idx = 0
        bounds_xMin = 1e20
        bounds_xMax = -1e20
        bounds_yMin = 1e20
        bounds_yMax = -1e20
        bounds_zMin = 1e20
        bounds_zMax = -1e20
        out = Math.NaN
        ranges = None
        if (skin.splitJoints is None):
            jointsByBind = []
            _g = 0
            _g1 = skin.boundJoints
            while (_g < len(_g1)):
                j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                python_internal_ArrayImpl._set(jointsByBind, j.bindIndex, j)
            ranges = [_hx_AnonObject({'index': 0, 'pos': 0, 'count': len(data.indexes), 'joints': jointsByBind})]
        else:
            idx = 0
            triPos = []
            pos = 0
            _g = 0
            _g1 = geom.indexCounts
            while (_g < len(_g1)):
                n = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                triPos.append(pos)
                pos = (pos + n)
            _g = []
            _g1 = 0
            _g2 = skin.splitJoints
            while (_g1 < len(_g2)):
                j = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                idx1 = idx
                triPos1 = (triPos[idx] if idx >= 0 and idx < len(triPos) else None)
                geom1 = idx
                idx = (idx + 1)
                x = _hx_AnonObject({'index': idx1, 'pos': triPos1, 'count': (geom.indexCounts[geom1] if geom1 >= 0 and geom1 < len(geom.indexCounts) else None), 'joints': j.joints})
                _g.append(x)
            ranges = _g
        _g = 0
        while (_g < len(ranges)):
            r = (ranges[_g] if _g >= 0 and _g < len(ranges) else None)
            _g = (_g + 1)
            _g1 = r.pos
            _g2 = (r.pos + r.count)
            while (_g1 < _g2):
                idx = _g1
                _g1 = (_g1 + 1)
                vidx = data.indexes[idx]
                p = (vidx * 7)
                x = vbuf[p]
                if (x != x):
                    continue
                index = p
                p = (p + 1)
                vbuf[index] = out
                index1 = p
                p = (p + 1)
                y = vbuf[index1]
                index2 = p
                p = (p + 1)
                z = vbuf[index2]
                index3 = p
                p = (p + 1)
                w1 = vbuf[index3]
                index4 = p
                p = (p + 1)
                w2 = vbuf[index4]
                index5 = p
                p = (p + 1)
                w3 = vbuf[index5]
                vout = (vidx * 3)
                skin.vertexWeights[vout] = w1
                skin.vertexWeights[(vout + 1)] = w2
                skin.vertexWeights[(vout + 2)] = w3
                w = ((((1 if ((w1 == 0)) else 0)) | ((2 if ((w2 == 0)) else 0))) | ((4 if ((w3 == 0)) else 0)))
                index6 = p
                p = (p + 1)
                idx1 = haxe_io_FPHelper.floatToI32(vbuf[index6])
                if (x < bounds_xMin):
                    bounds_xMin = x
                if (x > bounds_xMax):
                    bounds_xMax = x
                if (y < bounds_yMin):
                    bounds_yMin = y
                if (y > bounds_yMax):
                    bounds_yMax = y
                if (z < bounds_zMin):
                    bounds_zMin = z
                if (z > bounds_zMax):
                    bounds_zMax = z
                _g3 = 0
                while (_g3 < 3):
                    i = _g3
                    _g3 = (_g3 + 1)
                    if (((w & ((1 << i)))) != 0):
                        index7 = vout
                        vout = (vout + 1)
                        skin.vertexJoints[index7] = -1
                        continue
                    idx2 = ((idx1 >> ((i << 3))) & 255)
                    j = (r.joints[idx2] if idx2 >= 0 and idx2 < len(r.joints) else None)
                    _this = j.offsets
                    if (x < _this.xMin):
                        _this.xMin = x
                    if (x > _this.xMax):
                        _this.xMax = x
                    if (y < _this.yMin):
                        _this.yMin = y
                    if (y > _this.yMax):
                        _this.yMax = y
                    if (z < _this.zMin):
                        _this.zMin = z
                    if (z > _this.zMax):
                        _this.zMax = z
                    index8 = vout
                    vout = (vout + 1)
                    val = j.bindIndex
                    skin.vertexJoints[index8] = val
        if optimize:
            idx = (len(skin.allJoints) - 1)
            optOut = 0
            refVolume = ((((bounds_xMax - bounds_xMin)) * ((bounds_yMax - bounds_yMin))) * ((bounds_zMax - bounds_zMin)))
            while (idx >= 0):
                j = idx
                idx = (idx - 1)
                j1 = (skin.allJoints[j] if j >= 0 and j < len(skin.allJoints) else None)
                if (((j1.offsets is None) or ((j1.parent is None))) or ((j1.parent.offsets is None))):
                    continue
                poff = j1.parent.offsets
                _this = j1.offsets
                dx = (_this.xMax - _this.xMin)
                dy = (_this.yMax - _this.yMin)
                dz = (_this.zMax - _this.zMin)
                x = (((_this.xMin + _this.xMax)) * 0.5)
                y = (((_this.yMin + _this.yMax)) * 0.5)
                z = (((_this.zMin + _this.zMax)) * 0.5)
                f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
                r = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 0.5)
                if (r is None):
                    r = 0.
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                sx = x
                sy = y
                sz = z
                sr = r
                if (sr is None):
                    sr = 0.
                if (sz is None):
                    sz = 0.
                if (sy is None):
                    sy = 0.
                if (sx is None):
                    sx = 0.
                sp_x = sx
                sp_y = sy
                sp_z = sz
                sp_r = sr
                if ((((((poff.xMin <= ((sp_x - sp_r))) and ((poff.yMin <= ((sp_y - sp_r))))) and ((poff.zMin <= ((sp_z - sp_r))))) and ((poff.xMax >= ((sp_x + sp_r))))) and ((poff.yMax >= ((sp_y + sp_r))))) and ((poff.zMax >= ((sp_z + sp_r))))):
                    j1.offsets = None
                    optOut = (optOut + 1)
                    continue
                b = h3d_col_Bounds()
                b.xMin = poff.xMin
                b.xMax = poff.xMax
                b.yMin = poff.yMin
                b.yMax = poff.yMax
                b.zMin = poff.zMin
                b.zMax = poff.zMax
                pext = b
                x1 = sp_x
                y1 = sp_y
                z1 = sp_z
                r1 = sp_r
                if ((x1 - r1) < pext.xMin):
                    pext.xMin = (x1 - r1)
                if ((x1 + r1) > pext.xMax):
                    pext.xMax = (x1 + r1)
                if ((y1 - r1) < pext.yMin):
                    pext.yMin = (y1 - r1)
                if ((y1 + r1) > pext.yMax):
                    pext.yMax = (y1 + r1)
                if ((z1 - r1) < pext.zMin):
                    pext.zMin = (z1 - r1)
                if ((z1 + r1) > pext.zMax):
                    pext.zMax = (z1 + r1)
                f1 = ((refVolume * 1.5) / (((((pext.xMax - pext.xMin)) * ((pext.yMax - pext.yMin))) * ((pext.zMax - pext.zMin)))))
                ratio = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
                k = (((((pext.xMax - pext.xMin)) * ((pext.yMax - pext.yMin))) * ((pext.zMax - pext.zMin))) / (((((poff.xMax - poff.xMin)) * ((poff.yMax - poff.yMin))) * ((poff.zMax - poff.zMin)))))
                if (k < ratio):
                    j1.parent.offsets = pext
                    j1.offsets = None
                    optOut = (optOut + 1)
                    continue
        _g = 0
        _g1 = skin.allJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (j.offsets is None):
                j.offsetRay = -1
                continue
            b = j.offsets
            pt1 = None
            pt2 = None
            x = (((b.xMin + b.xMax)) * 0.5)
            y = (((b.yMin + b.yMax)) * 0.5)
            z = (((b.zMin + b.zMax)) * 0.5)
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            off_x = x
            off_y = y
            off_z = z
            r = None
            if (((b.xMax - b.xMin) > ((b.yMax - b.yMin))) and (((b.xMax - b.xMin) > ((b.zMax - b.zMin))))):
                a = (b.yMax - b.yMin)
                b1 = (b.zMax - b.zMin)
                r = (((b1 if ((a < b1)) else a)) * 0.5)
                pt1 = h3d_col_Point((b.xMin + r),off_y,off_z)
                pt2 = h3d_col_Point((b.xMax - r),off_y,off_z)
            elif ((b.yMax - b.yMin) > ((b.zMax - b.zMin))):
                a1 = (b.xMax - b.xMin)
                b2 = (b.zMax - b.zMin)
                r = (((b2 if ((a1 < b2)) else a1)) * 0.5)
                pt1 = h3d_col_Point(off_x,(b.yMin + r),off_z)
                pt2 = h3d_col_Point(off_x,(b.yMax - r),off_z)
            else:
                a2 = (b.xMax - b.xMin)
                b3 = (b.yMax - b.yMin)
                r = (((b3 if ((a2 < b3)) else a2)) * 0.5)
                pt1 = h3d_col_Point(off_x,off_y,(b.zMin + r))
                pt2 = h3d_col_Point(off_x,off_y,(b.zMax - r))
            b.xMin = pt1.x
            b.yMin = pt1.y
            b.zMin = pt1.z
            b.xMax = pt2.x
            b.yMax = pt2.y
            b.zMax = pt2.z
            j.offsetRay = r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.resource = None
        _hx_o.header = None
        _hx_o.cachedPrimitives = None
        _hx_o.cachedAnimations = None
        _hx_o.cachedSkin = None
hxd_fmt_hmd_Library._hx_class = hxd_fmt_hmd_Library
_hx_classes["hxd.fmt.hmd.Library"] = hxd_fmt_hmd_Library


class hxd_fmt_hmd_Reader:
    _hx_class_name = "hxd.fmt.hmd.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i", "version")
    _hx_fields = ["i", "version"]
    _hx_methods = ["readProperty", "readProps", "readName", "readCachedName", "readPosition", "readBounds", "readSkin", "readHeader", "read"]
    _hx_statics = ["BLEND", "CULLING", "HMD_STRINGS"]

    def __init__(self,i):
        self.version = None
        self.i = i

    def readProperty(self):
        _g = self.i.readByte()
        _g1 = _g
        if (_g1 == 0):
            return hxd_fmt_hmd_Property.CameraFOVY(self.i.readFloat())
        elif (_g1 == 1):
            raise haxe_Exception.thrown("Obsolete HasMaterialFlags")
        elif (_g1 == 2):
            return hxd_fmt_hmd_Property.HasExtraTextures
        else:
            unk = _g
            raise haxe_Exception.thrown(("Unknown property #" + Std.string(unk)))

    def readProps(self):
        if (self.version == 1):
            return None
        n = self.i.readByte()
        if (n == 0):
            return None
        _g = []
        _g1 = 0
        _g2 = n
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = self.readProperty()
            _g.append(x)
        return _g

    def readName(self):
        b = self.i.readByte()
        if (b == 255):
            return None
        return self.i.readString(b)

    def readCachedName(self):
        name = self.readName()
        if (name is None):
            return None
        if (hxd_fmt_hmd_Reader.HMD_STRINGS is None):
            hxd_fmt_hmd_Reader.HMD_STRINGS = haxe_ds_StringMap()
        n = hxd_fmt_hmd_Reader.HMD_STRINGS.h.get(name,None)
        if (n is not None):
            return n
        hxd_fmt_hmd_Reader.HMD_STRINGS.h[name] = name
        return name

    def readPosition(self,hasScale = None):
        if (hasScale is None):
            hasScale = True
        p = hxd_fmt_hmd_Position()
        p.x = self.i.readFloat()
        p.y = self.i.readFloat()
        p.z = self.i.readFloat()
        p.qx = self.i.readFloat()
        p.qy = self.i.readFloat()
        p.qz = self.i.readFloat()
        if hasScale:
            p.sx = self.i.readFloat()
            p.sy = self.i.readFloat()
            p.sz = self.i.readFloat()
        else:
            p.sx = 1
            p.sy = 1
            p.sz = 1
        return p

    def readBounds(self):
        b = h3d_col_Bounds()
        b.xMin = self.i.readFloat()
        b.yMin = self.i.readFloat()
        b.zMin = self.i.readFloat()
        b.xMax = self.i.readFloat()
        b.yMax = self.i.readFloat()
        b.zMax = self.i.readFloat()
        return b

    def readSkin(self):
        name = self.readCachedName()
        if (name is None):
            return None
        s = hxd_fmt_hmd_Skin()
        s.props = self.readProps()
        s.name = name
        s.joints = []
        _g = 0
        _g1 = self.i.readUInt16()
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            j = hxd_fmt_hmd_SkinJoint()
            j.props = self.readProps()
            j.name = self.readCachedName()
            pid = self.i.readUInt16()
            hasScale = (((pid & 32768)) != 0)
            if hasScale:
                pid = (pid & 32767)
            j.parent = (pid - 1)
            j.position = self.readPosition(hasScale)
            j.bind = (self.i.readUInt16() - 1)
            if (j.bind >= 0):
                j.transpos = self.readPosition(hasScale)
            _this = s.joints
            _this.append(j)
        count = self.i.readByte()
        if (count > 0):
            s.split = []
            _g = 0
            _g1 = count
            while (_g < _g1):
                k = _g
                _g = (_g + 1)
                ss = hxd_fmt_hmd_SkinSplit()
                ss.materialIndex = self.i.readByte()
                _g2 = []
                _g3 = 0
                _g4 = self.i.readByte()
                while (_g3 < _g4):
                    k1 = _g3
                    _g3 = (_g3 + 1)
                    x = self.i.readUInt16()
                    _g2.append(x)
                ss.joints = _g2
                _this = s.split
                _this.append(ss)
        return s

    def readHeader(self):
        d = hxd_fmt_hmd_Data()
        h = self.i.readString(3)
        if (h != "HMD"):
            if (HxString.charCodeAt(h,0) == 59):
                raise haxe_Exception.thrown("FBX was not converted to HMD")
            raise haxe_Exception.thrown(("Invalid HMD header " + HxOverrides.stringOrNull(python_lib_urllib_Parse.quote(h,""))))
        self.version = self.i.readByte()
        if (self.version > 3):
            raise haxe_Exception.thrown(("Can't read HMD v" + Std.string(self.version)))
        d.version = self.version
        d.geometries = []
        d.dataPosition = self.i.readInt32()
        d.props = self.readProps()
        _g = 0
        _g1 = self.i.readInt32()
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            g = hxd_fmt_hmd_Geometry()
            g.props = self.readProps()
            g.vertexCount = self.i.readInt32()
            g.vertexStride = self.i.readByte()
            _g2 = []
            _g3 = 0
            _g4 = self.i.readByte()
            while (_g3 < _g4):
                k1 = _g3
                _g3 = (_g3 + 1)
                x = self.readCachedName()
                this1 = self.i.readByte()
                x1 = hxd_fmt_hmd_GeometryFormat(x,this1)
                _g2.append(x1)
            g.vertexFormat = _g2
            g.vertexPosition = self.i.readInt32()
            _g5 = []
            _g6 = 0
            _g7 = self.i.readByte()
            while (_g6 < _g7):
                k2 = _g6
                _g6 = (_g6 + 1)
                x2 = self.i.readInt32()
                _g5.append(x2)
            g.indexCounts = _g5
            g.indexPosition = self.i.readInt32()
            g.bounds = self.readBounds()
            _this = d.geometries
            _this.append(g)
        d.materials = []
        _g = 0
        _g1 = self.i.readInt32()
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            m = hxd_fmt_hmd_Material()
            m.props = self.readProps()
            m.name = self.readName()
            m.diffuseTexture = self.readName()
            m.blendMode = python_internal_ArrayImpl._get(hxd_fmt_hmd_Reader.BLEND, self.i.readByte())
            self.i.readByte()
            self.i.readFloat()
            if ((m.props is not None) and ((python_internal_ArrayImpl.indexOf(m.props,hxd_fmt_hmd_Property.HasExtraTextures,None) >= 0))):
                m.specularTexture = self.readName()
                m.normalMap = self.readName()
            _this = d.materials
            _this.append(m)
        d.models = []
        _g = 0
        _g1 = self.i.readInt32()
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            m = hxd_fmt_hmd_Model()
            m.props = self.readProps()
            m.name = self.readCachedName()
            m.parent = (self.i.readInt32() - 1)
            m.follow = self.readCachedName()
            m.position = self.readPosition()
            m.geometry = (self.i.readInt32() - 1)
            _this = d.models
            _this.append(m)
            if (m.geometry < 0):
                continue
            m.materials = []
            _g2 = 0
            _g3 = self.i.readByte()
            while (_g2 < _g3):
                k1 = _g2
                _g2 = (_g2 + 1)
                _this1 = m.materials
                x = self.i.readInt32()
                _this1.append(x)
            m.skin = self.readSkin()
        d.animations = []
        _g = 0
        _g1 = self.i.readInt32()
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            a = hxd_fmt_hmd_Animation()
            a.props = self.readProps()
            a.name = self.readName()
            a.frames = self.i.readInt32()
            a.sampling = self.i.readFloat()
            a.speed = self.i.readFloat()
            flags = self.i.readByte()
            a.loop = (((flags & 1)) != 0)
            a.dataPosition = self.i.readInt32()
            a.objects = []
            _g2 = 0
            _g3 = self.i.readInt32()
            while (_g2 < _g3):
                k1 = _g2
                _g2 = (_g2 + 1)
                o = hxd_fmt_hmd_AnimationObject()
                o.name = self.readCachedName()
                i = self.i.readByte()
                if (i is None):
                    i = 0
                this1 = i
                o.flags = this1
                _this = a.objects
                _this.append(o)
                if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                    _g4 = []
                    _g5 = 0
                    _g6 = self.i.readByte()
                    while (_g5 < _g6):
                        i1 = _g5
                        _g5 = (_g5 + 1)
                        x = self.readName()
                        _g4.append(x)
                    o.props = _g4
            if (((flags & 2)) != 0):
                a.events = []
                _g7 = 0
                _g8 = self.i.readInt32()
                while (_g7 < _g8):
                    k2 = _g7
                    _g7 = (_g7 + 1)
                    e = hxd_fmt_hmd_AnimationEvent()
                    e.frame = self.i.readInt32()
                    e.data = self.readCachedName()
                    _this1 = a.events
                    _this1.append(e)
            _this2 = d.animations
            _this2.append(a)
        return d

    def read(self):
        h = self.readHeader()
        h.data = self.i.read(self.i.readInt32())
        return h
    HMD_STRINGS = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.version = None
hxd_fmt_hmd_Reader._hx_class = hxd_fmt_hmd_Reader
_hx_classes["hxd.fmt.hmd.Reader"] = hxd_fmt_hmd_Reader


class hxd_fmt_hmd_Writer:
    _hx_class_name = "hxd.fmt.hmd.Writer"
    _hx_is_interface = "False"
    __slots__ = ("out", "version")
    _hx_fields = ["out", "version"]
    _hx_methods = ["writeProperty", "writeProps", "writeName", "writeFloat", "writePosition", "writeBounds", "writeSkin", "write"]

    def __init__(self,out):
        self.version = None
        self.out = out

    def writeProperty(self,p):
        self.out.writeByte(p.index)
        tmp = p.index
        if (tmp == 0):
            v = p.params[0]
            self.out.writeFloat(v)
        elif (tmp == 1):
            pass
        elif (tmp == 2):
            pass
        else:
            pass

    def writeProps(self,props):
        if (props is None):
            if (self.version == 1):
                return
            self.out.writeByte(0)
            return
        if (self.version == 1):
            raise haxe_Exception.thrown("Properties not supported in HMDv1")
        self.out.writeByte(len(props))
        _g = 0
        while (_g < len(props)):
            p = (props[_g] if _g >= 0 and _g < len(props) else None)
            _g = (_g + 1)
            self.writeProperty(p)

    def writeName(self,name):
        if (name is None):
            self.out.writeByte(255)
            return
        self.out.writeByte(len(name))
        self.out.writeString(name)

    def writeFloat(self,f):
        self.out.writeFloat((0 if ((f == 0)) else f))

    def writePosition(self,p,hasScale = None):
        if (hasScale is None):
            hasScale = True
        f = p.x
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = p.y
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = p.z
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = p.qx
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = p.qy
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = p.qz
        self.out.writeFloat((0 if ((f == 0)) else f))
        if hasScale:
            f = p.sx
            self.out.writeFloat((0 if ((f == 0)) else f))
            f = p.sy
            self.out.writeFloat((0 if ((f == 0)) else f))
            f = p.sz
            self.out.writeFloat((0 if ((f == 0)) else f))

    def writeBounds(self,b):
        f = b.xMin
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = b.yMin
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = b.zMin
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = b.xMax
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = b.yMax
        self.out.writeFloat((0 if ((f == 0)) else f))
        f = b.zMax
        self.out.writeFloat((0 if ((f == 0)) else f))

    def writeSkin(self,s):
        self.writeName(("" if ((s.name is None)) else s.name))
        self.writeProps(s.props)
        self.out.writeUInt16(len(s.joints))
        _g = 0
        _g1 = s.joints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(j.props)
            self.writeName(j.name)
            rot = ((((j.position.sx != 1) or ((j.position.sy != 1))) or ((j.position.sz != 1))) or (((j.transpos is not None) and ((((j.transpos.sx != 1) or ((j.transpos.sy != 1))) or ((j.transpos.sz != 1)))))))
            self.out.writeUInt16(((j.parent + 1) | ((32768 if rot else 0))))
            self.writePosition(j.position,rot)
            self.out.writeUInt16((j.bind + 1))
            if (j.bind >= 0):
                self.writePosition(j.transpos,rot)
        self.out.writeByte((0 if ((s.split is None)) else len(s.split)))
        if (s.split is not None):
            _g = 0
            _g1 = s.split
            while (_g < len(_g1)):
                ss = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.out.writeByte(ss.materialIndex)
                self.out.writeByte(len(ss.joints))
                _g2 = 0
                _g3 = ss.joints
                while (_g2 < len(_g3)):
                    i = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    self.out.writeUInt16(i)

    def write(self,d):
        old = self.out
        header = haxe_io_BytesOutput()
        self.out = header
        self.version = d.version
        if (self.version > 3):
            raise haxe_Exception.thrown(("Can't write HMD v" + Std.string(self.version)))
        self.writeProps(d.props)
        self.out.writeInt32(len(d.geometries))
        _g = 0
        _g1 = d.geometries
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(g.props)
            self.out.writeInt32(g.vertexCount)
            self.out.writeByte(g.vertexStride)
            self.out.writeByte(len(g.vertexFormat))
            _g2 = 0
            _g3 = g.vertexFormat
            while (_g2 < len(_g3)):
                f = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.writeName(f.name)
                self.out.writeByte(f.format)
            self.out.writeInt32(g.vertexPosition)
            self.out.writeByte(len(g.indexCounts))
            _g4 = 0
            _g5 = g.indexCounts
            while (_g4 < len(_g5)):
                i = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                self.out.writeInt32(i)
            self.out.writeInt32(g.indexPosition)
            self.writeBounds(g.bounds)
        self.out.writeInt32(len(d.materials))
        _g = 0
        _g1 = d.materials
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(m.props)
            self.writeName(m.name)
            self.writeName(m.diffuseTexture)
            self.out.writeByte(m.blendMode.index)
            self.out.writeByte(1)
            self.out.writeFloat(1)
            if ((m.props is not None) and ((python_internal_ArrayImpl.indexOf(m.props,hxd_fmt_hmd_Property.HasExtraTextures,None) >= 0))):
                self.writeName(m.specularTexture)
                self.writeName(m.normalMap)
        self.out.writeInt32(len(d.models))
        _g = 0
        _g1 = d.models
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(m.props)
            self.writeName(m.name)
            self.out.writeInt32((m.parent + 1))
            self.writeName(m.follow)
            self.writePosition(m.position)
            self.out.writeInt32((m.geometry + 1))
            if (m.geometry < 0):
                continue
            self.out.writeByte(len(m.materials))
            _g2 = 0
            _g3 = m.materials
            while (_g2 < len(_g3)):
                m1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.out.writeInt32(m1)
            if (m.skin is None):
                self.writeName(None)
            else:
                self.writeSkin(m.skin)
        self.out.writeInt32(len(d.animations))
        _g = 0
        _g1 = d.animations
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(a.props)
            self.writeName(a.name)
            self.out.writeInt32(a.frames)
            f = a.sampling
            self.out.writeFloat((0 if ((f == 0)) else f))
            f1 = a.speed
            self.out.writeFloat((0 if ((f1 == 0)) else f1))
            self.out.writeByte((((1 if (a.loop) else 0)) | ((2 if ((a.events is not None)) else 0))))
            self.out.writeInt32(a.dataPosition)
            self.out.writeInt32(len(a.objects))
            _g2 = 0
            _g3 = a.objects
            while (_g2 < len(_g3)):
                o = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.writeName(o.name)
                self.out.writeByte(o.flags)
                if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                    self.out.writeByte(len(o.props))
                    _g4 = 0
                    _g5 = o.props
                    while (_g4 < len(_g5)):
                        n = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                        _g4 = (_g4 + 1)
                        self.writeName(n)
            if (a.events is not None):
                self.out.writeInt32(len(a.events))
                _g6 = 0
                _g7 = a.events
                while (_g6 < len(_g7)):
                    e = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                    _g6 = (_g6 + 1)
                    self.out.writeInt32(e.frame)
                    self.writeName(e.data)
        _hx_bytes = header.getBytes()
        self.out = old
        self.out.writeString("HMD")
        self.out.writeByte(d.version)
        self.out.writeInt32((_hx_bytes.length + 12))
        self.out.write(_hx_bytes)
        self.out.writeInt32(d.data.length)
        self.out.write(d.data)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.out = None
        _hx_o.version = None
hxd_fmt_hmd_Writer._hx_class = hxd_fmt_hmd_Writer
_hx_classes["hxd.fmt.hmd.Writer"] = hxd_fmt_hmd_Writer


class hxd_fs_FileEntry:
    _hx_class_name = "hxd.fs.FileEntry"
    _hx_is_interface = "False"
    __slots__ = ("name",)
    _hx_fields = ["name"]
    _hx_methods = ["getSign", "getBytes", "getText", "open", "skip", "readByte", "read", "close", "load", "loadBitmap", "watch", "exists", "get", "iterator", "get_isAvailable", "get_isDirectory", "get_size", "get_path", "get_directory", "get_extension"]

    def getSign(self):
        return 0

    def getBytes(self):
        return None

    def getText(self):
        return self.getBytes().toString()

    def open(self):
        pass

    def skip(self,nbytes):
        pass

    def readByte(self):
        return 0

    def read(self,out,pos,size):
        pass

    def close(self):
        pass

    def load(self,onReady = None):
        if (not self.get_isAvailable()):
            raise haxe_Exception.thrown("load() not implemented")
        elif (onReady is not None):
            onReady()

    def loadBitmap(self,onLoaded):
        raise haxe_Exception.thrown("loadBitmap() not implemented")

    def watch(self,onChanged):
        pass

    def exists(self,name):
        return False

    def get(self,name):
        return None

    def iterator(self):
        return None

    def get_isAvailable(self):
        return True

    def get_isDirectory(self):
        return False

    def get_size(self):
        return 0

    def get_path(self):
        raise haxe_Exception.thrown("path() not implemented")

    def get_directory(self):
        _this = self.get_path()
        startIndex = None
        idx = None
        if (startIndex is None):
            idx = _this.rfind("/", 0, len(_this))
        else:
            i = _this.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = _this.find("/", startLeft, len(_this))
            idx = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (idx < 0):
            return ""
        return HxString.substr(self.get_path(),0,idx)

    def get_extension(self):
        _this = self.name
        startIndex = None
        idx = None
        if (startIndex is None):
            idx = _this.rfind(".", 0, len(_this))
        else:
            i = _this.rfind(".", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("."))) if ((i == -1)) else (i + 1))
            check = _this.find(".", startLeft, len(_this))
            idx = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (idx < 0):
            return ""
        return HxString.substr(self.name,(idx + 1),None).lower()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
hxd_fs_FileEntry._hx_class = hxd_fs_FileEntry
_hx_classes["hxd.fs.FileEntry"] = hxd_fs_FileEntry


class hxd_fs_BytesFileEntry(hxd_fs_FileEntry):
    _hx_class_name = "hxd.fs.BytesFileEntry"
    _hx_is_interface = "False"
    __slots__ = ("fullPath", "bytes", "pos")
    _hx_fields = ["fullPath", "bytes", "pos"]
    _hx_methods = ["get_path", "getSign", "getBytes", "open", "skip", "readByte", "read", "close", "load", "loadBitmap", "exists", "get", "iterator", "get_size"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fs_FileEntry


    def __init__(self,path,_hx_bytes):
        self.pos = None
        self.fullPath = path
        _this = path.split("/")
        self.name = (None if ((len(_this) == 0)) else _this.pop())
        self.bytes = _hx_bytes

    def get_path(self):
        return self.fullPath

    def getSign(self):
        return (((self.bytes.b[0] | ((self.bytes.b[1] << 8))) | ((self.bytes.b[2] << 16))) | ((self.bytes.b[3] << 24)))

    def getBytes(self):
        return self.bytes

    def open(self):
        self.pos = 0

    def skip(self,nbytes):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + nbytes)
        _hx_local_0.pos

    def readByte(self):
        pos = self.pos
        self.pos = (self.pos + 1)
        return self.bytes.b[pos]

    def read(self,out,pos,size):
        out.blit(pos,self.bytes,self.pos,size)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + size)
        _hx_local_0.pos

    def close(self):
        pass

    def load(self,onReady = None):
        haxe_Timer.delay(onReady,1)

    def loadBitmap(self,onLoaded):
        raise haxe_Exception.thrown("Not implemented")

    def exists(self,name):
        return False

    def get(self,name):
        return None

    def iterator(self):
        return hxd_impl_ArrayIterator_hxd_fs_FileEntry(list())

    def get_size(self):
        return self.bytes.length

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fullPath = None
        _hx_o.bytes = None
        _hx_o.pos = None
hxd_fs_BytesFileEntry._hx_class = hxd_fs_BytesFileEntry
_hx_classes["hxd.fs.BytesFileEntry"] = hxd_fs_BytesFileEntry


class hxd_fs_FileSystem:
    _hx_class_name = "hxd.fs.FileSystem"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["getRoot", "get", "exists", "dispose", "dir"]
hxd_fs_FileSystem._hx_class = hxd_fs_FileSystem
_hx_classes["hxd.fs.FileSystem"] = hxd_fs_FileSystem


class hxd_fs_BytesFileSystem:
    _hx_class_name = "hxd.fs.BytesFileSystem"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["getRoot", "getBytes", "exists", "get", "dispose", "dir"]
    _hx_interfaces = [hxd_fs_FileSystem]

    def __init__(self):
        pass

    def getRoot(self):
        raise haxe_Exception.thrown("Not implemented")

    def getBytes(self,path):
        raise haxe_Exception.thrown("Not implemented")

    def exists(self,path):
        return (self.getBytes(path) is not None)

    def get(self,path):
        _hx_bytes = self.getBytes(path)
        if (_hx_bytes is None):
            raise haxe_Exception.thrown((("Resource not found '" + ("null" if path is None else path)) + "'"))
        return hxd_fs_BytesFileEntry(path,_hx_bytes)

    def dispose(self):
        pass

    def dir(self,path):
        raise haxe_Exception.thrown("Not implemented")

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_BytesFileSystem._hx_class = hxd_fs_BytesFileSystem
_hx_classes["hxd.fs.BytesFileSystem"] = hxd_fs_BytesFileSystem


class hxd_fs_Convert:
    _hx_class_name = "hxd.fs.Convert"
    _hx_is_interface = "False"
    __slots__ = ("sourceExts", "destExt", "version", "params", "srcPath", "dstPath", "originalFilename", "srcBytes")
    _hx_fields = ["sourceExts", "destExt", "version", "params", "srcPath", "dstPath", "originalFilename", "srcBytes"]
    _hx_methods = ["convert", "hasParam", "getParam", "save", "command"]
    _hx_statics = ["converts", "register"]

    def __init__(self,sourceExts,destExt):
        self.srcBytes = None
        self.originalFilename = None
        self.dstPath = None
        self.srcPath = None
        self.params = None
        self.sourceExts = (None if ((sourceExts is None)) else HxOverrides.split(sourceExts, ","))
        self.destExt = destExt
        self.version = 0

    def convert(self):
        raise haxe_Exception.thrown("Not implemented")

    def hasParam(self,name):
        f = Reflect.field(self.params,name)
        if (f is not None):
            return (f != False)
        else:
            return False

    def getParam(self,name):
        f = Reflect.field(self.params,name)
        if (f is None):
            raise haxe_Exception.thrown(((((("Missing required parameter '" + ("null" if name is None else name)) + "' for converting ") + HxOverrides.stringOrNull(self.srcPath)) + " to ") + HxOverrides.stringOrNull(self.dstPath)))
        return f

    def save(self,_hx_bytes):
        hxd_File.saveBytes(self.dstPath,_hx_bytes)

    def command(self,cmd,args):
        code = Sys.command(cmd,args)
        if (code != 0):
            raise haxe_Exception.thrown((((("Command '" + ("null" if cmd is None else cmd)) + HxOverrides.stringOrNull((("" if ((len(args) == 0)) else (" " + HxOverrides.stringOrNull(" ".join([python_Boot.toString1(x1,'') for x1 in args]))))))) + "' failed with exit code ") + Std.string(code)))

    @staticmethod
    def register(c):
        dest = hxd_fs_Convert.converts.h.get(c.destExt,None)
        if (dest is None):
            dest = []
            hxd_fs_Convert.converts.h[c.destExt] = dest
        dest.insert(0, c)
        return 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.sourceExts = None
        _hx_o.destExt = None
        _hx_o.version = None
        _hx_o.params = None
        _hx_o.srcPath = None
        _hx_o.dstPath = None
        _hx_o.originalFilename = None
        _hx_o.srcBytes = None
hxd_fs_Convert._hx_class = hxd_fs_Convert
_hx_classes["hxd.fs.Convert"] = hxd_fs_Convert


class hxd_fs_ConvertFBX2HMD(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertFBX2HMD"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        super().__init__("fbx","hmd")

    def convert(self):
        fbx = None
        try:
            fbx = hxd_fmt_fbx_Parser.parse(self.srcBytes)
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            raise haxe_Exception.thrown(((Std.string(e) + " in ") + HxOverrides.stringOrNull(self.srcPath)))
        hmdout = hxd_fmt_fbx_HMDOut(self.srcPath)
        hmdout.load(fbx)
        isAnim = None
        if (not self.originalFilename.startswith("Anim_")):
            _this = self.originalFilename.lower()
            startIndex = None
            isAnim = (((_this.find("_anim_") if ((startIndex is None)) else HxString.indexOfImpl(_this,"_anim_",startIndex))) > 0)
        else:
            isAnim = True
        hmd = hmdout.toHMD(None,(not isAnim))
        out = haxe_io_BytesOutput()
        hxd_fmt_hmd_Writer(out).write(hmd)
        self.save(out.getBytes())

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_ConvertFBX2HMD._hx_class = hxd_fs_ConvertFBX2HMD
_hx_classes["hxd.fs.ConvertFBX2HMD"] = hxd_fs_ConvertFBX2HMD


class hxd_fs_Command(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.Command"
    _hx_is_interface = "False"
    __slots__ = ("cmd", "args")
    _hx_fields = ["cmd", "args"]
    _hx_methods = ["convert"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self,fr,to,cmd,args):
        self.args = None
        self.cmd = None
        super().__init__(fr,to)
        self.cmd = cmd
        self.args = args

    def convert(self):
        tmp = self.cmd
        _g = []
        _g1 = 0
        _g2 = self.args
        while (_g1 < len(_g2)):
            a = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            if (a == "%SRC"):
                x = self.srcPath
                _g.append(x)
            elif (a == "%DST"):
                x1 = self.dstPath
                _g.append(x1)
            else:
                _g.append(a)
        self.command(tmp,_g)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cmd = None
        _hx_o.args = None
hxd_fs_Command._hx_class = hxd_fs_Command
_hx_classes["hxd.fs.Command"] = hxd_fs_Command


class hxd_fs_ConvertWAV2MP3(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertWAV2MP3"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        super().__init__("wav","mp3")

    def convert(self):
        self.command("lame",["--resample", "44100", "--silent", "-h", self.srcPath, self.dstPath])

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_ConvertWAV2MP3._hx_class = hxd_fs_ConvertWAV2MP3
_hx_classes["hxd.fs.ConvertWAV2MP3"] = hxd_fs_ConvertWAV2MP3


class hxd_fs_ConvertWAV2OGG(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertWAV2OGG"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        super().__init__("wav","ogg")

    def convert(self):
        cmd = "oggenc"
        args = ["--resample", "44100", "-Q", self.srcPath, "-o", self.dstPath]
        if (Sys.systemName() == "Windows"):
            cmd = "oggenc2"
        if self.hasParam("mono"):
            f = sys_io_File.read(self.srcPath)
            wav = format_wav_Reader(f).read()
            f.close()
            if (wav.header.channels >= 2):
                args.append("--downmix")
        self.command(cmd,args)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_ConvertWAV2OGG._hx_class = hxd_fs_ConvertWAV2OGG
_hx_classes["hxd.fs.ConvertWAV2OGG"] = hxd_fs_ConvertWAV2OGG


class hxd_fs_ConvertTGA2PNG(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertTGA2PNG"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        super().__init__("tga","png")

    def convert(self):
        input = haxe_io_BytesInput(sys_io_File.getBytes(self.srcPath))
        r = format_tga_Reader(input).read()
        if ((r.header.imageType != format_tga_ImageType.UncompressedTrueColor) or ((r.header.bitsPerPixel != 32))):
            raise haxe_Exception.thrown(((("Not supported " + Std.string(r.header.imageType)) + "/") + Std.string(r.header.bitsPerPixel)))
        w = r.header.width
        h = r.header.height
        pix = hxd_Pixels.alloc(w,h,hxd_PixelFormat.ARGB)
        access = hxd__Pixels_PixelsARGB_Impl_.fromPixels(pix)
        p = 0
        _g = 0
        _g1 = h
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = w
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                c = r.imageData[(x + ((y * w)))]
                _this = access.bytes
                pos = ((((x + ((y * access.width))) << 2)) + access.offset)
                v = (((HxOverrides.rshift(c, 24) | (((c >> 8) & 65280))) | (((c << 8) & 16711680))) | ((c << 24)))
                _this.b[pos] = (v & 255)
                _this.b[(pos + 1)] = ((v >> 8) & 255)
                _this.b[(pos + 2)] = ((v >> 16) & 255)
                _this.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        tmp = r.header.imageOrigin.index
        if (tmp == 0):
            pix.flags = (pix.flags | ((1 << hxd_Flags.FlipY.index)))
        elif (tmp == 2):
            pass
        else:
            raise haxe_Exception.thrown(("Not supported " + Std.string(r.header.imageOrigin)))
        sys_io_File.saveBytes(self.dstPath,pix.toPNG())

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_ConvertTGA2PNG._hx_class = hxd_fs_ConvertTGA2PNG
_hx_classes["hxd.fs.ConvertTGA2PNG"] = hxd_fs_ConvertTGA2PNG


class hxd_fs_ConvertFNT2BFNT(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertFNT2BFNT"
    _hx_is_interface = "False"
    __slots__ = ("emptyTile",)
    _hx_fields = ["emptyTile"]
    _hx_methods = ["convert", "resolveTile"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        self.emptyTile = h2d_Tile(None,0,0,0,0,0,0)
        super().__init__("fnt","bfnt")
        self.version = 1

    def convert(self):
        font = hxd_fmt_bfnt_FontParser.parse(self.srcBytes,self.srcPath,self.resolveTile)
        out = haxe_io_BytesOutput()
        hxd_fmt_bfnt_Writer(out).write(font)
        self.save(out.getBytes())

    def resolveTile(self,path):
        if (not sys_FileSystem.exists(path)):
            raise haxe_Exception.thrown(("Could not resolve BitmapFont texture reference at path: " + ("null" if path is None else path)))
        return self.emptyTile

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.emptyTile = None
hxd_fs_ConvertFNT2BFNT._hx_class = hxd_fs_ConvertFNT2BFNT
_hx_classes["hxd.fs.ConvertFNT2BFNT"] = hxd_fs_ConvertFNT2BFNT


class hxd_fs_CompressIMG(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.CompressIMG"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["TEXCONV_FMT", "_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self,sourceExts,destExt):
        super().__init__(sourceExts,destExt)

    def convert(self):
        format = self.getParam("format")
        mips = (self.hasParam("mips") and ((self.getParam("mips") == True)))
        tcFmt = hxd_fs_CompressIMG.TEXCONV_FMT.h.get(format,None)
        if (tcFmt is not None):
            tmpPath = haxe_io_Path(self.dstPath)
            tmpPath.ext = ("tmp." + HxOverrides.stringOrNull(haxe_io_Path(self.srcPath).ext))
            tmpFile = tmpPath.toString()
            try:
                sys_FileSystem.deleteFile(tmpFile)
            except BaseException as _g:
                None
            try:
                sys_FileSystem.deleteFile(self.dstPath)
            except BaseException as _g:
                None
            sys_io_File.copy(self.srcPath,tmpFile)
            args = ["-f", tcFmt, "-y", "-nologo", tmpFile]
            if (not mips):
                args = (["-m", "1"] + args)
            self.command("texconv",args)
            sys_FileSystem.deleteFile(tmpFile)
            tmpPath.ext = "tmp.DDS"
            sys_FileSystem.rename(tmpPath.toString(),self.dstPath)
            return
        args = ["-silent"]
        if mips:
            args.append("-miplevels")
            args.append("20")
        if (self.hasParam("alpha") and ((format == "BC1"))):
            args = (args + ["-DXT1UseAlpha", "1", "-AlphaThreshold", ("" + Std.string(self.getParam("alpha")))])
        args = (args + ["-fd", ("" + Std.string(self.getParam("format"))), self.srcPath, self.dstPath])
        self.command("CompressonatorCLI",args)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_CompressIMG._hx_class = hxd_fs_CompressIMG
_hx_classes["hxd.fs.CompressIMG"] = hxd_fs_CompressIMG


class hxd_fs_DummyConvert(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.DummyConvert"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self,sourceExts,destExt):
        super().__init__(sourceExts,destExt)

    def convert(self):
        self.save(haxe_io_Bytes.alloc(0))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_DummyConvert._hx_class = hxd_fs_DummyConvert
_hx_classes["hxd.fs.DummyConvert"] = hxd_fs_DummyConvert

class hxd_fs_ConvertPattern(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fs.ConvertPattern"
    _hx_constructs = ["Filename", "Regexp", "Ext", "Exts", "Wildcard"]

    @staticmethod
    def Filename(name):
        return hxd_fs_ConvertPattern("Filename", 0, (name,))

    @staticmethod
    def Regexp(r):
        return hxd_fs_ConvertPattern("Regexp", 1, (r,))

    @staticmethod
    def Ext(e):
        return hxd_fs_ConvertPattern("Ext", 2, (e,))

    @staticmethod
    def Exts(e):
        return hxd_fs_ConvertPattern("Exts", 3, (e,))
hxd_fs_ConvertPattern.Wildcard = hxd_fs_ConvertPattern("Wildcard", 4, ())
hxd_fs_ConvertPattern._hx_class = hxd_fs_ConvertPattern
_hx_classes["hxd.fs.ConvertPattern"] = hxd_fs_ConvertPattern


class hxd_fs_FileConverter:
    _hx_class_name = "hxd.fs.FileConverter"
    _hx_is_interface = "False"
    _hx_fields = ["configuration", "baseDir", "tmpDir", "configs", "defaultConfig", "cache"]
    _hx_methods = ["onConvert", "makeConfig", "loadConvert", "makeCommmand", "mergeRec", "getFileTime", "loadConfig", "getConvertRule", "run", "runConvert", "convertAndCache"]
    _hx_statics = ["extraConfigs", "addConfig", "sortByRulePiority"]

    def __init__(self,baseDir,configuration):
        self.cache = None
        self.defaultConfig = None
        self.configs = haxe_ds_StringMap()
        self.baseDir = baseDir
        self.configuration = configuration
        self.tmpDir = ".tmp/"
        defaultCfg = _hx_AnonObject({'fs.convert': _hx_AnonObject({'fbx': _hx_AnonObject({'convert': "hmd", 'priority': -1}), 'fnt': _hx_AnonObject({'convert': "bfnt", 'priority': -1})})})
        _g = 0
        _g1 = hxd_fs_FileConverter.extraConfigs
        while (_g < len(_g1)):
            conf = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            defaultCfg = self.mergeRec(defaultCfg,conf)
        self.defaultConfig = self.makeConfig(defaultCfg)

    def onConvert(self,c):
        pass

    def makeConfig(self,obj):
        cfg = _hx_AnonObject({'obj': obj, 'rules': []})
        _hx_def = Reflect.field(obj,"fs.convert")
        conf = Reflect.field(obj,("fs.convert." + HxOverrides.stringOrNull(self.configuration)))
        merge = self.mergeRec(_hx_def,conf)
        _g = 0
        _g1 = python_Boot.fields(merge)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            cmd = self.makeCommmand(Reflect.field(merge,f))
            pt = None
            if (HxString.charCodeAt(f,0) == 94):
                pt = hxd_fs_ConvertPattern.Regexp(EReg(f,""))
            else:
                _this = EReg("^[a-zA-Z0-9,]+$","")
                _this.matchObj = python_lib_Re.search(_this.pattern,f)
                if (_this.matchObj is not None):
                    _this1 = f.lower()
                    el = _this1.split(",")
                    pt = (hxd_fs_ConvertPattern.Ext((el[0] if 0 < len(el) else None)) if ((len(el) == 1)) else hxd_fs_ConvertPattern.Exts(el))
                else:
                    pt = (hxd_fs_ConvertPattern.Wildcard if ((f == "*")) else hxd_fs_ConvertPattern.Filename(f))
            _this2 = cfg.rules
            x = _hx_AnonObject({'pt': pt, 'cmd': cmd.cmd, 'priority': cmd.priority})
            _this2.append(x)
        cfg.rules.sort(key= python_lib_Functools.cmp_to_key(hxd_fs_FileConverter.sortByRulePiority))
        return cfg

    def loadConvert(self,name):
        if (name == "none"):
            return None
        c = hxd_fs_Convert.converts.h.get(name,None)
        if (c is None):
            raise haxe_Exception.thrown((("No convert has been registered with name/extension '" + ("null" if name is None else name)) + "'"))
        return c

    def makeCommmand(self,obj):
        if Std.isOfType(obj,str):
            return _hx_AnonObject({'cmd': _hx_AnonObject({'conv': self.loadConvert(obj)}), 'priority': 0})
        if (Reflect.field(obj,"convert") is None):
            raise haxe_Exception.thrown(("Missing 'convert' in " + Std.string(obj)))
        cmd = _hx_AnonObject({'conv': self.loadConvert(Reflect.field(obj,"convert"))})
        priority = 0
        _g = 0
        _g1 = python_Boot.fields(obj)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            value = Reflect.field(obj,f)
            f1 = f
            _hx_local_1 = len(f1)
            if (_hx_local_1 == 4):
                if (f1 == "then"):
                    Reflect.setField(cmd,"then",self.makeCommmand(value).cmd)
                else:
                    if (Reflect.field(cmd,"params") is None):
                        Reflect.setField(cmd,"params",_hx_AnonObject({}))
                    if (Reflect.isObject(value) and (not Std.isOfType(value,str))):
                        raise haxe_Exception.thrown(((("Invalid parameter value " + ("null" if f is None else f)) + "=") + Std.string(value)))
                    setattr(Reflect.field(cmd,"params"),(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
            elif (_hx_local_1 == 7):
                if (f1 == "convert"):
                    pass
                else:
                    if (Reflect.field(cmd,"params") is None):
                        Reflect.setField(cmd,"params",_hx_AnonObject({}))
                    if (Reflect.isObject(value) and (not Std.isOfType(value,str))):
                        raise haxe_Exception.thrown(((("Invalid parameter value " + ("null" if f is None else f)) + "=") + Std.string(value)))
                    setattr(Reflect.field(cmd,"params"),(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
            elif (_hx_local_1 == 8):
                if (f1 == "priority"):
                    priority = value
                else:
                    if (Reflect.field(cmd,"params") is None):
                        Reflect.setField(cmd,"params",_hx_AnonObject({}))
                    if (Reflect.isObject(value) and (not Std.isOfType(value,str))):
                        raise haxe_Exception.thrown(((("Invalid parameter value " + ("null" if f is None else f)) + "=") + Std.string(value)))
                    setattr(Reflect.field(cmd,"params"),(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
            else:
                if (Reflect.field(cmd,"params") is None):
                    Reflect.setField(cmd,"params",_hx_AnonObject({}))
                if (Reflect.isObject(value) and (not Std.isOfType(value,str))):
                    raise haxe_Exception.thrown(((("Invalid parameter value " + ("null" if f is None else f)) + "=") + Std.string(value)))
                setattr(Reflect.field(cmd,"params"),(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
        if (Reflect.field(cmd,"params") is not None):
            fl = python_Boot.fields(Reflect.field(cmd,"params"))
            fl.sort(key= python_lib_Functools.cmp_to_key(Reflect.compare))
            _g = []
            _g1 = 0
            while (_g1 < len(fl)):
                f = (fl[_g1] if _g1 >= 0 and _g1 < len(fl) else None)
                _g1 = (_g1 + 1)
                x = ((("null" if f is None else f) + "_") + Std.string(Reflect.field(Reflect.field(cmd,"params"),f)))
                _g.append(x)
            Reflect.setField(cmd,"paramsStr","_".join([python_Boot.toString1(x1,'') for x1 in _g]))
        return _hx_AnonObject({'cmd': cmd, 'priority': priority})

    def mergeRec(self,a,b):
        if (b is None):
            return a
        if (a is None):
            return b
        cp = _hx_AnonObject({})
        _g = 0
        _g1 = python_Boot.fields(a)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            va = Reflect.field(a,f)
            if python_Boot.hasField(b,f):
                vb = Reflect.field(b,f)
                if ((Type.typeof(vb) == ValueType.TObject) and ((Type.typeof(va) == ValueType.TObject))):
                    vb = self.mergeRec(va,vb)
                setattr(cp,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),vb)
                continue
            setattr(cp,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),va)
        _g = 0
        _g1 = python_Boot.fields(b)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (not python_Boot.hasField(cp,f)):
                value = Reflect.field(b,f)
                setattr(cp,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
        return cp

    def getFileTime(self,filePath):
        return (sys_FileSystem.stat(filePath).mtime.date.timestamp() * 1000)

    def loadConfig(self,dir):
        c = self.configs.h.get(dir,None)
        if (c is not None):
            return c
        startIndex = None
        dirPos = None
        if (startIndex is None):
            dirPos = dir.rfind("/", 0, len(dir))
        else:
            i = dir.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = dir.find("/", startLeft, len(dir))
            dirPos = (check if (((check > i) and ((check <= startIndex)))) else i)
        parent = (self.defaultConfig if ((dir == "")) else self.loadConfig(("" if ((dirPos < 0)) else HxString.substr(dir,0,dirPos))))
        propsFile = (HxOverrides.stringOrNull(((self.baseDir if ((dir == "")) else ((HxOverrides.stringOrNull(self.baseDir) + ("null" if dir is None else dir)) + "/")))) + "props.json")
        if (not sys_FileSystem.exists(propsFile)):
            c = parent
        else:
            content = sys_io_File.getContent(propsFile)
            obj = None
            try:
                obj = python_lib_Json.loads(content,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
            except BaseException as _g:
                None
                e = haxe_Exception.caught(_g).unwrap()
                raise haxe_Exception.thrown((((("Failed to parse " + ("null" if propsFile is None else propsFile)) + "(") + Std.string(e)) + ")"))
            fullObj = self.mergeRec(parent.obj,obj)
            c = self.makeConfig(fullObj)
        self.configs.h[dir] = c
        return c

    def getConvertRule(self,path):
        startIndex = None
        dirPos = None
        if (startIndex is None):
            dirPos = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            dirPos = (check if (((check > i) and ((check <= startIndex)))) else i)
        cfg = self.loadConfig(("" if ((dirPos < 0)) else HxString.substr(path,0,dirPos)))
        name = (path if ((dirPos < 0)) else HxString.substr(path,(dirPos + 1),None))
        _this = name.split(".")
        ext = (None if ((len(_this) == 0)) else _this.pop()).lower()
        _g = 0
        _g1 = cfg.rules
        while (_g < len(_g1)):
            r = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = r.pt
            tmp = _g2.index
            if (tmp == 0):
                f = _g2.params[0]
                if ((name == f) or ((path == f))):
                    return r
            elif (tmp == 1):
                reg = _g2.params[0]
                tmp1 = None
                reg.matchObj = python_lib_Re.search(reg.pattern,name)
                if (reg.matchObj is None):
                    reg.matchObj = python_lib_Re.search(reg.pattern,path)
                    tmp1 = (reg.matchObj is not None)
                else:
                    tmp1 = True
                if tmp1:
                    return r
            elif (tmp == 2):
                e = _g2.params[0]
                if (ext == e):
                    return r
            elif (tmp == 3):
                el = _g2.params[0]
                if (python_internal_ArrayImpl.indexOf(el,ext,None) >= 0):
                    return r
            elif (tmp == 4):
                return r
            else:
                pass
        return None

    def run(self,e):
        rule = self.getConvertRule(e.get_path())
        if (e.originalFile is None):
            e.originalFile = e.file
        else:
            e.file = e.originalFile
        if ((rule is None) or ((rule.cmd.conv is None))):
            return
        e.file = HxString.substr(e.file,len(self.baseDir),None)
        _g = rule.pt
        tmp = None
        if (_g.index == 2):
            _g1 = _g.params[0]
            tmp = True
        else:
            tmp = False
        self.runConvert(e,rule.cmd,tmp)

    def runConvert(self,e,cmd,replaceExt = None):
        if (replaceExt is None):
            replaceExt = False
        outFile = self.tmpDir
        ext = e.get_extension()
        if ((replaceExt and ((Reflect.field(cmd,"paramsStr") is None))) and ((Reflect.field(cmd,"then") is None))):
            outFile = (("null" if outFile is None else outFile) + HxOverrides.stringOrNull(HxString.substr(e.get_path(),0,-((len(ext) + 1)))))
        else:
            outFile = (("null" if outFile is None else outFile) + HxOverrides.stringOrNull(e.get_path()))
        if (Reflect.field(cmd,"paramsStr") is not None):
            outFile = (("null" if outFile is None else outFile) + HxOverrides.stringOrNull((("." + HxOverrides.stringOrNull(Reflect.field(cmd,"paramsStr"))))))
        conv = None
        _g = 0
        _g1 = cmd.conv
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((c.sourceExts is None) or ((python_internal_ArrayImpl.indexOf(c.sourceExts,ext,None) >= 0))):
                conv = c
                break
        if (conv is None):
            raise haxe_Exception.thrown(((("No converter is registered that can convert " + HxOverrides.stringOrNull(e.get_path())) + " to ") + HxOverrides.stringOrNull((cmd.conv[0] if 0 < len(cmd.conv) else None).destExt)))
        if (conv.destExt == "dummy"):
            e.file = ((HxOverrides.stringOrNull(self.baseDir) + HxOverrides.stringOrNull(self.tmpDir)) + ".dummy")
            if (not sys_FileSystem.exists(e.file)):
                sys_io_File.saveContent(e.file,"")
            return
        if (conv.destExt == "remove"):
            e.file = None
            return
        outFile = (("null" if outFile is None else outFile) + HxOverrides.stringOrNull((("." + HxOverrides.stringOrNull(conv.destExt)))))
        self.convertAndCache(e,outFile,conv,Reflect.field(cmd,"params"))
        if (Reflect.field(cmd,"then") is not None):
            e.file = outFile
            self.runConvert(e,Reflect.field(cmd,"then"))
        e.file = (HxOverrides.stringOrNull(self.baseDir) + ("null" if outFile is None else outFile))

    def convertAndCache(self,e,outFile,conv,params):
        _gthis = self
        if (self.cache is None):
            tmp = None
            try:
                tmp = haxe_Unserializer.run(sys_io_File.getContent(((HxOverrides.stringOrNull(self.baseDir) + HxOverrides.stringOrNull(self.tmpDir)) + "cache.dat")))
            except BaseException as _g:
                None
                tmp = haxe_ds_StringMap()
            self.cache = tmp
        entry = self.cache.h.get(e.file,None)
        needInsert = False
        if (entry is None):
            entry = []
            needInsert = True
        def _hx_local_0():
            if needInsert:
                _gthis.cache.h[e.file] = entry
            sys_FileSystem.createDirectory((HxOverrides.stringOrNull(_gthis.baseDir) + HxOverrides.stringOrNull(_gthis.tmpDir)))
            sys_io_File.saveContent(((HxOverrides.stringOrNull(_gthis.baseDir) + HxOverrides.stringOrNull(_gthis.tmpDir)) + "cache.dat"),haxe_Serializer.run(_gthis.cache))
        saveCache = _hx_local_0
        match = None
        _g = 0
        while (_g < len(entry)):
            e1 = (entry[_g] if _g >= 0 and _g < len(entry) else None)
            _g = (_g + 1)
            if (e1.out == outFile):
                match = e1
                if (match.ver is None):
                    match.ver = 0
                break
        if (match is None):
            match = _hx_AnonObject({'out': outFile, 'time': 0, 'hash': "", 'ver': conv.version})
            entry.append(match)
        fullPath = (HxOverrides.stringOrNull(self.baseDir) + HxOverrides.stringOrNull(e.file))
        fullOutPath = (HxOverrides.stringOrNull(self.baseDir) + ("null" if outFile is None else outFile))
        if (not sys_FileSystem.exists(fullPath)):
            raise haxe_Exception.thrown(("Missing " + ("null" if fullPath is None else fullPath)))
        time = Math.floor((self.getFileTime(fullPath) / 1000))
        alreadyGen = (sys_FileSystem.exists(fullOutPath) and ((match.ver == conv.version)))
        if (alreadyGen and ((match.time == time))):
            return
        content = hxd_File.getBytes(fullPath)
        hash = haxe_crypto_Sha1.make(content).toHex()
        if (alreadyGen and ((match.hash == hash))):
            match.time = time
            saveCache()
            return
        startIndex = None
        _hx_len = None
        if (startIndex is None):
            _hx_len = fullOutPath.rfind("/", 0, len(fullOutPath))
        else:
            i = fullOutPath.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = fullOutPath.find("/", startLeft, len(fullOutPath))
            _hx_len = (check if (((check > i) and ((check <= startIndex)))) else i)
        sys_FileSystem.createDirectory(HxString.substr(fullOutPath,0,_hx_len))
        conv.srcPath = fullPath
        conv.dstPath = fullOutPath
        conv.srcBytes = content
        conv.originalFilename = e.name
        conv.params = params
        self.onConvert(conv)
        conv.convert()
        conv.srcPath = None
        conv.dstPath = None
        conv.srcBytes = None
        conv.originalFilename = None
        hxd_System.timeoutTick()
        if (not sys_FileSystem.exists(fullOutPath)):
            raise haxe_Exception.thrown((("Converted output file " + ("null" if fullOutPath is None else fullOutPath)) + " was not created"))
        match.ver = conv.version
        match.time = time
        match.hash = hash
        saveCache()

    @staticmethod
    def addConfig(conf):
        _this = hxd_fs_FileConverter.extraConfigs
        _this.append(conf)
        return conf

    @staticmethod
    def sortByRulePiority(r1,r2):
        if (r1.priority != r2.priority):
            return (r2.priority - r1.priority)
        return (r1.pt.index - r2.pt.index)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.configuration = None
        _hx_o.baseDir = None
        _hx_o.tmpDir = None
        _hx_o.configs = None
        _hx_o.defaultConfig = None
        _hx_o.cache = None
hxd_fs_FileConverter._hx_class = hxd_fs_FileConverter
_hx_classes["hxd.fs.FileConverter"] = hxd_fs_FileConverter


class hxd_fs_FileInput(haxe_io_Input):
    _hx_class_name = "hxd.fs.FileInput"
    _hx_is_interface = "False"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["skip", "readByte", "readBytes", "close"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,f):
        self.f = f
        f.open()

    def skip(self,nbytes):
        self.f.skip(nbytes)

    def readByte(self):
        return self.f.readByte()

    def readBytes(self,b,pos,_hx_len):
        self.f.read(b,pos,_hx_len)
        return _hx_len

    def close(self):
        self.f.close()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
hxd_fs_FileInput._hx_class = hxd_fs_FileInput
_hx_classes["hxd.fs.FileInput"] = hxd_fs_FileInput


class hxd_fs__LoadedBitmap_LoadedBitmap_Impl_:
    _hx_class_name = "hxd.fs._LoadedBitmap.LoadedBitmap_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toBitmap", "toNative"]

    @staticmethod
    def _new(data):
        this1 = data
        return this1

    @staticmethod
    def toBitmap(this1):
        return this1

    @staticmethod
    def toNative(this1):
        return this1
hxd_fs__LoadedBitmap_LoadedBitmap_Impl_._hx_class = hxd_fs__LoadedBitmap_LoadedBitmap_Impl_
_hx_classes["hxd.fs._LoadedBitmap.LoadedBitmap_Impl_"] = hxd_fs__LoadedBitmap_LoadedBitmap_Impl_


class hxd_fs_LocalEntry(hxd_fs_FileEntry):
    _hx_class_name = "hxd.fs.LocalEntry"
    _hx_is_interface = "False"
    __slots__ = ("fs", "relPath", "file", "originalFile", "fread", "isDirCached", "watchCallback", "watchTime")
    _hx_fields = ["fs", "relPath", "file", "originalFile", "fread", "isDirCached", "watchCallback", "watchTime"]
    _hx_methods = ["getSign", "getBytes", "open", "skip", "readByte", "read", "close", "get_isDirectory", "load", "loadBitmap", "get_path", "exists", "get", "get_size", "iterator", "getModifTime", "watch"]
    _hx_statics = ["WATCH_INDEX", "WATCH_LIST", "tmpDir", "checkFiles", "checkNext"]
    _hx_interfaces = []
    _hx_super = hxd_fs_FileEntry


    def __init__(self,fs,name,relPath,file):
        self.watchTime = None
        self.watchCallback = None
        self.isDirCached = None
        self.fread = None
        self.originalFile = None
        self.fs = fs
        self.name = name
        self.relPath = relPath
        self.file = file

    def getSign(self):
        old = (-1 if ((self.fread is None)) else self.fread.tell())
        self.open()
        i = self.fread.readInt32()
        if (old < 0):
            self.close()
        else:
            self.fread.seek(old,sys_io_FileSeek.SeekBegin)
        return i

    def getBytes(self):
        return sys_io_File.getBytes(self.file)

    def open(self):
        if (self.fread is not None):
            self.fread.seek(0,sys_io_FileSeek.SeekBegin)
        else:
            self.fread = sys_io_File.read(self.file)

    def skip(self,nbytes):
        self.fread.seek(nbytes,sys_io_FileSeek.SeekCur)

    def readByte(self):
        return self.fread.readByte()

    def read(self,out,pos,size):
        self.fread.readFullBytes(out,pos,size)

    def close(self):
        if (self.fread is not None):
            self.fread.close()
            self.fread = None

    def get_isDirectory(self):
        if (self.isDirCached is not None):
            return self.isDirCached
        def _hx_local_1():
            def _hx_local_0():
                self.isDirCached = sys_FileSystem.isDirectory(self.file)
                return self.isDirCached
            return _hx_local_0()
        return _hx_local_1()

    def load(self,onReady = None):
        if (onReady is not None):
            haxe_Timer.delay(onReady,1)

    def loadBitmap(self,onLoaded):
        bmp = hxd_res_Image(self).toBitmap()
        this1 = bmp
        onLoaded(this1)

    def get_path(self):
        if (self.relPath is None):
            return "<root>"
        else:
            return self.relPath

    def exists(self,name):
        return self.fs.exists((name if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if name is None else name))))

    def get(self,name):
        return self.fs.get((name if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if name is None else name))))

    def get_size(self):
        return sys_FileSystem.stat(self.file).size

    def iterator(self):
        arr = list()
        _g = 0
        _g1 = sys_FileSystem.readDirectory(self.file)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f1 = f
            if ((f1 == ".svn") or ((f1 == ".git"))):
                if sys_FileSystem.isDirectory(((HxOverrides.stringOrNull(self.file) + "/") + ("null" if f is None else f))):
                    continue
                else:
                    x = self.fs.open((f if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if f is None else f))),False)
                    arr.append(x)
            elif (f1 == ".tmp"):
                if (self == self.fs.root):
                    continue
                else:
                    x1 = self.fs.open((f if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if f is None else f))),False)
                    arr.append(x1)
            else:
                x2 = self.fs.open((f if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if f is None else f))),False)
                arr.append(x2)
        return hxd_impl_ArrayIterator_hxd_fs_FileEntry(arr)

    def getModifTime(self):
        return (sys_FileSystem.stat((self.originalFile if ((self.originalFile is not None)) else self.file)).mtime.date.timestamp() * 1000)

    def watch(self,onChanged):
        _gthis = self
        if (onChanged is None):
            if (self.watchCallback is not None):
                python_internal_ArrayImpl.remove(hxd_fs_LocalEntry.WATCH_LIST,self)
                self.watchCallback = None
            return
        if (self.watchCallback is None):
            if (hxd_fs_LocalEntry.WATCH_LIST is None):
                hxd_fs_LocalEntry.WATCH_LIST = []
                haxe_MainLoop.add(hxd_fs_LocalEntry.checkFiles)
            path = self.get_path()
            _g = 0
            _g1 = hxd_fs_LocalEntry.WATCH_LIST
            while (_g < len(_g1)):
                w = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (w.get_path() == path):
                    w.watchCallback = None
                    python_internal_ArrayImpl.remove(hxd_fs_LocalEntry.WATCH_LIST,w)
            _this = hxd_fs_LocalEntry.WATCH_LIST
            _this.append(self)
        self.watchTime = (sys_FileSystem.stat((self.originalFile if ((self.originalFile is not None)) else self.file)).mtime.date.timestamp() * 1000)
        def _hx_local_1():
            _gthis.fs.convert.run(_gthis)
            onChanged()
        self.watchCallback = _hx_local_1

    @staticmethod
    def checkFiles():
        filesToCheck = Math.ceil((len(hxd_fs_LocalEntry.WATCH_LIST) / 60))
        if (filesToCheck > hxd_fs_LocalFileSystem.FILES_CHECK_MAX):
            filesToCheck = hxd_fs_LocalFileSystem.FILES_CHECK_MAX
        _g = 0
        _g1 = filesToCheck
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            hxd_fs_LocalEntry.checkNext()

    @staticmethod
    def checkNext():
        def _hx_local_2():
            _hx_local_0 = hxd_fs_LocalEntry
            _hx_local_1 = _hx_local_0.WATCH_INDEX
            _hx_local_0.WATCH_INDEX = (_hx_local_1 + 1)
            return _hx_local_1
        w = python_internal_ArrayImpl._get(hxd_fs_LocalEntry.WATCH_LIST, _hx_local_2())
        if (w is None):
            hxd_fs_LocalEntry.WATCH_INDEX = 0
            return
        t = None
        try:
            t = (sys_FileSystem.stat((w.originalFile if ((w.originalFile is not None)) else w.file)).mtime.date.timestamp() * 1000)
        except BaseException as _g:
            None
            return
        if (t == w.watchTime):
            return
        if (hxd_fs_LocalEntry.tmpDir is None):
            hxd_fs_LocalEntry.tmpDir = Sys.getEnv("TEMP")
            if (hxd_fs_LocalEntry.tmpDir is None):
                hxd_fs_LocalEntry.tmpDir = Sys.getEnv("TMPDIR")
            if (hxd_fs_LocalEntry.tmpDir is None):
                hxd_fs_LocalEntry.tmpDir = Sys.getEnv("TMP")
        lockFile = (HxOverrides.stringOrNull(hxd_fs_LocalEntry.tmpDir) + "/")
        _this = w.file
        _this1 = _this.split("/")
        lockFile1 = ((("null" if lockFile is None else lockFile) + HxOverrides.stringOrNull(((None if ((len(_this1) == 0)) else _this1.pop())))) + ".lock")
        if sys_FileSystem.exists(lockFile1):
            return
        if (not w.get_isDirectory()):
            try:
                pass
            except BaseException as _g:
                None
                return
        w.watchTime = t
        w.watchCallback()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fs = None
        _hx_o.relPath = None
        _hx_o.file = None
        _hx_o.originalFile = None
        _hx_o.fread = None
        _hx_o.isDirCached = None
        _hx_o.watchCallback = None
        _hx_o.watchTime = None
hxd_fs_LocalEntry._hx_class = hxd_fs_LocalEntry
_hx_classes["hxd.fs.LocalEntry"] = hxd_fs_LocalEntry


class hxd_fs_LocalFileSystem:
    _hx_class_name = "hxd.fs.LocalFileSystem"
    _hx_is_interface = "False"
    __slots__ = ("root", "fileCache", "baseDir", "convert", "directoryCache")
    _hx_fields = ["root", "fileCache", "baseDir", "convert", "directoryCache"]
    _hx_methods = ["getAbsolutePath", "getRoot", "checkPath", "open", "clearCache", "exists", "get", "dispose", "dir"]
    _hx_statics = ["isWindows", "FILES_CHECK_MAX"]
    _hx_interfaces = [hxd_fs_FileSystem]

    def __init__(self,dir,configuration):
        self.convert = None
        self.root = None
        self.directoryCache = haxe_ds_StringMap()
        self.fileCache = haxe_ds_StringMap()
        self.baseDir = dir
        if (configuration is None):
            configuration = "default"
        pr = Sys.programPath()
        exePath = None
        if (pr is None):
            exePath = None
        else:
            _this = pr.split("\\")
            _this1 = "/".join([python_Boot.toString1(x1,'') for x1 in _this])
            exePath = _this1.split("/")
        if (exePath is not None):
            if (len(exePath) != 0):
                exePath.pop()
        froot = (self.baseDir if ((exePath is None)) else sys_FileSystem.fullPath(((HxOverrides.stringOrNull("/".join([python_Boot.toString1(x1,'') for x1 in exePath])) + "/") + HxOverrides.stringOrNull(self.baseDir))))
        if (((froot is None) or (not sys_FileSystem.exists(froot))) or (not sys_FileSystem.isDirectory(froot))):
            froot = sys_FileSystem.fullPath(self.baseDir)
            if (((froot is None) or (not sys_FileSystem.exists(froot))) or (not sys_FileSystem.isDirectory(froot))):
                raise haxe_Exception.thrown(("Could not find dir " + ("null" if dir is None else dir)))
        _this = froot.split("\\")
        self.baseDir = "/".join([python_Boot.toString1(x1,'') for x1 in _this])
        if (not self.baseDir.endswith("/")):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.baseDir
            _hx_local_0.baseDir = (("null" if _hx_local_1 is None else _hx_local_1) + "/")
            _hx_local_0.baseDir
        self.convert = hxd_fs_FileConverter(self.baseDir,configuration)
        self.root = hxd_fs_LocalEntry(self,"root",None,self.baseDir)

    def getAbsolutePath(self,f):
        def _hx_local_1():
            _hx_local_0 = f
            if (Std.isOfType(_hx_local_0,hxd_fs_LocalEntry) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise "Class cast error"
            return _hx_local_0
        f1 = _hx_local_1()
        return f1.file

    def getRoot(self):
        return self.root

    def checkPath(self,path):
        baseDir = haxe_io_Path(path).dir
        c = self.directoryCache.h.get(baseDir,None)
        isNew = False
        if (c is None):
            isNew = True
            c = haxe_ds_StringMap()
            _g = 0
            _g1 = None
            try:
                _g1 = sys_FileSystem.readDirectory(baseDir)
            except BaseException as _g2:
                None
                _g1 = []
            while (_g < len(_g1)):
                f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.h[f] = True
            self.directoryCache.h[baseDir] = c
        if (not (HxString.substr(path,(len(baseDir) + 1),None) in c.h)):
            if (not isNew):
                self.directoryCache.remove(baseDir)
                return self.checkPath(path)
            return False
        return True

    def open(self,path,check = None):
        if (check is None):
            check = True
        r = self.fileCache.h.get(path,None)
        if (r is not None):
            return r.r
        e = None
        f = sys_FileSystem.fullPath((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path)))
        if (f is None):
            return None
        _this = f.split("\\")
        f = "/".join([python_Boot.toString1(x1,'') for x1 in _this])
        if ((not check) or ((((((not hxd_fs_LocalFileSystem.isWindows) or ((hxd_fs_LocalFileSystem.isWindows and ((f == ((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path))))))))) and sys_FileSystem.exists(f)) and self.checkPath(f)))):
            _this = path.split("/")
            e = hxd_fs_LocalEntry(self,(None if ((len(_this) == 0)) else _this.pop()),path,f)
            self.convert.run(e)
            if (e.file is None):
                e = None
        self.fileCache.h[path] = _hx_AnonObject({'r': e})
        return e

    def clearCache(self):
        path = self.fileCache.keys()
        while path.hasNext():
            path1 = path.next()
            r = self.fileCache.h.get(path1,None)
            if (r.r is None):
                self.fileCache.remove(path1)

    def exists(self,path):
        f = self.open(path)
        return (f is not None)

    def get(self,path):
        f = self.open(path)
        if (f is None):
            raise haxe_Exception.thrown(hxd_fs_NotFound(path))
        return f

    def dispose(self):
        self.fileCache = haxe_ds_StringMap()

    def dir(self,path):
        if ((not sys_FileSystem.exists((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path)))) or (not sys_FileSystem.isDirectory((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path))))):
            raise haxe_Exception.thrown(hxd_fs_NotFound((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path))))
        files = sys_FileSystem.readDirectory((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path)))
        r = []
        _g = 0
        while (_g < len(files)):
            f = (files[_g] if _g >= 0 and _g < len(files) else None)
            _g = (_g + 1)
            x = self.open(((("null" if path is None else path) + "/") + ("null" if f is None else f)),False)
            r.append(x)
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
        _hx_o.fileCache = None
        _hx_o.baseDir = None
        _hx_o.convert = None
        _hx_o.directoryCache = None
hxd_fs_LocalFileSystem._hx_class = hxd_fs_LocalFileSystem
_hx_classes["hxd.fs.LocalFileSystem"] = hxd_fs_LocalFileSystem


class hxd_fs_NotFound:
    _hx_class_name = "hxd.fs.NotFound"
    _hx_is_interface = "False"
    __slots__ = ("path",)
    _hx_fields = ["path"]
    _hx_methods = ["toString"]

    def __init__(self,path):
        self.path = path

    def toString(self):
        return (("Resource file not found '" + HxOverrides.stringOrNull(self.path)) + "'")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.path = None
hxd_fs_NotFound._hx_class = hxd_fs_NotFound
_hx_classes["hxd.fs.NotFound"] = hxd_fs_NotFound


class hxd_impl__Allocator_BufferFlags_Impl_:
    _hx_class_name = "hxd.impl._Allocator.BufferFlags_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["Dynamic", "UniformDynamic", "RawFormat", "RawQuads", "toInt"]

    @staticmethod
    def toInt(this1):
        return this1
hxd_impl__Allocator_BufferFlags_Impl_._hx_class = hxd_impl__Allocator_BufferFlags_Impl_
_hx_classes["hxd.impl._Allocator.BufferFlags_Impl_"] = hxd_impl__Allocator_BufferFlags_Impl_


class hxd_impl_Allocator:
    _hx_class_name = "hxd.impl.Allocator"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["allocBuffer", "ofFloats", "disposeBuffer", "allocIndexBuffer", "ofIndexes", "disposeIndexBuffer", "onContextLost", "allocFloats", "disposeFloats", "allocIndexes", "disposeIndexes"]
    _hx_statics = ["inst", "set", "get"]

    def __init__(self):
        pass

    def allocBuffer(self,vertices,stride,flags):
        tmp = None
        flags1 = flags
        if (flags1 == 0):
            tmp = [h3d_BufferFlag.Dynamic]
        elif (flags1 == 1):
            tmp = [h3d_BufferFlag.UniformBuffer, h3d_BufferFlag.Dynamic]
        elif (flags1 == 2):
            tmp = [h3d_BufferFlag.RawFormat]
        elif (flags1 == 3):
            tmp = [h3d_BufferFlag.Quads, h3d_BufferFlag.RawFormat]
        else:
            pass
        return h3d_Buffer(vertices,stride,tmp)

    def ofFloats(self,v,stride,flags):
        x = (len(v) / stride)
        nvert = None
        try:
            nvert = int(x)
        except BaseException as _g:
            None
            nvert = None
        b = self.allocBuffer(nvert,stride,flags)
        b.uploadVector(v,0,nvert)
        return b

    def disposeBuffer(self,b):
        b.dispose()

    def allocIndexBuffer(self,count):
        return h3d_Indexes(count)

    def ofIndexes(self,ib,length = None):
        if (length is None):
            length = -1
        if ((length < 0) and ((ib is not None))):
            length = len(ib)
        idx = self.allocIndexBuffer(length)
        idx.upload(ib,0,length)
        return idx

    def disposeIndexBuffer(self,i):
        i.dispose()

    def onContextLost(self):
        pass

    def allocFloats(self,count):
        length = count
        if (length is None):
            length = 0
        this1 = list()
        if (length > 0):
            if (length > len(this1)):
                python_internal_ArrayImpl._set(this1, (length - 1), 0.)
        return this1

    def disposeFloats(self,f):
        pass

    def allocIndexes(self,count):
        length = count
        if (length is None):
            length = 0
        this1 = list()
        if (length > 0):
            if (length > len(this1)):
                python_internal_ArrayImpl._set(this1, (length - 1), 0)
        return this1

    def disposeIndexes(self,i):
        pass
    inst = None

    @staticmethod
    def set(a):
        hxd_impl_Allocator.inst = a

    @staticmethod
    def get():
        if (hxd_impl_Allocator.inst is None):
            hxd_impl_Allocator.inst = hxd_impl_Allocator()
        return hxd_impl_Allocator.inst

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_impl_Allocator._hx_class = hxd_impl_Allocator
_hx_classes["hxd.impl.Allocator"] = hxd_impl_Allocator


class hxd_impl_Api:
    _hx_class_name = "hxd.impl.Api"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["downcast", "isOfType"]

    @staticmethod
    def downcast(value,c):
        return Std.downcast(value,c)

    @staticmethod
    def isOfType(v,t):
        return Std.isOfType(v,t)
hxd_impl_Api._hx_class = hxd_impl_Api
_hx_classes["hxd.impl.Api"] = hxd_impl_Api


class hxd_impl_ArrayIterator:
    _hx_class_name = "hxd.impl.ArrayIterator"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator._hx_class = hxd_impl_ArrayIterator
_hx_classes["hxd.impl.ArrayIterator"] = hxd_impl_ArrayIterator


class hxd_impl_ArrayIterator_h2d_Object:
    _hx_class_name = "hxd.impl.ArrayIterator_h2d_Object"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h2d_Object._hx_class = hxd_impl_ArrayIterator_h2d_Object
_hx_classes["hxd.impl.ArrayIterator_h2d_Object"] = hxd_impl_ArrayIterator_h2d_Object


class hxd_impl_ArrayIterator_h2d_col_IPoint:
    _hx_class_name = "hxd.impl.ArrayIterator_h2d_col_IPoint"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h2d_col_IPoint._hx_class = hxd_impl_ArrayIterator_h2d_col_IPoint
_hx_classes["hxd.impl.ArrayIterator_h2d_col_IPoint"] = hxd_impl_ArrayIterator_h2d_col_IPoint


class hxd_impl_ArrayIterator_h2d_col_IPolygon:
    _hx_class_name = "hxd.impl.ArrayIterator_h2d_col_IPolygon"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h2d_col_IPolygon._hx_class = hxd_impl_ArrayIterator_h2d_col_IPolygon
_hx_classes["hxd.impl.ArrayIterator_h2d_col_IPolygon"] = hxd_impl_ArrayIterator_h2d_col_IPolygon


class hxd_impl_ArrayIterator_h2d_col_Point:
    _hx_class_name = "hxd.impl.ArrayIterator_h2d_col_Point"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h2d_col_Point._hx_class = hxd_impl_ArrayIterator_h2d_col_Point
_hx_classes["hxd.impl.ArrayIterator_h2d_col_Point"] = hxd_impl_ArrayIterator_h2d_col_Point


class hxd_impl_ArrayIterator_h2d_col_Polygon:
    _hx_class_name = "hxd.impl.ArrayIterator_h2d_col_Polygon"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h2d_col_Polygon._hx_class = hxd_impl_ArrayIterator_h2d_col_Polygon
_hx_classes["hxd.impl.ArrayIterator_h2d_col_Polygon"] = hxd_impl_ArrayIterator_h2d_col_Polygon


class hxd_impl_ArrayIterator_h2d_col_Segment:
    _hx_class_name = "hxd.impl.ArrayIterator_h2d_col_Segment"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h2d_col_Segment._hx_class = hxd_impl_ArrayIterator_h2d_col_Segment
_hx_classes["hxd.impl.ArrayIterator_h2d_col_Segment"] = hxd_impl_ArrayIterator_h2d_col_Segment


class hxd_impl_ArrayIterator_h3d_scene_Object:
    _hx_class_name = "hxd.impl.ArrayIterator_h3d_scene_Object"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h3d_scene_Object._hx_class = hxd_impl_ArrayIterator_h3d_scene_Object
_hx_classes["hxd.impl.ArrayIterator_h3d_scene_Object"] = hxd_impl_ArrayIterator_h3d_scene_Object


class hxd_impl_ArrayIterator_hxd_fs_FileEntry:
    _hx_class_name = "hxd.impl.ArrayIterator_hxd_fs_FileEntry"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_hxd_fs_FileEntry._hx_class = hxd_impl_ArrayIterator_hxd_fs_FileEntry
_hx_classes["hxd.impl.ArrayIterator_hxd_fs_FileEntry"] = hxd_impl_ArrayIterator_hxd_fs_FileEntry


class hxd_impl_ArrayIterator_hxd_res_Any:
    _hx_class_name = "hxd.impl.ArrayIterator_hxd_res_Any"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_hxd_res_Any._hx_class = hxd_impl_ArrayIterator_hxd_res_Any
_hx_classes["hxd.impl.ArrayIterator_hxd_res_Any"] = hxd_impl_ArrayIterator_hxd_res_Any


class hxd_impl_ArrayIterator_hxd_snd_Channel:
    _hx_class_name = "hxd.impl.ArrayIterator_hxd_snd_Channel"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_hxd_snd_Channel._hx_class = hxd_impl_ArrayIterator_hxd_snd_Channel
_hx_classes["hxd.impl.ArrayIterator_hxd_snd_Channel"] = hxd_impl_ArrayIterator_hxd_snd_Channel


class hxd_impl__UncheckedBytes_UncheckedBytes_Impl_:
    _hx_class_name = "hxd.impl._UncheckedBytes.UncheckedBytes_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get", "set", "fromBytes"]

    @staticmethod
    def _new(v):
        this1 = v
        return this1

    @staticmethod
    def get(this1,i):
        return this1[i]

    @staticmethod
    def set(this1,i,v):
        this1[i] = v
        return v

    @staticmethod
    def fromBytes(b):
        this1 = b.b
        return this1
hxd_impl__UncheckedBytes_UncheckedBytes_Impl_._hx_class = hxd_impl__UncheckedBytes_UncheckedBytes_Impl_
_hx_classes["hxd.impl._UncheckedBytes.UncheckedBytes_Impl_"] = hxd_impl__UncheckedBytes_UncheckedBytes_Impl_


class hxd_res__Any_SingleFileSystem(hxd_fs_BytesFileSystem):
    _hx_class_name = "hxd.res._Any.SingleFileSystem"
    _hx_is_interface = "False"
    __slots__ = ("path", "bytes")
    _hx_fields = ["path", "bytes"]
    _hx_methods = ["getBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fs_BytesFileSystem


    def __init__(self,path,_hx_bytes):
        self.bytes = None
        self.path = None
        super().__init__()
        self.path = path
        self.bytes = _hx_bytes

    def getBytes(self,p):
        if (p == self.path):
            return self.bytes
        else:
            return None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.path = None
        _hx_o.bytes = None
hxd_res__Any_SingleFileSystem._hx_class = hxd_res__Any_SingleFileSystem
_hx_classes["hxd.res._Any.SingleFileSystem"] = hxd_res__Any_SingleFileSystem


class hxd_res_Resource:
    _hx_class_name = "hxd.res.Resource"
    _hx_is_interface = "False"
    __slots__ = ("entry",)
    _hx_fields = ["entry"]
    _hx_methods = ["get_name", "toString", "watch"]
    _hx_statics = ["LIVE_UPDATE"]

    def __init__(self,entry):
        self.entry = entry

    def get_name(self):
        return self.entry.name

    def toString(self):
        return self.entry.get_path()

    def watch(self,onChanged):
        if hxd_res_Resource.LIVE_UPDATE:
            self.entry.watch(onChanged)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.entry = None
hxd_res_Resource._hx_class = hxd_res_Resource
_hx_classes["hxd.res.Resource"] = hxd_res_Resource


class hxd_res_Any(hxd_res_Resource):
    _hx_class_name = "hxd.res.Any"
    _hx_is_interface = "False"
    __slots__ = ("loader",)
    _hx_fields = ["loader"]
    _hx_methods = ["toModel", "toTexture", "toTile", "toText", "toImage", "toSound", "toPrefab", "to", "iterator"]
    _hx_statics = ["fromBytes"]
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,loader,entry):
        self.loader = None
        super().__init__(entry)
        self.loader = loader

    def toModel(self):
        return self.loader.loadCache(self.entry.get_path(),hxd_res_Model)

    def toTexture(self):
        return self.toImage().toTexture()

    def toTile(self):
        return self.toImage().toTile()

    def toText(self):
        return self.entry.getBytes().toString()

    def toImage(self):
        return self.loader.loadCache(self.entry.get_path(),hxd_res_Image)

    def toSound(self):
        return self.loader.loadCache(self.entry.get_path(),hxd_res_Sound)

    def toPrefab(self):
        return self.loader.loadCache(self.entry.get_path(),hxd_res_Resource)

    def to(self,c):
        return self.loader.loadCache(self.entry.get_path(),c)

    def iterator(self):
        _g = []
        _g1 = self.entry.iterator()
        while (_g1.i < _g1.l):
            def _hx_local_1():
                _hx_local_0 = _g1.i
                _g1.i = (_g1.i + 1)
                return _hx_local_0
            f = python_internal_ArrayImpl._get(_g1.a, _hx_local_1())
            x = hxd_res_Any(self.loader,f)
            _g.append(x)
        return hxd_impl_ArrayIterator_hxd_res_Any(_g)

    @staticmethod
    def fromBytes(path,_hx_bytes):
        fs = hxd_res__Any_SingleFileSystem(path,_hx_bytes)
        return hxd_res_Loader(fs).load(path)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.loader = None
hxd_res_Any._hx_class = hxd_res_Any
_hx_classes["hxd.res.Any"] = hxd_res_Any


class hxd_res_BitmapFont(hxd_res_Resource):
    _hx_class_name = "hxd.res.BitmapFont"
    _hx_is_interface = "False"
    __slots__ = ("loader", "font", "sdfFonts")
    _hx_fields = ["loader", "font", "sdfFonts"]
    _hx_methods = ["toFont", "toSdfFont", "resolveSdfTile", "resolveTile"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,entry):
        self.sdfFonts = None
        self.font = None
        self.loader = None
        super().__init__(entry)
        self.loader = hxd_res_Loader.currentInstance

    def toFont(self):
        if (self.font is None):
            self.font = hxd_fmt_bfnt_FontParser.parse(self.entry.getBytes(),self.entry.get_path(),self.resolveTile)
        return self.font

    def toSdfFont(self,size = None,channel = None,alphaCutoff = None,smoothing = None):
        if (channel is None):
            channel = 0
        if (alphaCutoff is None):
            alphaCutoff = 0.5
        if (smoothing is None):
            smoothing = 0.03125
        if (self.sdfFonts is None):
            self.sdfFonts = list()
        if (size is None):
            size = self.toFont().size
        _g = 0
        _g1 = self.sdfFonts
        while (_g < len(_g1)):
            font = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = font.type
            if (_g2.index == 1):
                fchannel = _g2.params[0]
                falphaCutoff = _g2.params[1]
                fsmoothing = _g2.params[2]
                if ((((font.size == size) and ((fchannel == channel))) and ((falphaCutoff == alphaCutoff))) and ((fsmoothing == smoothing))):
                    return font
        font = hxd_fmt_bfnt_FontParser.parse(self.entry.getBytes(),self.entry.get_path(),self.resolveSdfTile)
        font.type = h2d_FontType.SignedDistanceField(channel,alphaCutoff,smoothing)
        font.resizeTo(size)
        _this = self.sdfFonts
        _this.append(font)
        return font

    def resolveSdfTile(self,path):
        tex = self.loader.load(path).toTexture()
        tex.set_filter(h3d_mat_Filter.Linear)
        return h2d_Tile.fromTexture(tex)

    def resolveTile(self,path):
        return self.loader.load(path).toTile()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.loader = None
        _hx_o.font = None
        _hx_o.sdfFonts = None
hxd_res_BitmapFont._hx_class = hxd_res_BitmapFont
_hx_classes["hxd.res.BitmapFont"] = hxd_res_BitmapFont


class hxd_res_Font(hxd_res_Resource):
    _hx_class_name = "hxd.res.Font"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["build"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,entry):
        super().__init__(entry)

    def build(self,size,options = None):
        raise haxe_Exception.thrown("Not implemented for this platform")

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_res_Font._hx_class = hxd_res_Font
_hx_classes["hxd.res.Font"] = hxd_res_Font


class hxd_res__Image_ImageFormat_Impl_:
    _hx_class_name = "hxd.res._Image.ImageFormat_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["Jpg", "Png", "Gif", "Tga", "Dds", "Raw", "Hdr", "get_useAsyncDecode", "toInt"]
    useAsyncDecode = None

    @staticmethod
    def get_useAsyncDecode(this1):
        return (this1 == 0)

    @staticmethod
    def toInt(this1):
        return this1
hxd_res__Image_ImageFormat_Impl_._hx_class = hxd_res__Image_ImageFormat_Impl_
_hx_classes["hxd.res._Image.ImageFormat_Impl_"] = hxd_res__Image_ImageFormat_Impl_

class hxd_res_ImageInfoFlag(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.res.ImageInfoFlag"
    _hx_constructs = ["IsCube", "Dxt10Header"]
hxd_res_ImageInfoFlag.IsCube = hxd_res_ImageInfoFlag("IsCube", 0, ())
hxd_res_ImageInfoFlag.Dxt10Header = hxd_res_ImageInfoFlag("Dxt10Header", 1, ())
hxd_res_ImageInfoFlag._hx_class = hxd_res_ImageInfoFlag
_hx_classes["hxd.res.ImageInfoFlag"] = hxd_res_ImageInfoFlag


class hxd_res_ImageInfo:
    _hx_class_name = "hxd.res.ImageInfo"
    _hx_is_interface = "False"
    __slots__ = ("width", "height", "mipLevels", "flags", "dataFormat", "pixelFormat")
    _hx_fields = ["width", "height", "mipLevels", "flags", "dataFormat", "pixelFormat"]

    def __init__(self):
        self.pixelFormat = None
        self.dataFormat = None
        self.mipLevels = 1
        self.height = 0
        self.width = 0
        this1 = 0
        self.flags = this1

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.mipLevels = None
        _hx_o.flags = None
        _hx_o.dataFormat = None
        _hx_o.pixelFormat = None
hxd_res_ImageInfo._hx_class = hxd_res_ImageInfo
_hx_classes["hxd.res.ImageInfo"] = hxd_res_ImageInfo


class hxd_res_Image(hxd_res_Resource):
    _hx_class_name = "hxd.res.Image"
    _hx_is_interface = "False"
    __slots__ = ("tex", "inf")
    _hx_fields = ["tex", "inf"]
    _hx_methods = ["getFormat", "getPixelFormat", "getSize", "getInfo", "getPixels", "toBitmap", "watchCallb", "loadTexture", "toTexture", "toTile"]
    _hx_statics = ["DEFAULT_FILTER", "DEFAULT_ASYNC", "ENABLE_AUTO_WATCH", "setupTextureFlags"]
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,entry):
        self.inf = None
        self.tex = None
        super().__init__(entry)

    def getFormat(self):
        return self.getInfo().dataFormat

    def getPixelFormat(self):
        return self.getInfo().pixelFormat

    def getSize(self):
        return self.getInfo()

    def getInfo(self):
        if (self.inf is not None):
            return self.inf
        self.inf = hxd_res_ImageInfo()
        f = hxd_fs_FileInput(self.entry)
        head = None
        try:
            head = f.readUInt16()
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof):
                head = 0
            else:
                raise _g
        head1 = head
        if (head1 == 16163):
            self.inf.dataFormat = 6
            while (f.readLine() != ""):
                pass
            _this = f.readLine()
            parts = _this.split(" ")
            self.inf.pixelFormat = hxd_PixelFormat.RGBA32F
            self.inf.height = Std.parseInt((parts[1] if 1 < len(parts) else None))
            self.inf.width = Std.parseInt((parts[3] if 3 < len(parts) else None))
        elif (head1 == 17476):
            self.inf.dataFormat = 4
            f.skip(10)
            self.inf.height = f.readInt32()
            self.inf.width = f.readInt32()
            f.skip(8)
            self.inf.mipLevels = f.readInt32()
            f.skip(48)
            caps = f.readInt32()
            fourCC = f.readInt32()
            bpp = f.readInt32()
            rMask = f.readInt32()
            gMask = f.readInt32()
            bMask = f.readInt32()
            aMask = f.readInt32()
            caps2 = f.readInt32()
            cubes = f.readInt32()
            if (((cubes & 65024)) == 65024):
                _hx_local_0 = self.inf
                _hx_local_1 = _hx_local_0.flags
                _hx_local_0.flags = (_hx_local_1 | ((1 << hxd_res_ImageInfoFlag.IsCube.index)))
                _hx_local_0.flags
            _g = (fourCC & 16777215)
            if (_g == 0):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_2 = self.inf
                    _hx_local_3 = _hx_local_2.flags
                    _hx_local_2.flags = (_hx_local_3 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_2.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                elif (((caps & 64)) != 0):
                    if (bpp == 32):
                        rMask1 = rMask
                        if (rMask1 == 255):
                            if (gMask == 65280):
                                if (bMask == 16711680):
                                    if (aMask == -16777216):
                                        self.inf.pixelFormat = hxd_PixelFormat.RGBA
                                    else:
                                        raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                                else:
                                    raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                            else:
                                raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                        elif (rMask1 == 16711680):
                            if (gMask == 65280):
                                if (bMask == 255):
                                    if (aMask == -16777216):
                                        self.inf.pixelFormat = hxd_PixelFormat.BGRA
                                    else:
                                        raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                                else:
                                    raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                            else:
                                raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                        else:
                            raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
                    else:
                        raise haxe_Exception.thrown(((((((((("Unsupported RGB DDS " + Std.string(bpp)) + "bits ") + HxOverrides.stringOrNull(StringTools.hex(rMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(gMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(bMask))) + "/") + HxOverrides.stringOrNull(StringTools.hex(aMask))))
            elif (_g == 111):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_4 = self.inf
                    _hx_local_5 = _hx_local_4.flags
                    _hx_local_4.flags = (_hx_local_5 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_4.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                else:
                    self.inf.pixelFormat = hxd_PixelFormat.R16F
            elif (_g == 112):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_6 = self.inf
                    _hx_local_7 = _hx_local_6.flags
                    _hx_local_6.flags = (_hx_local_7 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_6.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                else:
                    self.inf.pixelFormat = hxd_PixelFormat.RG16F
            elif (_g == 113):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_8 = self.inf
                    _hx_local_9 = _hx_local_8.flags
                    _hx_local_8.flags = (_hx_local_9 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_8.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                else:
                    self.inf.pixelFormat = hxd_PixelFormat.RGBA16F
            elif (_g == 114):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_10 = self.inf
                    _hx_local_11 = _hx_local_10.flags
                    _hx_local_10.flags = (_hx_local_11 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_10.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                else:
                    self.inf.pixelFormat = hxd_PixelFormat.R32F
            elif (_g == 115):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_12 = self.inf
                    _hx_local_13 = _hx_local_12.flags
                    _hx_local_12.flags = (_hx_local_13 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_12.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                else:
                    self.inf.pixelFormat = hxd_PixelFormat.RG32F
            elif (_g == 116):
                if (fourCC == 808540228):
                    f.skip(12)
                    _hx_local_14 = self.inf
                    _hx_local_15 = _hx_local_14.flags
                    _hx_local_14.flags = (_hx_local_15 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                    _hx_local_14.flags
                    dxgi = f.readInt32()
                    tmp = None
                    dxgi1 = dxgi
                    if (dxgi1 == 95):
                        tmp = hxd_PixelFormat.S3TC(6)
                    elif (dxgi1 == 98):
                        tmp = hxd_PixelFormat.S3TC(7)
                    else:
                        raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                    self.inf.pixelFormat = tmp
                else:
                    self.inf.pixelFormat = hxd_PixelFormat.RGBA32F
            elif (_g == 4805697):
                v = ((HxOverrides.rshift(fourCC, 24)) - 48)
                tmp = None
                v1 = v
                if (v1 == 1):
                    tmp = hxd_PixelFormat.S3TC(4)
                elif (v1 == 2):
                    tmp = hxd_PixelFormat.S3TC(5)
                else:
                    tmp = None
                self.inf.pixelFormat = tmp
            elif (_g == 5527620):
                dxt = ((HxOverrides.rshift(fourCC, 24)) - 48)
                tmp = None
                dxt1 = dxt
                if (dxt1 == 1):
                    tmp = hxd_PixelFormat.S3TC(1)
                elif ((dxt1 == 3) or ((dxt1 == 2))):
                    tmp = hxd_PixelFormat.S3TC(2)
                elif ((dxt1 == 5) or ((dxt1 == 4))):
                    tmp = hxd_PixelFormat.S3TC(3)
                else:
                    tmp = None
                self.inf.pixelFormat = tmp
            elif (fourCC == 808540228):
                f.skip(12)
                _hx_local_16 = self.inf
                _hx_local_17 = _hx_local_16.flags
                _hx_local_16.flags = (_hx_local_17 | ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))
                _hx_local_16.flags
                dxgi = f.readInt32()
                tmp = None
                dxgi1 = dxgi
                if (dxgi1 == 95):
                    tmp = hxd_PixelFormat.S3TC(6)
                elif (dxgi1 == 98):
                    tmp = hxd_PixelFormat.S3TC(7)
                else:
                    raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
                self.inf.pixelFormat = tmp
            if (self.inf.pixelFormat is None):
                fid = (((HxOverrides.stringOrNull("".join(map(chr,[(fourCC & 255)]))) + HxOverrides.stringOrNull("".join(map(chr,[((fourCC >> 8) & 255)])))) + HxOverrides.stringOrNull("".join(map(chr,[((fourCC >> 16) & 255)])))) + HxOverrides.stringOrNull("".join(map(chr,[HxOverrides.rshift(fourCC, 24)]))))
                if (((fourCC & 255)) == fourCC):
                    fid = ("0x" + Std.string(fourCC))
                raise haxe_Exception.thrown(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported 4CC ") + ("null" if fid is None else fid)))
        elif (head1 == 18759):
            self.inf.dataFormat = 2
            self.inf.pixelFormat = hxd_PixelFormat.BGRA
            f.readInt32()
            self.inf.width = f.readUInt16()
            self.inf.height = f.readUInt16()
        elif (head1 == 20617):
            self.inf.dataFormat = 1
            f.set_bigEndian(True)
            f.skip(6)
            while True:
                dataLen = f.readInt32()
                if (f.readInt32() == 1229472850):
                    self.inf.width = f.readInt32()
                    self.inf.height = f.readInt32()
                    colbits = f.readByte()
                    tmp = None
                    colbits1 = colbits
                    if (colbits1 == 8):
                        tmp = hxd_PixelFormat.BGRA
                    elif (colbits1 == 16):
                        tmp = hxd_PixelFormat.R16U
                    elif (colbits1 == 48):
                        tmp = hxd_PixelFormat.RGB16U
                    elif (colbits1 == 64):
                        tmp = hxd_PixelFormat.RGBA16U
                    else:
                        raise haxe_Exception.thrown((((("Unsupported png format " + Std.string(colbits)) + "(") + HxOverrides.stringOrNull(self.entry.get_path())) + ")"))
                    self.inf.pixelFormat = tmp
                    break
                f.skip((dataLen + 4))
        elif (head1 == 55551):
            self.inf.dataFormat = 0
            self.inf.pixelFormat = hxd_PixelFormat.BGRA
            f.set_bigEndian(True)
            while True:
                _g = f.readUInt16()
                if (((_g == 65474) or ((_g == 65473))) or ((_g == 65472))):
                    _hx_len = f.readUInt16()
                    prec = f.readByte()
                    self.inf.height = f.readUInt16()
                    self.inf.width = f.readUInt16()
                    break
                else:
                    f.skip((f.readUInt16() - 2))
        elif (self.entry.get_extension() == "tga"):
            self.inf.dataFormat = 3
            self.inf.pixelFormat = hxd_PixelFormat.ARGB
            f.skip(10)
            self.inf.width = f.readUInt16()
            self.inf.height = f.readUInt16()
        elif (self.entry.get_extension() == "raw"):
            self.inf.dataFormat = 5
            self.inf.pixelFormat = hxd_PixelFormat.R32F
            f1 = (self.entry.get_size() >> 2)
            x = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
            size = None
            try:
                size = int(x)
            except BaseException as _g:
                None
                size = None
            if (self.entry.get_size() != (((size * size) * 4))):
                f1 = (self.entry.get_size() >> 1)
                x = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
                size2 = None
                try:
                    size2 = int(x)
                except BaseException as _g:
                    None
                    size2 = None
                if (self.entry.get_size() == (((size2 * size2) * 2))):
                    self.inf.pixelFormat = hxd_PixelFormat.R16F
                    size = size2
                else:
                    raise haxe_Exception.thrown(((("RAW format does not match 32 bit per components on " + Std.string(size)) + "x") + Std.string(size)))
            def _hx_local_18():
                self.inf.height = size
                return self.inf.height
            self.inf.width = _hx_local_18()
        else:
            raise haxe_Exception.thrown(("Unsupported texture format " + HxOverrides.stringOrNull(self.entry.get_path())))
        f.close()
        if (self.inf.pixelFormat is None):
            raise haxe_Exception.thrown((("Unsupported internal format (" + HxOverrides.stringOrNull(self.entry.get_path())) + ")"))
        return self.inf

    def getPixels(self,fmt = None,flipY = None,index = None):
        pixels = None
        if (index is None):
            index = 0
        _g = self.getInfo().dataFormat
        if (_g == 0):
            _hx_bytes = self.entry.getBytes()
            if (self.inf.pixelFormat != hxd_PixelFormat.BGRA):
                raise haxe_Exception.thrown((((("No support to decode " + Std.string(self.inf.pixelFormat)) + " on this platform (") + HxOverrides.stringOrNull(self.entry.get_path())) + ")"))
            p = None
            try:
                p = hxd_res_NanoJpeg.decode(_hx_bytes)
            except BaseException as _g:
                None
                e = haxe_Exception.caught(_g).unwrap()
                raise haxe_Exception.thrown((((("Failed to decode JPG " + HxOverrides.stringOrNull(self.entry.get_path())) + " (") + Std.string(e)) + ")"))
            pixels = hxd_Pixels(p.width,p.height,p.pixels,hxd_PixelFormat.BGRA)
        elif (_g == 1):
            _hx_bytes = self.entry.getBytes()
            if (self.inf.pixelFormat != hxd_PixelFormat.BGRA):
                raise haxe_Exception.thrown((((("No support to decode " + Std.string(self.inf.pixelFormat)) + " on this platform (") + HxOverrides.stringOrNull(self.entry.get_path())) + ")"))
            png = format_png_Reader(haxe_io_BytesInput(_hx_bytes))
            png.checkCRC = False
            pixels = hxd_Pixels.alloc(self.inf.width,self.inf.height,hxd_PixelFormat.BGRA)
            pdata = png.read()
            format_png_Tools.extract32(pdata,pixels.bytes,flipY)
            if flipY:
                pixels.flags = (pixels.flags | ((1 << hxd_Flags.FlipY.index)))
        elif (_g == 2):
            _hx_bytes = self.entry.getBytes()
            gif = format_gif_Reader(haxe_io_BytesInput(_hx_bytes)).read()
            if (fmt == hxd_PixelFormat.RGBA):
                pixels = hxd_Pixels(self.inf.width,self.inf.height,format_gif_Tools.extractFullRGBA(gif,0),hxd_PixelFormat.RGBA)
            else:
                pixels = hxd_Pixels(self.inf.width,self.inf.height,format_gif_Tools.extractFullBGRA(gif,0),hxd_PixelFormat.BGRA)
        elif (_g == 3):
            _hx_bytes = self.entry.getBytes()
            r = format_tga_Reader(haxe_io_BytesInput(_hx_bytes)).read()
            if ((r.header.imageType != format_tga_ImageType.UncompressedTrueColor) or ((r.header.bitsPerPixel != 32))):
                raise haxe_Exception.thrown(((("Not supported TGA " + Std.string(r.header.imageType)) + "/") + Std.string(r.header.bitsPerPixel)))
            w = r.header.width
            h = r.header.height
            pixels = hxd_Pixels.alloc(w,h,hxd_PixelFormat.ARGB)
            access = hxd__Pixels_PixelsARGB_Impl_.fromPixels(pixels)
            p = 0
            _g = 0
            _g1 = h
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                _g2 = 0
                _g3 = w
                while (_g2 < _g3):
                    x = _g2
                    _g2 = (_g2 + 1)
                    c = r.imageData[(x + ((y * w)))]
                    _this = access.bytes
                    pos = ((((x + ((y * access.width))) << 2)) + access.offset)
                    v = (((HxOverrides.rshift(c, 24) | (((c >> 8) & 65280))) | (((c << 8) & 16711680))) | ((c << 24)))
                    _this.b[pos] = (v & 255)
                    _this.b[(pos + 1)] = ((v >> 8) & 255)
                    _this.b[(pos + 2)] = ((v >> 16) & 255)
                    _this.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)
            tmp = r.header.imageOrigin.index
            if (tmp == 0):
                pixels.flags = (pixels.flags | ((1 << hxd_Flags.FlipY.index)))
            elif (tmp == 2):
                pass
            else:
                raise haxe_Exception.thrown(("Not supported " + Std.string(r.header.imageOrigin)))
        elif (_g == 4):
            pos = 128
            mipLevel = 0
            if (((self.inf.flags & ((1 << hxd_res_ImageInfoFlag.Dxt10Header.index)))) != 0):
                pos = (pos + 20)
            if (index > 0):
                bpp = hxd_Pixels.calcStride(1,self.inf.pixelFormat)
                x = (index / self.inf.mipLevels)
                layer = None
                try:
                    layer = int(x)
                except BaseException as _g:
                    None
                    layer = None
                mipLevel = HxOverrides.mod(index, self.inf.mipLevels)
                totSize = 0
                _g = 0
                _g1 = self.inf.mipLevels
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    w = (self.inf.width >> i)
                    h = (self.inf.height >> i)
                    if (w == 0):
                        w = 1
                    if (h == 0):
                        h = 1
                    size = hxd_Pixels.calcDataSize(w,h,self.inf.pixelFormat)
                    totSize = (totSize + size)
                    if (i < mipLevel):
                        pos = (pos + size)
                    elif (layer == 0):
                        break
                pos = (pos + ((totSize * layer)))
            _hx_bytes = None
            w = (self.inf.width >> mipLevel)
            h = (self.inf.height >> mipLevel)
            if (w == 0):
                w = 1
            if (h == 0):
                h = 1
            if ((self.inf.mipLevels == 1) and ((((self.inf.flags & ((1 << hxd_res_ImageInfoFlag.IsCube.index)))) == 0))):
                _hx_bytes = self.entry.getBytes()
            else:
                size = hxd_Pixels.calcDataSize(w,h,self.inf.pixelFormat)
                self.entry.open()
                self.entry.skip(pos)
                _hx_bytes = haxe_io_Bytes.alloc(size)
                self.entry.read(_hx_bytes,0,size)
                self.entry.close()
                pos = 0
            pixels = hxd_Pixels(w,h,_hx_bytes,self.inf.pixelFormat,pos)
        elif (_g == 5):
            _hx_bytes = self.entry.getBytes()
            pixels = hxd_Pixels(self.inf.width,self.inf.height,_hx_bytes,self.inf.pixelFormat)
        elif (_g == 6):
            data = hxd_fmt_hdr_Reader.decode(self.entry.getBytes(),False)
            pixels = hxd_Pixels(data.width,data.height,data.bytes,self.inf.pixelFormat)
        else:
            pass
        if (fmt is not None):
            pixels.convert(fmt)
        if (flipY is not None):
            pixels.setFlip(flipY)
        return pixels

    def toBitmap(self):
        self.getInfo()
        bmp = hxd_BitmapData(self.inf.width,self.inf.height)
        pixels = self.getPixels()
        bmp.setPixels(pixels)
        pixels.dispose()
        return bmp

    def watchCallb(self):
        w = self.inf.width
        h = self.inf.height
        self.inf = None
        s = self.getInfo()
        if ((w != s.width) or ((h != s.height))):
            self.tex.resize(s.width,s.height)
        self.tex.realloc = None
        self.loadTexture()

    def loadTexture(self):
        _gthis = self
        if ((self.getInfo().dataFormat != 0) and (not hxd_res_Image.DEFAULT_ASYNC)):
            def _hx_local_0():
                _gthis.tex.alloc()
                _g = 0
                _g1 = _gthis.tex.get_layerCount()
                while (_g < _g1):
                    layer = _g
                    _g = (_g + 1)
                    _g2 = 0
                    _g3 = _gthis.inf.mipLevels
                    while (_g2 < _g3):
                        mip = _g2
                        _g2 = (_g2 + 1)
                        pixels = _gthis.getPixels(_gthis.tex.format,None,((layer * _gthis.inf.mipLevels) + mip))
                        _gthis.tex.uploadPixels(pixels,mip,layer)
                        pixels.dispose()
                _gthis.tex.realloc = _gthis.loadTexture
                if hxd_res_Image.ENABLE_AUTO_WATCH:
                    _gthis.watch(_gthis.watchCallb)
            load = _hx_local_0
            if self.entry.get_isAvailable():
                load()
            else:
                self.entry.load(load)
        else:
            _hx_local_1 = self.tex
            _hx_local_2 = _hx_local_1.flags
            _hx_local_1.flags = (_hx_local_2 | ((1 << h3d_mat_TextureFlags.Loading.index)))
            _hx_local_1.flags
            def _hx_local_6(bmp):
                bmp1 = hxd_fs__LoadedBitmap_LoadedBitmap_Impl_.toBitmap(bmp)
                _gthis.tex.alloc()
                _gthis.tex.uploadBitmap(bmp1)
                bmp1.data = None
                _gthis.tex.realloc = _gthis.loadTexture
                _hx_local_3 = _gthis.tex
                _hx_local_4 = _hx_local_3.flags
                _hx_local_3.flags = (_hx_local_4 & ((-1 - ((1 << h3d_mat_TextureFlags.Loading.index)))))
                _hx_local_3.flags
                if (_gthis.tex.waitLoads is not None):
                    arr = _gthis.tex.waitLoads
                    _gthis.tex.waitLoads = None
                    _g = 0
                    while (_g < len(arr)):
                        f = (arr[_g] if _g >= 0 and _g < len(arr) else None)
                        _g = (_g + 1)
                        f()
                if hxd_res_Image.ENABLE_AUTO_WATCH:
                    _gthis.watch(_gthis.watchCallb)
            self.entry.loadBitmap(_hx_local_6)

    def toTexture(self):
        if (self.tex is not None):
            return self.tex
        self.getInfo()
        flags = [h3d_mat_TextureFlags.NoAlloc]
        fmt = self.inf.pixelFormat
        if (((fmt == hxd_PixelFormat.BGRA) or ((fmt == hxd_PixelFormat.ARGB))) or ((fmt == hxd_PixelFormat.RGBA))):
            fmt = h3d_mat_Texture.nativeFormat
        if (((self.inf.flags & ((1 << hxd_res_ImageInfoFlag.IsCube.index)))) != 0):
            flags.append(h3d_mat_TextureFlags.Cube)
        if (self.inf.mipLevels > 1):
            flags.append(h3d_mat_TextureFlags.MipMapped)
            flags.append(h3d_mat_TextureFlags.ManualMipMapGen)
        if (fmt == hxd_PixelFormat.R16U):
            raise haxe_Exception.thrown(((("Unsupported texture format " + Std.string(fmt)) + " for ") + HxOverrides.stringOrNull(self.entry.get_path())))
        self.tex = h3d_mat_Texture(self.inf.width,self.inf.height,flags,fmt)
        if (hxd_res_Image.DEFAULT_FILTER != h3d_mat_Filter.Linear):
            self.tex.set_filter(hxd_res_Image.DEFAULT_FILTER)
        self.tex.setName(self.entry.get_path())
        hxd_res_Image.setupTextureFlags(self.tex)
        self.loadTexture()
        return self.tex

    def toTile(self):
        self.getInfo()
        return h2d_Tile.fromTexture(self.toTexture()).sub(0,0,self.inf.width,self.inf.height)

    @staticmethod
    def setupTextureFlags(tex):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tex = None
        _hx_o.inf = None
hxd_res_Image._hx_class = hxd_res_Image
_hx_classes["hxd.res.Image"] = hxd_res_Image


class hxd_res_Loader:
    _hx_class_name = "hxd.res.Loader"
    _hx_is_interface = "False"
    __slots__ = ("fs", "cache")
    _hx_fields = ["fs", "cache"]
    _hx_methods = ["cleanCache", "dir", "exists", "load", "loadCache", "dispose"]
    _hx_statics = ["currentInstance"]

    def __init__(self,fs):
        self.fs = fs
        self.cache = haxe_ds_StringMap()

    def cleanCache(self):
        self.cache = haxe_ds_StringMap()

    def dir(self,path):
        r = []
        entries = self.fs.dir(path)
        _g = 0
        while (_g < len(entries)):
            e = (entries[_g] if _g >= 0 and _g < len(entries) else None)
            _g = (_g + 1)
            x = hxd_res_Any(self,e)
            r.append(x)
        return r

    def exists(self,path):
        return self.fs.exists(path)

    def load(self,path):
        return hxd_res_Any(self,self.fs.get(path))

    def loadCache(self,path,c):
        res = self.cache.h.get(path,None)
        if (res is None):
            entry = self.fs.get(path)
            old = hxd_res_Loader.currentInstance
            hxd_res_Loader.currentInstance = self
            res = c(*[entry])
            hxd_res_Loader.currentInstance = old
            self.cache.h[path] = res
        elif (Std.downcast(res,c) is None):
            raise haxe_Exception.thrown(((((("null" if path is None else path) + " has been reintrepreted from ") + Std.string(Type.getClass(res))) + " to ") + Std.string(c)))
        return res

    def dispose(self):
        self.cleanCache()
        self.fs.dispose()
    currentInstance = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fs = None
        _hx_o.cache = None
hxd_res_Loader._hx_class = hxd_res_Loader
_hx_classes["hxd.res.Loader"] = hxd_res_Loader


class hxd_res_Model(hxd_res_Resource):
    _hx_class_name = "hxd.res.Model"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["toHmd"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,entry):
        super().__init__(entry)

    def toHmd(self):
        fs = hxd_fs_FileInput(self.entry)
        hmd = hxd_fmt_hmd_Reader(fs).readHeader()
        fs.close()
        return hxd_fmt_hmd_Library(self,hmd)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_res_Model._hx_class = hxd_res_Model
_hx_classes["hxd.res.Model"] = hxd_res_Model

class hxd_res_Filter(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.res.Filter"
    _hx_constructs = ["Fast", "Chromatic"]
hxd_res_Filter.Fast = hxd_res_Filter("Fast", 0, ())
hxd_res_Filter.Chromatic = hxd_res_Filter("Chromatic", 1, ())
hxd_res_Filter._hx_class = hxd_res_Filter
_hx_classes["hxd.res.Filter"] = hxd_res_Filter


class hxd_res__NanoJpeg_FastBytes_Impl_:
    _hx_class_name = "hxd.res._NanoJpeg.FastBytes_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get", "set"]

    @staticmethod
    def _new(b):
        this1 = b
        return this1

    @staticmethod
    def get(this1,i):
        return this1.b[i]

    @staticmethod
    def set(this1,i,v):
        this1.b[i] = (v & 255)
hxd_res__NanoJpeg_FastBytes_Impl_._hx_class = hxd_res__NanoJpeg_FastBytes_Impl_
_hx_classes["hxd.res._NanoJpeg.FastBytes_Impl_"] = hxd_res__NanoJpeg_FastBytes_Impl_


class hxd_res__NanoJpeg_Component:
    _hx_class_name = "hxd.res._NanoJpeg.Component"
    _hx_is_interface = "False"
    __slots__ = ("cid", "ssx", "ssy", "width", "height", "stride", "qtsel", "actabsel", "dctabsel", "dcpred", "pixels")
    _hx_fields = ["cid", "ssx", "ssy", "width", "height", "stride", "qtsel", "actabsel", "dctabsel", "dcpred", "pixels"]

    def __init__(self):
        self.pixels = None
        self.dcpred = None
        self.dctabsel = None
        self.actabsel = None
        self.qtsel = None
        self.stride = None
        self.height = None
        self.width = None
        self.ssy = None
        self.ssx = None
        self.cid = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cid = None
        _hx_o.ssx = None
        _hx_o.ssy = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.stride = None
        _hx_o.qtsel = None
        _hx_o.actabsel = None
        _hx_o.dctabsel = None
        _hx_o.dcpred = None
        _hx_o.pixels = None
hxd_res__NanoJpeg_Component._hx_class = hxd_res__NanoJpeg_Component
_hx_classes["hxd.res._NanoJpeg.Component"] = hxd_res__NanoJpeg_Component


class hxd_res_NanoJpeg:
    _hx_class_name = "hxd.res.NanoJpeg"
    _hx_is_interface = "False"
    __slots__ = ("bytes", "pos", "size", "length", "width", "height", "ncomp", "comps", "counts", "qtab", "qtused", "qtavail", "vlctab", "block", "njZZ", "progressive", "mbsizex", "mbsizey", "mbwidth", "mbheight", "rstinterval", "buf", "bufbits", "pixels", "filter", "vlcCode")
    _hx_fields = ["bytes", "pos", "size", "length", "width", "height", "ncomp", "comps", "counts", "qtab", "qtused", "qtavail", "vlctab", "block", "njZZ", "progressive", "mbsizex", "mbsizey", "mbwidth", "mbheight", "rstinterval", "buf", "bufbits", "pixels", "filter", "vlcCode"]
    _hx_methods = ["alloc", "free", "njInit", "cleanup", "njSkip", "syntax", "get", "njDecode16", "njByteAlign", "njShowBits", "njSkipBits", "njGetBits", "njDecodeLength", "njSkipMarker", "njDecodeSOF", "njDecodeDQT", "njDecodeDHT", "njDecodeDRI", "njGetVLC", "njRowIDCT", "njColIDCT", "njDecodeBlock", "notSupported", "njDecodeScan", "njUpsampleH", "njUpsampleV", "njUpsample", "njConvert", "njDecode"]
    _hx_statics = ["BLOCKSIZE", "W1", "W2", "W3", "W5", "W6", "W7", "CF4A", "CF4B", "CF4C", "CF4D", "CF3A", "CF3B", "CF3C", "CF3X", "CF3Y", "CF3Z", "CF2A", "CF2B", "CF", "njClip", "inst", "decode"]

    def __init__(self):
        self.vlcCode = None
        self.filter = None
        self.pixels = None
        self.bufbits = None
        self.buf = None
        self.rstinterval = None
        self.mbheight = None
        self.mbwidth = None
        self.mbsizey = None
        self.mbsizex = None
        self.progressive = None
        self.qtavail = None
        self.qtused = None
        self.ncomp = None
        self.height = None
        self.width = None
        self.length = None
        self.size = None
        self.pos = None
        self.bytes = None
        self.comps = list([hxd_res__NanoJpeg_Component(), hxd_res__NanoJpeg_Component(), hxd_res__NanoJpeg_Component()])
        this1 = [None]*64
        this2 = [None]*64
        this3 = [None]*64
        this4 = [None]*64
        self.qtab = list([this1, this2, this3, this4])
        this1 = [None]*16
        self.counts = this1
        this1 = [None]*64
        self.block = this1
        self.njZZ = list([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63])
        self.vlctab = list([None, None, None, None, None, None, None, None])

    def alloc(self,nbytes):
        return haxe_io_Bytes.alloc(nbytes)

    def free(self,_hx_bytes):
        pass

    def njInit(self,_hx_bytes,pos,size,_hx_filter):
        self.bytes = _hx_bytes
        self.pos = pos
        self.filter = (hxd_res_Filter.Chromatic if ((_hx_filter is None)) else _hx_filter)
        if (size < 0):
            size = (_hx_bytes.length - pos)
        if (self.vlctab[0] is None):
            this1 = self.vlctab
            val = haxe_io_Bytes.alloc(131072)
            this1[0] = val
        if (self.vlctab[1] is None):
            this1 = self.vlctab
            val = haxe_io_Bytes.alloc(131072)
            this1[1] = val
        if (self.vlctab[2] is None):
            this1 = self.vlctab
            val = haxe_io_Bytes.alloc(131072)
            this1[2] = val
        if (self.vlctab[3] is None):
            this1 = self.vlctab
            val = haxe_io_Bytes.alloc(131072)
            this1[3] = val
        self.size = size
        self.qtused = 0
        self.qtavail = 0
        self.rstinterval = 0
        self.length = 0
        self.buf = 0
        self.bufbits = 0
        self.progressive = False
        self.comps[0].dcpred = 0
        self.comps[1].dcpred = 0
        self.comps[2].dcpred = 0

    def cleanup(self):
        self.bytes = None
        _g = 0
        _g1 = self.comps
        while (_g < len(_g1)):
            c = _g1[_g]
            _g = (_g + 1)
            if (c.pixels is not None):
                c.pixels = None
        if (self.vlctab[0] is not None):
            _hx_bytes = self.vlctab[0]
            val = None
            self.vlctab[0] = val
        if (self.vlctab[1] is not None):
            _hx_bytes = self.vlctab[1]
            val = None
            self.vlctab[1] = val
        if (self.vlctab[2] is not None):
            _hx_bytes = self.vlctab[2]
            val = None
            self.vlctab[2] = val
        if (self.vlctab[3] is not None):
            _hx_bytes = self.vlctab[3]
            val = None
            self.vlctab[3] = val
        if (self.vlctab[4] is not None):
            _hx_bytes = self.vlctab[4]
            val = None
            self.vlctab[4] = val
        if (self.vlctab[5] is not None):
            _hx_bytes = self.vlctab[5]
            val = None
            self.vlctab[5] = val
        if (self.vlctab[6] is not None):
            _hx_bytes = self.vlctab[6]
            val = None
            self.vlctab[6] = val
        if (self.vlctab[7] is not None):
            _hx_bytes = self.vlctab[7]
            val = None
            self.vlctab[7] = val

    def njSkip(self,count):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + count)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - count)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - count)
        _hx_local_4.length

    def syntax(self,flag):
        pass

    def get(self,p):
        return self.bytes.b[(self.pos + p)]

    def njDecode16(self,p):
        return ((self.bytes.b[(self.pos + p)] << 8) | self.bytes.b[(self.pos + ((p + 1)))])

    def njByteAlign(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 & 248)
        _hx_local_0.bufbits

    def njShowBits(self,bits):
        if (bits == 0):
            return 0
        while (self.bufbits < bits):
            if (self.size <= 0):
                self.buf = ((self.buf << 8) | 255)
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.bufbits
                _hx_local_0.bufbits = (_hx_local_1 + 8)
                _hx_local_0.bufbits
                continue
            newbyte = self.bytes.b[self.pos]
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 1)
            _hx_local_3
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.size
            _hx_local_4.size = (_hx_local_5 - 1)
            _hx_local_5
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.bufbits
            _hx_local_6.bufbits = (_hx_local_7 + 8)
            _hx_local_6.bufbits
            self.buf = ((self.buf << 8) | newbyte)
            if (newbyte == 255):
                marker = self.bytes.b[self.pos]
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.pos
                _hx_local_8.pos = (_hx_local_9 + 1)
                _hx_local_9
                _hx_local_10 = self
                _hx_local_11 = _hx_local_10.size
                _hx_local_10.size = (_hx_local_11 - 1)
                _hx_local_11
                marker1 = marker
                if (marker1 == 217):
                    self.size = 0
                elif ((marker1 == 255) or ((marker1 == 0))):
                    pass
                else:
                    self.buf = ((self.buf << 8) | marker)
                    _hx_local_12 = self
                    _hx_local_13 = _hx_local_12.bufbits
                    _hx_local_12.bufbits = (_hx_local_13 + 8)
                    _hx_local_12.bufbits
        return ((self.buf >> ((self.bufbits - bits))) & ((((1 << bits)) - 1)))

    def njSkipBits(self,bits):
        if (self.bufbits < bits):
            self.njShowBits(bits)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 - bits)
        _hx_local_0.bufbits

    def njGetBits(self,bits):
        r = self.njShowBits(bits)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 - bits)
        _hx_local_0.bufbits
        return r

    def njDecodeLength(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length

    def njSkipMarker(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        count = self.length
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.pos
        _hx_local_6.pos = (_hx_local_7 + count)
        _hx_local_6.pos
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.size
        _hx_local_8.size = (_hx_local_9 - count)
        _hx_local_8.size
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.length
        _hx_local_10.length = (_hx_local_11 - count)
        _hx_local_10.length

    def njDecodeSOF(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        if (self.bytes.b[self.pos] != 8):
            self.notSupported()
        self.height = ((self.bytes.b[(self.pos + 1)] << 8) | self.bytes.b[(self.pos + 2)])
        self.width = ((self.bytes.b[(self.pos + 3)] << 8) | self.bytes.b[(self.pos + 4)])
        self.ncomp = self.bytes.b[(self.pos + 5)]
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.pos
        _hx_local_6.pos = (_hx_local_7 + 6)
        _hx_local_6.pos
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.size
        _hx_local_8.size = (_hx_local_9 - 6)
        _hx_local_8.size
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.length
        _hx_local_10.length = (_hx_local_11 - 6)
        _hx_local_10.length
        _g = self.ncomp
        if ((_g == 3) or ((_g == 1))):
            pass
        else:
            self.notSupported()
        ssxmax = 0
        ssymax = 0
        _g = 0
        _g1 = self.ncomp
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.comps[i]
            c.cid = self.bytes.b[self.pos]
            c.ssx = (self.bytes.b[(self.pos + 1)] >> 4)
            if (((c.ssx & ((c.ssx - 1)))) != 0):
                self.notSupported()
            c.ssy = (self.bytes.b[(self.pos + 1)] & 15)
            if (((c.ssy & ((c.ssy - 1)))) != 0):
                self.notSupported()
            c.qtsel = self.bytes.b[(self.pos + 2)]
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + 3)
            _hx_local_12.pos
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.size
            _hx_local_14.size = (_hx_local_15 - 3)
            _hx_local_14.size
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.length
            _hx_local_16.length = (_hx_local_17 - 3)
            _hx_local_16.length
            _hx_local_18 = self
            _hx_local_19 = _hx_local_18.qtused
            _hx_local_18.qtused = (_hx_local_19 | ((1 << c.qtsel)))
            _hx_local_18.qtused
            if (c.ssx > ssxmax):
                ssxmax = c.ssx
            if (c.ssy > ssymax):
                ssymax = c.ssy
        if (self.ncomp == 1):
            c = self.comps[0]
            ssymax = 1
            ssxmax = ssymax
            def _hx_local_20():
                c.ssy = ssxmax
                return c.ssy
            c.ssx = _hx_local_20()
        self.mbsizex = (ssxmax << 3)
        self.mbsizey = (ssymax << 3)
        x = ((((self.width + self.mbsizex) - 1)) / self.mbsizex)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        self.mbwidth = tmp
        x = ((((self.height + self.mbsizey) - 1)) / self.mbsizey)
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        self.mbheight = tmp
        _g = 0
        _g1 = self.ncomp
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.comps[i]
            x = (((((self.width * c.ssx) + ssxmax) - 1)) / ssxmax)
            tmp = None
            try:
                tmp = int(x)
            except BaseException as _g2:
                None
                tmp = None
            c.width = tmp
            c.stride = ((c.width + 7) & 2147483640)
            x1 = (((((self.height * c.ssy) + ssymax) - 1)) / ssymax)
            tmp1 = None
            try:
                tmp1 = int(x1)
            except BaseException as _g3:
                None
                tmp1 = None
            c.height = tmp1
            x2 = (((self.mbwidth * self.mbsizex) * c.ssx) / ssxmax)
            tmp2 = None
            try:
                tmp2 = int(x2)
            except BaseException as _g4:
                None
                tmp2 = None
            c.stride = tmp2
            if (((c.width < 3) and ((c.ssx != ssxmax))) or (((c.height < 3) and ((c.ssy != ssymax))))):
                self.notSupported()
            c1 = c.stride
            x3 = (((self.mbheight * self.mbsizey) * c.ssy) / ssymax)
            nbytes = None
            try:
                nbytes = int(x3)
            except BaseException as _g5:
                None
                nbytes = None
            c.pixels = haxe_io_Bytes.alloc((c1 * nbytes))
        count = self.length
        _hx_local_21 = self
        _hx_local_22 = _hx_local_21.pos
        _hx_local_21.pos = (_hx_local_22 + count)
        _hx_local_21.pos
        _hx_local_23 = self
        _hx_local_24 = _hx_local_23.size
        _hx_local_23.size = (_hx_local_24 - count)
        _hx_local_23.size
        _hx_local_25 = self
        _hx_local_26 = _hx_local_25.length
        _hx_local_25.length = (_hx_local_26 - count)
        _hx_local_25.length

    def njDecodeDQT(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        while (self.length >= 65):
            i = self.bytes.b[self.pos]
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.qtavail
            _hx_local_6.qtavail = (_hx_local_7 | ((1 << i)))
            _hx_local_6.qtavail
            t = self.qtab[i]
            _g = 0
            while (_g < 64):
                k = _g
                _g = (_g + 1)
                val = self.bytes.b[(self.pos + ((k + 1)))]
                t[k] = val
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.pos
            _hx_local_8.pos = (_hx_local_9 + 65)
            _hx_local_8.pos
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.size
            _hx_local_10.size = (_hx_local_11 - 65)
            _hx_local_10.size
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.length
            _hx_local_12.length = (_hx_local_13 - 65)
            _hx_local_12.length

    def njDecodeDHT(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        while (self.length >= 17):
            i = self.bytes.b[self.pos]
            i = (((i >> 4) & 1) | ((((i & 3)) << 1)))
            this1 = self.counts
            val = self.bytes.b[(self.pos + 1)]
            this1[0] = val
            this2 = self.counts
            val1 = self.bytes.b[(self.pos + 2)]
            this2[1] = val1
            this3 = self.counts
            val2 = self.bytes.b[(self.pos + 3)]
            this3[2] = val2
            this4 = self.counts
            val3 = self.bytes.b[(self.pos + 4)]
            this4[3] = val3
            this5 = self.counts
            val4 = self.bytes.b[(self.pos + 5)]
            this5[4] = val4
            this6 = self.counts
            val5 = self.bytes.b[(self.pos + 6)]
            this6[5] = val5
            this7 = self.counts
            val6 = self.bytes.b[(self.pos + 7)]
            this7[6] = val6
            this8 = self.counts
            val7 = self.bytes.b[(self.pos + 8)]
            this8[7] = val7
            this9 = self.counts
            val8 = self.bytes.b[(self.pos + 9)]
            this9[8] = val8
            this10 = self.counts
            val9 = self.bytes.b[(self.pos + 10)]
            this10[9] = val9
            this11 = self.counts
            val10 = self.bytes.b[(self.pos + 11)]
            this11[10] = val10
            this12 = self.counts
            val11 = self.bytes.b[(self.pos + 12)]
            this12[11] = val11
            this13 = self.counts
            val12 = self.bytes.b[(self.pos + 13)]
            this13[12] = val12
            this14 = self.counts
            val13 = self.bytes.b[(self.pos + 14)]
            this14[13] = val13
            this15 = self.counts
            val14 = self.bytes.b[(self.pos + 15)]
            this15[14] = val14
            this16 = self.counts
            val15 = self.bytes.b[(self.pos + 16)]
            this16[15] = val15
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 17)
            _hx_local_6.pos
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.size
            _hx_local_8.size = (_hx_local_9 - 17)
            _hx_local_8.size
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.length
            _hx_local_10.length = (_hx_local_11 - 17)
            _hx_local_10.length
            vlc = self.vlctab[i]
            vpos = 0
            remain = 65536
            spread = 65536
            _g = 1
            while (_g < 17):
                codelen = _g
                _g = (_g + 1)
                spread = (spread >> 1)
                currcnt = self.counts[(codelen - 1)]
                if (currcnt == 0):
                    continue
                remain = (remain - ((currcnt << ((16 - codelen)))))
                _g1 = 0
                _g2 = currcnt
                while (_g1 < _g2):
                    i1 = _g1
                    _g1 = (_g1 + 1)
                    code = self.bytes.b[(self.pos + i1)]
                    _g3 = 0
                    _g4 = spread
                    while (_g3 < _g4):
                        j = _g3
                        _g3 = (_g3 + 1)
                        pos = vpos
                        vpos = (vpos + 1)
                        vlc.b[pos] = (codelen & 255)
                        pos1 = vpos
                        vpos = (vpos + 1)
                        vlc.b[pos1] = (code & 255)
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.pos
                _hx_local_14.pos = (_hx_local_15 + currcnt)
                _hx_local_14.pos
                _hx_local_16 = self
                _hx_local_17 = _hx_local_16.size
                _hx_local_16.size = (_hx_local_17 - currcnt)
                _hx_local_16.size
                _hx_local_18 = self
                _hx_local_19 = _hx_local_18.length
                _hx_local_18.length = (_hx_local_19 - currcnt)
                _hx_local_18.length
            while True:
                tmp = remain
                remain = (remain - 1)
                if (not ((tmp != 0))):
                    break
                vlc.b[vpos] = 0
                vpos = (vpos + 2)

    def njDecodeDRI(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        self.rstinterval = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        count = self.length
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.pos
        _hx_local_6.pos = (_hx_local_7 + count)
        _hx_local_6.pos
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.size
        _hx_local_8.size = (_hx_local_9 - count)
        _hx_local_8.size
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.length
        _hx_local_10.length = (_hx_local_11 - count)
        _hx_local_10.length

    def njGetVLC(self,vlc):
        value = self.njShowBits(16)
        bits = vlc.b[(value << 1)]
        if (self.bufbits < bits):
            self.njShowBits(bits)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 - bits)
        _hx_local_0.bufbits
        value = vlc.b[((value << 1) | 1)]
        self.vlcCode = value
        bits = (value & 15)
        if (bits == 0):
            return 0
        r = self.njShowBits(bits)
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.bufbits
        _hx_local_2.bufbits = (_hx_local_3 - bits)
        _hx_local_2.bufbits
        value = r
        if (value < ((1 << ((bits - 1))))):
            value = (value + ((((-1 << bits)) + 1)))
        return value

    def njRowIDCT(self,bp):
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
            return
        x0 = (((self.block[bp] << 11)) + 128)
        x8 = (565 * ((x4 + x5)))
        x4 = (x8 + ((2276 * x4)))
        x5 = (x8 - ((3406 * x5)))
        x8 = (2408 * ((x6 + x7)))
        x6 = (x8 - ((799 * x6)))
        x7 = (x8 - ((4017 * x7)))
        x8 = (x0 + x1)
        x0 = (x0 - x1)
        x1 = (1108 * ((x3 + x2)))
        x2 = (x1 - ((3784 * x2)))
        x3 = (x1 + ((1568 * x3)))
        x1 = (x4 + x6)
        x4 = (x4 - x6)
        x6 = (x5 + x7)
        x5 = (x5 - x7)
        x7 = (x8 + x3)
        x8 = (x8 - x3)
        x3 = (x0 + x2)
        x0 = (x0 - x2)
        x2 = (((181 * ((x4 + x5))) + 128) >> 8)
        x4 = (((181 * ((x4 - x5))) + 128) >> 8)
        val = ((x7 + x1) >> 8)
        self.block[bp] = val
        val = ((x3 + x2) >> 8)
        self.block[(bp + 1)] = val
        val = ((x0 + x4) >> 8)
        self.block[(bp + 2)] = val
        val = ((x8 + x6) >> 8)
        self.block[(bp + 3)] = val
        val = ((x8 - x6) >> 8)
        self.block[(bp + 4)] = val
        val = ((x0 - x4) >> 8)
        self.block[(bp + 5)] = val
        val = ((x3 - x2) >> 8)
        self.block[(bp + 6)] = val
        val = ((x7 - x1) >> 8)
        self.block[(bp + 7)] = val

    def njColIDCT(self,bp,out,po,stride):
        x1 = (self.block[(bp + 32)] << 8)
        x2 = self.block[(bp + 48)]
        x3 = self.block[(bp + 16)]
        x4 = self.block[(bp + 8)]
        x5 = self.block[(bp + 56)]
        x6 = self.block[(bp + 40)]
        x7 = self.block[(bp + 24)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[bp] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            return
        x0 = (((self.block[bp] << 8)) + 8192)
        x8 = ((565 * ((x4 + x5))) + 4)
        x4 = ((x8 + ((2276 * x4))) >> 3)
        x5 = ((x8 - ((3406 * x5))) >> 3)
        x8 = ((2408 * ((x6 + x7))) + 4)
        x6 = ((x8 - ((799 * x6))) >> 3)
        x7 = ((x8 - ((4017 * x7))) >> 3)
        x8 = (x0 + x1)
        x0 = (x0 - x1)
        x1 = ((1108 * ((x3 + x2))) + 4)
        x2 = ((x1 - ((3784 * x2))) >> 3)
        x3 = ((x1 + ((1568 * x3))) >> 3)
        x1 = (x4 + x6)
        x4 = (x4 - x6)
        x6 = (x5 + x7)
        x5 = (x5 - x7)
        x7 = (x8 + x3)
        x8 = (x8 - x3)
        x3 = (x0 + x2)
        x0 = (x0 - x2)
        x2 = (((181 * ((x4 + x5))) + 128) >> 8)
        x4 = (((181 * ((x4 - x5))) + 128) >> 8)
        x = ((((x7 + x1) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x3 + x2) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x0 + x4) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x8 + x6) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x8 - x6) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x0 - x4) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x3 - x2) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po = (po + stride)
        x = ((((x7 - x1) >> 14)) + 128)
        out.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)

    def njDecodeBlock(self,c,po):
        this1 = c.pixels
        out = this1
        value = None
        coef = 0
        _g = 0
        while (_g < 64):
            i = _g
            _g = (_g + 1)
            self.block[i] = 0
        c1 = c
        c2 = c1.dcpred
        vlc = self.vlctab[c.dctabsel]
        value1 = self.njShowBits(16)
        bits = vlc.b[(value1 << 1)]
        if (self.bufbits < bits):
            self.njShowBits(bits)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 - bits)
        _hx_local_0.bufbits
        value1 = vlc.b[((value1 << 1) | 1)]
        self.vlcCode = value1
        bits = (value1 & 15)
        tmp = None
        if (bits == 0):
            tmp = 0
        else:
            r = self.njShowBits(bits)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.bufbits
            _hx_local_2.bufbits = (_hx_local_3 - bits)
            _hx_local_2.bufbits
            value1 = r
            if (value1 < ((1 << ((bits - 1))))):
                value1 = (value1 + ((((-1 << bits)) + 1)))
            tmp = value1
        c1.dcpred = (c2 + tmp)
        qt = self.qtab[c.qtsel]
        at = self.vlctab[c.actabsel]
        this1 = self.block
        val = (c.dcpred * qt[0])
        this1[0] = val
        while True:
            value1 = self.njShowBits(16)
            bits = at.b[(value1 << 1)]
            if (self.bufbits < bits):
                self.njShowBits(bits)
            _hx_local_5 = self
            _hx_local_6 = _hx_local_5.bufbits
            _hx_local_5.bufbits = (_hx_local_6 - bits)
            _hx_local_5.bufbits
            value1 = at.b[((value1 << 1) | 1)]
            self.vlcCode = value1
            bits = (value1 & 15)
            if (bits == 0):
                value = 0
            else:
                r = self.njShowBits(bits)
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.bufbits
                _hx_local_7.bufbits = (_hx_local_8 - bits)
                _hx_local_7.bufbits
                value1 = r
                if (value1 < ((1 << ((bits - 1))))):
                    value1 = (value1 + ((((-1 << bits)) + 1)))
                value = value1
            if (self.vlcCode == 0):
                break
            coef = (coef + ((((self.vlcCode >> 4)) + 1)))
            this1 = self.block
            index = self.njZZ[coef]
            val = (value * qt[coef])
            this1[index] = val
            if (not ((coef < 63))):
                break
        bp = 0
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 8
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 16
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 24
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 32
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 40
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 48
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        bp = 56
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val = val1
            this6[(bp + 5)] = val
            val1 = val
            this5[(bp + 4)] = val1
            val = val1
            this4[(bp + 3)] = val
            val1 = val
            this3[(bp + 2)] = val1
            val = val1
            this2[(bp + 1)] = val
            val1 = val
            this1[bp] = val1
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val = ((x7 + x1) >> 8)
            self.block[bp] = val
            val = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val
            val = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val
            val = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val
            val = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val
            val = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val
            val = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val
            val = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val
        po1 = po
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[32] << 8)
        x2 = self.block[48]
        x3 = self.block[16]
        x4 = self.block[8]
        x5 = self.block[56]
        x6 = self.block[40]
        x7 = self.block[24]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[0] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[0] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (1 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[33] << 8)
        x2 = self.block[49]
        x3 = self.block[17]
        x4 = self.block[9]
        x5 = self.block[57]
        x6 = self.block[41]
        x7 = self.block[25]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[1] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[1] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (2 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[34] << 8)
        x2 = self.block[50]
        x3 = self.block[18]
        x4 = self.block[10]
        x5 = self.block[58]
        x6 = self.block[42]
        x7 = self.block[26]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[2] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[2] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (3 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[35] << 8)
        x2 = self.block[51]
        x3 = self.block[19]
        x4 = self.block[11]
        x5 = self.block[59]
        x6 = self.block[43]
        x7 = self.block[27]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[3] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[3] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (4 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[36] << 8)
        x2 = self.block[52]
        x3 = self.block[20]
        x4 = self.block[12]
        x5 = self.block[60]
        x6 = self.block[44]
        x7 = self.block[28]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[4] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[4] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (5 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[37] << 8)
        x2 = self.block[53]
        x3 = self.block[21]
        x4 = self.block[13]
        x5 = self.block[61]
        x6 = self.block[45]
        x7 = self.block[29]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[5] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[5] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (6 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[38] << 8)
        x2 = self.block[54]
        x3 = self.block[22]
        x4 = self.block[14]
        x5 = self.block[62]
        x6 = self.block[46]
        x7 = self.block[30]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[6] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[6] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
        po1 = (7 + po)
        stride = c.stride
        x0 = None
        x8 = None
        x1 = (self.block[39] << 8)
        x2 = self.block[55]
        x3 = self.block[23]
        x4 = self.block[15]
        x5 = self.block[63]
        x6 = self.block[47]
        x7 = self.block[31]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[7] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x1 & 255)
            po1 = (po1 + stride)
        else:
            x0 = (((self.block[7] << 8)) + 8192)
            x8 = ((565 * ((x4 + x5))) + 4)
            x4 = ((x8 + ((2276 * x4))) >> 3)
            x5 = ((x8 - ((3406 * x5))) >> 3)
            x8 = ((2408 * ((x6 + x7))) + 4)
            x6 = ((x8 - ((799 * x6))) >> 3)
            x7 = ((x8 - ((4017 * x7))) >> 3)
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = ((1108 * ((x3 + x2))) + 4)
            x2 = ((x1 - ((3784 * x2))) >> 3)
            x3 = ((x1 + ((1568 * x3))) >> 3)
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            x = ((((x7 + x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 + x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 + x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 + x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x8 - x6) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x0 - x4) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x3 - x2) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            po1 = (po1 + stride)
            x = ((((x7 - x1) >> 14)) + 128)
            out.b[po1] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)

    def notSupported(self):
        raise haxe_Exception.thrown("This JPG file is not supported")

    def njDecodeScan(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        if (self.bytes.b[self.pos] != self.ncomp):
            self.notSupported()
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.pos
        _hx_local_6.pos = (_hx_local_7 + 1)
        _hx_local_6.pos
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.size
        _hx_local_8.size = (_hx_local_9 - 1)
        _hx_local_8.size
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.length
        _hx_local_10.length = (_hx_local_11 - 1)
        _hx_local_10.length
        _g = 0
        _g1 = self.ncomp
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.comps[i]
            flag = (self.bytes.b[self.pos] != c.cid)
            flag1 = (((self.bytes.b[(self.pos + 1)] & 236)) != 0)
            c.dctabsel = ((self.bytes.b[(self.pos + 1)] >> 4) << 1)
            c.actabsel = ((((self.bytes.b[(self.pos + 1)] & 3)) << 1) | 1)
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + 2)
            _hx_local_12.pos
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.size
            _hx_local_14.size = (_hx_local_15 - 2)
            _hx_local_14.size
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.length
            _hx_local_16.length = (_hx_local_17 - 2)
            _hx_local_16.length
        start = self.bytes.b[self.pos]
        count = self.bytes.b[(self.pos + 1)]
        other = self.bytes.b[(self.pos + 2)]
        if ((((not self.progressive) and ((start != 0))) or ((count != ((63 - start))))) or ((other != 0))):
            self.notSupported()
        count = self.length
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18.pos
        _hx_local_18.pos = (_hx_local_19 + count)
        _hx_local_18.pos
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20.size
        _hx_local_20.size = (_hx_local_21 - count)
        _hx_local_20.size
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22.length
        _hx_local_22.length = (_hx_local_23 - count)
        _hx_local_22.length
        mbx = 0
        mby = 0
        rstcount = self.rstinterval
        nextrst = 0
        while True:
            _g = 0
            _g1 = self.ncomp
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                c = self.comps[i]
                _g2 = 0
                _g3 = c.ssy
                while (_g2 < _g3):
                    sby = _g2
                    _g2 = (_g2 + 1)
                    _g4 = 0
                    _g5 = c.ssx
                    while (_g4 < _g5):
                        sbx = _g4
                        _g4 = (_g4 + 1)
                        self.njDecodeBlock(c,(((((((mby * c.ssy) + sby)) * c.stride) + ((mbx * c.ssx))) + sbx) << 3))
            mbx = (mbx + 1)
            tmp = mbx
            if (tmp >= self.mbwidth):
                mbx = 0
                mby = (mby + 1)
                tmp1 = mby
                if (tmp1 >= self.mbheight):
                    break
            tmp2 = None
            if (self.rstinterval != 0):
                rstcount = (rstcount - 1)
                tmp3 = rstcount
                tmp2 = (tmp3 == 0)
            else:
                tmp2 = False
            if tmp2:
                _hx_local_24 = self
                _hx_local_25 = _hx_local_24.bufbits
                _hx_local_24.bufbits = (_hx_local_25 & 248)
                _hx_local_24.bufbits
                r = self.njShowBits(16)
                _hx_local_26 = self
                _hx_local_27 = _hx_local_26.bufbits
                _hx_local_26.bufbits = (_hx_local_27 - 16)
                _hx_local_26.bufbits
                i1 = r
                nextrst = ((nextrst + 1) & 7)
                rstcount = self.rstinterval
                self.comps[0].dcpred = 0
                self.comps[1].dcpred = 0
                self.comps[2].dcpred = 0

    def njUpsampleH(self,c):
        xmax = (c.width - 3)
        cout = haxe_io_Bytes.alloc(((c.width * c.height) << 1))
        this1 = cout
        lout = this1
        this1 = c.pixels
        lin = this1
        pi = 0
        po = 0
        _g = 0
        _g1 = c.height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            x = ((((139 * lin.b[pi]) + ((-11 * lin.b[(pi + 1)]))) + 64) >> 7)
            lout.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            x1 = (((((104 * lin.b[pi]) + ((27 * lin.b[(pi + 1)]))) + ((-3 * lin.b[(pi + 2)]))) + 64) >> 7)
            lout.b[(po + 1)] = (((0 if ((x1 < 0)) else (255 if ((x1 > 255)) else x1))) & 255)
            x2 = (((((28 * lin.b[pi]) + ((109 * lin.b[(pi + 1)]))) + ((-9 * lin.b[(pi + 2)]))) + 64) >> 7)
            lout.b[(po + 2)] = (((0 if ((x2 < 0)) else (255 if ((x2 > 255)) else x2))) & 255)
            _g2 = 0
            _g3 = xmax
            while (_g2 < _g3):
                x3 = _g2
                _g2 = (_g2 + 1)
                x4 = ((((((-9 * lin.b[(pi + x3)]) + ((111 * lin.b[((pi + x3) + 1)]))) + ((29 * lin.b[((pi + x3) + 2)]))) + ((-3 * lin.b[((pi + x3) + 3)]))) + 64) >> 7)
                lout.b[((po + ((x3 << 1))) + 3)] = (((0 if ((x4 < 0)) else (255 if ((x4 > 255)) else x4))) & 255)
                x5 = ((((((-3 * lin.b[(pi + x3)]) + ((29 * lin.b[((pi + x3) + 1)]))) + ((111 * lin.b[((pi + x3) + 2)]))) + ((-9 * lin.b[((pi + x3) + 3)]))) + 64) >> 7)
                lout.b[((po + ((x3 << 1))) + 4)] = (((0 if ((x5 < 0)) else (255 if ((x5 > 255)) else x5))) & 255)
            pi = (pi + c.stride)
            po = (po + ((c.width << 1)))
            x6 = (((((28 * lin.b[(pi - 1)]) + ((109 * lin.b[(pi - 2)]))) + ((-9 * lin.b[(pi - 3)]))) + 64) >> 7)
            lout.b[(po - 3)] = (((0 if ((x6 < 0)) else (255 if ((x6 > 255)) else x6))) & 255)
            x7 = (((((104 * lin.b[(pi - 1)]) + ((27 * lin.b[(pi - 2)]))) + ((-3 * lin.b[(pi - 3)]))) + 64) >> 7)
            lout.b[(po - 2)] = (((0 if ((x7 < 0)) else (255 if ((x7 > 255)) else x7))) & 255)
            x8 = ((((139 * lin.b[(pi - 1)]) + ((-11 * lin.b[(pi - 2)]))) + 64) >> 7)
            lout.b[(po - 1)] = (((0 if ((x8 < 0)) else (255 if ((x8 > 255)) else x8))) & 255)
        c.width = (c.width << 1)
        c.stride = c.width
        c.pixels = cout

    def njUpsampleV(self,c):
        w = c.width
        s1 = c.stride
        s2 = (s1 + s1)
        out = haxe_io_Bytes.alloc(((c.width * c.height) << 1))
        pi = 0
        po = 0
        this1 = out
        cout = this1
        this1 = c.pixels
        cin = this1
        _g = 0
        _g1 = w
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            po = x
            pi = po
            x1 = ((((139 * cin.b[pi]) + ((-11 * cin.b[(pi + s1)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x1 < 0)) else (255 if ((x1 > 255)) else x1))) & 255)
            po = (po + w)
            x2 = (((((104 * cin.b[pi]) + ((27 * cin.b[(pi + s1)]))) + ((-3 * cin.b[(pi + s2)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x2 < 0)) else (255 if ((x2 > 255)) else x2))) & 255)
            po = (po + w)
            x3 = (((((28 * cin.b[pi]) + ((109 * cin.b[(pi + s1)]))) + ((-9 * cin.b[(pi + s2)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x3 < 0)) else (255 if ((x3 > 255)) else x3))) & 255)
            po = (po + w)
            pi = (pi + s1)
            _g2 = 0
            _g3 = (c.height - 2)
            while (_g2 < _g3):
                y = _g2
                _g2 = (_g2 + 1)
                x4 = ((((((-9 * cin.b[(pi - s1)]) + ((111 * cin.b[pi]))) + ((29 * cin.b[(pi + s1)]))) + ((-3 * cin.b[(pi + s2)]))) + 64) >> 7)
                cout.b[po] = (((0 if ((x4 < 0)) else (255 if ((x4 > 255)) else x4))) & 255)
                po = (po + w)
                x5 = ((((((-3 * cin.b[(pi - s1)]) + ((29 * cin.b[pi]))) + ((111 * cin.b[(pi + s1)]))) + ((-9 * cin.b[(pi + s2)]))) + 64) >> 7)
                cout.b[po] = (((0 if ((x5 < 0)) else (255 if ((x5 > 255)) else x5))) & 255)
                po = (po + w)
                pi = (pi + s1)
            pi = (pi + s1)
            x6 = (((((28 * cin.b[pi]) + ((109 * cin.b[(pi - s1)]))) + ((-9 * cin.b[(pi - s2)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x6 < 0)) else (255 if ((x6 > 255)) else x6))) & 255)
            po = (po + w)
            x7 = (((((104 * cin.b[pi]) + ((27 * cin.b[(pi - s1)]))) + ((-3 * cin.b[(pi - s2)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x7 < 0)) else (255 if ((x7 > 255)) else x7))) & 255)
            po = (po + w)
            x8 = ((((139 * cin.b[pi]) + ((-11 * cin.b[(pi - s1)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x8 < 0)) else (255 if ((x8 > 255)) else x8))) & 255)
        c.height = (c.height << 1)
        c.stride = c.width
        c.pixels = out

    def njUpsample(self,c):
        xshift = 0
        yshift = 0
        while (c.width < self.width):
            c.width = (c.width << 1)
            xshift = (xshift + 1)
        while (c.height < self.height):
            c.height = (c.height << 1)
            yshift = (yshift + 1)
        out = haxe_io_Bytes.alloc((c.width * c.height))
        this1 = c.pixels
        lin = this1
        pout = 0
        this1 = out
        lout = this1
        _g = 0
        _g1 = c.height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pin = (((y >> yshift)) * c.stride)
            _g2 = 0
            _g3 = c.width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                pos = pout
                pout = (pout + 1)
                v = lin.b[(((x >> xshift)) + pin)]
                lout.b[pos] = (v & 255)
        c.stride = c.width
        c.pixels = out

    def njConvert(self):
        _g = 0
        _g1 = self.ncomp
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.comps[i]
            tmp = self.filter.index
            if (tmp == 0):
                if ((c.width < self.width) or ((c.height < self.height))):
                    self.njUpsample(c)
            elif (tmp == 1):
                while ((c.width < self.width) or ((c.height < self.height))):
                    if (c.width < self.width):
                        self.njUpsampleH(c)
                    if (c.height < self.height):
                        self.njUpsampleV(c)
            else:
                pass
            if ((c.width < self.width) or ((c.height < self.height))):
                raise haxe_Exception.thrown("assert")
        pixels = haxe_io_Bytes.alloc(((self.width * self.height) * 4))
        if (self.ncomp == 3):
            this1 = self.comps[0].pixels
            py = this1
            this1 = self.comps[1].pixels
            pcb = this1
            this1 = self.comps[2].pixels
            pcr = this1
            this1 = pixels
            pix = this1
            k1 = 0
            k2 = 0
            k3 = 0
            out = 0
            _g = 0
            _g1 = self.height
            while (_g < _g1):
                yy = _g
                _g = (_g + 1)
                _g2 = 0
                _g3 = self.width
                while (_g2 < _g3):
                    x = _g2
                    _g2 = (_g2 + 1)
                    i = k1
                    k1 = (k1 + 1)
                    y = (py.b[i] << 8)
                    i1 = k2
                    k2 = (k2 + 1)
                    cb = (pcb.b[i1] - 128)
                    i2 = k3
                    k3 = (k3 + 1)
                    cr = (pcr.b[i2] - 128)
                    x1 = (((y + ((359 * cr))) + 128) >> 8)
                    r = (0 if ((x1 < 0)) else (255 if ((x1 > 255)) else x1))
                    x2 = ((((y - ((88 * cb))) - ((183 * cr))) + 128) >> 8)
                    g = (0 if ((x2 < 0)) else (255 if ((x2 > 255)) else x2))
                    x3 = (((y + ((454 * cb))) + 128) >> 8)
                    b = (0 if ((x3 < 0)) else (255 if ((x3 > 255)) else x3))
                    out1 = out
                    out = (out + 1)
                    pix.b[out1] = (b & 255)
                    out2 = out
                    out = (out + 1)
                    pix.b[out2] = (g & 255)
                    out3 = out
                    out = (out + 1)
                    pix.b[out3] = (r & 255)
                    out4 = out
                    out = (out + 1)
                    pix.b[out4] = 255
                k1 = (k1 + ((self.comps[0].stride - self.width)))
                k2 = (k2 + ((self.comps[1].stride - self.width)))
                k3 = (k3 + ((self.comps[2].stride - self.width)))
        else:
            raise haxe_Exception.thrown("TODO")
        return pixels

    def njDecode(self):
        if (((self.size < 2) or ((self.bytes.b[self.pos] != 255))) or ((self.bytes.b[(self.pos + 1)] != 216))):
            raise haxe_Exception.thrown("This file is not a JPEG")
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        while True:
            flag = ((self.size < 2) or ((self.bytes.b[self.pos] != 255)))
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 2)
            _hx_local_6.pos
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.size
            _hx_local_8.size = (_hx_local_9 - 2)
            _hx_local_8.size
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.length
            _hx_local_10.length = (_hx_local_11 - 2)
            _hx_local_10.length
            _g = self.bytes.b[(self.pos + (-1))]
            if (_g == 192):
                self.njDecodeSOF()
            elif (_g == 194):
                self.progressive = True
                if self.progressive:
                    raise haxe_Exception.thrown("Unsupported progressive JPG")
                if (self.vlctab[4] is None):
                    this1 = self.vlctab
                    val = haxe_io_Bytes.alloc(131072)
                    this1[4] = val
                if (self.vlctab[5] is None):
                    this2 = self.vlctab
                    val1 = haxe_io_Bytes.alloc(131072)
                    this2[5] = val1
                if (self.vlctab[6] is None):
                    this3 = self.vlctab
                    val2 = haxe_io_Bytes.alloc(131072)
                    this3[6] = val2
                if (self.vlctab[7] is None):
                    this4 = self.vlctab
                    val3 = haxe_io_Bytes.alloc(131072)
                    this4[7] = val3
                self.njDecodeSOF()
            elif (_g == 195):
                raise haxe_Exception.thrown("Unsupported lossless JPG")
            elif (_g == 196):
                self.njDecodeDHT()
            elif (_g == 218):
                self.njDecodeScan()
                break
            elif (_g == 219):
                self.njDecodeDQT()
            elif (_g == 221):
                self.njDecodeDRI()
            elif (_g == 254):
                self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
                _hx_local_12 = self
                _hx_local_13 = _hx_local_12.pos
                _hx_local_12.pos = (_hx_local_13 + 2)
                _hx_local_12.pos
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.size
                _hx_local_14.size = (_hx_local_15 - 2)
                _hx_local_14.size
                _hx_local_16 = self
                _hx_local_17 = _hx_local_16.length
                _hx_local_16.length = (_hx_local_17 - 2)
                _hx_local_16.length
                count = self.length
                _hx_local_18 = self
                _hx_local_19 = _hx_local_18.pos
                _hx_local_18.pos = (_hx_local_19 + count)
                _hx_local_18.pos
                _hx_local_20 = self
                _hx_local_21 = _hx_local_20.size
                _hx_local_20.size = (_hx_local_21 - count)
                _hx_local_20.size
                _hx_local_22 = self
                _hx_local_23 = _hx_local_22.length
                _hx_local_22.length = (_hx_local_23 - count)
                _hx_local_22.length
            else:
                _g1 = (self.bytes.b[(self.pos + (-1))] & 240)
                if (_g1 == 192):
                    raise haxe_Exception.thrown(("Unsupported jpeg type " + Std.string(((self.bytes.b[(self.pos + (-1))] & 15)))))
                elif (_g1 == 224):
                    self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
                    _hx_local_24 = self
                    _hx_local_25 = _hx_local_24.pos
                    _hx_local_24.pos = (_hx_local_25 + 2)
                    _hx_local_24.pos
                    _hx_local_26 = self
                    _hx_local_27 = _hx_local_26.size
                    _hx_local_26.size = (_hx_local_27 - 2)
                    _hx_local_26.size
                    _hx_local_28 = self
                    _hx_local_29 = _hx_local_28.length
                    _hx_local_28.length = (_hx_local_29 - 2)
                    _hx_local_28.length
                    count1 = self.length
                    _hx_local_30 = self
                    _hx_local_31 = _hx_local_30.pos
                    _hx_local_30.pos = (_hx_local_31 + count1)
                    _hx_local_30.pos
                    _hx_local_32 = self
                    _hx_local_33 = _hx_local_32.size
                    _hx_local_32.size = (_hx_local_33 - count1)
                    _hx_local_32.size
                    _hx_local_34 = self
                    _hx_local_35 = _hx_local_34.length
                    _hx_local_34.length = (_hx_local_35 - count1)
                    _hx_local_34.length
                else:
                    raise haxe_Exception.thrown(("Unsupported jpeg tag 0x" + HxOverrides.stringOrNull(StringTools.hex(self.bytes.b[(self.pos + (-1))],2))))
        pixels = self.njConvert()
        self.cleanup()
        return _hx_AnonObject({'pixels': pixels, 'width': self.width, 'height': self.height})

    @staticmethod
    def CF(x):
        x1 = ((x + 64) >> 7)
        if (x1 < 0):
            return 0
        elif (x1 > 255):
            return 255
        else:
            return x1

    @staticmethod
    def njClip(x):
        if (x < 0):
            return 0
        elif (x > 255):
            return 255
        else:
            return x

    @staticmethod
    def decode(_hx_bytes,_hx_filter = None,position = None,size = None):
        if (position is None):
            position = 0
        if (size is None):
            size = -1
        if (hxd_res_NanoJpeg.inst is None):
            hxd_res_NanoJpeg.inst = hxd_res_NanoJpeg()
        hxd_res_NanoJpeg.inst.njInit(_hx_bytes,position,size,_hx_filter)
        return hxd_res_NanoJpeg.inst.njDecode()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bytes = None
        _hx_o.pos = None
        _hx_o.size = None
        _hx_o.length = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.ncomp = None
        _hx_o.comps = None
        _hx_o.counts = None
        _hx_o.qtab = None
        _hx_o.qtused = None
        _hx_o.qtavail = None
        _hx_o.vlctab = None
        _hx_o.block = None
        _hx_o.njZZ = None
        _hx_o.progressive = None
        _hx_o.mbsizex = None
        _hx_o.mbsizey = None
        _hx_o.mbwidth = None
        _hx_o.mbheight = None
        _hx_o.rstinterval = None
        _hx_o.buf = None
        _hx_o.bufbits = None
        _hx_o.pixels = None
        _hx_o.filter = None
        _hx_o.vlcCode = None
hxd_res_NanoJpeg._hx_class = hxd_res_NanoJpeg
_hx_classes["hxd.res.NanoJpeg"] = hxd_res_NanoJpeg

class hxd_res_SoundFormat(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.res.SoundFormat"
    _hx_constructs = ["Wav", "Mp3", "OggVorbis"]
hxd_res_SoundFormat.Wav = hxd_res_SoundFormat("Wav", 0, ())
hxd_res_SoundFormat.Mp3 = hxd_res_SoundFormat("Mp3", 1, ())
hxd_res_SoundFormat.OggVorbis = hxd_res_SoundFormat("OggVorbis", 2, ())
hxd_res_SoundFormat._hx_class = hxd_res_SoundFormat
_hx_classes["hxd.res.SoundFormat"] = hxd_res_SoundFormat


class hxd_res_Sound(hxd_res_Resource):
    _hx_class_name = "hxd.res.Sound"
    _hx_is_interface = "False"
    __slots__ = ("data", "channel", "lastPlay")
    _hx_fields = ["data", "channel", "lastPlay"]
    _hx_methods = ["getData", "dispose", "stop", "play", "watchCallb"]
    _hx_statics = ["ENABLE_AUTO_WATCH", "supportedFormat", "startWorker"]
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,entry):
        self.channel = None
        self.data = None
        self.lastPlay = 0.
        super().__init__(entry)

    def getData(self):
        if (self.data is not None):
            return self.data
        _hx_bytes = self.entry.getBytes()
        _g = _hx_bytes.b[0]
        if ((_g == 255) or ((_g == 73))):
            self.data = hxd_snd_Mp3Data(_hx_bytes)
        elif (_g == 79):
            raise haxe_Exception.thrown((("OGG format requires -lib stb_ogg_sound (for " + HxOverrides.stringOrNull(self.entry.get_path())) + ")"))
        elif (_g == 82):
            self.data = hxd_snd_WavData(_hx_bytes)
        else:
            pass
        if (self.data is None):
            raise haxe_Exception.thrown(("Unsupported sound format " + HxOverrides.stringOrNull(self.entry.get_path())))
        if hxd_res_Sound.ENABLE_AUTO_WATCH:
            self.watch(self.watchCallb)
        return self.data

    def dispose(self):
        self.stop()
        self.data = None

    def stop(self):
        if (self.channel is not None):
            self.channel.stop()
            self.channel = None

    def play(self,loop = None,volume = None,channelGroup = None,soundGroup = None):
        if (loop is None):
            loop = False
        if (volume is None):
            volume = 1.
        self.lastPlay = python_lib_Timeit.default_timer()
        self.channel = hxd_snd_Manager.get().play(self,channelGroup,soundGroup)
        self.channel.loop = loop
        self.channel.set_volume(volume)
        return self.channel

    def watchCallb(self):
        old = self.data
        self.data = None
        data = self.getData()
        if (old is not None):
            if ((((old.channels != data.channels) or ((old.samples != data.samples))) or ((old.sampleFormat != data.sampleFormat))) or ((old.samplingRate != data.samplingRate))):
                manager = hxd_snd_Manager.get()
                ch = manager.getAll(self)
                while ch.hasNext():
                    ch1 = ch.next()
                    ch1.duration = data.get_duration()
                    ch1.set_position(ch1.position)

    @staticmethod
    def supportedFormat(fmt):
        tmp = fmt.index
        if ((tmp == 1) or ((tmp == 0))):
            return True
        elif (tmp == 2):
            return False
        else:
            pass

    @staticmethod
    def startWorker():
        return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
        _hx_o.channel = None
        _hx_o.lastPlay = None
hxd_res_Sound._hx_class = hxd_res_Sound
_hx_classes["hxd.res.Sound"] = hxd_res_Sound


class hxd_snd_ChannelBase:
    _hx_class_name = "hxd.snd.ChannelBase"
    _hx_is_interface = "False"
    __slots__ = ("priority", "mute", "effects", "bindedEffects", "volume", "currentFade", "currentVolume")
    _hx_fields = ["priority", "mute", "effects", "bindedEffects", "volume", "currentFade", "currentVolume"]
    _hx_methods = ["getEffect", "set_volume", "fadeTo", "updateCurrentVolume", "addEffect", "removeEffect"]

    def __init__(self):
        self.currentVolume = None
        self.currentFade = None
        self.volume = 1.
        self.bindedEffects = []
        self.effects = []
        self.mute = False
        self.priority = 0.

    def getEffect(self,etype):
        if (self.effects is None):
            return None
        _g = 0
        _g1 = self.effects
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            e1 = Std.downcast(e,etype)
            if (e1 is not None):
                return e1
        return None

    def set_volume(self,v):
        self.currentFade = None
        def _hx_local_1():
            def _hx_local_0():
                self.volume = v
                return self.volume
            return _hx_local_0()
        return _hx_local_1()

    def fadeTo(self,volume,time = None,onEnd = None):
        if (time is None):
            time = 1.
        self.currentFade = _hx_AnonObject({'start': python_lib_Timeit.default_timer(), 'duration': time, 'startVolume': self.volume, 'targetVolume': volume, 'onEnd': onEnd})

    def updateCurrentVolume(self,now):
        if (self.currentFade is not None):
            f = self.currentFade
            dt = (now - f.start)
            if (dt >= f.duration):
                self.set_volume(f.targetVolume)
                if (f.onEnd is not None):
                    f.onEnd()
            else:
                self.set_volume((f.startVolume + (((dt / f.duration) * ((f.targetVolume - f.startVolume))))))
                self.currentFade = f
        self.currentVolume = self.volume

    def addEffect(self,e):
        if (e is None):
            raise haxe_Exception.thrown("Can't add null effect")
        if (python_internal_ArrayImpl.indexOf(self.effects,e,None) >= 0):
            raise haxe_Exception.thrown("effect already added on this channel")
        _this = self.effects
        _this.append(e)
        return e

    def removeEffect(self,e):
        python_internal_ArrayImpl.remove(self.effects,e)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.priority = None
        _hx_o.mute = None
        _hx_o.effects = None
        _hx_o.bindedEffects = None
        _hx_o.volume = None
        _hx_o.currentFade = None
        _hx_o.currentVolume = None
hxd_snd_ChannelBase._hx_class = hxd_snd_ChannelBase
_hx_classes["hxd.snd.ChannelBase"] = hxd_snd_ChannelBase


class hxd_snd_Channel(hxd_snd_ChannelBase):
    _hx_class_name = "hxd.snd.Channel"
    _hx_is_interface = "False"
    _hx_fields = ["next", "manager", "source", "id", "sound", "duration", "soundGroup", "channelGroup", "position", "pause", "loop", "allowVirtual", "audibleVolume", "lastStamp", "isVirtual", "isLoading", "positionChanged", "queue"]
    _hx_methods = ["onEnd", "set_position", "set_pause", "updateCurrentVolume", "calcAudibleVolume", "queueSound", "stop", "isReleased"]
    _hx_statics = ["ID"]
    _hx_interfaces = []
    _hx_super = hxd_snd_ChannelBase


    def __init__(self):
        self.channelGroup = None
        self.soundGroup = None
        self.duration = None
        self.sound = None
        self.id = None
        self.source = None
        self.manager = None
        self.next = None
        self.queue = []
        self.positionChanged = False
        self.isLoading = False
        self.isVirtual = False
        self.lastStamp = 0.0
        self.audibleVolume = 1.0
        self.allowVirtual = True
        self.loop = False
        self.pause = False
        self.position = 0.0
        super().__init__()
        def _hx_local_2():
            _hx_local_0 = hxd_snd_Channel
            _hx_local_1 = _hx_local_0.ID
            _hx_local_0.ID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()

    def onEnd(self):
        pass

    def set_position(self,v):
        self.lastStamp = python_lib_Timeit.default_timer()
        self.positionChanged = True
        if (v > self.duration):
            v = self.duration
        elif (v < 0):
            v = 0
        def _hx_local_1():
            def _hx_local_0():
                self.position = v
                return self.position
            return _hx_local_0()
        return _hx_local_1()

    def set_pause(self,v):
        if (not v):
            self.lastStamp = python_lib_Timeit.default_timer()
        def _hx_local_1():
            def _hx_local_0():
                self.pause = v
                return self.pause
            return _hx_local_0()
        return _hx_local_1()

    def updateCurrentVolume(self,now):
        if (self.pause and ((self.currentFade is not None))):
            f = self.currentFade
            self.currentFade = None
            self.updateCurrentVolume(now)
            self.currentFade = f
        super().updateCurrentVolume(now)
        self.channelGroup.updateCurrentVolume(now)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.currentVolume
        _hx_local_0.currentVolume = (_hx_local_1 * ((self.channelGroup.currentVolume * self.soundGroup.volume)))
        _hx_local_0.currentVolume
        if (self.manager is not None):
            _g = 0
            _g1 = self.channelGroup.effects
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.currentVolume
                _hx_local_3.currentVolume = (_hx_local_4 * e.getVolumeModifier())
                _hx_local_3.currentVolume
            _g = 0
            _g1 = self.effects
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.currentVolume
                _hx_local_6.currentVolume = (_hx_local_7 * e.getVolumeModifier())
                _hx_local_6.currentVolume

    def calcAudibleVolume(self,now):
        self.updateCurrentVolume(now)
        self.audibleVolume = self.currentVolume
        if (self.manager is not None):
            _g = 0
            _g1 = self.channelGroup.effects
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.audibleVolume = e.applyAudibleVolumeModifier(self.audibleVolume)
            _g = 0
            _g1 = self.effects
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.audibleVolume = e.applyAudibleVolumeModifier(self.audibleVolume)

    def queueSound(self,sound):
        _this = self.queue
        _this.append(sound)

    def stop(self):
        if (self.manager is not None):
            self.manager.releaseChannel(self)

    def isReleased(self):
        return (self.manager is None)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.manager = None
        _hx_o.source = None
        _hx_o.id = None
        _hx_o.sound = None
        _hx_o.duration = None
        _hx_o.soundGroup = None
        _hx_o.channelGroup = None
        _hx_o.position = None
        _hx_o.pause = None
        _hx_o.loop = None
        _hx_o.allowVirtual = None
        _hx_o.audibleVolume = None
        _hx_o.lastStamp = None
        _hx_o.isVirtual = None
        _hx_o.isLoading = None
        _hx_o.positionChanged = None
        _hx_o.queue = None
hxd_snd_Channel._hx_class = hxd_snd_Channel
_hx_classes["hxd.snd.Channel"] = hxd_snd_Channel


class hxd_snd_ChannelGroup(hxd_snd_ChannelBase):
    _hx_class_name = "hxd.snd.ChannelGroup"
    _hx_is_interface = "False"
    __slots__ = ("name",)
    _hx_fields = ["name"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_snd_ChannelBase


    def __init__(self,name):
        self.name = None
        super().__init__()
        self.name = name

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
hxd_snd_ChannelGroup._hx_class = hxd_snd_ChannelGroup
_hx_classes["hxd.snd.ChannelGroup"] = hxd_snd_ChannelGroup

class hxd_snd_SampleFormat(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.snd.SampleFormat"
    _hx_constructs = ["UI8", "I16", "F32"]
hxd_snd_SampleFormat.UI8 = hxd_snd_SampleFormat("UI8", 0, ())
hxd_snd_SampleFormat.I16 = hxd_snd_SampleFormat("I16", 1, ())
hxd_snd_SampleFormat.F32 = hxd_snd_SampleFormat("F32", 2, ())
hxd_snd_SampleFormat._hx_class = hxd_snd_SampleFormat
_hx_classes["hxd.snd.SampleFormat"] = hxd_snd_SampleFormat


class hxd_snd_Data:
    _hx_class_name = "hxd.snd.Data"
    _hx_is_interface = "False"
    __slots__ = ("samples", "samplingRate", "sampleFormat", "channels")
    _hx_fields = ["samples", "samplingRate", "sampleFormat", "channels"]
    _hx_methods = ["isLoading", "decode", "resample", "resampleBuffer", "decodeBuffer", "getBytesPerSample", "load", "get_duration"]
    _hx_statics = ["formatBytes"]

    def isLoading(self):
        return False

    def decode(self,out,outPos,sampleStart,sampleCount):
        bpp = self.getBytesPerSample()
        if ((((sampleStart < 0) or ((sampleCount < 0))) or ((outPos < 0))) or (((outPos + ((sampleCount * bpp))) > out.length))):
            s = ("sampleStart = " + Std.string(sampleStart))
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" sampleCount = " + Std.string(sampleCount)))))
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" outPos = " + Std.string(outPos)))))
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" bpp = " + Std.string(bpp)))))
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" out.length = " + Std.string(out.length)))))
            raise haxe_Exception.thrown(s)
        if ((sampleStart + sampleCount) >= self.samples):
            count = 0
            if (sampleStart < self.samples):
                count = (self.samples - sampleStart)
                self.decodeBuffer(out,outPos,sampleStart,count)
            out.fill((outPos + ((count * bpp))),(((sampleCount - count)) * bpp),0)
            return
        self.decodeBuffer(out,outPos,sampleStart,sampleCount)

    def resample(self,rate,format,channels):
        if (((self.sampleFormat == format) and ((self.samplingRate == rate))) and ((self.channels == channels))):
            return self
        newSamples = Math.ceil((self.samples * ((rate / self.samplingRate))))
        bpp = self.getBytesPerSample()
        data = haxe_io_Bytes.alloc((bpp * self.samples))
        self.decodeBuffer(data,0,0,self.samples)
        out = (channels * newSamples)
        out1 = None
        out2 = format.index
        if (out2 == 0):
            out1 = 1
        elif (out2 == 1):
            out1 = 2
        elif (out2 == 2):
            out1 = 4
        else:
            pass
        out2 = haxe_io_Bytes.alloc((out * out1))
        self.resampleBuffer(out2,0,data,0,rate,format,channels,self.samples)
        data = hxd_snd_WavData(None)
        data.channels = channels
        data.samples = newSamples
        data.sampleFormat = format
        data.samplingRate = rate
        data.rawData = out2
        return data

    def resampleBuffer(self,out,outPos,input,inPos,rate,format,channels,samples):
        bpp = self.getBytesPerSample()
        newSamples = Math.ceil((samples * ((rate / self.samplingRate))))
        resample = (samples != newSamples)
        if (((((not resample) and ((self.sampleFormat == hxd_snd_SampleFormat.I16))) and ((format == hxd_snd_SampleFormat.I16))) and ((channels == 1))) and ((self.channels == 2))):
            r = inPos
            w = outPos
            _g = 0
            _g1 = samples
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                sl = (input.b[r] | ((input.b[(r + 1)] << 8)))
                r = (r + 2)
                sr = (input.b[r] | ((input.b[(r + 1)] << 8)))
                r = (r + 2)
                s = None
                if (((sl ^ sr)) >= 32768):
                    if (((sl & 32768)) != 0):
                        sl = (sl | -65536)
                    if (((sr & 32768)) != 0):
                        sr = (sr | -65536)
                    s = (((sl + sr) >> 1) & 65535)
                else:
                    s = ((sl + sr) >> 1)
                out.b[w] = (s & 255)
                out.b[(w + 1)] = ((s >> 8) & 255)
                w = (w + 2)
            return
        srcChannels = self.channels
        commonChannels = (channels if ((channels < srcChannels)) else srcChannels)
        extraChannels = (channels - commonChannels)
        sval = 0.
        ival = 0
        _g = 0
        _g1 = newSamples
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            targetSample = ((i / ((newSamples - 1))) * ((samples - 1)))
            isample = None
            try:
                isample = int(targetSample)
            except BaseException as _g2:
                None
                isample = None
            isample1 = isample
            offset = (targetSample - isample1)
            srcPos = (inPos + ((isample1 * bpp)))
            if (isample1 == ((samples - 1))):
                resample = False
            _g3 = 0
            _g4 = commonChannels
            while (_g3 < _g4):
                k = _g3
                _g3 = (_g3 + 1)
                sval1 = None
                sval2 = 0.
                tmp = self.sampleFormat.index
                if (tmp == 0):
                    sval1 = (input.b[srcPos] / 255)
                    if resample:
                        sval2 = (input.b[(srcPos + bpp)] / 255)
                    srcPos = (srcPos + 1)
                elif (tmp == 1):
                    v = (input.b[srcPos] | ((input.b[(srcPos + 1)] << 8)))
                    sval1 = (((v if ((((v & 32768)) == 0)) else (v | -65536))) / 32768)
                    if resample:
                        pos = (srcPos + bpp)
                        v1 = (input.b[pos] | ((input.b[(pos + 1)] << 8)))
                        sval2 = (((v1 if ((((v1 & 32768)) == 0)) else (v1 | -65536))) / 32768)
                    srcPos = (srcPos + 2)
                elif (tmp == 2):
                    sval1 = input.getFloat(srcPos)
                    if resample:
                        sval2 = input.getFloat((srcPos + bpp))
                    srcPos = (srcPos + 4)
                else:
                    pass
                sval = ((sval1 + ((offset * ((sval2 - sval1))))) if resample else sval1)
                tmp1 = format.index
                if (tmp1 == 0):
                    ival1 = None
                    try:
                        ival1 = int((((sval + 1)) * 128))
                    except BaseException as _g5:
                        None
                        ival1 = None
                    ival = ival1
                    if (ival > 255):
                        ival = 255
                    pos1 = outPos
                    outPos = (outPos + 1)
                    out.b[pos1] = (ival & 255)
                elif (tmp1 == 1):
                    ival2 = None
                    try:
                        ival2 = int((sval * 32768))
                    except BaseException as _g6:
                        None
                        ival2 = None
                    ival = ival2
                    if (ival > 32767):
                        ival = 32767
                    ival = (ival & 65535)
                    out.b[outPos] = (ival & 255)
                    out.b[(outPos + 1)] = ((ival >> 8) & 255)
                    outPos = (outPos + 2)
                elif (tmp1 == 2):
                    out.setFloat(outPos,sval)
                    outPos = (outPos + 4)
                else:
                    pass
            _g7 = 0
            _g8 = extraChannels
            while (_g7 < _g8):
                i1 = _g7
                _g7 = (_g7 + 1)
                tmp2 = format.index
                if (tmp2 == 0):
                    pos2 = outPos
                    outPos = (outPos + 1)
                    out.b[pos2] = (ival & 255)
                elif (tmp2 == 1):
                    out.b[outPos] = (ival & 255)
                    out.b[(outPos + 1)] = ((ival >> 8) & 255)
                    outPos = (outPos + 2)
                elif (tmp2 == 2):
                    out.setFloat(outPos,sval)
                    outPos = (outPos + 4)
                else:
                    pass

    def decodeBuffer(self,out,outPos,sampleStart,sampleCount):
        raise haxe_Exception.thrown("Not implemented")

    def getBytesPerSample(self):
        tmp = None
        tmp1 = self.sampleFormat.index
        if (tmp1 == 0):
            tmp = 1
        elif (tmp1 == 1):
            tmp = 2
        elif (tmp1 == 2):
            tmp = 4
        else:
            pass
        return (self.channels * tmp)

    def load(self,onEnd):
        onEnd()

    def get_duration(self):
        return (self.samples / self.samplingRate)

    @staticmethod
    def formatBytes(format):
        tmp = format.index
        if (tmp == 0):
            return 1
        elif (tmp == 1):
            return 2
        elif (tmp == 2):
            return 4
        else:
            pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.samples = None
        _hx_o.samplingRate = None
        _hx_o.sampleFormat = None
        _hx_o.channels = None
hxd_snd_Data._hx_class = hxd_snd_Data
_hx_classes["hxd.snd.Data"] = hxd_snd_Data


class hxd_snd_EffectDriver:
    _hx_class_name = "hxd.snd.EffectDriver"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["acquire", "release", "update", "bind", "apply", "unbind"]

    def __init__(self):
        pass

    def acquire(self):
        pass

    def release(self):
        pass

    def update(self,e):
        pass

    def bind(self,e,source):
        pass

    def apply(self,e,source):
        pass

    def unbind(self,e,source):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_snd_EffectDriver._hx_class = hxd_snd_EffectDriver
_hx_classes["hxd.snd.EffectDriver"] = hxd_snd_EffectDriver

class hxd_snd_DriverFeature(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.snd.DriverFeature"
    _hx_constructs = ["MasterVolume"]
hxd_snd_DriverFeature.MasterVolume = hxd_snd_DriverFeature("MasterVolume", 0, ())
hxd_snd_DriverFeature._hx_class = hxd_snd_DriverFeature
_hx_classes["hxd.snd.DriverFeature"] = hxd_snd_DriverFeature


class hxd_snd_Driver:
    _hx_class_name = "hxd.snd.Driver"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["hasFeature", "setMasterVolume", "setListenerParams", "createSource", "playSource", "stopSource", "setSourceVolume", "destroySource", "createBuffer", "setBufferData", "destroyBuffer", "queueBuffer", "unqueueBuffer", "getProcessedBuffers", "getPlayedSampleCount", "update", "dispose", "getEffectDriver"]
hxd_snd_Driver._hx_class = hxd_snd_Driver
_hx_classes["hxd.snd.Driver"] = hxd_snd_Driver


class hxd_snd_Effect:
    _hx_class_name = "hxd.snd.Effect"
    _hx_is_interface = "False"
    __slots__ = ("next", "refs", "retainTime", "lastStamp", "driver", "priority")
    _hx_fields = ["next", "refs", "retainTime", "lastStamp", "driver", "priority"]
    _hx_methods = ["applyAudibleVolumeModifier", "getVolumeModifier"]

    def __init__(self,_hx_type):
        self.driver = None
        self.next = None
        self.refs = 0
        self.priority = 0
        self.retainTime = 0.0
        self.lastStamp = 0.0
        managerDriver = hxd_snd_Manager.get().driver
        if (managerDriver is not None):
            self.driver = managerDriver.getEffectDriver(_hx_type)

    def applyAudibleVolumeModifier(self,v):
        return v

    def getVolumeModifier(self):
        return 1

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.refs = None
        _hx_o.retainTime = None
        _hx_o.lastStamp = None
        _hx_o.driver = None
        _hx_o.priority = None
hxd_snd_Effect._hx_class = hxd_snd_Effect
_hx_classes["hxd.snd.Effect"] = hxd_snd_Effect


class hxd_snd_Listener:
    _hx_class_name = "hxd.snd.Listener"
    _hx_is_interface = "False"
    __slots__ = ("position", "direction", "velocity", "up")
    _hx_fields = ["position", "direction", "velocity", "up"]
    _hx_methods = ["syncCamera"]

    def __init__(self):
        self.position = h3d_Vector()
        self.velocity = h3d_Vector()
        self.direction = h3d_Vector(1,0,0)
        self.up = h3d_Vector(0,0,1)

    def syncCamera(self,cam):
        _this = self.position
        v = cam.pos
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        _this = self.direction
        x = (cam.target.x - cam.pos.x)
        y = (cam.target.y - cam.pos.y)
        z = (cam.target.z - cam.pos.z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this = self.direction
        k = (((_this.x * _this.x) + ((_this.y * _this.y))) + ((_this.z * _this.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _this.x = (_this.x * k)
        _this.y = (_this.y * k)
        _this.z = (_this.z * k)
        _this = self.up
        v = cam.up
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.position = None
        _hx_o.direction = None
        _hx_o.velocity = None
        _hx_o.up = None
hxd_snd_Listener._hx_class = hxd_snd_Listener
_hx_classes["hxd.snd.Listener"] = hxd_snd_Listener


class hxd_snd_Source:
    _hx_class_name = "hxd.snd.Source"
    _hx_is_interface = "False"
    __slots__ = ("id", "handle", "channel", "buffers", "volume", "playing", "start", "streamSound", "streamBuffer", "streamStart", "streamPos")
    _hx_fields = ["id", "handle", "channel", "buffers", "volume", "playing", "start", "streamSound", "streamBuffer", "streamStart", "streamPos"]
    _hx_methods = ["dispose"]
    _hx_statics = ["ID"]

    def __init__(self,driver):
        self.streamPos = None
        self.streamStart = None
        self.streamBuffer = None
        self.streamSound = None
        self.channel = None
        self.start = 0
        self.playing = False
        self.volume = -1.0
        def _hx_local_2():
            _hx_local_0 = hxd_snd_Source
            _hx_local_1 = _hx_local_0.ID
            _hx_local_0.ID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()
        self.handle = driver.createSource()
        self.buffers = []

    def dispose(self):
        hxd_snd_Manager.get().driver.destroySource(self.handle)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.handle = None
        _hx_o.channel = None
        _hx_o.buffers = None
        _hx_o.volume = None
        _hx_o.playing = None
        _hx_o.start = None
        _hx_o.streamSound = None
        _hx_o.streamBuffer = None
        _hx_o.streamStart = None
        _hx_o.streamPos = None
hxd_snd_Source._hx_class = hxd_snd_Source
_hx_classes["hxd.snd.Source"] = hxd_snd_Source


class hxd_snd_Buffer:
    _hx_class_name = "hxd.snd.Buffer"
    _hx_is_interface = "False"
    __slots__ = ("handle", "sound", "isEnd", "isStream", "refs", "lastStop", "start", "end", "samples", "sampleRate")
    _hx_fields = ["handle", "sound", "isEnd", "isStream", "refs", "lastStop", "start", "end", "samples", "sampleRate"]
    _hx_methods = ["dispose"]

    def __init__(self,driver):
        self.sampleRate = None
        self.samples = None
        self.start = None
        self.isStream = None
        self.isEnd = None
        self.sound = None
        self.end = 0
        self.handle = driver.createBuffer()
        self.refs = 0
        self.lastStop = python_lib_Timeit.default_timer()

    def dispose(self):
        hxd_snd_Manager.get().driver.destroyBuffer(self.handle)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.handle = None
        _hx_o.sound = None
        _hx_o.isEnd = None
        _hx_o.isStream = None
        _hx_o.refs = None
        _hx_o.lastStop = None
        _hx_o.start = None
        _hx_o.end = None
        _hx_o.samples = None
        _hx_o.sampleRate = None
hxd_snd_Buffer._hx_class = hxd_snd_Buffer
_hx_classes["hxd.snd.Buffer"] = hxd_snd_Buffer


class hxd_snd_Manager:
    _hx_class_name = "hxd.snd.Manager"
    _hx_is_interface = "False"
    __slots__ = ("masterVolume", "masterSoundGroup", "masterChannelGroup", "listener", "timeOffset", "updateEvent", "cachedBytes", "resampleBytes", "driver", "channels", "sources", "now", "soundBufferCount", "soundBufferMap", "soundBufferKeys", "freeStreamBuffers", "effectGC", "hasMasterVolume", "suspended", "targetRate", "targetFormat", "targetChannels")
    _hx_fields = ["masterVolume", "masterSoundGroup", "masterChannelGroup", "listener", "timeOffset", "updateEvent", "cachedBytes", "resampleBytes", "driver", "channels", "sources", "now", "soundBufferCount", "soundBufferMap", "soundBufferKeys", "freeStreamBuffers", "effectGC", "hasMasterVolume", "suspended", "targetRate", "targetFormat", "targetChannels"]
    _hx_methods = ["getTmpBytes", "getResampleBytes", "stopAll", "stopAllNotLooping", "stopByName", "getAll", "cleanCache", "dispose", "play", "updateVirtualChannels", "update", "progressiveDecodeBuffer", "queueBuffer", "unqueueBuffer", "bindEffect", "unbindEffect", "releaseSource", "checkTargetFormat", "getSoundBuffer", "fillSoundBuffer", "getStreamBuffer", "sortChannel", "sortEffect", "releaseChannel"]
    _hx_statics = ["STREAM_DURATION", "STREAM_BUFFER_SAMPLE_COUNT", "BUFFER_QUEUE_LENGTH", "MAX_SOURCES", "SOUND_BUFFER_CACHE_SIZE", "VIRTUAL_VOLUME_THRESHOLD", "BUFFER_STREAM_SPLIT", "instance", "get", "regEffect"]

    def __init__(self):
        self.targetChannels = None
        self.targetFormat = None
        self.targetRate = None
        self.hasMasterVolume = None
        self.effectGC = None
        self.freeStreamBuffers = None
        self.soundBufferKeys = None
        self.soundBufferMap = None
        self.soundBufferCount = None
        self.now = None
        self.sources = None
        self.channels = None
        self.resampleBytes = None
        self.cachedBytes = None
        self.updateEvent = None
        self.listener = None
        self.masterChannelGroup = None
        self.masterSoundGroup = None
        self.suspended = False
        self.timeOffset = 0.
        try:
            self.driver = hxd_snd_openal_Driver()
        except BaseException as _g:
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),str):
                self.driver = None
            else:
                raise _g
        self.masterVolume = 1.0
        self.hasMasterVolume = (True if ((self.driver is None)) else self.driver.hasFeature(hxd_snd_DriverFeature.MasterVolume))
        self.masterSoundGroup = hxd_snd_SoundGroup("master")
        self.masterChannelGroup = hxd_snd_ChannelGroup("master")
        self.listener = hxd_snd_Listener()
        self.soundBufferMap = haxe_ds_StringMap()
        self.soundBufferKeys = []
        self.freeStreamBuffers = []
        self.effectGC = []
        self.soundBufferCount = 0
        if (self.driver is not None):
            self.sources = []
            _g = 0
            _g1 = hxd_snd_Manager.MAX_SOURCES
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this = self.sources
                x = hxd_snd_Source(self.driver)
                _this.append(x)
        self.cachedBytes = haxe_io_Bytes.alloc(24)
        self.resampleBytes = haxe_io_Bytes.alloc((hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * 2))

    def getTmpBytes(self,size):
        if (self.cachedBytes.length < size):
            self.cachedBytes = haxe_io_Bytes.alloc(size)
        return self.cachedBytes

    def getResampleBytes(self,size):
        if (self.resampleBytes.length < size):
            self.resampleBytes = haxe_io_Bytes.alloc(size)
        return self.resampleBytes

    def stopAll(self):
        while (self.channels is not None):
            self.channels.stop()

    def stopAllNotLooping(self):
        c = self.channels
        while (c is not None):
            n = c.next
            if (not c.loop):
                c.stop()
            c = n

    def stopByName(self,name):
        c = self.channels
        while (c is not None):
            n = c.next
            if ((c.soundGroup is not None) and ((c.soundGroup.name == name))):
                c.stop()
            c = n

    def getAll(self,sound):
        ch = self.channels
        result = list()
        while (ch is not None):
            if (ch.sound == sound):
                result.append(ch)
            ch = ch.next
        return hxd_impl_ArrayIterator_hxd_snd_Channel(result)

    def cleanCache(self):
        i = 0
        while (i < len(self.soundBufferKeys)):
            k = (self.soundBufferKeys[i] if i >= 0 and i < len(self.soundBufferKeys) else None)
            b = self.soundBufferMap.h.get(k,None)
            i = (i + 1)
            if (b.refs > 0):
                continue
            self.soundBufferMap.remove(k)
            python_internal_ArrayImpl.remove(self.soundBufferKeys,k)
            i = (i - 1)
            b.dispose()
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.soundBufferCount
            _hx_local_2.soundBufferCount = (_hx_local_3 - 1)
            _hx_local_2.soundBufferCount

    def dispose(self):
        self.stopAll()
        if (self.driver is not None):
            _g = 0
            _g1 = self.sources
            while (_g < len(_g1)):
                s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                s.dispose()
            b = self.soundBufferMap.iterator()
            while b.hasNext():
                b1 = b.next()
                b1.dispose()
            _g = 0
            _g1 = self.freeStreamBuffers
            while (_g < len(_g1)):
                b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                b.dispose()
            _g = 0
            _g1 = self.effectGC
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                e.driver.release()
            self.driver.dispose()
        self.sources = None
        self.soundBufferMap = None
        self.soundBufferKeys = None
        self.freeStreamBuffers = None
        self.effectGC = None
        self.updateEvent.stop()
        hxd_snd_Manager.instance = None

    def play(self,sound,channelGroup = None,soundGroup = None):
        if (soundGroup is None):
            soundGroup = self.masterSoundGroup
        if (channelGroup is None):
            channelGroup = self.masterChannelGroup
        sdat = sound.getData()
        if (sdat.samples == 0):
            raise haxe_Exception.thrown((Std.string(sound) + " has no samples"))
        c = hxd_snd_Channel()
        c.sound = sound
        c.duration = sdat.get_duration()
        c.manager = self
        c.soundGroup = soundGroup
        c.channelGroup = channelGroup
        c.next = self.channels
        c.isLoading = sdat.isLoading()
        c.isVirtual = (self.driver is None)
        self.channels = c
        return c

    def updateVirtualChannels(self,now):
        c = self.channels
        while (c is not None):
            if ((c.pause or (not c.isVirtual)) or c.isLoading):
                c = c.next
                continue
            a = (now - c.lastStamp)
            c.set_position((c.position + ((0.0 if ((a < 0.0)) else a))))
            c.lastStamp = now
            next = c.next
            while (c.position >= c.duration):
                c.set_position((c.position - c.duration))
                c.onEnd()
                if ((next is not None) and ((next.manager is None))):
                    next = None
                if (len(c.queue) > 0):
                    _this = c.queue
                    c.sound = (None if ((len(_this) == 0)) else _this.pop(0))
                    c.duration = c.sound.getData().get_duration()
                elif (not c.loop):
                    self.releaseChannel(c)
                    break
            c = next

    def update(self):
        if (self.timeOffset != 0):
            c = self.channels
            while (c is not None):
                c.lastStamp = (c.lastStamp + self.timeOffset)
                if (c.currentFade is not None):
                    _hx_local_1 = c.currentFade
                    _hx_local_2 = _hx_local_1.start
                    _hx_local_1.start = (_hx_local_2 + self.timeOffset)
                    _hx_local_1.start
                c = c.next
            _g = 0
            _g1 = self.sources
            while (_g < len(_g1)):
                s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _g2 = 0
                _g3 = s.buffers
                while (_g2 < len(_g3)):
                    b = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    b.lastStop = (b.lastStop + self.timeOffset)
            self.timeOffset = 0
        self.now = python_lib_Timeit.default_timer()
        if (self.driver is None):
            self.updateVirtualChannels(self.now)
            return
        _g = 0
        _g1 = self.sources
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c = s.channel
            if (c is None):
                continue
            if c.positionChanged:
                self.releaseSource(s)
                continue
            lastBuffer = None
            count = self.driver.getProcessedBuffers(s.handle)
            _g2 = 0
            _g3 = count
            while (_g2 < _g3):
                i = _g2
                _g2 = (_g2 + 1)
                b = self.unqueueBuffer(s)
                if (b is None):
                    continue
                lastBuffer = b
                if b.isEnd:
                    c.sound = b.sound
                    c.duration = b.sound.getData().get_duration()
                    c.set_position(c.duration)
                    c.positionChanged = False
                    c.onEnd()
                    s.start = 0
            if (len(s.buffers) == 0):
                if (not lastBuffer.isEnd):
                    c.set_position((((lastBuffer.start + lastBuffer.samples)) / lastBuffer.sampleRate))
                    self.releaseSource(s)
                elif (len(c.queue) > 0):
                    _this = c.queue
                    c.sound = (None if ((len(_this) == 0)) else _this.pop(0))
                    c.duration = c.sound.getData().get_duration()
                    c.set_position(0)
                    self.releaseSource(s)
                elif c.loop:
                    c.set_position(0)
                    self.releaseSource(s)
                else:
                    self.releaseChannel(c)
                continue
            c.sound = (s.buffers[0] if 0 < len(s.buffers) else None).sound
            c.duration = c.sound.getData().get_duration()
            playedSamples = self.driver.getPlayedSampleCount(s.handle)
            if (playedSamples < 0):
                playedSamples = 0
            c.set_position((playedSamples / (s.buffers[0] if 0 < len(s.buffers) else None).sampleRate))
            c.positionChanged = False
            if (len(s.buffers) < hxd_snd_Manager.BUFFER_QUEUE_LENGTH):
                b1 = python_internal_ArrayImpl._get(s.buffers, (len(s.buffers) - 1))
                if (not b1.isEnd):
                    self.queueBuffer(s,b1.sound,(b1.start + b1.samples))
                elif (len(c.queue) > 0):
                    snd = (c.queue[0] if 0 < len(c.queue) else None)
                    if self.queueBuffer(s,snd,0):
                        _this1 = c.queue
                        if (len(_this1) != 0):
                            _this1.pop(0)
                elif c.loop:
                    self.queueBuffer(s,b1.sound,0)
        c = self.channels
        while (c is not None):
            c.calcAudibleVolume(self.now)
            if (c.isLoading and (not c.sound.getData().isLoading())):
                c.isLoading = False
            c.isVirtual = (((((self.suspended or c.pause) or c.mute) or c.channelGroup.mute) or ((c.allowVirtual and ((c.audibleVolume < hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD))))) or c.isLoading)
            c = c.next
        _hx_list = self.channels
        cmp = self.sortChannel
        tmp = None
        if (_hx_list is None):
            tmp = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p = None
            q = None
            e = None
            tail = None
            while True:
                p = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p is not None):
                    nmerges = (nmerges + 1)
                    q = p
                    psize = 0
                    _g = 0
                    _g1 = insize
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        elif (((qsize == 0) or ((q is None))) or ((cmp(p,q) <= 0))):
                            e = p
                            p = p.next
                            psize = (psize - 1)
                        else:
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            tmp = _hx_list
        self.channels = tmp
        audibleCount = 0
        c = self.channels
        while ((c is not None) and (not c.isVirtual)):
            audibleCount = (audibleCount + 1)
            tmp = audibleCount
            if (tmp > len(self.sources)):
                c.isVirtual = True
            elif (c.soundGroup.maxAudible >= 0):
                if (c.soundGroup.lastUpdate != self.now):
                    c.soundGroup.lastUpdate = self.now
                    c.soundGroup.numAudible = 0
                def _hx_local_15():
                    _hx_local_13 = c.soundGroup
                    _hx_local_14 = _hx_local_13.numAudible
                    _hx_local_13.numAudible = (_hx_local_14 + 1)
                    return _hx_local_13.numAudible
                tmp1 = _hx_local_15()
                if (tmp1 > c.soundGroup.maxAudible):
                    c.isVirtual = True
                    audibleCount = (audibleCount - 1)
            c = c.next
        _g = 0
        _g1 = self.sources
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((s.channel is None) or (not s.channel.isVirtual)):
                continue
            self.releaseSource(s)
        c = self.channels
        while (c is not None):
            if ((c.source is not None) or c.isVirtual):
                c = c.next
                continue
            s = None
            _g = 0
            _g1 = self.sources
            while (_g < len(_g1)):
                s2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (s2.channel is None):
                    s = s2
                    break
            if (s is None):
                raise haxe_Exception.thrown("could not get a source")
            s.channel = c
            c.source = s
            self.checkTargetFormat(c.sound.getData(),c.soundGroup.mono)
            s.start = Math.floor((c.position * self.targetRate))
            if (s.start < 0):
                s.start = 0
            self.queueBuffer(s,c.sound,s.start)
            c.positionChanged = False
            c = c.next
        usedEffects = None
        volume = (1. if (self.hasMasterVolume) else self.masterVolume)
        _g = 0
        _g1 = self.sources
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c = s.channel
            if (c is None):
                continue
            v = (c.currentVolume * volume)
            if (s.volume != v):
                if (v < 0):
                    v = 0
                s.volume = v
                self.driver.setSourceVolume(s.handle,v)
            if (not s.playing):
                self.driver.playSource(s.handle)
                s.playing = True
            i = len(c.bindedEffects)
            while True:
                i = (i - 1)
                tmp = i
                if (not ((tmp >= 0))):
                    break
                e = (c.bindedEffects[i] if i >= 0 and i < len(c.bindedEffects) else None)
                if ((python_internal_ArrayImpl.indexOf(c.effects,e,None) < 0) and ((python_internal_ArrayImpl.indexOf(c.channelGroup.effects,e,None) < 0))):
                    self.unbindEffect(c,s,e)
            _g2 = 0
            _g3 = c.channelGroup.effects
            while (_g2 < len(_g3)):
                e1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                if (python_internal_ArrayImpl.indexOf(c.bindedEffects,e1,None) < 0):
                    self.bindEffect(c,s,e1)
            _g4 = 0
            _g5 = c.effects
            while (_g4 < len(_g5)):
                e2 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                if (python_internal_ArrayImpl.indexOf(c.bindedEffects,e2,None) < 0):
                    self.bindEffect(c,s,e2)
            _g6 = 0
            _g7 = c.bindedEffects
            while (_g6 < len(_g7)):
                e3 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                _g6 = (_g6 + 1)
                usedEffects = hxd_snd_Manager.regEffect(usedEffects,e3)
        _hx_list = usedEffects
        cmp = self.sortEffect
        if (_hx_list is None):
            usedEffects = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p = None
            q = None
            e = None
            tail = None
            while True:
                p = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p is not None):
                    nmerges = (nmerges + 1)
                    q = p
                    psize = 0
                    _g = 0
                    _g1 = insize
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        elif (((qsize == 0) or ((q is None))) or ((cmp(p,q) <= 0))):
                            e = p
                            p = p.next
                            psize = (psize - 1)
                        else:
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            usedEffects = _hx_list
        e = usedEffects
        while (e is not None):
            e.driver.update(e)
            e = e.next
        _g = 0
        _g1 = self.sources
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c = s.channel
            if (c is None):
                continue
            _g2 = 0
            _g3 = c.bindedEffects
            while (_g2 < len(_g3)):
                e = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                e.driver.apply(e,s.handle)
        _g = 0
        _g1 = self.effectGC
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((self.now - e.lastStamp) > e.retainTime):
                e.driver.release()
                python_internal_ArrayImpl.remove(self.effectGC,e)
                break
        self.updateVirtualChannels(self.now)
        _this = self.listener.direction
        k = (((_this.x * _this.x) + ((_this.y * _this.y))) + ((_this.z * _this.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _this.x = (_this.x * k)
        _this.y = (_this.y * k)
        _this.z = (_this.z * k)
        _this = self.listener.up
        k = (((_this.x * _this.x) + ((_this.y * _this.y))) + ((_this.z * _this.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _this.x = (_this.x * k)
        _this.y = (_this.y * k)
        _this.z = (_this.z * k)
        if self.hasMasterVolume:
            self.driver.setMasterVolume(self.masterVolume)
        self.driver.setListenerParams(self.listener.position,self.listener.direction,self.listener.up,self.listener.velocity)
        self.driver.update()
        if (self.soundBufferCount >= hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE):
            now = python_lib_Timeit.default_timer()
            i = 0
            while (i < len(self.soundBufferKeys)):
                k = (self.soundBufferKeys[i] if i >= 0 and i < len(self.soundBufferKeys) else None)
                b = self.soundBufferMap.h.get(k,None)
                i = (i + 1)
                if ((b.refs > 0) or (((b.lastStop + 60.0) > now))):
                    continue
                self.soundBufferMap.remove(k)
                python_internal_ArrayImpl.remove(self.soundBufferKeys,k)
                i = (i - 1)
                b.dispose()
                _hx_local_40 = self
                _hx_local_41 = _hx_local_40.soundBufferCount
                _hx_local_40.soundBufferCount = (_hx_local_41 - 1)
                _hx_local_40.soundBufferCount

    def progressiveDecodeBuffer(self,s,snd,start):
        data = snd.getData()
        samples = Math.ceil((hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT / hxd_snd_Manager.BUFFER_STREAM_SPLIT))
        if ((s.streamStart != start) or ((s.streamSound != snd))):
            s.streamSound = snd
            s.streamStart = start
            s.streamPos = start
        end = (start + hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT)
        if (s.streamPos == end):
            return True
        bpp = data.getBytesPerSample()
        reqSize = (hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * bpp)
        if ((s.streamBuffer is None) or ((s.streamBuffer.length < reqSize))):
            s.streamBuffer = haxe_io_Bytes.alloc(reqSize)
            s.streamPos = start
        remain = (end - s.streamPos)
        if (remain > samples):
            remain = samples
        data.decode(s.streamBuffer,(((s.streamPos - start)) * bpp),s.streamPos,remain)
        s.streamPos = (s.streamPos + remain)
        return (s.streamPos == end)

    def queueBuffer(self,s,snd,start):
        data = snd.getData()
        sgroup = s.channel.soundGroup
        b = None
        if (data.get_duration() <= hxd_snd_Manager.STREAM_DURATION):
            b = self.getSoundBuffer(snd,sgroup)
            self.driver.queueBuffer(s.handle,b.handle,start,True)
        else:
            if (((len(s.buffers) > 0) and ((hxd_snd_Manager.BUFFER_STREAM_SPLIT > 1))) and (not self.progressiveDecodeBuffer(s,snd,start))):
                return False
            b = self.getStreamBuffer(s,snd,sgroup,start)
            self.driver.queueBuffer(s.handle,b.handle,0,b.isEnd)
        _this = s.buffers
        _this.append(b)
        return True

    def unqueueBuffer(self,s):
        _this = s.buffers
        b = (None if ((len(_this) == 0)) else _this.pop(0))
        if (b is None):
            return None
        self.driver.unqueueBuffer(s.handle,b.handle)
        if b.isStream:
            self.freeStreamBuffers.insert(0, b)
        else:
            def _hx_local_1():
                b.refs = (b.refs - 1)
                return b.refs
            tmp = (_hx_local_1() == 0)
            if tmp:
                b.lastStop = python_lib_Timeit.default_timer()
        return b

    def bindEffect(self,c,s,e):
        if ((e.refs == 0) and (not python_internal_ArrayImpl.remove(self.effectGC,e))):
            e.driver.acquire()
        e.refs = (e.refs + 1)
        e.driver.bind(e,s.handle)
        _this = c.bindedEffects
        _this.append(e)

    def unbindEffect(self,c,s,e):
        e.driver.unbind(e,s.handle)
        python_internal_ArrayImpl.remove(c.bindedEffects,e)
        def _hx_local_1():
            e.refs = (e.refs - 1)
            return e.refs
        tmp = (_hx_local_1() == 0)
        if tmp:
            e.lastStamp = self.now
            _this = self.effectGC
            _this.append(e)

    def releaseSource(self,s):
        if (s.channel is not None):
            _g = 0
            _g1 = list(s.channel.bindedEffects)
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.unbindEffect(s.channel,s,e)
            s.channel.bindedEffects = []
            s.channel.source = None
            s.channel = None
        if s.playing:
            s.playing = False
            self.driver.stopSource(s.handle)
            s.volume = -1.0
        while (len(s.buffers) > 0):
            self.unqueueBuffer(s)

    def checkTargetFormat(self,dat,forceMono = None):
        if (forceMono is None):
            forceMono = False
        self.targetRate = dat.samplingRate
        self.targetRate = hxd_snd_openal_Emulator.get_NATIVE_FREQ()
        self.targetChannels = (1 if ((forceMono or ((dat.channels == 1)))) else 2)
        tmp = None
        tmp1 = dat.sampleFormat.index
        if (tmp1 == 0):
            tmp = hxd_snd_SampleFormat.UI8
        elif (tmp1 == 1):
            tmp = hxd_snd_SampleFormat.I16
        elif (tmp1 == 2):
            tmp = hxd_snd_SampleFormat.I16
        else:
            pass
        self.targetFormat = tmp
        if ((self.targetChannels == dat.channels) and ((self.targetFormat == dat.sampleFormat))):
            return (self.targetRate == dat.samplingRate)
        else:
            return False

    def getSoundBuffer(self,snd,grp):
        _gthis = self
        data = snd.getData()
        mono = grp.mono
        key = snd.entry.get_path()
        if (mono and ((data.channels != 1))):
            key = (("null" if key is None else key) + "mono")
        b = self.soundBufferMap.h.get(key,None)
        if (b is None):
            b = hxd_snd_Buffer(self.driver)
            b.isStream = False
            b.isEnd = True
            b.sound = snd
            def _hx_local_1():
                _gthis.fillSoundBuffer(b,data,mono)
            data.load(_hx_local_1)
            self.soundBufferMap.h[key] = b
            _this = self.soundBufferKeys
            _this.append(key)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.soundBufferCount
            _hx_local_2.soundBufferCount = (_hx_local_3 + 1)
            _hx_local_2.soundBufferCount
        b.refs = (b.refs + 1)
        return b

    def fillSoundBuffer(self,buf,dat,forceMono = None):
        if (forceMono is None):
            forceMono = False
        if (not self.checkTargetFormat(dat,forceMono)):
            dat = dat.resample(self.targetRate,self.targetFormat,self.targetChannels)
        length = (dat.samples * dat.getBytesPerSample())
        _hx_bytes = self.getTmpBytes(length)
        dat.decode(_hx_bytes,0,0,dat.samples)
        self.driver.setBufferData(buf.handle,_hx_bytes,length,self.targetFormat,self.targetChannels,self.targetRate)
        buf.sampleRate = self.targetRate
        buf.samples = dat.samples

    def getStreamBuffer(self,src,snd,grp,start):
        data = snd.getData()
        _this = self.freeStreamBuffers
        b = (None if ((len(_this) == 0)) else _this.pop(0))
        if (b is None):
            b = hxd_snd_Buffer(self.driver)
            b.isStream = True
        samples = hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT
        if ((start + samples) >= data.samples):
            samples = (data.samples - start)
            b.isEnd = True
        else:
            b.isEnd = False
        b.sound = snd
        b.samples = samples
        b.start = start
        size = (samples * data.getBytesPerSample())
        _hx_bytes = None
        if ((src.streamSound == snd) and ((src.streamStart == start))):
            while (not self.progressiveDecodeBuffer(src,snd,start)):
                pass
            _hx_bytes = src.streamBuffer
        else:
            _hx_bytes = self.getTmpBytes(size)
            data.decode(_hx_bytes,0,start,samples)
        if (not self.checkTargetFormat(data,grp.mono)):
            size1 = (Math.ceil((samples * ((self.targetRate / data.samplingRate)))) * self.targetChannels)
            size2 = None
            size3 = self.targetFormat.index
            if (size3 == 0):
                size2 = 1
            elif (size3 == 1):
                size2 = 2
            elif (size3 == 2):
                size2 = 4
            else:
                pass
            size = (size1 * size2)
            resampleBytes = self.getResampleBytes(size)
            data.resampleBuffer(resampleBytes,0,_hx_bytes,0,self.targetRate,self.targetFormat,self.targetChannels,samples)
            _hx_bytes = resampleBytes
        self.driver.setBufferData(b.handle,_hx_bytes,size,self.targetFormat,self.targetChannels,self.targetRate)
        b.sampleRate = self.targetRate
        return b

    def sortChannel(self,a,b):
        if (a.isVirtual != b.isVirtual):
            if a.isVirtual:
                return 1
            else:
                return -1
        if (a.channelGroup.priority != b.channelGroup.priority):
            if (a.channelGroup.priority < b.channelGroup.priority):
                return 1
            else:
                return -1
        if (a.priority != b.priority):
            if (a.priority < b.priority):
                return 1
            else:
                return -1
        if (a.audibleVolume != b.audibleVolume):
            if (a.audibleVolume < b.audibleVolume):
                return 1
            else:
                return -1
        if (a.id < b.id):
            return 1
        else:
            return -1

    def sortEffect(self,a,b):
        return (b.priority - a.priority)

    def releaseChannel(self,c):
        if (c.manager is None):
            return
        if (self.channels == c):
            self.channels = c.next
        else:
            prev = self.channels
            while (prev.next != c):
                prev = prev.next
            prev.next = c.next
        _g = 0
        _g1 = c.effects
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.removeEffect(e)
        if (c.source is not None):
            self.releaseSource(c.source)
        c.next = None
        c.manager = None
        c.effects = None
        c.bindedEffects = None
        c.currentFade = None
        snd = c.sound
        if ((snd is not None) and ((snd.channel == c))):
            snd.channel = None
    instance = None

    @staticmethod
    def get():
        if (hxd_snd_Manager.instance is None):
            hxd_snd_Manager.instance = hxd_snd_Manager()
            hxd_snd_Manager.instance.updateEvent = haxe_MainLoop.add(hxd_snd_Manager.instance.update)
            hxd_snd_Manager.instance.updateEvent.isBlocking = False
        return hxd_snd_Manager.instance

    @staticmethod
    def regEffect(_hx_list,e):
        l = _hx_list
        while (l is not None):
            if (l == e):
                return _hx_list
            l = l.next
        e.next = _hx_list
        return e

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.masterVolume = None
        _hx_o.masterSoundGroup = None
        _hx_o.masterChannelGroup = None
        _hx_o.listener = None
        _hx_o.timeOffset = None
        _hx_o.updateEvent = None
        _hx_o.cachedBytes = None
        _hx_o.resampleBytes = None
        _hx_o.driver = None
        _hx_o.channels = None
        _hx_o.sources = None
        _hx_o.now = None
        _hx_o.soundBufferCount = None
        _hx_o.soundBufferMap = None
        _hx_o.soundBufferKeys = None
        _hx_o.freeStreamBuffers = None
        _hx_o.effectGC = None
        _hx_o.hasMasterVolume = None
        _hx_o.suspended = None
        _hx_o.targetRate = None
        _hx_o.targetFormat = None
        _hx_o.targetChannels = None
hxd_snd_Manager._hx_class = hxd_snd_Manager
_hx_classes["hxd.snd.Manager"] = hxd_snd_Manager


class hxd_snd_Mp3Data(hxd_snd_Data):
    _hx_class_name = "hxd.snd.Mp3Data"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["decodeBuffer"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_snd_Data


    def __init__(self,_hx_bytes):
        mp = format_mp3_Reader(haxe_io_BytesInput(_hx_bytes)).read()
        self.samples = mp.sampleCount
        frame = (mp.frames[0] if 0 < len(mp.frames) else None).data
        lame = -1
        _g = 0
        _g1 = (frame.length - 24)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((((frame.b[i] == 76) and ((frame.b[(i + 1)] == 65))) and ((frame.b[(i + 2)] == 77))) and ((frame.b[(i + 3)] == 69))):
                lame = i
                break
        if (lame >= 0):
            startEnd = (((frame.b[(lame + 21)] << 16) | ((frame.b[(lame + 22)] << 8))) | frame.b[(lame + 23)])
            start = (startEnd >> 12)
            end = (startEnd & 4095)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.samples
            _hx_local_0.samples = (_hx_local_1 - (((start + end) + 1152)))
            _hx_local_0.samples
        header = (mp.frames[0] if 0 < len(mp.frames) else None).header
        self.sampleFormat = hxd_snd_SampleFormat.F32
        self.samplingRate = format_mp3_MPEG.srEnum2Num(header.samplingRate)
        self.channels = (1 if ((header.channelMode == format_mp3_ChannelMode.Mono)) else 2)

    def decodeBuffer(self,out,outPos,sampleStart,sampleCount):
        raise haxe_Exception.thrown("MP3 decoding is not available for this platform")

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_snd_Mp3Data._hx_class = hxd_snd_Mp3Data
_hx_classes["hxd.snd.Mp3Data"] = hxd_snd_Mp3Data


class hxd_snd_NativeChannel:
    _hx_class_name = "hxd.snd.NativeChannel"
    _hx_is_interface = "False"
    __slots__ = ("bufferSamples",)
    _hx_fields = ["bufferSamples"]
    _hx_methods = ["onSample", "stop"]

    def __init__(self,bufferSamples):
        self.bufferSamples = bufferSamples

    def onSample(self,out):
        pass

    def stop(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bufferSamples = None
hxd_snd_NativeChannel._hx_class = hxd_snd_NativeChannel
_hx_classes["hxd.snd.NativeChannel"] = hxd_snd_NativeChannel


class hxd_snd_SoundGroup:
    _hx_class_name = "hxd.snd.SoundGroup"
    _hx_is_interface = "False"
    __slots__ = ("name", "volume", "maxAudible", "mono", "numAudible", "lastUpdate")
    _hx_fields = ["name", "volume", "maxAudible", "mono", "numAudible", "lastUpdate"]

    def __init__(self,name):
        self.lastUpdate = None
        self.numAudible = None
        self.name = name
        self.maxAudible = -1
        self.volume = 1
        self.mono = False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.volume = None
        _hx_o.maxAudible = None
        _hx_o.mono = None
        _hx_o.numAudible = None
        _hx_o.lastUpdate = None
hxd_snd_SoundGroup._hx_class = hxd_snd_SoundGroup
_hx_classes["hxd.snd.SoundGroup"] = hxd_snd_SoundGroup


class hxd_snd_WavData(hxd_snd_Data):
    _hx_class_name = "hxd.snd.WavData"
    _hx_is_interface = "False"
    __slots__ = ("rawData",)
    _hx_fields = ["rawData"]
    _hx_methods = ["init", "decodeBuffer"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_snd_Data


    def __init__(self,_hx_bytes):
        self.rawData = None
        if (_hx_bytes is not None):
            self.init(format_wav_Reader(haxe_io_BytesInput(_hx_bytes)).read())

    def init(self,d):
        h = d.header
        self.samplingRate = h.samplingRate
        self.channels = h.channels
        tmp = None
        _g = h.bitsPerSample
        if (_g == 8):
            tmp = hxd_snd_SampleFormat.UI8
        elif (_g == 16):
            tmp = hxd_snd_SampleFormat.I16
        else:
            raise haxe_Exception.thrown((("Unsupported WAV " + Std.string(h.bitsPerSample)) + " bits"))
        self.sampleFormat = tmp
        self.rawData = d.data
        x = (self.rawData.length / self.getBytesPerSample())
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        self.samples = tmp

    def decodeBuffer(self,out,outPos,sampleStart,sampleCount):
        bpp = self.getBytesPerSample()
        out.blit(outPos,self.rawData,(sampleStart * bpp),(sampleCount * bpp))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.rawData = None
hxd_snd_WavData._hx_class = hxd_snd_WavData
_hx_classes["hxd.snd.WavData"] = hxd_snd_WavData


class hxd_snd_openal_BufferHandle:
    _hx_class_name = "hxd.snd.openal.BufferHandle"
    _hx_is_interface = "False"
    __slots__ = ("inst", "isEnd")
    _hx_fields = ["inst", "isEnd"]

    def __init__(self):
        self.isEnd = None
        self.inst = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.inst = None
        _hx_o.isEnd = None
hxd_snd_openal_BufferHandle._hx_class = hxd_snd_openal_BufferHandle
_hx_classes["hxd.snd.openal.BufferHandle"] = hxd_snd_openal_BufferHandle


class hxd_snd_openal_SourceHandle:
    _hx_class_name = "hxd.snd.openal.SourceHandle"
    _hx_is_interface = "False"
    __slots__ = ("inst", "sampleOffset", "playing", "nextAuxiliarySend", "freeAuxiliarySends", "effectToAuxiliarySend")
    _hx_fields = ["inst", "sampleOffset", "playing", "nextAuxiliarySend", "freeAuxiliarySends", "effectToAuxiliarySend"]
    _hx_methods = ["acquireAuxiliarySend", "getAuxiliarySend", "releaseAuxiliarySend"]

    def __init__(self):
        self.playing = None
        self.inst = None
        self.sampleOffset = 0
        self.nextAuxiliarySend = 0
        self.freeAuxiliarySends = []
        self.effectToAuxiliarySend = haxe_ds_ObjectMap()

    def acquireAuxiliarySend(self,effect):
        send = None
        if (len(self.freeAuxiliarySends) > 0):
            _this = self.freeAuxiliarySends
            send = (None if ((len(_this) == 0)) else _this.pop(0))
        else:
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nextAuxiliarySend
                _hx_local_0.nextAuxiliarySend = (_hx_local_1 + 1)
                return _hx_local_1
            send = _hx_local_2()
        self.effectToAuxiliarySend.set(effect,send)
        return send

    def getAuxiliarySend(self,effect):
        return self.effectToAuxiliarySend.h.get(effect,None)

    def releaseAuxiliarySend(self,effect):
        send = self.effectToAuxiliarySend.h.get(effect,None)
        self.effectToAuxiliarySend.remove(effect)
        _this = self.freeAuxiliarySends
        _this.append(send)
        return send

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.inst = None
        _hx_o.sampleOffset = None
        _hx_o.playing = None
        _hx_o.nextAuxiliarySend = None
        _hx_o.freeAuxiliarySends = None
        _hx_o.effectToAuxiliarySend = None
hxd_snd_openal_SourceHandle._hx_class = hxd_snd_openal_SourceHandle
_hx_classes["hxd.snd.openal.SourceHandle"] = hxd_snd_openal_SourceHandle


class hxd_snd_openal_Driver:
    _hx_class_name = "hxd.snd.openal.Driver"
    _hx_is_interface = "False"
    __slots__ = ("device", "context", "maxAuxiliarySends", "tmpBytes")
    _hx_fields = ["device", "context", "maxAuxiliarySends", "tmpBytes"]
    _hx_methods = ["hasFeature", "getTmpBytes", "setMasterVolume", "setListenerParams", "createSource", "destroySource", "playSource", "stopSource", "setSourceVolume", "createBuffer", "destroyBuffer", "setBufferData", "getPlayedSampleCount", "getProcessedBuffers", "queueBuffer", "unqueueBuffer", "update", "dispose", "getEffectDriver"]
    _hx_interfaces = [hxd_snd_Driver]

    def __init__(self):
        self.maxAuxiliarySends = None
        self.context = None
        self.tmpBytes = haxe_io_Bytes.alloc(24)
        self.device = hxd_snd_openal_ALC.openDevice(None)
        self.context = hxd_snd_openal_ALC.createContext(self.device,None)
        hxd_snd_openal_ALC.makeContextCurrent(self.context)
        hxd_snd_openal_ALC.loadExtensions(self.device)
        hxd_snd_openal_Emulator.loadExtensions()
        _hx_bytes = self.getTmpBytes(4)
        hxd_snd_openal_ALC.getIntegerv(self.device,131075,1,_hx_bytes)
        v = (((_hx_bytes.b[0] | ((_hx_bytes.b[1] << 8))) | ((_hx_bytes.b[2] << 16))) | ((_hx_bytes.b[3] << 24)))
        self.maxAuxiliarySends = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        if (hxd_snd_openal_Emulator.getError() != 0):
            raise haxe_Exception.thrown("could not init openAL Driver")

    def hasFeature(self,f):
        return False

    def getTmpBytes(self,size):
        if (self.tmpBytes.length < size):
            self.tmpBytes = haxe_io_Bytes.alloc(size)
        return self.tmpBytes

    def setMasterVolume(self,value):
        hxd_snd_openal_Emulator.listenerf(4106,value)

    def setListenerParams(self,position,direction,up,velocity = None):
        hxd_snd_openal_Emulator.listener3f(4100,-position.x,position.y,position.z)
        _hx_bytes = self.getTmpBytes(24)
        _hx_bytes.setFloat(0,-direction.x)
        _hx_bytes.setFloat(4,direction.y)
        _hx_bytes.setFloat(8,direction.z)
        k = (((up.x * up.x) + ((up.y * up.y))) + ((up.z * up.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        up.x = (up.x * k)
        up.y = (up.y * k)
        up.z = (up.z * k)
        _hx_bytes.setFloat(12,-up.x)
        _hx_bytes.setFloat(16,up.y)
        _hx_bytes.setFloat(20,up.z)
        hxd_snd_openal_Emulator.listenerfv(4111,self.tmpBytes)
        if (velocity is not None):
            hxd_snd_openal_Emulator.listener3f(4102,-velocity.x,velocity.y,velocity.z)

    def createSource(self):
        source = hxd_snd_openal_SourceHandle()
        _hx_bytes = self.getTmpBytes(4)
        hxd_snd_openal_Emulator.genSources(1,_hx_bytes)
        if (hxd_snd_openal_Emulator.getError() != 0):
            raise haxe_Exception.thrown("could not create source")
        v = (((_hx_bytes.b[0] | ((_hx_bytes.b[1] << 8))) | ((_hx_bytes.b[2] << 16))) | ((_hx_bytes.b[3] << 24)))
        source.inst = hxd_snd_openal_Source.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None)
        hxd_snd_openal_Emulator.sourcei(source.inst,514,1)
        return source

    def destroySource(self,source):
        hxd_snd_openal_Emulator.sourcei(source.inst,131077,0)
        _hx_bytes = self.getTmpBytes(4)
        v = source.inst.id
        _hx_bytes.b[0] = (v & 255)
        _hx_bytes.b[1] = ((v >> 8) & 255)
        _hx_bytes.b[2] = ((v >> 16) & 255)
        _hx_bytes.b[3] = (HxOverrides.rshift(v, 24) & 255)
        hxd_snd_openal_Emulator.deleteSources(1,_hx_bytes)

    def playSource(self,source):
        hxd_snd_openal_Emulator.sourcePlay(source.inst)
        source.sampleOffset = 0
        source.playing = True

    def stopSource(self,source):
        hxd_snd_openal_Emulator.sourceStop(source.inst)
        source.playing = False

    def setSourceVolume(self,source,value):
        hxd_snd_openal_Emulator.sourcef(source.inst,4106,value)

    def createBuffer(self):
        buffer = hxd_snd_openal_BufferHandle()
        _hx_bytes = self.getTmpBytes(4)
        hxd_snd_openal_Emulator.genBuffers(1,_hx_bytes)
        v = (((_hx_bytes.b[0] | ((_hx_bytes.b[1] << 8))) | ((_hx_bytes.b[2] << 16))) | ((_hx_bytes.b[3] << 24)))
        buffer.inst = hxd_snd_openal_Buffer.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None)
        return buffer

    def destroyBuffer(self,buffer):
        _hx_bytes = self.getTmpBytes(4)
        v = buffer.inst.id
        _hx_bytes.b[0] = (v & 255)
        _hx_bytes.b[1] = ((v >> 8) & 255)
        _hx_bytes.b[2] = ((v >> 16) & 255)
        _hx_bytes.b[3] = (HxOverrides.rshift(v, 24) & 255)
        hxd_snd_openal_Emulator.deleteBuffers(1,_hx_bytes)

    def setBufferData(self,buffer,data,size,format,channelCount,samplingRate):
        alFormat = None
        alFormat1 = format.index
        if (alFormat1 == 0):
            alFormat = (4352 if ((channelCount == 1)) else 4354)
        elif (alFormat1 == 1):
            alFormat = (4353 if ((channelCount == 1)) else 4355)
        elif (alFormat1 == 2):
            alFormat = (4353 if ((channelCount == 1)) else 4355)
        else:
            pass
        hxd_snd_openal_Emulator.bufferData(buffer.inst,alFormat,data,size,samplingRate)

    def getPlayedSampleCount(self,source):
        v = (source.sampleOffset + hxd_snd_openal_Emulator.getSourcei(source.inst,4133))
        if (v < 0):
            v = 0
        return v

    def getProcessedBuffers(self,source):
        return hxd_snd_openal_Emulator.getSourcei(source.inst,4118)

    def queueBuffer(self,source,buffer,sampleStart,endOfStream):
        _hx_bytes = self.getTmpBytes(4)
        v = buffer.inst.id
        _hx_bytes.b[0] = (v & 255)
        _hx_bytes.b[1] = ((v >> 8) & 255)
        _hx_bytes.b[2] = ((v >> 16) & 255)
        _hx_bytes.b[3] = (HxOverrides.rshift(v, 24) & 255)
        hxd_snd_openal_Emulator.sourceQueueBuffers(source.inst,1,_hx_bytes)
        err = hxd_snd_openal_Emulator.getError()
        if (err != 0):
            raise haxe_Exception.thrown((((("Failed to queue buffers: " + HxOverrides.stringOrNull(StringTools.hex(err))) + " (") + Std.string(buffer.inst.id)) + ")"))
        if (hxd_snd_openal_Emulator.getSourcei(source.inst,4112) == 4116):
            if (sampleStart > 0):
                hxd_snd_openal_Emulator.sourcei(source.inst,4133,sampleStart)
            else:
                hxd_snd_openal_Emulator.sourcei(source.inst,4133,0)
            if source.playing:
                hxd_snd_openal_Emulator.sourcePlay(source.inst)
        buffer.isEnd = endOfStream

    def unqueueBuffer(self,source,buffer):
        _hx_bytes = self.getTmpBytes(4)
        v = buffer.inst.id
        _hx_bytes.b[0] = (v & 255)
        _hx_bytes.b[1] = ((v >> 8) & 255)
        _hx_bytes.b[2] = ((v >> 16) & 255)
        _hx_bytes.b[3] = (HxOverrides.rshift(v, 24) & 255)
        hxd_snd_openal_Emulator.sourceUnqueueBuffers(source.inst,1,_hx_bytes)
        size = hxd_snd_openal_Emulator.getBufferi(buffer.inst,8196)
        bps = ((hxd_snd_openal_Emulator.getBufferi(buffer.inst,8194) * hxd_snd_openal_Emulator.getBufferi(buffer.inst,8195)) / 8)
        samples = None
        try:
            samples = int((size / bps))
        except BaseException as _g:
            None
            samples = None
        samples1 = samples
        if buffer.isEnd:
            source.sampleOffset = 0
        else:
            source.sampleOffset = (source.sampleOffset + samples1)

    def update(self):
        pass

    def dispose(self):
        hxd_snd_openal_ALC.makeContextCurrent(None)
        hxd_snd_openal_ALC.destroyContext(self.context)
        hxd_snd_openal_ALC.closeDevice(self.device)

    def getEffectDriver(self,_hx_type):
        return hxd_snd_EffectDriver()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.device = None
        _hx_o.context = None
        _hx_o.maxAuxiliarySends = None
        _hx_o.tmpBytes = None
hxd_snd_openal_Driver._hx_class = hxd_snd_openal_Driver
_hx_classes["hxd.snd.openal.Driver"] = hxd_snd_openal_Driver


class hxd_snd_openal__Emulator_Channel(hxd_snd_NativeChannel):
    _hx_class_name = "hxd.snd.openal._Emulator.Channel"
    _hx_is_interface = "False"
    __slots__ = ("source", "startup")
    _hx_fields = ["source", "startup"]
    _hx_methods = ["onSample"]
    _hx_statics = ["FADE_START"]
    _hx_interfaces = []
    _hx_super = hxd_snd_NativeChannel


    def __init__(self,source,samples):
        self.startup = 0.
        self.source = source
        super().__init__(samples)

    def onSample(self,out):
        pos = 0
        count = ((out.byteLength >> 2) >> 1)
        if (self.source.duration > 0):
            volume = self.source.volume
            bufferIndex = 0
            baseSample = 0
            curSample = self.source.currentSample
            buffer = bufferIndex
            bufferIndex = (bufferIndex + 1)
            buffer1 = python_internal_ArrayImpl._get(self.source.buffers, buffer)
            while (count > 0):
                while ((buffer1 is not None) and ((curSample >= buffer1.samples))):
                    baseSample = (baseSample + buffer1.samples)
                    curSample = (curSample - buffer1.samples)
                    buffer = bufferIndex
                    bufferIndex = (bufferIndex + 1)
                    buffer1 = python_internal_ArrayImpl._get(self.source.buffers, buffer)
                if (buffer1 is None):
                    if self.source.loop:
                        curSample = 0
                        baseSample = 0
                        bufferIndex = 0
                        buffer2 = bufferIndex
                        bufferIndex = (bufferIndex + 1)
                        buffer1 = python_internal_ArrayImpl._get(self.source.buffers, buffer2)
                        continue
                    break
                scount = (buffer1.samples - curSample)
                if (scount > count):
                    scount = count
                read = (curSample << 1)
                data = buffer1.data
                if (self.startup < 1):
                    _g = 0
                    _g1 = scount
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        index = pos
                        pos = (pos + 1)
                        index1 = read
                        read = (read + 1)
                        value = ((data[index1] * volume) * self.startup)
                        if ((index >= 0) and ((index < ((out.byteLength >> 2))))):
                            out.bytes.setFloat((((index << 2)) + out.byteOffset),value)
                        index2 = pos
                        pos = (pos + 1)
                        index3 = read
                        read = (read + 1)
                        value1 = ((data[index3] * volume) * self.startup)
                        if ((index2 >= 0) and ((index2 < ((out.byteLength >> 2))))):
                            out.bytes.setFloat((((index2 << 2)) + out.byteOffset),value1)
                        if (self.startup < 1.):
                            _hx_local_2 = self
                            _hx_local_3 = _hx_local_2.startup
                            _hx_local_2.startup = (_hx_local_3 + 0.1)
                            _hx_local_2.startup
                            if (self.startup > 1):
                                self.startup = 1
                else:
                    _g2 = 0
                    _g3 = scount
                    while (_g2 < _g3):
                        i1 = _g2
                        _g2 = (_g2 + 1)
                        index4 = pos
                        pos = (pos + 1)
                        index5 = read
                        read = (read + 1)
                        value2 = (data[index5] * volume)
                        if ((index4 >= 0) and ((index4 < ((out.byteLength >> 2))))):
                            out.bytes.setFloat((((index4 << 2)) + out.byteOffset),value2)
                        index6 = pos
                        pos = (pos + 1)
                        index7 = read
                        read = (read + 1)
                        value3 = (data[index7] * volume)
                        if ((index6 >= 0) and ((index6 < ((out.byteLength >> 2))))):
                            out.bytes.setFloat((((index6 << 2)) + out.byteOffset),value3)
                count = (count - scount)
                curSample = (curSample + scount)
            self.source.currentSample = (baseSample + curSample)
            if (self.source.currentSample < 0):
                raise haxe_Exception.thrown(((Std.string(baseSample) + "/") + Std.string(curSample)))
        _g = 0
        _g1 = (count << 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            index = pos
            pos = (pos + 1)
            if ((index >= 0) and ((index < ((out.byteLength >> 2))))):
                out.bytes.setFloat((((index << 2)) + out.byteOffset),0.)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.source = None
        _hx_o.startup = None
hxd_snd_openal__Emulator_Channel._hx_class = hxd_snd_openal__Emulator_Channel
_hx_classes["hxd.snd.openal._Emulator.Channel"] = hxd_snd_openal__Emulator_Channel


class hxd_snd_openal_Source:
    _hx_class_name = "hxd.snd.openal.Source"
    _hx_is_interface = "False"
    __slots__ = ("id", "chan", "playedTime", "currentSample", "buffers", "loop", "volume", "duration", "frequency")
    _hx_fields = ["id", "chan", "playedTime", "currentSample", "buffers", "loop", "volume", "duration", "frequency"]
    _hx_methods = ["updateDuration", "get_playing", "play", "stop", "dispose", "toInt"]
    _hx_statics = ["STOP_DELAY", "CHANNEL_BUFSIZE", "ID", "all", "ofInt"]

    def __init__(self):
        self.frequency = None
        self.duration = None
        self.chan = None
        self.volume = 1.
        self.loop = False
        self.buffers = []
        self.currentSample = 0
        self.playedTime = 0.
        def _hx_local_2():
            _hx_local_0 = hxd_snd_openal_Source
            _hx_local_1 = _hx_local_0.ID
            _hx_local_0.ID = (_hx_local_1 + 1)
            return _hx_local_0.ID
        self.id = _hx_local_2()
        hxd_snd_openal_Source.all.set(self.id,self)

    def updateDuration(self):
        self.frequency = (1 if ((len(self.buffers) == 0)) else (self.buffers[0] if 0 < len(self.buffers) else None).frequency)
        self.duration = 0.
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.duration
            _hx_local_1.duration = (_hx_local_2 + ((b.samples / b.frequency)))
            _hx_local_1.duration

    def get_playing(self):
        return (self.chan is not None)

    def play(self):
        if (self.chan is None):
            self.playedTime = (python_lib_Timeit.default_timer() - ((self.currentSample / self.frequency)))
            self.chan = hxd_snd_openal__Emulator_Channel(self,hxd_snd_openal_Source.CHANNEL_BUFSIZE)

    def stop(self,immediate = None):
        if (immediate is None):
            immediate = False
        if (self.chan is not None):
            self.chan.stop()
            self.chan = None

    def dispose(self):
        self.stop()
        hxd_snd_openal_Source.all.remove(self.id)
        self.id = 0

    def toInt(self):
        return self.id

    @staticmethod
    def ofInt(i):
        return hxd_snd_openal_Source.all.h.get(i,None)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.chan = None
        _hx_o.playedTime = None
        _hx_o.currentSample = None
        _hx_o.buffers = None
        _hx_o.loop = None
        _hx_o.volume = None
        _hx_o.duration = None
        _hx_o.frequency = None
hxd_snd_openal_Source._hx_class = hxd_snd_openal_Source
_hx_classes["hxd.snd.openal.Source"] = hxd_snd_openal_Source


class hxd_snd_openal_Buffer:
    _hx_class_name = "hxd.snd.openal.Buffer"
    _hx_is_interface = "False"
    __slots__ = ("id", "data", "frequency", "samples")
    _hx_fields = ["id", "data", "frequency", "samples"]
    _hx_methods = ["dispose", "alloc", "toInt"]
    _hx_statics = ["ID", "all", "ofInt"]

    def __init__(self):
        self.data = None
        self.samples = 0
        self.frequency = 1
        def _hx_local_2():
            _hx_local_0 = hxd_snd_openal_Buffer
            _hx_local_1 = _hx_local_0.ID
            _hx_local_0.ID = (_hx_local_1 + 1)
            return _hx_local_0.ID
        self.id = _hx_local_2()
        hxd_snd_openal_Buffer.all.set(self.id,self)

    def dispose(self):
        self.data = None
        hxd_snd_openal_Buffer.all.remove(self.id)
        self.id = 0

    def alloc(self,size):
        if ((self.data is None) or ((len(self.data) != size))):
            this1 = [None]*size
            self.data = this1
        return self.data

    def toInt(self):
        return self.id

    @staticmethod
    def ofInt(i):
        return hxd_snd_openal_Buffer.all.h.get(i,None)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.data = None
        _hx_o.frequency = None
        _hx_o.samples = None
hxd_snd_openal_Buffer._hx_class = hxd_snd_openal_Buffer
_hx_classes["hxd.snd.openal.Buffer"] = hxd_snd_openal_Buffer


class hxd_snd_openal_Emulator:
    _hx_class_name = "hxd.snd.openal.Emulator"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["CACHED_FREQ", "get_NATIVE_FREQ", "dopplerFactor", "dopplerVelocity", "speedOfSound", "distanceModel", "enable", "disable", "isEnabled", "getBooleanv", "getIntegerv", "getFloatv", "getDoublev", "getString", "getBoolean", "getInteger", "getFloat", "getDouble", "getError", "loadExtensions", "isExtensionPresent", "getEnumValue", "listenerf", "listener3f", "listenerfv", "listeneri", "listener3i", "listeneriv", "getListenerf", "getListener3f", "getListenerfv", "getListeneri", "getListener3i", "getListeneriv", "genSources", "deleteSources", "isSource", "sourcef", "source3f", "sourcefv", "sourcei", "source3i", "sourceiv", "getSourcef", "getSourcei", "getSource3f", "getSourcefv", "getSource3i", "getSourceiv", "sourcePlayv", "sourceStopv", "sourceRewindv", "sourcePausev", "sourcePlay", "sourceStop", "sourceRewind", "sourcePause", "sourceQueueBuffers", "sourceUnqueueBuffers", "genBuffers", "deleteBuffers", "isBuffer", "bufferData", "bufferf", "buffer3f", "bufferfv", "bufferi", "buffer3i", "bufferiv", "getBufferf", "getBuffer3f", "getBufferfv", "getBufferi", "getBuffer3i", "getBufferiv", "FORMAT_MONOF32", "FORMAT_STEREOF32", "NONE", "FALSE", "TRUE", "SOURCE_RELATIVE", "CONE_INNER_ANGLE", "CONE_OUTER_ANGLE", "PITCH", "POSITION", "DIRECTION", "VELOCITY", "LOOPING", "BUFFER", "GAIN", "MIN_GAIN", "MAX_GAIN", "ORIENTATION", "SOURCE_STATE", "INITIAL", "PLAYING", "PAUSED", "STOPPED", "BUFFERS_QUEUED", "BUFFERS_PROCESSED", "REFERENCE_DISTANCE", "ROLLOFF_FACTOR", "CONE_OUTER_GAIN", "MAX_DISTANCE", "SEC_OFFSET", "SAMPLE_OFFSET", "BYTE_OFFSET", "SOURCE_TYPE", "STATIC", "STREAMING", "UNDETERMINED", "FORMAT_MONO8", "FORMAT_MONO16", "FORMAT_STEREO8", "FORMAT_STEREO16", "FREQUENCY", "BITS", "CHANNELS", "SIZE", "UNUSED", "PENDING", "PROCESSED", "NO_ERROR", "INVALID_NAME", "INVALID_ENUM", "INVALID_VALUE", "INVALID_OPERATION", "OUT_OF_MEMORY", "VENDOR", "VERSION", "RENDERER", "EXTENSIONS", "DOPPLER_FACTOR", "DOPPLER_VELOCITY", "SPEED_OF_SOUND", "DISTANCE_MODEL", "INVERSE_DISTANCE", "INVERSE_DISTANCE_CLAMPED", "LINEAR_DISTANCE", "LINEAR_DISTANCE_CLAMPED", "EXPONENT_DISTANCE", "EXPONENT_DISTANCE_CLAMPED"]
    NATIVE_FREQ = None
    CACHED_FREQ = None

    @staticmethod
    def get_NATIVE_FREQ():
        if (hxd_snd_openal_Emulator.CACHED_FREQ is None):
            hxd_snd_openal_Emulator.CACHED_FREQ = 44100
        return hxd_snd_openal_Emulator.CACHED_FREQ

    @staticmethod
    def dopplerFactor(value):
        pass

    @staticmethod
    def dopplerVelocity(value):
        pass

    @staticmethod
    def speedOfSound(value):
        pass

    @staticmethod
    def distanceModel(distanceModel):
        pass

    @staticmethod
    def enable(capability):
        pass

    @staticmethod
    def disable(capability):
        pass

    @staticmethod
    def isEnabled(capability):
        return False

    @staticmethod
    def getBooleanv(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getIntegerv(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getFloatv(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getDoublev(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getString(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getBoolean(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getInteger(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getFloat(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getDouble(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getError():
        return 0

    @staticmethod
    def loadExtensions():
        pass

    @staticmethod
    def isExtensionPresent(extname):
        return False

    @staticmethod
    def getEnumValue(ename):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def listenerf(param,value):
        pass

    @staticmethod
    def listener3f(param,value1,value2,value3):
        pass

    @staticmethod
    def listenerfv(param,values):
        pass

    @staticmethod
    def listeneri(param,value):
        pass

    @staticmethod
    def listener3i(param,value1,value2,value3):
        pass

    @staticmethod
    def listeneriv(param,values):
        pass

    @staticmethod
    def getListenerf(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getListener3f(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getListenerfv(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getListeneri(param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getListener3i(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getListeneriv(param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def genSources(n,sources):
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = hxd_snd_openal_Source().id
            sources.b[pos] = (v & 255)
            sources.b[(pos + 1)] = ((v >> 8) & 255)
            sources.b[(pos + 2)] = ((v >> 16) & 255)
            sources.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)

    @staticmethod
    def deleteSources(n,sources):
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = (((sources.b[pos] | ((sources.b[(pos + 1)] << 8))) | ((sources.b[(pos + 2)] << 16))) | ((sources.b[(pos + 3)] << 24)))
            hxd_snd_openal_Source.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None).dispose()

    @staticmethod
    def isSource(source):
        return (source is not None)

    @staticmethod
    def sourcef(source,param,value):
        param1 = param
        if (param1 == 4099):
            pass
        elif (param1 == 4106):
            source.volume = value
        elif (((param1 == 4131) or ((param1 == 4129))) or ((param1 == 4128))):
            pass
        elif (param1 == 4132):
            tmp = None
            if (len(source.buffers) == 0):
                tmp = 0
            else:
                x = (value * source.frequency)
                try:
                    tmp = int(x)
                except BaseException as _g:
                    None
                    tmp = None
            source.currentSample = tmp
            if (source.chan is not None):
                source.stop(True)
                source.play()
        else:
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def source3f(source,param,value1,value2,value3):
        param1 = param
        if (((param1 == 4102) or ((param1 == 4101))) or ((param1 == 4100))):
            pass
        else:
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def sourcefv(source,param,values):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def sourcei(source,param,value):
        param1 = param
        if (param1 == 514):
            pass
        elif (param1 == 4103):
            source.loop = (value != 0)
        elif (param1 == 4105):
            b = hxd_snd_openal_Buffer.all.h.get(value,None)
            source.buffers = ([] if ((b is None)) else [b])
            source.updateDuration()
            source.currentSample = 0
        elif (param1 == 4133):
            x = (hxd_snd_openal_Emulator.getSourcef(source,4132) / source.frequency)
            tmp = None
            try:
                tmp = int(x)
            except BaseException as _g:
                None
                tmp = None
            source.currentSample = tmp
            if (source.chan is not None):
                source.stop(True)
                source.play()
        elif (param1 == 131077):
            pass
        else:
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def source3i(source,param,value1,value2,value3):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def sourceiv(source,param,values):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getSourcef(source,param):
        if (param == 4132):
            if (len(source.buffers) == 0):
                return 0
            now = python_lib_Timeit.default_timer()
            t = (now - source.playedTime)
            maxT = source.duration
            if source.loop:
                while (t > maxT):
                    t = (t - maxT)
                    source.playedTime = (source.playedTime + maxT)
            elif (t > maxT):
                t = maxT
            return t
        else:
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getSourcei(source,param):
        param1 = param
        if (param1 == 4112):
            if (((source.chan is None) or ((len(source.buffers) == 0))) or (((not source.loop) and (((python_lib_Timeit.default_timer() - source.playedTime) >= source.duration))))):
                return 4116
            else:
                return 4114
        elif (param1 == 4118):
            if source.loop:
                return 0
            count = 0
            cur = source.currentSample
            _g = 0
            _g1 = source.buffers
            while (_g < len(_g1)):
                b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (cur >= b.samples):
                    cur = (cur - b.samples)
                    count = (count + 1)
                else:
                    break
            return count
        elif (param1 == 4133):
            x = (hxd_snd_openal_Emulator.getSourcef(source,4132) * source.frequency)
            try:
                return int(x)
            except BaseException as _g:
                None
                return None
        else:
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getSource3f(source,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getSourcefv(source,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getSource3i(source,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getSourceiv(source,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourcePlayv(n,sources):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourceStopv(n,sources):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourceRewindv(n,sources):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourcePausev(n,sources):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourcePlay(source):
        source.play()

    @staticmethod
    def sourceStop(source):
        source.stop()
        source.currentSample = 0

    @staticmethod
    def sourceRewind(source):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourcePause(source):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def sourceQueueBuffers(source,nb,buffers):
        _g = 0
        _g1 = nb
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i * 4)
            v = (((buffers.b[pos] | ((buffers.b[(pos + 1)] << 8))) | ((buffers.b[(pos + 2)] << 16))) | ((buffers.b[(pos + 3)] << 24)))
            b = hxd_snd_openal_Buffer.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None)
            if (b is None):
                raise haxe_Exception.thrown("assert")
            _this = source.buffers
            _this.append(b)
        source.updateDuration()

    @staticmethod
    def sourceUnqueueBuffers(source,nb,buffers):
        _g = 0
        _g1 = nb
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i * 4)
            v = (((buffers.b[pos] | ((buffers.b[(pos + 1)] << 8))) | ((buffers.b[(pos + 2)] << 16))) | ((buffers.b[(pos + 3)] << 24)))
            b = hxd_snd_openal_Buffer.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None)
            if (b != (source.buffers[0] if 0 < len(source.buffers) else None)):
                raise haxe_Exception.thrown("assert")
            if (source.chan is not None):
                if (source.currentSample < b.samples):
                    raise haxe_Exception.thrown("assert")
                _this = source.buffers
                if (len(_this) != 0):
                    _this.pop(0)
                source.currentSample = (source.currentSample - b.samples)
                source.playedTime = (source.playedTime + ((b.samples / b.frequency)))
            else:
                _this1 = source.buffers
                if (len(_this1) != 0):
                    _this1.pop(0)
            source.updateDuration()

    @staticmethod
    def genBuffers(n,buffers):
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = hxd_snd_openal_Buffer().id
            buffers.b[pos] = (v & 255)
            buffers.b[(pos + 1)] = ((v >> 8) & 255)
            buffers.b[(pos + 2)] = ((v >> 16) & 255)
            buffers.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)

    @staticmethod
    def deleteBuffers(n,buffers):
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = (((buffers.b[pos] | ((buffers.b[(pos + 1)] << 8))) | ((buffers.b[(pos + 2)] << 16))) | ((buffers.b[(pos + 3)] << 24)))
            hxd_snd_openal_Buffer.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None).dispose()

    @staticmethod
    def isBuffer(buffer):
        return (buffer is not None)

    @staticmethod
    def bufferData(buffer,format,data,size,freq):
        if (freq != hxd_snd_openal_Emulator.get_NATIVE_FREQ()):
            raise haxe_Exception.thrown(((("Unsupported frequency value: " + Std.string(freq)) + " should be ") + Std.string(hxd_snd_openal_Emulator.get_NATIVE_FREQ())))
        format1 = format
        if (format1 == 4352):
            bdata = buffer.alloc((size * 2))
            _g = 0
            _g1 = size
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                v = (data.b[i] / 255)
                bdata[(i << 1)] = v
                bdata[((i << 1) | 1)] = v
        elif (format1 == 4353):
            bdata = buffer.alloc(size)
            _g = 0
            _g1 = (size >> 1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                pos = (i << 1)
                v = (data.b[pos] | ((data.b[(pos + 1)] << 8)))
                v1 = (((v if ((((v & 32768)) == 0)) else (v | -65536))) / 32768)
                bdata[(i << 1)] = v1
                bdata[((i << 1) | 1)] = v1
        elif (format1 == 4354):
            bdata = buffer.alloc(size)
            _g = 0
            _g1 = size
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                v = (data.b[i] / 255)
                bdata[i] = v
        elif (format1 == 4355):
            bdata = buffer.alloc((size >> 1))
            _g = 0
            _g1 = (size >> 1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                pos = (i << 1)
                v = (data.b[pos] | ((data.b[(pos + 1)] << 8)))
                v1 = (((v if ((((v & 32768)) == 0)) else (v | -65536))) / 32768)
                bdata[i] = v1
        elif (format1 == 4368):
            bdata = buffer.alloc((size >> 1))
            _g = 0
            _g1 = (size >> 2)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                f = data.getFloat((i << 2))
                bdata[(i << 1)] = f
                bdata[((i << 1) | 1)] = f
        elif (format1 == 4369):
            bdata = buffer.alloc((size >> 2))
            _g = 0
            _g1 = (size >> 2)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                this1 = buffer.data
                val = data.getFloat((i << 2))
                this1[i] = val
        else:
            raise haxe_Exception.thrown(("Format not supported 0x" + HxOverrides.stringOrNull(StringTools.hex(format))))
        buffer.samples = (len(buffer.data) >> 1)
        buffer.frequency = freq

    @staticmethod
    def bufferf(buffer,param,value):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def buffer3f(buffer,param,value1,value2,value3):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def bufferfv(buffer,param,values):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def bufferi(buffer,param,value):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def buffer3i(buffer,param,value1,value2,value3):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def bufferiv(buffer,param,values):
        raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getBufferf(buffer,param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getBuffer3f(buffer,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getBufferfv(buffer,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getBufferi(buffer,param):
        param1 = param
        if (param1 == 8194):
            return 32
        elif (param1 == 8195):
            return 2
        elif (param1 == 8196):
            return (len(buffer.data) * 4)
        else:
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getBuffer3i(buffer,param,values):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getBufferiv(buffer,param,values):
        raise haxe_Exception.thrown("TODO")
hxd_snd_openal_Emulator._hx_class = hxd_snd_openal_Emulator
_hx_classes["hxd.snd.openal.Emulator"] = hxd_snd_openal_Emulator


class hxd_snd_openal_Device:
    _hx_class_name = "hxd.snd.openal.Device"
    _hx_is_interface = "False"
    __slots__ = ()

    def __init__(self):
        pass
hxd_snd_openal_Device._hx_class = hxd_snd_openal_Device
_hx_classes["hxd.snd.openal.Device"] = hxd_snd_openal_Device


class hxd_snd_openal_Context:
    _hx_class_name = "hxd.snd.openal.Context"
    _hx_is_interface = "False"
    __slots__ = ("device",)
    _hx_fields = ["device"]

    def __init__(self,d):
        self.device = d

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.device = None
hxd_snd_openal_Context._hx_class = hxd_snd_openal_Context
_hx_classes["hxd.snd.openal.Context"] = hxd_snd_openal_Context


class hxd_snd_openal_ALC:
    _hx_class_name = "hxd.snd.openal.ALC"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ctx", "getError", "createContext", "makeContextCurrent", "processContext", "suspendContext", "destroyContext", "getCurrentContext", "getContextsDevice", "openDevice", "closeDevice", "loadExtensions", "isExtensionPresent", "getEnumValue", "getString", "getIntegerv", "FALSE", "TRUE", "FREQUENCY", "REFRESH", "SYNC", "MONO_SOURCES", "STEREO_SOURCES", "NO_ERROR", "INVALID_DEVICE", "INVALID_CONTEXT", "INVALID_ENUM", "INVALID_VALUE", "OUT_OF_MEMORY", "MAJOR_VERSION", "MINOR_VERSION", "ATTRIBUTES_SIZE", "ALL_ATTRIBUTES", "DEFAULT_DEVICE_SPECIFIER", "DEVICE_SPECIFIER", "EXTENSIONS", "EXT_CAPTURE", "CAPTURE_DEVICE_SPECIFIER", "CAPTURE_DEFAULT_DEVICE_SPECIFIER", "CAPTURE_SAMPLES", "ENUMERATE_ALL_EXT", "DEFAULT_ALL_DEVICES_SPECIFIER", "ALL_DEVICES_SPECIFIER"]

    @staticmethod
    def getError(device):
        return 0

    @staticmethod
    def createContext(device,attrlist):
        return hxd_snd_openal_Context(device)

    @staticmethod
    def makeContextCurrent(context):
        hxd_snd_openal_ALC.ctx = context
        return True

    @staticmethod
    def processContext(context):
        pass

    @staticmethod
    def suspendContext(context):
        pass

    @staticmethod
    def destroyContext(context):
        pass

    @staticmethod
    def getCurrentContext():
        return hxd_snd_openal_ALC.ctx

    @staticmethod
    def getContextsDevice(context):
        return hxd_snd_openal_ALC.ctx.device

    @staticmethod
    def openDevice(devicename):
        return hxd_snd_openal_Device()

    @staticmethod
    def closeDevice(device):
        return True

    @staticmethod
    def loadExtensions(alDevice):
        pass

    @staticmethod
    def isExtensionPresent(device,extname):
        return False

    @staticmethod
    def getEnumValue(device,enumname):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getString(device,param):
        raise haxe_Exception.thrown("TODO")

    @staticmethod
    def getIntegerv(device,param,size,values):
        if (param != 131075):
            raise haxe_Exception.thrown(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))
hxd_snd_openal_ALC._hx_class = hxd_snd_openal_ALC
_hx_classes["hxd.snd.openal.ALC"] = hxd_snd_openal_ALC


class hxd_snd_openal_EFX:
    _hx_class_name = "hxd.snd.openal.EFX"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["EFX_MAJOR_VERSION", "EFX_MINOR_VERSION", "MAX_AUXILIARY_SENDS", "METERS_PER_UNIT", "DIRECT_FILTER", "FILTER_NULL"]
hxd_snd_openal_EFX._hx_class = hxd_snd_openal_EFX
_hx_classes["hxd.snd.openal.EFX"] = hxd_snd_openal_EFX

class hxsl_Type(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Type"
    _hx_constructs = ["TVoid", "TInt", "TBool", "TFloat", "TString", "TVec", "TMat3", "TMat4", "TMat3x4", "TBytes", "TSampler2D", "TSampler2DArray", "TSamplerCube", "TStruct", "TFun", "TArray", "TBuffer", "TChannel", "TMat2"]

    @staticmethod
    def TVec(size,t):
        return hxsl_Type("TVec", 5, (size,t))

    @staticmethod
    def TBytes(size):
        return hxsl_Type("TBytes", 9, (size,))

    @staticmethod
    def TStruct(vl):
        return hxsl_Type("TStruct", 13, (vl,))

    @staticmethod
    def TFun(variants):
        return hxsl_Type("TFun", 14, (variants,))

    @staticmethod
    def TArray(t,size):
        return hxsl_Type("TArray", 15, (t,size))

    @staticmethod
    def TBuffer(t,size):
        return hxsl_Type("TBuffer", 16, (t,size))

    @staticmethod
    def TChannel(size):
        return hxsl_Type("TChannel", 17, (size,))
hxsl_Type.TVoid = hxsl_Type("TVoid", 0, ())
hxsl_Type.TInt = hxsl_Type("TInt", 1, ())
hxsl_Type.TBool = hxsl_Type("TBool", 2, ())
hxsl_Type.TFloat = hxsl_Type("TFloat", 3, ())
hxsl_Type.TString = hxsl_Type("TString", 4, ())
hxsl_Type.TMat3 = hxsl_Type("TMat3", 6, ())
hxsl_Type.TMat4 = hxsl_Type("TMat4", 7, ())
hxsl_Type.TMat3x4 = hxsl_Type("TMat3x4", 8, ())
hxsl_Type.TSampler2D = hxsl_Type("TSampler2D", 10, ())
hxsl_Type.TSampler2DArray = hxsl_Type("TSampler2DArray", 11, ())
hxsl_Type.TSamplerCube = hxsl_Type("TSamplerCube", 12, ())
hxsl_Type.TMat2 = hxsl_Type("TMat2", 18, ())
hxsl_Type._hx_class = hxsl_Type
_hx_classes["hxsl.Type"] = hxsl_Type

class hxsl_VecType(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.VecType"
    _hx_constructs = ["VInt", "VFloat", "VBool"]
hxsl_VecType.VInt = hxsl_VecType("VInt", 0, ())
hxsl_VecType.VFloat = hxsl_VecType("VFloat", 1, ())
hxsl_VecType.VBool = hxsl_VecType("VBool", 2, ())
hxsl_VecType._hx_class = hxsl_VecType
_hx_classes["hxsl.VecType"] = hxsl_VecType

class hxsl_SizeDecl(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.SizeDecl"
    _hx_constructs = ["SConst", "SVar"]

    @staticmethod
    def SConst(v):
        return hxsl_SizeDecl("SConst", 0, (v,))

    @staticmethod
    def SVar(v):
        return hxsl_SizeDecl("SVar", 1, (v,))
hxsl_SizeDecl._hx_class = hxsl_SizeDecl
_hx_classes["hxsl.SizeDecl"] = hxsl_SizeDecl


class hxsl_Error:
    _hx_class_name = "hxsl.Error"
    _hx_is_interface = "False"
    __slots__ = ("msg", "pos")
    _hx_fields = ["msg", "pos"]
    _hx_methods = ["toString"]
    _hx_statics = ["t"]

    def __init__(self,msg,pos):
        self.msg = msg
        self.pos = pos

    def toString(self):
        return ((("Error(" + HxOverrides.stringOrNull(self.msg)) + ")@") + Std.string(self.pos))

    @staticmethod
    def t(msg,pos):
        raise haxe_Exception.thrown(hxsl_Error(msg,pos))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.msg = None
        _hx_o.pos = None
hxsl_Error._hx_class = hxsl_Error
_hx_classes["hxsl.Error"] = hxsl_Error

class hxsl_VarKind(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.VarKind"
    _hx_constructs = ["Global", "Input", "Param", "Var", "Local", "Output", "Function"]
hxsl_VarKind.Global = hxsl_VarKind("Global", 0, ())
hxsl_VarKind.Input = hxsl_VarKind("Input", 1, ())
hxsl_VarKind.Param = hxsl_VarKind("Param", 2, ())
hxsl_VarKind.Var = hxsl_VarKind("Var", 3, ())
hxsl_VarKind.Local = hxsl_VarKind("Local", 4, ())
hxsl_VarKind.Output = hxsl_VarKind("Output", 5, ())
hxsl_VarKind.Function = hxsl_VarKind("Function", 6, ())
hxsl_VarKind._hx_class = hxsl_VarKind
_hx_classes["hxsl.VarKind"] = hxsl_VarKind

class hxsl_VarQualifier(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.VarQualifier"
    _hx_constructs = ["Const", "Private", "Nullable", "PerObject", "Name", "Shared", "Precision", "Range", "Ignore", "PerInstance", "Doc", "Borrow", "Sampler"]

    @staticmethod
    def Const(max = None):
        return hxsl_VarQualifier("Const", 0, (max,))

    @staticmethod
    def Name(n):
        return hxsl_VarQualifier("Name", 4, (n,))

    @staticmethod
    def Precision(p):
        return hxsl_VarQualifier("Precision", 6, (p,))

    @staticmethod
    def Range(min,max):
        return hxsl_VarQualifier("Range", 7, (min,max))

    @staticmethod
    def PerInstance(v):
        return hxsl_VarQualifier("PerInstance", 9, (v,))

    @staticmethod
    def Doc(s):
        return hxsl_VarQualifier("Doc", 10, (s,))

    @staticmethod
    def Borrow(source):
        return hxsl_VarQualifier("Borrow", 11, (source,))

    @staticmethod
    def Sampler(name):
        return hxsl_VarQualifier("Sampler", 12, (name,))
hxsl_VarQualifier.Private = hxsl_VarQualifier("Private", 1, ())
hxsl_VarQualifier.Nullable = hxsl_VarQualifier("Nullable", 2, ())
hxsl_VarQualifier.PerObject = hxsl_VarQualifier("PerObject", 3, ())
hxsl_VarQualifier.Shared = hxsl_VarQualifier("Shared", 5, ())
hxsl_VarQualifier.Ignore = hxsl_VarQualifier("Ignore", 8, ())
hxsl_VarQualifier._hx_class = hxsl_VarQualifier
_hx_classes["hxsl.VarQualifier"] = hxsl_VarQualifier

class hxsl_Prec(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Prec"
    _hx_constructs = ["Low", "Medium", "High"]
hxsl_Prec.Low = hxsl_Prec("Low", 0, ())
hxsl_Prec.Medium = hxsl_Prec("Medium", 1, ())
hxsl_Prec.High = hxsl_Prec("High", 2, ())
hxsl_Prec._hx_class = hxsl_Prec
_hx_classes["hxsl.Prec"] = hxsl_Prec

class hxsl_Const(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Const"
    _hx_constructs = ["CNull", "CBool", "CInt", "CFloat", "CString"]

    @staticmethod
    def CBool(b):
        return hxsl_Const("CBool", 1, (b,))

    @staticmethod
    def CInt(v):
        return hxsl_Const("CInt", 2, (v,))

    @staticmethod
    def CFloat(v):
        return hxsl_Const("CFloat", 3, (v,))

    @staticmethod
    def CString(v):
        return hxsl_Const("CString", 4, (v,))
hxsl_Const.CNull = hxsl_Const("CNull", 0, ())
hxsl_Const._hx_class = hxsl_Const
_hx_classes["hxsl.Const"] = hxsl_Const

class hxsl_ExprDef(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.ExprDef"
    _hx_constructs = ["EConst", "EIdent", "EParenthesis", "EField", "EBinop", "EUnop", "ECall", "EBlock", "EVars", "EFunction", "EIf", "EDiscard", "EFor", "EReturn", "EBreak", "EContinue", "EArray", "EArrayDecl", "ESwitch", "EWhile", "EMeta"]

    @staticmethod
    def EConst(c):
        return hxsl_ExprDef("EConst", 0, (c,))

    @staticmethod
    def EIdent(i):
        return hxsl_ExprDef("EIdent", 1, (i,))

    @staticmethod
    def EParenthesis(e):
        return hxsl_ExprDef("EParenthesis", 2, (e,))

    @staticmethod
    def EField(e,f):
        return hxsl_ExprDef("EField", 3, (e,f))

    @staticmethod
    def EBinop(op,e1,e2):
        return hxsl_ExprDef("EBinop", 4, (op,e1,e2))

    @staticmethod
    def EUnop(op,e1):
        return hxsl_ExprDef("EUnop", 5, (op,e1))

    @staticmethod
    def ECall(e,args):
        return hxsl_ExprDef("ECall", 6, (e,args))

    @staticmethod
    def EBlock(el):
        return hxsl_ExprDef("EBlock", 7, (el,))

    @staticmethod
    def EVars(v):
        return hxsl_ExprDef("EVars", 8, (v,))

    @staticmethod
    def EFunction(f):
        return hxsl_ExprDef("EFunction", 9, (f,))

    @staticmethod
    def EIf(econd,eif,eelse):
        return hxsl_ExprDef("EIf", 10, (econd,eif,eelse))

    @staticmethod
    def EFor(v,loop,block):
        return hxsl_ExprDef("EFor", 12, (v,loop,block))

    @staticmethod
    def EReturn(e = None):
        return hxsl_ExprDef("EReturn", 13, (e,))

    @staticmethod
    def EArray(e,eindex):
        return hxsl_ExprDef("EArray", 16, (e,eindex))

    @staticmethod
    def EArrayDecl(el):
        return hxsl_ExprDef("EArrayDecl", 17, (el,))

    @staticmethod
    def ESwitch(e,cases,_hx_def):
        return hxsl_ExprDef("ESwitch", 18, (e,cases,_hx_def))

    @staticmethod
    def EWhile(cond,loop,normalWhile):
        return hxsl_ExprDef("EWhile", 19, (cond,loop,normalWhile))

    @staticmethod
    def EMeta(name,args,e):
        return hxsl_ExprDef("EMeta", 20, (name,args,e))
hxsl_ExprDef.EDiscard = hxsl_ExprDef("EDiscard", 11, ())
hxsl_ExprDef.EBreak = hxsl_ExprDef("EBreak", 14, ())
hxsl_ExprDef.EContinue = hxsl_ExprDef("EContinue", 15, ())
hxsl_ExprDef._hx_class = hxsl_ExprDef
_hx_classes["hxsl.ExprDef"] = hxsl_ExprDef

class hxsl_FunctionKind(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.FunctionKind"
    _hx_constructs = ["Vertex", "Fragment", "Init", "Helper"]
hxsl_FunctionKind.Vertex = hxsl_FunctionKind("Vertex", 0, ())
hxsl_FunctionKind.Fragment = hxsl_FunctionKind("Fragment", 1, ())
hxsl_FunctionKind.Init = hxsl_FunctionKind("Init", 2, ())
hxsl_FunctionKind.Helper = hxsl_FunctionKind("Helper", 3, ())
hxsl_FunctionKind._hx_class = hxsl_FunctionKind
_hx_classes["hxsl.FunctionKind"] = hxsl_FunctionKind

class hxsl_TGlobal(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.TGlobal"
    _hx_constructs = ["Radians", "Degrees", "Sin", "Cos", "Tan", "Asin", "Acos", "Atan", "Pow", "Exp", "Log", "Exp2", "Log2", "Sqrt", "Inversesqrt", "Abs", "Sign", "Floor", "Ceil", "Fract", "Mod", "Min", "Max", "Clamp", "Mix", "Step", "Smoothstep", "Length", "Distance", "Dot", "Cross", "Normalize", "LReflect", "Texture", "TextureLod", "Texel", "TextureSize", "ToInt", "ToFloat", "ToBool", "Vec2", "Vec3", "Vec4", "IVec2", "IVec3", "IVec4", "BVec2", "BVec3", "BVec4", "Mat2", "Mat3", "Mat4", "Mat3x4", "Saturate", "Pack", "Unpack", "PackNormal", "UnpackNormal", "ScreenToUv", "UvToScreen", "DFdx", "DFdy", "Fwidth", "ChannelRead", "ChannelReadLod", "ChannelFetch", "ChannelTextureSize", "Trace", "VertexID", "InstanceID", "FragCoord", "FrontFacing"]
hxsl_TGlobal.Radians = hxsl_TGlobal("Radians", 0, ())
hxsl_TGlobal.Degrees = hxsl_TGlobal("Degrees", 1, ())
hxsl_TGlobal.Sin = hxsl_TGlobal("Sin", 2, ())
hxsl_TGlobal.Cos = hxsl_TGlobal("Cos", 3, ())
hxsl_TGlobal.Tan = hxsl_TGlobal("Tan", 4, ())
hxsl_TGlobal.Asin = hxsl_TGlobal("Asin", 5, ())
hxsl_TGlobal.Acos = hxsl_TGlobal("Acos", 6, ())
hxsl_TGlobal.Atan = hxsl_TGlobal("Atan", 7, ())
hxsl_TGlobal.Pow = hxsl_TGlobal("Pow", 8, ())
hxsl_TGlobal.Exp = hxsl_TGlobal("Exp", 9, ())
hxsl_TGlobal.Log = hxsl_TGlobal("Log", 10, ())
hxsl_TGlobal.Exp2 = hxsl_TGlobal("Exp2", 11, ())
hxsl_TGlobal.Log2 = hxsl_TGlobal("Log2", 12, ())
hxsl_TGlobal.Sqrt = hxsl_TGlobal("Sqrt", 13, ())
hxsl_TGlobal.Inversesqrt = hxsl_TGlobal("Inversesqrt", 14, ())
hxsl_TGlobal.Abs = hxsl_TGlobal("Abs", 15, ())
hxsl_TGlobal.Sign = hxsl_TGlobal("Sign", 16, ())
hxsl_TGlobal.Floor = hxsl_TGlobal("Floor", 17, ())
hxsl_TGlobal.Ceil = hxsl_TGlobal("Ceil", 18, ())
hxsl_TGlobal.Fract = hxsl_TGlobal("Fract", 19, ())
hxsl_TGlobal.Mod = hxsl_TGlobal("Mod", 20, ())
hxsl_TGlobal.Min = hxsl_TGlobal("Min", 21, ())
hxsl_TGlobal.Max = hxsl_TGlobal("Max", 22, ())
hxsl_TGlobal.Clamp = hxsl_TGlobal("Clamp", 23, ())
hxsl_TGlobal.Mix = hxsl_TGlobal("Mix", 24, ())
hxsl_TGlobal.Step = hxsl_TGlobal("Step", 25, ())
hxsl_TGlobal.Smoothstep = hxsl_TGlobal("Smoothstep", 26, ())
hxsl_TGlobal.Length = hxsl_TGlobal("Length", 27, ())
hxsl_TGlobal.Distance = hxsl_TGlobal("Distance", 28, ())
hxsl_TGlobal.Dot = hxsl_TGlobal("Dot", 29, ())
hxsl_TGlobal.Cross = hxsl_TGlobal("Cross", 30, ())
hxsl_TGlobal.Normalize = hxsl_TGlobal("Normalize", 31, ())
hxsl_TGlobal.LReflect = hxsl_TGlobal("LReflect", 32, ())
hxsl_TGlobal.Texture = hxsl_TGlobal("Texture", 33, ())
hxsl_TGlobal.TextureLod = hxsl_TGlobal("TextureLod", 34, ())
hxsl_TGlobal.Texel = hxsl_TGlobal("Texel", 35, ())
hxsl_TGlobal.TextureSize = hxsl_TGlobal("TextureSize", 36, ())
hxsl_TGlobal.ToInt = hxsl_TGlobal("ToInt", 37, ())
hxsl_TGlobal.ToFloat = hxsl_TGlobal("ToFloat", 38, ())
hxsl_TGlobal.ToBool = hxsl_TGlobal("ToBool", 39, ())
hxsl_TGlobal.Vec2 = hxsl_TGlobal("Vec2", 40, ())
hxsl_TGlobal.Vec3 = hxsl_TGlobal("Vec3", 41, ())
hxsl_TGlobal.Vec4 = hxsl_TGlobal("Vec4", 42, ())
hxsl_TGlobal.IVec2 = hxsl_TGlobal("IVec2", 43, ())
hxsl_TGlobal.IVec3 = hxsl_TGlobal("IVec3", 44, ())
hxsl_TGlobal.IVec4 = hxsl_TGlobal("IVec4", 45, ())
hxsl_TGlobal.BVec2 = hxsl_TGlobal("BVec2", 46, ())
hxsl_TGlobal.BVec3 = hxsl_TGlobal("BVec3", 47, ())
hxsl_TGlobal.BVec4 = hxsl_TGlobal("BVec4", 48, ())
hxsl_TGlobal.Mat2 = hxsl_TGlobal("Mat2", 49, ())
hxsl_TGlobal.Mat3 = hxsl_TGlobal("Mat3", 50, ())
hxsl_TGlobal.Mat4 = hxsl_TGlobal("Mat4", 51, ())
hxsl_TGlobal.Mat3x4 = hxsl_TGlobal("Mat3x4", 52, ())
hxsl_TGlobal.Saturate = hxsl_TGlobal("Saturate", 53, ())
hxsl_TGlobal.Pack = hxsl_TGlobal("Pack", 54, ())
hxsl_TGlobal.Unpack = hxsl_TGlobal("Unpack", 55, ())
hxsl_TGlobal.PackNormal = hxsl_TGlobal("PackNormal", 56, ())
hxsl_TGlobal.UnpackNormal = hxsl_TGlobal("UnpackNormal", 57, ())
hxsl_TGlobal.ScreenToUv = hxsl_TGlobal("ScreenToUv", 58, ())
hxsl_TGlobal.UvToScreen = hxsl_TGlobal("UvToScreen", 59, ())
hxsl_TGlobal.DFdx = hxsl_TGlobal("DFdx", 60, ())
hxsl_TGlobal.DFdy = hxsl_TGlobal("DFdy", 61, ())
hxsl_TGlobal.Fwidth = hxsl_TGlobal("Fwidth", 62, ())
hxsl_TGlobal.ChannelRead = hxsl_TGlobal("ChannelRead", 63, ())
hxsl_TGlobal.ChannelReadLod = hxsl_TGlobal("ChannelReadLod", 64, ())
hxsl_TGlobal.ChannelFetch = hxsl_TGlobal("ChannelFetch", 65, ())
hxsl_TGlobal.ChannelTextureSize = hxsl_TGlobal("ChannelTextureSize", 66, ())
hxsl_TGlobal.Trace = hxsl_TGlobal("Trace", 67, ())
hxsl_TGlobal.VertexID = hxsl_TGlobal("VertexID", 68, ())
hxsl_TGlobal.InstanceID = hxsl_TGlobal("InstanceID", 69, ())
hxsl_TGlobal.FragCoord = hxsl_TGlobal("FragCoord", 70, ())
hxsl_TGlobal.FrontFacing = hxsl_TGlobal("FrontFacing", 71, ())
hxsl_TGlobal._hx_class = hxsl_TGlobal
_hx_classes["hxsl.TGlobal"] = hxsl_TGlobal

class hxsl_Component(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Component"
    _hx_constructs = ["X", "Y", "Z", "W"]
hxsl_Component.X = hxsl_Component("X", 0, ())
hxsl_Component.Y = hxsl_Component("Y", 1, ())
hxsl_Component.Z = hxsl_Component("Z", 2, ())
hxsl_Component.W = hxsl_Component("W", 3, ())
hxsl_Component._hx_class = hxsl_Component
_hx_classes["hxsl.Component"] = hxsl_Component

class hxsl_TExprDef(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.TExprDef"
    _hx_constructs = ["TConst", "TVar", "TGlobal", "TParenthesis", "TBlock", "TBinop", "TUnop", "TVarDecl", "TCall", "TSwiz", "TIf", "TDiscard", "TReturn", "TFor", "TContinue", "TBreak", "TArray", "TArrayDecl", "TSwitch", "TWhile", "TMeta"]

    @staticmethod
    def TConst(c):
        return hxsl_TExprDef("TConst", 0, (c,))

    @staticmethod
    def TVar(v):
        return hxsl_TExprDef("TVar", 1, (v,))

    @staticmethod
    def TGlobal(g):
        return hxsl_TExprDef("TGlobal", 2, (g,))

    @staticmethod
    def TParenthesis(e):
        return hxsl_TExprDef("TParenthesis", 3, (e,))

    @staticmethod
    def TBlock(el):
        return hxsl_TExprDef("TBlock", 4, (el,))

    @staticmethod
    def TBinop(op,e1,e2):
        return hxsl_TExprDef("TBinop", 5, (op,e1,e2))

    @staticmethod
    def TUnop(op,e1):
        return hxsl_TExprDef("TUnop", 6, (op,e1))

    @staticmethod
    def TVarDecl(v,init = None):
        return hxsl_TExprDef("TVarDecl", 7, (v,init))

    @staticmethod
    def TCall(e,args):
        return hxsl_TExprDef("TCall", 8, (e,args))

    @staticmethod
    def TSwiz(e,regs):
        return hxsl_TExprDef("TSwiz", 9, (e,regs))

    @staticmethod
    def TIf(econd,eif,eelse):
        return hxsl_TExprDef("TIf", 10, (econd,eif,eelse))

    @staticmethod
    def TReturn(e = None):
        return hxsl_TExprDef("TReturn", 12, (e,))

    @staticmethod
    def TFor(v,it,loop):
        return hxsl_TExprDef("TFor", 13, (v,it,loop))

    @staticmethod
    def TArray(e,index):
        return hxsl_TExprDef("TArray", 16, (e,index))

    @staticmethod
    def TArrayDecl(el):
        return hxsl_TExprDef("TArrayDecl", 17, (el,))

    @staticmethod
    def TSwitch(e,cases,_hx_def):
        return hxsl_TExprDef("TSwitch", 18, (e,cases,_hx_def))

    @staticmethod
    def TWhile(e,loop,normalWhile):
        return hxsl_TExprDef("TWhile", 19, (e,loop,normalWhile))

    @staticmethod
    def TMeta(m,args,e):
        return hxsl_TExprDef("TMeta", 20, (m,args,e))
hxsl_TExprDef.TDiscard = hxsl_TExprDef("TDiscard", 11, ())
hxsl_TExprDef.TContinue = hxsl_TExprDef("TContinue", 14, ())
hxsl_TExprDef.TBreak = hxsl_TExprDef("TBreak", 15, ())
hxsl_TExprDef._hx_class = hxsl_TExprDef
_hx_classes["hxsl.TExprDef"] = hxsl_TExprDef


class hxsl_Tools:
    _hx_class_name = "hxsl.Tools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["UID", "SWIZ", "MAX_CHANNELS_BITS", "allocVarId", "getName", "getDoc", "getConstBits", "isConst", "isStruct", "isArray", "hasQualifier", "hasBorrowQualifier", "isSampler", "toString", "toType", "hasSideEffect", "iter", "map", "size", "evalConst"]

    @staticmethod
    def allocVarId():
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = hxsl_Tools
                _hx_local_1 = _hx_local_0.UID
                _hx_local_0.UID = (_hx_local_1 + 1)
                return _hx_local_0.UID
            return _hx_local_2()
        return _hx_local_3()

    @staticmethod
    def getName(v):
        if (Reflect.field(v,"qualifiers") is None):
            return v.name
        _g = 0
        _g1 = Reflect.field(v,"qualifiers")
        while (_g < len(_g1)):
            q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (q.index == 4):
                n = q.params[0]
                return n
        return v.name

    @staticmethod
    def getDoc(v):
        if (Reflect.field(v,"qualifiers") is None):
            return None
        _g = 0
        _g1 = Reflect.field(v,"qualifiers")
        while (_g < len(_g1)):
            q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (q.index == 10):
                s = q.params[0]
                return s
        return None

    @staticmethod
    def getConstBits(v):
        _g = v.type
        tmp = _g.index
        if (tmp == 1):
            _g1 = 0
            _g2 = Reflect.field(v,"qualifiers")
            while (_g1 < len(_g2)):
                q = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                if (q.index == 0):
                    n = q.params[0]
                    if (n is not None):
                        bits = 0
                        while (n >= ((1 << bits))):
                            bits = (bits + 1)
                        return bits
                    return 8
        elif (tmp == 2):
            return 1
        elif (tmp == 17):
            _g1 = _g.params[0]
            return (3 + hxsl_Tools.MAX_CHANNELS_BITS)
        else:
            pass
        return 0

    @staticmethod
    def isConst(v):
        _g = v.type
        tmp = None
        if (_g.index == 17):
            _g1 = _g.params[0]
            tmp = True
        else:
            tmp = False
        if tmp:
            return True
        if (Reflect.field(v,"qualifiers") is not None):
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (q.index == 0):
                    _g2 = q.params[0]
                    return True
        return False

    @staticmethod
    def isStruct(v):
        _g = v.type
        if (_g.index == 13):
            _g1 = _g.params[0]
            return True
        else:
            return False

    @staticmethod
    def isArray(v):
        _g = v.type
        if (_g.index == 15):
            _g1 = _g.params[0]
            _g1 = _g.params[1]
            return True
        else:
            return False

    @staticmethod
    def hasQualifier(v,q):
        if (Reflect.field(v,"qualifiers") is not None):
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (q2 == q):
                    return True
        return False

    @staticmethod
    def hasBorrowQualifier(v,path):
        if (Reflect.field(v,"qualifiers") is not None):
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (q.index == 11):
                    s = q.params[0]
                    return (path == s)
        return False

    @staticmethod
    def isSampler(t):
        tmp = t.index
        if (((tmp == 12) or ((tmp == 11))) or ((tmp == 10))):
            return True
        elif (tmp == 17):
            _g = t.params[0]
            return True
        else:
            return False

    @staticmethod
    def toString(t):
        tmp = t.index
        if (tmp == 5):
            size = t.params[0]
            t1 = t.params[1]
            prefix = None
            prefix1 = t1.index
            if (prefix1 == 0):
                prefix = "I"
            elif (prefix1 == 1):
                prefix = ""
            elif (prefix1 == 2):
                prefix = "B"
            else:
                pass
            return ((("null" if prefix is None else prefix) + "Vec") + Std.string(size))
        elif (tmp == 9):
            n = t.params[0]
            return ("Bytes" + Std.string(n))
        elif (tmp == 13):
            vl = t.params[0]
            _g = []
            _g1 = 0
            while (_g1 < len(vl)):
                v = (vl[_g1] if _g1 >= 0 and _g1 < len(vl) else None)
                _g1 = (_g1 + 1)
                x = ((HxOverrides.stringOrNull(v.name) + " : ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v.type)))
                _g.append(x)
            return (("{" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))) + "}")
        elif (tmp == 15):
            t1 = t.params[0]
            s = t.params[1]
            tmp = (HxOverrides.stringOrNull(hxsl_Tools.toString(t1)) + "[")
            tmp1 = None
            tmp2 = s.index
            if (tmp2 == 0):
                i = s.params[0]
                tmp1 = ("" + Std.string(i))
            elif (tmp2 == 1):
                v = s.params[0]
                tmp1 = v.name
            else:
                pass
            return ((("null" if tmp is None else tmp) + ("null" if tmp1 is None else tmp1)) + "]")
        elif (tmp == 16):
            t1 = t.params[0]
            s = t.params[1]
            tmp = (("buffer " + HxOverrides.stringOrNull(hxsl_Tools.toString(t1))) + "[")
            tmp1 = None
            tmp2 = s.index
            if (tmp2 == 0):
                i = s.params[0]
                tmp1 = ("" + Std.string(i))
            elif (tmp2 == 1):
                v = s.params[0]
                tmp1 = v.name
            else:
                pass
            return ((("null" if tmp is None else tmp) + ("null" if tmp1 is None else tmp1)) + "]")
        else:
            return HxString.substr(t.tag,1,None)

    @staticmethod
    def toType(t):
        tmp = t.index
        if (tmp == 0):
            return hxsl_Type.TInt
        elif (tmp == 1):
            return hxsl_Type.TFloat
        elif (tmp == 2):
            return hxsl_Type.TBool
        else:
            pass

    @staticmethod
    def hasSideEffect(e):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            _g1 = _g.params[0]
            return False
        elif (tmp == 1):
            _g1 = _g.params[0]
            return False
        elif (tmp == 2):
            _g1 = _g.params[0]
            return False
        elif (tmp == 3):
            e = _g.params[0]
            return hxsl_Tools.hasSideEffect(e)
        elif (tmp == 4):
            el = _g.params[0]
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                if hxsl_Tools.hasSideEffect(e):
                    return True
            return False
        elif (tmp == 5):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g.params[2]
            tmp = _g1.index
            if (tmp == 4):
                return True
            elif (tmp == 20):
                _g4 = _g1.params[0]
                return True
            else:
                e1 = _g2
                e2 = _g3
                if (not hxsl_Tools.hasSideEffect(e1)):
                    return hxsl_Tools.hasSideEffect(e2)
                else:
                    return True
        elif (tmp == 6):
            _g1 = _g.params[0]
            e1 = _g.params[1]
            return hxsl_Tools.hasSideEffect(e1)
        elif (tmp == 7):
            _g1 = _g.params[0]
            _g1 = _g.params[1]
            return True
        elif (tmp == 8):
            e = _g.params[0]
            pl = _g.params[1]
            _g1 = e.e
            tmp = None
            if (_g1.index == 2):
                _g2 = _g1.params[0]
                tmp = True
            else:
                tmp = False
            if (not tmp):
                return True
            _g1 = 0
            while (_g1 < len(pl)):
                p = (pl[_g1] if _g1 >= 0 and _g1 < len(pl) else None)
                _g1 = (_g1 + 1)
                if hxsl_Tools.hasSideEffect(p):
                    return True
            return False
        elif (tmp == 9):
            _g1 = _g.params[1]
            e = _g.params[0]
            return hxsl_Tools.hasSideEffect(e)
        elif (tmp == 10):
            econd = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            if (not ((hxsl_Tools.hasSideEffect(econd) or hxsl_Tools.hasSideEffect(eif)))):
                if (eelse is not None):
                    return hxsl_Tools.hasSideEffect(eelse)
                else:
                    return False
            else:
                return True
        elif (((tmp == 15) or ((tmp == 14))) or ((tmp == 11))):
            return True
        elif (tmp == 12):
            _g1 = _g.params[0]
            return True
        elif (tmp == 13):
            _g1 = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            if (not hxsl_Tools.hasSideEffect(it)):
                return hxsl_Tools.hasSideEffect(loop)
            else:
                return True
        elif (tmp == 16):
            e = _g.params[0]
            index = _g.params[1]
            if (not hxsl_Tools.hasSideEffect(e)):
                return hxsl_Tools.hasSideEffect(index)
            else:
                return True
        elif (tmp == 17):
            el = _g.params[0]
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                if hxsl_Tools.hasSideEffect(e):
                    return True
            return False
        elif (tmp == 18):
            e = _g.params[0]
            cases = _g.params[1]
            _hx_def = _g.params[2]
            _g1 = 0
            while (_g1 < len(cases)):
                c = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
                _g1 = (_g1 + 1)
                _g2 = 0
                _g3 = c.values
                while (_g2 < len(_g3)):
                    v = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if hxsl_Tools.hasSideEffect(v):
                        return True
                if hxsl_Tools.hasSideEffect(c.expr):
                    return True
            if (not hxsl_Tools.hasSideEffect(e)):
                if (_hx_def is not None):
                    return hxsl_Tools.hasSideEffect(_hx_def)
                else:
                    return False
            else:
                return True
        elif (tmp == 19):
            _g1 = _g.params[2]
            e = _g.params[0]
            loop = _g.params[1]
            if (not hxsl_Tools.hasSideEffect(e)):
                return hxsl_Tools.hasSideEffect(loop)
            else:
                return True
        elif (tmp == 20):
            _g1 = _g.params[0]
            _g1 = _g.params[1]
            e = _g.params[2]
            return hxsl_Tools.hasSideEffect(e)
        else:
            pass

    @staticmethod
    def iter(e,f):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            _g1 = _g.params[0]
        elif (tmp == 1):
            _g1 = _g.params[0]
        elif (tmp == 2):
            _g1 = _g.params[0]
        elif (tmp == 3):
            e = _g.params[0]
            f(e)
        elif (tmp == 4):
            el = _g.params[0]
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                f(e)
        elif (tmp == 5):
            _g1 = _g.params[0]
            e1 = _g.params[1]
            e2 = _g.params[2]
            f(e1)
            f(e2)
        elif (tmp == 6):
            _g1 = _g.params[0]
            e1 = _g.params[1]
            f(e1)
        elif (tmp == 7):
            _g1 = _g.params[0]
            init = _g.params[1]
            if (init is not None):
                f(init)
        elif (tmp == 8):
            e = _g.params[0]
            args = _g.params[1]
            f(e)
            _g1 = 0
            while (_g1 < len(args)):
                a = (args[_g1] if _g1 >= 0 and _g1 < len(args) else None)
                _g1 = (_g1 + 1)
                f(a)
        elif (tmp == 9):
            _g1 = _g.params[1]
            e = _g.params[0]
            f(e)
        elif (tmp == 10):
            econd = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            f(econd)
            f(eif)
            if (eelse is not None):
                f(eelse)
        elif (((tmp == 15) or ((tmp == 14))) or ((tmp == 11))):
            pass
        elif (tmp == 12):
            e = _g.params[0]
            if (e is not None):
                f(e)
        elif (tmp == 13):
            _g1 = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            f(it)
            f(loop)
        elif (tmp == 16):
            e = _g.params[0]
            index = _g.params[1]
            f(e)
            f(index)
        elif (tmp == 17):
            el = _g.params[0]
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                f(e)
        elif (tmp == 18):
            e = _g.params[0]
            cases = _g.params[1]
            _hx_def = _g.params[2]
            f(e)
            _g1 = 0
            while (_g1 < len(cases)):
                c = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
                _g1 = (_g1 + 1)
                _g2 = 0
                _g3 = c.values
                while (_g2 < len(_g3)):
                    v = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    f(v)
                f(c.expr)
            if (_hx_def is not None):
                f(_hx_def)
        elif (tmp == 19):
            _g1 = _g.params[2]
            e = _g.params[0]
            loop = _g.params[1]
            f(e)
            f(loop)
        elif (tmp == 20):
            _g1 = _g.params[0]
            _g1 = _g.params[1]
            e = _g.params[2]
            f(e)
        else:
            pass

    @staticmethod
    def map(e,f):
        ed = None
        _g = e.e
        ed1 = _g.index
        if (ed1 == 0):
            _g1 = _g.params[0]
            ed = e.e
        elif (ed1 == 1):
            _g1 = _g.params[0]
            ed = e.e
        elif (ed1 == 2):
            _g1 = _g.params[0]
            ed = e.e
        elif (ed1 == 3):
            e1 = _g.params[0]
            ed = hxsl_TExprDef.TParenthesis(f(e1))
        elif (ed1 == 4):
            el = _g.params[0]
            _g1 = []
            _g2 = 0
            while (_g2 < len(el)):
                e1 = (el[_g2] if _g2 >= 0 and _g2 < len(el) else None)
                _g2 = (_g2 + 1)
                x = f(e1)
                _g1.append(x)
            ed = hxsl_TExprDef.TBlock(_g1)
        elif (ed1 == 5):
            op = _g.params[0]
            e1 = _g.params[1]
            e2 = _g.params[2]
            ed = hxsl_TExprDef.TBinop(op,f(e1),f(e2))
        elif (ed1 == 6):
            op = _g.params[0]
            e1 = _g.params[1]
            ed = hxsl_TExprDef.TUnop(op,f(e1))
        elif (ed1 == 7):
            v = _g.params[0]
            init = _g.params[1]
            ed = hxsl_TExprDef.TVarDecl(v,(f(init) if ((init is not None)) else None))
        elif (ed1 == 8):
            e1 = _g.params[0]
            args = _g.params[1]
            ed1 = f(e1)
            _g1 = []
            _g2 = 0
            while (_g2 < len(args)):
                a = (args[_g2] if _g2 >= 0 and _g2 < len(args) else None)
                _g2 = (_g2 + 1)
                x = f(a)
                _g1.append(x)
            ed = hxsl_TExprDef.TCall(ed1,_g1)
        elif (ed1 == 9):
            e1 = _g.params[0]
            c = _g.params[1]
            ed = hxsl_TExprDef.TSwiz(f(e1),c)
        elif (ed1 == 10):
            econd = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            ed = hxsl_TExprDef.TIf(f(econd),f(eif),(f(eelse) if ((eelse is not None)) else None))
        elif (((ed1 == 15) or ((ed1 == 14))) or ((ed1 == 11))):
            ed = e.e
        elif (ed1 == 12):
            e1 = _g.params[0]
            ed = hxsl_TExprDef.TReturn((f(e1) if ((e1 is not None)) else None))
        elif (ed1 == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            ed = hxsl_TExprDef.TFor(v,f(it),f(loop))
        elif (ed1 == 16):
            e1 = _g.params[0]
            index = _g.params[1]
            ed = hxsl_TExprDef.TArray(f(e1),f(index))
        elif (ed1 == 17):
            el = _g.params[0]
            _g1 = []
            _g2 = 0
            while (_g2 < len(el)):
                e1 = (el[_g2] if _g2 >= 0 and _g2 < len(el) else None)
                _g2 = (_g2 + 1)
                x = f(e1)
                _g1.append(x)
            ed = hxsl_TExprDef.TArrayDecl(_g1)
        elif (ed1 == 18):
            e1 = _g.params[0]
            cases = _g.params[1]
            _hx_def = _g.params[2]
            ed1 = f(e1)
            _g1 = []
            _g2 = 0
            while (_g2 < len(cases)):
                c = (cases[_g2] if _g2 >= 0 and _g2 < len(cases) else None)
                _g2 = (_g2 + 1)
                _g3 = []
                _g4 = 0
                _g5 = c.values
                while (_g4 < len(_g5)):
                    v = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                    _g4 = (_g4 + 1)
                    x = f(v)
                    _g3.append(x)
                x1 = _hx_AnonObject({'values': _g3, 'expr': f(c.expr)})
                _g1.append(x1)
            ed = hxsl_TExprDef.TSwitch(ed1,_g1,(None if ((_hx_def is None)) else f(_hx_def)))
        elif (ed1 == 19):
            e1 = _g.params[0]
            loop = _g.params[1]
            normalWhile = _g.params[2]
            ed = hxsl_TExprDef.TWhile(f(e1),f(loop),normalWhile)
        elif (ed1 == 20):
            m = _g.params[0]
            args = _g.params[1]
            e1 = _g.params[2]
            ed = hxsl_TExprDef.TMeta(m,args,f(e1))
        else:
            pass
        return _hx_AnonObject({'e': ed, 't': e.t, 'p': e.p})

    @staticmethod
    def size(t):
        tmp = t.index
        if (tmp == 0):
            return 0
        elif ((tmp == 3) or ((tmp == 1))):
            return 1
        elif (((((tmp == 12) or ((tmp == 11))) or ((tmp == 10))) or ((tmp == 4))) or ((tmp == 2))):
            return 0
        elif (tmp == 5):
            _g = t.params[1]
            n = t.params[0]
            return n
        elif (tmp == 6):
            return 9
        elif (tmp == 7):
            return 16
        elif (tmp == 8):
            return 12
        elif (tmp == 9):
            s = t.params[0]
            return s
        elif (tmp == 13):
            vl = t.params[0]
            s = 0
            _g = 0
            while (_g < len(vl)):
                v = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                s = (s + hxsl_Tools.size(v.type))
            return s
        elif (tmp == 14):
            _g = t.params[0]
            return 0
        elif (tmp == 15):
            _g = t.params[0]
            _g1 = t.params[1]
            tmp = _g1.index
            if (tmp == 0):
                v = _g1.params[0]
                t1 = _g
                return (hxsl_Tools.size(t1) * v)
            elif (tmp == 1):
                _g = _g1.params[0]
                return 0
            else:
                pass
        elif (tmp == 16):
            _g = t.params[1]
            if (_g.index == 0):
                v = _g.params[0]
                t1 = t.params[0]
                return (hxsl_Tools.size(t1) * v)
            else:
                return 0
        elif (tmp == 17):
            n = t.params[0]
            return n
        elif (tmp == 18):
            return 4
        else:
            pass

    @staticmethod
    def evalConst(e):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            c = _g.params[0]
            tmp = c.index
            if (tmp == 0):
                return None
            elif (tmp == 1):
                b = c.params[0]
                return b
            elif (tmp == 2):
                i = c.params[0]
                return i
            elif (tmp == 3):
                f = c.params[0]
                return f
            elif (tmp == 4):
                s = c.params[0]
                return s
            else:
                pass
        elif (tmp == 8):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g = _g1.e
            _g3 = _g1.p
            _g3 = _g1.t
            if (_g.index == 2):
                tmp = _g.params[0].index
                if (((tmp == 42) or ((tmp == 41))) or ((tmp == 40))):
                    args = _g2
                    _g = []
                    _g1 = 0
                    while (_g1 < len(args)):
                        a = (args[_g1] if _g1 >= 0 and _g1 < len(args) else None)
                        _g1 = (_g1 + 1)
                        x = hxsl_Tools.evalConst(a)
                        _g.append(x)
                    vals = _g
                    if (len(vals) == 1):
                        return h3d_Vector((vals[0] if 0 < len(vals) else None),(vals[0] if 0 < len(vals) else None),(vals[0] if 0 < len(vals) else None),(vals[0] if 0 < len(vals) else None))
                    return h3d_Vector((vals[0] if 0 < len(vals) else None),(vals[1] if 1 < len(vals) else None),(vals[2] if 2 < len(vals) else None),(vals[3] if 3 < len(vals) else None))
                else:
                    raise haxe_Exception.thrown(("Unhandled constant init " + HxOverrides.stringOrNull(hxsl_Printer.toString(e))))
            else:
                raise haxe_Exception.thrown(("Unhandled constant init " + HxOverrides.stringOrNull(hxsl_Printer.toString(e))))
        else:
            raise haxe_Exception.thrown(("Unhandled constant init " + HxOverrides.stringOrNull(hxsl_Printer.toString(e))))
hxsl_Tools._hx_class = hxsl_Tools
_hx_classes["hxsl.Tools"] = hxsl_Tools


class hxsl_Tools2:
    _hx_class_name = "hxsl.Tools2"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(g):
        n = g.tag
        return (HxOverrides.stringOrNull(("" if ((0 >= len(n))) else n[0]).lower()) + HxOverrides.stringOrNull(HxString.substr(n,1,None)))
hxsl_Tools2._hx_class = hxsl_Tools2
_hx_classes["hxsl.Tools2"] = hxsl_Tools2


class hxsl_Tools3:
    _hx_class_name = "hxsl.Tools3"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(s):
        return hxsl_Printer.shaderToString(s)
hxsl_Tools3._hx_class = hxsl_Tools3
_hx_classes["hxsl.Tools3"] = hxsl_Tools3


class hxsl_Tools4:
    _hx_class_name = "hxsl.Tools4"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(e):
        return hxsl_Printer.toString(e)
hxsl_Tools4._hx_class = hxsl_Tools4
_hx_classes["hxsl.Tools4"] = hxsl_Tools4


class hxsl_BatchShader(hxsl_Shader):
    _hx_class_name = "hxsl.BatchShader"
    _hx_is_interface = "False"
    __slots__ = ("Batch_Count__", "Batch_Buffer__")
    _hx_fields = ["Batch_Count__", "Batch_Buffer__"]
    _hx_methods = ["get_Batch_Count", "set_Batch_Count", "get_Batch_Buffer", "set_Batch_Buffer", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.Batch_Buffer__ = None
        self.Batch_Count__ = 0
        super().__init__()

    def get_Batch_Count(self):
        return self.Batch_Count__

    def set_Batch_Count(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.Batch_Count__ = _v
                return self.Batch_Count__
            return _hx_local_0()
        return _hx_local_1()

    def get_Batch_Buffer(self):
        return self.Batch_Buffer__

    def set_Batch_Buffer(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.Batch_Buffer__ = _v
                return self.Batch_Buffer__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.Batch_Count__
        if (HxOverrides.rshift(v, 17) != 0):
            raise haxe_Exception.thrown((((("Batch_Count" + " is out of range ") + Std.string(v)) + ">") + Std.string(131071)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.Batch_Count__
        elif (index1 == 1):
            return self.Batch_Buffer__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(hxsl_BatchShader)
        s.shader = self.shader
        s.Batch_Count__ = self.Batch_Count__
        s.Batch_Buffer__ = self.Batch_Buffer__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.Batch_Count__ = None
        _hx_o.Batch_Buffer__ = None
hxsl_BatchShader._hx_class = hxsl_BatchShader
_hx_classes["hxsl.BatchShader"] = hxsl_BatchShader


class hxsl_SearchMap:
    _hx_class_name = "hxsl.SearchMap"
    _hx_is_interface = "False"
    __slots__ = ("linked", "next")
    _hx_fields = ["linked", "next"]

    def __init__(self):
        self.next = None
        self.linked = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.linked = None
        _hx_o.next = None
hxsl_SearchMap._hx_class = hxsl_SearchMap
_hx_classes["hxsl.SearchMap"] = hxsl_SearchMap


class hxsl_Cache:
    _hx_class_name = "hxsl.Cache"
    _hx_is_interface = "False"
    __slots__ = ("linkCache", "linkShaders", "batchShaders", "byID", "constsToGlobal")
    _hx_fields = ["linkCache", "linkShaders", "batchShaders", "byID", "constsToGlobal"]
    _hx_methods = ["getLinkShader", "link", "compileRuntimeShader", "buildRuntimeShader", "initGlobals", "getPath", "flattenShader", "makeBatchShader", "createBatchShader"]
    _hx_statics = ["INST", "get", "set", "clear"]

    def __init__(self):
        self.constsToGlobal = False
        self.linkCache = hxsl_SearchMap()
        self.linkShaders = haxe_ds_StringMap()
        self.batchShaders = haxe_ds_IntMap()
        self.byID = haxe_ds_StringMap()

    def getLinkShader(self,vars):
        _g = []
        _g1 = 0
        while (_g1 < len(vars)):
            v = (vars[_g1] if _g1 >= 0 and _g1 < len(vars) else None)
            _g1 = (_g1 + 1)
            x = Std.string(v)
            _g.append(x)
        key = ",".join([python_Boot.toString1(x1,'') for x1 in _g])
        shader = self.linkShaders.h.get(key,None)
        if (shader is not None):
            return shader
        s = hxsl_SharedShader("")
        id = HxString.substr(haxe_crypto_Md5.encode(key),0,8)
        s.data = _hx_AnonObject({'name': ("shaderLinker_" + ("null" if id is None else id)), 'vars': [], 'funs': []})
        pos = None
        outVars = haxe_ds_StringMap()
        outputCount = 0
        tvec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat)
        def _hx_local_2(g,size,args,makeOutExpr):
            out = []
            rem = size
            _g = 0
            _g1 = len(args)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                e = makeOutExpr(python_internal_ArrayImpl._get(args, ((len(args) - 1) - i)),(rem - (((len(args) - 1) - i))))
                rem = (rem - hxsl_Tools.size(e.t))
                out.insert(0, e)
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(g), 't': hxsl_Type.TVoid, 'p': pos}),out), 't': hxsl_Type.TVec(size,hxsl_VecType.VFloat), 'p': pos})
        makeVec = _hx_local_2
        def _hx_local_3(name,t,parent):
            path = (name if ((parent is None)) else ((HxOverrides.stringOrNull(hxsl_Tools.getName(parent)) + ".") + ("null" if name is None else name)))
            v = outVars.h.get(path,None)
            if (v is not None):
                return v
            v = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': name, 'type': t, 'kind': hxsl_VarKind.Var, 'parent': parent})
            if (parent is None):
                _this = s.data.vars
                _this.append(v)
            else:
                _g = parent.type
                if (_g.index == 13):
                    vl = _g.params[0]
                    vl.append(v)
                else:
                    raise haxe_Exception.thrown("assert")
            outVars.h[path] = v
            return v
        makeVar = _hx_local_3
        makeOutExpr = None
        def _hx_local_4(v,rem):
            makeOutExpr1 = v.index
            if (makeOutExpr1 == 0):
                v1 = v.params[0]
                return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CFloat(v1)), 't': hxsl_Type.TFloat, 'p': pos})
            elif (makeOutExpr1 == 1):
                vname = v.params[0]
                size = v.params[1]
                v1 = outVars.h.get(vname,None)
                if (v1 is not None):
                    return _hx_AnonObject({'e': hxsl_TExprDef.TVar(v1), 't': v1.type, 'p': pos})
                path = vname.split(".")
                parent = None
                while (len(path) > 1):
                    parent = makeVar((None if ((len(path) == 0)) else path.pop(0)),hxsl_Type.TStruct([]),parent)
                if (size is not None):
                    rem = size
                v1 = makeVar((None if ((len(path) == 0)) else path.pop(0)),(hxsl_Type.TFloat if ((rem == 1)) else hxsl_Type.TVec(rem,hxsl_VecType.VFloat)),parent)
                return _hx_AnonObject({'e': hxsl_TExprDef.TVar(v1), 't': v1.type, 'p': pos})
            elif (makeOutExpr1 == 2):
                v1 = v.params[0]
                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.PackNormal), 't': hxsl_Type.TVoid, 'p': pos}),[makeOutExpr(v1,3)]), 't': tvec4, 'p': pos})
            elif (makeOutExpr1 == 3):
                v1 = v.params[0]
                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Pack), 't': hxsl_Type.TVoid, 'p': pos}),[makeOutExpr(v1,1)]), 't': tvec4, 'p': pos})
            elif (makeOutExpr1 == 4):
                args = v.params[0]
                return makeVec(hxsl_TGlobal.Vec2,2,args,makeOutExpr)
            elif (makeOutExpr1 == 5):
                args = v.params[0]
                return makeVec(hxsl_TGlobal.Vec3,3,args,makeOutExpr)
            elif (makeOutExpr1 == 6):
                args = v.params[0]
                return makeVec(hxsl_TGlobal.Vec4,4,args,makeOutExpr)
            elif (makeOutExpr1 == 7):
                v1 = v.params[0]
                comps = v.params[1]
                return _hx_AnonObject({'e': hxsl_TExprDef.TSwiz(makeOutExpr(v1,4),comps), 't': hxsl_Type.TVec(len(comps),hxsl_VecType.VFloat), 'p': pos})
            else:
                pass
        makeOutExpr = _hx_local_4
        def _hx_local_6(v):
            nonlocal outputCount
            outputCount = (outputCount + 1)
            ov = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'type': tvec4, 'name': ("OUTPUT" + Std.string(((outputCount - 1)))), 'kind': hxsl_VarKind.Output})
            _this = s.data.vars
            _this.append(ov)
            return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,_hx_AnonObject({'e': hxsl_TExprDef.TVar(ov), 't': tvec4, 'p': pos}),makeOutExpr(v,4)), 't': hxsl_Type.TVoid, 'p': pos})
        makeOutput = _hx_local_6
        def _hx_local_8(kind,vars):
            fv = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'type': hxsl_Type.TFun([]), 'name': ("" + Std.string(kind)).lower(), 'kind': hxsl_VarKind.Function})
            _g = []
            _g1 = 0
            while (_g1 < len(vars)):
                v = (vars[_g1] if _g1 >= 0 and _g1 < len(vars) else None)
                _g1 = (_g1 + 1)
                x = makeOutput(v)
                _g.append(x)
            f = _hx_AnonObject({'kind': kind, 'ref': fv, 'args': [], 'ret': hxsl_Type.TVoid, 'expr': _hx_AnonObject({'e': hxsl_TExprDef.TBlock(_g), 'p': pos, 't': hxsl_Type.TVoid})})
            _this = s.data.funs
            _this.append(f)
        defineFun = _hx_local_8
        defineFun(hxsl_FunctionKind.Vertex,[hxsl_Output.Value("output.position")])
        defineFun(hxsl_FunctionKind.Fragment,vars)
        shader = Type.createEmptyInstance(hxsl_Shader)
        shader.shader = s
        self.linkShaders.h[key] = shader
        shader.updateConstantsFinal(None)
        return shader

    def link(self,shaders,batchMode):
        c = self.linkCache
        _g_l = shaders
        _g_last = None
        while (_g_l != _g_last):
            s = _g_l.s
            _g_l = _g_l.next
            s1 = s
            i = s1.instance
            if (c.next is None):
                c.next = haxe_ds_IntMap()
            cs = c.next.h.get(i.id,None)
            if (cs is None):
                cs = hxsl_SearchMap()
                c.next.set(i.id,cs)
            c = cs
        if (c.linked is None):
            c.linked = self.compileRuntimeShader(shaders,batchMode)
        return c.linked

    def compileRuntimeShader(self,shaders,batchMode):
        shaderDatas = []
        index = 0
        _g_l = shaders
        _g_last = None
        while (_g_l != _g_last):
            s = _g_l.s
            _g_l = _g_l.next
            s1 = s
            i = s1.instance
            x = index
            index = (index + 1)
            x1 = _hx_AnonObject({'inst': i, 'p': s1.priority, 'index': x})
            shaderDatas.append(x1)
        shaderDatas.reverse()
        def _hx_local_0(s1,s2):
            return (s2.p - s1.p)
        haxe_ds_ArraySort.sort(shaderDatas,_hx_local_0)
        linker = hxsl_Linker(batchMode)
        s = None
        try:
            _g = []
            _g1 = 0
            while (_g1 < len(shaderDatas)):
                s1 = (shaderDatas[_g1] if _g1 >= 0 and _g1 < len(shaderDatas) else None)
                _g1 = (_g1 + 1)
                x = s1.inst.shader
                _g.append(x)
            s = linker.link(_g)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,hxsl_Error):
                e = _g1
                _g1 = []
                _g2 = 0
                while (_g2 < len(shaderDatas)):
                    s1 = (shaderDatas[_g2] if _g2 >= 0 and _g2 < len(shaderDatas) else None)
                    _g2 = (_g2 + 1)
                    x = hxsl_Printer.shaderToString(s1.inst.shader)
                    _g1.append(x)
                shaders1 = _g1
                e.msg = (HxOverrides.stringOrNull(e.msg) + HxOverrides.stringOrNull((("\n\nin\n\n" + HxOverrides.stringOrNull("\n-----\n".join([python_Boot.toString1(x1,'') for x1 in shaders1]))))))
                raise haxe_Exception.thrown(e)
            else:
                raise _g
        if batchMode:
            checkRec = None
            def _hx_local_5(v):
                if ((Reflect.field(v,"qualifiers") is not None) and ((python_internal_ArrayImpl.indexOf(Reflect.field(v,"qualifiers"),hxsl_VarQualifier.PerObject,None) >= 0))):
                    if (len(Reflect.field(v,"qualifiers")) == 1):
                        Reflect.setField(v,"qualifiers",None)
                    else:
                        Reflect.setField(v,"qualifiers",list(Reflect.field(v,"qualifiers")))
                        python_internal_ArrayImpl.remove(Reflect.field(v,"qualifiers"),hxsl_VarQualifier.PerObject)
                    if (v.kind != hxsl_VarKind.Var):
                        v.kind = hxsl_VarKind.Local
                _g = v.type
                if (_g.index == 13):
                    vl = _g.params[0]
                    _g = 0
                    while (_g < len(vl)):
                        v = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                        _g = (_g + 1)
                        checkRec(v)
            checkRec = _hx_local_5
            _g = 0
            _g1 = s.vars
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                checkRec(v)
        paramVars = haxe_ds_IntMap()
        _g = 0
        _g1 = linker.allVars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (v.v.kind == hxsl_VarKind.Param):
                _g2 = v.v.type
                if (_g2.index == 13):
                    _g3 = _g2.params[0]
                    continue
                inf = python_internal_ArrayImpl._get(shaderDatas, v.instanceIndex)
                paramVars.set(v.id,_hx_AnonObject({'instance': inf.index, 'index': inf.inst.params.h.get((v.merged[0] if 0 < len(v.merged) else None).id,None)}))
        prev = s
        s1 = None
        try:
            s1 = hxsl_Splitter().split(s)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,hxsl_Error):
                e = _g1
                e.msg = (HxOverrides.stringOrNull(e.msg) + HxOverrides.stringOrNull((("\n\nin\n\n" + HxOverrides.stringOrNull(hxsl_Printer.shaderToString(s))))))
                raise haxe_Exception.thrown(e)
            else:
                raise _g
        prev = s1
        s = hxsl_Dce().dce(s1.vertex,s1.fragment)
        r = self.buildRuntimeShader(s.vertex,s.fragment,paramVars)
        _g = []
        _g4_l = shaders
        _g4_last = None
        while (_g4_l != _g4_last):
            s = _g4_l.s
            _g4_l = _g4_l.next
            s1 = s
            x = hxsl_ShaderInstanceDesc(s1.shader,s1.constBits)
            _g.append(x)
        r.spec = _hx_AnonObject({'instances': _g, 'signature': None})
        _g = 0
        _g1 = len(shaderDatas)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            s = python_internal_ArrayImpl._get(shaderDatas, ((len(shaderDatas) - 1) - i))
            python_internal_ArrayImpl._get(r.spec.instances, s.index).index = i
        _g = []
        _g1 = 0
        _g2 = r.spec.instances
        while (_g1 < len(_g2)):
            i = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = ((((HxOverrides.stringOrNull(i.shader.data.name) + "_") + Std.string(i.bits)) + "_") + Std.string(i.index))
            _g.append(x)
        signParts = _g
        tmp = ":".join
        tmp1 = [python_Boot.toString1(x1,'') for x1 in signParts]
        r.spec.signature = haxe_crypto_Md5.encode(tmp(tmp1))
        r.signature = haxe_crypto_Md5.encode((HxOverrides.stringOrNull(hxsl_Printer.shaderToString(r.vertex.data)) + HxOverrides.stringOrNull(hxsl_Printer.shaderToString(r.fragment.data))))
        r.batchMode = batchMode
        r2 = self.byID.h.get(r.signature,None)
        if (r2 is not None):
            r.id = r2.id
        else:
            self.byID.h[r.signature] = r
        return r

    def buildRuntimeShader(self,vertex,fragment,paramVars):
        r = hxsl_RuntimeShader()
        r.vertex = self.flattenShader(vertex,hxsl_FunctionKind.Vertex,paramVars)
        r.vertex.vertex = True
        r.fragment = self.flattenShader(fragment,hxsl_FunctionKind.Fragment,paramVars)
        r.globals = haxe_ds_IntMap()
        self.initGlobals(r,r.vertex)
        self.initGlobals(r,r.fragment)
        return r

    def initGlobals(self,r,s):
        p = s.globals
        while (p is not None):
            r.globals.set(p.gid,True)
            p = p.next
        p = s.params
        while (p is not None):
            if (p.perObjectGlobal is not None):
                r.globals.set(p.perObjectGlobal.gid,True)
            p = p.next

    def getPath(self,v):
        if (Reflect.field(v,"parent") is None):
            return v.name
        return ((HxOverrides.stringOrNull(self.getPath(Reflect.field(v,"parent"))) + ".") + HxOverrides.stringOrNull(v.name))

    def flattenShader(self,s,kind,params):
        flat = hxsl_Flatten()
        c = hxsl_RuntimeShaderData()
        data = flat.flatten(s,kind,self.constsToGlobal)
        textures = []
        c.consts = flat.consts
        c.texturesCount = 0
        g = flat.allocData.keys()
        while g.hasNext():
            g1 = g.next()
            alloc = flat.allocData.h.get(g1,None)
            tmp = g1.kind.index
            if (tmp == 0):
                _g = []
                _g1 = 0
                while (_g1 < len(alloc)):
                    a = (alloc[_g1] if _g1 >= 0 and _g1 < len(alloc) else None)
                    _g1 = (_g1 + 1)
                    if (a.v is not None):
                        x = hxsl_AllocGlobal(a.pos,self.getPath(a.v),a.v.type)
                        _g.append(x)
                out = _g
                _g2 = 0
                _g3 = (len(out) - 1)
                while (_g2 < _g3):
                    i = _g2
                    _g2 = (_g2 + 1)
                    (out[i] if i >= 0 and i < len(out) else None).next = python_internal_ArrayImpl._get(out, (i + 1))
                _g4 = g1.type
                if (_g4.index == 15):
                    _g5 = _g4.params[0]
                    _g6 = _g4.params[1]
                    if (_g5.index == 5):
                        if (_g5.params[0] == 4):
                            if (_g5.params[1].index == 1):
                                if (_g6.index == 0):
                                    size = _g6.params[0]
                                    c.globals = (out[0] if 0 < len(out) else None)
                                    c.globalsSize = size
                                else:
                                    raise haxe_Exception.thrown("assert")
                            else:
                                raise haxe_Exception.thrown("assert")
                        else:
                            raise haxe_Exception.thrown("assert")
                    else:
                        raise haxe_Exception.thrown("assert")
                else:
                    raise haxe_Exception.thrown("assert")
            elif (tmp == 2):
                out1 = []
                count = 0
                _g7 = 0
                while (_g7 < len(alloc)):
                    a1 = (alloc[_g7] if _g7 >= 0 and _g7 < len(alloc) else None)
                    _g7 = (_g7 + 1)
                    if (a1.v is None):
                        continue
                    p = params.h.get(a1.v.id,None)
                    if (p is None):
                        ap = hxsl_AllocParam(a1.v.name,a1.pos,-1,-1,a1.v.type)
                        ap.perObjectGlobal = hxsl_AllocGlobal(-1,self.getPath(a1.v),a1.v.type)
                        out1.append(ap)
                        count = (count + 1)
                        continue
                    ap1 = hxsl_AllocParam(a1.v.name,a1.pos,p.instance,p.index,a1.v.type)
                    _g8 = a1.v.type
                    if (_g8.index == 15):
                        _g9 = _g8.params[1]
                        t = _g8.params[0]
                        if hxsl_Tools.isSampler(t):
                            ap1.pos = -a1.size
                            count = (count + a1.size)
                        else:
                            count = (count + 1)
                    else:
                        count = (count + 1)
                    out1.append(ap1)
                _g10 = 0
                _g11 = (len(out1) - 1)
                while (_g10 < _g11):
                    i1 = _g10
                    _g10 = (_g10 + 1)
                    (out1[i1] if i1 >= 0 and i1 < len(out1) else None).next = python_internal_ArrayImpl._get(out1, (i1 + 1))
                _g12 = g1.type
                if (_g12.index == 15):
                    _g13 = _g12.params[0]
                    _g14 = _g12.params[1]
                    t1 = _g13
                    if hxsl_Tools.isSampler(t1):
                        textures.append(_hx_AnonObject({'t': t1, 'all': out1}))
                        c.texturesCount = (c.texturesCount + count)
                    else:
                        tmp1 = _g13.index
                        if (tmp1 == 5):
                            if (_g13.params[0] == 4):
                                if (_g13.params[1].index == 1):
                                    if (_g14.index == 0):
                                        size1 = _g14.params[0]
                                        c.params = (out1[0] if 0 < len(out1) else None)
                                        c.paramsSize = size1
                                    else:
                                        raise haxe_Exception.thrown("assert")
                                else:
                                    raise haxe_Exception.thrown("assert")
                            else:
                                raise haxe_Exception.thrown("assert")
                        elif (tmp1 == 16):
                            _g15 = _g13.params[0]
                            _g16 = _g13.params[1]
                            c.buffers = (out1[0] if 0 < len(out1) else None)
                            c.bufferCount = len(out1)
                        else:
                            raise haxe_Exception.thrown("assert")
                else:
                    raise haxe_Exception.thrown("assert")
            else:
                raise haxe_Exception.thrown("assert")
        if (len(textures) > 0):
            def _hx_local_7(t1,t2):
                return (t1.t.index - t2.t.index)
            textures.sort(key= python_lib_Functools.cmp_to_key(_hx_local_7))
            c.textures = python_internal_ArrayImpl._get((textures[0] if 0 < len(textures) else None).all, 0)
            _g = 1
            _g1 = len(textures)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prevAll = python_internal_ArrayImpl._get(textures, (i - 1)).all
                prev = python_internal_ArrayImpl._get(prevAll, (len(prevAll) - 1))
                prev.next = python_internal_ArrayImpl._get((textures[i] if i >= 0 and i < len(textures) else None).all, 0)
        if (c.globals is None):
            c.globalsSize = 0
        if (c.params is None):
            c.paramsSize = 0
        if (c.buffers is None):
            c.bufferCount = 0
        c.data = data
        return c

    def makeBatchShader(self,rt):
        sh = self.batchShaders.h.get(rt.id,None)
        if (sh is None):
            sh = self.createBatchShader(rt)
            self.batchShaders.set(rt.id,sh)
        shader = Type.createEmptyInstance(hxsl_BatchShader)
        shader.shader = sh
        return shader

    def createBatchShader(self,rt):
        s = hxsl_SharedShader("")
        id = HxString.substr(rt.spec.signature,0,8)
        def _hx_local_0(name,t,kind):
            return _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'type': t, 'name': name, 'kind': kind})
        declVar = _hx_local_0
        pos = None
        vcount = declVar("Batch_Count",hxsl_Type.TInt,hxsl_VarKind.Param)
        vbuffer = declVar("Batch_Buffer",hxsl_Type.TBuffer(hxsl_Type.TVec(4,hxsl_VecType.VFloat),hxsl_SizeDecl.SVar(vcount)),hxsl_VarKind.Param)
        voffset = declVar("Batch_Offset",hxsl_Type.TInt,hxsl_VarKind.Local)
        ebuffer = _hx_AnonObject({'e': hxsl_TExprDef.TVar(vbuffer), 'p': pos, 't': vbuffer.type})
        eoffset = _hx_AnonObject({'e': hxsl_TExprDef.TVar(voffset), 'p': pos, 't': voffset.type})
        tvec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat)
        countBits = 16
        Reflect.setField(vcount,"qualifiers",[hxsl_VarQualifier.Const((1 << countBits))])
        s.data = _hx_AnonObject({'name': ("batchShader_" + ("null" if id is None else id)), 'vars': [vcount, vbuffer, voffset], 'funs': []})
        stride = (rt.vertex.paramsSize + rt.fragment.paramsSize)
        parentVars = haxe_ds_ObjectMap()
        swiz = [[hxsl_Component.X], [hxsl_Component.Y], [hxsl_Component.Z], [hxsl_Component.W]]
        def _hx_local_1(index):
            return _hx_AnonObject({'e': hxsl_TExprDef.TArray(ebuffer,_hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,eoffset,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos})), 't': tvec4, 'p': pos})
        readOffset = _hx_local_1
        def _hx_local_2(v,offset):
            vreal = declVar(v.name,v.type,hxsl_VarKind.Local)
            if (v.perObjectGlobal is not None):
                _this = v.perObjectGlobal.path
                path = _this.split(".")
                if (len(path) != 0):
                    path.pop()
                cur = vreal
                while (len(path) > 0):
                    key = ".".join([python_Boot.toString1(x1,'') for x1 in path])
                    name = (None if ((len(path) == 0)) else path.pop())
                    vp = parentVars.h.get(path,None)
                    if (vp is None):
                        vp = declVar(name,hxsl_Type.TStruct([]),hxsl_VarKind.Local)
                        parentVars.set(path,vp)
                    _g = vp.type
                    if (_g.index == 13):
                        vl = _g.params[0]
                        vl.append(cur)
                    Reflect.setField(cur,"parent",vp)
                    cur = vp
            _this = s.data.vars
            _this.append(vreal)
            index = (((v.pos >> 2)) + offset)
            extract = None
            _g = v.type
            extract1 = _g.index
            if (extract1 == 3):
                extract = _hx_AnonObject({'p': pos, 't': v.type, 'e': hxsl_TExprDef.TSwiz(readOffset(index),python_internal_ArrayImpl._get(swiz, (v.pos & 3)))})
            elif (extract1 == 5):
                _g1 = _g.params[1]
                _g2 = _g.params[0]
                if (_g2 == 2):
                    if (_g1.index == 1):
                        swiz1 = None
                        _g = (v.pos & 3)
                        if (_g == 0):
                            swiz1 = [hxsl_Component.X, hxsl_Component.Y]
                        elif (_g == 1):
                            swiz1 = [hxsl_Component.Y, hxsl_Component.Z]
                        else:
                            swiz1 = [hxsl_Component.Z, hxsl_Component.W]
                        extract = _hx_AnonObject({'p': pos, 't': v.type, 'e': hxsl_TExprDef.TSwiz(readOffset(index),swiz1)})
                    else:
                        raise haxe_Exception.thrown(("Unsupported batch var type " + Std.string(v.type)))
                elif (_g2 == 3):
                    if (_g1.index == 1):
                        extract = _hx_AnonObject({'p': pos, 't': v.type, 'e': hxsl_TExprDef.TSwiz(readOffset(index),([hxsl_Component.X, hxsl_Component.Y, hxsl_Component.Z] if ((((v.pos & 3)) == 0)) else [hxsl_Component.Y, hxsl_Component.Z, hxsl_Component.W]))})
                    else:
                        raise haxe_Exception.thrown(("Unsupported batch var type " + Std.string(v.type)))
                elif (_g2 == 4):
                    if (_g1.index == 1):
                        extract = readOffset(index)
                    else:
                        raise haxe_Exception.thrown(("Unsupported batch var type " + Std.string(v.type)))
                else:
                    raise haxe_Exception.thrown(("Unsupported batch var type " + Std.string(v.type)))
            elif (extract1 == 7):
                extract = _hx_AnonObject({'p': pos, 't': v.type, 'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4), 't': hxsl_Type.TVoid, 'p': pos}),[readOffset(index), readOffset((index + 1)), readOffset((index + 2)), readOffset((index + 3))])})
            else:
                raise haxe_Exception.thrown(("Unsupported batch var type " + Std.string(v.type)))
            return _hx_AnonObject({'p': pos, 'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,_hx_AnonObject({'e': hxsl_TExprDef.TVar(vreal), 'p': pos, 't': v.type}),extract), 't': hxsl_Type.TVoid})
        extractVar = _hx_local_2
        exprs = []
        p = rt.vertex.params
        while (p is not None):
            x = extractVar(p,0)
            exprs.append(x)
            p = p.next
        p = rt.fragment.params
        while (p is not None):
            x = extractVar(p,rt.vertex.paramsSize)
            exprs.append(x)
            p = p.next
        x = _hx_AnonObject({'p': pos, 'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,eoffset,_hx_AnonObject({'p': pos, 't': hxsl_Type.TInt, 'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpMult,_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.InstanceID), 't': hxsl_Type.TInt, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(stride)), 'p': pos, 't': hxsl_Type.TInt}))})), 't': hxsl_Type.TVoid})
        exprs.insert(0, x)
        fv = declVar("init",hxsl_Type.TFun([]),hxsl_VarKind.Function)
        f = _hx_AnonObject({'kind': hxsl_FunctionKind.Init, 'ref': fv, 'args': [], 'ret': hxsl_Type.TVoid, 'expr': _hx_AnonObject({'e': hxsl_TExprDef.TBlock(exprs), 'p': pos, 't': hxsl_Type.TVoid})})
        _this = s.data.funs
        _this.append(f)
        s.consts = hxsl_ShaderConst(vcount,0,countBits)
        s.consts.globalId = 0
        return s
    INST = None

    @staticmethod
    def get():
        c = hxsl_Cache.INST
        if (c is None):
            c = hxsl_Cache()
            hxsl_Cache.INST = c
        return c

    @staticmethod
    def set(c):
        hxsl_Cache.INST = c

    @staticmethod
    def clear():
        hxsl_Cache.INST = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.linkCache = None
        _hx_o.linkShaders = None
        _hx_o.batchShaders = None
        _hx_o.byID = None
        _hx_o.constsToGlobal = None
hxsl_Cache._hx_class = hxsl_Cache
_hx_classes["hxsl.Cache"] = hxsl_Cache

class hxsl_Channel(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Channel"
    _hx_constructs = ["Unknown", "R", "G", "B", "A", "PackedFloat", "PackedNormal"]
hxsl_Channel.Unknown = hxsl_Channel("Unknown", 0, ())
hxsl_Channel.R = hxsl_Channel("R", 1, ())
hxsl_Channel.G = hxsl_Channel("G", 2, ())
hxsl_Channel.B = hxsl_Channel("B", 3, ())
hxsl_Channel.A = hxsl_Channel("A", 4, ())
hxsl_Channel.PackedFloat = hxsl_Channel("PackedFloat", 5, ())
hxsl_Channel.PackedNormal = hxsl_Channel("PackedNormal", 6, ())
hxsl_Channel._hx_class = hxsl_Channel
_hx_classes["hxsl.Channel"] = hxsl_Channel


class hxsl_Clone:
    _hx_class_name = "hxsl.Clone"
    _hx_is_interface = "False"
    __slots__ = ("varMap",)
    _hx_fields = ["varMap"]
    _hx_methods = ["tvar", "tfun", "ttype", "texpr", "shader"]
    _hx_statics = ["shaderData"]

    def __init__(self):
        self.varMap = haxe_ds_IntMap()

    def tvar(self,v):
        v2 = self.varMap.h.get(v.id,None)
        if (v2 is not None):
            return v2
        v2 = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'type': v.type, 'name': v.name, 'kind': v.kind})
        self.varMap.set(v.id,v2)
        if (Reflect.field(v,"parent") is not None):
            Reflect.setField(v2,"parent",self.tvar(Reflect.field(v,"parent")))
        if (Reflect.field(v,"qualifiers") is not None):
            Reflect.setField(v2,"qualifiers",list(Reflect.field(v,"qualifiers")))
        v2.type = self.ttype(v.type)
        return v2

    def tfun(self,f):
        tmp = self.ttype(f.ret)
        f1 = f.kind
        tmp1 = self.tvar(f.ref)
        _g = []
        _g1 = 0
        _g2 = f.args
        while (_g1 < len(_g2)):
            a = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = self.tvar(a)
            _g.append(x)
        return _hx_AnonObject({'ret': tmp, 'kind': f1, 'ref': tmp1, 'args': _g, 'expr': self.texpr(f.expr)})

    def ttype(self,t):
        tmp = t.index
        if (tmp == 13):
            vl = t.params[0]
            _g = []
            _g1 = 0
            while (_g1 < len(vl)):
                v = (vl[_g1] if _g1 >= 0 and _g1 < len(vl) else None)
                _g1 = (_g1 + 1)
                x = self.tvar(v)
                _g.append(x)
            return hxsl_Type.TStruct(_g)
        elif (tmp == 14):
            vars = t.params[0]
            return hxsl_Type.TFun(vars)
        elif (tmp == 15):
            t1 = t.params[0]
            size = t.params[1]
            tmp = self.ttype(t1)
            tmp1 = None
            tmp2 = size.index
            if (tmp2 == 0):
                _g = size.params[0]
                tmp1 = size
            elif (tmp2 == 1):
                v = size.params[0]
                tmp1 = hxsl_SizeDecl.SVar(self.tvar(v))
            else:
                pass
            return hxsl_Type.TArray(tmp,tmp1)
        else:
            return t

    def texpr(self,e):
        e2 = hxsl_Tools.map(e,self.texpr)
        e2.t = self.ttype(e.t)
        _g = e2.e
        tmp = None
        tmp1 = _g.index
        if (tmp1 == 1):
            v = _g.params[0]
            tmp = hxsl_TExprDef.TVar(self.tvar(v))
        elif (tmp1 == 7):
            v = _g.params[0]
            init = _g.params[1]
            tmp = hxsl_TExprDef.TVarDecl(self.tvar(v),init)
        elif (tmp1 == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            tmp = hxsl_TExprDef.TFor(self.tvar(v),it,loop)
        else:
            tmp = e2.e
        e2.e = tmp
        return e2

    def shader(self,s):
        s1 = s.name
        _g = []
        _g1 = 0
        _g2 = s.vars
        while (_g1 < len(_g2)):
            v = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = self.tvar(v)
            _g.append(x)
        tmp = _g
        _g = []
        _g1 = 0
        _g2 = s.funs
        while (_g1 < len(_g2)):
            f = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = self.tfun(f)
            _g.append(x)
        return _hx_AnonObject({'name': s1, 'vars': tmp, 'funs': _g})

    @staticmethod
    def shaderData(s):
        return hxsl_Clone().shader(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.varMap = None
hxsl_Clone._hx_class = hxsl_Clone
_hx_classes["hxsl.Clone"] = hxsl_Clone


class hxsl__Dce_Exit:
    _hx_class_name = "hxsl._Dce.Exit"
    _hx_is_interface = "False"
    __slots__ = ()

    def __init__(self):
        pass
hxsl__Dce_Exit._hx_class = hxsl__Dce_Exit
_hx_classes["hxsl._Dce.Exit"] = hxsl__Dce_Exit


class hxsl__Dce_VarDeps:
    _hx_class_name = "hxsl._Dce.VarDeps"
    _hx_is_interface = "False"
    __slots__ = ("v", "keep", "used", "deps")
    _hx_fields = ["v", "keep", "used", "deps"]

    def __init__(self,v):
        self.keep = None
        self.v = v
        self.used = False
        self.deps = haxe_ds_IntMap()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.v = None
        _hx_o.keep = None
        _hx_o.used = None
        _hx_o.deps = None
hxsl__Dce_VarDeps._hx_class = hxsl__Dce_VarDeps
_hx_classes["hxsl._Dce.VarDeps"] = hxsl__Dce_VarDeps


class hxsl_Dce:
    _hx_class_name = "hxsl.Dce"
    _hx_is_interface = "False"
    __slots__ = ("used", "channelVars", "markAsKeep")
    _hx_fields = ["used", "channelVars", "markAsKeep"]
    _hx_methods = ["debug", "dce", "get", "markRec", "link", "check", "checkBranches", "mapExpr"]

    def __init__(self):
        self.markAsKeep = None
        self.channelVars = None
        self.used = None

    def debug(self,msg,pos = None):
        pass

    def dce(self,vertex,fragment):
        self.used = haxe_ds_IntMap()
        self.channelVars = []
        inputs = []
        _g = 0
        _g1 = vertex.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            i = self.get(v)
            if (v.kind == hxsl_VarKind.Input):
                inputs.append(i)
            if (v.kind == hxsl_VarKind.Output):
                i.keep = True
        _g = 0
        _g1 = fragment.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            i = self.get(v)
            if (v.kind == hxsl_VarKind.Output):
                i.keep = True
        _g = 0
        _g1 = vertex.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.check(f.expr,[],[])
        _g = 0
        _g1 = fragment.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.check(f.expr,[],[])
        outExprs = []
        while True:
            v = self.used.iterator()
            while v.hasNext():
                v1 = v.next()
                if v1.keep:
                    self.markRec(v1)
            while ((len(inputs) > 1) and (not python_internal_ArrayImpl._get(inputs, (len(inputs) - 1)).used)):
                if (len(inputs) != 0):
                    inputs.pop()
            _g = 0
            while (_g < len(inputs)):
                v2 = (inputs[_g] if _g >= 0 and _g < len(inputs) else None)
                _g = (_g + 1)
                self.markRec(v2)
            outExprs = []
            _g1 = 0
            _g2 = vertex.funs
            while (_g1 < len(_g2)):
                f = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                x = self.mapExpr(f.expr,False)
                outExprs.append(x)
            _g3 = 0
            _g4 = fragment.funs
            while (_g3 < len(_g4)):
                f1 = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                _g3 = (_g3 + 1)
                x1 = self.mapExpr(f1.expr,False)
                outExprs.append(x1)
            self.markAsKeep = False
            _g5 = 0
            while (_g5 < len(outExprs)):
                e = (outExprs[_g5] if _g5 >= 0 and _g5 < len(outExprs) else None)
                _g5 = (_g5 + 1)
                self.checkBranches(e)
            if (not self.markAsKeep):
                break
        _g = 0
        _g1 = vertex.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f.expr = (None if ((len(outExprs) == 0)) else outExprs.pop(0))
        _g = 0
        _g1 = fragment.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f.expr = (None if ((len(outExprs) == 0)) else outExprs.pop(0))
        v = self.used.iterator()
        while v.hasNext():
            v1 = v.next()
            if v1.used:
                continue
            if (v1.v.kind == hxsl_VarKind.Input):
                continue
            python_internal_ArrayImpl.remove(vertex.vars,v1.v)
            python_internal_ArrayImpl.remove(fragment.vars,v1.v)
        return _hx_AnonObject({'fragment': fragment, 'vertex': vertex})

    def get(self,v):
        vd = self.used.h.get(v.id,None)
        if (vd is None):
            vd = hxsl__Dce_VarDeps(v)
            self.used.set(v.id,vd)
        return vd

    def markRec(self,v):
        if v.used:
            return
        v.used = True
        d = v.deps.iterator()
        while d.hasNext():
            d1 = d.next()
            self.markRec(d1)

    def link(self,v,writeTo):
        vd = self.get(v)
        _g = 0
        while (_g < len(writeTo)):
            w = (writeTo[_g] if _g >= 0 and _g < len(writeTo) else None)
            _g = (_g + 1)
            if (w is None):
                if (not vd.keep):
                    vd.keep = True
                    self.markAsKeep = True
                continue
            w.deps.set(v.id,vd)

    def check(self,e,writeTo,isAffected):
        _g = e.e
        tmp = _g.index
        if (tmp == 1):
            v = _g.params[0]
            self.link(v,writeTo)
        elif (tmp == 4):
            el = _g.params[0]
            noWrite = []
            _g1 = 0
            _g2 = len(el)
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                self.check((el[i] if i >= 0 and i < len(el) else None),(noWrite if ((i < ((len(el) - 1)))) else writeTo),isAffected)
        elif (tmp == 5):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g.params[2]
            tmp = _g1.index
            if (tmp == 4):
                _g4 = _g2.e
                _g5 = _g2.p
                _g5 = _g2.t
                tmp = _g4.index
                if (tmp == 1):
                    v = _g4.params[0]
                    e1 = _g3
                    v1 = self.get(v)
                    writeTo.append(v1)
                    self.check(e1,writeTo,isAffected)
                    if (len(writeTo) != 0):
                        writeTo.pop()
                    if (python_internal_ArrayImpl.indexOf(isAffected,v1,None) < 0):
                        isAffected.append(v1)
                elif (tmp == 9):
                    _g5 = _g4.params[0]
                    _g6 = _g4.params[1]
                    _g4 = _g5.e
                    _g6 = _g5.p
                    _g6 = _g5.t
                    if (_g4.index == 1):
                        v = _g4.params[0]
                        e1 = _g3
                        v1 = self.get(v)
                        writeTo.append(v1)
                        self.check(e1,writeTo,isAffected)
                        if (len(writeTo) != 0):
                            writeTo.pop()
                        if (python_internal_ArrayImpl.indexOf(isAffected,v1,None) < 0):
                            isAffected.append(v1)
                    else:
                        _g4 = self.check
                        writeTo1 = writeTo
                        isAffected1 = isAffected
                        def _hx_local_0(e):
                            _g4(e,writeTo1,isAffected1)
                        hxsl_Tools.iter(e,_hx_local_0)
                else:
                    _g5 = self.check
                    writeTo2 = writeTo
                    isAffected2 = isAffected
                    def _hx_local_1(e):
                        _g5(e,writeTo2,isAffected2)
                    hxsl_Tools.iter(e,_hx_local_1)
            elif (tmp == 20):
                _g6 = _g1.params[0]
                _g1 = _g2.e
                _g6 = _g2.p
                _g6 = _g2.t
                tmp = _g1.index
                if (tmp == 1):
                    v = _g1.params[0]
                    e1 = _g3
                    v1 = self.get(v)
                    writeTo.append(v1)
                    self.check(e1,writeTo,isAffected)
                    if (len(writeTo) != 0):
                        writeTo.pop()
                    if (python_internal_ArrayImpl.indexOf(isAffected,v1,None) < 0):
                        isAffected.append(v1)
                elif (tmp == 9):
                    _g2 = _g1.params[0]
                    _g6 = _g1.params[1]
                    _g1 = _g2.e
                    _g6 = _g2.p
                    _g6 = _g2.t
                    if (_g1.index == 1):
                        v = _g1.params[0]
                        e1 = _g3
                        v1 = self.get(v)
                        writeTo.append(v1)
                        self.check(e1,writeTo,isAffected)
                        if (len(writeTo) != 0):
                            writeTo.pop()
                        if (python_internal_ArrayImpl.indexOf(isAffected,v1,None) < 0):
                            isAffected.append(v1)
                    else:
                        _g1 = self.check
                        writeTo3 = writeTo
                        isAffected3 = isAffected
                        def _hx_local_2(e):
                            _g1(e,writeTo3,isAffected3)
                        hxsl_Tools.iter(e,_hx_local_2)
                else:
                    _g2 = self.check
                    writeTo4 = writeTo
                    isAffected4 = isAffected
                    def _hx_local_3(e):
                        _g2(e,writeTo4,isAffected4)
                    hxsl_Tools.iter(e,_hx_local_3)
            else:
                _g3 = self.check
                writeTo5 = writeTo
                isAffected5 = isAffected
                def _hx_local_4(e):
                    _g3(e,writeTo5,isAffected5)
                hxsl_Tools.iter(e,_hx_local_4)
        elif (tmp == 7):
            v = _g.params[0]
            init = _g.params[1]
            if (init is not None):
                x = self.get(v)
                writeTo.append(x)
                self.check(init,writeTo,isAffected)
                if (len(writeTo) != 0):
                    writeTo.pop()
            else:
                _g6 = self.check
                writeTo6 = writeTo
                isAffected6 = isAffected
                def _hx_local_5(e):
                    _g6(e,writeTo6,isAffected6)
                hxsl_Tools.iter(e,_hx_local_5)
        elif (tmp == 8):
            _g7 = _g.params[0]
            _g8 = _g.params[1]
            _g9 = _g7.e
            _g10 = _g7.p
            _g10 = _g7.t
            if (_g9.index == 2):
                tmp = _g9.params[0].index
                if (tmp == 63):
                    if (len(_g8) == 3):
                        _g7 = (_g8[0] if 0 < len(_g8) else None)
                        _g9 = (_g8[2] if 2 < len(_g8) else None)
                        _g10 = _g7.e
                        _g11 = _g7.p
                        _g11 = _g7.t
                        if (_g10.index == 1):
                            _g7 = _g9.e
                            _g11 = _g9.p
                            _g11 = _g9.t
                            if (_g7.index == 0):
                                _g9 = _g7.params[0]
                                if (_g9.index == 2):
                                    cid = _g9.params[0]
                                    uv = (_g8[1] if 1 < len(_g8) else None)
                                    c = _g10.params[0]
                                    self.check(uv,writeTo,isAffected)
                                    if ((self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None) is None):
                                        python_internal_ArrayImpl._set(self.channelVars, cid, c)
                                        self.link(c,writeTo)
                                    else:
                                        self.link((self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None),writeTo)
                                else:
                                    _g7 = self.check
                                    writeTo7 = writeTo
                                    isAffected7 = isAffected
                                    def _hx_local_6(e):
                                        _g7(e,writeTo7,isAffected7)
                                    hxsl_Tools.iter(e,_hx_local_6)
                            else:
                                _g9 = self.check
                                writeTo8 = writeTo
                                isAffected8 = isAffected
                                def _hx_local_7(e):
                                    _g9(e,writeTo8,isAffected8)
                                hxsl_Tools.iter(e,_hx_local_7)
                        else:
                            _g10 = self.check
                            writeTo9 = writeTo
                            isAffected9 = isAffected
                            def _hx_local_8(e):
                                _g10(e,writeTo9,isAffected9)
                            hxsl_Tools.iter(e,_hx_local_8)
                    else:
                        _g11 = self.check
                        writeTo10 = writeTo
                        isAffected10 = isAffected
                        def _hx_local_9(e):
                            _g11(e,writeTo10,isAffected10)
                        hxsl_Tools.iter(e,_hx_local_9)
                elif (tmp == 64):
                    if (len(_g8) == 4):
                        _g12 = (_g8[0] if 0 < len(_g8) else None)
                        _g13 = (_g8[3] if 3 < len(_g8) else None)
                        _g14 = _g12.e
                        _g15 = _g12.p
                        _g15 = _g12.t
                        if (_g14.index == 1):
                            _g12 = _g13.e
                            _g15 = _g13.p
                            _g15 = _g13.t
                            if (_g12.index == 0):
                                _g13 = _g12.params[0]
                                if (_g13.index == 2):
                                    cid = _g13.params[0]
                                    lod = (_g8[2] if 2 < len(_g8) else None)
                                    uv = (_g8[1] if 1 < len(_g8) else None)
                                    c = _g14.params[0]
                                    self.check(uv,writeTo,isAffected)
                                    self.check(lod,writeTo,isAffected)
                                    if ((self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None) is None):
                                        python_internal_ArrayImpl._set(self.channelVars, cid, c)
                                        self.link(c,writeTo)
                                    else:
                                        self.link((self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None),writeTo)
                                else:
                                    _g8 = self.check
                                    writeTo11 = writeTo
                                    isAffected11 = isAffected
                                    def _hx_local_10(e):
                                        _g8(e,writeTo11,isAffected11)
                                    hxsl_Tools.iter(e,_hx_local_10)
                            else:
                                _g12 = self.check
                                writeTo12 = writeTo
                                isAffected12 = isAffected
                                def _hx_local_11(e):
                                    _g12(e,writeTo12,isAffected12)
                                hxsl_Tools.iter(e,_hx_local_11)
                        else:
                            _g13 = self.check
                            writeTo13 = writeTo
                            isAffected13 = isAffected
                            def _hx_local_12(e):
                                _g13(e,writeTo13,isAffected13)
                            hxsl_Tools.iter(e,_hx_local_12)
                    else:
                        _g14 = self.check
                        writeTo14 = writeTo
                        isAffected14 = isAffected
                        def _hx_local_13(e):
                            _g14(e,writeTo14,isAffected14)
                        hxsl_Tools.iter(e,_hx_local_13)
                else:
                    _g15 = self.check
                    writeTo15 = writeTo
                    isAffected15 = isAffected
                    def _hx_local_14(e):
                        _g15(e,writeTo15,isAffected15)
                    hxsl_Tools.iter(e,_hx_local_14)
            else:
                _g16 = self.check
                writeTo16 = writeTo
                isAffected16 = isAffected
                def _hx_local_15(e):
                    _g16(e,writeTo16,isAffected16)
                hxsl_Tools.iter(e,_hx_local_15)
        elif (tmp == 10):
            e1 = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            affect = []
            self.check(eif,writeTo,affect)
            if (eelse is not None):
                self.check(eelse,writeTo,affect)
            _hx_len = len(affect)
            _g17 = 0
            while (_g17 < len(writeTo)):
                v = (writeTo[_g17] if _g17 >= 0 and _g17 < len(writeTo) else None)
                _g17 = (_g17 + 1)
                if (python_internal_ArrayImpl.indexOf(affect,v,None) < 0):
                    affect.append(v)
            self.check(e1,affect,isAffected)
            _g17 = 0
            _g18 = _hx_len
            while (_g17 < _g18):
                i = _g17
                _g17 = (_g17 + 1)
                v = (affect[i] if i >= 0 and i < len(affect) else None)
                if (python_internal_ArrayImpl.indexOf(isAffected,v,None) < 0):
                    isAffected.append(v)
        elif (tmp == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            affect = []
            self.check(loop,writeTo,affect)
            self.check(it,affect,isAffected)
            _g = 0
            while (_g < len(affect)):
                v = (affect[_g] if _g >= 0 and _g < len(affect) else None)
                _g = (_g + 1)
                if (python_internal_ArrayImpl.indexOf(isAffected,v,None) < 0):
                    isAffected.append(v)
        else:
            _g = self.check
            writeTo17 = writeTo
            isAffected17 = isAffected
            def _hx_local_18(e):
                _g(e,writeTo17,isAffected17)
            hxsl_Tools.iter(e,_hx_local_18)

    def checkBranches(self,e):
        _g = e.e
        if (_g.index == 10):
            _g1 = _g.params[1]
            _g1 = _g.params[2]
            cond = _g.params[0]
            writeTo = [None]
            self.check(cond,writeTo,[])
        hxsl_Tools.iter(e,self.checkBranches)

    def mapExpr(self,e,isVar):
        _gthis = self
        _g = e.e
        tmp = _g.index
        if (tmp == 4):
            el = _g.params[0]
            out = []
            count = 0
            _g1 = 0
            while (_g1 < len(el)):
                e1 = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                isVar1 = (isVar and ((count == ((len(el) - 1)))))
                e2 = self.mapExpr(e1,isVar1)
                if (hxsl_Tools.hasSideEffect(e2) or isVar1):
                    out.append(e2)
                count = (count + 1)
            return _hx_AnonObject({'e': hxsl_TExprDef.TBlock(out), 'p': e.p, 't': e.t})
        elif (tmp == 5):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g.params[2]
            tmp = _g1.index
            if (tmp == 4):
                _g3 = _g2.e
                _g4 = _g2.p
                _g4 = _g2.t
                tmp = _g3.index
                if (tmp == 1):
                    v = _g3.params[0]
                    if (not self.get(v).used):
                        return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
                    else:
                        def _hx_local_3():
                            def _hx_local_2(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_2)
                        return _hx_local_3()
                elif (tmp == 9):
                    _g4 = _g3.params[0]
                    _g5 = _g3.params[1]
                    _g3 = _g4.e
                    _g5 = _g4.p
                    _g5 = _g4.t
                    if (_g3.index == 1):
                        v = _g3.params[0]
                        if (not self.get(v).used):
                            return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
                        else:
                            def _hx_local_5():
                                def _hx_local_4(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_4)
                            return _hx_local_5()
                    else:
                        def _hx_local_7():
                            def _hx_local_6(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_6)
                        return _hx_local_7()
                else:
                    def _hx_local_9():
                        def _hx_local_8(e):
                            return _gthis.mapExpr(e,True)
                        return hxsl_Tools.map(e,_hx_local_8)
                    return _hx_local_9()
            elif (tmp == 20):
                _g3 = _g1.params[0]
                _g1 = _g2.e
                _g3 = _g2.p
                _g3 = _g2.t
                tmp = _g1.index
                if (tmp == 1):
                    v = _g1.params[0]
                    if (not self.get(v).used):
                        return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
                    else:
                        def _hx_local_11():
                            def _hx_local_10(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_10)
                        return _hx_local_11()
                elif (tmp == 9):
                    _g2 = _g1.params[0]
                    _g3 = _g1.params[1]
                    _g1 = _g2.e
                    _g3 = _g2.p
                    _g3 = _g2.t
                    if (_g1.index == 1):
                        v = _g1.params[0]
                        if (not self.get(v).used):
                            return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
                        else:
                            def _hx_local_13():
                                def _hx_local_12(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_12)
                            return _hx_local_13()
                    else:
                        def _hx_local_15():
                            def _hx_local_14(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_14)
                        return _hx_local_15()
                else:
                    def _hx_local_17():
                        def _hx_local_16(e):
                            return _gthis.mapExpr(e,True)
                        return hxsl_Tools.map(e,_hx_local_16)
                    return _hx_local_17()
            else:
                def _hx_local_19():
                    def _hx_local_18(e):
                        return _gthis.mapExpr(e,True)
                    return hxsl_Tools.map(e,_hx_local_18)
                return _hx_local_19()
        elif (tmp == 7):
            _g1 = _g.params[1]
            v = _g.params[0]
            if (not self.get(v).used):
                return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
            else:
                def _hx_local_21():
                    def _hx_local_20(e):
                        return _gthis.mapExpr(e,True)
                    return hxsl_Tools.map(e,_hx_local_20)
                return _hx_local_21()
        elif (tmp == 8):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g1.e
            _g4 = _g1.p
            _g4 = _g1.t
            if (_g3.index == 2):
                tmp = _g3.params[0].index
                if (tmp == 63):
                    if (len(_g2) == 3):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g1 = (_g2[2] if 2 < len(_g2) else None)
                        _g3 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g3.index == 0):
                            _g1 = _g3.params[0]
                            if (_g1.index == 2):
                                cid = _g1.params[0]
                                uv = (_g2[1] if 1 < len(_g2) else None)
                                c = (self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texture), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c), 't': c.type, 'p': e.p}), self.mapExpr(uv,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_23():
                                    def _hx_local_22(e):
                                        return _gthis.mapExpr(e,True)
                                    return hxsl_Tools.map(e,_hx_local_22)
                                return _hx_local_23()
                        else:
                            def _hx_local_25():
                                def _hx_local_24(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_24)
                            return _hx_local_25()
                    else:
                        def _hx_local_27():
                            def _hx_local_26(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_26)
                        return _hx_local_27()
                elif (tmp == 64):
                    if (len(_g2) == 4):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g1 = (_g2[3] if 3 < len(_g2) else None)
                        _g3 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g3.index == 0):
                            _g1 = _g3.params[0]
                            if (_g1.index == 2):
                                cid = _g1.params[0]
                                lod = (_g2[2] if 2 < len(_g2) else None)
                                uv = (_g2[1] if 1 < len(_g2) else None)
                                c = (self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureLod), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c), 't': c.type, 'p': e.p}), self.mapExpr(uv,True), self.mapExpr(lod,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_29():
                                    def _hx_local_28(e):
                                        return _gthis.mapExpr(e,True)
                                    return hxsl_Tools.map(e,_hx_local_28)
                                return _hx_local_29()
                        else:
                            def _hx_local_31():
                                def _hx_local_30(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_30)
                            return _hx_local_31()
                    else:
                        def _hx_local_33():
                            def _hx_local_32(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_32)
                        return _hx_local_33()
                elif (tmp == 65):
                    _g1 = len(_g2)
                    if (_g1 == 3):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g1 = (_g2[2] if 2 < len(_g2) else None)
                        _g3 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g3.index == 0):
                            _g1 = _g3.params[0]
                            if (_g1.index == 2):
                                cid = _g1.params[0]
                                pos = (_g2[1] if 1 < len(_g2) else None)
                                c = (self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c), 't': c.type, 'p': e.p}), self.mapExpr(pos,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_35():
                                    def _hx_local_34(e):
                                        return _gthis.mapExpr(e,True)
                                    return hxsl_Tools.map(e,_hx_local_34)
                                return _hx_local_35()
                        else:
                            def _hx_local_37():
                                def _hx_local_36(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_36)
                            return _hx_local_37()
                    elif (_g1 == 4):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g1 = (_g2[3] if 3 < len(_g2) else None)
                        _g3 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g3.index == 0):
                            _g1 = _g3.params[0]
                            if (_g1.index == 2):
                                cid = _g1.params[0]
                                lod = (_g2[2] if 2 < len(_g2) else None)
                                pos = (_g2[1] if 1 < len(_g2) else None)
                                c = (self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c), 't': c.type, 'p': e.p}), self.mapExpr(pos,True), self.mapExpr(lod,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_39():
                                    def _hx_local_38(e):
                                        return _gthis.mapExpr(e,True)
                                    return hxsl_Tools.map(e,_hx_local_38)
                                return _hx_local_39()
                        else:
                            def _hx_local_41():
                                def _hx_local_40(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_40)
                            return _hx_local_41()
                    else:
                        def _hx_local_43():
                            def _hx_local_42(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_42)
                        return _hx_local_43()
                elif (tmp == 66):
                    _g1 = len(_g2)
                    if (_g1 == 2):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g1 = (_g2[1] if 1 < len(_g2) else None)
                        _g3 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g3.index == 0):
                            _g1 = _g3.params[0]
                            if (_g1.index == 2):
                                cid = _g1.params[0]
                                c = (self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureSize), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c), 't': c.type, 'p': e.p})]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_45():
                                    def _hx_local_44(e):
                                        return _gthis.mapExpr(e,True)
                                    return hxsl_Tools.map(e,_hx_local_44)
                                return _hx_local_45()
                        else:
                            def _hx_local_47():
                                def _hx_local_46(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_46)
                            return _hx_local_47()
                    elif (_g1 == 3):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g1 = (_g2[2] if 2 < len(_g2) else None)
                        _g3 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g3.index == 0):
                            _g1 = _g3.params[0]
                            if (_g1.index == 2):
                                cid = _g1.params[0]
                                lod = (_g2[1] if 1 < len(_g2) else None)
                                c = (self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureSize), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c), 't': c.type, 'p': e.p}), self.mapExpr(lod,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_49():
                                    def _hx_local_48(e):
                                        return _gthis.mapExpr(e,True)
                                    return hxsl_Tools.map(e,_hx_local_48)
                                return _hx_local_49()
                        else:
                            def _hx_local_51():
                                def _hx_local_50(e):
                                    return _gthis.mapExpr(e,True)
                                return hxsl_Tools.map(e,_hx_local_50)
                            return _hx_local_51()
                    else:
                        def _hx_local_53():
                            def _hx_local_52(e):
                                return _gthis.mapExpr(e,True)
                            return hxsl_Tools.map(e,_hx_local_52)
                        return _hx_local_53()
                else:
                    def _hx_local_55():
                        def _hx_local_54(e):
                            return _gthis.mapExpr(e,True)
                        return hxsl_Tools.map(e,_hx_local_54)
                    return _hx_local_55()
            else:
                def _hx_local_57():
                    def _hx_local_56(e):
                        return _gthis.mapExpr(e,True)
                    return hxsl_Tools.map(e,_hx_local_56)
                return _hx_local_57()
        elif (tmp == 10):
            e1 = _g.params[0]
            econd = _g.params[1]
            eelse = _g.params[2]
            e2 = self.mapExpr(e1,True)
            econd1 = self.mapExpr(econd,isVar)
            eelse1 = (None if ((eelse is None)) else self.mapExpr(eelse,isVar))
            if (((not isVar) and (not hxsl_Tools.hasSideEffect(econd1))) and (((eelse1 is None) or (not hxsl_Tools.hasSideEffect(eelse1))))):
                return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e2.t, 'p': e2.p})
            return _hx_AnonObject({'e': hxsl_TExprDef.TIf(e2,econd1,eelse1), 'p': e2.p, 't': e2.t})
        elif (tmp == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            it1 = self.mapExpr(it,True)
            loop1 = self.mapExpr(loop,False)
            if (not hxsl_Tools.hasSideEffect(loop1)):
                return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
            return _hx_AnonObject({'e': hxsl_TExprDef.TFor(v,it1,loop1), 'p': e.p, 't': e.t})
        else:
            def _hx_local_59():
                def _hx_local_58(e):
                    return _gthis.mapExpr(e,True)
                return hxsl_Tools.map(e,_hx_local_58)
            return _hx_local_59()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.used = None
        _hx_o.channelVars = None
        _hx_o.markAsKeep = None
hxsl_Dce._hx_class = hxsl_Dce
_hx_classes["hxsl.Dce"] = hxsl_Dce


class hxsl_Eval:
    _hx_class_name = "hxsl.Eval"
    _hx_is_interface = "False"
    __slots__ = ("varMap", "inlineCalls", "unrollLoops", "eliminateConditionals", "constants", "funMap", "curFun", "markReturn")
    _hx_fields = ["varMap", "inlineCalls", "unrollLoops", "eliminateConditionals", "constants", "funMap", "curFun", "markReturn"]
    _hx_methods = ["setConstant", "mapVar", "checkSamplerRec", "needsInline", "eval", "hasReturn", "hasReturnLoop", "handleReturn", "handleReturnDef", "evalCall", "constantsToString", "ifBlock", "evalExpr"]

    def __init__(self):
        self.markReturn = None
        self.curFun = None
        self.eliminateConditionals = None
        self.unrollLoops = None
        self.inlineCalls = None
        self.varMap = haxe_ds_ObjectMap()
        self.funMap = haxe_ds_ObjectMap()
        self.constants = haxe_ds_IntMap()

    def setConstant(self,v,c):
        self.constants.set(v.id,hxsl_TExprDef.TConst(c))

    def mapVar(self,v):
        v2 = self.varMap.h.get(v,None)
        if (v2 is not None):
            if (v == v2):
                return v2
            else:
                return self.mapVar(v2)
        if (Reflect.field(v,"parent") is not None):
            self.mapVar(Reflect.field(v,"parent"))
            v2 = self.varMap.h.get(v,None)
            if (v2 is not None):
                if (v == v2):
                    return v2
                else:
                    return self.mapVar(v2)
        _g = v.type
        v21 = None
        if (_g.index == 17):
            _g1 = _g.params[0]
            v21 = True
        else:
            v21 = False
        v2 = _hx_AnonObject({'id': (v.id if v21 else hxsl_Tools.allocVarId()), 'name': v.name, 'type': v.type, 'kind': v.kind})
        if (Reflect.field(v,"parent") is not None):
            Reflect.setField(v2,"parent",self.mapVar(Reflect.field(v,"parent")))
        if (Reflect.field(v,"qualifiers") is not None):
            Reflect.setField(v2,"qualifiers",list(Reflect.field(v,"qualifiers")))
        self.varMap.set(v,v2)
        self.varMap.set(v2,v2)
        _g = v2.type
        tmp = _g.index
        if (tmp == 13):
            vl = _g.params[0]
            _g1 = []
            _g2 = 0
            while (_g2 < len(vl)):
                v = (vl[_g2] if _g2 >= 0 and _g2 < len(vl) else None)
                _g2 = (_g2 + 1)
                x = self.mapVar(v)
                _g1.append(x)
            v2.type = hxsl_Type.TStruct(_g1)
        elif (tmp == 15):
            _g1 = _g.params[1]
            if (_g1.index == 1):
                vs = _g1.params[0]
                t = _g.params[0]
                c = self.constants.h.get(vs.id,None)
                if (c is not None):
                    if (c is None):
                        hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                    elif (c.index == 0):
                        _g1 = c.params[0]
                        if (_g1.index == 2):
                            v = _g1.params[0]
                            _g1 = v2.type
                            tmp = None
                            if (_g1.index == 15):
                                _g2 = _g1.params[0]
                                _g2 = _g1.params[1]
                                tmp = True
                            else:
                                tmp = False
                            v2.type = (hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(v)) if tmp else hxsl_Type.TBuffer(t,hxsl_SizeDecl.SConst(v)))
                        else:
                            hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                    else:
                        hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                else:
                    vs2 = self.mapVar(vs)
                    _g1 = v2.type
                    tmp = None
                    if (_g1.index == 15):
                        _g2 = _g1.params[0]
                        _g2 = _g1.params[1]
                        tmp = True
                    else:
                        tmp = False
                    v2.type = (hxsl_Type.TArray(t,hxsl_SizeDecl.SVar(vs2)) if tmp else hxsl_Type.TBuffer(t,hxsl_SizeDecl.SVar(vs2)))
        elif (tmp == 16):
            _g1 = _g.params[1]
            if (_g1.index == 1):
                vs = _g1.params[0]
                t = _g.params[0]
                c = self.constants.h.get(vs.id,None)
                if (c is not None):
                    if (c is None):
                        hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                    elif (c.index == 0):
                        _g = c.params[0]
                        if (_g.index == 2):
                            v = _g.params[0]
                            _g = v2.type
                            tmp = None
                            if (_g.index == 15):
                                _g1 = _g.params[0]
                                _g1 = _g.params[1]
                                tmp = True
                            else:
                                tmp = False
                            v2.type = (hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(v)) if tmp else hxsl_Type.TBuffer(t,hxsl_SizeDecl.SConst(v)))
                        else:
                            hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                    else:
                        hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                else:
                    vs2 = self.mapVar(vs)
                    _g = v2.type
                    tmp = None
                    if (_g.index == 15):
                        _g1 = _g.params[0]
                        _g1 = _g.params[1]
                        tmp = True
                    else:
                        tmp = False
                    v2.type = (hxsl_Type.TArray(t,hxsl_SizeDecl.SVar(vs2)) if tmp else hxsl_Type.TBuffer(t,hxsl_SizeDecl.SVar(vs2)))
        else:
            pass
        return v2

    def checkSamplerRec(self,t):
        if hxsl_Tools.isSampler(t):
            return True
        tmp = t.index
        if (tmp == 13):
            vl = t.params[0]
            _g = 0
            while (_g < len(vl)):
                v = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                if self.checkSamplerRec(v.type):
                    return True
            return False
        elif (tmp == 15):
            _g = t.params[1]
            t1 = t.params[0]
            return self.checkSamplerRec(t1)
        elif (tmp == 16):
            _g = t.params[0]
            size = t.params[1]
            return True
        else:
            pass
        return False

    def needsInline(self,f):
        _g = 0
        _g1 = f.args
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if self.checkSamplerRec(a.type):
                return True
        return False

    def eval(self,s):
        funs = []
        _g = 0
        _g1 = s.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f1 = f.kind
            f2 = self.mapVar(f.ref)
            _g2 = []
            _g3 = 0
            _g4 = f.args
            while (_g3 < len(_g4)):
                a = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                _g3 = (_g3 + 1)
                x = self.mapVar(a)
                _g2.append(x)
            f21 = _hx_AnonObject({'kind': f1, 'ref': f2, 'args': _g2, 'ret': f.ret, 'expr': f.expr})
            if (((f.kind == hxsl_FunctionKind.Helper) and self.inlineCalls) or self.needsInline(f21)):
                self.funMap.set(f21.ref,f)
            else:
                funs.append(f21)
        _g = 0
        _g1 = len(funs)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.curFun = (funs[i] if i >= 0 and i < len(funs) else None)
            self.curFun.expr = self.evalExpr(self.curFun.expr,False)
        s1 = s.name
        _g = []
        _g1 = 0
        _g2 = s.vars
        while (_g1 < len(_g2)):
            v = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = self.mapVar(v)
            _g.append(x)
        return _hx_AnonObject({'name': s1, 'vars': _g, 'funs': funs})

    def hasReturn(self,e):
        self.markReturn = False
        self.hasReturnLoop(e)
        return self.markReturn

    def hasReturnLoop(self,e):
        _g = e.e
        if (_g.index == 12):
            _g1 = _g.params[0]
            self.markReturn = True
        elif (not self.markReturn):
            hxsl_Tools.iter(e,self.hasReturnLoop)

    def handleReturn(self,e,isFinal = None):
        if (isFinal is None):
            isFinal = False
        _g = e.e
        tmp = _g.index
        if (tmp == 3):
            v = _g.params[0]
            v1 = self.handleReturn(v,isFinal)
            return _hx_AnonObject({'e': hxsl_TExprDef.TParenthesis(v1), 't': v1.t, 'p': e.p})
        elif (tmp == 4):
            el = _g.params[0]
            i = 0
            last = len(el)
            out = []
            while (i < last):
                e1 = i
                i = (i + 1)
                e2 = (el[e1] if e1 >= 0 and e1 < len(el) else None)
                if (i == last):
                    x = self.handleReturn(e2,isFinal)
                    out.append(x)
                else:
                    _g1 = e2.e
                    tmp = _g1.index
                    if (tmp == 10):
                        if (_g1.params[2] is None):
                            eif = _g1.params[1]
                            econd = _g1.params[0]
                            if (isFinal and self.hasReturn(eif)):
                                x1 = self.handleReturn(_hx_AnonObject({'e': hxsl_TExprDef.TIf(econd,eif,_hx_AnonObject({'e': hxsl_TExprDef.TBlock(el[i:None]), 't': e2.t, 'p': e2.p})), 't': e2.t, 'p': e2.p}))
                                out.append(x1)
                                break
                            else:
                                x2 = self.handleReturn(e2)
                                out.append(x2)
                        else:
                            x3 = self.handleReturn(e2)
                            out.append(x3)
                    elif (tmp == 12):
                        e3 = _g1.params[0]
                        x4 = self.handleReturn(e3,isFinal)
                        out.append(x4)
                        break
                    else:
                        x5 = self.handleReturn(e2)
                        out.append(x5)
            t = (python_internal_ArrayImpl._get(out, (len(out) - 1)).t if isFinal else e.t)
            return _hx_AnonObject({'e': hxsl_TExprDef.TBlock(out), 't': t, 'p': e.p})
        elif (tmp == 10):
            cond = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            if ((eelse is not None) and isFinal):
                cond1 = self.handleReturn(cond)
                eif1 = self.handleReturn(eif,isFinal)
                return _hx_AnonObject({'e': hxsl_TExprDef.TIf(cond1,eif1,self.handleReturn(eelse,isFinal)), 't': eif1.t, 'p': e.p})
            else:
                return hxsl_Tools.map(e,self.handleReturnDef)
        elif (tmp == 12):
            v = _g.params[0]
            if (not isFinal):
                hxsl_Error.t("Cannot inline not final return",e.p)
            if (v is None):
                return _hx_AnonObject({'e': hxsl_TExprDef.TBlock([]), 't': hxsl_Type.TVoid, 'p': e.p})
            return self.handleReturn(v,True)
        else:
            return hxsl_Tools.map(e,self.handleReturnDef)

    def handleReturnDef(self,e):
        return self.handleReturn(e)

    def evalCall(self,g,args,oldArgs,pos):
        tmp = g.index
        if (tmp == 38):
            if (len(args) == 1):
                _g = (args[0] if 0 < len(args) else None)
                _g1 = _g.e
                _g2 = _g.p
                _g2 = _g.t
                if (_g1.index == 0):
                    _g = _g1.params[0]
                    if (_g.index == 2):
                        i = _g.params[0]
                        return hxsl_TExprDef.TConst(hxsl_Const.CFloat(i))
                    else:
                        return None
                else:
                    return None
            else:
                return None
        elif ((tmp == 64) or ((tmp == 63))):
            i = None
            _g = (args[0] if 0 < len(args) else None).e
            if (_g.index == 0):
                _g1 = _g.params[0]
                if (_g1.index == 2):
                    i1 = _g1.params[0]
                    i = i1
                else:
                    hxsl_Error.t(((("Cannot eval complex channel " + HxOverrides.stringOrNull(hxsl_Printer.toString((args[0] if 0 < len(args) else None),True))) + " ") + HxOverrides.stringOrNull(self.constantsToString())),pos)
                    raise haxe_Exception.thrown("assert")
            else:
                hxsl_Error.t(((("Cannot eval complex channel " + HxOverrides.stringOrNull(hxsl_Printer.toString((args[0] if 0 < len(args) else None),True))) + " ") + HxOverrides.stringOrNull(self.constantsToString())),pos)
                raise haxe_Exception.thrown("assert")
            channel = (oldArgs[0] if 0 < len(oldArgs) else None)
            _g = channel.e
            channel1 = None
            if (_g.index == 1):
                v = _g.params[0]
                channel1 = hxsl_TExprDef.TVar(self.mapVar(v))
            else:
                raise haxe_Exception.thrown("assert")
            channel = _hx_AnonObject({'e': channel1, 't': channel.t, 'p': channel.p})
            count = None
            _g = channel.t
            if (_g.index == 17):
                i1 = _g.params[0]
                count = i1
            else:
                raise haxe_Exception.thrown("assert")
            channelMode = Type.createEnumIndex(hxsl_Channel,(i & 7),None)
            targs = [channel]
            _g = 1
            _g1 = len(args)
            while (_g < _g1):
                i1 = _g
                _g = (_g + 1)
                targs.append((args[i1] if i1 >= 0 and i1 < len(args) else None))
            targs.append(_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((i >> 3))), 't': hxsl_Type.TInt, 'p': pos}))
            tget = _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(g), 't': hxsl_Type.TVoid, 'p': pos}),targs), 't': hxsl_Type.TVoid, 'p': pos})
            tmp = channelMode.index
            if (tmp == 0):
                zero = _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CFloat(0.)), 't': hxsl_Type.TFloat, 'p': pos})
                if (count == 1):
                    return zero.e
                return hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(python_internal_ArrayImpl._get([hxsl_TGlobal.Vec2, hxsl_TGlobal.Vec3, hxsl_TGlobal.Vec4], (count - 2))), 't': hxsl_Type.TVoid, 'p': pos}),[zero])
            elif ((((tmp == 4) or ((tmp == 3))) or ((tmp == 2))) or ((tmp == 1))):
                tmp = None
                count1 = count
                if (count1 == 1):
                    tmp1 = channelMode.index
                    if (tmp1 == 1):
                        tmp = [hxsl_Component.X]
                    elif (tmp1 == 2):
                        tmp = [hxsl_Component.Y]
                    elif (tmp1 == 3):
                        tmp = [hxsl_Component.Z]
                    elif (tmp1 == 4):
                        tmp = [hxsl_Component.W]
                    else:
                        raise haxe_Exception.thrown((((("Invalid channel value " + Std.string(channelMode)) + " for ") + Std.string(count)) + " channels"))
                elif (count1 == 2):
                    tmp1 = channelMode.index
                    if (tmp1 == 1):
                        tmp = [hxsl_Component.X, hxsl_Component.Y]
                    elif (tmp1 == 2):
                        tmp = [hxsl_Component.Y, hxsl_Component.Z]
                    elif (tmp1 == 3):
                        tmp = [hxsl_Component.Z, hxsl_Component.W]
                    else:
                        raise haxe_Exception.thrown((((("Invalid channel value " + Std.string(channelMode)) + " for ") + Std.string(count)) + " channels"))
                elif (count1 == 3):
                    tmp1 = channelMode.index
                    if (tmp1 == 1):
                        tmp = [hxsl_Component.X, hxsl_Component.Y, hxsl_Component.Z]
                    elif (tmp1 == 2):
                        tmp = [hxsl_Component.Y, hxsl_Component.Z, hxsl_Component.W]
                    else:
                        raise haxe_Exception.thrown((((("Invalid channel value " + Std.string(channelMode)) + " for ") + Std.string(count)) + " channels"))
                else:
                    raise haxe_Exception.thrown((((("Invalid channel value " + Std.string(channelMode)) + " for ") + Std.string(count)) + " channels"))
                return hxsl_TExprDef.TSwiz(tget,tmp)
            elif (tmp == 5):
                return hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Unpack), 't': hxsl_Type.TVoid, 'p': pos}),[tget])
            elif (tmp == 6):
                return hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.UnpackNormal), 't': hxsl_Type.TVoid, 'p': pos}),[tget])
            else:
                pass
        elif (tmp == 67):
            args1 = args
            _g = 0
            while (_g < len(args1)):
                a = (args1[_g] if _g >= 0 and _g < len(args1) else None)
                _g = (_g + 1)
                haxe_Log.trace(hxsl_Printer.toString(a),_hx_AnonObject({'fileName': a.p.file, 'lineNumber': 0, 'className': None, 'methodName': None}))
            return hxsl_TExprDef.TBlock([])
        else:
            return None

    def constantsToString(self):
        _g = []
        c = self.constants.keys()
        while c.hasNext():
            c1 = c.next()
            x = ((Std.string(c1) + " => ") + HxOverrides.stringOrNull(hxsl_Printer.toString(_hx_AnonObject({'e': self.constants.h.get(c1,None), 't': hxsl_Type.TVoid, 'p': None}),True)))
            _g.append(x)
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))) + "]")

    def ifBlock(self,e):
        tmp = None
        if (e is not None):
            _g = e.e
            tmp1 = None
            if (_g.index == 10):
                _g1 = _g.params[0]
                _g1 = _g.params[1]
                _g1 = _g.params[2]
                tmp1 = True
            else:
                tmp1 = False
            tmp = (not tmp1)
        else:
            tmp = True
        if tmp:
            return e
        return _hx_AnonObject({'e': hxsl_TExprDef.TBlock([e]), 't': e.t, 'p': e.p})

    def evalExpr(self,e,isVal = None):
        if (isVal is None):
            isVal = True
        _gthis = self
        d = None
        _g = e.e
        d1 = _g.index
        if (d1 == 0):
            _g1 = _g.params[0]
            d = e.e
        elif (d1 == 1):
            v = _g.params[0]
            c = self.constants.h.get(v.id,None)
            if (c is not None):
                d = c
            else:
                v2 = self.mapVar(v)
                d = hxsl_TExprDef.TVar(v2)
        elif (d1 == 2):
            _g1 = _g.params[0]
            d = e.e
        elif (d1 == 3):
            e1 = _g.params[0]
            e2 = self.evalExpr(e1,isVal)
            _g1 = e2.e
            if (_g1.index == 0):
                _g2 = _g1.params[0]
                d = e2.e
            else:
                d = hxsl_TExprDef.TParenthesis(e2)
        elif (d1 == 4):
            el = _g.params[0]
            out = []
            last = (len(el) - 1)
            _g1 = 0
            _g2 = len(el)
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                isVal1 = (isVal and ((i == last)))
                e1 = self.evalExpr((el[i] if i >= 0 and i < len(el) else None),isVal1)
                _g3 = e1.e
                d1 = _g3.index
                if (d1 == 0):
                    _g4 = _g3.params[0]
                    if isVal1:
                        out.append(e1)
                elif (d1 == 1):
                    _g5 = _g3.params[0]
                    if isVal1:
                        out.append(e1)
                else:
                    out.append(e1)
            d = ((out[0] if 0 < len(out) else None).e if (((len(out) == 1) and ((self.curFun.kind != hxsl_FunctionKind.Init)))) else hxsl_TExprDef.TBlock(out))
        elif (d1 == 5):
            op = _g.params[0]
            e1 = _g.params[1]
            e2 = _g.params[2]
            e11 = self.evalExpr(e1)
            e21 = self.evalExpr(e2)
            d1 = op.index
            if (d1 == 0):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                x = (a + b)
                                d1 = None
                                try:
                                    d1 = int(x)
                                except BaseException as _g1:
                                    None
                                    d1 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d1))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 3):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat((a + b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 1):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                x = (a * b)
                                d1 = None
                                try:
                                    d1 = int(x)
                                except BaseException as _g1:
                                    None
                                    d1 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d1))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 3):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat((a * b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 2):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                x = (a / b)
                                d1 = None
                                try:
                                    d1 = int(x)
                                except BaseException as _g1:
                                    None
                                    d1 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d1))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 3):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat((a / b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 3):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                x = (a - b)
                                d1 = None
                                try:
                                    d1 = int(x)
                                except BaseException as _g1:
                                    None
                                    d1 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d1))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 3):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat((a - b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif ((d1 == 21) or ((d1 == 4))):
                d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 5):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(True)) if ((_g2.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(False))) if ((_g2.index == 0)) else hxsl_TExprDef.TBinop(op,e11,e21))
                    elif (d1 == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 1):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a == b)) else 1)) == 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 2):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 2):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a - b) == 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 3):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) == 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 4):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            d1 = _g3.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 4):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) == 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 6):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(False)) if ((_g2.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(True))) if ((_g2.index == 0)) else hxsl_TExprDef.TBinop(op,e11,e21))
                    elif (d1 == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 1):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a == b)) else 1)) != 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 2):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 2):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a - b) != 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 3):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) != 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 4):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            d1 = _g3.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 4):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) != 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 7):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(False)) if ((_g2.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(False))) if ((_g2.index == 0)) else hxsl_TExprDef.TBinop(op,e11,e21))
                    elif (d1 == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 1):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a == b)) else 1)) > 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 2):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 2):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a - b) > 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 3):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) > 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 4):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            d1 = _g3.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 4):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) > 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 8):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(True)) if ((_g2.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(False))) if ((_g2.index == 0)) else hxsl_TExprDef.TBinop(op,e11,e21))
                    elif (d1 == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 1):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a == b)) else 1)) >= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 2):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 2):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a - b) >= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 3):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) >= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 4):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            d1 = _g3.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d1 == 4):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) >= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 9):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(False)) if ((_g2.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(True))) if ((_g2.index == 0)) else hxsl_TExprDef.TBinop(op,e11,e21))
                    elif (d1 == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 1):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a == b)) else 1)) < 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 2):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 2):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a - b) < 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 3):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) < 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 4):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            d1 = _g3.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 4):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) < 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 10):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(True)) if ((_g2.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(True))) if ((_g2.index == 0)) else hxsl_TExprDef.TBinop(op,e11,e21))
                    elif (d1 == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 1):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a == b)) else 1)) <= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 2):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 2):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a - b) <= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g4 = _g2.params[0]
                            d1 = _g4.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 3):
                                b = _g4.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) <= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 4):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            d1 = _g3.index
                            if (d1 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d1 == 4):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a > b)) else (0 if ((a == b)) else -1))) <= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 11):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a & b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 12):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a | b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 13):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a ^ b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 14):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            if (_g3.index == 1):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a and b)))
                            else:
                                a = _g1
                                d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == False)) else e21.e)
                        else:
                            a = _g1
                            d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == False)) else e21.e)
                    elif (_g2.index == 0):
                        _g1 = _g2.params[0]
                        if (_g1.index == 1):
                            a = _g1.params[0]
                            d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == False)) else e11.e)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                elif (_g2.index == 0):
                    _g1 = _g2.params[0]
                    if (_g1.index == 1):
                        a = _g1.params[0]
                        d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == False)) else e11.e)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 15):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 1):
                        _g1 = _g3.params[0]
                        if (_g2.index == 0):
                            _g3 = _g2.params[0]
                            if (_g3.index == 1):
                                b = _g3.params[0]
                                a = _g1
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a or b)))
                            else:
                                a = _g1
                                d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == True)) else e21.e)
                        else:
                            a = _g1
                            d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == True)) else e21.e)
                    elif (_g2.index == 0):
                        _g1 = _g2.params[0]
                        if (_g1.index == 1):
                            a = _g1.params[0]
                            d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == True)) else e11.e)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                elif (_g2.index == 0):
                    _g1 = _g2.params[0]
                    if (_g1.index == 1):
                        a = _g1.params[0]
                        d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) if ((a == True)) else e11.e)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 16):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a << b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 17):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a >> b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 18):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    if (_g3.index == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(HxOverrides.rshift(a, b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 19):
                _g1 = e11.e
                _g2 = e21.e
                if (_g1.index == 0):
                    _g3 = _g1.params[0]
                    d1 = _g3.index
                    if (d1 == 2):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 2):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                x = HxOverrides.mod(a, b)
                                d1 = None
                                try:
                                    d1 = int(x)
                                except BaseException as _g1:
                                    None
                                    d1 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d1))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    elif (d1 == 3):
                        if (_g2.index == 0):
                            _g1 = _g2.params[0]
                            if (_g1.index == 3):
                                b = _g1.params[0]
                                a = _g3.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(HxOverrides.modf(a, b)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e11,e21)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e11,e21)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e11,e21)
                else:
                    d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 20):
                _g1 = op.params[0]
                d = hxsl_TExprDef.TBinop(op,e11,e21)
            elif (d1 == 22):
                raise haxe_Exception.thrown("assert")
            elif (d1 == 23):
                raise haxe_Exception.thrown("assert")
            else:
                pass
        elif (d1 == 6):
            op = _g.params[0]
            e1 = _g.params[1]
            e2 = self.evalExpr(e1)
            _g1 = e2.e
            if (_g1.index == 0):
                c = _g1.params[0]
                d1 = op.index
                if (d1 == 2):
                    if (c.index == 1):
                        b = c.params[0]
                        d = hxsl_TExprDef.TConst(hxsl_Const.CBool((not b)))
                    else:
                        d = hxsl_TExprDef.TUnop(op,e2)
                elif (d1 == 3):
                    d1 = c.index
                    if (d1 == 2):
                        i = c.params[0]
                        d = hxsl_TExprDef.TConst(hxsl_Const.CInt(-i))
                    elif (d1 == 3):
                        f = c.params[0]
                        d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(-f))
                    else:
                        d = hxsl_TExprDef.TUnop(op,e2)
                else:
                    d = hxsl_TExprDef.TUnop(op,e2)
            else:
                d = hxsl_TExprDef.TUnop(op,e2)
        elif (d1 == 7):
            v = _g.params[0]
            init = _g.params[1]
            d = hxsl_TExprDef.TVarDecl(self.mapVar(v),(None if ((init is None)) else self.evalExpr(init)))
        elif (d1 == 8):
            c = _g.params[0]
            eargs = _g.params[1]
            c1 = self.evalExpr(c)
            _g1 = []
            _g2 = 0
            while (_g2 < len(eargs)):
                a = (eargs[_g2] if _g2 >= 0 and _g2 < len(eargs) else None)
                _g2 = (_g2 + 1)
                x = self.evalExpr(a)
                _g1.append(x)
            args = _g1
            _g1 = c1.e
            d1 = _g1.index
            if (d1 == 1):
                v = _g1.params[0]
                if (v in self.funMap.h):
                    f = self.funMap.h.get(v,None)
                    outExprs = []
                    undo = []
                    _g2 = 0
                    _g3 = len(f.args)
                    while (_g2 < _g3):
                        i = _g2
                        _g2 = (_g2 + 1)
                        v = [(f.args[i] if i >= 0 and i < len(f.args) else None)]
                        e1 = (args[i] if i >= 0 and i < len(args) else None)
                        _g4 = e1.e
                        d1 = _g4.index
                        if (d1 == 0):
                            _g5 = _g4.params[0]
                            old = [self.constants.h.get((v[0] if 0 < len(v) else None).id,None)]
                            def _hx_local_2(old,v):
                                def _hx_local_1():
                                    if ((old[0] if 0 < len(old) else None) is None):
                                        _gthis.constants.remove((v[0] if 0 < len(v) else None).id)
                                    else:
                                        _gthis.constants.set((v[0] if 0 < len(v) else None).id,(old[0] if 0 < len(old) else None))
                                return _hx_local_1
                            undo.append(_hx_local_2(old,v))
                            self.constants.set((v[0] if 0 < len(v) else None).id,e1.e)
                        elif (d1 == 1):
                            _g6 = _g4.params[0]
                            _g7 = _g6.id
                            _g8 = _g6.name
                            _g9 = Reflect.field(_g6,"parent")
                            _g10 = Reflect.field(_g6,"qualifiers")
                            _g11 = _g6.type
                            d2 = _g6.kind.index
                            if (((d2 == 2) or ((d2 == 1))) or ((d2 == 0))):
                                old1 = [self.constants.h.get((v[0] if 0 < len(v) else None).id,None)]
                                def _hx_local_4(old,v):
                                    def _hx_local_3():
                                        if ((old[0] if 0 < len(old) else None) is None):
                                            _gthis.constants.remove((v[0] if 0 < len(v) else None).id)
                                        else:
                                            _gthis.constants.set((v[0] if 0 < len(v) else None).id,(old[0] if 0 < len(old) else None))
                                    return _hx_local_3
                                undo.append(_hx_local_4(old1,v))
                                self.constants.set((v[0] if 0 < len(v) else None).id,e1.e)
                            else:
                                old2 = [self.varMap.h.get((v[0] if 0 < len(v) else None),None)]
                                if ((old2[0] if 0 < len(old2) else None) is None):
                                    def _hx_local_6(v):
                                        def _hx_local_5():
                                            _gthis.varMap.remove((v[0] if 0 < len(v) else None))
                                        return _hx_local_5
                                    undo.append(_hx_local_6(v))
                                else:
                                    self.varMap.remove((v[0] if 0 < len(v) else None))
                                    def _hx_local_8(old,v):
                                        def _hx_local_7():
                                            _gthis.varMap.set((v[0] if 0 < len(v) else None),(old[0] if 0 < len(old) else None))
                                        return _hx_local_7
                                    undo.append(_hx_local_8(old2,v))
                                v2 = self.mapVar((v[0] if 0 < len(v) else None))
                                x = _hx_AnonObject({'e': hxsl_TExprDef.TVarDecl(v2,e1), 't': hxsl_Type.TVoid, 'p': e1.p})
                                outExprs.append(x)
                        else:
                            old3 = [self.varMap.h.get((v[0] if 0 < len(v) else None),None)]
                            if ((old3[0] if 0 < len(old3) else None) is None):
                                def _hx_local_10(v):
                                    def _hx_local_9():
                                        _gthis.varMap.remove((v[0] if 0 < len(v) else None))
                                    return _hx_local_9
                                undo.append(_hx_local_10(v))
                            else:
                                self.varMap.remove((v[0] if 0 < len(v) else None))
                                def _hx_local_12(old,v):
                                    def _hx_local_11():
                                        _gthis.varMap.set((v[0] if 0 < len(v) else None),(old[0] if 0 < len(old) else None))
                                    return _hx_local_11
                                undo.append(_hx_local_12(old3,v))
                            v21 = self.mapVar((v[0] if 0 < len(v) else None))
                            x1 = _hx_AnonObject({'e': hxsl_TExprDef.TVarDecl(v21,e1), 't': hxsl_Type.TVoid, 'p': e1.p})
                            outExprs.append(x1)
                    e1 = self.handleReturn(self.evalExpr(f.expr,False),True)
                    _g2 = 0
                    while (_g2 < len(undo)):
                        u = (undo[_g2] if _g2 >= 0 and _g2 < len(undo) else None)
                        _g2 = (_g2 + 1)
                        u()
                    _g2 = e1.e
                    if (_g2.index == 4):
                        el = _g2.params[0]
                        _g2 = 0
                        while (_g2 < len(el)):
                            e2 = (el[_g2] if _g2 >= 0 and _g2 < len(el) else None)
                            _g2 = (_g2 + 1)
                            outExprs.append(e2)
                    else:
                        outExprs.append(e1)
                    d = hxsl_TExprDef.TBlock(outExprs)
                else:
                    d = hxsl_TExprDef.TCall(c1,args)
            elif (d1 == 2):
                g = _g1.params[0]
                v1 = self.evalCall(g,args,eargs,e.p)
                d = (v1 if ((v1 is not None)) else hxsl_TExprDef.TCall(c1,args))
            else:
                d = hxsl_Error.t((("Cannot eval non-static call expresssion '" + HxOverrides.stringOrNull(hxsl_Printer().exprString(c1))) + "'"),c1.p)
        elif (d1 == 9):
            e1 = _g.params[0]
            r = _g.params[1]
            d = hxsl_TExprDef.TSwiz(self.evalExpr(e1),list(r))
        elif (d1 == 10):
            econd = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            econd1 = self.evalExpr(econd)
            _g1 = econd1.e
            if (_g1.index == 0):
                _g2 = _g1.params[0]
                if (_g2.index == 1):
                    b = _g2.params[0]
                    d = (self.evalExpr(eif,isVal).e if b else (hxsl_TExprDef.TConst(hxsl_Const.CNull) if ((eelse is None)) else self.evalExpr(eelse,isVal).e))
                elif ((isVal and ((eelse is not None))) and self.eliminateConditionals):
                    d = hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), 't': e.t, 'p': e.p}),[self.evalExpr(eelse,True), self.evalExpr(eif,True), _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), 't': hxsl_Type.TFun([]), 'p': econd1.p}),[econd1]), 't': hxsl_Type.TFloat, 'p': e.p})])
                else:
                    eif = self.evalExpr(eif,isVal)
                    if (eelse is not None):
                        eelse = self.evalExpr(eelse,isVal)
                        _g1 = eelse.e
                        if ((_g1.index == 0) and ((_g1.params[0].index == 0))):
                            eelse = None
                    eif = self.ifBlock(eif)
                    eelse = self.ifBlock(eelse)
                    d = hxsl_TExprDef.TIf(econd1,eif,eelse)
            elif ((isVal and ((eelse is not None))) and self.eliminateConditionals):
                d = hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), 't': e.t, 'p': e.p}),[self.evalExpr(eelse,True), self.evalExpr(eif,True), _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), 't': hxsl_Type.TFun([]), 'p': econd1.p}),[econd1]), 't': hxsl_Type.TFloat, 'p': e.p})])
            else:
                eif = self.evalExpr(eif,isVal)
                if (eelse is not None):
                    eelse = self.evalExpr(eelse,isVal)
                    _g1 = eelse.e
                    if ((_g1.index == 0) and ((_g1.params[0].index == 0))):
                        eelse = None
                eif = self.ifBlock(eif)
                eelse = self.ifBlock(eelse)
                d = hxsl_TExprDef.TIf(econd1,eif,eelse)
        elif (d1 == 11):
            d = hxsl_TExprDef.TDiscard
        elif (d1 == 12):
            e1 = _g.params[0]
            d = hxsl_TExprDef.TReturn((None if ((e1 is None)) else self.evalExpr(e1)))
        elif (d1 == 13):
            v1 = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            v2 = self.mapVar(v1)
            it1 = self.evalExpr(it)
            e1 = None
            _g1 = it1.e
            if (_g1.index == 5):
                _g2 = _g1.params[1]
                _g3 = _g1.params[2]
                if (_g1.params[0].index == 21):
                    _g1 = _g2.e
                    _g4 = _g2.p
                    _g4 = _g2.t
                    if (_g1.index == 0):
                        _g2 = _g1.params[0]
                        if (_g2.index == 2):
                            _g1 = _g3.e
                            _g4 = _g3.p
                            _g4 = _g3.t
                            if (_g1.index == 0):
                                _g3 = _g1.params[0]
                                if (_g3.index == 2):
                                    _hx_len = _g3.params[0]
                                    start = _g2.params[0]
                                    if self.unrollLoops:
                                        out = []
                                        _g1 = start
                                        _g2 = _hx_len
                                        while (_g1 < _g2):
                                            i = _g1
                                            _g1 = (_g1 + 1)
                                            self.constants.set(v1.id,hxsl_TExprDef.TConst(hxsl_Const.CInt(i)))
                                            x = self.evalExpr(loop,False)
                                            out.append(x)
                                        self.constants.remove(v1.id)
                                        e1 = hxsl_TExprDef.TBlock(out)
                                    else:
                                        e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
                                else:
                                    e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
                            else:
                                e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
                        else:
                            e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
                    else:
                        e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
                else:
                    e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
            else:
                e1 = hxsl_TExprDef.TFor(v2,it1,self.ifBlock(self.evalExpr(loop,False)))
            self.varMap.remove(v1)
            d = e1
        elif (d1 == 14):
            d = hxsl_TExprDef.TContinue
        elif (d1 == 15):
            d = hxsl_TExprDef.TBreak
        elif (d1 == 16):
            e1 = _g.params[0]
            e2 = _g.params[1]
            e11 = self.evalExpr(e1)
            e21 = self.evalExpr(e2)
            _g1 = e11.e
            _g2 = e21.e
            if (_g1.index == 17):
                if (_g2.index == 0):
                    _g3 = _g2.params[0]
                    if (_g3.index == 2):
                        i = _g3.params[0]
                        el = _g1.params[0]
                        d = ((el[i] if i >= 0 and i < len(el) else None).e if (((i >= 0) and ((i < len(el))))) else hxsl_TExprDef.TArray(e11,e21))
                    else:
                        d = hxsl_TExprDef.TArray(e11,e21)
                else:
                    d = hxsl_TExprDef.TArray(e11,e21)
            else:
                d = hxsl_TExprDef.TArray(e11,e21)
        elif (d1 == 17):
            el = _g.params[0]
            _g1 = []
            _g2 = 0
            while (_g2 < len(el)):
                e1 = (el[_g2] if _g2 >= 0 and _g2 < len(el) else None)
                _g2 = (_g2 + 1)
                x = self.evalExpr(e1)
                _g1.append(x)
            d = hxsl_TExprDef.TArrayDecl(_g1)
        elif (d1 == 18):
            e1 = _g.params[0]
            cases = _g.params[1]
            _hx_def = _g.params[2]
            e2 = self.evalExpr(e1)
            _g1 = []
            _g2 = 0
            while (_g2 < len(cases)):
                c = (cases[_g2] if _g2 >= 0 and _g2 < len(cases) else None)
                _g2 = (_g2 + 1)
                _g3 = []
                _g4 = 0
                _g5 = c.values
                while (_g4 < len(_g5)):
                    v1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                    _g4 = (_g4 + 1)
                    x = self.evalExpr(v1)
                    _g3.append(x)
                x1 = _hx_AnonObject({'values': _g3, 'expr': self.evalExpr(c.expr,isVal)})
                _g1.append(x1)
            cases = _g1
            def1 = (None if ((_hx_def is None)) else self.evalExpr(_hx_def,isVal))
            hasCase = False
            _g1 = e2.e
            if (_g1.index == 0):
                c = _g1.params[0]
                if (c.index == 2):
                    val = c.params[0]
                    _g1 = 0
                    while (_g1 < len(cases)):
                        c1 = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
                        _g1 = (_g1 + 1)
                        _g2 = 0
                        _g3 = c1.values
                        while (_g2 < len(_g3)):
                            v1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                            _g2 = (_g2 + 1)
                            _g4 = v1.e
                            if (_g4.index == 0):
                                cst = _g4.params[0]
                                d1 = cst.index
                                if (d1 == 2):
                                    k = cst.params[0]
                                    if (k == val):
                                        return c1.expr
                                elif (d1 == 3):
                                    k1 = cst.params[0]
                                    if (k1 == val):
                                        return c1.expr
                                else:
                                    pass
                            else:
                                hasCase = True
                else:
                    raise haxe_Exception.thrown(("Unsupported switch constant " + Std.string(c)))
            else:
                hasCase = True
            d = (hxsl_TExprDef.TSwitch(e2,cases,def1) if hasCase else (hxsl_TExprDef.TBlock([]) if ((def1 is None)) else def1.e))
        elif (d1 == 19):
            cond = _g.params[0]
            loop = _g.params[1]
            normalWhile = _g.params[2]
            cond1 = self.evalExpr(cond)
            loop1 = self.evalExpr(loop,False)
            d = hxsl_TExprDef.TWhile(cond1,self.ifBlock(loop1),normalWhile)
        elif (d1 == 20):
            name = _g.params[0]
            args = _g.params[1]
            e1 = _g.params[2]
            e2 = None
            if (name == "unroll"):
                old4 = self.unrollLoops
                self.unrollLoops = True
                e2 = self.evalExpr(e1,isVal)
                self.unrollLoops = False
            else:
                e2 = self.evalExpr(e1,isVal)
            d = hxsl_TExprDef.TMeta(name,args,e2)
        else:
            pass
        return _hx_AnonObject({'e': d, 't': e.t, 'p': e.p})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.varMap = None
        _hx_o.inlineCalls = None
        _hx_o.unrollLoops = None
        _hx_o.eliminateConditionals = None
        _hx_o.constants = None
        _hx_o.funMap = None
        _hx_o.curFun = None
        _hx_o.markReturn = None
hxsl_Eval._hx_class = hxsl_Eval
_hx_classes["hxsl.Eval"] = hxsl_Eval


class hxsl__Flatten_Alloc:
    _hx_class_name = "hxsl._Flatten.Alloc"
    _hx_is_interface = "False"
    __slots__ = ("t", "pos", "size", "g", "v")
    _hx_fields = ["t", "pos", "size", "g", "v"]

    def __init__(self,g,t,pos,size):
        self.v = None
        self.g = g
        self.t = t
        self.pos = pos
        self.size = size

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.t = None
        _hx_o.pos = None
        _hx_o.size = None
        _hx_o.g = None
        _hx_o.v = None
hxsl__Flatten_Alloc._hx_class = hxsl__Flatten_Alloc
_hx_classes["hxsl._Flatten.Alloc"] = hxsl__Flatten_Alloc

class hxsl_ARead(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.ARead"
    _hx_constructs = ["AIndex", "AOffset"]

    @staticmethod
    def AIndex(a):
        return hxsl_ARead("AIndex", 0, (a,))

    @staticmethod
    def AOffset(a,stride,delta):
        return hxsl_ARead("AOffset", 1, (a,stride,delta))
hxsl_ARead._hx_class = hxsl_ARead
_hx_classes["hxsl.ARead"] = hxsl_ARead


class hxsl_Flatten:
    _hx_class_name = "hxsl.Flatten"
    _hx_is_interface = "False"
    __slots__ = ("globals", "params", "outVars", "varMap", "econsts", "consts", "allocData")
    _hx_fields = ["globals", "params", "outVars", "varMap", "econsts", "consts", "allocData"]
    _hx_methods = ["flatten", "mapFun", "mapExpr", "mapConsts", "allocConst", "allocConsts", "mkInt", "readIndex", "readOffset", "access", "toInt", "optimize", "packTextures", "packBuffers", "pack", "varSize", "gatherVar"]

    def __init__(self):
        self.allocData = None
        self.consts = None
        self.econsts = None
        self.varMap = None
        self.outVars = None
        self.params = None
        self.globals = None

    def flatten(self,s,kind,constsToGlobal):
        self.globals = []
        self.params = []
        self.outVars = []
        if constsToGlobal:
            self.consts = []
            p = (s.funs[0] if 0 < len(s.funs) else None).expr.p
            gc = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': "__consts__", 'kind': hxsl_VarKind.Global, 'type': None})
            self.econsts = _hx_AnonObject({'e': hxsl_TExprDef.TVar(gc), 't': None, 'p': p})
            s1 = s.name
            s2 = list(s.vars)
            _g = []
            _g1 = 0
            _g2 = s.funs
            while (_g1 < len(_g2)):
                f = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                x = self.mapFun(f,self.mapConsts)
                _g.append(x)
            s = _hx_AnonObject({'name': s1, 'vars': s2, 'funs': _g})
            _g = 0
            _g1 = s.vars
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _g2 = v.type
                if (_g2.index == 9):
                    _g3 = _g2.params[0]
                    self.allocConst(255,p)
            if (len(self.consts) > 0):
                def _hx_local_2():
                    self.econsts.t = hxsl_Type.TArray(hxsl_Type.TFloat,hxsl_SizeDecl.SConst(len(self.consts)))
                    return self.econsts.t
                gc.type = _hx_local_2()
                _this = s.vars
                _this.append(gc)
        self.varMap = haxe_ds_ObjectMap()
        self.allocData = haxe_ds_ObjectMap()
        _g = 0
        _g1 = s.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.gatherVar(v)
        prefix = None
        prefix1 = kind.index
        if (prefix1 == 0):
            prefix = "vertex"
        elif (prefix1 == 1):
            prefix = "fragment"
        else:
            raise haxe_Exception.thrown("assert")
        self.pack((("null" if prefix is None else prefix) + "Globals"),hxsl_VarKind.Global,self.globals,hxsl_VecType.VFloat)
        self.pack((("null" if prefix is None else prefix) + "Params"),hxsl_VarKind.Param,self.params,hxsl_VecType.VFloat)
        allVars = (self.globals + self.params)
        textures = ((self.packTextures((("null" if prefix is None else prefix) + "Textures"),allVars,hxsl_Type.TSampler2D) + self.packTextures((("null" if prefix is None else prefix) + "TexturesCube"),allVars,hxsl_Type.TSamplerCube)) + self.packTextures((("null" if prefix is None else prefix) + "TexturesArray"),allVars,hxsl_Type.TSampler2DArray))
        self.packBuffers(allVars)
        _g = []
        _g1 = 0
        _g2 = s.funs
        while (_g1 < len(_g2)):
            f = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = self.mapFun(f,self.mapExpr)
            _g.append(x)
        funs = _g
        return _hx_AnonObject({'name': s.name, 'vars': self.outVars, 'funs': funs})

    def mapFun(self,f,mapExpr):
        return _hx_AnonObject({'kind': f.kind, 'ret': f.ret, 'args': f.args, 'ref': f.ref, 'expr': mapExpr(f.expr)})

    def mapExpr(self,e):
        _g = e.e
        e1 = _g.index
        if (e1 == 1):
            v = _g.params[0]
            a = self.varMap.h.get(v,None)
            if (a is not None):
                e = self.access(a,v.type,e.p,hxsl_ARead.AIndex(a))
        elif (e1 == 16):
            _g1 = _g.params[0]
            _g2 = _g1.e
            _g3 = _g1.t
            if (_g2.index == 1):
                v = _g2.params[0]
                vp = _g1.p
                eindex = _g.params[1]
                _g = eindex.e
                e1 = None
                if (_g.index == 0):
                    _g1 = _g.params[0]
                    if (_g1.index == 2):
                        _g = _g1.params[0]
                        e1 = True
                    else:
                        e1 = False
                else:
                    e1 = False
                if (not e1):
                    a = self.varMap.h.get(v,None)
                    if (a is not None):
                        _g = v.type
                        if (_g.index == 15):
                            _g1 = _g.params[0]
                            _g2 = _g.params[1]
                            t = _g1
                            if hxsl_Tools.isSampler(t):
                                eindex = self.toInt(self.mapExpr(eindex))
                                e = self.access(a,t,vp,hxsl_ARead.AOffset(a,1,eindex))
                            else:
                                t = _g1
                                stride = self.varSize(t,a.t)
                                if ((stride == 0) or ((((stride & 3)) != 0))):
                                    raise haxe_Exception.thrown(hxsl_Error("Dynamic access to an Array which size is not 4 components-aligned is not allowed",e.p))
                                stride = (stride >> 2)
                                eindex = self.toInt(self.mapExpr(eindex))
                                e = self.access(a,t,vp,hxsl_ARead.AOffset(a,stride,(eindex if ((stride == 1)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpMult,eindex,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(stride)), 't': hxsl_Type.TInt, 'p': vp})), 't': hxsl_Type.TInt, 'p': vp}))))
                        else:
                            raise haxe_Exception.thrown("assert")
                else:
                    e = hxsl_Tools.map(e,self.mapExpr)
            else:
                e = hxsl_Tools.map(e,self.mapExpr)
        else:
            e = hxsl_Tools.map(e,self.mapExpr)
        return self.optimize(e)

    def mapConsts(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            c = _g.params[0]
            tmp = c.index
            if (tmp == 2):
                v = c.params[0]
                return self.allocConst(v,e.p)
            elif (tmp == 3):
                v = c.params[0]
                return self.allocConst(v,e.p)
            else:
                return e
        elif (tmp == 2):
            g = _g.params[0]
            tmp = g.index
            if (tmp == 0):
                self.allocConst((Math.PI / 180),e.p)
            elif (tmp == 1):
                self.allocConst((180 / Math.PI),e.p)
            elif (tmp == 9):
                self.allocConst(1.4426950408889634,e.p)
            elif (tmp == 10):
                self.allocConst(0.6931471805599453,e.p)
            elif (tmp == 24):
                self.allocConst(1,e.p)
            elif (tmp == 26):
                self.allocConst(2.0,e.p)
                self.allocConst(3.0,e.p)
            elif (tmp == 54):
                self.allocConsts([1, 255, 65025, 16581375],e.p)
                self.allocConsts([0.00392156862745098, 0.00392156862745098, 0.00392156862745098, 0],e.p)
            elif (tmp == 55):
                self.allocConsts([1, 0.00392156862745098, 1.53787004998077679e-05, 6.03086294110108446e-08],e.p)
            elif (tmp == 56):
                self.allocConst(1,e.p)
                self.allocConst(0.5,e.p)
            elif (tmp == 57):
                self.allocConst(0.5,e.p)
            elif (tmp == 58):
                self.allocConsts([0.5, 0.5],e.p)
                self.allocConsts([0.5, -0.5],e.p)
            elif (tmp == 59):
                self.allocConsts([2, -2],e.p)
                self.allocConsts([-1, 1],e.p)
            else:
                pass
        elif (tmp == 5):
            _g1 = _g.params[1]
            _g1 = _g.params[2]
            if (_g.params[0].index == 1):
                _g2 = _g1.e
                _g2 = _g1.p
                if (_g1.t.index == 8):
                    self.allocConst(1,e.p)
        elif (tmp == 8):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g1.e
            _g4 = _g1.p
            _g4 = _g1.t
            if (_g3.index == 2):
                if (_g3.params[0].index == 42):
                    if (len(_g2) == 2):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g3 = (_g2[1] if 1 < len(_g2) else None)
                        _g2 = _g1.e
                        _g4 = _g1.p
                        _g4 = _g1.t
                        if (_g2.index == 1):
                            _g1 = _g2.params[0]
                            _g2 = _g1.id
                            _g2 = _g1.name
                            _g2 = Reflect.field(_g1,"parent")
                            _g2 = Reflect.field(_g1,"qualifiers")
                            _g2 = _g1.type
                            tmp = _g1.kind.index
                            if (tmp == 0):
                                if (_g4.index == 5):
                                    if (_g4.params[0] == 3):
                                        if (_g4.params[1].index == 1):
                                            _g1 = _g3.e
                                            _g2 = _g3.p
                                            _g2 = _g3.t
                                            if (_g1.index == 0):
                                                _g2 = _g1.params[0]
                                                if (_g2.index == 2):
                                                    if (_g2.params[0] == 1):
                                                        return e
                            elif (tmp == 1):
                                if (_g4.index == 5):
                                    if (_g4.params[0] == 3):
                                        if (_g4.params[1].index == 1):
                                            _g1 = _g3.e
                                            _g2 = _g3.p
                                            _g2 = _g3.t
                                            if (_g1.index == 0):
                                                _g2 = _g1.params[0]
                                                if (_g2.index == 2):
                                                    if (_g2.params[0] == 1):
                                                        return e
                            elif (tmp == 2):
                                if (_g4.index == 5):
                                    if (_g4.params[0] == 3):
                                        if (_g4.params[1].index == 1):
                                            _g1 = _g3.e
                                            _g2 = _g3.p
                                            _g2 = _g3.t
                                            if (_g1.index == 0):
                                                _g2 = _g1.params[0]
                                                if (_g2.index == 2):
                                                    if (_g2.params[0] == 1):
                                                        return e
                            elif (tmp == 3):
                                if (_g4.index == 5):
                                    if (_g4.params[0] == 3):
                                        if (_g4.params[1].index == 1):
                                            _g1 = _g3.e
                                            _g2 = _g3.p
                                            _g2 = _g3.t
                                            if (_g1.index == 0):
                                                _g2 = _g1.params[0]
                                                if (_g2.index == 2):
                                                    if (_g2.params[0] == 1):
                                                        return e
                            else:
                                pass
        elif (tmp == 16):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g = _g2.e
            _g3 = _g2.p
            _g3 = _g2.t
            if (_g.index == 0):
                _g3 = _g.params[0]
                if (_g3.index == 2):
                    _g = _g3.params[0]
                    eindex = _g2
                    ea = _g1
                    return _hx_AnonObject({'e': hxsl_TExprDef.TArray(self.mapConsts(ea),eindex), 't': e.t, 'p': e.p})
                else:
                    eindex = _g2
                    ea = _g1
                    _g = ea.t
                    if (_g.index == 15):
                        _g3 = _g.params[1]
                        t = _g.params[0]
                        stride = (self.varSize(t,hxsl_VecType.VFloat) >> 2)
                        self.allocConst(stride,e.p)
            else:
                eindex = _g2
                ea = _g1
                _g = ea.t
                if (_g.index == 15):
                    _g1 = _g.params[1]
                    t = _g.params[0]
                    stride = (self.varSize(t,hxsl_VecType.VFloat) >> 2)
                    self.allocConst(stride,e.p)
        else:
            pass
        return hxsl_Tools.map(e,self.mapConsts)

    def allocConst(self,v,p):
        index = python_internal_ArrayImpl.indexOf(self.consts,v,None)
        if (index < 0):
            index = len(self.consts)
            _this = self.consts
            _this.append(v)
        return _hx_AnonObject({'e': hxsl_TExprDef.TArray(self.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})

    def allocConsts(self,va,p):
        _gthis = self
        pad = ((len(va) - 1) & 3)
        index = -1
        _g = 0
        _g1 = (len(self.consts) - ((len(va) - 1)))
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((i >> 2) != (((i + pad) >> 2))):
                continue
            found = True
            _g2 = 0
            _g3 = len(va)
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                if (python_internal_ArrayImpl._get(self.consts, (i + j)) != (va[j] if j >= 0 and j < len(va) else None)):
                    found = False
                    break
            if found:
                index = i
                break
        if (index < 0):
            while ((len(self.consts) >> 2) != (((len(self.consts) + pad) >> 2))):
                _this = self.consts
                _this.append(0)
            index = len(self.consts)
            _g = 0
            while (_g < len(va)):
                v = (va[_g] if _g >= 0 and _g < len(va) else None)
                _g = (_g + 1)
                _this = self.consts
                _this.append(v)
        _g = len(va)
        if (_g == 1):
            return _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})
        elif (_g == 2):
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec2), 't': hxsl_Type.TVoid, 'p': p}),[_hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 1))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})]), 't': hxsl_Type.TVec(2,hxsl_VecType.VFloat), 'p': p})
        elif (_g == 3):
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec3), 't': hxsl_Type.TVoid, 'p': p}),[_hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 1))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 2))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})]), 't': hxsl_Type.TVec(3,hxsl_VecType.VFloat), 'p': p})
        elif (_g == 4):
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec4), 't': hxsl_Type.TVoid, 'p': p}),[_hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 1))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 3))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 4))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})]), 't': hxsl_Type.TVec(4,hxsl_VecType.VFloat), 'p': p})
        else:
            raise haxe_Exception.thrown("assert")

    def mkInt(self,v,pos):
        return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(v)), 't': hxsl_Type.TInt, 'p': pos})

    def readIndex(self,a,index,pos):
        offs = (a.pos if ((a.t is None)) else (a.pos >> 2))
        return _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a.g), 't': a.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((offs + index))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a.t), 'p': pos})

    def readOffset(self,a,stride,delta,index,pos):
        index1 = (((a.pos if ((a.t is None)) else (a.pos >> 2))) + index)
        offset = (delta if ((index1 == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index1)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
        return _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a.g), 't': a.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a.t), 'p': pos})

    def access(self,a,t,pos,acc):
        _gthis = self
        tmp = t.index
        if (tmp == 6):
            tmp = self.access(a,hxsl_Type.TMat3x4,pos,acc)
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3), 't': hxsl_Type.TFun([]), 'p': pos}),[tmp]), 't': hxsl_Type.TMat3, 'p': pos})
        elif (tmp == 7):
            tmp = hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4)
            tmp1 = hxsl_Type.TFun([])
            tmp2 = None
            tmp3 = acc.index
            if (tmp3 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp2 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp3 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp2 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            tmp3 = None
            tmp4 = acc.index
            if (tmp4 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp3 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((offs + 1))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp4 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (((a1.pos if ((a1.t is None)) else (a1.pos >> 2))) + 1)
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp3 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            tmp4 = None
            tmp5 = acc.index
            if (tmp5 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp4 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((offs + 2))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp5 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (((a1.pos if ((a1.t is None)) else (a1.pos >> 2))) + 2)
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp4 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            tmp5 = None
            tmp6 = acc.index
            if (tmp6 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp5 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((offs + 3))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp6 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (((a1.pos if ((a1.t is None)) else (a1.pos >> 2))) + 3)
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp5 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': tmp, 't': tmp1, 'p': pos}),[tmp2, tmp3, tmp4, tmp5]), 't': hxsl_Type.TMat4, 'p': pos})
        elif (tmp == 8):
            tmp = hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3x4)
            tmp1 = hxsl_Type.TFun([])
            tmp2 = None
            tmp3 = acc.index
            if (tmp3 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp2 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp3 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp2 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            tmp3 = None
            tmp4 = acc.index
            if (tmp4 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp3 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((offs + 1))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp4 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (((a1.pos if ((a1.t is None)) else (a1.pos >> 2))) + 1)
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp3 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            tmp4 = None
            tmp5 = acc.index
            if (tmp5 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                tmp4 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((offs + 2))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp5 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (((a1.pos if ((a1.t is None)) else (a1.pos >> 2))) + 2)
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp4 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': tmp, 't': tmp1, 'p': pos}),[tmp2, tmp3, tmp4]), 't': hxsl_Type.TMat3x4, 'p': pos})
        elif (tmp == 15):
            _g = t.params[1]
            if (_g.index == 0):
                _hx_len = _g.params[0]
                t1 = t.params[0]
                x = (a.size / _hx_len)
                stride = None
                try:
                    stride = int(x)
                except BaseException as _g:
                    None
                    stride = None
                _g = []
                _g1 = 0
                _g2 = _hx_len
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    a1 = hxsl__Flatten_Alloc(a.g,a.t,(a.pos + ((stride * i))),stride)
                    x = self.access(a1,t1,pos,hxsl_ARead.AIndex(a1))
                    _g.append(x)
                earr = _g
                return _hx_AnonObject({'e': hxsl_TExprDef.TArrayDecl(earr), 't': t1, 'p': pos})
            else:
                if hxsl_Tools.isSampler(t):
                    e = None
                    e1 = acc.index
                    if (e1 == 0):
                        a1 = acc.params[0]
                        offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                        e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
                    elif (e1 == 1):
                        a1 = acc.params[0]
                        stride = acc.params[1]
                        delta = acc.params[2]
                        index = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                        offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                        e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
                    else:
                        pass
                    e.t = t
                    return e
                size = self.varSize(t,a.t)
                if (size > 4):
                    return hxsl_Error.t(("Access not supported for " + HxOverrides.stringOrNull(hxsl_Tools.toString(t))),None)
                e = None
                e1 = acc.index
                if (e1 == 0):
                    a1 = acc.params[0]
                    offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
                elif (e1 == 1):
                    a1 = acc.params[0]
                    stride = acc.params[1]
                    delta = acc.params[2]
                    index = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                    offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
                else:
                    pass
                if (size == 4):
                    if (((a.pos & 3)) != 0):
                        raise haxe_Exception.thrown("assert")
                else:
                    sw = []
                    _g = 0
                    _g1 = size
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        x = python_internal_ArrayImpl._get(hxsl_Tools.SWIZ, (i + ((a.pos & 3))))
                        sw.append(x)
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TSwiz(e,sw), 't': t, 'p': pos})
                tmp = t.index
                if (tmp == 1):
                    e.t = hxsl_Type.TFloat
                    e = self.toInt(e)
                elif (tmp == 5):
                    if (t.params[1].index == 0):
                        size = t.params[0]
                        e.t = hxsl_Type.TVec(size,hxsl_VecType.VFloat)
                        e = _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(python_internal_ArrayImpl._get([hxsl_TGlobal.IVec2, hxsl_TGlobal.IVec3, hxsl_TGlobal.IVec4], (size - 2))), 't': hxsl_Type.TFun([]), 'p': pos}),[e]), 't': t, 'p': pos})
                else:
                    pass
                return e
        else:
            if hxsl_Tools.isSampler(t):
                e = None
                e1 = acc.index
                if (e1 == 0):
                    a1 = acc.params[0]
                    offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
                elif (e1 == 1):
                    a1 = acc.params[0]
                    stride = acc.params[1]
                    delta = acc.params[2]
                    index = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                    offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
                else:
                    pass
                e.t = t
                return e
            size = self.varSize(t,a.t)
            if (size > 4):
                return hxsl_Error.t(("Access not supported for " + HxOverrides.stringOrNull(hxsl_Tools.toString(t))),None)
            e = None
            e1 = acc.index
            if (e1 == 0):
                a1 = acc.params[0]
                offs = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (e1 == 1):
                a1 = acc.params[0]
                stride = acc.params[1]
                delta = acc.params[2]
                index = (a1.pos if ((a1.t is None)) else (a1.pos >> 2))
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                e = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            else:
                pass
            if (size == 4):
                if (((a.pos & 3)) != 0):
                    raise haxe_Exception.thrown("assert")
            else:
                sw = []
                _g = 0
                _g1 = size
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    x = python_internal_ArrayImpl._get(hxsl_Tools.SWIZ, (i + ((a.pos & 3))))
                    sw.append(x)
                e = _hx_AnonObject({'e': hxsl_TExprDef.TSwiz(e,sw), 't': t, 'p': pos})
            tmp = t.index
            if (tmp == 1):
                e.t = hxsl_Type.TFloat
                e = self.toInt(e)
            elif (tmp == 5):
                if (t.params[1].index == 0):
                    size = t.params[0]
                    e.t = hxsl_Type.TVec(size,hxsl_VecType.VFloat)
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(python_internal_ArrayImpl._get([hxsl_TGlobal.IVec2, hxsl_TGlobal.IVec3, hxsl_TGlobal.IVec4], (size - 2))), 't': hxsl_Type.TFun([]), 'p': pos}),[e]), 't': t, 'p': pos})
            else:
                pass
            return e

    def toInt(self,e):
        if (e.t == hxsl_Type.TInt):
            return e
        return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToInt), 't': hxsl_Type.TFun([]), 'p': e.p}),[e]), 't': hxsl_Type.TInt, 'p': e.p})

    def optimize(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 8):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g1.e
            _g4 = _g1.p
            _g4 = _g1.t
            if (_g3.index == 2):
                if (_g3.params[0].index == 52):
                    if (len(_g2) == 1):
                        _g1 = (_g2[0] if 0 < len(_g2) else None)
                        _g2 = _g1.e
                        _g3 = _g1.p
                        _g3 = _g1.t
                        if (_g2.index == 8):
                            _g1 = _g2.params[0]
                            _g3 = _g1.e
                            _g4 = _g1.p
                            _g4 = _g1.t
                            if (_g3.index == 2):
                                if (_g3.params[0].index == 51):
                                    args = _g2.params[1]
                                    rem = 0
                                    size = 0
                                    while (size < 4):
                                        t = python_internal_ArrayImpl._get(args, ((len(args) - 1) - rem)).t
                                        size = (size + self.varSize(t,hxsl_VecType.VFloat))
                                        rem = (rem + 1)
                                    if (size == 4):
                                        _g1 = 0
                                        _g2 = rem
                                        while (_g1 < _g2):
                                            i = _g1
                                            _g1 = (_g1 + 1)
                                            if (len(args) != 0):
                                                args.pop()
                                        emat = None
                                        _g1 = e.e
                                        if (_g1.index == 8):
                                            _g2 = _g1.params[1]
                                            e1 = _g1.params[0]
                                            emat = e1
                                        else:
                                            raise haxe_Exception.thrown("assert")
                                        return _hx_AnonObject({'e': hxsl_TExprDef.TCall(emat,args), 't': e.t, 'p': e.p})
        elif (tmp == 16):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g = _g1.e
            _g3 = _g1.p
            _g3 = _g1.t
            if (_g.index == 17):
                _g1 = _g2.e
                _g3 = _g2.p
                _g3 = _g2.t
                if (_g1.index == 0):
                    _g2 = _g1.params[0]
                    if (_g2.index == 2):
                        i = _g2.params[0]
                        el = _g.params[0]
                        if ((i >= 0) and ((i < len(el)))):
                            return (el[i] if i >= 0 and i < len(el) else None)
                        hxsl_Error.t("Reading outside array bounds",e.p)
        else:
            pass
        return e

    def packTextures(self,name,vars,t):
        alloc = list()
        g = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': name, 'type': t, 'kind': hxsl_VarKind.Param})
        pos = 0
        samplers = []
        _g = 0
        while (_g < len(vars)):
            v = (vars[_g] if _g >= 0 and _g < len(vars) else None)
            _g = (_g + 1)
            count = 1
            if (v.type != t):
                _g1 = v.type
                tmp = _g1.index
                if (tmp == 15):
                    _g2 = _g1.params[1]
                    if (_g2.index == 0):
                        n = _g2.params[0]
                        t2 = _g1.params[0]
                        if (t2 == t):
                            count = n
                        else:
                            continue
                    else:
                        continue
                elif (tmp == 17):
                    _g3 = _g1.params[0]
                    if (t != hxsl_Type.TSampler2D):
                        continue
                else:
                    continue
            a = hxsl__Flatten_Alloc(g,None,pos,count)
            a.v = v
            if (Reflect.field(v,"qualifiers") is not None):
                _g4 = 0
                _g5 = Reflect.field(v,"qualifiers")
                while (_g4 < len(_g5)):
                    q = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                    _g4 = (_g4 + 1)
                    if (q.index == 12):
                        name = q.params[0]
                        _g6 = 0
                        _g7 = count
                        while (_g6 < _g7):
                            i = _g6
                            _g6 = (_g6 + 1)
                            python_internal_ArrayImpl._set(samplers, (pos + i), name)
            self.varMap.set(v,a)
            alloc.append(a)
            pos = (pos + count)
        g.type = hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(pos))
        if (len(samplers) > 0):
            _g = 0
            _g1 = pos
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if ((samplers[i] if i >= 0 and i < len(samplers) else None) is None):
                    python_internal_ArrayImpl._set(samplers, i, "")
            if (Reflect.field(g,"qualifiers") is None):
                Reflect.setField(g,"qualifiers",[])
            _this = Reflect.field(g,"qualifiers")
            x = hxsl_VarQualifier.Sampler(",".join([python_Boot.toString1(x1,'') for x1 in samplers]))
            _this.append(x)
        if (len(alloc) > 0):
            _this = self.outVars
            _this.append(g)
            self.allocData.set(g,alloc)
        return alloc

    def packBuffers(self,vars):
        alloc = list()
        g = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': "buffers", 'type': hxsl_Type.TVoid, 'kind': hxsl_VarKind.Param})
        _g = 0
        while (_g < len(vars)):
            v = (vars[_g] if _g >= 0 and _g < len(vars) else None)
            _g = (_g + 1)
            _g1 = v.type
            tmp = None
            if (_g1.index == 16):
                _g2 = _g1.params[0]
                _g3 = _g1.params[1]
                tmp = True
            else:
                tmp = False
            if tmp:
                a = hxsl__Flatten_Alloc(g,None,len(alloc),1)
                a.v = v
                alloc.append(a)
                _this = self.outVars
                _this.append(v)
        g.type = hxsl_Type.TArray(hxsl_Type.TBuffer(hxsl_Type.TVoid,hxsl_SizeDecl.SConst(0)),hxsl_SizeDecl.SConst(len(alloc)))
        self.allocData.set(g,alloc)

    def pack(self,name,kind,vars,t):
        alloc = list()
        apos = 0
        g = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': name, 'type': hxsl_Type.TVec(0,t), 'kind': kind})
        _g = 0
        while (_g < len(vars)):
            v = (vars[_g] if _g >= 0 and _g < len(vars) else None)
            _g = (_g + 1)
            tmp = None
            if (not hxsl_Tools.isSampler(v.type)):
                _g1 = v.type
                if (_g1.index == 16):
                    _g2 = _g1.params[0]
                    _g3 = _g1.params[1]
                    tmp = True
                else:
                    tmp = False
            else:
                tmp = True
            if tmp:
                continue
            _g4 = v.type
            if (_g4.index == 15):
                _g5 = _g4.params[1]
                t1 = _g4.params[0]
                if hxsl_Tools.isSampler(t1):
                    continue
            size = self.varSize(v.type,t)
            best = None
            _g6 = 0
            while (_g6 < len(alloc)):
                a = (alloc[_g6] if _g6 >= 0 and _g6 < len(alloc) else None)
                _g6 = (_g6 + 1)
                if (((a.v is None) and ((a.size >= size))) and (((best is None) or ((best.size > a.size))))):
                    best = a
            if (best is not None):
                free = (best.size - size)
                if (free > 0):
                    i = python_internal_ArrayImpl.indexOf(alloc,best,None)
                    a1 = hxsl__Flatten_Alloc(g,t,(best.pos + size),free)
                    alloc.insert((i + 1), a1)
                    best.size = size
                best.v = v
                self.varMap.set(v,best)
            else:
                a2 = hxsl__Flatten_Alloc(g,t,apos,size)
                apos = (apos + size)
                a2.v = v
                self.varMap.set(v,a2)
                alloc.append(a2)
                pad = HxOverrides.mod(((4 - (HxOverrides.mod(size, 4)))), 4)
                if (pad > 0):
                    a3 = hxsl__Flatten_Alloc(g,t,apos,pad)
                    apos = (apos + pad)
                    alloc.append(a3)
        g.type = hxsl_Type.TArray(hxsl_Type.TVec(4,t),hxsl_SizeDecl.SConst((apos >> 2)))
        if (apos > 0):
            _this = self.outVars
            _this.append(g)
            self.allocData.set(g,alloc)
        return g

    def varSize(self,v,t):
        tmp = v.index
        if ((tmp == 3) or ((tmp == 1))):
            if (t == hxsl_VecType.VFloat):
                return 1
            else:
                raise haxe_Exception.thrown(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        elif (tmp == 5):
            n = v.params[0]
            t2 = v.params[1]
            if (t == t2):
                return n
            else:
                raise haxe_Exception.thrown(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        elif (tmp == 7):
            if (t == hxsl_VecType.VFloat):
                return 16
            else:
                raise haxe_Exception.thrown(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        elif ((tmp == 8) or ((tmp == 6))):
            if (t == hxsl_VecType.VFloat):
                return 12
            else:
                raise haxe_Exception.thrown(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        elif (tmp == 15):
            _g = v.params[1]
            if (_g.index == 0):
                n = _g.params[0]
                at = v.params[0]
                return (self.varSize(at,t) * n)
            else:
                raise haxe_Exception.thrown(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        else:
            raise haxe_Exception.thrown(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))

    def gatherVar(self,v):
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g = 0
            while (_g < len(vl)):
                v1 = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                self.gatherVar(v1)
        else:
            tmp = v.kind.index
            if (tmp == 0):
                if hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.PerObject):
                    _this = self.params
                    _this.append(v)
                else:
                    _this = self.globals
                    _this.append(v)
            elif (tmp == 2):
                _this = self.params
                _this.append(v)
            else:
                _this = self.outVars
                _this.append(v)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.globals = None
        _hx_o.params = None
        _hx_o.outVars = None
        _hx_o.varMap = None
        _hx_o.econsts = None
        _hx_o.consts = None
        _hx_o.allocData = None
hxsl_Flatten._hx_class = hxsl_Flatten
_hx_classes["hxsl.Flatten"] = hxsl_Flatten


class hxsl__Globals_GlobalSlot_Impl_:
    _hx_class_name = "hxsl._Globals.GlobalSlot_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toInt", "set", "get"]

    @staticmethod
    def _new(name):
        this1 = hxsl_Globals.allocID(name)
        return this1

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def set(this1,globals,v):
        globals.map.set(this1,v)

    @staticmethod
    def get(this1,globals):
        return globals.map.h.get(this1,None)
hxsl__Globals_GlobalSlot_Impl_._hx_class = hxsl__Globals_GlobalSlot_Impl_
_hx_classes["hxsl._Globals.GlobalSlot_Impl_"] = hxsl__Globals_GlobalSlot_Impl_


class hxsl_Globals:
    _hx_class_name = "hxsl.Globals"
    _hx_is_interface = "False"
    __slots__ = ("map", "channels", "maxChannels")
    _hx_fields = ["map", "channels", "maxChannels"]
    _hx_methods = ["set", "get", "fastSet", "fastGet", "resetChannels", "allocChannelID"]
    _hx_statics = ["ALL", "MAP", "allocID", "getIDName"]

    def __init__(self):
        self.maxChannels = None
        self.channels = []
        self.map = haxe_ds_IntMap()

    def set(self,path,v):
        self.map.set(hxsl_Globals.allocID(path),v)

    def get(self,path):
        this1 = self.map
        key = hxsl_Globals.allocID(path)
        return this1.h.get(key,None)

    def fastSet(self,id,v):
        self.map.set(id,v)

    def fastGet(self,id):
        return self.map.h.get(id,None)

    def resetChannels(self):
        self.maxChannels = 0

    def allocChannelID(self,t):
        _g = 0
        _g1 = self.maxChannels
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.channels[i] if i >= 0 and i < len(self.channels) else None) == t):
                return i
        if (self.maxChannels == ((1 << hxsl_Tools.MAX_CHANNELS_BITS))):
            raise haxe_Exception.thrown("Too many unique channels")
        i = self.maxChannels
        self.maxChannels = (self.maxChannels + 1)
        python_internal_ArrayImpl._set(self.channels, i, t)
        return i
    ALL = None
    MAP = None

    @staticmethod
    def allocID(path):
        if (hxsl_Globals.MAP is None):
            hxsl_Globals.MAP = haxe_ds_StringMap()
            hxsl_Globals.ALL = []
        id = hxsl_Globals.MAP.h.get(path,None)
        if (id is None):
            id = len(hxsl_Globals.ALL)
            _this = hxsl_Globals.ALL
            _this.append(path)
            hxsl_Globals.MAP.h[path] = id
        return id

    @staticmethod
    def getIDName(id):
        return python_internal_ArrayImpl._get(hxsl_Globals.ALL, id)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.map = None
        _hx_o.channels = None
        _hx_o.maxChannels = None
hxsl_Globals._hx_class = hxsl_Globals
_hx_classes["hxsl.Globals"] = hxsl_Globals


class hxsl__Linker_AllocatedVar:
    _hx_class_name = "hxsl._Linker.AllocatedVar"
    _hx_is_interface = "False"
    __slots__ = ("id", "v", "path", "merged", "kind", "parent", "rootShaderName", "instanceIndex")
    _hx_fields = ["id", "v", "path", "merged", "kind", "parent", "rootShaderName", "instanceIndex"]

    def __init__(self):
        self.instanceIndex = None
        self.rootShaderName = None
        self.parent = None
        self.kind = None
        self.merged = None
        self.path = None
        self.v = None
        self.id = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.v = None
        _hx_o.path = None
        _hx_o.merged = None
        _hx_o.kind = None
        _hx_o.parent = None
        _hx_o.rootShaderName = None
        _hx_o.instanceIndex = None
hxsl__Linker_AllocatedVar._hx_class = hxsl__Linker_AllocatedVar
_hx_classes["hxsl._Linker.AllocatedVar"] = hxsl__Linker_AllocatedVar


class hxsl__Linker_ShaderInfos:
    _hx_class_name = "hxsl._Linker.ShaderInfos"
    _hx_is_interface = "False"
    __slots__ = ("uid", "name", "priority", "body", "usedFunctions", "deps", "read", "write", "processed", "vertex", "onStack", "hasDiscard", "marked")
    _hx_fields = ["uid", "name", "priority", "body", "usedFunctions", "deps", "read", "write", "processed", "vertex", "onStack", "hasDiscard", "marked"]
    _hx_statics = ["UID"]

    def __init__(self,n,v):
        self.marked = None
        self.hasDiscard = None
        self.onStack = None
        self.deps = None
        self.body = None
        self.priority = None
        self.name = n
        def _hx_local_2():
            _hx_local_0 = hxsl__Linker_ShaderInfos
            _hx_local_1 = _hx_local_0.UID
            _hx_local_0.UID = (_hx_local_1 + 1)
            return _hx_local_1
        self.uid = _hx_local_2()
        self.vertex = v
        self.processed = haxe_ds_IntMap()
        self.usedFunctions = []
        self.read = haxe_ds_IntMap()
        self.write = haxe_ds_IntMap()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.uid = None
        _hx_o.name = None
        _hx_o.priority = None
        _hx_o.body = None
        _hx_o.usedFunctions = None
        _hx_o.deps = None
        _hx_o.read = None
        _hx_o.write = None
        _hx_o.processed = None
        _hx_o.vertex = None
        _hx_o.onStack = None
        _hx_o.hasDiscard = None
        _hx_o.marked = None
hxsl__Linker_ShaderInfos._hx_class = hxsl__Linker_ShaderInfos
_hx_classes["hxsl._Linker.ShaderInfos"] = hxsl__Linker_ShaderInfos


class hxsl_Linker:
    _hx_class_name = "hxsl.Linker"
    _hx_is_interface = "False"
    __slots__ = ("allVars", "varMap", "curShader", "shaders", "varIdMap", "locals", "curInstance", "batchMode", "isBatchShader", "debugDepth")
    _hx_fields = ["allVars", "varMap", "curShader", "shaders", "varIdMap", "locals", "curInstance", "batchMode", "isBatchShader", "debugDepth"]
    _hx_methods = ["debug", "error", "mergeVar", "allocVar", "mapExprVar", "addShader", "sortByPriorityDesc", "buildDependency", "initDependencies", "collect", "uniqueLocals", "link"]

    def __init__(self,batchMode = None):
        if (batchMode is None):
            batchMode = False
        self.isBatchShader = None
        self.curInstance = None
        self.locals = None
        self.varIdMap = None
        self.shaders = None
        self.curShader = None
        self.varMap = None
        self.allVars = None
        self.debugDepth = 0
        self.batchMode = batchMode

    def debug(self,msg,pos = None):
        pass

    def error(self,msg,p):
        return hxsl_Error.t(msg,p)

    def mergeVar(self,path,v,v2,p,shaderName):
        tmp = v.kind.index
        if (tmp == 2):
            if (not (((shaderName is not None) and hxsl_Tools.hasBorrowQualifier(v2,shaderName)))):
                raise haxe_Exception.thrown("assert")
        elif (((((tmp == 5) or ((tmp == 4))) or ((tmp == 3))) or ((tmp == 1))) or ((tmp == 0))):
            pass
        elif (tmp == 6):
            raise haxe_Exception.thrown("assert")
        else:
            pass
        if (((v.kind != v2.kind) and ((v.kind != hxsl_VarKind.Local))) and ((v2.kind != hxsl_VarKind.Local))):
            self.error(((((("'" + ("null" if path is None else path)) + "' kind does not match : ") + Std.string(v.kind)) + " should be ") + Std.string(v2.kind)),p)
        _g = v.type
        _g1 = v2.type
        if (_g.index == 13):
            if (_g1.index == 13):
                fl2 = _g1.params[0]
                fl1 = _g.params[0]
                _g = 0
                while (_g < len(fl1)):
                    f1 = (fl1[_g] if _g >= 0 and _g < len(fl1) else None)
                    _g = (_g + 1)
                    ft = None
                    _g1 = 0
                    while (_g1 < len(fl2)):
                        f2 = (fl2[_g1] if _g1 >= 0 and _g1 < len(fl2) else None)
                        _g1 = (_g1 + 1)
                        if (f1.name == f2.name):
                            ft = f2
                            break
                    if (ft is None):
                        x = self.allocVar(f1,p,shaderName).v
                        fl2.append(x)
                    else:
                        self.mergeVar(((("null" if path is None else path) + ".") + HxOverrides.stringOrNull(ft.name)),f1,ft,p,shaderName)
            elif (not Type.enumEq(v.type,v2.type)):
                self.error(((((("'" + ("null" if path is None else path)) + "' type does not match : ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v.type))) + " should be ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v2.type))),p)
        elif (not Type.enumEq(v.type,v2.type)):
            self.error(((((("'" + ("null" if path is None else path)) + "' type does not match : ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v.type))) + " should be ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v2.type))),p)

    def allocVar(self,v,p,shaderName = None,path = None,parent = None):
        _gthis = self
        if ((Reflect.field(v,"parent") is not None) and ((parent is None))):
            parent = self.allocVar(Reflect.field(v,"parent"),p,shaderName)
            p1 = parent.v
            path = p1.name
            p1 = Reflect.field(p1,"parent")
            while (p1 is not None):
                path = ((HxOverrides.stringOrNull(p1.name) + ".") + ("null" if path is None else path))
                p1 = Reflect.field(p1,"parent")
        key = (v.name if ((path is None)) else ((("null" if path is None else path) + ".") + HxOverrides.stringOrNull(v.name)))
        if (Reflect.field(v,"qualifiers") is not None):
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (q.index == 4):
                    n = q.params[0]
                    key = n
        v2 = self.varMap.h.get(key,None)
        vname = v.name
        if (v2 is not None):
            _g = 0
            _g1 = v2.merged
            while (_g < len(_g1)):
                vm = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (vm == v):
                    return v2
            tmp = None
            borrowed = hxsl_Tools.hasBorrowQualifier(v2.v,shaderName)
            if (not (((((((v.kind == hxsl_VarKind.Param) and (not borrowed)) and (not hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Shared))) and (not _gthis.isBatchShader)) or ((v.kind == hxsl_VarKind.Function))) or (((((v.kind == hxsl_VarKind.Var) or ((v.kind == hxsl_VarKind.Local)))) and hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Private)))))):
                v1 = v2.v
                borrowed = hxsl_Tools.hasBorrowQualifier(v,v2.rootShaderName)
                tmp = ((((((v1.kind == hxsl_VarKind.Param) and (not borrowed)) and (not hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Shared))) and (not _gthis.isBatchShader)) or ((v1.kind == hxsl_VarKind.Function))) or (((((v1.kind == hxsl_VarKind.Var) or ((v1.kind == hxsl_VarKind.Local)))) and hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Private))))
            else:
                tmp = True
            if (tmp or (((v.kind == hxsl_VarKind.Param) and ((v2.v.kind == hxsl_VarKind.Param))))):
                k = 2
                while True:
                    a = self.varMap.h.get((("null" if key is None else key) + Std.string(k)),None)
                    if (a is None):
                        break
                    _g = 0
                    _g1 = a.merged
                    while (_g < len(_g1)):
                        vm = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                        _g = (_g + 1)
                        if (vm == v):
                            return a
                    k = (k + 1)
                vname = (("null" if vname is None else vname) + Std.string(k))
                key = (("null" if key is None else key) + Std.string(k))
            else:
                _this = v2.merged
                _this.append(v)
                self.mergeVar(key,v,v2.v,p,v2.rootShaderName)
                self.varIdMap.set(v.id,v2.id)
                return v2
        vid = (len(self.allVars) + 1)
        v2 = _hx_AnonObject({'id': vid, 'name': vname, 'type': v.type, 'kind': v.kind, 'qualifiers': Reflect.field(v,"qualifiers"), 'parent': (None if ((parent is None)) else parent.v)})
        a = hxsl__Linker_AllocatedVar()
        a.v = v2
        a.merged = [v]
        a.path = key
        a.id = vid
        a.parent = parent
        a.instanceIndex = self.curInstance
        a.rootShaderName = shaderName
        _this = self.allVars
        _this.append(a)
        self.varMap.h[key] = a
        _g = v2.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g = []
            _g1 = 0
            while (_g1 < len(vl)):
                v = (vl[_g1] if _g1 >= 0 and _g1 < len(vl) else None)
                _g1 = (_g1 + 1)
                x = self.allocVar(v,p,shaderName,key,a).v
                _g.append(x)
            v2.type = hxsl_Type.TStruct(_g)
        return a

    def mapExprVar(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 1):
            v = _g.params[0]
            if (not (v.id in self.locals.h)):
                v1 = self.allocVar(v,e.p)
                if ((self.curShader is not None) and (not (v1.id in self.curShader.write.h))):
                    self.curShader.read.set(v1.id,v1)
                    if ((self.curShader.vertex is None) and ((v1.v.kind == hxsl_VarKind.Var))):
                        self.curShader.vertex = False
                return _hx_AnonObject({'e': hxsl_TExprDef.TVar(v1.v), 't': v1.v.type, 'p': e.p})
        elif (tmp == 5):
            op = _g.params[0]
            e1 = _g.params[1]
            e2 = _g.params[2]
            _g1 = e1.e
            tmp = op.index
            if (tmp == 4):
                tmp = _g1.index
                if (tmp == 1):
                    _g2 = _g1.params[0]
                    v = _g2
                    if (not (v.id in self.locals.h)):
                        e21 = self.mapExprVar(e2)
                        v1 = self.allocVar(v,e1.p)
                        if (self.curShader is not None):
                            self.curShader.write.set(v1.id,v1)
                        return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,_hx_AnonObject({'e': hxsl_TExprDef.TVar(v1.v), 't': v1.v.type, 'p': e.p}),e21), 't': e.t, 'p': e.p})
                    else:
                        v = _g2
                        if (not (v.id in self.locals.h)):
                            e11 = self.mapExprVar(e1)
                            e21 = self.mapExprVar(e2)
                            v1 = self.allocVar(v,e11.p)
                            if (self.curShader is not None):
                                self.curShader.write.set(v1.id,v1)
                            return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,e11,e21), 't': e.t, 'p': e.p})
                elif (tmp == 9):
                    _g2 = _g1.params[0]
                    _g3 = _g1.params[1]
                    _g3 = _g2.e
                    _g4 = _g2.p
                    _g4 = _g2.t
                    if (_g3.index == 1):
                        v = _g3.params[0]
                        if (not (v.id in self.locals.h)):
                            e11 = self.mapExprVar(e1)
                            e21 = self.mapExprVar(e2)
                            v1 = self.allocVar(v,e11.p)
                            if (self.curShader is not None):
                                self.curShader.write.set(v1.id,v1)
                            return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,e11,e21), 't': e.t, 'p': e.p})
                else:
                    pass
            elif (tmp == 20):
                _g2 = op.params[0]
                tmp = _g1.index
                if (tmp == 1):
                    v = _g1.params[0]
                    if (not (v.id in self.locals.h)):
                        e11 = self.mapExprVar(e1)
                        e21 = self.mapExprVar(e2)
                        v1 = self.allocVar(v,e11.p)
                        if (self.curShader is not None):
                            self.curShader.write.set(v1.id,v1)
                        return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,e11,e21), 't': e.t, 'p': e.p})
                elif (tmp == 9):
                    _g2 = _g1.params[0]
                    _g3 = _g1.params[1]
                    _g1 = _g2.e
                    _g3 = _g2.p
                    _g3 = _g2.t
                    if (_g1.index == 1):
                        v = _g1.params[0]
                        if (not (v.id in self.locals.h)):
                            e11 = self.mapExprVar(e1)
                            e21 = self.mapExprVar(e2)
                            v1 = self.allocVar(v,e11.p)
                            if (self.curShader is not None):
                                self.curShader.write.set(v1.id,v1)
                            return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,e11,e21), 't': e.t, 'p': e.p})
                else:
                    pass
            else:
                pass
        elif (tmp == 7):
            _g1 = _g.params[1]
            v = _g.params[0]
            self.locals.set(v.id,True)
        elif (tmp == 11):
            if (self.curShader is not None):
                self.curShader.vertex = False
                self.curShader.hasDiscard = True
        elif (tmp == 13):
            _g1 = _g.params[1]
            _g1 = _g.params[2]
            v = _g.params[0]
            self.locals.set(v.id,True)
        else:
            pass
        return hxsl_Tools.map(e,self.mapExprVar)

    def addShader(self,name,vertex,e,p):
        s = hxsl__Linker_ShaderInfos(name,vertex)
        self.curShader = s
        s.priority = p
        s.body = self.mapExprVar(e)
        _this = self.shaders
        _this.append(s)
        self.curShader = None
        return s

    def sortByPriorityDesc(self,s1,s2):
        if (s1.priority == s2.priority):
            return (s1.uid - s2.uid)
        return (s2.priority - s1.priority)

    def buildDependency(self,s,v,isWritten):
        found = (not isWritten)
        _g = 0
        _g1 = self.shaders
        while (_g < len(_g1)):
            parent = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (parent == s):
                found = True
                continue
            elif (not found):
                continue
            if (not (v.id in parent.write.h)):
                continue
            if s.vertex:
                if (parent.vertex == False):
                    continue
                if (parent.vertex is None):
                    parent.vertex = True
            s.deps.set(parent,True)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.debugDepth
            _hx_local_1.debugDepth = (_hx_local_2 + 1)
            _hx_local_2
            self.initDependencies(parent)
            _hx_local_3 = self
            _hx_local_4 = _hx_local_3.debugDepth
            _hx_local_3.debugDepth = (_hx_local_4 - 1)
            _hx_local_4
            if (not (v.id in parent.read.h)):
                return
        if (v.v.kind == hxsl_VarKind.Var):
            self.error((((("Variable " + HxOverrides.stringOrNull(v.path)) + " required by ") + HxOverrides.stringOrNull(s.name)) + " is missing initializer"),None)

    def initDependencies(self,s):
        if (s.deps is not None):
            return
        s.deps = haxe_ds_ObjectMap()
        r = s.read.iterator()
        while r.hasNext():
            r1 = r.next()
            self.buildDependency(s,r1,(r1.id in s.write.h))
        if (s.vertex is None):
            d = s.deps.keys()
            while d.hasNext():
                d1 = d.next()
                if (d1.vertex == False):
                    s.vertex = False
                    break
        if s.vertex:
            d = s.deps.keys()
            while d.hasNext():
                d1 = d.next()
                if (d1.vertex is None):
                    d1.vertex = True

    def collect(self,cur,out,vertex):
        if cur.onStack:
            self.error((("Loop in shader dependencies (" + HxOverrides.stringOrNull(cur.name)) + ")"),None)
        if (cur.marked == vertex):
            return
        cur.marked = vertex
        cur.onStack = True
        _g = []
        d = cur.deps.keys()
        while d.hasNext():
            d1 = d.next()
            _g.append(d1)
        deps = _g
        deps.sort(key= python_lib_Functools.cmp_to_key(self.sortByPriorityDesc))
        _g = 0
        while (_g < len(deps)):
            d = (deps[_g] if _g >= 0 and _g < len(deps) else None)
            _g = (_g + 1)
            self.collect(d,out,vertex)
        if (cur.vertex is None):
            cur.vertex = vertex
        if (cur.vertex == vertex):
            out.append(cur)
        cur.onStack = False

    def uniqueLocals(self,expr,locals):
        _g = expr.e
        tmp = _g.index
        if (tmp == 4):
            el = _g.params[0]
            _g1 = haxe_ds_StringMap()
            k = locals.keys()
            while k.hasNext():
                k1 = k.next()
                _g1.h[k1] = True
            locals1 = _g1
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                self.uniqueLocals(e,locals1)
        elif (tmp == 7):
            _g1 = _g.params[1]
            v = _g.params[0]
            if (v.name in locals.h):
                k = 2
                while ((HxOverrides.stringOrNull(v.name) + Std.string(k)) in locals.h):
                    k = (k + 1)
                v.name = (HxOverrides.stringOrNull(v.name) + Std.string(k))
            locals.h[v.name] = True
        else:
            _g = self.uniqueLocals
            locals1 = locals
            def _hx_local_3(expr):
                _g(expr,locals1)
            hxsl_Tools.iter(expr,_hx_local_3)

    def link(self,shadersData):
        _gthis = self
        self.varMap = haxe_ds_StringMap()
        self.varIdMap = haxe_ds_IntMap()
        self.allVars = list()
        self.shaders = []
        self.locals = haxe_ds_IntMap()
        dupShaders = haxe_ds_ObjectMap()
        _g = []
        _g1 = 0
        while (_g1 < len(shadersData)):
            s = (shadersData[_g1] if _g1 >= 0 and _g1 < len(shadersData) else None)
            _g1 = (_g1 + 1)
            s1 = s
            sreal = s1
            if (s1 in dupShaders.h):
                s1 = hxsl_Clone.shaderData(s1)
            dupShaders.set(s1,sreal)
            _g.append(s1)
        shadersData = _g
        self.curInstance = 0
        outVars = []
        _g = 0
        while (_g < len(shadersData)):
            s = (shadersData[_g] if _g >= 0 and _g < len(shadersData) else None)
            _g = (_g + 1)
            self.isBatchShader = (self.batchMode and s.name.startswith("batchShader_"))
            _g1 = 0
            _g2 = s.vars
            while (_g1 < len(_g2)):
                v = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                v2 = self.allocVar(v,None,s.name)
                if ((self.isBatchShader and ((v2.v.kind == hxsl_VarKind.Param))) and (not v2.path.startswith("Batch_"))):
                    v2.v.kind = hxsl_VarKind.Local
                if (v.kind == hxsl_VarKind.Output):
                    outVars.append(v)
            _g3 = 0
            _g4 = s.funs
            while (_g3 < len(_g4)):
                f = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                _g3 = (_g3 + 1)
                v1 = self.allocVar(f.ref,f.expr.p)
                v1.kind = f.kind
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.curInstance
            _hx_local_4.curInstance = (_hx_local_5 + 1)
            _hx_local_5
        priority = 0
        initPrio_init = [-3000]
        initPrio_vert = [-2000]
        initPrio_frag = [-1000]
        _g = 0
        while (_g < len(shadersData)):
            s = (shadersData[_g] if _g >= 0 and _g < len(shadersData) else None)
            _g = (_g + 1)
            _g1 = 0
            _g2 = s.funs
            while (_g1 < len(_g2)):
                f = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                v = self.allocVar(f.ref,f.expr.p)
                if (v.kind is None):
                    raise haxe_Exception.thrown("assert")
                tmp = v.kind.index
                if ((tmp == 1) or ((tmp == 0))):
                    self.addShader(((HxOverrides.stringOrNull(s.name) + ".") + HxOverrides.stringOrNull((("vertex" if ((v.kind == hxsl_FunctionKind.Vertex)) else "fragment")))),(v.kind == hxsl_FunctionKind.Vertex),f.expr,priority)
                elif (tmp == 2):
                    prio = None
                    status = None
                    _g3 = f.ref.name
                    _hx_local_8 = len(_g3)
                    if (_hx_local_8 == 16):
                        if (_g3 == "__init__fragment"):
                            prio = initPrio_frag
                            status = False
                        else:
                            prio = initPrio_init
                            status = None
                    elif (_hx_local_8 == 14):
                        if (_g3 == "__init__vertex"):
                            prio = initPrio_vert
                            status = True
                        else:
                            prio = initPrio_init
                            status = None
                    else:
                        prio = initPrio_init
                        status = None
                    _g4 = f.expr.e
                    if (_g4.index == 4):
                        el = _g4.params[0]
                        index = 0
                        _g5 = 0
                        while (_g5 < len(el)):
                            e = (el[_g5] if _g5 >= 0 and _g5 < len(el) else None)
                            _g5 = (_g5 + 1)
                            tmp1 = index
                            index = (index + 1)
                            def _hx_local_13():
                                _hx_local_10 = prio
                                _hx_local_11 = 0
                                _hx_local_12 = (_hx_local_10[_hx_local_11] if _hx_local_11 >= 0 and _hx_local_11 < len(_hx_local_10) else None)
                                python_internal_ArrayImpl._set(_hx_local_10, _hx_local_11, (_hx_local_12 + 1))
                                return _hx_local_12
                            self.addShader((((HxOverrides.stringOrNull(s.name) + ".") + HxOverrides.stringOrNull(f.ref.name)) + Std.string(tmp1)),status,e,_hx_local_13())
                    else:
                        def _hx_local_17():
                            _hx_local_14 = prio
                            _hx_local_15 = 0
                            _hx_local_16 = (_hx_local_14[_hx_local_15] if _hx_local_15 >= 0 and _hx_local_15 < len(_hx_local_14) else None)
                            python_internal_ArrayImpl._set(_hx_local_14, _hx_local_15, (_hx_local_16 + 1))
                            return _hx_local_16
                        self.addShader(((HxOverrides.stringOrNull(s.name) + ".") + HxOverrides.stringOrNull(f.ref.name)),status,f.expr,_hx_local_17())
                elif (tmp == 3):
                    raise haxe_Exception.thrown(("Unexpected helper function in linker " + HxOverrides.stringOrNull(v.v.name)))
                else:
                    pass
            priority = (priority + 1)
        self.shaders.sort(key= python_lib_Functools.cmp_to_key(self.sortByPriorityDesc))
        entry = hxsl__Linker_ShaderInfos("<entry>",False)
        entry.deps = haxe_ds_ObjectMap()
        _g = 0
        while (_g < len(outVars)):
            v = (outVars[_g] if _g >= 0 and _g < len(outVars) else None)
            _g = (_g + 1)
            self.buildDependency(entry,self.allocVar(v,None),False)
        _g = 0
        _g1 = self.shaders
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if s.hasDiscard:
                self.initDependencies(s)
                entry.deps.set(s,True)
        _g = 0
        _g1 = self.shaders
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (s.vertex is not None):
                continue
            onlyParams = True
            r = s.read.iterator()
            while r.hasNext():
                r1 = r.next()
                if (r1.v.kind != hxsl_VarKind.Param):
                    onlyParams = False
                    break
            if onlyParams:
                s.vertex = False
        v = []
        f = []
        self.collect(entry,v,True)
        self.collect(entry,f,False)
        if (((None if ((len(f) == 0)) else f.pop())) != entry):
            raise haxe_Exception.thrown("assert")
        _g = 0
        _g1 = self.shaders
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            s.marked = None
        _g = 0
        _g1 = (v + f)
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            d = s.deps.keys()
            while d.hasNext():
                d1 = d.next()
                if (d1.marked is None):
                    self.error((((HxOverrides.stringOrNull(d1.name) + " needed by ") + HxOverrides.stringOrNull(s.name)) + " is unreachable"),None)
            s.marked = True
        outVars = []
        varMap = haxe_ds_IntMap()
        addVar = None
        def _hx_local_24(v):
            if (v.id in varMap.h):
                return
            varMap.set(v.id,True)
            if (Reflect.field(v.v,"parent") is not None):
                addVar(v.parent)
            else:
                x = v.v
                outVars.append(x)
        addVar = _hx_local_24
        _g = 0
        _g1 = (v + f)
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            v1 = s.read.iterator()
            while v1.hasNext():
                v2 = v1.next()
                addVar(v2)
            v3 = s.write.iterator()
            while v3.hasNext():
                v4 = v3.next()
                addVar(v4)
        cleanVar = None
        def _hx_local_27(v):
            _g = v.type
            if (_g.index == 13):
                vl = _g.params[0]
                if (v.kind != hxsl_VarKind.Input):
                    vout = []
                    _g = 0
                    while (_g < len(vl)):
                        v1 = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                        _g = (_g + 1)
                        if (v1.id in varMap.h):
                            cleanVar(v1)
                            vout.append(v1)
                    v.type = hxsl_Type.TStruct(vout)
        cleanVar = _hx_local_27
        _g = 0
        while (_g < len(outVars)):
            v1 = (outVars[_g] if _g >= 0 and _g < len(outVars) else None)
            _g = (_g + 1)
            cleanVar(v1)
        def _hx_local_31(kind,name,a):
            v = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': name, 'type': hxsl_Type.TFun([_hx_AnonObject({'ret': hxsl_Type.TVoid, 'args': []})]), 'kind': hxsl_VarKind.Function})
            outVars.append(v)
            exprs = []
            _g = 0
            while (_g < len(a)):
                s = (a[_g] if _g >= 0 and _g < len(a) else None)
                _g = (_g + 1)
                _g1 = s.body.e
                if (_g1.index == 4):
                    el = _g1.params[0]
                    _g2 = 0
                    while (_g2 < len(el)):
                        e = (el[_g2] if _g2 >= 0 and _g2 < len(el) else None)
                        _g2 = (_g2 + 1)
                        exprs.append(e)
                else:
                    x = s.body
                    exprs.append(x)
            expr = _hx_AnonObject({'e': hxsl_TExprDef.TBlock(exprs), 't': hxsl_Type.TVoid, 'p': (None if ((len(exprs) == 0)) else (exprs[0] if 0 < len(exprs) else None).p)})
            _gthis.uniqueLocals(expr,haxe_ds_StringMap())
            return _hx_AnonObject({'kind': kind, 'ref': v, 'ret': hxsl_Type.TVoid, 'args': [], 'expr': expr})
        build = _hx_local_31
        funs = [build(hxsl_FunctionKind.Vertex,"vertex",v), build(hxsl_FunctionKind.Fragment,"fragment",f)]
        s = dupShaders.keys()
        while s.hasNext():
            s1 = s.next()
            sreal = dupShaders.h.get(s1,None)
            if (s1 == sreal):
                continue
            _g = 0
            _g1 = len(s1.vars)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this = self.allocVar((s1.vars[i] if i >= 0 and i < len(s1.vars) else None),None).merged
                x = (sreal.vars[i] if i >= 0 and i < len(sreal.vars) else None)
                _this.insert(0, x)
        return _hx_AnonObject({'name': "out", 'vars': outVars, 'funs': funs})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.allVars = None
        _hx_o.varMap = None
        _hx_o.curShader = None
        _hx_o.shaders = None
        _hx_o.varIdMap = None
        _hx_o.locals = None
        _hx_o.curInstance = None
        _hx_o.batchMode = None
        _hx_o.isBatchShader = None
        _hx_o.debugDepth = None
hxsl_Linker._hx_class = hxsl_Linker
_hx_classes["hxsl.Linker"] = hxsl_Linker

class hxsl_Output(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Output"
    _hx_constructs = ["Const", "Value", "PackNormal", "PackFloat", "Vec2", "Vec3", "Vec4", "Swiz"]

    @staticmethod
    def Const(v):
        return hxsl_Output("Const", 0, (v,))

    @staticmethod
    def Value(v,size = None):
        return hxsl_Output("Value", 1, (v,size))

    @staticmethod
    def PackNormal(v):
        return hxsl_Output("PackNormal", 2, (v,))

    @staticmethod
    def PackFloat(v):
        return hxsl_Output("PackFloat", 3, (v,))

    @staticmethod
    def Vec2(a):
        return hxsl_Output("Vec2", 4, (a,))

    @staticmethod
    def Vec3(a):
        return hxsl_Output("Vec3", 5, (a,))

    @staticmethod
    def Vec4(a):
        return hxsl_Output("Vec4", 6, (a,))

    @staticmethod
    def Swiz(a,swiz):
        return hxsl_Output("Swiz", 7, (a,swiz))
hxsl_Output._hx_class = hxsl_Output
_hx_classes["hxsl.Output"] = hxsl_Output


class hxsl_Printer:
    _hx_class_name = "hxsl.Printer"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "varId")
    _hx_fields = ["buffer", "varId"]
    _hx_methods = ["add", "shaderString", "varString", "funString", "exprString", "addVar", "addFun", "addVarName", "addConst", "addExpr"]
    _hx_statics = ["SWIZ", "opStr", "toString", "shaderToString", "check"]

    def __init__(self,varId = None):
        if (varId is None):
            varId = False
        self.buffer = None
        self.varId = varId

    def add(self,v):
        _this = self.buffer
        s = Std.string(v)
        _this.b.write(s)

    def shaderString(self,s):
        self.buffer = StringBuf()
        _g = 0
        _g1 = s.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.addVar(v,None)
            _this = self.buffer
            s1 = Std.string(";\n")
            _this.b.write(s1)
        if (len(s.vars) > 0):
            _this = self.buffer
            s1 = Std.string("\n")
            _this.b.write(s1)
        _g = 0
        _g1 = s.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.addFun(f)
            _this = self.buffer
            s = Std.string("\n\n")
            _this.b.write(s)
        return self.buffer.b.getvalue()

    def varString(self,v):
        self.buffer = StringBuf()
        self.addVar(v,None)
        return self.buffer.b.getvalue()

    def funString(self,f):
        self.buffer = StringBuf()
        self.addFun(f)
        return self.buffer.b.getvalue()

    def exprString(self,e):
        self.buffer = StringBuf()
        self.addExpr(e,"")
        return self.buffer.b.getvalue()

    def addVar(self,v,defKind,tabs = None,parent = None):
        if (tabs is None):
            tabs = ""
        if (Reflect.field(v,"qualifiers") is not None):
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                v1 = None
                v2 = q.index
                if (v2 == 0):
                    _hx_max = q.params[0]
                    v1 = ("const" + HxOverrides.stringOrNull((("" if ((_hx_max is None)) else (("(" + Std.string(_hx_max)) + ")")))))
                elif (v2 == 1):
                    v1 = "private"
                elif (v2 == 2):
                    v1 = "nullable"
                elif (v2 == 3):
                    v1 = "perObject"
                elif (v2 == 4):
                    n = q.params[0]
                    v1 = (("name('" + ("null" if n is None else n)) + "')")
                elif (v2 == 5):
                    v1 = "shared"
                elif (v2 == 6):
                    p = q.params[0]
                    v1 = (HxOverrides.stringOrNull(p.tag.lower()) + "p")
                elif (v2 == 7):
                    _hx_min = q.params[0]
                    max1 = q.params[1]
                    v1 = (((("range(" + Std.string(_hx_min)) + ",") + Std.string(max1)) + ")")
                elif (v2 == 8):
                    v1 = "ignore"
                elif (v2 == 9):
                    n1 = q.params[0]
                    v1 = (("perInstance(" + Std.string(n1)) + ")")
                elif (v2 == 10):
                    s = q.params[0]
                    v1 = (("doc(\"" + HxOverrides.stringOrNull(StringTools.replace(s,"\"","\\\""))) + "\")")
                elif (v2 == 11):
                    s1 = q.params[0]
                    v1 = (("borrow(" + ("null" if s1 is None else s1)) + ")")
                elif (v2 == 12):
                    s2 = q.params[0]
                    v1 = (("sampler(" + ("null" if s2 is None else s2)) + ")")
                else:
                    pass
                _this = self.buffer
                s3 = Std.string((("@" + ("null" if v1 is None else v1)) + " "))
                _this.b.write(s3)
        if (v.kind != defKind):
            tmp = v.kind.index
            if (tmp == 0):
                _this = self.buffer
                s = Std.string("@global ")
                _this.b.write(s)
            elif (tmp == 1):
                _this = self.buffer
                s = Std.string("@input ")
                _this.b.write(s)
            elif (tmp == 2):
                _this = self.buffer
                s = Std.string("@param ")
                _this.b.write(s)
            elif (tmp == 3):
                _this = self.buffer
                s = Std.string("@varying ")
                _this.b.write(s)
            elif (tmp == 4):
                _this = self.buffer
                s = Std.string("@local ")
                _this.b.write(s)
            elif (tmp == 5):
                _this = self.buffer
                s = Std.string("@output ")
                _this.b.write(s)
            elif (tmp == 6):
                _this = self.buffer
                s = Std.string("@function ")
                _this.b.write(s)
            else:
                pass
        _this = self.buffer
        s = Std.string("var ")
        _this.b.write(s)
        if (Reflect.field(v,"parent") == parent):
            _this = self.buffer
            s = Std.string((HxOverrides.stringOrNull(v.name) + HxOverrides.stringOrNull(((("@" + Std.string(v.id)) if (self.varId) else "")))))
            _this.b.write(s)
        else:
            self.addVarName(v)
        _this = self.buffer
        s = Std.string(" : ")
        _this.b.write(s)
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _this = self.buffer
            s = Std.string("{")
            _this.b.write(s)
            first = True
            _g = 0
            while (_g < len(vl)):
                v1 = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                if first:
                    first = False
                else:
                    _this = self.buffer
                    s = Std.string(", ")
                    _this.b.write(s)
                self.addVar(v1,v1.kind,tabs,v1)
            _this = self.buffer
            s = Std.string("}")
            _this.b.write(s)
        else:
            v1 = hxsl_Tools.toString(v.type)
            _this = self.buffer
            s = Std.string(v1)
            _this.b.write(s)

    def addFun(self,f):
        _this = self.buffer
        s = Std.string((("function " + HxOverrides.stringOrNull(f.ref.name)) + "("))
        _this.b.write(s)
        first = True
        _g = 0
        _g1 = f.args
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if first:
                _this = self.buffer
                s = Std.string(" ")
                _this.b.write(s)
                first = False
            else:
                _this1 = self.buffer
                s1 = Std.string(", ")
                _this1.b.write(s1)
            self.addVar(a,hxsl_VarKind.Local)
        if (len(f.args) > 0):
            _this = self.buffer
            s = Std.string(" ")
            _this.b.write(s)
        v = ((") : " + HxOverrides.stringOrNull(hxsl_Tools.toString(f.ret))) + " ")
        _this = self.buffer
        s = Std.string(v)
        _this.b.write(s)
        self.addExpr(f.expr,"")

    def addVarName(self,v):
        if (Reflect.field(v,"parent") is not None):
            self.addVarName(Reflect.field(v,"parent"))
            _this = self.buffer
            s = Std.string(".")
            _this.b.write(s)
        _this = self.buffer
        s = Std.string(v.name)
        _this.b.write(s)
        if self.varId:
            _this = self.buffer
            s = Std.string(("@" + Std.string(v.id)))
            _this.b.write(s)

    def addConst(self,c):
        _this = self.buffer
        s = None
        s1 = c.index
        if (s1 == 0):
            s = "null"
        elif (s1 == 1):
            b = c.params[0]
            s = b
        elif (s1 == 2):
            i = c.params[0]
            s = i
        elif (s1 == 3):
            f = c.params[0]
            s = f
        elif (s1 == 4):
            s1 = c.params[0]
            s = (("\"" + ("null" if s1 is None else s1)) + "\"")
        else:
            pass
        s1 = Std.string(s)
        _this.b.write(s1)

    def addExpr(self,e,tabs):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            c = _g.params[0]
            self.addConst(c)
        elif (tmp == 1):
            v = _g.params[0]
            self.addVarName(v)
        elif (tmp == 2):
            g = _g.params[0]
            v = hxsl_Tools2.toString(g)
            _this = self.buffer
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 3):
            e = _g.params[0]
            _this = self.buffer
            s = Std.string("(")
            _this.b.write(s)
            self.addExpr(e,tabs)
            _this = self.buffer
            s = Std.string(")")
            _this.b.write(s)
        elif (tmp == 4):
            el = _g.params[0]
            _this = self.buffer
            s = Std.string("{")
            _this.b.write(s)
            tabs = (("null" if tabs is None else tabs) + "\t")
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                _this = self.buffer
                s = Std.string(("\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
                self.addExpr(e,tabs)
                _this1 = self.buffer
                s1 = Std.string(";")
                _this1.b.write(s1)
            tabs = HxString.substr(tabs,1,None)
            if (len(el) > 0):
                _this = self.buffer
                s = Std.string(("\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
            _this = self.buffer
            s = Std.string("}")
            _this.b.write(s)
        elif (tmp == 5):
            op = _g.params[0]
            e1 = _g.params[1]
            e2 = _g.params[2]
            self.addExpr(e1,tabs)
            v = ((" " + HxOverrides.stringOrNull(hxsl_Printer.opStr(op))) + " ")
            _this = self.buffer
            s = Std.string(v)
            _this.b.write(s)
            self.addExpr(e2,tabs)
        elif (tmp == 6):
            op = _g.params[0]
            e = _g.params[1]
            v = None
            v1 = op.index
            if (v1 == 0):
                v = "++"
            elif (v1 == 1):
                v = "--"
            elif (v1 == 2):
                v = "!"
            elif (v1 == 3):
                v = "-"
            elif (v1 == 4):
                v = "~"
            else:
                raise haxe_Exception.thrown("assert")
            _this = self.buffer
            s = Std.string(v)
            _this.b.write(s)
            self.addExpr(e,tabs)
        elif (tmp == 7):
            v = _g.params[0]
            init = _g.params[1]
            self.addVar(v,hxsl_VarKind.Local,tabs)
            if (init is not None):
                _this = self.buffer
                s = Std.string(" = ")
                _this.b.write(s)
                self.addExpr(init,tabs)
        elif (tmp == 8):
            e = _g.params[0]
            el = _g.params[1]
            self.addExpr(e,tabs)
            _this = self.buffer
            s = Std.string("(")
            _this.b.write(s)
            first = True
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                if first:
                    first = False
                else:
                    _this = self.buffer
                    s = Std.string(", ")
                    _this.b.write(s)
                self.addExpr(e,tabs)
            _this = self.buffer
            s = Std.string(")")
            _this.b.write(s)
        elif (tmp == 9):
            e = _g.params[0]
            regs = _g.params[1]
            self.addExpr(e,tabs)
            _this = self.buffer
            s = Std.string(".")
            _this.b.write(s)
            _g1 = 0
            while (_g1 < len(regs)):
                r = (regs[_g1] if _g1 >= 0 and _g1 < len(regs) else None)
                _g1 = (_g1 + 1)
                _this = self.buffer
                s = Std.string(python_internal_ArrayImpl._get(hxsl_Printer.SWIZ, r.index))
                _this.b.write(s)
        elif (tmp == 10):
            cond = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            _this = self.buffer
            s = Std.string("if( ")
            _this.b.write(s)
            self.addExpr(cond,tabs)
            _this = self.buffer
            s = Std.string(" ) ")
            _this.b.write(s)
            self.addExpr(eif,tabs)
            if (eelse is not None):
                _this = self.buffer
                s = Std.string(" else ")
                _this.b.write(s)
                self.addExpr(eelse,tabs)
        elif (tmp == 11):
            _this = self.buffer
            s = Std.string("discard")
            _this.b.write(s)
        elif (tmp == 12):
            e = _g.params[0]
            _this = self.buffer
            s = Std.string("return")
            _this.b.write(s)
            if (e is not None):
                _this = self.buffer
                s = Std.string(" ")
                _this.b.write(s)
                self.addExpr(e,tabs)
        elif (tmp == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            _this = self.buffer
            s = Std.string("for( ")
            _this.b.write(s)
            self.addVarName(v)
            _this = self.buffer
            s = Std.string(" in ")
            _this.b.write(s)
            self.addExpr(it,tabs)
            _this = self.buffer
            s = Std.string(" ) ")
            _this.b.write(s)
            self.addExpr(loop,tabs)
        elif (tmp == 14):
            _this = self.buffer
            s = Std.string("continue")
            _this.b.write(s)
        elif (tmp == 15):
            _this = self.buffer
            s = Std.string("break")
            _this.b.write(s)
        elif (tmp == 16):
            e1 = _g.params[0]
            e2 = _g.params[1]
            self.addExpr(e1,tabs)
            _this = self.buffer
            s = Std.string("[")
            _this.b.write(s)
            self.addExpr(e2,tabs)
            _this = self.buffer
            s = Std.string("]")
            _this.b.write(s)
        elif (tmp == 17):
            el = _g.params[0]
            _this = self.buffer
            s = Std.string("[")
            _this.b.write(s)
            first = True
            _g1 = 0
            while (_g1 < len(el)):
                e = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                if first:
                    first = False
                else:
                    _this = self.buffer
                    s = Std.string(", ")
                    _this.b.write(s)
                self.addExpr(e,tabs)
            _this = self.buffer
            s = Std.string("]")
            _this.b.write(s)
        elif (tmp == 18):
            e = _g.params[0]
            cases = _g.params[1]
            _hx_def = _g.params[2]
            _this = self.buffer
            s = Std.string("switch( ")
            _this.b.write(s)
            self.addExpr(e,tabs)
            _this = self.buffer
            s = Std.string(") {")
            _this.b.write(s)
            old = tabs
            _g1 = 0
            while (_g1 < len(cases)):
                c = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
                _g1 = (_g1 + 1)
                _this = self.buffer
                s = Std.string(("\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
                _this1 = self.buffer
                s1 = Std.string("case ")
                _this1.b.write(s1)
                first = True
                _g2 = 0
                _g3 = c.values
                while (_g2 < len(_g3)):
                    v = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if first:
                        first = False
                    else:
                        _this2 = self.buffer
                        s2 = Std.string(", ")
                        _this2.b.write(s2)
                    self.addExpr(v,tabs)
                tabs = (("null" if tabs is None else tabs) + "\t")
                _this3 = self.buffer
                s3 = Std.string((":\n" + ("null" if tabs is None else tabs)))
                _this3.b.write(s3)
                self.addExpr(c.expr,tabs)
                tabs = old
            if (_hx_def is not None):
                _this = self.buffer
                s = Std.string(("\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
                tabs = (("null" if tabs is None else tabs) + "\t")
                _this = self.buffer
                s = Std.string(("default:\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
                self.addExpr(_hx_def,tabs)
                tabs = old
            _this = self.buffer
            s = Std.string((("\n" + ("null" if tabs is None else tabs)) + "}"))
            _this.b.write(s)
        elif (tmp == 19):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            if (_g.params[2] == False):
                loop = _g2
                e = _g1
                old = tabs
                tabs = (("null" if tabs is None else tabs) + "\t")
                _this = self.buffer
                s = Std.string(("do {\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
                self.addExpr(loop,tabs)
                tabs = old
                _this = self.buffer
                s = Std.string((("\n" + ("null" if tabs is None else tabs)) + "} while( "))
                _this.b.write(s)
                self.addExpr(e,tabs)
                _this = self.buffer
                s = Std.string(" )")
                _this.b.write(s)
            else:
                loop = _g2
                e = _g1
                _this = self.buffer
                s = Std.string("while( ")
                _this.b.write(s)
                self.addExpr(e,tabs)
                old = tabs
                tabs = (("null" if tabs is None else tabs) + "\t")
                _this = self.buffer
                s = Std.string((" ) {\n" + ("null" if tabs is None else tabs)))
                _this.b.write(s)
                self.addExpr(loop,tabs)
                tabs = old
                _this = self.buffer
                s = Std.string((("\n" + ("null" if tabs is None else tabs)) + "}"))
                _this.b.write(s)
        elif (tmp == 20):
            m = _g.params[0]
            args = _g.params[1]
            e = _g.params[2]
            _this = self.buffer
            s = Std.string("@")
            _this.b.write(s)
            _this = self.buffer
            s = Std.string(m)
            _this.b.write(s)
            if (len(args) > 0):
                _this = self.buffer
                s = Std.string("(")
                _this.b.write(s)
                first = True
                _g = 0
                while (_g < len(args)):
                    c = (args[_g] if _g >= 0 and _g < len(args) else None)
                    _g = (_g + 1)
                    if first:
                        first = False
                    else:
                        _this = self.buffer
                        s = Std.string(", ")
                        _this.b.write(s)
                    self.addConst(c)
                _this = self.buffer
                s = Std.string(")")
                _this.b.write(s)
            _this = self.buffer
            s = Std.string(" ")
            _this.b.write(s)
            self.addExpr(e,tabs)
        else:
            pass

    @staticmethod
    def opStr(op):
        tmp = op.index
        if (tmp == 0):
            return "+"
        elif (tmp == 1):
            return "*"
        elif (tmp == 2):
            return "/"
        elif (tmp == 3):
            return "-"
        elif (tmp == 4):
            return "="
        elif (tmp == 5):
            return "=="
        elif (tmp == 6):
            return "!="
        elif (tmp == 7):
            return ">"
        elif (tmp == 8):
            return ">="
        elif (tmp == 9):
            return "<"
        elif (tmp == 10):
            return "<="
        elif (tmp == 11):
            return "&"
        elif (tmp == 12):
            return "|"
        elif (tmp == 13):
            return "^"
        elif (tmp == 14):
            return "&&"
        elif (tmp == 15):
            return "||"
        elif (tmp == 16):
            return "<<"
        elif (tmp == 17):
            return ">>"
        elif (tmp == 18):
            return ">>>"
        elif (tmp == 19):
            return "%"
        elif (tmp == 20):
            op1 = op.params[0]
            return (HxOverrides.stringOrNull(hxsl_Printer.opStr(op1)) + "=")
        elif (tmp == 21):
            return "..."
        elif (tmp == 22):
            return "=>"
        elif (tmp == 23):
            return " in "
        else:
            pass

    @staticmethod
    def toString(e,varId = None):
        if (varId is None):
            varId = False
        return hxsl_Printer(varId).exprString(e)

    @staticmethod
    def shaderToString(s,varId = None):
        if (varId is None):
            varId = False
        return hxsl_Printer(varId).shaderString(s)

    @staticmethod
    def check(s,_hx_from = None):
        try:
            vars = haxe_ds_IntMap()
            regVars = []
            regVar = None
            def _hx_local_1(v,reg):
                if reg:
                    if (v.id in vars.h):
                        raise haxe_Exception.thrown(("Duplicate var " + Std.string(v.id)))
                    vars.set(v.id,v)
                    regVars.append(v)
                else:
                    vars.remove(v.id)
                _g = v.type
                if (_g.index == 13):
                    vl = _g.params[0]
                    _g = 0
                    while (_g < len(vl)):
                        v = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                        _g = (_g + 1)
                        regVar(v,reg)
            regVar = _hx_local_1
            checkExpr = None
            def _hx_local_4(e):
                nonlocal regVars
                nonlocal regVars
                _g = e.e
                checkExpr1 = _g.index
                if (checkExpr1 == 1):
                    v = _g.params[0]
                    if (not (v.id in vars.h)):
                        raise haxe_Exception.thrown(((("Unbound var " + HxOverrides.stringOrNull(v.name)) + "@") + Std.string(v.id)))
                elif (checkExpr1 == 4):
                    el = _g.params[0]
                    old = regVars
                    regVars = []
                    _g1 = 0
                    while (_g1 < len(el)):
                        e1 = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                        _g1 = (_g1 + 1)
                        checkExpr(e1)
                    _g1 = 0
                    while (_g1 < len(regVars)):
                        v = (regVars[_g1] if _g1 >= 0 and _g1 < len(regVars) else None)
                        _g1 = (_g1 + 1)
                        regVar(v,False)
                    regVars = old
                elif (checkExpr1 == 7):
                    v = _g.params[0]
                    init = _g.params[1]
                    if (init is not None):
                        checkExpr(init)
                    regVar(v,True)
                elif (checkExpr1 == 13):
                    v = _g.params[0]
                    it = _g.params[1]
                    loop = _g.params[2]
                    checkExpr(it)
                    regVar(v,True)
                    checkExpr(loop)
                    regVar(v,False)
                else:
                    hxsl_Tools.iter(e,checkExpr)
            checkExpr = _hx_local_4
            _g = 0
            _g1 = s.vars
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                regVar(v,True)
            _g = 0
            _g1 = s.funs
            while (_g < len(_g1)):
                f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _g2 = 0
                _g3 = f.args
                while (_g2 < len(_g3)):
                    v = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    regVar(v,True)
                checkExpr(f.expr)
                _g4 = 0
                _g5 = f.args
                while (_g4 < len(_g5)):
                    v1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                    _g4 = (_g4 + 1)
                    regVar(v1,False)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,str):
                e = _g1
                msg = ((("null" if e is None else e) + "\n    in\n") + HxOverrides.stringOrNull(hxsl_Printer.shaderToString(s,True)))
                if (_hx_from is not None):
                    _g1 = []
                    _g2 = 0
                    while (_g2 < len(_hx_from)):
                        s = (_hx_from[_g2] if _g2 >= 0 and _g2 < len(_hx_from) else None)
                        _g2 = (_g2 + 1)
                        x = hxsl_Printer.shaderToString(s,True)
                        _g1.append(x)
                    msg = (("null" if msg is None else msg) + HxOverrides.stringOrNull((("\n    from\n\n" + HxOverrides.stringOrNull("\n\n".join([python_Boot.toString1(x1,'') for x1 in _g1]))))))
                raise haxe_Exception.thrown(msg)
            else:
                raise _g

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.varId = None
hxsl_Printer._hx_class = hxsl_Printer
_hx_classes["hxsl.Printer"] = hxsl_Printer


class hxsl_AllocParam:
    _hx_class_name = "hxsl.AllocParam"
    _hx_is_interface = "False"
    __slots__ = ("name", "pos", "instance", "index", "type", "perObjectGlobal", "next")
    _hx_fields = ["name", "pos", "instance", "index", "type", "perObjectGlobal", "next"]
    _hx_methods = ["clone"]

    def __init__(self,name,pos,instance,index,_hx_type):
        self.next = None
        self.perObjectGlobal = None
        self.name = name
        self.pos = pos
        self.instance = instance
        self.index = index
        self.type = _hx_type

    def clone(self,resetGID = None):
        if (resetGID is None):
            resetGID = False
        p = hxsl_AllocParam(self.name,self.pos,self.instance,self.index,self.type)
        if (self.perObjectGlobal is not None):
            p.perObjectGlobal = self.perObjectGlobal.clone(resetGID)
        if (self.next is not None):
            p.next = self.next.clone(resetGID)
        return p

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.pos = None
        _hx_o.instance = None
        _hx_o.index = None
        _hx_o.type = None
        _hx_o.perObjectGlobal = None
        _hx_o.next = None
hxsl_AllocParam._hx_class = hxsl_AllocParam
_hx_classes["hxsl.AllocParam"] = hxsl_AllocParam


class hxsl_AllocGlobal:
    _hx_class_name = "hxsl.AllocGlobal"
    _hx_is_interface = "False"
    __slots__ = ("pos", "gid", "path", "type", "next")
    _hx_fields = ["pos", "gid", "path", "type", "next"]
    _hx_methods = ["clone"]

    def __init__(self,pos,path,_hx_type):
        self.next = None
        self.pos = pos
        self.path = path
        self.gid = hxsl_Globals.allocID(path)
        self.type = _hx_type

    def clone(self,resetGID = None):
        if (resetGID is None):
            resetGID = False
        g = hxsl_AllocGlobal(self.pos,self.path,self.type)
        if (self.next is not None):
            g.next = self.next.clone(resetGID)
        if resetGID:
            g.gid = 0
        return g

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pos = None
        _hx_o.gid = None
        _hx_o.path = None
        _hx_o.type = None
        _hx_o.next = None
hxsl_AllocGlobal._hx_class = hxsl_AllocGlobal
_hx_classes["hxsl.AllocGlobal"] = hxsl_AllocGlobal


class hxsl_RuntimeShaderData:
    _hx_class_name = "hxsl.RuntimeShaderData"
    _hx_is_interface = "False"
    __slots__ = ("vertex", "data", "code", "params", "paramsSize", "globals", "globalsSize", "textures", "texturesCount", "buffers", "bufferCount", "consts")
    _hx_fields = ["vertex", "data", "code", "params", "paramsSize", "globals", "globalsSize", "textures", "texturesCount", "buffers", "bufferCount", "consts"]

    def __init__(self):
        self.consts = None
        self.bufferCount = None
        self.buffers = None
        self.texturesCount = None
        self.textures = None
        self.globalsSize = None
        self.globals = None
        self.paramsSize = None
        self.params = None
        self.code = None
        self.data = None
        self.vertex = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vertex = None
        _hx_o.data = None
        _hx_o.code = None
        _hx_o.params = None
        _hx_o.paramsSize = None
        _hx_o.globals = None
        _hx_o.globalsSize = None
        _hx_o.textures = None
        _hx_o.texturesCount = None
        _hx_o.buffers = None
        _hx_o.bufferCount = None
        _hx_o.consts = None
hxsl_RuntimeShaderData._hx_class = hxsl_RuntimeShaderData
_hx_classes["hxsl.RuntimeShaderData"] = hxsl_RuntimeShaderData


class hxsl_ShaderInstanceDesc:
    _hx_class_name = "hxsl.ShaderInstanceDesc"
    _hx_is_interface = "False"
    __slots__ = ("shader", "bits", "index")
    _hx_fields = ["shader", "bits", "index"]

    def __init__(self,shader,bits):
        self.index = None
        self.shader = shader
        self.bits = bits

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shader = None
        _hx_o.bits = None
        _hx_o.index = None
hxsl_ShaderInstanceDesc._hx_class = hxsl_ShaderInstanceDesc
_hx_classes["hxsl.ShaderInstanceDesc"] = hxsl_ShaderInstanceDesc


class hxsl_RuntimeShader:
    _hx_class_name = "hxsl.RuntimeShader"
    _hx_is_interface = "False"
    __slots__ = ("id", "vertex", "fragment", "globals", "signature", "batchMode", "spec")
    _hx_fields = ["id", "vertex", "fragment", "globals", "signature", "batchMode", "spec"]
    _hx_methods = ["hasGlobal"]
    _hx_statics = ["UID"]

    def __init__(self):
        self.spec = None
        self.batchMode = None
        self.signature = None
        self.globals = None
        self.fragment = None
        self.vertex = None
        def _hx_local_2():
            _hx_local_0 = hxsl_RuntimeShader
            _hx_local_1 = _hx_local_0.UID
            _hx_local_0.UID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()

    def hasGlobal(self,gid):
        return (gid in self.globals.h)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.vertex = None
        _hx_o.fragment = None
        _hx_o.globals = None
        _hx_o.signature = None
        _hx_o.batchMode = None
        _hx_o.spec = None
hxsl_RuntimeShader._hx_class = hxsl_RuntimeShader
_hx_classes["hxsl.RuntimeShader"] = hxsl_RuntimeShader


class hxsl_Serializer:
    _hx_class_name = "hxsl.Serializer"
    _hx_is_interface = "False"
    __slots__ = ("out", "input", "varMap", "idMap", "typeIdMap", "types", "uid", "tid")
    _hx_fields = ["out", "input", "varMap", "idMap", "typeIdMap", "types", "uid", "tid"]
    _hx_methods = ["writeArr", "readArr", "readVarInt", "writeVarInt", "writeID", "readID", "writeTID", "writeType", "readType", "writeString", "readString", "writeVar", "writeFun", "writeConst", "writeExpr", "readConst", "readExpr", "readVar", "readFun", "unserialize", "serialize"]
    _hx_statics = ["TVECS", "BOPS", "UNOPS", "TGLOBALS", "TSWIZ", "REGS", "VKINDS", "PRECS", "FKIND", "SIGN", "run"]

    def __init__(self):
        self.types = None
        self.typeIdMap = None
        self.idMap = None
        self.varMap = None
        self.input = None
        self.out = None
        self.tid = 1
        self.uid = 1

    def writeArr(self,arr,f):
        self.writeVarInt(len(arr))
        _g = 0
        while (_g < len(arr)):
            v = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            f(v)

    def readArr(self,f):
        _g = []
        _g1 = 0
        _g2 = self.readVarInt()
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = f()
            _g.append(x)
        return _g

    def readVarInt(self):
        b = self.input.readByte()
        if (b < 128):
            return b
        if (b == 255):
            return self.input.readInt32()
        return ((((b & 127)) << 8) | self.input.readByte())

    def writeVarInt(self,id):
        if (id < 128):
            self.out.b.append(id)
        else:
            n = (id >> 8)
            if (n >= 127):
                self.out.b.append(255)
                self.out.addInt32(n)
            else:
                self.out.b.append((n | 128))
                self.out.b.append((id & 255))

    def writeID(self,id):
        id2 = self.idMap.h.get(id,None)
        if (id2 is None):
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.uid
                _hx_local_0.uid = (_hx_local_1 + 1)
                return _hx_local_1
            id2 = _hx_local_2()
            self.idMap.set(id,id2)
        self.writeVarInt(id2)

    def readID(self):
        return self.readVarInt()

    def writeTID(self,t):
        tid = self.typeIdMap.get(t)
        if (tid is not None):
            self.writeVarInt(tid)
            return False
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.tid
            _hx_local_0.tid = (_hx_local_1 + 1)
            return _hx_local_1
        tid = _hx_local_2()
        self.typeIdMap.set(t,tid)
        self.writeVarInt(tid)
        return True

    def writeType(self,t):
        self.out.b.append(t.index)
        tmp = t.index
        if ((((((((((((tmp == 18) or ((tmp == 12))) or ((tmp == 11))) or ((tmp == 10))) or ((tmp == 8))) or ((tmp == 7))) or ((tmp == 6))) or ((tmp == 4))) or ((tmp == 3))) or ((tmp == 2))) or ((tmp == 1))) or ((tmp == 0))):
            pass
        elif (tmp == 5):
            size = t.params[0]
            t1 = t.params[1]
            self.out.b.append((size | ((t1.index << 3))))
        elif (tmp == 9):
            size = t.params[0]
            self.out.addInt32(size)
        elif (tmp == 13):
            vl = t.params[0]
            if self.writeTID(t):
                f = self.writeVar
                self.writeVarInt(len(vl))
                _g = 0
                while (_g < len(vl)):
                    v = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                    _g = (_g + 1)
                    f(v)
        elif (tmp == 14):
            variants = t.params[0]
        elif (tmp == 15):
            t1 = t.params[0]
            size = t.params[1]
            self.writeType(t1)
            tmp = size.index
            if (tmp == 0):
                v = size.params[0]
                self.out.b.append(0)
                self.writeVarInt(v)
            elif (tmp == 1):
                v = size.params[0]
                self.writeVar(v)
            else:
                pass
        elif (tmp == 16):
            t1 = t.params[0]
            size = t.params[1]
            self.writeType(t1)
            tmp = size.index
            if (tmp == 0):
                v = size.params[0]
                self.out.b.append(0)
                self.writeVarInt(v)
            elif (tmp == 1):
                v = size.params[0]
                self.writeVar(v)
            else:
                pass
        elif (tmp == 17):
            size = t.params[0]
            self.out.b.append(size)
        else:
            pass

    def readType(self):
        _g = self.input.readByte()
        if (_g == 0):
            return hxsl_Type.TVoid
        elif (_g == 1):
            return hxsl_Type.TInt
        elif (_g == 2):
            return hxsl_Type.TBool
        elif (_g == 3):
            return hxsl_Type.TFloat
        elif (_g == 4):
            return hxsl_Type.TString
        elif (_g == 5):
            bits = self.input.readByte()
            v = hxsl_Serializer.TVECS.h.get(bits,None)
            if (v is None):
                v = hxsl_Type.TVec((bits & 7),Type.createEnumIndex(hxsl_VecType,(bits >> 3),None))
                hxsl_Serializer.TVECS.set(bits,v)
            return v
        elif (_g == 6):
            return hxsl_Type.TMat3
        elif (_g == 7):
            return hxsl_Type.TMat4
        elif (_g == 8):
            return hxsl_Type.TMat3x4
        elif (_g == 9):
            return hxsl_Type.TBytes(self.input.readInt32())
        elif (_g == 10):
            return hxsl_Type.TSampler2D
        elif (_g == 11):
            return hxsl_Type.TSampler2DArray
        elif (_g == 12):
            return hxsl_Type.TSamplerCube
        elif (_g == 13):
            id = self.readVarInt()
            t = (self.types[id] if id >= 0 and id < len(self.types) else None)
            if (t is not None):
                return t
            f = self.readVar
            _g = []
            _g1 = 0
            _g2 = self.readVarInt()
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = f()
                _g.append(x)
            t = hxsl_Type.TStruct(_g)
            python_internal_ArrayImpl._set(self.types, id, t)
            return t
        elif (_g == 14):
            return hxsl_Type.TFun(None)
        elif (_g == 15):
            t = self.readType()
            v = self.readVar()
            return hxsl_Type.TArray(t,(hxsl_SizeDecl.SConst(self.readVarInt()) if ((v is None)) else hxsl_SizeDecl.SVar(v)))
        elif (_g == 16):
            t = self.readType()
            v = self.readVar()
            return hxsl_Type.TBuffer(t,(hxsl_SizeDecl.SConst(self.readVarInt()) if ((v is None)) else hxsl_SizeDecl.SVar(v)))
        elif (_g == 17):
            return hxsl_Type.TChannel(self.input.readByte())
        elif (_g == 18):
            return hxsl_Type.TMat2
        else:
            raise haxe_Exception.thrown("assert")

    def writeString(self,s):
        _hx_bytes = haxe_io_Bytes.ofString(s)
        self.writeVarInt(_hx_bytes.length)
        self.out.b.extend(_hx_bytes.b)

    def readString(self):
        _hx_len = self.readVarInt()
        s = self.input.read(_hx_len).getString(0,_hx_len)
        return s

    def writeVar(self,v):
        if (v is None):
            self.out.b.append(0)
            return
        self.writeID(v.id)
        if (v.id in self.varMap.h):
            return
        self.varMap.set(v.id,v)
        self.writeString(v.name)
        self.writeType(v.type)
        self.out.b.append(v.kind.index)
        self.writeVar(Reflect.field(v,"parent"))
        if (Reflect.field(v,"qualifiers") is None):
            self.out.b.append(0)
        else:
            self.out.b.append(len(Reflect.field(v,"qualifiers")))
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.out.b.append(q.index)
                tmp = q.index
                if (tmp == 0):
                    _hx_max = q.params[0]
                    self.out.addInt32((0 if ((_hx_max is None)) else _hx_max))
                elif (tmp == 4):
                    n = q.params[0]
                    self.writeString(n)
                elif (((((tmp == 8) or ((tmp == 5))) or ((tmp == 3))) or ((tmp == 2))) or ((tmp == 1))):
                    pass
                elif (tmp == 6):
                    p = q.params[0]
                    self.out.b.append(p.index)
                elif (tmp == 7):
                    _hx_min = q.params[0]
                    max1 = q.params[1]
                    self.out.addInt64(haxe_io_FPHelper.doubleToI64(_hx_min))
                    self.out.addInt64(haxe_io_FPHelper.doubleToI64(max1))
                elif (tmp == 9):
                    v = q.params[0]
                    self.out.addInt32(v)
                elif (tmp == 10):
                    s = q.params[0]
                    self.writeString(s)
                elif (tmp == 11):
                    s1 = q.params[0]
                    self.writeString(s1)
                elif (tmp == 12):
                    s2 = q.params[0]
                    self.writeString(s2)
                else:
                    pass

    def writeFun(self,f):
        self.out.b.append(f.kind.index)
        self.writeVar(f.ref)
        arr = f.args
        f1 = self.writeVar
        self.writeVarInt(len(arr))
        _g = 0
        while (_g < len(arr)):
            v = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            f1(v)
        self.writeType(f.ret)
        self.writeExpr(f.expr)

    def writeConst(self,c):
        self.out.b.append(c.index)
        tmp = c.index
        if (tmp == 0):
            pass
        elif (tmp == 1):
            b = c.params[0]
            self.out.b.append((1 if b else 0))
        elif (tmp == 2):
            v = c.params[0]
            self.out.addInt32(v)
        elif (tmp == 3):
            v = c.params[0]
            self.out.addInt64(haxe_io_FPHelper.doubleToI64(v))
        elif (tmp == 4):
            v = c.params[0]
            self.writeString(v)
        else:
            pass

    def writeExpr(self,e):
        _gthis = self
        if (e is None):
            self.out.b.append(0)
            return
        self.out.b.append((e.e.index + 1))
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            c = _g.params[0]
            self.writeConst(c)
        elif (tmp == 1):
            v = _g.params[0]
            self.writeVar(v)
        elif (tmp == 2):
            g = _g.params[0]
            self.out.b.append(g.index)
        elif (tmp == 3):
            e1 = _g.params[0]
            self.writeExpr(e1)
        elif (tmp == 4):
            el = _g.params[0]
            f = self.writeExpr
            self.writeVarInt(len(el))
            _g1 = 0
            while (_g1 < len(el)):
                v = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                f(v)
        elif (tmp == 5):
            op = _g.params[0]
            e1 = _g.params[1]
            e2 = _g.params[2]
            if (op.index == 20):
                op1 = op.params[0]
                self.out.b.append((op1.index | 128))
            else:
                self.out.b.append(op.index)
            self.writeExpr(e1)
            self.writeExpr(e2)
        elif (tmp == 6):
            op = _g.params[0]
            e1 = _g.params[1]
            self.out.b.append(op.index)
            self.writeExpr(e1)
        elif (tmp == 7):
            v = _g.params[0]
            init = _g.params[1]
            self.writeVar(v)
            self.writeExpr(init)
        elif (tmp == 8):
            e1 = _g.params[0]
            args = _g.params[1]
            self.writeExpr(e1)
            f = self.writeExpr
            self.writeVarInt(len(args))
            _g1 = 0
            while (_g1 < len(args)):
                v = (args[_g1] if _g1 >= 0 and _g1 < len(args) else None)
                _g1 = (_g1 + 1)
                f(v)
        elif (tmp == 9):
            e1 = _g.params[0]
            regs = _g.params[1]
            self.writeExpr(e1)
            if (len(regs) == 0):
                raise haxe_Exception.thrown("assert")
            bits = (len(regs) - 1)
            k = 2
            _g1 = 0
            while (_g1 < len(regs)):
                r = (regs[_g1] if _g1 >= 0 and _g1 < len(regs) else None)
                _g1 = (_g1 + 1)
                bits = (bits | ((r.index << k)))
                k = (k + 2)
            self.out.b.append((bits & 255))
            self.out.b.append((bits >> 8))
        elif (tmp == 10):
            econd = _g.params[0]
            eif = _g.params[1]
            eelse = _g.params[2]
            self.writeExpr(econd)
            self.writeExpr(eif)
            self.writeExpr(eelse)
        elif (tmp == 11):
            pass
        elif (tmp == 12):
            e1 = _g.params[0]
            self.writeExpr(e1)
        elif (tmp == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            self.writeVar(v)
            self.writeExpr(it)
            self.writeExpr(loop)
        elif (tmp == 14):
            pass
        elif (tmp == 15):
            pass
        elif (tmp == 16):
            e1 = _g.params[0]
            index = _g.params[1]
            self.writeExpr(e1)
            self.writeExpr(index)
        elif (tmp == 17):
            el = _g.params[0]
            f = self.writeExpr
            self.writeVarInt(len(el))
            _g1 = 0
            while (_g1 < len(el)):
                v = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                f(v)
        elif (tmp == 18):
            e1 = _g.params[0]
            cases = _g.params[1]
            _hx_def = _g.params[2]
            self.writeExpr(e1)
            self.writeVarInt(len(cases))
            _g1 = 0
            while (_g1 < len(cases)):
                v = (cases[_g1] if _g1 >= 0 and _g1 < len(cases) else None)
                _g1 = (_g1 + 1)
                arr = v.values
                f = _gthis.writeExpr
                _gthis.writeVarInt(len(arr))
                _g2 = 0
                while (_g2 < len(arr)):
                    v1 = (arr[_g2] if _g2 >= 0 and _g2 < len(arr) else None)
                    _g2 = (_g2 + 1)
                    f(v1)
                _gthis.writeExpr(v.expr)
            self.writeExpr(_hx_def)
        elif (tmp == 19):
            e1 = _g.params[0]
            loop = _g.params[1]
            normalWhile = _g.params[2]
            self.writeExpr(e1)
            self.writeExpr(loop)
            self.out.b.append((1 if normalWhile else 0))
        elif (tmp == 20):
            m = _g.params[0]
            args = _g.params[1]
            e1 = _g.params[2]
            self.writeString(m)
            f = self.writeConst
            self.writeVarInt(len(args))
            _g = 0
            while (_g < len(args)):
                v = (args[_g] if _g >= 0 and _g < len(args) else None)
                _g = (_g + 1)
                f(v)
            self.writeExpr(e1)
        else:
            pass
        self.writeType(e.t)

    def readConst(self):
        _g = self.input.readByte()
        if (_g == 0):
            return hxsl_Const.CNull
        elif (_g == 1):
            return hxsl_Const.CBool((self.input.readByte() != 0))
        elif (_g == 2):
            return hxsl_Const.CInt(self.input.readInt32())
        elif (_g == 3):
            return hxsl_Const.CFloat(self.input.readDouble())
        elif (_g == 4):
            return hxsl_Const.CString(self.readString())
        else:
            raise haxe_Exception.thrown("assert")

    def readExpr(self):
        _gthis = self
        k = self.input.readByte()
        tmp = k
        k = (k - 1)
        if (tmp == 0):
            return None
        e = None
        k1 = k
        if (k1 == 0):
            e = hxsl_TExprDef.TConst(self.readConst())
        elif (k1 == 1):
            e = hxsl_TExprDef.TVar(self.readVar())
        elif (k1 == 2):
            e = hxsl_TExprDef.TGlobal(python_internal_ArrayImpl._get(hxsl_Serializer.TGLOBALS, self.input.readByte()))
        elif (k1 == 3):
            e = hxsl_TExprDef.TParenthesis(self.readExpr())
        elif (k1 == 4):
            f = self.readExpr
            _g = []
            _g1 = 0
            _g2 = self.readVarInt()
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = f()
                _g.append(x)
            e = hxsl_TExprDef.TBlock(_g)
        elif (k1 == 5):
            op = self.input.readByte()
            e = hxsl_TExprDef.TBinop((haxe_macro_Binop.OpAssignOp(python_internal_ArrayImpl._get(hxsl_Serializer.BOPS, (op & 127))) if ((op >= 128)) else python_internal_ArrayImpl._get(hxsl_Serializer.BOPS, op)),self.readExpr(),self.readExpr())
        elif (k1 == 6):
            e = hxsl_TExprDef.TUnop(python_internal_ArrayImpl._get(hxsl_Serializer.UNOPS, self.input.readByte()),self.readExpr())
        elif (k1 == 7):
            e = hxsl_TExprDef.TVarDecl(self.readVar(),self.readExpr())
        elif (k1 == 8):
            e1 = self.readExpr()
            f = self.readExpr
            _g = []
            _g1 = 0
            _g2 = self.readVarInt()
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = f()
                _g.append(x)
            e = hxsl_TExprDef.TCall(e1,_g)
        elif (k1 == 9):
            e1 = self.readExpr()
            bits = self.input.readUInt16()
            swiz = hxsl_Serializer.TSWIZ.h.get(bits,None)
            if (swiz is None):
                _g = []
                _g1 = 0
                _g2 = (((bits & 3)) + 1)
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    x = python_internal_ArrayImpl._get(hxsl_Serializer.REGS, ((bits >> (((i * 2) + 2))) & 3))
                    _g.append(x)
                swiz = _g
                hxsl_Serializer.TSWIZ.set(bits,swiz)
            e = hxsl_TExprDef.TSwiz(e1,swiz)
        elif (k1 == 10):
            e = hxsl_TExprDef.TIf(self.readExpr(),self.readExpr(),self.readExpr())
        elif (k1 == 11):
            e = hxsl_TExprDef.TDiscard
        elif (k1 == 12):
            e = hxsl_TExprDef.TReturn(self.readExpr())
        elif (k1 == 13):
            e = hxsl_TExprDef.TFor(self.readVar(),self.readExpr(),self.readExpr())
        elif (k1 == 14):
            e = hxsl_TExprDef.TContinue
        elif (k1 == 15):
            e = hxsl_TExprDef.TBreak
        elif (k1 == 16):
            e = hxsl_TExprDef.TArray(self.readExpr(),self.readExpr())
        elif (k1 == 17):
            f = self.readExpr
            _g = []
            _g1 = 0
            _g2 = self.readVarInt()
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = f()
                _g.append(x)
            e = hxsl_TExprDef.TArrayDecl(_g)
        elif (k1 == 18):
            e1 = self.readExpr()
            _g = []
            _g1 = 0
            _g2 = self.readVarInt()
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                f = _gthis.readExpr
                _g3 = []
                _g4 = 0
                _g5 = _gthis.readVarInt()
                while (_g4 < _g5):
                    i1 = _g4
                    _g4 = (_g4 + 1)
                    x = f()
                    _g3.append(x)
                x1 = _hx_AnonObject({'values': _g3, 'expr': _gthis.readExpr()})
                _g.append(x1)
            e = hxsl_TExprDef.TSwitch(e1,_g,self.readExpr())
        elif (k1 == 19):
            e = hxsl_TExprDef.TWhile(self.readExpr(),self.readExpr(),(self.input.readByte() != 0))
        elif (k1 == 20):
            e1 = self.readString()
            f = self.readConst
            _g = []
            _g1 = 0
            _g2 = self.readVarInt()
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = f()
                _g.append(x)
            e = hxsl_TExprDef.TMeta(e1,_g,self.readExpr())
        else:
            raise haxe_Exception.thrown("assert")
        return _hx_AnonObject({'e': e, 't': self.readType(), 'p': None})

    def readVar(self):
        id = self.readVarInt()
        if (id == 0):
            return None
        v = self.varMap.h.get(id,None)
        if (v is not None):
            return v
        v = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': self.readString(), 'type': None, 'kind': None})
        self.varMap.set(id,v)
        v.type = self.readType()
        v.kind = python_internal_ArrayImpl._get(hxsl_Serializer.VKINDS, self.input.readByte())
        Reflect.setField(v,"parent",self.readVar())
        nq = self.input.readByte()
        if (nq > 0):
            Reflect.setField(v,"qualifiers",[])
            _g = 0
            _g1 = nq
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                qid = self.input.readByte()
                q = None
                qid1 = qid
                if (qid1 == 0):
                    n = self.input.readInt32()
                    q = hxsl_VarQualifier.Const((None if ((n == 0)) else n))
                elif (qid1 == 1):
                    q = hxsl_VarQualifier.Private
                elif (qid1 == 2):
                    q = hxsl_VarQualifier.Nullable
                elif (qid1 == 3):
                    q = hxsl_VarQualifier.PerObject
                elif (qid1 == 4):
                    q = hxsl_VarQualifier.Name(self.readString())
                elif (qid1 == 5):
                    q = hxsl_VarQualifier.Shared
                elif (qid1 == 6):
                    q = hxsl_VarQualifier.Precision(python_internal_ArrayImpl._get(hxsl_Serializer.PRECS, self.input.readByte()))
                elif (qid1 == 7):
                    q = hxsl_VarQualifier.Range(self.input.readDouble(),self.input.readDouble())
                elif (qid1 == 8):
                    q = hxsl_VarQualifier.Ignore
                elif (qid1 == 9):
                    q = hxsl_VarQualifier.PerInstance(self.input.readInt32())
                elif (qid1 == 10):
                    q = hxsl_VarQualifier.Doc(self.readString())
                elif (qid1 == 11):
                    q = hxsl_VarQualifier.Borrow(self.readString())
                elif (qid1 == 12):
                    q = hxsl_VarQualifier.Sampler(self.readString())
                else:
                    raise haxe_Exception.thrown("assert")
                _this = Reflect.field(v,"qualifiers")
                _this.append(q)
        return v

    def readFun(self):
        tmp = python_internal_ArrayImpl._get(hxsl_Serializer.FKIND, self.input.readByte())
        tmp1 = self.readVar()
        f = self.readVar
        _g = []
        _g1 = 0
        _g2 = self.readVarInt()
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = f()
            _g.append(x)
        return _hx_AnonObject({'kind': tmp, 'ref': tmp1, 'args': _g, 'ret': self.readType(), 'expr': self.readExpr()})

    def unserialize(self,data):
        self.input = haxe_io_BytesInput(haxe_crypto_Base64.decode(data,False))
        if (((self.input.readByte() != ((hxsl_Serializer.SIGN & 255))) or ((self.input.readByte() != (((hxsl_Serializer.SIGN >> 8) & 255))))) or ((self.input.readByte() != (((hxsl_Serializer.SIGN >> 16) & 255))))):
            raise haxe_Exception.thrown("Invalid HXSL data")
        self.varMap = haxe_ds_IntMap()
        self.types = []
        tmp = self.readString()
        f = self.readVar
        _g = []
        _g1 = 0
        _g2 = self.readVarInt()
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = f()
            _g.append(x)
        tmp1 = _g
        f = self.readFun
        _g = []
        _g1 = 0
        _g2 = self.readVarInt()
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = f()
            _g.append(x)
        return _hx_AnonObject({'name': tmp, 'vars': tmp1, 'funs': _g})

    def serialize(self,s):
        self.varMap = haxe_ds_IntMap()
        self.idMap = haxe_ds_IntMap()
        self.typeIdMap = haxe_ds_EnumValueMap()
        self.out = haxe_io_BytesBuffer()
        self.out.b.append((hxsl_Serializer.SIGN & 255))
        self.out.b.append(((hxsl_Serializer.SIGN >> 8) & 255))
        self.out.b.append(((hxsl_Serializer.SIGN >> 16) & 255))
        self.writeString(s.name)
        arr = s.vars
        f = self.writeVar
        self.writeVarInt(len(arr))
        _g = 0
        while (_g < len(arr)):
            v = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            f(v)
        arr = s.funs
        f = self.writeFun
        self.writeVarInt(len(arr))
        _g = 0
        while (_g < len(arr)):
            v = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            f(v)
        return haxe_crypto_Base64.encode(self.out.getBytes(),False)

    @staticmethod
    def run(s):
        return hxsl_Serializer().serialize(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.out = None
        _hx_o.input = None
        _hx_o.varMap = None
        _hx_o.idMap = None
        _hx_o.typeIdMap = None
        _hx_o.types = None
        _hx_o.uid = None
        _hx_o.tid = None
hxsl_Serializer._hx_class = hxsl_Serializer
_hx_classes["hxsl.Serializer"] = hxsl_Serializer


class hxsl_ShaderList:
    _hx_class_name = "hxsl.ShaderList"
    _hx_is_interface = "False"
    __slots__ = ("s", "next")
    _hx_fields = ["s", "next"]
    _hx_methods = ["clone", "iterator", "iterateTo"]
    _hx_statics = ["addSort"]

    def __init__(self,s,n = None):
        self.s = s
        self.next = n

    def clone(self):
        return hxsl_ShaderList(self.s.clone(),(None if ((self.next is None)) else self.next.clone()))

    def iterator(self):
        return hxsl__ShaderList_ShaderIterator(self,None)

    def iterateTo(self,s):
        return hxsl__ShaderList_ShaderIterator(self,s)

    @staticmethod
    def addSort(s,shaders):
        prev = None
        hd = shaders
        while ((hd is not None) and ((hd.s.priority < s.priority))):
            prev = hd
            hd = hd.next
        if (prev is None):
            return hxsl_ShaderList(s,shaders)
        prev.next = hxsl_ShaderList(s,prev.next)
        return shaders

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.s = None
        _hx_o.next = None
hxsl_ShaderList._hx_class = hxsl_ShaderList
_hx_classes["hxsl.ShaderList"] = hxsl_ShaderList


class hxsl__ShaderList_ShaderIterator:
    _hx_class_name = "hxsl._ShaderList.ShaderIterator"
    _hx_is_interface = "False"
    __slots__ = ("l", "last")
    _hx_fields = ["l", "last"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,l,last):
        self.l = l
        self.last = last

    def hasNext(self):
        return (self.l != self.last)

    def next(self):
        s = self.l.s
        self.l = self.l.next
        return s

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.l = None
        _hx_o.last = None
hxsl__ShaderList_ShaderIterator._hx_class = hxsl__ShaderList_ShaderIterator
_hx_classes["hxsl._ShaderList.ShaderIterator"] = hxsl__ShaderList_ShaderIterator


class hxsl_ShaderInstance:
    _hx_class_name = "hxsl.ShaderInstance"
    _hx_is_interface = "False"
    __slots__ = ("id", "shader", "params")
    _hx_fields = ["id", "shader", "params"]

    def __init__(self,shader):
        self.id = hxsl_Tools.allocVarId()
        self.shader = shader
        self.params = haxe_ds_IntMap()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.shader = None
        _hx_o.params = None
hxsl_ShaderInstance._hx_class = hxsl_ShaderInstance
_hx_classes["hxsl.ShaderInstance"] = hxsl_ShaderInstance


class hxsl_ShaderGlobal:
    _hx_class_name = "hxsl.ShaderGlobal"
    _hx_is_interface = "False"
    __slots__ = ("v", "globalId")
    _hx_fields = ["v", "globalId"]

    def __init__(self,v,gid):
        self.v = v
        self.globalId = gid

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.v = None
        _hx_o.globalId = None
hxsl_ShaderGlobal._hx_class = hxsl_ShaderGlobal
_hx_classes["hxsl.ShaderGlobal"] = hxsl_ShaderGlobal


class hxsl_ShaderConst:
    _hx_class_name = "hxsl.ShaderConst"
    _hx_is_interface = "False"
    __slots__ = ("v", "pos", "bits", "globalId", "next")
    _hx_fields = ["v", "pos", "bits", "globalId", "next"]

    def __init__(self,v,pos,bits):
        self.next = None
        self.globalId = None
        self.v = v
        self.pos = pos
        self.bits = bits

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.v = None
        _hx_o.pos = None
        _hx_o.bits = None
        _hx_o.globalId = None
        _hx_o.next = None
hxsl_ShaderConst._hx_class = hxsl_ShaderConst
_hx_classes["hxsl.ShaderConst"] = hxsl_ShaderConst


class hxsl_SharedShader:
    _hx_class_name = "hxsl.SharedShader"
    _hx_is_interface = "False"
    __slots__ = ("data", "globals", "consts", "instanceCache", "paramsCount")
    _hx_fields = ["data", "globals", "consts", "instanceCache", "paramsCount"]
    _hx_methods = ["initialize", "getInstance", "makeInstance", "addSelfParam", "addParam", "browseVar"]
    _hx_statics = ["UNROLL_LOOPS"]

    def __init__(self,src):
        self.paramsCount = None
        self.instanceCache = haxe_ds_IntMap()
        self.consts = None
        self.globals = []
        if (src == ""):
            return
        self.data = hxsl_Serializer().unserialize(src)
        self.initialize()

    def initialize(self):
        _g = 0
        _g1 = self.data.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.browseVar(v)

    def getInstance(self,constBits):
        i = self.instanceCache.h.get(constBits,None)
        if (i is None):
            return self.makeInstance(constBits)
        else:
            return i

    def makeInstance(self,constBits):
        eval = hxsl_Eval()
        c = self.consts
        while (c is not None):
            c1 = c.v
            _g = c.v.type
            tmp = None
            tmp1 = _g.index
            if (tmp1 == 1):
                tmp = hxsl_Const.CInt((HxOverrides.rshift(constBits, c.pos) & ((((1 << c.bits)) - 1))))
            elif (tmp1 == 2):
                tmp = hxsl_Const.CBool((((HxOverrides.rshift(constBits, c.pos) & 1)) != 0))
            elif (tmp1 == 17):
                _g1 = _g.params[0]
                tmp = hxsl_Const.CInt((HxOverrides.rshift(constBits, c.pos) & ((((1 << c.bits)) - 1))))
            else:
                raise haxe_Exception.thrown("assert")
            eval.setConstant(c1,tmp)
            c = c.next
        eval.inlineCalls = True
        eval.unrollLoops = hxsl_SharedShader.UNROLL_LOOPS
        i = hxsl_ShaderInstance(eval.eval(self.data))
        self.paramsCount = 0
        _g = 0
        _g1 = self.data.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.addParam(eval,i,v)
        self.instanceCache.set(constBits,i)
        return i

    def addSelfParam(self,i,v):
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g = 0
            while (_g < len(vl)):
                v1 = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                self.addSelfParam(i,v1)
        elif (v.kind == hxsl_VarKind.Param):
            i.params.set(v.id,self.paramsCount)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.paramsCount
            _hx_local_1.paramsCount = (_hx_local_2 + 1)
            _hx_local_2

    def addParam(self,eval,i,v):
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g = 0
            while (_g < len(vl)):
                v1 = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                self.addParam(eval,i,v1)
        elif (v.kind == hxsl_VarKind.Param):
            i.params.set(eval.varMap.h.get(v,None).id,self.paramsCount)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.paramsCount
            _hx_local_1.paramsCount = (_hx_local_2 + 1)
            _hx_local_2

    def browseVar(self,v,path = None):
        v.id = hxsl_Tools.allocVarId()
        if (path is None):
            path = hxsl_Tools.getName(v)
        else:
            path = (("null" if path is None else path) + HxOverrides.stringOrNull((("." + HxOverrides.stringOrNull(v.name)))))
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g = 0
            while (_g < len(vl)):
                vs = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                self.browseVar(vs,path)
        else:
            globalId = 0
            if (v.kind == hxsl_VarKind.Global):
                globalId = hxsl_Globals.allocID(path)
                _this = self.globals
                x = hxsl_ShaderGlobal(v,globalId)
                _this.append(x)
            if (not hxsl_Tools.isConst(v)):
                return
            bits = hxsl_Tools.getConstBits(v)
            if (bits > 0):
                pos = (0 if ((self.consts is None)) else (self.consts.pos + self.consts.bits))
                c = hxsl_ShaderConst(v,pos,bits)
                c.globalId = globalId
                c.next = self.consts
                self.consts = c

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
        _hx_o.globals = None
        _hx_o.consts = None
        _hx_o.instanceCache = None
        _hx_o.paramsCount = None
hxsl_SharedShader._hx_class = hxsl_SharedShader
_hx_classes["hxsl.SharedShader"] = hxsl_SharedShader


class hxsl__Splitter_VarProps:
    _hx_class_name = "hxsl._Splitter.VarProps"
    _hx_is_interface = "False"
    __slots__ = ("v", "read", "write", "local", "requireInit")
    _hx_fields = ["v", "read", "write", "local", "requireInit"]

    def __init__(self,v):
        self.requireInit = None
        self.local = None
        self.v = v
        self.read = 0
        self.write = 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.v = None
        _hx_o.read = None
        _hx_o.write = None
        _hx_o.local = None
        _hx_o.requireInit = None
hxsl__Splitter_VarProps._hx_class = hxsl__Splitter_VarProps
_hx_classes["hxsl._Splitter.VarProps"] = hxsl__Splitter_VarProps


class hxsl_Splitter:
    _hx_class_name = "hxsl.Splitter"
    _hx_is_interface = "False"
    __slots__ = ("vars", "varNames", "varMap")
    _hx_fields = ["vars", "varNames", "varMap"]
    _hx_methods = ["split", "addExpr", "checkVar", "mapVars", "get", "uniqueName", "checkExpr"]

    def __init__(self):
        self.varMap = None
        self.varNames = None
        self.vars = None

    def split(self,s):
        vfun = None
        vvars = haxe_ds_IntMap()
        ffun = None
        fvars = haxe_ds_IntMap()
        self.varNames = haxe_ds_StringMap()
        self.varMap = haxe_ds_ObjectMap()
        _g = 0
        _g1 = s.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            tmp = f.kind.index
            if (tmp == 0):
                self.vars = vvars
                vfun = f
                self.checkExpr(f.expr)
            elif (tmp == 1):
                self.vars = fvars
                ffun = f
                self.checkExpr(f.expr)
            else:
                raise haxe_Exception.thrown("assert")
        vfun = _hx_AnonObject({'ret': vfun.ret, 'ref': vfun.ref, 'kind': vfun.kind, 'args': vfun.args, 'expr': self.mapVars(vfun.expr)})
        _g = 0
        _g1 = Lambda.array(vvars)
        while (_g < len(_g1)):
            inf = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            v = inf.v
            tmp = v.kind.index
            if ((tmp == 4) or ((tmp == 3))):
                v.kind = (hxsl_VarKind.Var if ((v.id in fvars.h)) else hxsl_VarKind.Local)
            else:
                pass
            tmp1 = v.kind.index
            if ((tmp1 == 5) or ((tmp1 == 3))):
                if ((inf.read > 0) or ((inf.write > 1))):
                    nv = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': v.name, 'kind': v.kind, 'type': v.type})
                    self.vars = vvars
                    ninf = self.get(nv)
                    v.kind = hxsl_VarKind.Local
                    p = vfun.expr.p
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,_hx_AnonObject({'e': hxsl_TExprDef.TVar(nv), 't': nv.type, 'p': p}),_hx_AnonObject({'e': hxsl_TExprDef.TVar(v), 't': v.type, 'p': p})), 't': nv.type, 'p': p})
                    self.addExpr(vfun,e)
                    self.checkExpr(e)
                    if (nv.kind == hxsl_VarKind.Var):
                        old = fvars.h.get(v.id,None)
                        self.varMap.set(v,nv)
                        fvars.remove(v.id)
                        np = hxsl__Splitter_VarProps(nv)
                        np.read = old.read
                        np.write = old.write
                        fvars.set(nv.id,np)
            else:
                pass
        finits = []
        todo = []
        inf = fvars.iterator()
        while inf.hasNext():
            inf1 = inf.next()
            v = inf1.v
            tmp = v.kind.index
            if (tmp == 1):
                nv = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': v.name, 'kind': hxsl_VarKind.Var, 'type': v.type})
                self.uniqueName(nv)
                i = vvars.h.get(v.id,None)
                if (i is None):
                    i = hxsl__Splitter_VarProps(v)
                    vvars.set(v.id,i)
                i.read = (i.read + 1)
                vp = hxsl__Splitter_VarProps(nv)
                vp.write = 1
                vvars.set(nv.id,vp)
                fp = hxsl__Splitter_VarProps(nv)
                fp.read = 1
                todo.append(fp)
                self.addExpr(vfun,_hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,_hx_AnonObject({'e': hxsl_TExprDef.TVar(nv), 't': v.type, 'p': vfun.expr.p}),_hx_AnonObject({'e': hxsl_TExprDef.TVar(v), 't': v.type, 'p': vfun.expr.p})), 't': v.type, 'p': vfun.expr.p}))
                self.varMap.set(v,nv)
                inf1.local = True
            elif (tmp == 3):
                if (inf1.write > 0):
                    nv1 = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': v.name, 'kind': hxsl_VarKind.Local, 'type': v.type})
                    self.uniqueName(nv1)
                    x = _hx_AnonObject({'e': hxsl_TExprDef.TVarDecl(nv1,_hx_AnonObject({'e': hxsl_TExprDef.TVar(v), 't': v.type, 'p': ffun.expr.p})), 't': hxsl_Type.TVoid, 'p': ffun.expr.p})
                    finits.append(x)
                    self.varMap.set(v,nv1)
            else:
                pass
        _g = 0
        while (_g < len(todo)):
            v = (todo[_g] if _g >= 0 and _g < len(todo) else None)
            _g = (_g + 1)
            fvars.set(v.v.id,v)
        v = vvars.iterator()
        while v.hasNext():
            v1 = v.next()
            self.checkVar(v1,True,vvars,vfun.expr.p)
        v = fvars.iterator()
        while v.hasNext():
            v1 = v.next()
            self.checkVar(v1,False,vvars,ffun.expr.p)
        v = self.varMap.keys()
        while v.hasNext():
            v1 = v.next()
            this1 = self.varMap
            key = self.varMap.h.get(v1,None)
            v2 = this1.h.get(key,None)
            if (v2 is not None):
                self.varMap.set(v1,v2)
        ffun = _hx_AnonObject({'ret': ffun.ret, 'ref': ffun.ref, 'kind': ffun.kind, 'args': ffun.args, 'expr': self.mapVars(ffun.expr)})
        _g = ffun.expr.e
        if (_g.index == 4):
            el = _g.params[0]
            _g = 0
            while (_g < len(finits)):
                e = (finits[_g] if _g >= 0 and _g < len(finits) else None)
                _g = (_g + 1)
                el.insert(0, e)
        else:
            x = ffun.expr
            finits.append(x)
            ffun.expr = _hx_AnonObject({'e': hxsl_TExprDef.TBlock(finits), 't': hxsl_Type.TVoid, 'p': ffun.expr.p})
        _g = []
        v = vvars.iterator()
        while v.hasNext():
            v1 = v.next()
            if (not v1.local):
                x = v1.v
                _g.append(x)
        vvars = _g
        _g = []
        v = fvars.iterator()
        while v.hasNext():
            v1 = v.next()
            if (not v1.local):
                x = v1.v
                _g.append(x)
        fvars = _g
        def _hx_local_5(v1,v2):
            return (v1.id - v2.id)
        vvars.sort(key= python_lib_Functools.cmp_to_key(_hx_local_5))
        def _hx_local_6(v1,v2):
            return (v1.id - v2.id)
        fvars.sort(key= python_lib_Functools.cmp_to_key(_hx_local_6))
        return _hx_AnonObject({'vertex': _hx_AnonObject({'name': "vertex", 'vars': vvars, 'funs': [vfun]}), 'fragment': _hx_AnonObject({'name': "fragment", 'vars': fvars, 'funs': [ffun]})})

    def addExpr(self,f,e):
        _g = f.expr.e
        if (_g.index == 4):
            el = _g.params[0]
            el.append(e)
        else:
            f.expr = _hx_AnonObject({'e': hxsl_TExprDef.TBlock([f.expr, e]), 't': hxsl_Type.TVoid, 'p': f.expr.p})

    def checkVar(self,v,vertex,vvars,p):
        tmp = v.v.kind.index
        if (tmp == 3):
            if (not vertex):
                i = vvars.h.get(v.v.id,None)
                if ((i is None) or ((i.write == 0))):
                    raise haxe_Exception.thrown(hxsl_Error((("Varying " + HxOverrides.stringOrNull(v.v.name)) + " is not written by vertex shader"),p))
        elif (tmp == 4):
            if v.requireInit:
                raise haxe_Exception.thrown(hxsl_Error((("Variable " + HxOverrides.stringOrNull(v.v.name)) + " is used without being initialized"),p))
        else:
            pass

    def mapVars(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 1):
            v = _g.params[0]
            v2 = self.varMap.h.get(v,None)
            if (v2 is None):
                return e
            else:
                return _hx_AnonObject({'e': hxsl_TExprDef.TVar(v2), 't': e.t, 'p': e.p})
        elif (tmp == 7):
            v = _g.params[0]
            init = _g.params[1]
            v2 = self.varMap.h.get(v,None)
            if (v2 is None):
                return hxsl_Tools.map(e,self.mapVars)
            else:
                return _hx_AnonObject({'e': hxsl_TExprDef.TVarDecl(v2,self.mapVars(init)), 't': e.t, 'p': e.p})
        elif (tmp == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            v2 = self.varMap.h.get(v,None)
            if (v2 is None):
                return hxsl_Tools.map(e,self.mapVars)
            else:
                return _hx_AnonObject({'e': hxsl_TExprDef.TFor(v2,self.mapVars(it),self.mapVars(loop)), 't': e.t, 'p': e.p})
        else:
            return hxsl_Tools.map(e,self.mapVars)

    def get(self,v):
        i = self.vars.h.get(v.id,None)
        if (i is None):
            v2 = self.varMap.h.get(v,None)
            if (v2 is not None):
                return self.get(v2)
            oldName = v.name
            self.uniqueName(v)
            if ((v.kind == hxsl_VarKind.Local) and ((oldName != v.name))):
                nv = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': v.name, 'kind': v.kind, 'type': v.type})
                self.varMap.set(v,nv)
                v.name = oldName
                v = nv
            i = hxsl__Splitter_VarProps(v)
            self.vars.set(v.id,i)
        return i

    def uniqueName(self,v):
        if (((v.kind == hxsl_VarKind.Global) or ((v.kind == hxsl_VarKind.Output))) or ((v.kind == hxsl_VarKind.Input))):
            return
        Reflect.setField(v,"parent",None)
        n = self.varNames.h.get(v.name,None)
        if ((n is not None) and ((n != v))):
            prefix = v.name
            while ((HxString.charCodeAt(prefix,(len(prefix) - 1)) >= 48) and ((HxString.charCodeAt(prefix,(len(prefix) - 1)) <= 57))):
                prefix = HxString.substr(prefix,0,-1)
            k = (2 if ((prefix == v.name)) else Std.parseInt(HxString.substr(v.name,len(prefix),None)))
            while ((("null" if prefix is None else prefix) + Std.string(k)) in self.varNames.h):
                k = (k + 1)
            v.name = (("null" if prefix is None else prefix) + Std.string(k))
        self.varNames.h[v.name] = v

    def checkExpr(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 1):
            v = _g.params[0]
            inf = self.get(v)
            if (inf.write == 0):
                inf.requireInit = True
            inf.read = (inf.read + 1)
        elif (tmp == 5):
            _g1 = _g.params[0]
            _g2 = _g.params[1]
            _g3 = _g.params[2]
            tmp = _g1.index
            if (tmp == 4):
                _g4 = _g2.e
                _g5 = _g2.p
                _g5 = _g2.t
                tmp = _g4.index
                if (tmp == 1):
                    v = _g4.params[0]
                    e1 = _g3
                    inf = self.get(v)
                    inf.write = (inf.write + 1)
                    self.checkExpr(e1)
                elif (tmp == 9):
                    _g5 = _g4.params[0]
                    _g6 = _g4.params[1]
                    _g4 = _g5.e
                    _g6 = _g5.p
                    _g6 = _g5.t
                    if (_g4.index == 1):
                        v = _g4.params[0]
                        e1 = _g3
                        inf = self.get(v)
                        inf.write = (inf.write + 1)
                        self.checkExpr(e1)
                    else:
                        hxsl_Tools.iter(e,self.checkExpr)
                else:
                    hxsl_Tools.iter(e,self.checkExpr)
            elif (tmp == 20):
                _g4 = _g1.params[0]
                _g1 = _g2.e
                _g4 = _g2.p
                _g4 = _g2.t
                tmp = _g1.index
                if (tmp == 1):
                    v = _g1.params[0]
                    e1 = _g3
                    inf = self.get(v)
                    if (inf.write == 0):
                        inf.requireInit = True
                    inf.read = (inf.read + 1)
                    inf.write = (inf.write + 1)
                    self.checkExpr(e1)
                elif (tmp == 9):
                    _g2 = _g1.params[0]
                    _g4 = _g1.params[1]
                    _g1 = _g2.e
                    _g4 = _g2.p
                    _g4 = _g2.t
                    if (_g1.index == 1):
                        v = _g1.params[0]
                        e1 = _g3
                        inf = self.get(v)
                        if (inf.write == 0):
                            inf.requireInit = True
                        inf.read = (inf.read + 1)
                        inf.write = (inf.write + 1)
                        self.checkExpr(e1)
                    else:
                        hxsl_Tools.iter(e,self.checkExpr)
                else:
                    hxsl_Tools.iter(e,self.checkExpr)
            else:
                hxsl_Tools.iter(e,self.checkExpr)
        elif (tmp == 7):
            v = _g.params[0]
            init = _g.params[1]
            inf = self.get(v)
            inf.local = True
            if (init is not None):
                self.checkExpr(init)
                inf.write = (inf.write + 1)
        elif (tmp == 13):
            v = _g.params[0]
            it = _g.params[1]
            loop = _g.params[2]
            self.checkExpr(it)
            inf = self.get(v)
            inf.local = True
            inf.write = (inf.write + 1)
            self.checkExpr(loop)
        else:
            hxsl_Tools.iter(e,self.checkExpr)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vars = None
        _hx_o.varNames = None
        _hx_o.varMap = None
hxsl_Splitter._hx_class = hxsl_Splitter
_hx_classes["hxsl.Splitter"] = hxsl_Splitter


class hxsl_ChannelTools:
    _hx_class_name = "hxsl.ChannelTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["isPackedFormat"]

    @staticmethod
    def isPackedFormat(c):
        return (c.format == h3d_mat_Texture.nativeFormat)
hxsl_ChannelTools._hx_class = hxsl_ChannelTools
_hx_classes["hxsl.ChannelTools"] = hxsl_ChannelTools


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        this1 = python_Lib.anonAsDict(d)
        return this1
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_
_hx_classes["python._KwArgs.KwArgs_Impl_"] = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "dictToAnon", "anonToDict", "anonAsDict"]

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def dictToAnon(v):
        return _hx_AnonObject(v.copy())

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None
python_Lib._hx_class = python_Lib
_hx_classes["python.Lib"] = python_Lib


class HxOverrides:
    _hx_class_name = "HxOverrides"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "split", "rshift", "modf", "mod", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return haxe_iterators_ArrayIterator(x)
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def split(x,delimiter):
        if isinstance(x,str):
            _this = x
            if (delimiter == ""):
                return list(_this)
            else:
                return _this.split(delimiter)
        return x.split(delimiter)

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1
HxOverrides._hx_class = HxOverrides
_hx_classes["HxOverrides"] = HxOverrides


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    _hx_is_interface = "False"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = ["close", "tell", "throwEof", "readinto", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise haxe_Exception.thrown("Write-only stream")

    def close(self):
        self.stream.close()

    def tell(self):
        return self.stream.tell()

    def throwEof(self):
        self.wasEof = True
        raise haxe_Exception.thrown(haxe_io_Eof())

    def readinto(self,b):
        raise haxe_Exception.thrown("abstract method, should be overridden")

    def readBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        ba = bytearray(_hx_len)
        ret = self.readinto(ba)
        if (ret == 0):
            self.throwEof()
        s.blit(pos,haxe_io_Bytes.ofData(ba),0,_hx_len)
        return ret

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None
        _hx_o.wasEof = None
python_io_NativeInput._hx_class = python_io_NativeInput
_hx_classes["python.io.NativeInput"] = python_io_NativeInput


class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    _hx_is_interface = "True"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "readByte", "readBytes", "close", "readFullBytes", "read", "readUntil", "readLine", "readFloat", "readDouble", "readInt16", "readUInt16", "readUInt24", "readInt32", "readString"]
python_io_IInput._hx_class = python_io_IInput
_hx_classes["python.io.IInput"] = python_io_IInput


class python_io_NativeBytesInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeBytesInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "seek", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    def seek(self,p,pos):
        self.wasEof = False
        python_io_IoTools.seekInBinaryMode(self.stream,p,pos)

    def readinto(self,b):
        return self.stream.readinto(b)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeBytesInput._hx_class = python_io_NativeBytesInput
_hx_classes["python.io.NativeBytesInput"] = python_io_NativeBytesInput


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["seek", "tell"]
    _hx_interfaces = [python_io_IInput]
python_io_IFileInput._hx_class = python_io_IFileInput
_hx_classes["python.io.IFileInput"] = python_io_IFileInput


class python_io_FileBytesInput(python_io_NativeBytesInput):
    _hx_class_name = "python.io.FileBytesInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeBytesInput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileBytesInput._hx_class = python_io_FileBytesInput
_hx_classes["python.io.FileBytesInput"] = python_io_FileBytesInput


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "seek", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.buffer.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    def seek(self,p,pos):
        self.wasEof = False
        python_io_IoTools.seekInTextMode(self.stream,self.tell,p,pos)

    def readinto(self,b):
        return self.stream.buffer.readinto(b)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeTextInput._hx_class = python_io_NativeTextInput
_hx_classes["python.io.NativeTextInput"] = python_io_NativeTextInput


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextInput._hx_class = python_io_FileTextInput
_hx_classes["python.io.FileTextInput"] = python_io_FileTextInput


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileInputFromBytes", "seekInTextMode", "seekInBinaryMode"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileInputFromBytes(t):
        return sys_io_FileInput(python_io_FileBytesInput(t))

    @staticmethod
    def seekInTextMode(stream,tell,p,pos):
        pos1 = None
        pos2 = pos.index
        if (pos2 == 0):
            pos1 = 0
        elif (pos2 == 1):
            p = (tell() + p)
            pos1 = 0
        elif (pos2 == 2):
            stream.seek(0,2)
            p = (tell() + p)
            pos1 = 0
        else:
            pass
        stream.seek(p,pos1)

    @staticmethod
    def seekInBinaryMode(stream,p,pos):
        pos1 = None
        pos2 = pos.index
        if (pos2 == 0):
            pos1 = 0
        elif (pos2 == 1):
            pos1 = 1
        elif (pos2 == 2):
            pos1 = 2
        else:
            pass
        stream.seek(p,pos1)
python_io_IoTools._hx_class = python_io_IoTools
_hx_classes["python.io.IoTools"] = python_io_IoTools


class screens_Screen(h2d_Scene):
    _hx_class_name = "screens.Screen"
    _hx_is_interface = "False"
    __slots__ = ("ASSET_SCALE",)
    _hx_fields = ["ASSET_SCALE"]
    _hx_methods = ["init", "update"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Scene


    def __init__(self):
        self.ASSET_SCALE = 0.375
        super().__init__()

    def init(self):
        pass

    def update(self,dt):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.ASSET_SCALE = None
screens_Screen._hx_class = screens_Screen
_hx_classes["screens.Screen"] = screens_Screen


class screens_Menu(screens_Screen):
    _hx_class_name = "screens.Menu"
    _hx_is_interface = "False"
    __slots__ = ("TITLE_SCALE", "time", "mov", "sy", "ey", "ty", "tf_start", "tf_exit", "tf_title")
    _hx_fields = ["TITLE_SCALE", "time", "mov", "sy", "ey", "ty", "tf_start", "tf_exit", "tf_title"]
    _hx_methods = ["init", "add_title", "update_menu", "menu_add", "update"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = screens_Screen


    def __init__(self):
        self.tf_title = None
        self.tf_exit = None
        self.tf_start = None
        self.time = None
        self.ty = 30
        self.ey = 640
        self.sy = 560
        self.mov = 1
        self.TITLE_SCALE = 3
        super().__init__()

    def init(self):
        haxe_Log.trace("Menu init()",_hx_AnonObject({'fileName': "src/screens/Menu.hx", 'lineNumber': 15, 'className': "screens.Menu", 'methodName': "init"}))
        bitmap = h2d_Bitmap(hxd_Res.get_loader().loadCache("background.png",hxd_res_Image).toTile(),self)
        v = self.ASSET_SCALE
        bitmap.posChanged = True
        bitmap.scaleX = (bitmap.scaleX * v)
        bitmap.posChanged = True
        bitmap.scaleY = (bitmap.scaleY * v)
        self.tf_title = h2d_Text(hxd_Res.get_loader().loadCache("GloriaHallelujah.fnt",hxd_res_BitmapFont).toFont(),self)
        _this = self.tf_title
        v = self.TITLE_SCALE
        _this.posChanged = True
        _this.scaleX = (_this.scaleX * v)
        _this.posChanged = True
        _this.scaleY = (_this.scaleY * v)
        self.add_title(self.tf_title,self.ty)
        self.tf_start = h2d_Text(hxd_Res.get_loader().loadCache("GloriaHallelujah.fnt",hxd_res_BitmapFont).toFont(),self)
        self.tf_exit = h2d_Text(hxd_Res.get_loader().loadCache("GloriaHallelujah.fnt",hxd_res_BitmapFont).toFont(),self)
        self.update_menu(self.sy,self.ey)

    def add_title(self,item,y):
        item.set_text("Colhe Cacau!")
        v = ((self.window.get_width() / 2) - (((item.get_textWidth() * self.TITLE_SCALE) / 2)))
        item.posChanged = True
        item.x = v
        item.posChanged = True
        item.y = y

    def update_menu(self,sy,ey):
        self.menu_add(self.tf_start,sy,"Press enter to start")
        self.menu_add(self.tf_exit,ey,"Press esc to exit")

    def menu_add(self,item,y,descricao):
        item.set_text(descricao)
        v = ((self.window.get_width() / 2) - ((item.get_textWidth() / 2)))
        item.posChanged = True
        item.x = v
        item.posChanged = True
        item.y = y

    def update(self,dt):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.time
        _hx_local_0.time = (_hx_local_1 + dt)
        _hx_local_0.time
        if (self.time >= 0.1):
            if ((self.mov < 4) or (((self.sy > 554) and ((self.ey < 644))))):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.sy
                _hx_local_2.sy = (_hx_local_3 - 1)
                _hx_local_2.sy
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.ty
                _hx_local_4.ty = (_hx_local_5 - 1)
                _hx_local_4.ty
            elif ((self.mov > 3) or (((self.sy > 564) and ((self.ey < 634))))):
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.sy
                _hx_local_6.sy = (_hx_local_7 + 1)
                _hx_local_6.sy
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.ty
                _hx_local_8.ty = (_hx_local_9 + 1)
                _hx_local_8.ty
            self.update_menu(self.sy,self.ey)
            if (self.mov < 7):
                _hx_local_10 = self
                _hx_local_11 = _hx_local_10.mov
                _hx_local_10.mov = (_hx_local_11 + 1)
                _hx_local_10.mov
            else:
                self.mov = 1
            self.time = 0
        if hxd_Key.isPressed(27):
            haxe_Log.trace("Menu update(): esc wasPressed",_hx_AnonObject({'fileName': "src/screens/Menu.hx", 'lineNumber': 73, 'className': "screens.Menu", 'methodName': "update"}))
            hxd_System.exit()
        if hxd_Key.isPressed(13):
            haxe_Log.trace("Menu update(): ender wasPressed",_hx_AnonObject({'fileName': "src/screens/Menu.hx", 'lineNumber': 78, 'className': "screens.Menu", 'methodName': "update"}))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.TITLE_SCALE = None
        _hx_o.time = None
        _hx_o.mov = None
        _hx_o.sy = None
        _hx_o.ey = None
        _hx_o.ty = None
        _hx_o.tf_start = None
        _hx_o.tf_exit = None
        _hx_o.tf_title = None
screens_Menu._hx_class = screens_Menu
_hx_classes["screens.Menu"] = screens_Menu


class sys_io_File:
    _hx_class_name = "sys.io.File"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getContent", "saveContent", "getBytes", "saveBytes", "read", "copy"]

    @staticmethod
    def getContent(path):
        f = python_lib_Builtins.open(path,"r",-1,"utf-8",None,"")
        content = f.read(-1)
        f.close()
        return content

    @staticmethod
    def saveContent(path,content):
        f = python_lib_Builtins.open(path,"w",-1,"utf-8",None,"")
        f.write(content)
        f.close()

    @staticmethod
    def getBytes(path):
        f = python_lib_Builtins.open(path,"rb",-1)
        size = f.read(-1)
        b = haxe_io_Bytes.ofData(size)
        f.close()
        return b

    @staticmethod
    def saveBytes(path,_hx_bytes):
        f = python_lib_Builtins.open(path,"wb",-1)
        f.write(_hx_bytes.b)
        f.close()

    @staticmethod
    def read(path,binary = None):
        if (binary is None):
            binary = True
        mode = ("rb" if binary else "r")
        f = python_lib_Builtins.open(path,mode,-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileInputFromBytes(f)
        else:
            return python_io_IoTools.createFileInputFromText(f)

    @staticmethod
    def copy(srcPath,dstPath):
        python_lib_Shutil.copy(srcPath,dstPath)
sys_io_File._hx_class = sys_io_File
_hx_classes["sys.io.File"] = sys_io_File


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    _hx_is_interface = "False"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "seek", "tell", "readByte", "readBytes", "close", "readFullBytes", "read", "readUntil", "readLine", "readFloat", "readDouble", "readInt16", "readUInt16", "readUInt24", "readInt32", "readString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def seek(self,p,pos):
        self.impl.seek(p,pos)

    def tell(self):
        return self.impl.tell()

    def readByte(self):
        return self.impl.readByte()

    def readBytes(self,s,pos,_hx_len):
        return self.impl.readBytes(s,pos,_hx_len)

    def close(self):
        self.impl.close()

    def readFullBytes(self,s,pos,_hx_len):
        self.impl.readFullBytes(s,pos,_hx_len)

    def read(self,nbytes):
        return self.impl.read(nbytes)

    def readUntil(self,end):
        return self.impl.readUntil(end)

    def readLine(self):
        return self.impl.readLine()

    def readFloat(self):
        return self.impl.readFloat()

    def readDouble(self):
        return self.impl.readDouble()

    def readInt16(self):
        return self.impl.readInt16()

    def readUInt16(self):
        return self.impl.readUInt16()

    def readUInt24(self):
        return self.impl.readUInt24()

    def readInt32(self):
        return self.impl.readInt32()

    def readString(self,_hx_len,encoding = None):
        return self.impl.readString(_hx_len)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None
sys_io_FileInput._hx_class = sys_io_FileInput
_hx_classes["sys.io.FileInput"] = sys_io_FileInput

class sys_io_FileSeek(Enum):
    __slots__ = ()
    _hx_class_name = "sys.io.FileSeek"
    _hx_constructs = ["SeekBegin", "SeekCur", "SeekEnd"]
sys_io_FileSeek.SeekBegin = sys_io_FileSeek("SeekBegin", 0, ())
sys_io_FileSeek.SeekCur = sys_io_FileSeek("SeekCur", 1, ())
sys_io_FileSeek.SeekEnd = sys_io_FileSeek("SeekEnd", 2, ())
sys_io_FileSeek._hx_class = sys_io_FileSeek
_hx_classes["sys.io.FileSeek"] = sys_io_FileSeek


class sys_thread__EventLoop_RegularEvent:
    _hx_class_name = "sys.thread._EventLoop.RegularEvent"
    _hx_is_interface = "False"
    __slots__ = ("nextRunTime", "interval", "run", "next", "previous")
    _hx_fields = ["nextRunTime", "interval", "run", "next", "previous"]

    def __init__(self,run,nextRunTime,interval):
        self.previous = None
        self.next = None
        self.run = run
        self.nextRunTime = nextRunTime
        self.interval = interval

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nextRunTime = None
        _hx_o.interval = None
        _hx_o.run = None
        _hx_o.next = None
        _hx_o.previous = None
sys_thread__EventLoop_RegularEvent._hx_class = sys_thread__EventLoop_RegularEvent
_hx_classes["sys.thread._EventLoop.RegularEvent"] = sys_thread__EventLoop_RegularEvent


class sys_thread_Lock:
    _hx_class_name = "sys.thread.Lock"
    _hx_is_interface = "False"
    __slots__ = ("semaphore",)
    _hx_fields = ["semaphore"]

    def __init__(self):
        self.semaphore = Lock(0)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.semaphore = None
sys_thread_Lock._hx_class = sys_thread_Lock
_hx_classes["sys.thread.Lock"] = sys_thread_Lock


class sys_thread_NoEventLoopException(haxe_Exception):
    _hx_class_name = "sys.thread.NoEventLoopException"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,msg = None,previous = None):
        if (msg is None):
            msg = "Event loop is not available. Refer to sys.thread.Thread.runWithEventLoop."
        super().__init__(msg,previous)
sys_thread_NoEventLoopException._hx_class = sys_thread_NoEventLoopException
_hx_classes["sys.thread.NoEventLoopException"] = sys_thread_NoEventLoopException


class sys_thread__Thread_Thread_Impl_:
    _hx_class_name = "sys.thread._Thread.Thread_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_events", "processEvents"]
    events = None

    @staticmethod
    def get_events(this1):
        if (this1.events is None):
            raise sys_thread_NoEventLoopException()
        return this1.events

    @staticmethod
    def processEvents():
        sys_thread__Thread_HxThread.current().events.loop()
sys_thread__Thread_Thread_Impl_._hx_class = sys_thread__Thread_Thread_Impl_
_hx_classes["sys.thread._Thread.Thread_Impl_"] = sys_thread__Thread_Thread_Impl_

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi
sys_thread__Thread_HxThread.threads = haxe_ds_ObjectMap()
sys_thread__Thread_HxThread.threadsMutex = sys_thread_Mutex()
sys_thread__Thread_HxThread.mainThread = sys_thread__Thread_HxThread(threading.current_thread())
sys_thread__Thread_HxThread.mainThread.events = sys_thread_EventLoop()

Sys._programPath = sys_FileSystem.fullPath(python_lib_Inspect.getsourcefile(Sys))
Xml.Element = 0
Xml.PCData = 1
Xml.CData = 2
Xml.Comment = 3
Xml.DocType = 4
Xml.ProcessingInstruction = 5
Xml.Document = 6
format_gif_Tools.LN2 = python_lib_Math.log(2)
format_mp3_MPEG.V1 = 3
format_mp3_MPEG.V2 = 2
format_mp3_MPEG.V25 = 0
format_mp3_MPEG.Reserved = 1
format_mp3_MPEG.V1_Bitrates = [[format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_40, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_192, format_mp3_Bitrate.BR_224, format_mp3_Bitrate.BR_256, format_mp3_Bitrate.BR_320, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_192, format_mp3_Bitrate.BR_224, format_mp3_Bitrate.BR_256, format_mp3_Bitrate.BR_320, format_mp3_Bitrate.BR_384, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_192, format_mp3_Bitrate.BR_224, format_mp3_Bitrate.BR_256, format_mp3_Bitrate.BR_288, format_mp3_Bitrate.BR_320, format_mp3_Bitrate.BR_352, format_mp3_Bitrate.BR_384, format_mp3_Bitrate.BR_416, format_mp3_Bitrate.BR_448, format_mp3_Bitrate.BR_Bad]]
format_mp3_MPEG.V2_Bitrates = [[format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_8, format_mp3_Bitrate.BR_16, format_mp3_Bitrate.BR_24, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_40, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_144, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_8, format_mp3_Bitrate.BR_16, format_mp3_Bitrate.BR_24, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_40, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_144, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_144, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_176, format_mp3_Bitrate.BR_192, format_mp3_Bitrate.BR_224, format_mp3_Bitrate.BR_256, format_mp3_Bitrate.BR_Bad]]
format_mp3_MPEG.SamplingRates = [[format_mp3_SamplingRate.SR_11025, format_mp3_SamplingRate.SR_12000, format_mp3_SamplingRate.SR_8000, format_mp3_SamplingRate.SR_Bad], [format_mp3_SamplingRate.SR_Bad, format_mp3_SamplingRate.SR_Bad, format_mp3_SamplingRate.SR_Bad, format_mp3_SamplingRate.SR_Bad], [format_mp3_SamplingRate.SR_22050, format_mp3_SamplingRate.SR_24000, format_mp3_SamplingRate.SR_12000, format_mp3_SamplingRate.SR_Bad], [format_mp3_SamplingRate.SR_44100, format_mp3_SamplingRate.SR_48000, format_mp3_SamplingRate.SR_32000, format_mp3_SamplingRate.SR_Bad]]
format_mp3_CLayer.LReserved = 0
format_mp3_CLayer.LLayer3 = 1
format_mp3_CLayer.LLayer2 = 2
format_mp3_CLayer.LLayer1 = 3
format_mp3_CChannelMode.CStereo = 0
format_mp3_CChannelMode.CJointStereo = 1
format_mp3_CChannelMode.CDualChannel = 2
format_mp3_CChannelMode.CMono = 3
format_mp3_CEmphasis.ENone = 0
format_mp3_CEmphasis.EMs50_15 = 1
format_mp3_CEmphasis.EReserved = 2
format_mp3_CEmphasis.ECCIT_J17 = 3
h2d_RenderContext.BUFFERING = False
h2d_col_Matrix.tmp = h2d_col_Matrix()
h3d_Buffer.GUID = 0
h3d_Engine.SOFTWARE_DRIVER = False
h3d_Engine.ANTIALIASING = 0
h3d_Engine.CURRENT = None
h3d_Matrix.tmp = h3d_Matrix()
h3d_Matrix.lumR = 0.212671
h3d_Matrix.lumG = 0.71516
h3d_Matrix.lumB = 0.072169
h3d_Matrix.SQ13 = 0.57735026918962576450914878050196
h3d_anim_Animation.EPSILON = 0.000001
h3d_col_ObjectCollider.TMP_RAY = h3d_col_Ray()
h3d_col_ObjectCollider.TMP_MAT = h3d_Matrix()
h3d_impl_InputNames.UID = 0
h3d_impl_InputNames.CACHE = haxe_ds_StringMap()
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
h3d_impl_MemoryManager.MAX_MEMORY = 4294967296.
h3d_impl_MemoryManager.MAX_BUFFERS = 65536
h3d_impl_MemoryManager.SIZE = 65533
h3d_impl_MemoryManager.ALL_FLAGS = Type.allEnums(h3d_BufferFlag)
h3d_mat_Defaults.defaultKillAlphaThreshold = 0.5
h3d_mat_Defaults.loadingTextureColor = -65281
h3d_mat_MaterialSetup.current = h3d_mat_MaterialSetup("Default")
h3d_mat_Pass.enableLights_bits = 1
h3d_mat_Pass.enableLights_offset = 0
h3d_mat_Pass.enableLights_mask = 1
h3d_mat_Pass.dynamicParameters_bits = 1
h3d_mat_Pass.dynamicParameters_offset = 1
h3d_mat_Pass.dynamicParameters_mask = 2
h3d_mat_Pass.isStatic_bits = 1
h3d_mat_Pass.isStatic_offset = 2
h3d_mat_Pass.isStatic_mask = 4
h3d_mat_Pass.batchMode_bits = 1
h3d_mat_Pass.batchMode_offset = 3
h3d_mat_Pass.batchMode_mask = 8
h3d_mat_Pass.culling_bits = 2
h3d_mat_Pass.culling_offset = 0
h3d_mat_Pass.culling_mask = 3
h3d_mat_Pass.depthWrite_bits = 1
h3d_mat_Pass.depthWrite_offset = 2
h3d_mat_Pass.depthWrite_mask = 4
h3d_mat_Pass.depthTest_bits = 3
h3d_mat_Pass.depthTest_offset = 3
h3d_mat_Pass.depthTest_mask = 56
h3d_mat_Pass.blendSrc_bits = 4
h3d_mat_Pass.blendSrc_offset = 6
h3d_mat_Pass.blendSrc_mask = 960
h3d_mat_Pass.blendDst_bits = 4
h3d_mat_Pass.blendDst_offset = 10
h3d_mat_Pass.blendDst_mask = 15360
h3d_mat_Pass.blendAlphaSrc_bits = 4
h3d_mat_Pass.blendAlphaSrc_offset = 14
h3d_mat_Pass.blendAlphaSrc_mask = 245760
h3d_mat_Pass.blendAlphaDst_bits = 4
h3d_mat_Pass.blendAlphaDst_offset = 18
h3d_mat_Pass.blendAlphaDst_mask = 3932160
h3d_mat_Pass.blendOp_bits = 3
h3d_mat_Pass.blendOp_offset = 22
h3d_mat_Pass.blendOp_mask = 29360128
h3d_mat_Pass.blendAlphaOp_bits = 3
h3d_mat_Pass.blendAlphaOp_offset = 25
h3d_mat_Pass.blendAlphaOp_mask = 234881024
h3d_mat_Pass.wireframe_bits = 1
h3d_mat_Pass.wireframe_offset = 28
h3d_mat_Pass.wireframe_mask = 268435456
h3d_mat_Pass.reserved_bits = 1
h3d_mat_Pass.reserved_offset = 29
h3d_mat_Pass.reserved_mask = 536870912
h3d_mat_Stencil.readMask_bits = 8
h3d_mat_Stencil.readMask_offset = 0
h3d_mat_Stencil.readMask_mask = 255
h3d_mat_Stencil.writeMask_bits = 8
h3d_mat_Stencil.writeMask_offset = 8
h3d_mat_Stencil.writeMask_mask = 65280
h3d_mat_Stencil.reference_bits = 8
h3d_mat_Stencil.reference_offset = 16
h3d_mat_Stencil.reference_mask = 16711680
h3d_mat_Stencil.frontTest_bits = 3
h3d_mat_Stencil.frontTest_offset = 0
h3d_mat_Stencil.frontTest_mask = 7
h3d_mat_Stencil.frontPass_bits = 3
h3d_mat_Stencil.frontPass_offset = 3
h3d_mat_Stencil.frontPass_mask = 56
h3d_mat_Stencil.frontSTfail_bits = 3
h3d_mat_Stencil.frontSTfail_offset = 6
h3d_mat_Stencil.frontSTfail_mask = 448
h3d_mat_Stencil.frontDPfail_bits = 3
h3d_mat_Stencil.frontDPfail_offset = 9
h3d_mat_Stencil.frontDPfail_mask = 3584
h3d_mat_Stencil.backTest_bits = 3
h3d_mat_Stencil.backTest_offset = 12
h3d_mat_Stencil.backTest_mask = 28672
h3d_mat_Stencil.backPass_bits = 3
h3d_mat_Stencil.backPass_offset = 15
h3d_mat_Stencil.backPass_mask = 229376
h3d_mat_Stencil.backSTfail_bits = 3
h3d_mat_Stencil.backSTfail_offset = 18
h3d_mat_Stencil.backSTfail_mask = 1835008
h3d_mat_Stencil.backDPfail_bits = 3
h3d_mat_Stencil.backDPfail_offset = 21
h3d_mat_Stencil.backDPfail_mask = 14680064
h3d_mat_Texture.UID = 0
h3d_mat_Texture.PREVENT_AUTO_DISPOSE = 2147483647
h3d_mat_Texture.nativeFormat = hxd_PixelFormat.RGBA
h3d_mat_Texture.checkerTextureKeys = haxe_ds_IntMap()
h3d_mat_Texture.noiseTextureKeys = haxe_ds_IntMap()
h3d_mat_Texture.genTextureKeys = haxe_ds_StringMap()
h3d_pass_Blur.__meta__ = _hx_AnonObject({'obj': _hx_AnonObject({'ignore': ["shader"]})})
h3d_shader_ScreenShader.SRC = "HXSLF2gzZC5zaGFkZXIuU2NyZWVuU2hhZGVyBwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACghfX2luaXRfXw4GAAALBnZlcnRleA4GAAACAgoAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAALAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAA"
h3d_pass__Border_BorderShader.SRC = "HXSLHWgzZC5wYXNzLl9Cb3JkZXIuQm9yZGVyU2hhZGVyCQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgVjb2xvcgUMAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMAgoFDAUMAA"
h3d_pass__Copy_ArrayCopyShader.SRC = "HXSLHmgzZC5wYXNzLl9Db3B5LkFycmF5Q29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQsCAAALBWxheWVyAQIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFAQYEAggFDAkDIQ4CAgoLCQMpDgICCQUKCQMmDgECCwEDBQsFDAUMAA"
h3d_pass__Copy_CopyShader.SRC = "HXSLGWgzZC5wYXNzLl9Db3B5LkNvcHlTaGFkZXIJAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKB3RleHR1cmUKAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMCQMhDgICCgoCCQUKBQwFDAA"
h3d_pass__CubeCopy_CubeCopyShader.SRC = "HXSLIWgzZC5wYXNzLl9DdWJlQ29weS5DdWJlQ29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQwCAAALA21hdAYCAAAMCF9faW5pdF9fDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwIMAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADQAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDgAABQIIDwJ1dgUKBAAABgMGAQIJBQoBAwAAAAAAAABAAwUKAQMAAAAAAADwPwMFCgAGBAIIBQwJAyEOAgIKDAkDHw4BBgEJAykOAgIPBQoBAwAAAAAAAPA/AwULAgsGBQsFCwUMBQwA"
h3d_pass_Default.__meta__ = _hx_AnonObject({'fields': _hx_AnonObject({'cameraView': _hx_AnonObject({'_hx_global': ["camera.view"]}), 'cameraNear': _hx_AnonObject({'_hx_global': ["camera.zNear"]}), 'cameraFar': _hx_AnonObject({'_hx_global': ["camera.zFar"]}), 'cameraProj': _hx_AnonObject({'_hx_global': ["camera.proj"]}), 'cameraPos': _hx_AnonObject({'_hx_global': ["camera.position"]}), 'cameraProjDiag': _hx_AnonObject({'_hx_global': ["camera.projDiag"]}), 'cameraProjFlip': _hx_AnonObject({'_hx_global': ["camera.projFlip"]}), 'cameraViewProj': _hx_AnonObject({'_hx_global': ["camera.viewProj"]}), 'cameraInverseViewProj': _hx_AnonObject({'_hx_global': ["camera.inverseViewProj"]}), 'globalTime': _hx_AnonObject({'_hx_global': ["global.time"]}), 'pixelSize': _hx_AnonObject({'_hx_global': ["global.pixelSize"]}), 'globalModelView': _hx_AnonObject({'_hx_global': ["global.modelView"]}), 'globalModelViewInverse': _hx_AnonObject({'_hx_global': ["global.modelViewInverse"]})})})
h3d_pass__HardwarePick_FixedColor.SRC = "HXSLIWgzZC5wYXNzLl9IYXJkd2FyZVBpY2suRml4ZWRDb2xvcgUBB2NvbG9ySUQFDAIAAAIIdmlld3BvcnQFDAIAAAMGb3V0cHV0DQECBAhwb3NpdGlvbgUMBAMABQdjb2xvcklEBQwEAwAEAAAGBnZlcnRleA4GAAAHCGZyYWdtZW50DgYAAAIABgAABQEGBAIEBQwGAQQGAAIEBQwGAQkDKg4DCgICBQwRAAUKAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMCgIEBQwMAAMFDAUMBQwJAyoOAwoCAgUMOQAFCgEDAAAAAAAA8D8DAQMAAAAAAADwPwMFDAUMBQwAAQcAAAUBBgQCBQUMAgEFDAUMAA"
h3d_pass_ShaderManager.STRICT = True
h3d_scene_Object.ROT2RAD = -0.017453292519943295769236907684886
h3d_scene_Object.tmpMat = h3d_Matrix()
h3d_scene_Object.tmpVec = h3d_Vector()
h3d_scene__Object_ObjectFlags_Impl_.FPosChanged = 1
h3d_scene__Object_ObjectFlags_Impl_.FVisible = 2
h3d_scene__Object_ObjectFlags_Impl_.FCulled = 4
h3d_scene__Object_ObjectFlags_Impl_.FFollowPositionOnly = 8
h3d_scene__Object_ObjectFlags_Impl_.FLightCameraCenter = 16
h3d_scene__Object_ObjectFlags_Impl_.FAllocated = 32
h3d_scene__Object_ObjectFlags_Impl_.FAlwaysSync = 64
h3d_scene__Object_ObjectFlags_Impl_.FInheritCulled = 128
h3d_scene__Object_ObjectFlags_Impl_.FNoSerialize = 256
h3d_scene__Object_ObjectFlags_Impl_.FIgnoreBounds = 512
h3d_scene__Object_ObjectFlags_Impl_.FIgnoreCollide = 1024
h3d_scene__Object_ObjectFlags_Impl_.FIgnoreParentTransform = 2048
h3d_scene__Object_ObjectFlags_Impl_.FCullingColliderInherited = 4096
h3d_scene_Skin.TMP_MAT = h3d_Matrix()
h3d_shader_AmbientLight.SRC = "HXSLF2gzZC5zaGFkZXIuQW1iaWVudExpZ2h0CgEGZ2xvYmFsDQECAgxhbWJpZW50TGlnaHQFCwABAAMQcGVyUGl4ZWxMaWdodGluZwIAAQEAAAAAAAAAAAQKcGl4ZWxDb2xvcgUMBAAABQ9saWdodFBpeGVsQ29sb3IFCwQAAAYKbGlnaHRDb2xvcgULBAAABwhhZGRpdGl2ZQICAAEAAAAAAAgIX19pbml0X18OBgAACRBfX2luaXRfX2ZyYWdtZW50DgYAAAoJY2FsY0xpZ2h0DgYAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAABQIIAAAFAQYEAgYFCwsCBwICAgULCQMpDgEBAwAAAAAAAAAAAwULBQsFCwACCQAABQEGBAIFBQsLAgcCAgIFCwkDKQ4BAQMAAAAAAAAAAAMFCwULBQsAAwoBDQpsaWdodENvbG9yBQsEAAAFCwUBDQsCBwICDQULBAYAAgIFCwYBCQMWDgIEBgMBAwAAAAAAAPA/AwICBQsFCwULAQMAAAAAAAAAAAMFCwINBQsFCwULBQsFCwAAAAsAAAUBCwcCAgMCAgaBCgIEBQySAAULCQIKDgECBgULBQsFCwAAAAEMAAAFAQsCAwIGgQoCBAUMkgAFCwkCCg4BAgUFCwULBQsAAAA"
h3d_shader_Base2d.SRC = "HXSLEWgzZC5zaGFkZXIuQmFzZTJkGwEFaW5wdXQNAQMCCHBvc2l0aW9uBQoBAQADAnV2BQoBAQAEBWNvbG9yBQwBAQABAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgEdGltZQMAAAAJBnpWYWx1ZQMCAAAKB3RleHR1cmUKAgAACw5zcHJpdGVQb3NpdGlvbgUMBAAADBBhYnNvbHV0ZVBvc2l0aW9uBQwEAAANCnBpeGVsQ29sb3IFDAQAAA4MdGV4dHVyZUNvbG9yBQwEAAAPDGNhbGN1bGF0ZWRVVgUKAwAAEAppc1JlbGF0aXZlAgIAAQAAAAAAEQVjb2xvcgUMAgAAEg9hYnNvbHV0ZU1hdHJpeEEFCwIAABMPYWJzb2x1dGVNYXRyaXhCBQsCAAAUDWZpbHRlck1hdHJpeEEFCwIAABUNZmlsdGVyTWF0cml4QgULAgAAFghoYXNVVlBvcwICAAEAAAAAABcFdXZQb3MFDAIAABgJa2lsbEFscGhhAgIAAQAAAAAAGQpwaXhlbEFsaWduAgIAAQAAAAAAGhBoYWxmUGl4ZWxJbnZlcnNlBQoCAAAbCXZpZXdwb3J0QQULAgAAHAl2aWV3cG9ydEIFCwIAAB0Ob3V0cHV0UG9zaXRpb24FDAQAAB4IX19pbml0X18OBgAAHwZ2ZXJ0ZXgOBgAAIAhmcmFnbWVudA4GAAADAh4AAAUGBgQCCwUMCQMqDgMCAgUKAgkDAQMAAAAAAADwPwMFDAUMCwIQAgUDBgQKAgwFDAAAAwkDHQ4CCQMpDgIKAgsFDBEABQoBAwAAAAAAAPA/AwULAhIFCwMDBgQKAgwFDAQAAwkDHQ4CCQMpDgIKAgsFDBEABQoBAwAAAAAAAPA/AwULAhMFCwMDBgQKAgwFDDkABQoKAgsFDDkABQoFCgAGBAIMBQwCCwUMBQwABgQCDwUKCwIWAgYABgECAwUKCgIXBQw5AAUKBQoKAhcFDBEABQoFCgIDBQoFCgUKBgQCDQUMCwIQAgYBAhEFDAIEBQwFDAIEBQwFDAUMBgQCDgUMCQMhDgICCgoCDwUKBQwFDAaBAg0FDAIOBQwFDAAAHwAABQUIIQN0bXAFCwQAAAkDKQ4CCgIMBQwRAAUKAQMAAAAAAADwPwMFCwAGBAIhBQsJAykOAwkDHQ4CAiEFCwIUBQsDCQMdDgICIQULAhUFCwMBAwAAAAAAAPA/AwULBQsGBAIdBQwJAyoOAwkDHQ4CAiEFCwIbBQsDCQMdDgICIQULAhwFCwMKAgwFDDkABQoFDAUMCwIZAgaDCgIdBQwRAAUKAhoFCgUKAAAGBAIGBQwCHQUMBQwAASAAAAUCCwYOAhgCBgkKAg0FDAwAAwED/Knx0k1iUD8DAgIMAAAABgQCBwUMAg0FDAUMAA"
h3d_shader_BaseMesh.SRC = "HXSLE2gzZC5zaGFkZXIuQmFzZU1lc2gXAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQVjb2xvcgUMAgAAJg1zcGVjdWxhclBvd2VyAwIAAQcAAAAAAAAAAAAAAAAAAFlAJw5zcGVjdWxhckFtb3VudAMCAAEHAAAAAAAAAAAAAAAAAAAkQCgNc3BlY3VsYXJDb2xvcgULAgAAKQhfX2luaXRfXw4GAAAqEF9faW5pdF9fZnJhZ21lbnQOBgAAKwZ2ZXJ0ZXgOBgAALAhmcmFnbWVudA4GAAAEAikAAAULBgQCGgULAhIFCwULBgQCGwULBgECGgULCQM0DgECDwcIBQsFCwYEAh4FDAYBCQMqDgICGwULAQMAAAAAAADwPwMFDAIHBwUMBQwGBAIdBQsJAx8OAQQGAQITBQsJAzIOAQIPBwYFCwULBQsFCwYEAgsFCwkDHw4BBAYDAgQFCwIbBQsFCwULBQsFCwYEAh8FDAIlBQwFDAYEAiIDAiYDAwYEAiMFCwYBAigFCwInAwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCJAMGAgkDGw4BBgMCGwULAgQFCwULAwIKAwMDAAIqAAAFBQYEAh0FCwkDHw4BAh0FCwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCIgMCJgMDBgQCIwULBgECKAULAicDBQsFCwAAKwAABQIGBAIVBQwGAQIeBQwJAyoOBAEDAAAAAAAA8D8DAgUDAQMAAAAAAADwPwMBAwAAAAAAAPA/AwUMBQwFDAYEAhwFCwIbBQsFCwABLAAABQQGBAIWBQwCHwUMBQwGBAIXAwIgAwMGBAIYBQsCHQULBQsGBAIZAwIkAwMA"
h3d_shader_Blur.SRC = "HXSLD2gzZC5zaGFkZXIuQmx1choBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoVY2FtZXJhSW52ZXJzZVZpZXdQcm9qBwIAAAsHdGV4dHVyZQoCAAAMDGRlcHRoVGV4dHVyZQoCAAANB1F1YWxpdHkBAgABAAAAAAAOB2lzRGVwdGgCAgABAAAAAAAPBnZhbHVlcw8DDQIAABAHb2Zmc2V0cw8DDQIAABEFcGl4ZWwFCgIAABINaGFzRml4ZWRDb2xvcgICAAEAAAAAABMQc21vb3RoRml4ZWRDb2xvcgICAAEAAAAAABQKZml4ZWRDb2xvcgUMAgAAFRBpc0RlcHRoRGVwZW5kYW50AgIAAQAAAAAAFgloYXNOb3JtYWwCAgABAAAAAAAXDW5vcm1hbFRleHR1cmUKAgAAGAZpc0N1YmUCAgABAAAAAAAZC2N1YmVUZXh0dXJlDAIAABoHY3ViZURpcgYCAAAbCF9faW5pdF9fDgYAABwGdmVydGV4DgYAAB0IZnJhZ21lbnQOBgAAHgtnZXRQb3NpdGlvbg4GAAAEAhsAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAcAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEdAAAFAgsCFQIFBggfBHBjdXIFCwQAAAkCHg4BAgMFCgULAAggBGNjdXIFDAQAAAkDIQ4CAgsKAgMFCgUMAAghBWNvbG9yBQwEAAAJAyoOBAEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwEDAAAAAAAAAAADBQwACCIEbmN1cgULBAAACQM5DgEJAyEOAgIXCgIDBQoFDAULABUGdW5yb2xsAA4jAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUICCQCdXYFCgQAAAYAAgMFCgYBAhEFChECEA8DDQsGCQIjAQECAAAAAAECBwMCIwEBAiMBAQMFCgUKAAglAWMFDAQAAAkDIQ4CAgsKAiQFCgUMAAgmAXAFCwQAAAkCHg4BAiQFCgULAAgnAWQDBAAACQMdDgIEBgMCJgULAh8FCwULBQsGAwImBQsCHwULBQsDAAgoAW4FCwQAAAkDOQ4BCQMhDgICFwoCJAUKBQwFCwAGBAIlBQwJAxgOAwIgBQwCJQUMCQMdDgICIgULAigFCwMFDAUMBgQCJQUMCQMYDgMCJQUMAiAFDAkDFQ4CBAYBCQMWDgIEBgMCJwMBA/yp8dJNYlA/AwMDAQMAAAAAAAAAAAMDAQMAAAAAAGr4QAMDAwEDAAAAAAAA8D8DAwUMBQwGgAIhBQwGAQIlBQwRAg8PAw0LBgkCIwEBAgAAAAABAgcDAiMBAQIjAQEDBQwFDAAAAAYEAggFDAIhBQwFDAALAg4CBQMIKQN2YWwDBAAAAQMAAAAAAAAAAAMAFQZ1bnJvbGwADioBaQEEAAAGFQYABwMCDQEBAQIBAAAAAQECDQEPAQAABQELAhgCBoACKQMGAQkDNw4BCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwDEQIPDwMNCwYJAioBAQIAAAAAAQIHAwIqAQECKgEBAwMDBoACKQMGAQkDNw4BCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFDAMRAg8PAw0LBgkCKgEBAgAAAAABAgcDAioBAQIqAQEDAwMAAAAABgQCCAUMCQM2DgEJAxUOAgIpAwEDyxpQyv//7z8DAwUMBQwABQMIKwVjb2xvcgUMBAAACQMqDgQBAwAAAAAAAAAAAwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMABUGdW5yb2xsAA4sAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUBCwIYAgaAAisFDAYBCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwRAg8PAw0LBgkCLAEBAgAAAAABAgcDAiwBAQIsAQEDBQwFDAaAAisFDAYBCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFDBECDw8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFDAUMAAAAAAYEAggFDAIrBQwFDAAAAAsCEgIFAgsCEwIGgQoCCAUMDAADCgIUBQwMAAMDBgQKAggFDAwAAwYBCgIUBQwMAAMJAyYOAQYHCgIIBQwMAAMBAwAAAAAAAAAAAwIDAwMABgQKAggFDJIABQsGAQoCFAUMkgAFCwoCCAUMDAADBQsFCwAAAAADHgEtAnV2BQoEAAAFCwUECC4FZGVwdGgDBAAACQM3DgEJAyEOAgIMCgItBQoFDAMACC8EdGVtcAUMBAAABgEJAyoOAwkDOw4BAi0FCgUKAi4DAQMAAAAAAADwPwMFDAIKBwUMAAgwCG9yaWdpbldTBQsEAAAGAgoCLwUMkgAFCwoCLwUMDAADBQsADQIwBQsAAA"
h3d_shader_ColorAdd.SRC = "HXSLE2gzZC5zaGFkZXIuQ29sb3JBZGQDAQpwaXhlbENvbG9yBQwEAAACBWNvbG9yBQsCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGgAoCAQUMkgAFCwICBQsFCwA"
h3d_shader_ColorKey.SRC = "HXSLE2gzZC5zaGFkZXIuQ29sb3JLZXkDAQhjb2xvcktleQUMAgAAAgx0ZXh0dXJlQ29sb3IFDAQAAAMIZnJhZ21lbnQOBgAAAQEDAAAFAggEBWNkaWZmBQwEAAAGAwICBQwCAQUMBQwACwYJCQMdDgICBAUMAgQFDAMBA/Fo44i1+OQ+AwIMAAAAAA"
h3d_shader_ColorMatrix.SRC = "HXSLFmgzZC5zaGFkZXIuQ29sb3JNYXRyaXgDAQpwaXhlbENvbG9yBQwEAAACBm1hdHJpeAcCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGBAIBBQwJAyoOAgoEBgEJAyoOAgoCAQUMkgAFCwEDAAAAAAAA8D8DBQwCAgcFDAUMkgAFCwoEBgECAQUMAgIHBQwFDAwAAwUMBQwA"
h3d_shader_DirShadow.SRC = "HXSLFGgzZC5zaGFkZXIuRGlyU2hhZG93EgEGZW5hYmxlAgIAAQAAAAAAAgdVU0VfRVNNAgIAAQAAAAAAAwtzaGFkb3dQb3dlcgMCAAAEB1VTRV9QQ0YCAgABAAAAAAAFCnBjZlF1YWxpdHkBAgABAAAAAAAGCHBjZlNjYWxlAwIAAAcJc2hhZG93UmVzBQoCAAAICXNoYWRvd01hcBEBAgAACQpzaGFkb3dQcm9qCAIAAAoKc2hhZG93QmlhcwMCAAALE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAwGc2hhZG93AwQAAA0JZGlyU2hhZG93AwQAAA4OcG9pc3NvbkRpc2tMb3cPBQwABAIAAA8PcG9pc3NvbkRpc2tIaWdoDwUMAAwCAAAQE3BvaXNzb25EaXNrVmVyeUhpZ2gPBQwAQAIAABEEcmFuZA4GAAASCGZyYWdtZW50DgYAAAIDEQETAXYDBAAAAwUCCBQCZHADBAAACQMdDgIJAyoOAQITAwUMCQMqDgQBA18pyxDH+ilAAwED9P3UeOmOU0ADAQOiRbbz/ZRGQAMBA1CNl24Sq1dAAwUMAwANCQMTDgEGAQkDAg4BAhQDAwEDUPwYc9Fd5UADAwMAAAESAAAFAgsCAQIFAQsCBAIFBwYEAgwDAQMAAAAAAADwPwMDCBUJdGV4ZWxTaXplBQoEAAAGAgEDAAAAAAAA8D8DAgcFCgUKAAgWCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACBcIc2hhZG93VXYFCgQAAAkDOg4BCgIWBQsRAAUKBQoACBgEek1heAMEAAAJAzUOAQoCFgULCAADAwAIGQNyb3QDBAAABgEGAQkCEQ4BBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwEDH4XrUbgeCUADAwEDAAAAAAAAAEADAwATBAIFAQEDAQECAQAAAAEFAggaDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAABBAAwMADhsBaQEEAAAGFQECAAAAAAEBAgQAAAABDwEAAAUECBwGb2Zmc2V0BQoEAAAGAQYBChECDg8FDAAEAhsBBQwRAAUKAhUFCgUKAgYDBQoABgQCHAUKCQMoDgIGAwYBCQMDDgECGQMDCgIcBQoAAAMDBgEJAwIOAQIZAwMKAhwFCgQAAwMDBgAGAQkDAw4BAhkDAwoCHAUKBAADAwYBCQMCDgECGQMDCgIcBQoAAAMDAwUKBQoIHQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCHAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAh0DAgaDAgwDAhoDAwAAAAAAAQECAgAAAAEFAggeDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAChAAwMADh8BaQEEAAAGFQECAAAAAAEBAgwAAAABDwEAAAUECCAGb2Zmc2V0BQoEAAAGAQYBChECDw8FDAAMAh8BBQwRAAUKAhUFCgUKAgYDBQoABgQCIAUKCQMoDgIGAwYBCQMDDgECGQMDCgIgBQoAAAMDBgEJAwIOAQIZAwMKAiAFCgQAAwMDBgAGAQkDAw4BAhkDAwoCIAUKBAADAwYBCQMCDgECGQMDCgIgBQoAAAMDAwUKBQoIIQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCIAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiEDAgaDAgwDAh4DAwAAAAAAAQECAwAAAAEFAggiDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAFBAAwMADiMBaQEEAAAGFQECAAAAAAEBAkAAAAABDwEAAAUECCQGb2Zmc2V0BQoEAAAGAQYBChECEA8FDABAAiMBBQwRAAUKAhUFCgUKAgYDBQoABgQCJAUKCQMoDgIGAwYBCQMDDgECGQMDCgIkBQoAAAMDBgEJAwIOAQIZAwMKAiQFCgQAAwMDBgAGAQkDAw4BAhkDAwoCJAUKBAADAwYBCQMCDgECGQMDCgIkBQoAAAMDAwUKBQoIJQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCJAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiUDAgaDAgwDAiIDAwAAAAAAAAAACwICAgUFCCYJc2hhZG93UG9zBQsEAAAGAQILBQsCCQgFCwAIJwVkZXB0aAMEAAAJAz8OAgIIEQEJAzoOAQoCJgULEQAFCgUKAwAIKAR6TWF4AwQAAAkDNQ4BCgImBQsIAAMDAAgpBWRlbHRhAwQAAAYDCQMVDgIEBgACJwMCCgMDAwIoAwMCKAMDAAYEAgwDCQM1DgEJAwkOAQYBAgMDAikDAwMDAwAFBAgqCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACCsIc2hhZG93VXYFCgQAAAkDOg4BCgIqBQsRAAUKBQoACCwFZGVwdGgDBAAACQM/DgICCBEBCgIrBQoRAAUKAwAGBAIMAwsGBwYDCgIqBQsIAAMCCgMDAiwDAgEDAAAAAAAAAAADAQMAAAAAAADwPwMDAwAAAAAAAAYEAg0DAgwDAwA"
h3d_shader_GenTexture.SRC = "HXSLFWgzZC5zaGFkZXIuR2VuVGV4dHVyZQoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEbW9kZQECAAEAAAAAAAsFY29sb3IFDAIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFARMEAgoBAQEBAQIAAAAAAQUBBgQCCAUMCwYHCQMbDgEKAgYFDBEABQoDAQMAAAAAAADwPwMCCQMqDgEBAwAAAAAAAAAAAwUMAgsFDAUMBQwAAAAA"
h3d_shader_LineShader.SRC = "HXSLFWgzZC5zaGFkZXIuTGluZVNoYWRlcgwBBmNhbWVyYQ0BAwIEdmlldwcAAQADBHByb2oHAAEABAh2aWV3UHJvagcAAQAAAAAFBmdsb2JhbA0CAgYJcGl4ZWxTaXplBQoABQAHCW1vZGVsVmlldwcABQEDAAAACAVpbnB1dA0DAwkIcG9zaXRpb24FCwEIAAoGbm9ybWFsBQsBCAALAnV2BQoBCAABAAAMBm91dHB1dA0EAQ0IcG9zaXRpb24FDAQMAAQAAA4RdHJhbnNmb3JtZWROb3JtYWwFCwQAAA8TdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAEBFwcm9qZWN0ZWRQb3NpdGlvbgUMBAAAEQtsZW5ndGhTY2FsZQMCAAASBXdpZHRoAwIAABMEcGRpcgUMBAAAFAhfX2luaXRfXw4GAAAVBnZlcnRleA4GAAACAhQAAAUBBQUIFgNkaXIFCwQAAAYBAgoFCwkDMg4BAgcHBgULAAYEAhMFDAYBCQMqDgIGAQIWBQsJAzIOAQICBwYFCwEDAAAAAAAA8D8DBQwCAwcFDAUMBoEKAhMFDBEABQoGAgEDAAAAAAAA8D8DCQMNDgEGAAYBCgITBQwAAAMKAhMFDAAAAwMGAQoCEwUMBAADCgITBQwEAAMDAwMDBQoGgAIPBQsGAQYBAhYFCwoCCwUKAAADBQsCEQMFCwULBgQCDgULCQMfDgECFgULBQsFCwAAABUAAAUBBoAKAhAFDBEABQoGAQYBBgEGAQQGAQoCEwUMBQAFCgkDKA4CAQMAAAAAAADwPwMBAwAAAAAAAPC/AwUKBQoFCgQGAwoCCwUKBAADAQMAAAAAAADgPwMDAwUKCgIQBQwIAAMFCgIGBQoFCgISAwUKBQoA"
h3d_shader_MinMaxShader.SRC = "HXSLF2gzZC5zaGFkZXIuTWluTWF4U2hhZGVyCwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgR0ZXhBCgIAAAsEdGV4QgoCAAAMBWlzTWF4AgIAAQAAAAAADQhfX2luaXRfXw4GAAAOBnZlcnRleA4GAAAPCGZyYWdtZW50DgYAAAMCDQAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAA4AAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ8AAAUDCBABYQUMBAAACQMhDgICCgoCCQUKBQwACBEBYgUMBAAACQMhDgICCwoCCQUKBQwABgQCCAUMCwIMAgkDFg4CAhAFDAIRBQwFDAkDFQ4CAhAFDAIRBQwFDAUMBQwA"
h3d_shader_CubeMinMaxShader.SRC = "HXSLG2gzZC5zaGFkZXIuQ3ViZU1pbk1heFNoYWRlcgwBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEdGV4QQwCAAALBHRleEIMAgAADAVpc01heAICAAEAAAAAAA0DbWF0BgIAAA4IX19pbml0X18OBgAADwZ2ZXJ0ZXgOBgAAEAhmcmFnbWVudA4GAAADAg4AAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAPAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEQAAAFBQgRAnV2BQoEAAAGAwYBAgkFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAAgSA2RpcgULBAAABgEJAykOAgIRBQoBAwAAAAAAAPA/AwULAg0GBQsACBMBYQUMBAAACQMhDgICCgwCEgULBQwACBQBYgUMBAAACQMhDgICCwwCEgULBQwABgQCCAUMCwIMAgkDFg4CAhMFDAIUBQwFDAkDFQ4CAhMFDAIUBQwFDAUMBQwA"
h3d_shader_NormalMap.SRC = "HXSLFGgzZC5zaGFkZXIuTm9ybWFsTWFwCgEGY2FtZXJhDQECAghwb3NpdGlvbgULAAEAAwNkaXIFCwMBAAAAAAQGZ2xvYmFsDQIBBQltb2RlbFZpZXcHAAQBAwAAAAYFaW5wdXQNAwIHBm5vcm1hbAULAQYACAd0YW5nZW50BQsBBgABAAAJB3RleHR1cmUKAgAACgxjYWxjdWxhdGVkVVYFCgQAAAsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAADBF0cmFuc2Zvcm1lZE5vcm1hbAULBAAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAMAAA4OX19pbml0X192ZXJ0ZXgOBgAADwhmcmFnbWVudA4GAAACAg4AAAUBBgQCDQUMCQMqDgIGAQIIBQsJAzIOAQIFBwYFCwsGBwkDHQ4CAggFCwIIBQsDAQMAAAAAAADgPwMCAQMAAAAAAADwPwMBAwAAAAAAAPC/AwMFDAUMAAEPAAAFBQgQAW4FCwQAAAIMBQsACBECbmYFCwQAAAkDOQ4BCQMhDgICCQoCCgUKBQwFCwAIEgR0YW5YBQsEAAAJAx8OAQoCDQUMkgAFCwULAAgTBHRhblkFCwQAAAYBCQMeDgICEAULAhIFCwULBwMKAg0FDAwAAwMFCwAGBAIMBQsJAx8OAQQGAAYABgEKAhEFCwAAAwISBQsFCwYBCgIRBQsEAAMCEwULBQsFCwYBCgIRBQsIAAMCEAULBQsFCwULBQsFCwA"
h3d_shader_Shadow.SRC = "HXSLEWgzZC5zaGFkZXIuU2hhZG93BgEGc2hhZG93DQEFAgNtYXARAQABAAMEcHJvaggAAQAEBWNvbG9yBQsAAQAFBXBvd2VyAwABAAYEYmlhcwMAAQAAAAAHCnBpeGVsQ29sb3IFDAQAAAgTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAACRhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAoJc2hhZG93UG9zBQsEAAEBCwhmcmFnbWVudA4GAAABAQsAAAUGCAwJc2hhZG93UG9zBQsEAAAGAQIJBQsCAwgFCwAIDQVkZXB0aAMEAAAJAz8OAgICEQEJAzoOAQoCDAULEQAFCgUKAwAIDgR6TWF4AwQAAAkDNQ4BCgIMBQsIAAMDAAgPBWRlbHRhAwQAAAYDCQMVDgIEBgACDQMCBgMDAwIOAwMCDgMDAAgQBXNoYWRlAwQAAAkDNQ4BCQMJDgEGAQIFAwIPAwMDAwAGgQoCBwUMkgAFCwYABgEEBgMBAwAAAAAAAPA/AwIQAwMDCgIEBQuSAAULBQsCEAMFCwULAA"
h3d_shader_SignedDistanceField.SRC = "HXSLHmgzZC5zaGFkZXIuU2lnbmVkRGlzdGFuY2VGaWVsZA4BBWlucHV0DQEDAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEABAVjb2xvcgUMAQEAAQAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAIBHRpbWUDAAAACQ5zcHJpdGVQb3NpdGlvbgUMBAAAChBhYnNvbHV0ZVBvc2l0aW9uBQwEAAALCnBpeGVsQ29sb3IFDAQAAAwMdGV4dHVyZUNvbG9yBQwEAAANDGNhbGN1bGF0ZWRVVgUKAwAADg5vdXRwdXRQb3NpdGlvbgUMBAAADwdjaGFubmVsAQIAAQAAAAAAEAthbHBoYUN1dG9mZgMCAAARCXNtb290aGluZwMCAAASBm1lZGlhbg4GAAATCGZyYWdtZW50DgYAAAIDEgMUAXIDBAAAFQFnAwQAABYBYgMEAAADBQENCQMWDgIJAxUOAgIUAwIVAwMJAxUOAgkDFg4CAhQDAhUDAwIWAwMDAAABEwAABQQIFw10ZXh0dXJlU2FtcGxlBQwEAAACDAUMAAgYCGRpc3RhbmNlAwQAAAAABgQCGAMLBgUCDwEBAgAAAAABAgoCFwUMAAADCwYFAg8BAQIBAAAAAQIKAhcFDAQAAwsGBQIPAQECAgAAAAECCgIXBQwIAAMLBgUCDwEBAgMAAAABAgoCFwUMDAADCQISDgMKAhcFDAAAAwoCFwUMBAADCgIXBQwIAAMDAwMDAwMGBAIMBQwJAyoOBAEDAAAAAAAA8D8DAQMAAAAAAADwPwMBAwAAAAAAAPA/AwkDGg4DBgMCEAMCEQMDBgACEAMCEQMDAhgDAwUMBQwA"
h3d_shader_SkinBase.SRC = "HXSLE2gzZC5zaGFkZXIuU2tpbkJhc2UFARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIAA"
h3d_shader_Skin.SRC = "HXSLD2gzZC5zaGFkZXIuU2tpbggBEHJlbGF0aXZlUG9zaXRpb24FCwQAAAITdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAAxF0cmFuc2Zvcm1lZE5vcm1hbAULBAAABAhNYXhCb25lcwECAAEAAAAAAAUNYm9uZXNNYXRyaXhlcw8IBAIAAQgGBWlucHV0DQEEBwhwb3NpdGlvbgULAQYACAZub3JtYWwFCwEGAAkHd2VpZ2h0cwULAQYACgdpbmRleGVzCQQAAAABBgABAAALEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADAZ2ZXJ0ZXgOBgAAAQAMAAAFAgYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQJAyUOAQoCCgkEAAAAAAADAQgFCwULCgIJBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAkDJQ4BCgIKCQQAAAAEAAMBCAULBQsKAgkFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQJAyUOAQoCCgkEAAAACAADAQgFCwULCgIJBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAkDJQ4BCgIKCQQAAAAAAAMBCAYFCwULCgIJBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECQMlDgEKAgoJBAAAAAQAAwEIBgULBQsKAgkFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAkDJQ4BCgIKCQQAAAAIAAMBCAYFCwULCgIJBQsIAAMFCwULBQsFCwA"
h3d_shader_SkinTangent.SRC = "HXSLFmgzZC5zaGFkZXIuU2tpblRhbmdlbnQIARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIBgVpbnB1dA0BBQcIcG9zaXRpb24FCwEGAAgGbm9ybWFsBQsBBgAJB3RhbmdlbnQFCwEGAAoHd2VpZ2h0cwULAQYACwdpbmRleGVzCQQAAAABBgABAAAMEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADQZ2ZXJ0ZXgOBgAAAQANAAAFAwYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQJAyUOAQoCCwkEAAAAAAADAQgFCwULCgIKBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAkDJQ4BCgILCQQAAAAEAAMBCAULBQsKAgoFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQJAyUOAQoCCwkEAAAACAADAQgFCwULCgIKBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAkDJQ4BCgILCQQAAAAAAAMBCAYFCwULCgIKBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECQMlDgEKAgsJBAAAAAQAAwEIBgULBQsKAgoFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAkDJQ4BCgILCQQAAAAIAAMBCAYFCwULCgIKBQsIAAMFCwULBQsFCwYEAgwFDAkDKg4CCQMfDgEGAAYABgEEBgEKAgkFC5IABQsJAzIOARECBQ8IBAkDJQ4BCgILCQQAAAAAAAMBCAYFCwULCgIKBQsAAAMFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQJAyUOAQoCCwkEAAAABAADAQgGBQsFCwoCCgULBAADBQsFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQJAyUOAQoCCwkEAAAACAADAQgGBQsFCwoCCgULCAADBQsFCwULCgIMBQwMAAMFDAUMAA"
h3d_shader_SpecularTexture.SRC = "HXSLGmgzZC5zaGFkZXIuU3BlY3VsYXJUZXh0dXJlBAEHdGV4dHVyZQoCAAACDGNhbGN1bGF0ZWRVVgUKBAAAAwlzcGVjQ29sb3IFCwQAAAQIZnJhZ21lbnQOBgAAAQEEAAAFAQaBAgMFCwoJAyEOAgIBCgICBQoFDJIABQsFCwA"
h3d_shader_Texture.SRC = "HXSLEmgzZC5zaGFkZXIuVGV4dHVyZQsBBWlucHV0DQEBAgJ1dgUKAQEAAQAAAwhhZGRpdGl2ZQICAAEAAAAAAAQJa2lsbEFscGhhAgIAAQAAAAAABQ1zcGVjdWxhckFscGhhAgIAAQAAAAAABhJraWxsQWxwaGFUaHJlc2hvbGQDAgABBwAAAAAAAAAAAAAAAAAA8D8HB3RleHR1cmUKAgAACAxjYWxjdWxhdGVkVVYFCgQAAAkKcGl4ZWxDb2xvcgUMBAAACglzcGVjQ29sb3IFCwQAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAAAgALAAAFAQYEAggFCgICBQoFCgABDAAABQQIDQFjBQwEAAAJAyEOAgIHCgIIBQoFDAALBg4CBAIGCQYDCgINBQwMAAMCBgMDAQMAAAAAAAAAAAMCAgwAAAALAgMCBoACCQUMAg0FDAUMBoECCQUMAg0FDAUMAAsCBQIGgQIKBQsKAg0FDP4ABQsFCwAAAA"
h3d_shader_UVDelta.SRC = "HXSLEmgzZC5zaGFkZXIuVVZEZWx0YQQBB3V2RGVsdGEFCgIAAAIHdXZTY2FsZQUKAgAAAwxjYWxjdWxhdGVkVVYFCgQAAAQGdmVydGV4DgYAAAEABAAABQEGBAIDBQoGAAYBAgMFCgICBQoFCgIBBQoFCgUKAA"
h3d_shader_VertexColorAlpha.SRC = "HXSLG2gzZC5zaGFkZXIuVmVydGV4Q29sb3JBbHBoYQQBBWlucHV0DQEBAgVjb2xvcgUMAQEAAQAAAwpwaXhlbENvbG9yBQwEAAAECGFkZGl0aXZlAgIAAQAAAAAABQhmcmFnbWVudA4GAAABAQUAAAUBCwIEAgaAAgMFDAICBQwFDAaBAgMFDAICBQwFDAAA"
h3d_shader_VolumeDecal.SRC = "HXSLFmgzZC5zaGFkZXIuVm9sdW1lRGVjYWwYAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQhkZXB0aE1hcBEBAAAAJgVzY2FsZQUKAgAAJwZub3JtYWwFCwIAACgHdGFuZ2VudAULAgAAKQppc0NlbnRlcmVkAgIAAQAAAAAAKgxjYWxjdWxhdGVkVVYFCgQAACsSdHJhbnNmb3JtZWRUYW5nZW50BQwEAAAsDl9faW5pdF9fdmVydGV4DgYAAC0IZnJhZ21lbnQOBgAAAgIsAAAFAgYEAh0FCwkDHw4BBAYBAicFCwkDMg4BAg8HBgULBQsFCwULBgQCKwUMCQMqDgIJAx8OAQQGAQIoBQsJAzIOAQIPBwYFCwULBQsBAwAAAAAAAPA/AwUMBQwAAS0AAAUJCC4GbWF0cml4BwQAAAYBAggHAhAHBwAILwlzY3JlZW5Qb3MFCgQAAAYCCgIeBQwRAAUKCgIeBQwMAAMFCgAIMANydXYFDAQAAAkDKg4DAi8FCgkDPw4CAiURAQkDOg4BAi8FCgUKAwEDAAAAAAAA8D8DBQwACDEEd3BvcwUMBAAABgECMAUMAi4HBQwACDIEcHBvcwUMBAAABgECMAUMAggHBQwABgQCHAULBgIKAjIFDJIABQsKAjIFDAwAAwULBQsGBAIqBQoGAQImBQoEBgIKAjEFDBEABQoKAjEFDAwAAwUKBQoFCgUKCwIpAgaAAioFCgEDAAAAAAAA4D8DBQoAAAsGCQkDFQ4CCQMVDgIKAioFCgAAAwoCKgUKBAADAwkDFQ4CBgMBAwAAAAAAAPA/AwoCKgUKAAADAwYDAQMAAAAAAADwPwMKAioFCgQAAwMDAwEDAAAAAAAAAAADAgwAAAAA"
haxe_MainLoop.mutex = sys_thread_Mutex()
haxe_MainLoop.mainThread = sys_thread__Thread_HxThread.current()
haxe_Serializer.USE_CACHE = False
haxe_Serializer.USE_ENUM_INDEX = False
haxe_Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"
haxe_Serializer.BASE64_CODES = None
haxe_Unserializer.DEFAULT_RESOLVER = haxe__Unserializer_DefaultResolver()
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"
haxe_Unserializer.CODES = None
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS)
def _hx_init_haxe_io_FPHelper_i64tmp():
    def _hx_local_0():
        this1 = haxe__Int64____Int64(0,0)
        return this1
    return _hx_local_0()
haxe_io_FPHelper.i64tmp = _hx_init_haxe_io_FPHelper_i64tmp()
def _hx_init_haxe_xml_Parser_escapes():
    def _hx_local_0():
        h = haxe_ds_StringMap()
        h.h["lt"] = "<"
        h.h["gt"] = ">"
        h.h["amp"] = "&"
        h.h["quot"] = "\""
        h.h["apos"] = "'"
        return h
    return _hx_local_0()
haxe_xml_Parser.escapes = _hx_init_haxe_xml_Parser_escapes()
haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1]
haxe_zip_InflateImpl.LEN_BASE_VAL_TBL = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]
haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1]
haxe_zip_InflateImpl.DIST_BASE_VAL_TBL = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]
haxe_zip_InflateImpl.CODE_LENGTHS_POS = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
haxe_zip_InflateImpl.FIXED_HUFFMAN = None
hxd_Charset.ASCII = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
hxd_Charset.LATIN1 = "¡¢£¤¥¦§¨©ª«¬-®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿœæŒÆ€"
hxd_Charset.CYRILLIC = "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя—"
hxd_Charset.POLISH = "ĄĆĘŁŃÓŚŹŻąćęłńóśźż"
hxd_Charset.TURKISH = "ÂÇĞIİÎÖŞÜÛâçğıİîöşüû"
hxd_Charset.JP_KANA = "　あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをんがぎぐげござじずぜぞだぢづでどばびぶべぼぱぴぷぺぽゃゅょアイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲンガギグゲゴザジズゼゾダヂヅデドバビブベボパピプペポヴャぇっッュョァィゥェォ・ー「」、。『』“”！：？％＆（）－０１２３４５６７８９"
hxd_Charset.UNICODE_SPECIALS = "�□"
hxd_Charset.DEFAULT_CHARS = (HxOverrides.stringOrNull(hxd_Charset.ASCII) + HxOverrides.stringOrNull(hxd_Charset.LATIN1))
def _hx_init_hxd_Charset_complementChars():
    def _hx_local_0():
        _hx_str = "ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻"
        _g = haxe_ds_IntMap()
        _g1 = 0
        _g2 = len(_hx_str)
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.set(HxString.charCodeAt(_hx_str,i),True)
        return _g
    return _hx_local_0()
hxd_Charset.complementChars = _hx_init_hxd_Charset_complementChars()
hxd_Key.BACKSPACE = 8
hxd_Key.TAB = 9
hxd_Key.ENTER = 13
hxd_Key.SHIFT = 16
hxd_Key.CTRL = 17
hxd_Key.ALT = 18
hxd_Key.ESCAPE = 27
hxd_Key.SPACE = 32
hxd_Key.PGUP = 33
hxd_Key.PGDOWN = 34
hxd_Key.END = 35
hxd_Key.HOME = 36
hxd_Key.LEFT = 37
hxd_Key.UP = 38
hxd_Key.RIGHT = 39
hxd_Key.DOWN = 40
hxd_Key.INSERT = 45
hxd_Key.DELETE = 46
hxd_Key.QWERTY_EQUALS = 187
hxd_Key.QWERTY_MINUS = 189
hxd_Key.QWERTY_TILDE = 192
hxd_Key.QWERTY_BRACKET_LEFT = 219
hxd_Key.QWERTY_BRACKET_RIGHT = 221
hxd_Key.QWERTY_SEMICOLON = 186
hxd_Key.QWERTY_QUOTE = 222
hxd_Key.QWERTY_BACKSLASH = 220
hxd_Key.QWERTY_COMMA = 188
hxd_Key.QWERTY_PERIOD = 190
hxd_Key.QWERTY_SLASH = 191
hxd_Key.INTL_BACKSLASH = 226
hxd_Key.LEFT_WINDOW_KEY = 91
hxd_Key.RIGHT_WINDOW_KEY = 92
hxd_Key.CONTEXT_MENU = 93
hxd_Key.PAUSE_BREAK = 19
hxd_Key.CAPS_LOCK = 20
hxd_Key.NUM_LOCK = 144
hxd_Key.SCROLL_LOCK = 145
hxd_Key.NUMBER_0 = 48
hxd_Key.NUMBER_1 = 49
hxd_Key.NUMBER_2 = 50
hxd_Key.NUMBER_3 = 51
hxd_Key.NUMBER_4 = 52
hxd_Key.NUMBER_5 = 53
hxd_Key.NUMBER_6 = 54
hxd_Key.NUMBER_7 = 55
hxd_Key.NUMBER_8 = 56
hxd_Key.NUMBER_9 = 57
hxd_Key.NUMPAD_0 = 96
hxd_Key.NUMPAD_1 = 97
hxd_Key.NUMPAD_2 = 98
hxd_Key.NUMPAD_3 = 99
hxd_Key.NUMPAD_4 = 100
hxd_Key.NUMPAD_5 = 101
hxd_Key.NUMPAD_6 = 102
hxd_Key.NUMPAD_7 = 103
hxd_Key.NUMPAD_8 = 104
hxd_Key.NUMPAD_9 = 105
hxd_Key.A = 65
hxd_Key.B = 66
hxd_Key.C = 67
hxd_Key.D = 68
hxd_Key.E = 69
hxd_Key.F = 70
hxd_Key.G = 71
hxd_Key.H = 72
hxd_Key.I = 73
hxd_Key.J = 74
hxd_Key.K = 75
hxd_Key.L = 76
hxd_Key.M = 77
hxd_Key.N = 78
hxd_Key.O = 79
hxd_Key.P = 80
hxd_Key.Q = 81
hxd_Key.R = 82
hxd_Key.S = 83
hxd_Key.T = 84
hxd_Key.U = 85
hxd_Key.V = 86
hxd_Key.W = 87
hxd_Key.X = 88
hxd_Key.Y = 89
hxd_Key.Z = 90
hxd_Key.F1 = 112
hxd_Key.F2 = 113
hxd_Key.F3 = 114
hxd_Key.F4 = 115
hxd_Key.F5 = 116
hxd_Key.F6 = 117
hxd_Key.F7 = 118
hxd_Key.F8 = 119
hxd_Key.F9 = 120
hxd_Key.F10 = 121
hxd_Key.F11 = 122
hxd_Key.F12 = 123
hxd_Key.F13 = 124
hxd_Key.F14 = 125
hxd_Key.F15 = 126
hxd_Key.F16 = 127
hxd_Key.F17 = 128
hxd_Key.F18 = 129
hxd_Key.F19 = 130
hxd_Key.F20 = 131
hxd_Key.F21 = 132
hxd_Key.F22 = 133
hxd_Key.F23 = 134
hxd_Key.F24 = 135
hxd_Key.NUMPAD_MULT = 106
hxd_Key.NUMPAD_ADD = 107
hxd_Key.NUMPAD_ENTER = 108
hxd_Key.NUMPAD_SUB = 109
hxd_Key.NUMPAD_DOT = 110
hxd_Key.NUMPAD_DIV = 111
hxd_Key.MOUSE_LEFT = 0
hxd_Key.MOUSE_RIGHT = 1
hxd_Key.MOUSE_MIDDLE = 2
hxd_Key.MOUSE_BACK = 3
hxd_Key.MOUSE_FORWARD = 4
hxd_Key.MOUSE_WHEEL_UP = 5
hxd_Key.MOUSE_WHEEL_DOWN = 6
hxd_Key.LOC_LEFT = 256
hxd_Key.LOC_RIGHT = 512
hxd_Key.LSHIFT = 272
hxd_Key.RSHIFT = 528
hxd_Key.LCTRL = 273
hxd_Key.RCTRL = 529
hxd_Key.LALT = 274
hxd_Key.RALT = 530
hxd_Key.initDone = False
hxd_Key.keyPressed = []
hxd_Key.ALLOW_KEY_REPEAT = False
hxd_Math.PI = 3.14159265358979323
hxd_Math.EPSILON = 1e-10
hxd__Pixels_Channel_Impl_.R = 0
hxd__Pixels_Channel_Impl_.G = 1
hxd__Pixels_Channel_Impl_.B = 2
hxd__Pixels_Channel_Impl_.A = 3
hxd_System.setCursor = hxd_System.setNativeCursor
hxd_Timer.wantedFPS = 60.
hxd_Timer.maxDeltaTime = 0.5
hxd_Timer.smoothFactor = 0.95
hxd_Timer.lastTimeStamp = python_lib_Timeit.default_timer()
hxd_Timer.elapsedTime = 0.
hxd_Timer.frameCount = 0
hxd_Timer.dt = (1 / hxd_Timer.wantedFPS)
hxd_Timer.currentDT = (1 / hxd_Timer.wantedFPS)
hxd_Window.inst = None
hxd_clipper__Clipper_ClipperBase.HORIZONTAL = -9007199254740992.
hxd_clipper__Clipper_ClipperBase.TOLERANCE = 1E-20
hxd_clipper__Clipper_ClipperBase.SKIP = -2
hxd_clipper__Clipper_ClipperBase.UNASSIGNED = -1
hxd_fmt_bfnt_Writer.VERSION = 1
hxd_fmt_fbx_BaseLibrary.maxBonesPerSkin = 34
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DFloat = 1
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DVec2 = 2
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DVec3 = 3
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DVec4 = 4
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DBytes4 = 9
hxd_fmt_hmd_Position.QTMP = h3d_Quat()
hxd_fmt_hmd_Data.CURRENT_VERSION = 3
hxd_fmt_hmd_Reader.BLEND = Type.allEnums(h2d_BlendMode)
hxd_fmt_hmd_Reader.CULLING = Type.allEnums(h3d_mat_Face)
hxd_fs_Convert.converts = haxe_ds_StringMap()
hxd_fs_ConvertFBX2HMD._ = hxd_fs_Convert.register(hxd_fs_ConvertFBX2HMD())
hxd_fs_ConvertWAV2MP3._ = hxd_fs_Convert.register(hxd_fs_ConvertWAV2MP3())
hxd_fs_ConvertWAV2OGG._ = hxd_fs_Convert.register(hxd_fs_ConvertWAV2OGG())
hxd_fs_ConvertTGA2PNG._ = hxd_fs_Convert.register(hxd_fs_ConvertTGA2PNG())
hxd_fs_ConvertFNT2BFNT._ = hxd_fs_Convert.register(hxd_fs_ConvertFNT2BFNT())
def _hx_init_hxd_fs_CompressIMG_TEXCONV_FMT():
    def _hx_local_0():
        _g = haxe_ds_StringMap()
        _g.h["R16F"] = "R16_FLOAT"
        _g.h["R32F"] = "R32_FLOAT"
        _g.h["RG16F"] = "R16G16_FLOAT"
        _g.h["RG32F"] = "R32G32_FLOAT"
        _g.h["RGB16F"] = "R16G16B16_FLOAT"
        _g.h["RGB32F"] = "R32G32B32_FLOAT"
        _g.h["RGBA16F"] = "R16G16B16A16_FLOAT"
        _g.h["RGBA32F"] = "R32G32B32A32_FLOAT"
        return _g
    return _hx_local_0()
hxd_fs_CompressIMG.TEXCONV_FMT = _hx_init_hxd_fs_CompressIMG_TEXCONV_FMT()
hxd_fs_CompressIMG._ = hxd_fs_Convert.register(hxd_fs_CompressIMG("png,tga,jpg,jpeg","dds"))
hxd_fs_DummyConvert._ = [hxd_fs_Convert.register(hxd_fs_DummyConvert(None,"dummy")), hxd_fs_Convert.register(hxd_fs_DummyConvert(None,"remove"))]
hxd_fs_FileConverter.extraConfigs = []
hxd_fs_LocalEntry.WATCH_INDEX = 0
hxd_fs_LocalEntry.WATCH_LIST = None
hxd_fs_LocalEntry.tmpDir = None
hxd_fs_LocalFileSystem.isWindows = (Sys.systemName() == "Windows")
hxd_fs_LocalFileSystem.FILES_CHECK_MAX = 5
hxd_impl__Allocator_BufferFlags_Impl_.Dynamic = 0
hxd_impl__Allocator_BufferFlags_Impl_.UniformDynamic = 1
hxd_impl__Allocator_BufferFlags_Impl_.RawFormat = 2
hxd_impl__Allocator_BufferFlags_Impl_.RawQuads = 3
hxd_res_Resource.LIVE_UPDATE = False
hxd_res__Image_ImageFormat_Impl_.Jpg = 0
hxd_res__Image_ImageFormat_Impl_.Png = 1
hxd_res__Image_ImageFormat_Impl_.Gif = 2
hxd_res__Image_ImageFormat_Impl_.Tga = 3
hxd_res__Image_ImageFormat_Impl_.Dds = 4
hxd_res__Image_ImageFormat_Impl_.Raw = 5
hxd_res__Image_ImageFormat_Impl_.Hdr = 6
hxd_res_Image.DEFAULT_FILTER = h3d_mat_Filter.Linear
hxd_res_Image.DEFAULT_ASYNC = False
hxd_res_Image.ENABLE_AUTO_WATCH = True
hxd_res_NanoJpeg.BLOCKSIZE = 64
hxd_res_NanoJpeg.W1 = 2841
hxd_res_NanoJpeg.W2 = 2676
hxd_res_NanoJpeg.W3 = 2408
hxd_res_NanoJpeg.W5 = 1609
hxd_res_NanoJpeg.W6 = 1108
hxd_res_NanoJpeg.W7 = 565
hxd_res_NanoJpeg.CF4A = -9
hxd_res_NanoJpeg.CF4B = 111
hxd_res_NanoJpeg.CF4C = 29
hxd_res_NanoJpeg.CF4D = -3
hxd_res_NanoJpeg.CF3A = 28
hxd_res_NanoJpeg.CF3B = 109
hxd_res_NanoJpeg.CF3C = -9
hxd_res_NanoJpeg.CF3X = 104
hxd_res_NanoJpeg.CF3Y = 27
hxd_res_NanoJpeg.CF3Z = -3
hxd_res_NanoJpeg.CF2A = 139
hxd_res_NanoJpeg.CF2B = -11
hxd_res_NanoJpeg.inst = None
hxd_res_Sound.ENABLE_AUTO_WATCH = True
hxd_snd_Channel.ID = 0
hxd_snd_Source.ID = 0
hxd_snd_Manager.STREAM_DURATION = 5.
hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT = 44100
hxd_snd_Manager.BUFFER_QUEUE_LENGTH = 2
hxd_snd_Manager.MAX_SOURCES = 16
hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE = 256
hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD = 1e-5
hxd_snd_Manager.BUFFER_STREAM_SPLIT = 16
hxd_snd_openal__Emulator_Channel.FADE_START = 10
hxd_snd_openal_Source.STOP_DELAY = 0
hxd_snd_openal_Source.CHANNEL_BUFSIZE = 4096
hxd_snd_openal_Source.ID = 0
hxd_snd_openal_Source.all = haxe_ds_IntMap()
hxd_snd_openal_Buffer.ID = 0
hxd_snd_openal_Buffer.all = haxe_ds_IntMap()
hxd_snd_openal_Emulator.FORMAT_MONOF32 = 4368
hxd_snd_openal_Emulator.FORMAT_STEREOF32 = 4369
hxd_snd_openal_Emulator.NONE = 0
hxd_snd_openal_Emulator.FALSE = 0
hxd_snd_openal_Emulator.TRUE = 1
hxd_snd_openal_Emulator.SOURCE_RELATIVE = 514
hxd_snd_openal_Emulator.CONE_INNER_ANGLE = 4097
hxd_snd_openal_Emulator.CONE_OUTER_ANGLE = 4098
hxd_snd_openal_Emulator.PITCH = 4099
hxd_snd_openal_Emulator.POSITION = 4100
hxd_snd_openal_Emulator.DIRECTION = 4101
hxd_snd_openal_Emulator.VELOCITY = 4102
hxd_snd_openal_Emulator.LOOPING = 4103
hxd_snd_openal_Emulator.BUFFER = 4105
hxd_snd_openal_Emulator.GAIN = 4106
hxd_snd_openal_Emulator.MIN_GAIN = 4109
hxd_snd_openal_Emulator.MAX_GAIN = 4110
hxd_snd_openal_Emulator.ORIENTATION = 4111
hxd_snd_openal_Emulator.SOURCE_STATE = 4112
hxd_snd_openal_Emulator.INITIAL = 4113
hxd_snd_openal_Emulator.PLAYING = 4114
hxd_snd_openal_Emulator.PAUSED = 4115
hxd_snd_openal_Emulator.STOPPED = 4116
hxd_snd_openal_Emulator.BUFFERS_QUEUED = 4117
hxd_snd_openal_Emulator.BUFFERS_PROCESSED = 4118
hxd_snd_openal_Emulator.REFERENCE_DISTANCE = 4128
hxd_snd_openal_Emulator.ROLLOFF_FACTOR = 4129
hxd_snd_openal_Emulator.CONE_OUTER_GAIN = 4130
hxd_snd_openal_Emulator.MAX_DISTANCE = 4131
hxd_snd_openal_Emulator.SEC_OFFSET = 4132
hxd_snd_openal_Emulator.SAMPLE_OFFSET = 4133
hxd_snd_openal_Emulator.BYTE_OFFSET = 4134
hxd_snd_openal_Emulator.SOURCE_TYPE = 4135
hxd_snd_openal_Emulator.STATIC = 4136
hxd_snd_openal_Emulator.STREAMING = 4137
hxd_snd_openal_Emulator.UNDETERMINED = 4144
hxd_snd_openal_Emulator.FORMAT_MONO8 = 4352
hxd_snd_openal_Emulator.FORMAT_MONO16 = 4353
hxd_snd_openal_Emulator.FORMAT_STEREO8 = 4354
hxd_snd_openal_Emulator.FORMAT_STEREO16 = 4355
hxd_snd_openal_Emulator.FREQUENCY = 8193
hxd_snd_openal_Emulator.BITS = 8194
hxd_snd_openal_Emulator.CHANNELS = 8195
hxd_snd_openal_Emulator.SIZE = 8196
hxd_snd_openal_Emulator.UNUSED = 8208
hxd_snd_openal_Emulator.PENDING = 8209
hxd_snd_openal_Emulator.PROCESSED = 8210
hxd_snd_openal_Emulator.NO_ERROR = 0
hxd_snd_openal_Emulator.INVALID_NAME = 40961
hxd_snd_openal_Emulator.INVALID_ENUM = 40962
hxd_snd_openal_Emulator.INVALID_VALUE = 40963
hxd_snd_openal_Emulator.INVALID_OPERATION = 40964
hxd_snd_openal_Emulator.OUT_OF_MEMORY = 40965
hxd_snd_openal_Emulator.VENDOR = 45057
hxd_snd_openal_Emulator.VERSION = 45058
hxd_snd_openal_Emulator.RENDERER = 45059
hxd_snd_openal_Emulator.EXTENSIONS = 45060
hxd_snd_openal_Emulator.DOPPLER_FACTOR = 49152
hxd_snd_openal_Emulator.DOPPLER_VELOCITY = 49153
hxd_snd_openal_Emulator.SPEED_OF_SOUND = 49155
hxd_snd_openal_Emulator.DISTANCE_MODEL = 53248
hxd_snd_openal_Emulator.INVERSE_DISTANCE = 53249
hxd_snd_openal_Emulator.INVERSE_DISTANCE_CLAMPED = 53250
hxd_snd_openal_Emulator.LINEAR_DISTANCE = 53251
hxd_snd_openal_Emulator.LINEAR_DISTANCE_CLAMPED = 53252
hxd_snd_openal_Emulator.EXPONENT_DISTANCE = 53253
hxd_snd_openal_Emulator.EXPONENT_DISTANCE_CLAMPED = 53254
hxd_snd_openal_ALC.ctx = None
hxd_snd_openal_ALC.FALSE = 0
hxd_snd_openal_ALC.TRUE = 1
hxd_snd_openal_ALC.FREQUENCY = 4103
hxd_snd_openal_ALC.REFRESH = 4104
hxd_snd_openal_ALC.SYNC = 4105
hxd_snd_openal_ALC.MONO_SOURCES = 4112
hxd_snd_openal_ALC.STEREO_SOURCES = 4113
hxd_snd_openal_ALC.NO_ERROR = 0
hxd_snd_openal_ALC.INVALID_DEVICE = 40961
hxd_snd_openal_ALC.INVALID_CONTEXT = 40962
hxd_snd_openal_ALC.INVALID_ENUM = 40963
hxd_snd_openal_ALC.INVALID_VALUE = 40964
hxd_snd_openal_ALC.OUT_OF_MEMORY = 40965
hxd_snd_openal_ALC.MAJOR_VERSION = 4096
hxd_snd_openal_ALC.MINOR_VERSION = 4097
hxd_snd_openal_ALC.ATTRIBUTES_SIZE = 4098
hxd_snd_openal_ALC.ALL_ATTRIBUTES = 4099
hxd_snd_openal_ALC.DEFAULT_DEVICE_SPECIFIER = 4100
hxd_snd_openal_ALC.DEVICE_SPECIFIER = 4101
hxd_snd_openal_ALC.EXTENSIONS = 4102
hxd_snd_openal_ALC.EXT_CAPTURE = 1
hxd_snd_openal_ALC.CAPTURE_DEVICE_SPECIFIER = 784
hxd_snd_openal_ALC.CAPTURE_DEFAULT_DEVICE_SPECIFIER = 785
hxd_snd_openal_ALC.CAPTURE_SAMPLES = 786
hxd_snd_openal_ALC.ENUMERATE_ALL_EXT = 1
hxd_snd_openal_ALC.DEFAULT_ALL_DEVICES_SPECIFIER = 4114
hxd_snd_openal_ALC.ALL_DEVICES_SPECIFIER = 4115
hxd_snd_openal_EFX.EFX_MAJOR_VERSION = 131073
hxd_snd_openal_EFX.EFX_MINOR_VERSION = 131074
hxd_snd_openal_EFX.MAX_AUXILIARY_SENDS = 131075
hxd_snd_openal_EFX.METERS_PER_UNIT = 131076
hxd_snd_openal_EFX.DIRECT_FILTER = 131077
hxd_snd_openal_EFX.FILTER_NULL = 0
hxsl_Tools.UID = 0
hxsl_Tools.SWIZ = Type.allEnums(hxsl_Component)
hxsl_Tools.MAX_CHANNELS_BITS = 3
hxsl_BatchShader.SRC = "HXSLEGh4c2wuQmF0Y2hTaGFkZXICAQtCYXRjaF9Db3VudAECAAEAAAABAAIMQmF0Y2hfQnVmZmVyEAUMAQIAAAA"
hxsl__Linker_ShaderInfos.UID = 0
hxsl_Printer.SWIZ = ["x", "y", "z", "w"]
hxsl_RuntimeShader.UID = 0
hxsl_Serializer.TVECS = haxe_ds_IntMap()
def _hx_init_hxsl_Serializer_BOPS():
    def _hx_local_0():
        ops = Type.allEnums(haxe_macro_Binop)
        pos = haxe_macro_Binop.OpAssignOp(None).index
        ops.insert(pos, None)
        return ops
    return _hx_local_0()
hxsl_Serializer.BOPS = _hx_init_hxsl_Serializer_BOPS()
hxsl_Serializer.UNOPS = Type.allEnums(haxe_macro_Unop)
hxsl_Serializer.TGLOBALS = Type.allEnums(hxsl_TGlobal)
hxsl_Serializer.TSWIZ = haxe_ds_IntMap()
hxsl_Serializer.REGS = [hxsl_Component.X, hxsl_Component.Y, hxsl_Component.Z, hxsl_Component.W]
hxsl_Serializer.VKINDS = Type.allEnums(hxsl_VarKind)
hxsl_Serializer.PRECS = Type.allEnums(hxsl_Prec)
hxsl_Serializer.FKIND = Type.allEnums(hxsl_FunctionKind)
hxsl_Serializer.SIGN = 9139229
hxsl_SharedShader.UNROLL_LOOPS = False
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")

Main.main()
sys_thread__Thread_Thread_Impl_.processEvents()
